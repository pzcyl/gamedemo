var cc = cc || {};
cc._tmp = cc._tmp || {}, cc._LogInfos = {}, window._p, _p = window, _p.gl, _p.WebGLRenderingContext, _p.DeviceOrientationEvent, _p.DeviceMotionEvent, _p.AudioContext, _p.webkitAudioContext, _p.mozAudioContext, _p = Object.prototype, _p._super, _p.ctor, delete window._p, cc.newElement = function(a) {
        return document.createElement(a)
    }, cc._addEventListener = function(a, b, c, d) {
        a.addEventListener(b, c, d)
    }, cc._isNodeJs = "undefined" != typeof require && require("fs"), cc.each = function(a, b, c) {
        if (a)
            if (a instanceof Array) {
                for (var d = 0, e = a.length; e > d; d++)
                    if (b.call(c, a[d], d) === !1) return
            } else
                for (var f in a)
                    if (b.call(c, a[f], f) === !1) return
    }, cc.extend = function(a) {
        var b = arguments.length >= 2 ? Array.prototype.slice.call(arguments, 1) : [];
        return cc.each(b, function(b) {
            for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c])
        }), a
    }, cc.isFunction = function(a) {
        return "function" == typeof a
    }, cc.isNumber = function(a) {
        return "number" == typeof a || "[object Number]" == Object.prototype.toString.call(a)
    }, cc.isString = function(a) {
        return "string" == typeof a || "[object String]" == Object.prototype.toString.call(a)
    }, cc.isArray = function(a) {
        return "[object Array]" == Object.prototype.toString.call(a)
    }, cc.isUndefined = function(a) {
        return "undefined" == typeof a
    }, cc.isObject = function(a) {
        var b = typeof a;
        return "function" == b || a && "object" == b
    }, cc.isCrossOrigin = function(a) {
        if (!a) return cc.log("invalid URL"), !1;
        var b = a.indexOf("://");
        if (-1 == b) return !1;
        var c = a.indexOf("/", b + 3),
            d = -1 == c ? a : a.substring(0, c);
        return d != location.origin
    }, cc.AsyncPool = function(a, b, c, d, e) {
        var f = this;
        f._srcObj = a, f._limit = b, f._pool = [], f._iterator = c, f._iteratorTarget = e, f._onEnd = d, f._onEndTarget = e, f._results = a instanceof Array ? [] : {}, f._isErr = !1, cc.each(a, function(a, b) {
            f._pool.push({
                index: b,
                value: a
            })
        }), f.size = f._pool.length, f.finishedSize = 0, f._workingSize = 0, f._limit = f._limit || f.size, f.onIterator = function(a, b) {
            f._iterator = a, f._iteratorTarget = b
        }, f.onEnd = function(a, b) {
            f._onEnd = a, f._onEndTarget = b
        }, f._handleItem = function() {
            var a = this;
            if (!(0 == a._pool.length || a._workingSize >= a._limit)) {
                var b = a._pool.shift(),
                    c = b.value,
                    d = b.index;
                a._workingSize++, a._iterator.call(a._iteratorTarget, c, d, function(b) {
                    if (!a._isErr) {
                        if (a.finishedSize++, a._workingSize--, b) return a._isErr = !0, void(a._onEnd && a._onEnd.call(a._onEndTarget, b));
                        var c = Array.prototype.slice.call(arguments, 1);
                        return a._results[this.index] = c[0], a.finishedSize == a.size ? void(a._onEnd && a._onEnd.call(a._onEndTarget, null, a._results)) : void a._handleItem()
                    }
                }.bind(b), a)
            }
        }, f.flow = function() {
            var a = this;
            if (0 == a._pool.length) return void(a._onEnd && a._onEnd.call(a._onEndTarget, null, []));
            for (var b = 0; b < a._limit; b++) a._handleItem()
        }
    }, cc.async = {
        series: function(a, b, c) {
            var d = new cc.AsyncPool(a, 1, function(a, b, d) {
                a.call(c, d)
            }, b, c);
            return d.flow(), d
        },
        parallel: function(a, b, c) {
            var d = new cc.AsyncPool(a, 0, function(a, b, d) {
                a.call(c, d)
            }, b, c);
            return d.flow(), d
        },
        waterfall: function(a, b, c) {
            var d = [],
                e = [null],
                f = new cc.AsyncPool(a, 1, function(b, f, g) {
                    d.push(function() {
                        d = Array.prototype.slice.call(arguments, 1), a.length - 1 == f && (e = e.concat(d)), g.apply(null, arguments)
                    }), b.apply(c, d)
                }, function(a) {
                    return b ? a ? b.call(c, a) : void b.apply(c, e) : void 0
                });
            return f.flow(), f
        },
        map: function(a, b, c, d) {
            var e = b;
            "object" == typeof b && (c = b.cb, d = b.iteratorTarget, e = b.iterator);
            var f = new cc.AsyncPool(a, 0, e, c, d);
            return f.flow(), f
        },
        mapLimit: function(a, b, c, d, e) {
            var f = new cc.AsyncPool(a, b, c, d, e);
            return f.flow(), f
        }
    }, cc.path = {
        join: function() {
            for (var a = arguments.length, b = "", c = 0; a > c; c++) b = (b + ("" == b ? "" : "/") + arguments[c]).replace(/(\/|\\\\)$/, "");
            return b
        },
        extname: function(a) {
            var b = /(\.[^\.\/\?\\]*)(\?.*)?$/.exec(a);
            return b ? b[1] : null
        },
        mainFileName: function(a) {
            if (a) {
                var b = a.lastIndexOf(".");
                if (-1 !== b) return a.substring(0, b)
            }
            return a
        },
        basename: function(a, b) {
            var c = a.indexOf("?");
            c > 0 && (a = a.substring(0, c));
            var d = /(\/|\\\\)([^(\/|\\\\)]+)$/g,
                e = d.exec(a.replace(/(\/|\\\\)$/, ""));
            if (!e) return null;
            var f = e[2];
            return b && a.substring(a.length - b.length).toLowerCase() == b.toLowerCase() ? f.substring(0, f.length - b.length) : f
        },
        dirname: function(a) {
            return a.replace(/((.*)(\/|\\|\\\\))?(.*?\..*$)?/, "$2")
        },
        changeExtname: function(a, b) {
            b = b || "";
            var c = a.indexOf("?"),
                d = "";
            return c > 0 && (d = a.substring(c), a = a.substring(0, c)), c = a.lastIndexOf("."), 0 > c ? a + b + d : a.substring(0, c) + b + d
        },
        changeBasename: function(a, b, c) {
            if (0 == b.indexOf(".")) return this.changeExtname(a, b);
            var d = a.indexOf("?"),
                e = "",
                f = c ? this.extname(a) : "";
            return d > 0 && (e = a.substring(d), a = a.substring(0, d)), d = a.lastIndexOf("/"), d = 0 >= d ? 0 : d + 1, a.substring(0, d) + b + f + e
        }
    }, cc.loader = {
        _jsCache: {},
        _register: {},
        _langPathCache: {},
        _aliases: {},
        resPath: "",
        audioPath: "",
        cache: {},
        getXMLHttpRequest: function() {
            return window.XMLHttpRequest ? new window.XMLHttpRequest : new ActiveXObject("MSXML2.XMLHTTP")
        },
        _getArgs4Js: function(a) {
            var b = a[0],
                c = a[1],
                d = a[2],
                e = ["", null, null];
            if (1 === a.length) e[1] = b instanceof Array ? b : [b];
            else if (2 === a.length) "function" == typeof c ? (e[1] = b instanceof Array ? b : [b], e[2] = c) : (e[0] = b || "", e[1] = c instanceof Array ? c : [c]);
            else {
                if (3 !== a.length) throw "arguments error to load js!";
                e[0] = b || "", e[1] = c instanceof Array ? c : [c], e[2] = d
            }
            return e
        },
        loadJs: function() {
            var a = this,
                b = a._jsCache,
                c = a._getArgs4Js(arguments),
                d = c[0],
                e = c[1],
                f = c[2];
            navigator.userAgent.indexOf("Trident/5") > -1 ? a._loadJs4Dependency(d, e, 0, f) : cc.async.map(e, function(c, e, f) {
                var g = cc.path.join(d, c);
                return b[g] ? f(null) : void a._createScript(g, !1, f)
            }, f)
        },
        loadJsWithImg: function() {
            var a = this,
                b = a._loadJsImg(),
                c = a._getArgs4Js(arguments);
            this.loadJs(c[0], c[1], function(a) {
                if (a) throw a;
                b.parentNode.removeChild(b), c[2] && c[2]()
            })
        },
        _createScript: function(a, b, c) {
            var d = document,
                e = this,
                f = cc.newElement("script");
            f.async = b, f.src = a, e._jsCache[a] = !0, cc._addEventListener(f, "load", function() {
                f.parentNode.removeChild(f), this.removeEventListener("load", arguments.callee, !1), c()
            }, !1), cc._addEventListener(f, "error", function() {
                f.parentNode.removeChild(f), c("Load " + a + " failed!")
            }, !1), d.body.appendChild(f)
        },
        _loadJs4Dependency: function(a, b, c, d) {
            if (c >= b.length) return void(d && d());
            var e = this;
            e._createScript(cc.path.join(a, b[c]), !1, function(f) {
                return f ? d(f) : void e._loadJs4Dependency(a, b, c + 1, d)
            })
        },
        _loadJsImg: function() {
            var a = document,
                b = a.getElementById("cocos2d_loadJsImg");
            if (!b) {
                b = cc.newElement("img"), cc._loadingImage && (b.src = cc._loadingImage);
                var c = a.getElementById(cc.game.config.id);
                c.style.backgroundColor = "black", c.parentNode.appendChild(b);
                var d = getComputedStyle ? getComputedStyle(c) : c.currentStyle;
                d || (d = {
                    width: c.width,
                    height: c.height
                }), b.style.left = c.offsetLeft + (parseFloat(d.width) - b.width) / 2 + "px", b.style.top = c.offsetTop + (parseFloat(d.height) - b.height) / 2 + "px", b.style.position = "absolute"
            }
            return b
        },
        loadTxt: function(a, b) {
            if (cc._isNodeJs) {
                var c = require("fs");
                c.readFile(a, function(a, c) {
                    a ? b(a) : b(null, c.toString())
                })
            } else {
                var d = this.getXMLHttpRequest(),
                    e = "load " + a + " failed!";
                d.open("GET", a, !0), /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? (d.setRequestHeader("Accept-Charset", "utf-8"), d.onreadystatechange = function() {
                    4 == d.readyState && (200 == d.status ? b(null, d.responseText) : b(e))
                }) : (d.overrideMimeType && d.overrideMimeType("text/plain; charset=utf-8"), d.onload = function() {
                    4 == d.readyState && (200 == d.status ? b(null, d.responseText) : b(e))
                }), d.send(null)
            }
        },
        _loadTxtSync: function(a) {
            if (cc._isNodeJs) {
                var b = require("fs");
                return b.readFileSync(a).toString()
            }
            var c = this.getXMLHttpRequest();
            return c.open("GET", a, !1), /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? c.setRequestHeader("Accept-Charset", "utf-8") : c.overrideMimeType && c.overrideMimeType("text/plain; charset=utf-8"), c.send(null), 4 == !c.readyState || 200 != c.status ? null : c.responseText
        },
        loadCsb: function(a, b) {
            var c = new XMLHttpRequest;
            c.open("GET", a, !0), c.responseType = "arraybuffer", c.onload = function() {
                var d = c.response;
                d && (window.msg = d), 4 == c.readyState && (200 == c.status ? b(null, c.response) : b("load " + a + " failed!"))
            }, c.send(null)
        },
        loadJson: function(a, b) {
            this.loadTxt(a, function(c, d) {
                if (c) b(c);
                else {
                    try {
                        var e = JSON.parse(d)
                    } catch (f) {
                        throw "parse json [" + a + "] failed : " + f
                    }
                    b(null, e)
                }
            })
        },
        _checkIsImageURL: function(a) {
            var b = /(\.png)|(\.jpg)|(\.bmp)|(\.jpeg)|(\.gif)/.exec(a);
            return null != b
        },
        loadImg: function(a, b, c) {
            var d = {
                isCrossOrigin: !0
            };
            void 0 !== c ? d.isCrossOrigin = null == b.isCrossOrigin ? d.isCrossOrigin : b.isCrossOrigin : void 0 !== b && (c = b);
            var e = this.getRes(a);
            if (e) return c && c(null, e), e;
            e = new Image, d.isCrossOrigin && "file://" != location.origin && (e.crossOrigin = "Anonymous");
            var f = function() {
                    this.removeEventListener("load", f, !1), this.removeEventListener("error", g, !1), cc.loader.cache[a] = e, c && c(null, e)
                },
                g = function() {
                    this.removeEventListener("error", g, !1), e.crossOrigin && "anonymous" == e.crossOrigin.toLowerCase() ? (d.isCrossOrigin = !1, cc.loader.loadImg(a, d, c)) : "function" == typeof c && c("load image failed")
                };
            return cc._addEventListener(e, "load", f), cc._addEventListener(e, "error", g), e.src = a, e
        },
        _loadResIterator: function(a, b, c) {
            var d = this,
                e = null,
                f = a.type;
            f ? (f = "." + f.toLowerCase(), e = a.src ? a.src : a.name + f) : (e = a, f = cc.path.extname(e));
            var g = d.getRes(e);
            if (g) return c(null, g);
            var h = null;
            if (f && (h = d._register[f.toLowerCase()]), !h) return cc.error("loader for [" + f + "] not exists!"), c();
            var i = h.getBasePath ? h.getBasePath() : d.resPath,
                j = d.getUrl(i, e);
            h.load(j, e, a, function(a, b) {
                a ? (cc.log(a), d.cache[e] = null, delete d.cache[e], c()) : (d.cache[e] = b, c(null, b))
            })
        },
        getUrl: function(a, b) {
            var c = this,
                d = c._langPathCache,
                e = cc.path;
            if (void 0 !== a && void 0 === b) {
                b = a;
                var f = e.extname(b);
                f = f ? f.toLowerCase() : "";
                var g = c._register[f];
                a = g && g.getBasePath ? g.getBasePath() : c.resPath
            }
            if (b = cc.path.join(a || "", b), b.match(/[\/(\\\\)]lang[\/(\\\\)]/i)) {
                if (d[b]) return d[b];
                var h = e.extname(b) || "";
                b = d[b] = b.substring(0, b.length - h.length) + "_" + cc.sys.language + h
            }
            return b
        },
        load: function(a, b, c) {
            var d = this,
                e = arguments.length;
            if (0 == e) throw "arguments error!";
            3 == e ? "function" == typeof b && (b = "function" == typeof c ? {
                trigger: b,
                cb: c
            } : {
                cb: b,
                cbTarget: c
            }) : 2 == e ? "function" == typeof b && (b = {
                cb: b
            }) : 1 == e && (b = {}), a instanceof Array || (a = [a]);
            var f = new cc.AsyncPool(a, 0, function(a, c, e, f) {
                d._loadResIterator(a, c, function(a) {
                    if (a) return e(a);
                    var c = Array.prototype.slice.call(arguments, 1);
                    b.trigger && b.trigger.call(b.triggerTarget, c[0], f.size, f.finishedSize), e(null, c[0])
                })
            }, b.cb, b.cbTarget);
            return f.flow(), f
        },
        _handleAliases: function(a, b) {
            var c = this,
                d = c._aliases,
                e = [];
            for (var f in a) {
                var g = a[f];
                d[f] = g, e.push(g)
            }
            this.load(e, b)
        },
        loadAliases: function(a, b) {
            var c = this,
                d = c.getRes(a);
            d ? c._handleAliases(d.filenames, b) : c.load(a, function(a, d) {
                c._handleAliases(d[0].filenames, b)
            })
        },
        register: function(a, b) {
            if (a && b) {
                var c = this;
                if ("string" == typeof a) return this._register[a.trim().toLowerCase()] = b;
                for (var d = 0, e = a.length; e > d; d++) c._register["." + a[d].trim().toLowerCase()] = b
            }
        },
        getRes: function(a) {
            return this.cache[a] || this.cache[this._aliases[a]]
        },
        release: function(a) {
            var b = this.cache,
                c = this._aliases;
            delete b[a], delete b[c[a]], delete c[a]
        },
        releaseAll: function() {
            var a = this.cache,
                b = this._aliases;
            for (var c in a) delete a[c];
            for (var c in b) delete b[c]
        }
    }, cc.formatStr = function() {
        var a = arguments,
            b = a.length;
        if (1 > b) return "";
        var c = a[0],
            d = !0;
        "object" == typeof c && (d = !1);
        for (var e = 1; b > e; ++e) {
            var f = a[e];
            if (d)
                for (;;) {
                    var g = null;
                    if ("number" == typeof f && (g = c.match(/(%d)|(%s)/))) {
                        c = c.replace(/(%d)|(%s)/, f);
                        break
                    }
                    g = c.match(/%s/), g ? c = c.replace(/%s/, f) : c += "    " + f;
                    break
                } else c += "    " + f
        }
        return c
    },
    function() {
        var a, b, c = window;
        cc.isUndefined(document.hidden) ? cc.isUndefined(document.mozHidden) ? cc.isUndefined(document.msHidden) ? cc.isUndefined(document.webkitHidden) || (a = "webkitHidden", b = "webkitvisibilitychange") : (a = "msHidden", b = "msvisibilitychange") : (a = "mozHidden", b = "mozvisibilitychange") : (a = "hidden", b = "visibilitychange");
        var d = function() {
                cc.eventManager && cc.game._eventHide && cc.eventManager.dispatchEvent(cc.game._eventHide)
            },
            e = function() {
                cc.eventManager && cc.game._eventShow && cc.eventManager.dispatchEvent(cc.game._eventShow), cc.game._intervalId && (window.cancelAnimationFrame(cc.game._intervalId), cc.game._runMainLoop())
            };
        a ? cc._addEventListener(document, b, function() {
            document[a] ? d() : e()
        }, !1) : (cc._addEventListener(c, "blur", d, !1), cc._addEventListener(c, "focus", e, !1)), navigator.userAgent.indexOf("MicroMessenger") > -1 && (c.onfocus = function() {
            e()
        }), "onpageshow" in window && "onpagehide" in window && (cc._addEventListener(c, "pagehide", d, !1), cc._addEventListener(c, "pageshow", e, !1)), c = null, b = null
    }(), cc.log = cc.warn = cc.error = cc.assert = function() {}, cc.create3DContext = function(a, b) {
        for (var c = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"], d = null, e = 0; e < c.length; ++e) {
            try {
                d = a.getContext(c[e], b)
            } catch (f) {}
            if (d) break
        }
        return d
    }, cc._initSys = function(a, b) {
        cc._RENDER_TYPE_CANVAS = 0, cc._RENDER_TYPE_WEBGL = 1, cc.sys = {};
        var c = cc.sys;
        c.LANGUAGE_ENGLISH = "en", c.LANGUAGE_CHINESE = "zh", c.LANGUAGE_FRENCH = "fr", c.LANGUAGE_ITALIAN = "it", c.LANGUAGE_GERMAN = "de", c.LANGUAGE_SPANISH = "es", c.LANGUAGE_DUTCH = "du", c.LANGUAGE_RUSSIAN = "ru", c.LANGUAGE_KOREAN = "ko", c.LANGUAGE_JAPANESE = "ja", c.LANGUAGE_HUNGARIAN = "hu", c.LANGUAGE_PORTUGUESE = "pt", c.LANGUAGE_ARABIC = "ar", c.LANGUAGE_NORWEGIAN = "no", c.LANGUAGE_POLISH = "pl", c.OS_WINDOWS = "Windows", c.OS_IOS = "iOS", c.OS_OSX = "OS X", c.OS_UNIX = "UNIX", c.OS_LINUX = "Linux", c.OS_ANDROID = "Android", c.OS_UNKNOWN = "Unknown", c.WINDOWS = 0, c.LINUX = 1, c.MACOS = 2, c.ANDROID = 3, c.IPHONE = 4, c.IPAD = 5, c.BLACKBERRY = 6, c.NACL = 7, c.EMSCRIPTEN = 8, c.TIZEN = 9, c.WINRT = 10, c.WP8 = 11, c.MOBILE_BROWSER = 100, c.DESKTOP_BROWSER = 101, c.BROWSER_TYPE_WECHAT = "wechat", c.BROWSER_TYPE_ANDROID = "androidbrowser", c.BROWSER_TYPE_IE = "ie", c.BROWSER_TYPE_QQ = "qqbrowser", c.BROWSER_TYPE_MOBILE_QQ = "mqqbrowser", c.BROWSER_TYPE_UC = "ucbrowser", c.BROWSER_TYPE_360 = "360browser", c.BROWSER_TYPE_BAIDU_APP = "baiduboxapp", c.BROWSER_TYPE_BAIDU = "baidubrowser", c.BROWSER_TYPE_MAXTHON = "maxthon", c.BROWSER_TYPE_OPERA = "opera", c.BROWSER_TYPE_OUPENG = "oupeng", c.BROWSER_TYPE_MIUI = "miuibrowser", c.BROWSER_TYPE_FIREFOX = "firefox", c.BROWSER_TYPE_SAFARI = "safari", c.BROWSER_TYPE_CHROME = "chrome", c.BROWSER_TYPE_LIEBAO = "liebao", c.BROWSER_TYPE_QZONE = "qzone", c.BROWSER_TYPE_SOUGOU = "sogou", c.BROWSER_TYPE_UNKNOWN = "unknown", c.isNative = !1;
        var d = [c.BROWSER_TYPE_BAIDU, c.BROWSER_TYPE_OPERA, c.BROWSER_TYPE_FIREFOX, c.BROWSER_TYPE_CHROME, c.BROWSER_TYPE_SAFARI],
            e = [c.OS_IOS, c.OS_WINDOWS, c.OS_OSX, c.OS_LINUX],
            f = [c.BROWSER_TYPE_BAIDU, c.BROWSER_TYPE_OPERA, c.BROWSER_TYPE_FIREFOX, c.BROWSER_TYPE_CHROME, c.BROWSER_TYPE_BAIDU_APP, c.BROWSER_TYPE_SAFARI, c.BROWSER_TYPE_UC, c.BROWSER_TYPE_QQ, c.BROWSER_TYPE_MOBILE_QQ, c.BROWSER_TYPE_IE],
            g = window,
            h = g.navigator,
            i = document,
            j = i.documentElement,
            k = h.userAgent.toLowerCase();
        c.isMobile = -1 != k.indexOf("mobile") || -1 != k.indexOf("android"), c.platform = c.isMobile ? c.MOBILE_BROWSER : c.DESKTOP_BROWSER;
        var l = h.language;
        l = l ? l : h.browserLanguage, l = l ? l.split("-")[0] : c.LANGUAGE_ENGLISH, c.language = l;
        var m = c.BROWSER_TYPE_UNKNOWN,
            n = k.match(/sogou|qzone|liebao|micromessenger|qqbrowser|ucbrowser|360 aphone|360browser|baiduboxapp|baidubrowser|maxthon|trident|oupeng|opera|miuibrowser|firefox/i) || k.match(/chrome|safari/i);
        n && n.length > 0 && (m = n[0], "micromessenger" == m ? m = c.BROWSER_TYPE_WECHAT : "safari" === m && k.match(/android.*applewebkit/) ? m = c.BROWSER_TYPE_ANDROID : "trident" == m ? m = c.BROWSER_TYPE_IE : "360 aphone" == m && (m = c.BROWSER_TYPE_360)), c.browserType = m;
        var o = k.match(/(iPad|iPhone|iPod)/i) ? !0 : !1,
            p = k.match(/android/i) || h.platform.match(/android/i) ? !0 : !1,
            q = c.OS_UNKNOWN; - 1 != h.appVersion.indexOf("Win") ? q = c.OS_WINDOWS : o ? q = c.OS_IOS : -1 != h.appVersion.indexOf("Mac") ? q = c.OS_OSX : -1 != h.appVersion.indexOf("X11") ? q = c.OS_UNIX : p ? q = c.OS_ANDROID : -1 != h.appVersion.indexOf("Linux") && (q = c.OS_LINUX), c.os = q, c._supportMultipleAudio = f.indexOf(c.browserType) > -1;
        var r = parseInt(a[b.renderMode]),
            s = cc._RENDER_TYPE_WEBGL,
            t = cc.newElement("Canvas");
        cc._supportRender = !0;
        var u = !window.WebGLRenderingContext || -1 == d.indexOf(c.browserType) || -1 == e.indexOf(c.os);
        if ((1 === r || 0 === r && u || "file://" == location.origin) && (s = cc._RENDER_TYPE_CANVAS), c._canUseCanvasNewBlendModes = function() {
            var a = document.createElement("canvas");
            a.width = 1, a.height = 1;
            var b = a.getContext("2d");
            b.fillStyle = "#000", b.fillRect(0, 0, 1, 1), b.globalCompositeOperation = "multiply";
            var c = document.createElement("canvas");
            c.width = 1, c.height = 1;
            var d = c.getContext("2d");
            return d.fillStyle = "#fff", d.fillRect(0, 0, 1, 1), b.drawImage(c, 0, 0, 1, 1), 0 === b.getImageData(0, 0, 1, 1).data[0]
        }, c._supportCanvasNewBlendModes = c._canUseCanvasNewBlendModes(), s == cc._RENDER_TYPE_WEBGL && (g.WebGLRenderingContext && cc.create3DContext(t, {
            stencil: !0,
            preserveDrawingBuffer: !0
        }) || (0 == r ? s = cc._RENDER_TYPE_CANVAS : cc._supportRender = !1)), s == cc._RENDER_TYPE_CANVAS) try {
            t.getContext("2d")
        } catch (v) {
            cc._supportRender = !1
        }
        cc._renderType = s;
        try {
            c._supportWebAudio = !!(g.AudioContext || g.webkitAudioContext || g.mozAudioContext)
        } catch (v) {
            c._supportWebAudio = !1
        }
        try {
            var w = c.localStorage = g.localStorage;
            w.setItem("storage", ""), w.removeItem("storage"), w = null
        } catch (v) {
            ("SECURITY_ERR" === v.name || "QuotaExceededError" === v.name) && cc.warn("Warning: localStorage isn't enabled. Please confirm browser cookie or privacy option"), c.localStorage = function() {}
        }
        var x = c.capabilities = {
            canvas: !0
        };
        cc._renderType == cc._RENDER_TYPE_WEBGL && (x.opengl = !0), (void 0 !== j.ontouchstart || void 0 !== i.ontouchstart || h.msPointerEnabled) && (x.touches = !0), void 0 !== j.onmouseup && (x.mouse = !0), void 0 !== j.onkeyup && (x.keyboard = !0), (g.DeviceMotionEvent || g.DeviceOrientationEvent) && (x.accelerometer = !0), c.garbageCollect = function() {}, c.dumpRoot = function() {}, c.restartVM = function() {}, c.cleanScript = function() {}, c.dump = function() {
            var a = this,
                b = "";
            b += "isMobile : " + a.isMobile + "\r\n", b += "language : " + a.language + "\r\n", b += "browserType : " + a.browserType + "\r\n", b += "capabilities : " + JSON.stringify(a.capabilities) + "\r\n", b += "os : " + a.os + "\r\n", b += "platform : " + a.platform + "\r\n", cc.log(b)
        }
    }, cc.ORIENTATION_PORTRAIT = 0, cc.ORIENTATION_PORTRAIT_UPSIDE_DOWN = 1, cc.ORIENTATION_LANDSCAPE_LEFT = 2, cc.ORIENTATION_LANDSCAPE_RIGHT = 3, cc._drawingUtil = null, cc._renderContext = null, cc._canvas = null, cc._gameDiv = null, cc._rendererInitialized = !1, cc._setupCalled = !1, cc._setup = function(a, b, c) {
        if (!cc._setupCalled) {
            cc._setupCalled = !0;
            var d, e, f, g = window,
                h = cc.$(a) || cc.$("#" + a);
            if (cc.game._setAnimFrame(), "CANVAS" == h.tagName ? (b = b || h.width, c = c || h.height, e = cc.container = cc.newElement("DIV"), d = cc._canvas = h, d.parentNode.insertBefore(e, d), d.appendTo(e), e.setAttribute("id", "Cocos2dGameContainer")) : ("DIV" != h.tagName && cc.log("Warning: target element is not a DIV or CANVAS"), b = b || h.clientWidth, c = c || h.clientHeight, e = cc.container = h, d = cc._canvas = cc.$(cc.newElement("CANVAS")), h.appendChild(d)), d.addClass("gameCanvas"), d.setAttribute("width", b || 480), d.setAttribute("height", c || 320), d.setAttribute("tabindex", 99), d.style.outline = "none", f = e.style, f.width = (b || 480) + "px", f.height = (c || 320) + "px", f.margin = "0 auto", f.position = "relative", f.overflow = "hidden", e.top = "100%", cc._renderType == cc._RENDER_TYPE_WEBGL && (cc._renderContext = cc.webglContext = cc.create3DContext(d, {
                stencil: !0,
                preserveDrawingBuffer: !0,
                antialias: !cc.sys.isMobile,
                alpha: !1
            })), cc._renderContext ? (g.gl = cc._renderContext, cc._drawingUtil = new cc.DrawingPrimitiveWebGL(cc._renderContext), cc._rendererInitialized = !0, cc.textureCache._initializingRenderer(), cc.shaderCache._init()) : (cc._renderContext = new cc.CanvasContextWrapper(d.getContext("2d")), cc._drawingUtil = cc.DrawingPrimitiveCanvas ? new cc.DrawingPrimitiveCanvas(cc._renderContext) : null), cc._gameDiv = e, cc.log(cc.ENGINE_VERSION), cc._setContextMenuEnable(!1), cc.sys.isMobile) {
                var i = cc.newElement("style");
                i.type = "text/css", document.body.appendChild(i), i.textContent = "body,canvas,div{ -moz-user-select: none;-webkit-user-select: none;-ms-user-select: none;-khtml-user-select: none;-webkit-tap-highlight-color:rgba(0,0,0,0);}"
            }
            cc.view = cc.EGLView._getInstance(), cc.inputManager.registerSystemEvent(cc._canvas), cc.director = cc.Director._getInstance(), cc.director.setOpenGLView && cc.director.setOpenGLView(cc.view), cc.winSize = cc.director.getWinSize(), cc.saxParser = new cc.SAXParser, cc.plistParser = new cc.PlistParser
        }
    }, cc._checkWebGLRenderMode = function() {
        if (cc._renderType !== cc._RENDER_TYPE_WEBGL) throw "This feature supports WebGL render mode only."
    }, cc._isContextMenuEnable = !1, cc._setContextMenuEnable = function(a) {
        cc._isContextMenuEnable = a, cc._canvas.oncontextmenu = function() {
            return cc._isContextMenuEnable ? void 0 : !1
        }
    }, cc.game = {
        DEBUG_MODE_NONE: 0,
        DEBUG_MODE_INFO: 1,
        DEBUG_MODE_WARN: 2,
        DEBUG_MODE_ERROR: 3,
        DEBUG_MODE_INFO_FOR_WEB_PAGE: 4,
        DEBUG_MODE_WARN_FOR_WEB_PAGE: 5,
        DEBUG_MODE_ERROR_FOR_WEB_PAGE: 6,
        EVENT_HIDE: "game_on_hide",
        EVENT_SHOW: "game_on_show",
        _eventHide: null,
        _eventShow: null,
        _onBeforeStartArr: [],
        CONFIG_KEY: {
            engineDir: "engineDir",
            dependencies: "dependencies",
            debugMode: "debugMode",
            showFPS: "showFPS",
            frameRate: "frameRate",
            id: "id",
            renderMode: "renderMode",
            jsList: "jsList",
            classReleaseMode: "classReleaseMode"
        },
        _prepareCalled: !1,
        _prepared: !1,
        _paused: !0,
        _intervalId: null,
        _lastTime: null,
        _frameTime: null,
        config: null,
        onStart: null,
        onStop: null,
        setFrameRate: function(a) {
            var b = this,
                c = b.config,
                d = b.CONFIG_KEY;
            c[d.frameRate] = a, b._intervalId && window.cancelAnimationFrame(b._intervalId), b._paused = !0, b._setAnimFrame(), b._runMainLoop()
        },
        _setAnimFrame: function() {
            this._lastTime = new Date, this._frameTime = 1e3 / cc.game.config[cc.game.CONFIG_KEY.frameRate], cc.sys.os === cc.sys.OS_IOS && cc.sys.browserType === cc.sys.BROWSER_TYPE_WECHAT || 60 != cc.game.config[cc.game.CONFIG_KEY.frameRate] ? (window.requestAnimFrame = this._stTime, window.cancelAnimationFrame = this._ctTime) : (window.requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || this._stTime, window.cancelAnimationFrame = window.cancelAnimationFrame || window.cancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.oCancelAnimationFrame || this._ctTime)
        },
        _stTime: function(a) {
            var b = (new Date).getTime(),
                c = Math.max(0, cc.game._frameTime - (b - cc.game._lastTime)),
                d = window.setTimeout(function() {
                    a()
                }, c);
            return cc.game._lastTime = b + c, d
        },
        _ctTime: function(a) {
            window.clearTimeout(a)
        },
        _runMainLoop: function() {
            var a, b = this,
                c = b.config,
                d = b.CONFIG_KEY,
                e = cc.director;
            e.setDisplayStats(c[d.showFPS]), a = function() {
                b._paused || (e.mainLoop(), b._intervalId && window.cancelAnimationFrame(b._intervalId), b._intervalId = window.requestAnimFrame(a))
            }, window.requestAnimFrame(a), b._paused = !1
        },
        restart: function() {
            cc.director.popToSceneStackLevel(0), cc.audioEngine && cc.audioEngine.end(), cc.game.onStart()
        },
        run: function(a) {
            var b = this,
                c = function() {
                    a && (b.config[b.CONFIG_KEY.id] = a), b._prepareCalled || b.prepare(function() {
                        b._prepared = !0
                    }), cc._supportRender && (b._checkPrepare = setInterval(function() {
                        b._prepared && (cc._setup(b.config[b.CONFIG_KEY.id]), b._runMainLoop(), b._eventHide = b._eventHide || new cc.EventCustom(b.EVENT_HIDE), b._eventHide.setUserData(b), b._eventShow = b._eventShow || new cc.EventCustom(b.EVENT_SHOW), b._eventShow.setUserData(b), b.onStart(), clearInterval(b._checkPrepare))
                    }, 10))
                };
            document.body ? c() : cc._addEventListener(window, "load", function() {
                this.removeEventListener("load", arguments.callee, !1), c()
            }, !1)
        },
        _initConfig: function() {
            var a = this,
                b = a.CONFIG_KEY,
                c = function(a) {
                    return a[b.engineDir] = a[b.engineDir] || "frameworks/cocos2d-html5", null == a[b.debugMode] && (a[b.debugMode] = 0), a[b.frameRate] = a[b.frameRate] || 60, null == a[b.renderMode] && (a[b.renderMode] = 1), a
                };
            if (document.ccConfig) a.config = c(document.ccConfig);
            else try {
                for (var d = document.getElementsByTagName("script"), e = 0; e < d.length; e++) {
                    var f = d[e].getAttribute("cocos");
                    if ("" == f || f) break
                }
                var g, h, i;
                e < d.length && (g = d[e].src, g && (i = /(.*)\//.exec(g)[0], cc.loader.resPath = i, g = cc.path.join(i, "project.json")), h = cc.loader._loadTxtSync(g)), h || (h = cc.loader._loadTxtSync("project.json"));
                var j = JSON.parse(h);
                a.config = c(j || {})
            } catch (k) {
                cc.log("Failed to read or parse project.json"), a.config = c({})
            }
            cc._initSys(a.config, b)
        },
        _jsAddedCache: {},
        _getJsListOfModule: function(a, b, c) {
            var d = this._jsAddedCache;
            if (d[b]) return null;
            c = c || "";
            var e = [],
                f = a[b];
            if (!f) throw "can not find module [" + b + "]";
            for (var g = cc.path, h = 0, i = f.length; i > h; h++) {
                var j = f[h];
                if (!d[j]) {
                    var k = g.extname(j);
                    if (k) ".js" == k.toLowerCase() && e.push(g.join(c, j));
                    else {
                        var l = this._getJsListOfModule(a, j, c);
                        l && (e = e.concat(l))
                    }
                    d[j] = 1
                }
            }
            return e
        },
        prepare: function(a) {
            var b = this,
                c = b.config,
                d = b.CONFIG_KEY,
                e = c[d.engineDir],
                f = cc.loader;
            if (!cc._supportRender) throw "The renderer doesn't support the renderMode " + c[d.renderMode];
            b._prepareCalled = !0;
            var g = c[d.jsList] || [];
            if (cc.Class) f.loadJsWithImg("", g, function(c) {
                if (c) throw c;
                b._prepared = !0, a && a()
            });
            else {
                var h = cc.path.join(e, "moduleConfig.json");
                f.loadJson(h, function(d, f) {
                    if (d) throw d;
                    var h = c.modules || [],
                        i = f.module,
                        j = [];
                    cc._renderType == cc._RENDER_TYPE_WEBGL ? h.splice(0, 0, "shaders") : h.indexOf("core") < 0 && h.splice(0, 0, "core");
                    for (var k = 0, l = h.length; l > k; k++) {
                        var m = b._getJsListOfModule(i, h[k], e);
                        m && (j = j.concat(m))
                    }
                    j = j.concat(g), cc.loader.loadJsWithImg(j, function(c) {
                        if (c) throw c;
                        b._prepared = !0, a && a()
                    })
                })
            }
        }
    }, cc.game._initConfig(), Function.prototype.bind = Function.prototype.bind || function(a) {
        if (!cc.isFunction(this)) throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
        var b = Array.prototype.slice.call(arguments, 1),
            c = this,
            d = function() {},
            e = function() {
                return c.apply(this instanceof d && a ? this : a, b.concat(Array.prototype.slice.call(arguments)))
            };
        return d.prototype = this.prototype, e.prototype = new d, e
    };
var cc = cc || {};
cc._loadingImage = "data:image/gif;base64,R0lGODlhEAAQALMNAD8/P7+/vyoqKlVVVX9/fxUVFUBAQGBgYMDAwC8vL5CQkP///wAAAP///wAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFAAANACwAAAAAEAAQAAAEO5DJSau9OOvNex0IMnDIsiCkiW6g6BmKYlBFkhSUEgQKlQCARG6nEBwOgl+QApMdCIRD7YZ5RjlGpCUCACH5BAUAAA0ALAAAAgAOAA4AAAQ6kLGB0JA4M7QW0hrngRllkYyhKAYqKUGguAws0ypLS8JxCLQDgXAIDg+FRKIA6v0SAECCBpXSkstMBAAh+QQFAAANACwAAAAACgAQAAAEOJDJORAac6K1kDSKYmydpASBUl0mqmRfaGTCcQgwcxDEke+9XO2WkxQSiUIuAQAkls0n7JgsWq8RACH5BAUAAA0ALAAAAAAOAA4AAAQ6kMlplDIzTxWC0oxwHALnDQgySAdBHNWFLAvCukc215JIZihVIZEogDIJACBxnCSXTcmwGK1ar1hrBAAh+QQFAAANACwAAAAAEAAKAAAEN5DJKc4RM+tDyNFTkSQF5xmKYmQJACTVpQSBwrpJNteZSGYoFWjIGCAQA2IGsVgglBOmEyoxIiMAIfkEBQAADQAsAgAAAA4ADgAABDmQSVZSKjPPBEDSGucJxyGA1XUQxAFma/tOpDlnhqIYN6MEAUXvF+zldrMBAjHoIRYLhBMqvSmZkggAIfkEBQAADQAsBgAAAAoAEAAABDeQyUmrnSWlYhMASfeFVbZdjHAcgnUQxOHCcqWylKEohqUEAYVkgEAMfkEJYrFA6HhKJsJCNFoiACH5BAUAAA0ALAIAAgAOAA4AAAQ3kMlJq704611SKloCAEk4lln3DQgyUMJxCBKyLAh1EMRR3wiDQmHY9SQslyIQUMRmlmVTIyRaIgA7", cc._fpsImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAAgCAYAAAD9qabkAAAKQ2lDQ1BJQ0MgcHJvZmlsZQAAeNqdU3dYk/cWPt/3ZQ9WQtjwsZdsgQAiI6wIyBBZohCSAGGEEBJAxYWIClYUFRGcSFXEgtUKSJ2I4qAouGdBiohai1VcOO4f3Ke1fXrv7e371/u855zn/M55zw+AERImkeaiagA5UoU8Otgfj09IxMm9gAIVSOAEIBDmy8JnBcUAAPADeXh+dLA//AGvbwACAHDVLiQSx+H/g7pQJlcAIJEA4CIS5wsBkFIAyC5UyBQAyBgAsFOzZAoAlAAAbHl8QiIAqg0A7PRJPgUA2KmT3BcA2KIcqQgAjQEAmShHJAJAuwBgVYFSLALAwgCgrEAiLgTArgGAWbYyRwKAvQUAdo5YkA9AYACAmUIszAAgOAIAQx4TzQMgTAOgMNK/4KlfcIW4SAEAwMuVzZdL0jMUuJXQGnfy8ODiIeLCbLFCYRcpEGYJ5CKcl5sjE0jnA0zODAAAGvnRwf44P5Dn5uTh5mbnbO/0xaL+a/BvIj4h8d/+vIwCBAAQTs/v2l/l5dYDcMcBsHW/a6lbANpWAGjf+V0z2wmgWgrQevmLeTj8QB6eoVDIPB0cCgsL7SViob0w44s+/zPhb+CLfvb8QB7+23rwAHGaQJmtwKOD/XFhbnauUo7nywRCMW735yP+x4V//Y4p0eI0sVwsFYrxWIm4UCJNx3m5UpFEIcmV4hLpfzLxH5b9CZN3DQCshk/ATrYHtctswH7uAQKLDljSdgBAfvMtjBoLkQAQZzQyefcAAJO/+Y9AKwEAzZek4wAAvOgYXKiUF0zGCAAARKCBKrBBBwzBFKzADpzBHbzAFwJhBkRADCTAPBBCBuSAHAqhGJZBGVTAOtgEtbADGqARmuEQtMExOA3n4BJcgetwFwZgGJ7CGLyGCQRByAgTYSE6iBFijtgizggXmY4EImFINJKApCDpiBRRIsXIcqQCqUJqkV1II/ItchQ5jVxA+pDbyCAyivyKvEcxlIGyUQPUAnVAuagfGorGoHPRdDQPXYCWomvRGrQePYC2oqfRS+h1dAB9io5jgNExDmaM2WFcjIdFYIlYGibHFmPlWDVWjzVjHVg3dhUbwJ5h7wgkAouAE+wIXoQQwmyCkJBHWExYQ6gl7CO0EroIVwmDhDHCJyKTqE+0JXoS+cR4YjqxkFhGrCbuIR4hniVeJw4TX5NIJA7JkuROCiElkDJJC0lrSNtILaRTpD7SEGmcTCbrkG3J3uQIsoCsIJeRt5APkE+S+8nD5LcUOsWI4kwJoiRSpJQSSjVlP+UEpZ8yQpmgqlHNqZ7UCKqIOp9aSW2gdlAvU4epEzR1miXNmxZDy6Qto9XQmmlnafdoL+l0ugndgx5Fl9CX0mvoB+nn6YP0dwwNhg2Dx0hiKBlrGXsZpxi3GS+ZTKYF05eZyFQw1zIbmWeYD5hvVVgq9ip8FZHKEpU6lVaVfpXnqlRVc1U/1XmqC1SrVQ+rXlZ9pkZVs1DjqQnUFqvVqR1Vu6k2rs5Sd1KPUM9RX6O+X/2C+mMNsoaFRqCGSKNUY7fGGY0hFsYyZfFYQtZyVgPrLGuYTWJbsvnsTHYF+xt2L3tMU0NzqmasZpFmneZxzQEOxrHg8DnZnErOIc4NznstAy0/LbHWaq1mrX6tN9p62r7aYu1y7Rbt69rvdXCdQJ0snfU6bTr3dQm6NrpRuoW623XP6j7TY+t56Qn1yvUO6d3RR/Vt9KP1F+rv1u/RHzcwNAg2kBlsMThj8MyQY+hrmGm40fCE4agRy2i6kcRoo9FJoye4Ju6HZ+M1eBc+ZqxvHGKsNN5l3Gs8YWJpMtukxKTF5L4pzZRrmma60bTTdMzMyCzcrNisyeyOOdWca55hvtm82/yNhaVFnMVKizaLx5balnzLBZZNlvesmFY+VnlW9VbXrEnWXOss623WV2xQG1ebDJs6m8u2qK2brcR2m23fFOIUjynSKfVTbtox7PzsCuya7AbtOfZh9iX2bfbPHcwcEh3WO3Q7fHJ0dcx2bHC866ThNMOpxKnD6VdnG2ehc53zNRemS5DLEpd2lxdTbaeKp26fesuV5RruutK10/Wjm7ub3K3ZbdTdzD3Ffav7TS6bG8ldwz3vQfTw91jicczjnaebp8LzkOcvXnZeWV77vR5Ps5wmntYwbcjbxFvgvct7YDo+PWX6zukDPsY+Ap96n4e+pr4i3z2+I37Wfpl+B/ye+zv6y/2P+L/hefIW8U4FYAHBAeUBvYEagbMDawMfBJkEpQc1BY0FuwYvDD4VQgwJDVkfcpNvwBfyG/ljM9xnLJrRFcoInRVaG/owzCZMHtYRjobPCN8Qfm+m+UzpzLYIiOBHbIi4H2kZmRf5fRQpKjKqLupRtFN0cXT3LNas5Fn7Z72O8Y+pjLk722q2cnZnrGpsUmxj7Ju4gLiquIF4h/hF8ZcSdBMkCe2J5MTYxD2J43MC52yaM5zkmlSWdGOu5dyiuRfm6c7Lnnc8WTVZkHw4hZgSl7I/5YMgQlAvGE/lp25NHRPyhJuFT0W+oo2iUbG3uEo8kuadVpX2ON07fUP6aIZPRnXGMwlPUit5kRmSuSPzTVZE1t6sz9lx2S05lJyUnKNSDWmWtCvXMLcot09mKyuTDeR55m3KG5OHyvfkI/lz89sVbIVM0aO0Uq5QDhZML6greFsYW3i4SL1IWtQz32b+6vkjC4IWfL2QsFC4sLPYuHhZ8eAiv0W7FiOLUxd3LjFdUrpkeGnw0n3LaMuylv1Q4lhSVfJqedzyjlKD0qWlQyuCVzSVqZTJy26u9Fq5YxVhlWRV72qX1VtWfyoXlV+scKyorviwRrjm4ldOX9V89Xlt2treSrfK7etI66Trbqz3Wb+vSr1qQdXQhvANrRvxjeUbX21K3nShemr1js20zcrNAzVhNe1bzLas2/KhNqP2ep1/XctW/a2rt77ZJtrWv913e/MOgx0VO97vlOy8tSt4V2u9RX31btLugt2PGmIbur/mft24R3dPxZ6Pe6V7B/ZF7+tqdG9s3K+/v7IJbVI2jR5IOnDlm4Bv2pvtmne1cFoqDsJB5cEn36Z8e+NQ6KHOw9zDzd+Zf7f1COtIeSvSOr91rC2jbaA9ob3v6IyjnR1eHUe+t/9+7zHjY3XHNY9XnqCdKD3x+eSCk+OnZKeenU4/PdSZ3Hn3TPyZa11RXb1nQ8+ePxd07ky3X/fJ897nj13wvHD0Ivdi2yW3S609rj1HfnD94UivW2/rZffL7Vc8rnT0Tes70e/Tf/pqwNVz1/jXLl2feb3vxuwbt24m3Ry4Jbr1+Hb27Rd3Cu5M3F16j3iv/L7a/eoH+g/qf7T+sWXAbeD4YMBgz8NZD+8OCYee/pT/04fh0kfMR9UjRiONj50fHxsNGr3yZM6T4aeypxPPyn5W/3nrc6vn3/3i+0vPWPzY8Av5i8+/rnmp83Lvq6mvOscjxx+8znk98ab8rc7bfe+477rfx70fmSj8QP5Q89H6Y8en0E/3Pud8/vwv94Tz+4A5JREAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfcAgcQLxxUBNp/AAAQZ0lEQVR42u2be3QVVZbGv1N17829eRLyIKAEOiISEtPhJTJAYuyBDmhWjAEx4iAGBhxA4wABbVAMWUAeykMCM+HRTcBRWkNH2l5moS0LCCrQTkYeQWBQSCAIgYRXEpKbW/XNH5zS4noR7faPEeu31l0h4dSpvc+t/Z199jkFWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhY/H9D/MR9qfKnLj/00U71aqfJn9+HCkCR/Wk36ddsgyJ/1wF4fkDfqqm9/gPsUeTnVr6a2xlQfnxdI7zs0W7irzD17Ytb2WT7EeNv/r4ox1O3Quf2QP2pgt9utwfout4FQE8AVBSlnaRmfvAURQkg2RlAbwB9AThlW5L0GaiKojhJhgOIBqDa7XaPrusdPtr5kQwF0BVAAoBIABRCKDd5aFUhRDAAw57eAOwAhKIoupft3zoqhB1AqLwuHIBut9uFt02qqvqRDJR2dAEQJj/BAOjn56dqmma+xiaECAEQAWAggLsB6A6HQ2iaZggBhBAqgEAAnQB0kzaEmT4hAITT6VQ8Ho/HJAKKECJQtr8LwD1y/A1/vcdfEUIEyfZ9AcQbYvZ942Px88L2UwlJR0dH0EMPPbRj5syZPUeNGrXR7Xb/641xIwJ1XY9NSUlZm52dfW+XLl1w8uRJzJ8//+OGhoYJqqqe1TSt1Wsm9NN1PSIqKmr12rVrR5WUlHy1bdu2AQCumWc3IYRD1/UwVVXnFRQUTIuNjUVzczN2797dWFJSkq8oymZd15sAGAEnFEUJ1nX9nzIzM1dnZmZGh4SE4OTJk5g5c+Zf29vbp9pstrMej6fVOyhIhgAYU1hY+B+hoaGoqKg4XVlZea+XTULTNFdCQsLGiRMnPuR2u3UhBOV9eeDAAWXTpk095DUe6WsoyRE5OTlr0tLSAux2O/bs2cO5c+e+pijKUpIXSHaQVAGkvPLKK++6XK4OksJLCFlXV2cvKSlJBFAjhU+x2WwhHo9nUHp6+urMzMy7wsLCUF9fjxdffPHjxsbGiTab7WuPx9NiEutOuq4PyMjI+M+srKyYqKgoHD58GDNmzNjq8XhyVFU9b/q+LH7hBAEYu3PnTlZVVRFAGgCX6f/tAHoOHDjwa0p27txp/JO9e/f+QM7cipw9nfL3kQBKt2zZQpJ87rnn6mQmoHilw2EACs+cOUOSrK+vZ1NTE0nyo48+IoBpxswoBcMJ4Ndjx471kOTFixe5d+9ekqTH42H//v13A4jyzpAURfEH0H/OnDnthu1z5sw558MmFUCPWbNmnaMP3nrrLZoyDmP8Hl68eDFJ8siRI9/Yc+zYMQKYKdtAztrTrl27xptRXV1NAKMAOAyBBBA/Y8aMdpLs6Ojgxx9//E37+++//29yvFXppwvAwMcee8xjtDHsuXLlCqOjo//ia3wsfpkoALqFhoZuIckJEyackimm3dQmEMDUmpoakmRISMhhAHOHDx/eQJIbN24kgKEyMAHAFRMTs2XXrl1saWkhSZ0kp0+ffhrAr3wEW/S8efOukORLL72kA1gKYMPWrVtJkk899dRJAHeYrgsEsIQkjx8/TgDvAPjd448/3kaSb7zxBmUa7vC6z53BwcFbSHL9+vU6Sc6aNes8gF5ewWAH0PfVV18lSQL4DMBGIcQ6AKtcLleBFC2jXtFt8ODBe0iyoqKCAJYByC8qKmJDQwOzsrK+MAmqo1OnTveHhoa+GRkZ+XZkZOSWiIiIvzgcjk9mzpypkWRmZuZpmbYbGV4AgPnNzc1sa2sjgN0A5iQmJtaSZHl5OQHcb/K3s81mW0uSTU1NBFAFYFbfvn1Pk+Tbb79NAA8IIVzW42/hByA+Pz/fLR/2ZXIda05NI/z9/TeR5J49ewhgqlxTrtI0jY2NjQQw3zTLuWJiYjaUlJToS5Ys6fjkk080kwDEeAmADcA9GzZsIElGRUW9CyAWwLApU6Y0kOSKFSsog9QICGdERMTGsrIyZmVlEcC9AB4IDw/fTpLbtm0jgN94CUAnAJmVlZVcs2aNZ/LkyRdJcvbs2b4EwAkgZfPmzTxw4AABFAN4BkC6vFeUSewcAO5duXIlSTIhIaEawGMAxgKYAmAGgCS73e5vrKVk/yGythANYEhCQsIhkly+fDkBpKqqGmL6DgIALDKN/3yZpVWQZGVlJQE8aPI3KiMjo5okV61aRQAjAPQBMPfIkSN0u90EUCBtsPiFEwpgbn19PdetW2fM5N4zQ9ekpKQqkty0aRMBpMjiWM6JEydIkoqirJUFJ6iq6pAPVy8A6cZMehMBUACEuVyuFwG8HBwcPEIWx367ZMkSjSQXLVrUJouTRorrkAHdA8BdQogsAOsKCwtJkmPGjDkvMw2bDDo/ADEjRoz4XylyFbm5uY0mAbjLyyZ/AOOrq6tZVlbWsWDBgo69e/eyoqKCgwcPPg4gSQaoIRbp27dvN7KF+tLSUr28vJwFBQXtMpvpYRIM7+wrAkDeqVOnePbsWQIoNKfzpiXPg8uXLydJJicnNwF4f+nSpW6STEtLq5fjYwhk1wkTJtSQ5Ouvv04AqTKj+N2xY8dIkgEBAW/Ie1v8wncRegwZMmQvSfbr12+3Ua33WqPfOWbMmP0kWVpaSgCDZAqcfejQIWNZsEGKgvnh9gfQb9myZd8nAEJVVZtMkUNk8CcNHTq0liR1XWdYWNhmH1mJIme80OnTp18x1rp5eXkEsNJms92Fb7e/IgEsvHz5Mp999tkmAI/l5uZeMC0B7vEqqAYAyL106RJJsra2lpWVld+sucePH38ZQG+5NncBeOrgwYMkqbe3t/Po0aOsra011wAWyl0H7x0JJ4DE+fPnu0kyPT29DsDdUrBuyNKEEAkAdpw/f/6GeoEM8GUmfwEgPCIiopwkGxsbabPZPgOw6L777vvm4p49e26VGYjFLxUhhD+ApLKyMp44ccIoVnXybgbgzkcfffRzklyzZg0BDJYCMMmoCwQFBXkLgLGWvvcWAgBToSsKwNPTp09vMR7UuLi4rwH0lgU8c/Db5ezbeeTIkRWzZ8++aMxu+fn5BPCADBwHgP4LFy701NXVEUAJgAnPP/98kyxMNgHo53A4zH77BQQETMvPz7+Um5vbBuAlAFMSExPPmdbVL0qh8Acw8fDhw5SCchVAEYAVb775JknyhRdeaJYztHfxMwLAaqNwCGC2FArv8x0hAHKNLGPKlCme5OTk/Zs3bzb7O0wKiiG8KXl5ed8IxenTp0mSR48e1UmyW7duWywBuD2xyQcgFECgoih+8H1gyJgZV5Lkyy+/3CbTRIePtl2HDBmyw1QBHyGDdXZdXR1JUghRKkXBjOMHCoBdpr0L3nvvPZLkF198wejo6O0A4lVVDTb74HQ6AwD8Wq7Jh8rgGgDgQ13XjVR8qaxJuADMbmlpYXl5uV5UVNRWUFDgfv/993Vj/ZydnU1c37eHXML4S3viAcQqitJD2l104cIFY8lTKsXSBWBMVVWVcd9yed2A1NTUQ6Zl00CvLMMOoHdubm6zFIlWOf5+PsY/Kj09vdrU11QAwwGsv3jxIk21m2DZr10I0RXAuAcffPBgaWkpV69eTYfDcdiwUxY0w6xw+flX8L1xApjevXv3lREREaW6rofB93aPDUDQpEmTMgHgtddeqwBwEd/utZvpqK6uPgEAcXFxkA94NwB9unfvjrNnz4LklwDcf08iIqv66Zs2bXrl4YcfxooVKxAbG7uqrq5uAYA2TdOEqqpGYIi2tjbl6aeffu/YsWPv5uTk7JaC1wHg4Pnz542MwoVvTx+21dbWYvjw4WLixIl+2dnZ9lGjRgmSTE1NRUpKCkwFTGiaxtTU1OXTpk3707Bhw/6g67pDipnT4biuj7qut+Lbk3Vf1tTUXI9qu91Pjq1QFEUBgJaWFgBo8yGOQ8eNGxcAAOvXr/8QwBUfYygAKL169eoCABcuXACAWtn2hOGv0+kMNO1KiPDw8F4A4rZv3/7R1KlTR0+bNu1ht9u9r1+/fqitrQXJgwDarRC6/QjPzs4+QJIffPCB9/aQmSAA43ft2mW0e1QGoi8CAPyLsZccExNTC2BlRkbGRdOyYJCP2csBIN6UAZzCd7cBbQCijYp/dXU1ExMTz6SmptaMHj36f9LS0vYlJCRsl6mxIWSdu3fv/g5J7t+/nwC2AShMTk6+SJKff/45AWRLYbD7+fndAeDf5BJnLoCCyZMnt5JkdnZ2C4B/F0KEm1Pu+Pj4rST55ZdfEsBWAK+mpaVdMo3raDn7KwDuSEpK+m+S3LBhAwG8DuCtHTt2UBbpjgC408vvcFVV15HkuXPnjMp+p5uMf0RcXNyHJNnQ0EBVVfcCWBQXF3fG+Jv0yxABPwB5LS0tRmFxN4BlTzzxxGWSXLx4sS5F3GGFy+1Hp5SUlJq6ujoWFxdTpsZ2H+0iIyMj/0iSWVlZX5mr5jfJFroPGzasxlhTnjp1iiTZ3NxMl8tlrCd9pfa9SkpKSJI5OTmnZOageLUZZqxvfVFWVkZcPwdgNwnSCKPqb17jkmR8fPzfZMDZ5CRsFBmNI7h95s2b1yhT7/MAYmStwCx4vy0uLqa3v5qmEcCfvSr1QQAeXb16NY3Cm3HQ55133iGAp+SxZTNhKSkpfzUddkrFjYevzAQCeGjp0qXfsYckY2NjTwD4leGDLCL2HTdunNtoY+zWSHFcIHdsFCtcfuZ1vO9Eqs3m7/F47sb1k2qX/f3997W2tl7BjWfpBYDOzzzzzIVJkyZh0KBBCwEsB3AJvl9AETabLcDj8dwRFRW1ctasWb8JCgpSzp07d62wsPC/Wltb8xRFadR1/ZqPXYbgAQMGbI2Pjw/+6quv9ldVVT0r01ezuPRJSUn5Y9euXXVd11WzDaqq6kePHm3+7LPPRgO4KlNuxWazhXo8nuTk5OSXMjIyEl0uFxoaGtqKior+dPXq1VdUVT0jj7r68ieoT58+vx8yZMjdx48fP1JVVTVF9m20VW02WyfZf97YsWPjXS4X6urqWvPy8jYCWCyEuEDS8FdVFKWzruv//OSTTy5OTk7uqWkaPv3007qysrJ8RVH+LI8ym8/rB3Tu3HnRI488knLo0KG2ffv2ZQI4C98vP6mqqoZqmpaclpa2cOTIkX39/f3R0NDQUVxc/G5TU9PLqqrWa5rWLH1QVFUN0TStX1JSUvH48eP7BwYG4uDBg1cKCgpeBbBe2u+2Qug2EwD5N5sMPuNtMe8XP4TT6Qxoa2sbIGeXvUKIK7d4IISiKC5d1wPljOfA9bPwzYqiXNV13dd6Uqiq6qdpml2mpe02m63d4/G4vcTF5fF47LJf71nJA6BZVVW3pmntuPHlmAD5wk6Q9NnbHp9vHaqq6tA0zU/64PZhk1FfCZB9G/23ALiqKEqzD39tpvbGUqoFwFUhRLP3yzpCCDtJpxyXDulfG27+pqRR3DXsUWVd4Yq0x/taVQjhIhksC8L+ABpM9ljBf5sKwI8pIBr75L5E4vvu+UNeG/a+hv+AL7yFH8qPtOfHjtOP6V/Bja8D6z/B2Nys/1u9Xv33tLf4GfF/LC4GCJwByWIAAAAASUVORK5CYII=", cc._loaderImage = "data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAAAlAAD/4QMpaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjAtYzA2MCA2MS4xMzQ3NzcsIDIwMTAvMDIvMTItMTc6MzI6MDAgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjM4MDBEMDY2QTU1MjExRTFBQTAzQjEzMUNFNzMxRkQwIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjM4MDBEMDY1QTU1MjExRTFBQTAzQjEzMUNFNzMxRkQwIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDUzUgV2luZG93cyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkU2RTk0OEM4OERCNDExRTE5NEUyRkE3M0M3QkE1NTlEIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkU2RTk0OEM5OERCNDExRTE5NEUyRkE3M0M3QkE1NTlEIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+/+4ADkFkb2JlAGTAAAAAAf/bAIQADQkJCQoJDQoKDRMMCwwTFhENDREWGhUVFhUVGhkUFhUVFhQZGR0fIB8dGScnKionJzk4ODg5QEBAQEBAQEBAQAEODAwOEA4RDw8RFA4RDhQVERISERUfFRUXFRUfKB0ZGRkZHSgjJiAgICYjLCwoKCwsNzc1NzdAQEBAQEBAQEBA/8AAEQgAyACgAwEiAAIRAQMRAf/EALAAAAEFAQEAAAAAAAAAAAAAAAQAAgMFBgcBAQEAAwEBAAAAAAAAAAAAAAAAAQMEAgUQAAIBAgIEBwoLBgQGAwAAAAECAwAEEQUhMRIGQVFxsTITFGGBwdEiQlKSMzWRoeFicqKyI1NzFYJjJDQWB9KjVCbxwkNkJWXik3QRAAIBAgMFBQcDBQEAAAAAAAABAhEDIRIEMUFRcTJhwVIUBZGhsSJyEzOB0ULhYpIjUxX/2gAMAwEAAhEDEQA/AMJSpUqAVKlXuFAeUq9wpUB5XuFe4V6ooDzZHDox0CnGMinzwl7Z8NajaHeoO3vmTBZBtp9YUIqTEV5ROxHKnWRnaU8VRMhFBUjpV7hSoSeUq9pUB5Sr2lhQHlKvcK8oBV7hSFSRrtaKAZs07YNPM1pG2xJIAw1jSeandry/8X4m8VCKkWwaWwam7Xl/4v1W8VLtmX/i/VbxUoKkWwakSM407tmX/i/VbxUmzGwjQsjdY41IARie/U0IbZO0kNtCXnOCkEBeFu4KI3Bs7DNb27ya+jDx3kJeEnpJJEcQVbWDsk17u5urd591ucZkWhym2Vnd9RkCDEpFxDRpbw0bunu5mlp2De2FMLYXOD2wB2xbOeraUcYGJ72mlSUiqzzdzMd3Z3mixltA2yzcK/NlHM1DQyRXce1HocdNOEfJXZ88y9ZojOqhiBszIRiHQ8Y4cK5TvHuzLljHNMqxNoDjLFraHHnjPxcNCGVbxEUzYNTx5jZSxhpW6qTzlwJ+DCvO2Zf+L9VvFSgqyHYNLYNTdssPxfibxUu15f8Ai/VPiqCakOwa82DU/a8v/F+JvFTDdWPBL8R8VKCvYRYV5UzoMAy6QdIIqI0B4KJtxiRQwou16QoGUkntH5Tz0RbZbmF2hktraSVBo2lUkY8tDye0flPPXTslVUyiyVRsjqUOA4yMT8dW2ram2m6UVTNq9S7EIyUVJydMTn/6DnP+im9Wl+g5z/opvVrpteEhQWY4AaSTwAVf5WPiZh/9S5/zj7zltzlmYWkfWXNvJDGTgGcYDHirR7i7mSbwXParsFMrgb7w6jKw/wCmnc9I14kF3vpvCljbMyWMOJL4aEiB8qU/ObUK7HYWVrl1pFZWiCOCBQqKOLjPGTrNZZqKbUXVHq2nNwTuJRk1VpbgXN8s7Rk5ym0UQQzhIG2NAjhxHWbI+gCBVjBBFbwxwQqEiiUJGg1BVGAFe7dV28WYLYZFmF2Th1UD7JGjymGyn1iK5OyzIBGB1HgrLZhamzumQAGJwSqnSCh1q3GOCodxt4cxurdcpzuN4cyhiWaF5Bg09udUmnWw1H/jV9nFuJ7Quo+8h8peThFA+047vduyMtk7fYqTl07YFdfUufMPzT5p71UdtlmYXaGS2t3mQHAsgxANdadYJopLe4QS2867EsZ4QfCNYrCFbjdDPmgkYyWFxgVf04ifJf6ScNdRUW1XBb6FU5TjF5EpSSrGu/s5lN+g5z/opvVpfoOc/wCim9WtdHnatvObJXDW7xLGhB8nrPaY9/HCr+tEdPCVaSeDoYLnqF63lzW4/PFSW3ecxbI84VSzWUwUaSdg0DXXK5nvAipnd6qgKvWnQO7pri9ZUEmm3Vl2j1kr8pRlFRyquBNZjGxQ/S56Y1S2fu9OVueon11Szahoou06QoQUXadIVCD2FJJ7R+U89dMydv8Axdn+TH9muZye0flPPXQstlK5Tbka1gUjlC1q0vVLkeb6r+O3Tx9xcY1nt8c0NrZCyiOE1108NYjGv1joo7Js1jzKyScYLIvkzL6LDwHXVJksH9Sb49dKNq0tj1jA6uriOCL+02FWX7iVtZX1/AzaHTyeoauKn2MX9W79zebiZCuR5MjSrhfXuEtwTrUeZH+yNfdrRNcxI6IzhXlJEak6WIGJ2Rw4ChWnChndtlVBLMdQA0k1gbXNMzzDfDLs6mjaPKppJbWwJ1bOwwxw43OnHh71YT3DpfWUJmFlb5jHHDdeXBHIsrRea5TSqvxqG04cNN62vetoCS4tre5mgnkGE9q+3DKOkuI2WX6LDQRRHWDh1UCtwj7QRg2wdl8Djgw1qe7XvW0BQ3kfZ7mSLgU+T9E6RVbnuVrnWVSWqj+Lt8ZbRuHEdKPkYVcZ2MJY5fSGyeVar45+rkWQHAqccalPE5km1htWK5nK4Wnt5FuUBUwOMG4nGkA/BXUrW4S6torlOjMgcd/xVn7rLo7zKs0uEjCNeSvdwoBhgsZxX1l2j36k3Lu+uyprdj5Vs5A+i/lD48a0aaVJOPi7jB6lbzWozpjB48pf1NDXNN4vfl7+Z4BXS65pvF78vfzPAK71XTHmZ/S/yT+jvJ7L3fHytz1E+upbL+Qj5W56jfXWRnsIYKLtekKEFGWvSFQgyjk9o/Keet3YthlMP/5x9msJJ7R+U89biyb/AMXEv7gD6tadL1T+kwepRrC39ZkLDMbiwMvUHRPG0bjlGg8ore/23sxBldxfMPLupNhT8yL/AORNZbdzJ484scytxgLqJY5LZj6Q2sV5G1Vud1mjjyG0ij0NEGSZToKyhjtqw4waztuiXA3qKTbSxltfGhbZlE95ZtZqxVbgiOZhrER9ph3Svk9+pJILZ4Y4DGBFCUMKjRsGPobPFhUfW0NJmljE2xJcIrcI2vFUEln1lRXd6lrazXT9GCNpD+yNqoI7mOVduNw6nzlOIoPOUa6yye1XXcbMR5GdQ3xY0BSbj31/FcTQZirJ+q431q7anbHCTZ72Bw7lbPrKBMcBWNNgbMBBh+bsjBdni0VJ1lARZs6yWiupxCuMDy6KpS2IwOo6DTr3Mre3e5tZZVUM4ZBjqOOJoWO4jkXajcOOMHGgDISvWIrdAkKR80+TzVl908bPPL3LzxOuHdifxVfiTAg92qI/w+/8gGgSyN/mR7XPVlp0lF/3L3mbVKtu5Hjbk/8AHE2Fc03i9+Xv5ngFdKNc13i9+Xv5ngFaNV0x5nn+l/kn9HeEWXu+PlbnqJ9dS2Xu9OVueon11kZ7CGCjLXpCgxRlr0hUIPYUcntH5Tz1s8vb+Bt1/dqPirGSe0flPPWusG/g4Py15q06XqlyMWvVYQ+ruI9xJOqzO9hOto/sP8tbGOFIrmWeM7IuMDMnAXXQJOUjQeOsJk0nY96ip0CYunrjaHx1t+srPJUbXBm2LrFPikwTOb+T+VhbZxGMrDXp83x1QSy2tucJpUjPETp+Cn5/ftaRvKvtp3Kx48HG3erHMzOxZiWZtLMdJNQSbbL71Vk6yynViOkqnEEfOWtPbXi3EQkGg6mXiNckjeSJxJGxR10qw0GtxuxmvbImD4CZMFlA4fRfv0BqesqqzTMZNMEDbIHtHH2QeCiZJSqMQdOGiue53mz3czQwsRbIcNHnkec3c4qAMuriz68gTIToxwOOnlp0MjxMJYW741Gs3RVldtbygE/dMcHX/moDaxTiWNZB53B3arb8/wC+4SOF4sf/AKxU9kcBsfOGHfoUHtG/RbzY5Die5HHhXdvavqiZ9Q8Jdlq4/gbKua7xe/L38zwCuhpf2Uk/Zo50kmwJKIdogDjw1VzzeL35e/meAVp1LTgqY4nn+mRauzqmqwrjzCLL3fHytz1E+upLL+Qj5W56jfXWRnroYKLtekKEFF2vSFQg9hSSe0flPPWosm/hIfoLzVl5PaPynnrRWb/w0X0F5q06XqlyM2sVYx5gmbFre/t71NY2T+0h8VbSO5SWNJUOKSAMp7jDGspmMPaLRlXS6eWve1/FRO7WYdbZm1Y/eW/R7qHxHRXGojlm3ulid6aVbaW+OALvgCLq2Hm9WxHKWqjhj6xsK1e8dm15l4niG1LZkswGsxtrPeOmsvayBJA1VItlWjptLuTdPMo7LtjRDq9naK4+WF9IrUW7BaHOljGqVHB7w2hzVoZt87d8vaNYSLl02CcRsDEbJbj71Uu7UBkvJ7/D7q2QoDxySaAO8MTXdxRVMpRp5XZOWdF/ms7R5XdyKfKWJsO/5PhrG5XlNxmEywW6bTnTxAAcJNbGSMXkM1pjgbiNo1PziPJ+Os7u7m/6ReM00ZOgxSpqYYHT3wRXMKN4ll9zUG4bQfNshu8sZVuEA2hirA4qe/VOwwrVbzbww5mI44UKRRYkbWG0S3JWctbd7u5WFfOOLHiUdJqmaipfLsIsObhWe001lMkMVvJNjhghIALMcBxCs7fxXQmkupx1bXDswGPlaTidVaEyKNXkoo4eBV+Sq7L7Vs9zcBgeyQ4GQ/MB1crmoim2orezqcowTuSeEY48jQ7oZX2PLzdyLhNd6RjrEY6I7+uspvH78vfzPAK6UAAAFGAGgAcArmu8Xvy9/M8ArTfio24RW5nnaG67uou3H/KPuqT2X8hHytz1G+upLL3enK3PUb66ys9RDBRdr0hQgou06QqEGUkntH5Tz1e238vF9BeaqKT2j8p56vbb+Xi+gvNWjTdUuRn1XTHmTh8KrJTJlt8t1CPIY44cGnpJVjTJYkmjaN9Ib4u7V923njTethRauZJV3PaW1rfLIiXEDYg6R4VYc9CXW7thfOZbKdbGZtLW8uPVY/u3GrkNUkM9zlcxUjbhfWOA90cRq4gv4LhdqN+VToNYWmnRm9NNVWNTyHc6VWBv8wt4YeHqm6xyPmroq1Z7WGFLSxTq7WLSuPSdjrkfumq5yHXDUeA92oO2SKpVumNAaoJLMXH3myp0rpJ4uKhc3tbDM5BMri1zAj79j7KTiY8TcdBpcsith0286o+sPCagEX9Pzg4zXUCp6QYse8oouCG3tk6m1BYv05W6T+IdyolxbHDAAa2OgDlNCz3ryN2WxBd5PJMg1t81eId2ukqnLlTBbfcuY+9uJLiRcvtPvHdsHK+cfRHcHDWsyawjyy0WBcDI3lTP6TeIcFV+S5OmXx9bJg1048o8Cj0V8Jq2DVu09nL80up7OxHi+oal3P8AXB/IsZS8T/YOV65zvCcc7vfzPAK3ivWCz445zeH954BXOr6I8yfSfyz+jvCLP3fHytz1G+upLP3fHytz1E+usbPaQ0UXadIUIKLtekKhB7Ckk9o/Keer22/l4/oLzVRSe0flPPV7b/y8X0F5q0abqlyM+q6Y8yQsBTDMor1o8aiaE1pbluMqS3sbLLHIhSRQyngqukhaJ9uBjo+H5aOa3ao2t34qouRlLajTalGP8v0IY8ylXQ+PKPFU/bYXOLPge6CKia0LaxTOxHu1Q7cuBd9yPEJ7TbjXKO8CajbMIF6CNIeNvJHjqIWJ7tSpYkalqVblwIdyG+RGXur0hXYJFxal+Dhq5y3slkv3Y2pD0pTr+QUClpJRUdo9XW4OLrTHtM16cZLLWkeC7y4jvlNEpcRtw1Ux27Ci448NZrTFy3nn3IQWxlgGrDZ3pza7/M8ArZo+ArF5171uvp+CqdV0R5l/psUrs2vB3hdl7vTlbnqJ9dS2Xu+PlbnqJ9dY2eshooq16QoQUXa9IVCD2FLJ7RuU89WNtmUSQqkgYMgw0accKrpPaPynnrZWG4Vi+VWmY5tnMWXG+XrIYnA0rhj0mdcTgdNdwnKDqjmduM1SRR/qlr8/4KX6pa8T/BVzDuLZXudRZblmbxXcPUNPc3KqCIwrbOzgrHEnHjoyD+3eSXkht7DeKG4umDGOJVUklfouThXfmbnZ7Cvy1vt9pmv1W1+d8FL9VteJvgq5yrcOGfLmzHN80iyyETPbptAEFo2ZG8pmUa1OFNn3Ky6W/sbDKM5hv5bx2WTZA+7RF2y52WOPJTzE+z2Dy1vt9pT/AKpacTerS/U7Tib1a04/t7kDXPY03jhN0W6sQ7K7W3q2dnrMccaDy/8At80kuZfqWYxWNtlcvUPPhiGYhWDeUy7IwYU8xPs9g8tb7faUn6pacTerTxm9oOBvVq3v9z927aynuId44LiWKNnjhAXF2UYhRg516qpsryjLr21665zFLSTaK9U2GOA87SwqY37knRU+BzOzags0s1Oyr+BKM6sxwP6tSDPLMen6vy0rvdm3Sxlu7K/S7WDDrFUDUTxgnTU826eXW7KlxmqQuwDBXUKcD+1Xee/wXuKX5XDGWLapSVcOyhEM/seJ/V+WnjeGx4pPV+Wkm6kKZlFay3Jlt7iFpYZY8ASVK6DjtDDA0f8A0Tl340/1f8Ndx8xJVWXB0KbktFFpNzdVXAC/qOwA0CQni2flrO3Vwbm5lnI2TKxbDirX/wBE5d+NcfV/wVR7xZPa5U9utvI8nWhmbbw0YEAYYAVxfhfy5rlKR4Fulu6X7mW1mzT8S4Yis/5CPlbnqJ9dSWfu9OVueon11mZvQ2i7XpChKKtekKhBlNJ7R+U89bDfGTb3a3ZX0Lcj6kdY+T2j8p560288m1kWQr6MJ+ylSAr+2cnV5renjs3H1loX+3j9XvbbtxLN9lqW4UnV5jdnjtXHxihtyZNjeSBu5J9k1BJe7xy7W5CJ/wCzuD/mTVTf2+fq97LJuLrPsNRueS7W6aJ/38x+vLVXuY+xvHaNxbf2GoCezf8A36j/APsSf8w1sLnqczTefJluYoLm5uo5F61sBshItP1cNFYe1f8A3ir/APfE/wCZUe9bB94r5jwuPsrQFhmG4l/Z2M17HdW90tuu3IkTHaCjWdIw0VVZdks9/C06yJFEp2dp+E1bbqybGTZ8vpQD7L1XRv8A7blT96Oda7tpNuuNE37Cq9KSisjyuUoxrStKllHbLlWTXsMs8chuSuwEPDqwoLe5y+YRE/gLzmqRekvKKtd4327yM/ulHxmrHJStySWVRyrjxKI2XC/CTlnlPPKTpTdFbP0L1bgrf5Lp0G3dPhQHwV0S1lzBsns3sESR8Crh9WAJGjSOKuU3E+zdZQ3oJh8IArdZXFDmOTpHa3i2+YrI2KtKy4ricBsBuHHgFXSo440+Wa2qqxjvM9uMoy+WvzWpLCWWWE28HxL6e43ojgkeSCBY1Ri5BGIUDT51cl3vm276BBqSEH4WbxV0tlkyXJcxTMb+OW6uY9mGHrCzDQwwAbTp2uKuTZ9N1uYsfRRR8WPhrm419mSSjRyiqxVK7y23B/ftuTm2oSdJyzNVw3BFn7vTlbnqF9dS2fu9OVueon11lZuQ2iLdsGFD05H2dNQGV0ntG5Tz1dWm9N1b2kVq8EVwsI2UaQaQOKhmitZGLOmk68DhSFvY+gfWNSAg7z3Qvo7yKCKIohiaNR5LKxx8qpxvjcqS0VpbxvwOAcRQPZ7D0G9Y0uz2HoH1jUCpLY7zXlpbm3eKO5QuzjrBqZji3x17PvNcyT288VvDBJbMWUovS2hslW7mFQ9nsPQPrGl2ew9A+saCod/WNxtbYsrfb17WBxx5ddD2281xC88klvDcSXEnWuzrqOGGC9zRUPZ7D0G9Y0uzWHoH1jQVCLreq6ntZbaO3it1mGy7RjTs1X2mYy20ZiCq8ZOODcdEdmsPQb1jS7PYegfWNdJuLqnQiSUlRqpFLmryxtH1Ma7Qw2gNNPOdSt0oI27p007s9h6B9Y0uz2HoH1jXX3Z+I4+1b8IJdX89xLHKQFMXQUahpxoiPN5P+onfU+A0/s9h6DesaXZ7D0D6xpG7OLbUtu0StW5JJx2bBsmbtiSiEk+cxoCWWSaVpZOk2vDVo0VYdnsPQb1jSNvZcCH1jSd2c+p1XAmFqEOmOPEfaH+BQd1ueo211IzrgFUYKNAAqI1WztCpUqVCRUqVKgFSpUqAVKlSoBUqVKgFSpUqAVKlSoBUqVKgFSpUqAVKlSoD/9k=", cc.loader.loadBinary = function(a, b) {
    var c = this,
        d = this.getXMLHttpRequest(),
        e = "load " + a + " failed!";
    d.open("GET", a, !0), /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? (d.setRequestHeader("Accept-Charset", "x-user-defined"), d.onreadystatechange = function() {
        if (4 == d.readyState && 200 == d.status) {
            var a = cc._convertResponseBodyToText(d.responseBody);
            b(null, c._str2Uint8Array(a))
        } else b(e)
    }) : (d.overrideMimeType && d.overrideMimeType("text/plain; charset=x-user-defined"), d.onload = function() {
        4 == d.readyState && 200 == d.status ? b(null, c._str2Uint8Array(d.responseText)) : b(e)
    }), d.send(null)
}, cc.loader._str2Uint8Array = function(a) {
    if (!a) return null;
    for (var b = new Uint8Array(a.length), c = 0; c < a.length; c++) b[c] = 255 & a.charCodeAt(c);
    return b
}, cc.loader.loadBinarySync = function(a) {
    var b = this,
        c = this.getXMLHttpRequest(),
        d = "load " + a + " failed!";
    c.open("GET", a, !1);
    var e = null;
    if (/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
        if (c.setRequestHeader("Accept-Charset", "x-user-defined"), c.send(null), 200 != c.status) return cc.log(d), null;
        var f = cc._convertResponseBodyToText(c.responseBody);
        f && (e = b._str2Uint8Array(f))
    } else {
        if (c.overrideMimeType && c.overrideMimeType("text/plain; charset=x-user-defined"), c.send(null), 200 != c.status) return cc.log(d), null;
        e = this._str2Uint8Array(c.responseText)
    }
    return e
};
var Uint8Array = Uint8Array || Array;
if (/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
    var IEBinaryToArray_ByteStr_Script = '<!-- IEBinaryToArray_ByteStr -->\r\nFunction IEBinaryToArray_ByteStr(Binary)\r\n   IEBinaryToArray_ByteStr = CStr(Binary)\r\nEnd Function\r\nFunction IEBinaryToArray_ByteStr_Last(Binary)\r\n   Dim lastIndex\r\n   lastIndex = LenB(Binary)\r\n   if lastIndex mod 2 Then\r\n       IEBinaryToArray_ByteStr_Last = Chr( AscB( MidB( Binary, lastIndex, 1 ) ) )\r\n   Else\r\n       IEBinaryToArray_ByteStr_Last = ""\r\n   End If\r\nEnd Function\r\n',
        myVBScript = cc.newElement("script");
    myVBScript.type = "text/vbscript", myVBScript.textContent = IEBinaryToArray_ByteStr_Script, document.body.appendChild(myVBScript), cc._convertResponseBodyToText = function(a) {
        for (var b = {}, c = 0; 256 > c; c++)
            for (var d = 0; 256 > d; d++) b[String.fromCharCode(c + 256 * d)] = String.fromCharCode(c) + String.fromCharCode(d);
        var e = IEBinaryToArray_ByteStr(a),
            f = IEBinaryToArray_ByteStr_Last(a);
        return e.replace(/[\s\S]/g, function(a) {
            return b[a]
        }) + f
    }
}
var cc = cc || {},
    ClassManager = {
        id: 0 | 998 * Math.random(),
        instanceId: 0 | 998 * Math.random(),
        compileSuper: function(a, b, c) {
            var d = a.toString(),
                e = d.indexOf("("),
                f = d.indexOf(")"),
                g = d.substring(e + 1, f);
            g = g.trim();
            for (var h = d.indexOf("{"), i = d.lastIndexOf("}"), d = d.substring(h + 1, i); - 1 != d.indexOf("this._super");) {
                var j = d.indexOf("this._super"),
                    k = d.indexOf("(", j),
                    l = d.indexOf(")", k),
                    m = d.substring(k + 1, l);
                m = m.trim();
                var n = m ? "," : "";
                d = d.substring(0, j) + "ClassManager[" + c + "]." + b + ".call(this" + n + d.substring(k + 1)
            }
            return Function(g, d)
        },
        getNewID: function() {
            return this.id++
        },
        getNewInstanceId: function() {
            return this.instanceId++
        }
    };
switch (ClassManager.compileSuper.ClassManager = ClassManager, function() {
    var a = /\b_super\b/,
        b = cc.game.config,
        c = b[cc.game.CONFIG_KEY.classReleaseMode];
    c && console.log("release Mode"), cc.Class = function() {}, cc.Class.extend = function() {
        function b() {
            this.__instanceId = ClassManager.getNewInstanceId(), this.ctor && this.ctor.apply(this, arguments)
        }
        var d = this.prototype,
            e = Object.create(d),
            f = ClassManager.getNewID();
        ClassManager[f] = d;
        var g = {
            writable: !0,
            enumerable: !1,
            configurable: !0
        };
        e.__instanceId = null, b.id = f, g.value = f, Object.defineProperty(e, "__pid", g), b.prototype = e, g.value = b, Object.defineProperty(b.prototype, "constructor", g), this.__getters__ && (b.__getters__ = cc.clone(this.__getters__)), this.__setters__ && (b.__setters__ = cc.clone(this.__setters__));
        for (var h = 0, i = arguments.length; i > h; ++h) {
            var j = arguments[h];
            for (var k in j) {
                var l = "function" == typeof j[k],
                    m = "function" == typeof d[k],
                    n = a.test(j[k]);
                if (c && l && m && n ? (g.value = ClassManager.compileSuper(j[k], k, f), Object.defineProperty(e, k, g)) : l && m && n ? (g.value = function(a, b) {
                    return function() {
                        var c = this._super;
                        this._super = d[a];
                        var e = b.apply(this, arguments);
                        return this._super = c, e
                    }
                }(k, j[k]), Object.defineProperty(e, k, g)) : l ? (g.value = j[k], Object.defineProperty(e, k, g)) : e[k] = j[k], l) {
                    var o, p, q;
                    if (this.__getters__ && this.__getters__[k]) {
                        q = this.__getters__[k];
                        for (var r in this.__setters__)
                            if (this.__setters__[r] == q) {
                                p = r;
                                break
                            }
                        cc.defineGetterSetter(e, q, j[k], j[p] ? j[p] : e[p], k, p)
                    }
                    if (this.__setters__ && this.__setters__[k]) {
                        q = this.__setters__[k];
                        for (var r in this.__getters__)
                            if (this.__getters__[r] == q) {
                                o = r;
                                break
                            }
                        cc.defineGetterSetter(e, q, j[o] ? j[o] : e[o], j[k], o, k)
                    }
                }
            }
        }
        return b.extend = cc.Class.extend, b.implement = function(a) {
            for (var b in a) e[b] = a[b]
        }, b
    }
}(), cc.defineGetterSetter = function(a, b, c, d, e, f) {
    if (a.__defineGetter__) c && a.__defineGetter__(b, c), d && a.__defineSetter__(b, d);
    else {
        if (!Object.defineProperty) throw new Error("browser does not support getters");
        var g = {
            enumerable: !1,
            configurable: !0
        };
        c && (g.get = c), d && (g.set = d), Object.defineProperty(a, b, g)
    } if (!e && !f)
        for (var h = null != c, i = void 0 != d, j = Object.getOwnPropertyNames(a), k = 0; k < j.length; k++) {
            var l = j[k];
            if ((a.__lookupGetter__ ? !a.__lookupGetter__(l) : !Object.getOwnPropertyDescriptor(a, l)) && "function" == typeof a[l]) {
                var m = a[l];
                if (h && m === c && (e = l, !i || f)) break;
                if (i && m === d && (f = l, !h || e)) break
            }
        }
    var n = a.constructor;
    e && (n.__getters__ || (n.__getters__ = {}), n.__getters__[e] = b), f && (n.__setters__ || (n.__setters__ = {}), n.__setters__[f] = b)
}, cc.clone = function(a) {
    var b = a.constructor ? new a.constructor : {};
    for (var c in a) {
        var d = a[c];
        b[c] = "object" != typeof d || !d || d instanceof cc.Node || d instanceof HTMLElement ? d : cc.clone(d)
    }
    return b
}, cc.inject = function(a, b) {
    for (var c in a) b[c] = a[c]
}, cc.Point = function(a, b) {
    this.x = a || 0, this.y = b || 0
}, cc.p = function(a, b) {
    return void 0 == a ? {
        x: 0,
        y: 0
    } : void 0 == b ? {
        x: a.x,
        y: a.y
    } : {
        x: a,
        y: b
    }
}, cc.pointEqualToPoint = function(a, b) {
    return a && b && a.x === b.x && a.y === b.y
}, cc.Size = function(a, b) {
    this.width = a || 0, this.height = b || 0
}, cc.size = function(a, b) {
    return void 0 === a ? {
        width: 0,
        height: 0
    } : void 0 === b ? {
        width: a.width,
        height: a.height
    } : {
        width: a,
        height: b
    }
}, cc.sizeEqualToSize = function(a, b) {
    return a && b && a.width == b.width && a.height == b.height
}, cc.Rect = function(a, b, c, d) {
    this.x = a || 0, this.y = b || 0, this.width = c || 0, this.height = d || 0
}, cc.rect = function(a, b, c, d) {
    return void 0 === a ? {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    } : void 0 === b ? {
        x: a.x,
        y: a.y,
        width: a.width,
        height: a.height
    } : {
        x: a,
        y: b,
        width: c,
        height: d
    }
}, cc.rectEqualToRect = function(a, b) {
    return a && b && a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height
}, cc._rectEqualToZero = function(a) {
    return a && 0 === a.x && 0 === a.y && 0 === a.width && 0 === a.height
}, cc.rectContainsRect = function(a, b) {
    return a && b ? !(a.x >= b.x || a.y >= b.y || a.x + a.width <= b.x + b.width || a.y + a.height <= b.y + b.height) : !1
}, cc.rectGetMaxX = function(a) {
    return a.x + a.width
}, cc.rectGetMidX = function(a) {
    return a.x + a.width / 2
}, cc.rectGetMinX = function(a) {
    return a.x
}, cc.rectGetMaxY = function(a) {
    return a.y + a.height
}, cc.rectGetMidY = function(a) {
    return a.y + a.height / 2
}, cc.rectGetMinY = function(a) {
    return a.y
}, cc.rectContainsPoint = function(a, b) {
    return b.x >= cc.rectGetMinX(a) && b.x <= cc.rectGetMaxX(a) && b.y >= cc.rectGetMinY(a) && b.y <= cc.rectGetMaxY(a)
}, cc.rectIntersectsRect = function(a, b) {
    var c = a.x + a.width,
        d = a.y + a.height,
        e = b.x + b.width,
        f = b.y + b.height;
    return !(c < b.x || e < a.x || d < b.y || f < a.y)
}, cc.rectOverlapsRect = function(a, b) {
    return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y)
}, cc.rectUnion = function(a, b) {
    var c = cc.rect(0, 0, 0, 0);
    return c.x = Math.min(a.x, b.x), c.y = Math.min(a.y, b.y), c.width = Math.max(a.x + a.width, b.x + b.width) - c.x, c.height = Math.max(a.y + a.height, b.y + b.height) - c.y, c
}, cc.rectIntersection = function(a, b) {
    var c = cc.rect(Math.max(cc.rectGetMinX(a), cc.rectGetMinX(b)), Math.max(cc.rectGetMinY(a), cc.rectGetMinY(b)), 0, 0);
    return c.width = Math.min(cc.rectGetMaxX(a), cc.rectGetMaxX(b)) - cc.rectGetMinX(c), c.height = Math.min(cc.rectGetMaxY(a), cc.rectGetMaxY(b)) - cc.rectGetMinY(c), c
}, cc.SAXParser = cc.Class.extend({
    _parser: null,
    _isSupportDOMParser: null,
    ctor: function() {
        window.DOMParser ? (this._isSupportDOMParser = !0, this._parser = new DOMParser) : this._isSupportDOMParser = !1
    },
    parse: function(a) {
        return this._parseXML(a)
    },
    _parseXML: function(a) {
        var b;
        return this._isSupportDOMParser ? b = this._parser.parseFromString(a, "text/xml") : (b = new ActiveXObject("Microsoft.XMLDOM"), b.async = "false", b.loadXML(a)), b
    }
}), cc.PlistParser = cc.SAXParser.extend({
    parse: function(a) {
        var b = this._parseXML(a),
            c = b.documentElement;
        if ("plist" != c.tagName) throw "Not a plist file!";
        for (var d = null, e = 0, f = c.childNodes.length; f > e && (d = c.childNodes[e], 1 != d.nodeType); e++);
        return b = null, this._parseNode(d)
    },
    _parseNode: function(a) {
        var b = null,
            c = a.tagName;
        if ("dict" == c) b = this._parseDict(a);
        else if ("array" == c) b = this._parseArray(a);
        else if ("string" == c)
            if (1 == a.childNodes.length) b = a.firstChild.nodeValue;
            else {
                b = "";
                for (var d = 0; d < a.childNodes.length; d++) b += a.childNodes[d].nodeValue
            } else "false" == c ? b = !1 : "true" == c ? b = !0 : "real" == c ? b = parseFloat(a.firstChild.nodeValue) : "integer" == c && (b = parseInt(a.firstChild.nodeValue, 10));
        return b
    },
    _parseArray: function(a) {
        for (var b = [], c = 0, d = a.childNodes.length; d > c; c++) {
            var e = a.childNodes[c];
            1 == e.nodeType && b.push(this._parseNode(e))
        }
        return b
    },
    _parseDict: function(a) {
        for (var b = {}, c = null, d = 0, e = a.childNodes.length; e > d; d++) {
            var f = a.childNodes[d];
            1 == f.nodeType && ("key" == f.tagName ? c = f.firstChild.nodeValue : b[c] = this._parseNode(f))
        }
        return b
    }
}), cc._txtLoader = {
    load: function(a, b, c, d) {
        cc.loader.loadTxt(a, d)
    }
}, cc.loader.register(["txt", "xml", "vsh", "fsh", "atlas"], cc._txtLoader), cc._jsonLoader = {
    load: function(a, b, c, d) {
        cc.loader.loadJson(a, d)
    }
}, cc.loader.register(["json", "ExportJson"], cc._jsonLoader), cc._imgLoader = {
    load: function(a, b, c, d) {
        cc.loader.cache[b] = cc.loader.loadImg(a, function(a, c) {
            return a ? d(a) : (cc.textureCache.handleLoadedTexture(b), void d(null, c))
        })
    }
}, cc.loader.register(["png", "jpg", "bmp", "jpeg", "gif", "ico"], cc._imgLoader), cc._serverImgLoader = {
    load: function(a, b, c, d) {
        cc.loader.cache[b] = cc.loader.loadImg(c.src, function(a, c) {
            return a ? d(a) : (cc.textureCache.handleLoadedTexture(b), void d(null, c))
        })
    }
}, cc.loader.register(["serverImg"], cc._serverImgLoader), cc._plistLoader = {
    load: function(a, b, c, d) {
        cc.loader.loadTxt(a, function(a, b) {
            return a ? d(a) : void d(null, cc.plistParser.parse(b))
        })
    }
}, cc.loader.register(["plist"], cc._plistLoader), cc._fontLoader = {
    TYPE: {
        ".eot": "embedded-opentype",
        ".ttf": "truetype",
        ".woff": "woff",
        ".svg": "svg"
    },
    _loadFont: function(a, b, c) {
        var d = document,
            e = cc.path,
            f = this.TYPE,
            g = cc.newElement("style");
        g.type = "text/css", d.body.appendChild(g);
        var h = "@font-face { font-family:" + a + "; src:";
        if (b instanceof Array)
            for (var i = 0, j = b.length; j > i; i++) {
                var k = b[i];
                c = e.extname(k).toLowerCase(), h += "url('" + b[i] + "') format('" + f[c] + "')", h += i == j - 1 ? ";" : ","
            } else h += "url('" + b + "') format('" + f[c] + "');";
        g.textContent += h + "};";
        var l = cc.newElement("div"),
            m = l.style;
        m.fontFamily = a, l.innerHTML = ".", m.position = "absolute", m.left = "-100px", m.top = "-100px", d.body.appendChild(l)
    },
    load: function(a, b, c, d) {
        var e = this,
            f = c.type,
            g = c.name,
            h = c.srcs;
        cc.isString(c) ? (f = cc.path.extname(c), g = cc.path.basename(c, f), e._loadFont(g, c, f)) : e._loadFont(g, h), d(null, !0)
    }
}, cc.loader.register(["font", "eot", "ttf", "woff", "svg"], cc._fontLoader), cc._binaryLoader = {
    load: function(a, b, c, d) {
        cc.loader.loadBinary(a, d)
    }
}, cc._csbLoader = {
    load: function(a, b, c, d) {
        cc.loader.loadCsb(a, d)
    }
}, cc.loader.register(["csb"], cc._csbLoader), window.CocosEngine = cc.ENGINE_VERSION = "Cocos2d-JS v3.2", cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL = 0, cc.DIRECTOR_STATS_POSITION = cc.p(0, 0), cc.DIRECTOR_FPS_INTERVAL = .5, cc.COCOSNODE_RENDER_SUBPIXEL = 1, cc.SPRITEBATCHNODE_RENDER_SUBPIXEL = 1, cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA = 0, cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP = 0, cc.TEXTURE_ATLAS_USE_VAO = 0, cc.TEXTURE_NPOT_SUPPORT = 0, cc.RETINA_DISPLAY_SUPPORT = 1, cc.RETINA_DISPLAY_FILENAME_SUFFIX = "-hd", cc.USE_LA88_LABELS = 1, cc.SPRITE_DEBUG_DRAW = 0, cc.SPRITEBATCHNODE_DEBUG_DRAW = 0, cc.LABELBMFONT_DEBUG_DRAW = 0, cc.LABELATLAS_DEBUG_DRAW = 0, cc.IS_RETINA_DISPLAY_SUPPORTED = 1, cc.DEFAULT_ENGINE = cc.ENGINE_VERSION + "-canvas", cc.ENABLE_STACKABLE_ACTIONS = 1, cc.ENABLE_GL_STATE_CACHE = 1, cc.$ = function(a) {
    var b = this == cc ? document : this,
        c = a instanceof HTMLElement ? a : b.querySelector(a);
    return c && (c.find = c.find || cc.$, c.hasClass = c.hasClass || function(a) {
        return this.className.match(new RegExp("(\\s|^)" + a + "(\\s|$)"))
    }, c.addClass = c.addClass || function(a) {
        return this.hasClass(a) || (this.className && (this.className += " "), this.className += a), this
    }, c.removeClass = c.removeClass || function(a) {
        return this.hasClass(a) && (this.className = this.className.replace(a, "")), this
    }, c.remove = c.remove || function() {
        return this.parentNode && this.parentNode.removeChild(this), this
    }, c.appendTo = c.appendTo || function(a) {
        return a.appendChild(this), this
    }, c.prependTo = c.prependTo || function(a) {
        return a.childNodes[0] ? a.insertBefore(this, a.childNodes[0]) : a.appendChild(this), this
    }, c.transforms = c.transforms || function() {
        return this.style[cc.$.trans] = cc.$.translate(this.position) + cc.$.rotate(this.rotation) + cc.$.scale(this.scale) + cc.$.skew(this.skew), this
    }, c.position = c.position || {
        x: 0,
        y: 0
    }, c.rotation = c.rotation || 0, c.scale = c.scale || {
        x: 1,
        y: 1
    }, c.skew = c.skew || {
        x: 0,
        y: 0
    }, c.translates = function(a, b) {
        return this.position.x = a, this.position.y = b, this.transforms(), this
    }, c.rotate = function(a) {
        return this.rotation = a, this.transforms(), this
    }, c.resize = function(a, b) {
        return this.scale.x = a, this.scale.y = b, this.transforms(), this
    }, c.setSkew = function(a, b) {
        return this.skew.x = a, this.skew.y = b, this.transforms(), this
    }), c
}, cc.sys.browserType) {
    case cc.sys.BROWSER_TYPE_FIREFOX:
        cc.$.pfx = "Moz", cc.$.hd = !0;
        break;
    case cc.sys.BROWSER_TYPE_CHROME:
    case cc.sys.BROWSER_TYPE_SAFARI:
        cc.$.pfx = "webkit", cc.$.hd = !0;
        break;
    case cc.sys.BROWSER_TYPE_OPERA:
        cc.$.pfx = "O", cc.$.hd = !1;
        break;
    case cc.sys.BROWSER_TYPE_IE:
        cc.$.pfx = "ms", cc.$.hd = !1;
        break;
    default:
        cc.$.pfx = "webkit", cc.$.hd = !0
}
cc.$.trans = cc.$.pfx + "Transform", cc.$.translate = cc.$.hd ? function(a) {
    return "translate3d(" + a.x + "px, " + a.y + "px, 0) "
} : function(a) {
    return "translate(" + a.x + "px, " + a.y + "px) "
}, cc.$.rotate = cc.$.hd ? function(a) {
    return "rotateZ(" + a + "deg) "
} : function(a) {
    return "rotate(" + a + "deg) "
}, cc.$.scale = function(a) {
    return "scale(" + a.x + ", " + a.y + ") "
}, cc.$.skew = function(a) {
    return "skewX(" + -a.x + "deg) skewY(" + a.y + "deg)"
}, cc.$new = function(a) {
    return cc.$(document.createElement(a))
}, cc.$.findpos = function(a) {
    var b = 0,
        c = 0;
    do b += a.offsetLeft, c += a.offsetTop; while (a = a.offsetParent);
    return {
        x: b,
        y: c
    }
}, cc.INVALID_INDEX = -1, cc.PI = Math.PI, cc.FLT_MAX = parseFloat("3.402823466e+38F"), cc.FLT_MIN = parseFloat("1.175494351e-38F"), cc.RAD = cc.PI / 180, cc.DEG = 180 / cc.PI, cc.UINT_MAX = 4294967295, cc.swap = function(a, b, c) {
    if (!cc.isObject(c) || cc.isUndefined(c.x) || cc.isUndefined(c.y)) cc.log(cc._LogInfos.swap);
    else {
        var d = c[a];
        c[a] = c[b], c[b] = d
    }
}, cc.lerp = function(a, b, c) {
    return a + (b - a) * c
}, cc.rand = function() {
    return 16777215 * Math.random()
}, cc.randomMinus1To1 = function() {
    return 2 * (Math.random() - .5)
}, cc.random0To1 = Math.random, cc.degreesToRadians = function(a) {
    return a * cc.RAD
}, cc.radiansToDegrees = function(a) {
    return a * cc.DEG
}, cc.radiansToDegress = function(a) {
    return cc.log(cc._LogInfos.radiansToDegress), a * cc.DEG
}, cc.REPEAT_FOREVER = Number.MAX_VALUE - 1, cc.BLEND_SRC = cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA ? 1 : 770, cc.BLEND_DST = 771, cc.nodeDrawSetup = function(a) {
    a._shaderProgram && (a._shaderProgram.use(), a._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4())
}, cc.enableDefaultGLStates = function() {}, cc.disableDefaultGLStates = function() {}, cc.incrementGLDraws = function(a) {
    cc.g_NumberOfDraws += a
}, cc.FLT_EPSILON = 1.192092896e-7, cc.contentScaleFactor = cc.IS_RETINA_DISPLAY_SUPPORTED ? function() {
    return cc.director.getContentScaleFactor()
} : function() {
    return 1
}, cc.pointPointsToPixels = function(a) {
    var b = cc.contentScaleFactor();
    return cc.p(a.x * b, a.y * b)
}, cc.pointPixelsToPoints = function(a) {
    var b = cc.contentScaleFactor();
    return cc.p(a.x / b, a.y / b)
}, cc._pointPixelsToPointsOut = function(a, b) {
    var c = cc.contentScaleFactor();
    b.x = a.x / c, b.y = a.y / c
}, cc.sizePointsToPixels = function(a) {
    var b = cc.contentScaleFactor();
    return cc.size(a.width * b, a.height * b)
}, cc.sizePixelsToPoints = function(a) {
    var b = cc.contentScaleFactor();
    return cc.size(a.width / b, a.height / b)
}, cc._sizePixelsToPointsOut = function(a, b) {
    var c = cc.contentScaleFactor();
    b.width = a.width / c, b.height = a.height / c
}, cc.rectPixelsToPoints = cc.IS_RETINA_DISPLAY_SUPPORTED ? function(a) {
    var b = cc.contentScaleFactor();
    return cc.rect(a.x / b, a.y / b, a.width / b, a.height / b)
} : function(a) {
    return a
}, cc.rectPointsToPixels = cc.IS_RETINA_DISPLAY_SUPPORTED ? function(a) {
    var b = cc.contentScaleFactor();
    return cc.rect(a.x * b, a.y * b, a.width * b, a.height * b)
} : function(a) {
    return a
}, cc.ONE = 1, cc.ZERO = 0, cc.SRC_ALPHA = 770, cc.SRC_ALPHA_SATURATE = 776, cc.SRC_COLOR = 768, cc.DST_ALPHA = 772, cc.DST_COLOR = 774, cc.ONE_MINUS_SRC_ALPHA = 771, cc.ONE_MINUS_SRC_COLOR = 769, cc.ONE_MINUS_DST_ALPHA = 773, cc.ONE_MINUS_DST_COLOR = 775, cc.ONE_MINUS_CONSTANT_ALPHA = 32772, cc.ONE_MINUS_CONSTANT_COLOR = 32770, cc.LINEAR = 9729, cc.REPEAT = 10497, cc.CLAMP_TO_EDGE = 33071, cc.MIRRORED_REPEAT = 33648, cc.checkGLErrorDebug = function() {
    if (cc.renderMode == cc._RENDER_TYPE_WEBGL) {
        var a = cc._renderContext.getError();
        a && cc.log(cc._LogInfos.checkGLErrorDebug, a)
    }
}, cc.DEVICE_ORIENTATION_PORTRAIT = 0, cc.DEVICE_ORIENTATION_LANDSCAPE_LEFT = 1, cc.DEVICE_ORIENTATION_PORTRAIT_UPSIDE_DOWN = 2, cc.DEVICE_ORIENTATION_LANDSCAPE_RIGHT = 3, cc.DEVICE_MAX_ORIENTATIONS = 2, cc.VERTEX_ATTRIB_FLAG_NONE = 0, cc.VERTEX_ATTRIB_FLAG_POSITION = 1, cc.VERTEX_ATTRIB_FLAG_COLOR = 2, cc.VERTEX_ATTRIB_FLAG_TEX_COORDS = 4, cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX = cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS, cc.GL_ALL = 0, cc.VERTEX_ATTRIB_POSITION = 0, cc.VERTEX_ATTRIB_COLOR = 1, cc.VERTEX_ATTRIB_TEX_COORDS = 2, cc.VERTEX_ATTRIB_MAX = 3, cc.UNIFORM_PMATRIX = 0, cc.UNIFORM_MVMATRIX = 1, cc.UNIFORM_MVPMATRIX = 2, cc.UNIFORM_TIME = 3, cc.UNIFORM_SINTIME = 4, cc.UNIFORM_COSTIME = 5, cc.UNIFORM_RANDOM01 = 6, cc.UNIFORM_SAMPLER = 7, cc.UNIFORM_MAX = 8, cc.SHADER_POSITION_TEXTURECOLOR = "ShaderPositionTextureColor", cc.SHADER_POSITION_TEXTURECOLORALPHATEST = "ShaderPositionTextureColorAlphaTest", cc.SHADER_POSITION_COLOR = "ShaderPositionColor", cc.SHADER_POSITION_TEXTURE = "ShaderPositionTexture", cc.SHADER_POSITION_TEXTURE_UCOLOR = "ShaderPositionTexture_uColor", cc.SHADER_POSITION_TEXTUREA8COLOR = "ShaderPositionTextureA8Color", cc.SHADER_POSITION_UCOLOR = "ShaderPosition_uColor", cc.SHADER_POSITION_LENGTHTEXTURECOLOR = "ShaderPositionLengthTextureColor", cc.UNIFORM_PMATRIX_S = "CC_PMatrix", cc.UNIFORM_MVMATRIX_S = "CC_MVMatrix", cc.UNIFORM_MVPMATRIX_S = "CC_MVPMatrix", cc.UNIFORM_TIME_S = "CC_Time", cc.UNIFORM_SINTIME_S = "CC_SinTime", cc.UNIFORM_COSTIME_S = "CC_CosTime", cc.UNIFORM_RANDOM01_S = "CC_Random01", cc.UNIFORM_SAMPLER_S = "CC_Texture0", cc.UNIFORM_ALPHA_TEST_VALUE_S = "CC_alpha_value", cc.ATTRIBUTE_NAME_COLOR = "a_color", cc.ATTRIBUTE_NAME_POSITION = "a_position", cc.ATTRIBUTE_NAME_TEX_COORD = "a_texCoord", cc.ITEM_SIZE = 32, cc.CURRENT_ITEM = 3233828865, cc.ZOOM_ACTION_TAG = 3233828866, cc.NORMAL_TAG = 8801, cc.SELECTED_TAG = 8802, cc.DISABLE_TAG = 8803, cc.arrayVerifyType = function(a, b) {
    if (a && a.length > 0)
        for (var c = 0; c < a.length; c++)
            if (!(a[c] instanceof b)) return cc.log("element type is wrong!"), !1;
    return !0
}, cc.arrayRemoveObject = function(a, b) {
    for (var c = 0, d = a.length; d > c; c++)
        if (a[c] == b) {
            a.splice(c, 1);
            break
        }
}, cc.arrayRemoveArray = function(a, b) {
    for (var c = 0, d = b.length; d > c; c++) cc.arrayRemoveObject(a, b[c])
}, cc.arrayAppendObjectsToIndex = function(a, b, c) {
    return a.splice.apply(a, [c, 0].concat(b)), a
}, cc.copyArray = function(a) {
    var b, c = a.length,
        d = new Array(c);
    for (b = 0; c > b; b += 1) d[b] = a[b];
    return d
}, cc._tmp.PrototypeColor = function() {
    var a = cc.color;
    a._getWhite = function() {
        return a(255, 255, 255)
    }, a._getYellow = function() {
        return a(255, 255, 0)
    }, a._getBlue = function() {
        return a(0, 0, 255)
    }, a._getGreen = function() {
        return a(0, 255, 0)
    }, a._getRed = function() {
        return a(255, 0, 0)
    }, a._getMagenta = function() {
        return a(255, 0, 255)
    }, a._getBlack = function() {
        return a(0, 0, 0)
    }, a._getOrange = function() {
        return a(255, 127, 0)
    }, a._getGray = function() {
        return a(166, 166, 166)
    }, a.WHITE, cc.defineGetterSetter(a, "WHITE", a._getWhite), a.YELLOW, cc.defineGetterSetter(a, "YELLOW", a._getYellow), a.BLUE, cc.defineGetterSetter(a, "BLUE", a._getBlue), a.GREEN, cc.defineGetterSetter(a, "GREEN", a._getGreen), a.RED, cc.defineGetterSetter(a, "RED", a._getRed), a.MAGENTA, cc.defineGetterSetter(a, "MAGENTA", a._getMagenta), a.BLACK, cc.defineGetterSetter(a, "BLACK", a._getBlack), a.ORANGE, cc.defineGetterSetter(a, "ORANGE", a._getOrange), a.GRAY, cc.defineGetterSetter(a, "GRAY", a._getGray), cc.BlendFunc._disable = function() {
        return new cc.BlendFunc(cc.ONE, cc.ZERO)
    }, cc.BlendFunc._alphaPremultiplied = function() {
        return new cc.BlendFunc(cc.ONE, cc.ONE_MINUS_SRC_ALPHA)
    }, cc.BlendFunc._alphaNonPremultiplied = function() {
        return new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA)
    }, cc.BlendFunc._additive = function() {
        return new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE)
    }, cc.BlendFunc.DISABLE, cc.defineGetterSetter(cc.BlendFunc, "DISABLE", cc.BlendFunc._disable), cc.BlendFunc.ALPHA_PREMULTIPLIED, cc.defineGetterSetter(cc.BlendFunc, "ALPHA_PREMULTIPLIED", cc.BlendFunc._alphaPremultiplied), cc.BlendFunc.ALPHA_NON_PREMULTIPLIED, cc.defineGetterSetter(cc.BlendFunc, "ALPHA_NON_PREMULTIPLIED", cc.BlendFunc._alphaNonPremultiplied), cc.BlendFunc.ADDITIVE, cc.defineGetterSetter(cc.BlendFunc, "ADDITIVE", cc.BlendFunc._additive)
};
var cc = cc || {};
switch (cc._tmp = cc._tmp || {}, cc._tmp.WebGLColor = function() {
    cc.color = function(a, b, c, d, e, f) {
        if (void 0 === a) return new cc.Color(0, 0, 0, 255, e, f);
        if (cc.isString(a)) {
            var g = cc.hexToColor(a);
            return new cc.Color(g.r, g.g, g.b, g.a)
        }
        return cc.isObject(a) ? new cc.Color(a.r, a.g, a.b, a.a, a.arrayBuffer, a.offset) : new cc.Color(a, b, c, d, e, f)
    }, cc.Color = function(a, b, c, d, e, f) {
        this._arrayBuffer = e || new ArrayBuffer(cc.Color.BYTES_PER_ELEMENT), this._offset = f || 0;
        var g = this._arrayBuffer,
            h = this._offset,
            i = Uint8Array.BYTES_PER_ELEMENT;
        this._rU8 = new Uint8Array(g, h, 1), this._gU8 = new Uint8Array(g, h + i, 1), this._bU8 = new Uint8Array(g, h + 2 * i, 1), this._aU8 = new Uint8Array(g, h + 3 * i, 1), this._rU8[0] = a || 0, this._gU8[0] = b || 0, this._bU8[0] = c || 0, this._aU8[0] = null == d ? 255 : d, void 0 === d && (this.a_undefined = !0)
    }, cc.Color.BYTES_PER_ELEMENT = 4;
    var a = cc.Color.prototype;
    a._getR = function() {
        return this._rU8[0]
    }, a._setR = function(a) {
        this._rU8[0] = 0 > a ? 0 : a
    }, a._getG = function() {
        return this._gU8[0]
    }, a._setG = function(a) {
        this._gU8[0] = 0 > a ? 0 : a
    }, a._getB = function() {
        return this._bU8[0]
    }, a._setB = function(a) {
        this._bU8[0] = 0 > a ? 0 : a
    }, a._getA = function() {
        return this._aU8[0]
    }, a._setA = function(a) {
        this._aU8[0] = 0 > a ? 0 : a
    }, a.r, cc.defineGetterSetter(a, "r", a._getR, a._setR), a.g, cc.defineGetterSetter(a, "g", a._getG, a._setG), a.b, cc.defineGetterSetter(a, "b", a._getB, a._setB), a.a, cc.defineGetterSetter(a, "a", a._getA, a._setA), cc.Vertex2F = function(a, b, c, d) {
        this._arrayBuffer = c || new ArrayBuffer(cc.Vertex2F.BYTES_PER_ELEMENT), this._offset = d || 0, this._xF32 = new Float32Array(this._arrayBuffer, this._offset, 1), this._yF32 = new Float32Array(this._arrayBuffer, this._offset + 4, 1), this._xF32[0] = a || 0, this._yF32[0] = b || 0
    }, cc.Vertex2F.BYTES_PER_ELEMENT = 8, Object.defineProperties(cc.Vertex2F.prototype, {
        x: {
            get: function() {
                return this._xF32[0]
            },
            set: function(a) {
                this._xF32[0] = a
            },
            enumerable: !0
        },
        y: {
            get: function() {
                return this._yF32[0]
            },
            set: function(a) {
                this._yF32[0] = a
            },
            enumerable: !0
        }
    }), cc.Vertex3F = function(a, b, c, d, e) {
        this._arrayBuffer = d || new ArrayBuffer(cc.Vertex3F.BYTES_PER_ELEMENT), this._offset = e || 0;
        var f = this._arrayBuffer,
            g = this._offset;
        this._xF32 = new Float32Array(f, g, 1), this._xF32[0] = a || 0, this._yF32 = new Float32Array(f, g + Float32Array.BYTES_PER_ELEMENT, 1), this._yF32[0] = b || 0, this._zF32 = new Float32Array(f, g + 2 * Float32Array.BYTES_PER_ELEMENT, 1), this._zF32[0] = c || 0
    }, cc.Vertex3F.BYTES_PER_ELEMENT = 12, Object.defineProperties(cc.Vertex3F.prototype, {
        x: {
            get: function() {
                return this._xF32[0]
            },
            set: function(a) {
                this._xF32[0] = a
            },
            enumerable: !0
        },
        y: {
            get: function() {
                return this._yF32[0]
            },
            set: function(a) {
                this._yF32[0] = a
            },
            enumerable: !0
        },
        z: {
            get: function() {
                return this._zF32[0]
            },
            set: function(a) {
                this._zF32[0] = a
            },
            enumerable: !0
        }
    }), cc.Tex2F = function(a, b, c, d) {
        this._arrayBuffer = c || new ArrayBuffer(cc.Tex2F.BYTES_PER_ELEMENT), this._offset = d || 0, this._uF32 = new Float32Array(this._arrayBuffer, this._offset, 1), this._vF32 = new Float32Array(this._arrayBuffer, this._offset + 4, 1), this._uF32[0] = a || 0, this._vF32[0] = b || 0
    }, cc.Tex2F.BYTES_PER_ELEMENT = 8, Object.defineProperties(cc.Tex2F.prototype, {
        u: {
            get: function() {
                return this._uF32[0]
            },
            set: function(a) {
                this._uF32[0] = a
            },
            enumerable: !0
        },
        v: {
            get: function() {
                return this._vF32[0]
            },
            set: function(a) {
                this._vF32[0] = a
            },
            enumerable: !0
        }
    }), cc.Quad2 = function(a, b, c, d, e, f) {
        this._arrayBuffer = e || new ArrayBuffer(cc.Quad2.BYTES_PER_ELEMENT), this._offset = f || 0;
        var g = this._arrayBuffer,
            h = cc.Vertex2F.BYTES_PER_ELEMENT;
        this._tl = a ? new cc.Vertex2F(a.x, a.y, g, 0) : new cc.Vertex2F(0, 0, g, 0), this._tr = b ? new cc.Vertex2F(b.x, b.y, g, h) : new cc.Vertex2F(0, 0, g, h), this._bl = c ? new cc.Vertex2F(c.x, c.y, g, 2 * h) : new cc.Vertex2F(0, 0, g, 2 * h), this._br = d ? new cc.Vertex2F(d.x, d.y, g, 3 * h) : new cc.Vertex2F(0, 0, g, 3 * h)
    }, cc.Quad2.BYTES_PER_ELEMENT = 32, cc.Quad3 = function(a, b, c, d) {
        this.bl = a || new cc.Vertex3F(0, 0, 0), this.br = b || new cc.Vertex3F(0, 0, 0), this.tl = c || new cc.Vertex3F(0, 0, 0), this.tr = d || new cc.Vertex3F(0, 0, 0)
    }, Object.defineProperties(cc.Quad2.prototype, {
        tl: {
            get: function() {
                return this._tl
            },
            set: function(a) {
                this._tl.x = a.x, this._tl.y = a.y
            },
            enumerable: !0
        },
        tr: {
            get: function() {
                return this._tr
            },
            set: function(a) {
                this._tr.x = a.x, this._tr.y = a.y
            },
            enumerable: !0
        },
        bl: {
            get: function() {
                return this._bl
            },
            set: function(a) {
                this._bl.x = a.x, this._bl.y = a.y
            },
            enumerable: !0
        },
        br: {
            get: function() {
                return this._br
            },
            set: function(a) {
                this._br.x = a.x, this._br.y = a.y
            },
            enumerable: !0
        }
    }), cc.V3F_C4B_T2F = function(a, b, c, d, e) {
        this._arrayBuffer = d || new ArrayBuffer(cc.V3F_C4B_T2F.BYTES_PER_ELEMENT), this._offset = e || 0;
        var f = this._arrayBuffer,
            g = this._offset,
            h = cc.Vertex3F.BYTES_PER_ELEMENT;
        this._vertices = a ? new cc.Vertex3F(a.x, a.y, a.z, f, g) : new cc.Vertex3F(0, 0, 0, f, g), this._colors = b ? cc.color(b.r, b.g, b.b, b.a, f, g + h) : cc.color(0, 0, 0, 0, f, g + h), this._texCoords = c ? new cc.Tex2F(c.u, c.v, f, g + h + cc.Color.BYTES_PER_ELEMENT) : new cc.Tex2F(0, 0, f, g + h + cc.Color.BYTES_PER_ELEMENT)
    }, cc.V3F_C4B_T2F.BYTES_PER_ELEMENT = 24, Object.defineProperties(cc.V3F_C4B_T2F.prototype, {
        vertices: {
            get: function() {
                return this._vertices
            },
            set: function(a) {
                var b = this._vertices;
                b.x = a.x, b.y = a.y, b.z = a.z
            },
            enumerable: !0
        },
        colors: {
            get: function() {
                return this._colors
            },
            set: function(a) {
                var b = this._colors;
                b.r = a.r, b.g = a.g, b.b = a.b, b.a = a.a
            },
            enumerable: !0
        },
        texCoords: {
            get: function() {
                return this._texCoords
            },
            set: function(a) {
                this._texCoords.u = a.u, this._texCoords.v = a.v
            },
            enumerable: !0
        }
    }), cc.V3F_C4B_T2F_Quad = function(a, b, c, d, e, f) {
        this._arrayBuffer = e || new ArrayBuffer(cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT), this._offset = f || 0;
        var g = this._arrayBuffer,
            h = this._offset,
            i = cc.V3F_C4B_T2F.BYTES_PER_ELEMENT;
        this._tl = a ? new cc.V3F_C4B_T2F(a.vertices, a.colors, a.texCoords, g, h) : new cc.V3F_C4B_T2F(null, null, null, g, h), this._bl = b ? new cc.V3F_C4B_T2F(b.vertices, b.colors, b.texCoords, g, h + i) : new cc.V3F_C4B_T2F(null, null, null, g, h + i), this._tr = c ? new cc.V3F_C4B_T2F(c.vertices, c.colors, c.texCoords, g, h + 2 * i) : new cc.V3F_C4B_T2F(null, null, null, g, h + 2 * i), this._br = d ? new cc.V3F_C4B_T2F(d.vertices, d.colors, d.texCoords, g, h + 3 * i) : new cc.V3F_C4B_T2F(null, null, null, g, h + 3 * i)
    }, cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT = 96, Object.defineProperties(cc.V3F_C4B_T2F_Quad.prototype, {
        tl: {
            get: function() {
                return this._tl
            },
            set: function(a) {
                var b = this._tl;
                b.vertices = a.vertices, b.colors = a.colors, b.texCoords = a.texCoords
            },
            enumerable: !0
        },
        bl: {
            get: function() {
                return this._bl
            },
            set: function(a) {
                var b = this._bl;
                b.vertices = a.vertices, b.colors = a.colors, b.texCoords = a.texCoords
            },
            enumerable: !0
        },
        tr: {
            get: function() {
                return this._tr
            },
            set: function(a) {
                var b = this._tr;
                b.vertices = a.vertices, b.colors = a.colors, b.texCoords = a.texCoords
            },
            enumerable: !0
        },
        br: {
            get: function() {
                return this._br
            },
            set: function(a) {
                var b = this._br;
                b.vertices = a.vertices, b.colors = a.colors, b.texCoords = a.texCoords
            },
            enumerable: !0
        },
        arrayBuffer: {
            get: function() {
                return this._arrayBuffer
            },
            enumerable: !0
        }
    }), cc.V3F_C4B_T2F_QuadZero = function() {
        return new cc.V3F_C4B_T2F_Quad
    }, cc.V3F_C4B_T2F_QuadCopy = function(a) {
        if (!a) return cc.V3F_C4B_T2F_QuadZero();
        var b = a.tl,
            c = a.bl,
            d = a.tr,
            e = a.br;
        return {
            tl: {
                vertices: {
                    x: b.vertices.x,
                    y: b.vertices.y,
                    z: b.vertices.z
                },
                colors: {
                    r: b.colors.r,
                    g: b.colors.g,
                    b: b.colors.b,
                    a: b.colors.a
                },
                texCoords: {
                    u: b.texCoords.u,
                    v: b.texCoords.v
                }
            },
            bl: {
                vertices: {
                    x: c.vertices.x,
                    y: c.vertices.y,
                    z: c.vertices.z
                },
                colors: {
                    r: c.colors.r,
                    g: c.colors.g,
                    b: c.colors.b,
                    a: c.colors.a
                },
                texCoords: {
                    u: c.texCoords.u,
                    v: c.texCoords.v
                }
            },
            tr: {
                vertices: {
                    x: d.vertices.x,
                    y: d.vertices.y,
                    z: d.vertices.z
                },
                colors: {
                    r: d.colors.r,
                    g: d.colors.g,
                    b: d.colors.b,
                    a: d.colors.a
                },
                texCoords: {
                    u: d.texCoords.u,
                    v: d.texCoords.v
                }
            },
            br: {
                vertices: {
                    x: e.vertices.x,
                    y: e.vertices.y,
                    z: e.vertices.z
                },
                colors: {
                    r: e.colors.r,
                    g: e.colors.g,
                    b: e.colors.b,
                    a: e.colors.a
                },
                texCoords: {
                    u: e.texCoords.u,
                    v: e.texCoords.v
                }
            }
        }
    }, cc.V3F_C4B_T2F_QuadsCopy = function(a) {
        if (!a) return [];
        for (var b = [], c = 0; c < a.length; c++) b.push(cc.V3F_C4B_T2F_QuadCopy(a[c]));
        return b
    }, cc.V2F_C4B_T2F = function(a, b, c, d, e) {
        this._arrayBuffer = d || new ArrayBuffer(cc.V2F_C4B_T2F.BYTES_PER_ELEMENT), this._offset = e || 0;
        var f = this._arrayBuffer,
            g = this._offset,
            h = cc.Vertex2F.BYTES_PER_ELEMENT;
        this._vertices = a ? new cc.Vertex2F(a.x, a.y, f, g) : new cc.Vertex2F(0, 0, f, g), this._colors = b ? cc.color(b.r, b.g, b.b, b.a, f, g + h) : cc.color(0, 0, 0, 0, f, g + h), this._texCoords = c ? new cc.Tex2F(c.u, c.v, f, g + h + cc.Color.BYTES_PER_ELEMENT) : new cc.Tex2F(0, 0, f, g + h + cc.Color.BYTES_PER_ELEMENT)
    }, cc.V2F_C4B_T2F.BYTES_PER_ELEMENT = 20, Object.defineProperties(cc.V2F_C4B_T2F.prototype, {
        vertices: {
            get: function() {
                return this._vertices
            },
            set: function(a) {
                this._vertices.x = a.x, this._vertices.y = a.y
            },
            enumerable: !0
        },
        colors: {
            get: function() {
                return this._colors
            },
            set: function(a) {
                var b = this._colors;
                b.r = a.r, b.g = a.g, b.b = a.b, b.a = a.a
            },
            enumerable: !0
        },
        texCoords: {
            get: function() {
                return this._texCoords
            },
            set: function(a) {
                this._texCoords.u = a.u, this._texCoords.v = a.v
            },
            enumerable: !0
        }
    }), cc.V2F_C4B_T2F_Triangle = function(a, b, c, d, e) {
        this._arrayBuffer = d || new ArrayBuffer(cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT), this._offset = e || 0;
        var f = this._arrayBuffer,
            g = this._offset,
            h = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
        this._a = a ? new cc.V2F_C4B_T2F(a.vertices, a.colors, a.texCoords, f, g) : new cc.V2F_C4B_T2F(null, null, null, f, g), this._b = b ? new cc.V2F_C4B_T2F(b.vertices, b.colors, b.texCoords, f, g + h) : new cc.V2F_C4B_T2F(null, null, null, f, g + h), this._c = c ? new cc.V2F_C4B_T2F(c.vertices, c.colors, c.texCoords, f, g + 2 * h) : new cc.V2F_C4B_T2F(null, null, null, f, g + 2 * h)
    }, cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT = 60, Object.defineProperties(cc.V2F_C4B_T2F_Triangle.prototype, {
        a: {
            get: function() {
                return this._a
            },
            set: function(a) {
                var b = this._a;
                b.vertices = a.vertices, b.colors = a.colors, b.texCoords = a.texCoords
            },
            enumerable: !0
        },
        b: {
            get: function() {
                return this._b
            },
            set: function(a) {
                var b = this._b;
                b.vertices = a.vertices, b.colors = a.colors, b.texCoords = a.texCoords
            },
            enumerable: !0
        },
        c: {
            get: function() {
                return this._c
            },
            set: function(a) {
                var b = this._c;
                b.vertices = a.vertices, b.colors = a.colors, b.texCoords = a.texCoords
            },
            enumerable: !0
        }
    })
}, cc.Color = function(a, b, c, d) {
    this.r = a || 0, this.g = b || 0, this.b = c || 0, this.a = null == d ? 255 : d
}, cc.color = function(a, b, c, d) {
    return void 0 === a ? {
        r: 0,
        g: 0,
        b: 0,
        a: 255
    } : cc.isString(a) ? cc.hexToColor(a) : cc.isObject(a) ? {
        r: a.r,
        g: a.g,
        b: a.b,
        a: null == a.a ? 255 : a.a
    } : {
        r: a,
        g: b,
        b: c,
        a: null == d ? 255 : d
    }
}, cc.colorEqual = function(a, b) {
    return a.r === b.r && a.g === b.g && a.b === b.b
}, cc.Acceleration = function(a, b, c, d) {
    this.x = a || 0, this.y = b || 0, this.z = c || 0, this.timestamp = d || 0
}, cc.Vertex2F = function(a, b) {
    this.x = a || 0, this.y = b || 0
}, cc.vertex2 = function(a, b) {
    return new cc.Vertex2F(a, b)
}, cc.Vertex3F = function(a, b, c) {
    this.x = a || 0, this.y = b || 0, this.z = c || 0
}, cc.vertex3 = function(a, b, c) {
    return new cc.Vertex3F(a, b, c)
}, cc.Tex2F = function(a, b) {
    this.u = a || 0, this.v = b || 0
}, cc.tex2 = function(a, b) {
    return new cc.Tex2F(a, b)
}, cc.BlendFunc = function(a, b) {
    this.src = a, this.dst = b
}, cc.blendFuncDisable = function() {
    return new cc.BlendFunc(cc.ONE, cc.ZERO)
}, cc.hexToColor = function(a) {
    a = a.replace(/^#?/, "0x");
    var b = parseInt(a),
        c = b >> 16,
        d = (b >> 8) % 256,
        e = b % 256;
    return cc.color(c, d, e)
}, cc.colorToHex = function(a) {
    var b = a.r.toString(16),
        c = a.g.toString(16),
        d = a.b.toString(16);
    return "#" + (a.r < 16 ? "0" + b : b) + (a.g < 16 ? "0" + c : c) + (a.b < 16 ? "0" + d : d)
}, cc.TEXT_ALIGNMENT_LEFT = 0, cc.TEXT_ALIGNMENT_CENTER = 1, cc.TEXT_ALIGNMENT_RIGHT = 2, cc.VERTICAL_TEXT_ALIGNMENT_TOP = 0, cc.VERTICAL_TEXT_ALIGNMENT_CENTER = 1, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM = 2, cc._Dictionary = cc.Class.extend({
    _keyMapTb: null,
    _valueMapTb: null,
    __currId: 0,
    ctor: function() {
        this._keyMapTb = {}, this._valueMapTb = {}, this.__currId = 2 << (0 | 10 * Math.random())
    },
    __getKey: function() {
        return this.__currId++, "key_" + this.__currId
    },
    setObject: function(a, b) {
        if (null != b) {
            var c = this.__getKey();
            this._keyMapTb[c] = b, this._valueMapTb[c] = a
        }
    },
    objectForKey: function(a) {
        if (null == a) return null;
        var b = this._keyMapTb;
        for (var c in b)
            if (b[c] === a) return this._valueMapTb[c];
        return null
    },
    valueForKey: function(a) {
        return this.objectForKey(a)
    },
    removeObjectForKey: function(a) {
        if (null != a) {
            var b = this._keyMapTb;
            for (var c in b)
                if (b[c] === a) return delete this._valueMapTb[c], void delete b[c]
        }
    },
    removeObjectsForKeys: function(a) {
        if (null != a)
            for (var b = 0; b < a.length; b++) this.removeObjectForKey(a[b])
    },
    allKeys: function() {
        var a = [],
            b = this._keyMapTb;
        for (var c in b) a.push(b[c]);
        return a
    },
    removeAllObjects: function() {
        this._keyMapTb = {}, this._valueMapTb = {}
    },
    count: function() {
        return this.allKeys().length
    }
}), cc.FontDefinition = function() {
    var a = this;
    a.fontName = "Arial", a.fontSize = 12, a.textAlign = cc.TEXT_ALIGNMENT_CENTER, a.verticalAlign = cc.VERTICAL_TEXT_ALIGNMENT_TOP, a.fillStyle = cc.color(255, 255, 255, 255), a.boundingWidth = 0, a.boundingHeight = 0, a.strokeEnabled = !1, a.strokeStyle = cc.color(255, 255, 255, 255), a.lineWidth = 1, a.shadowEnabled = !1, a.shadowOffsetX = 0, a.shadowOffsetY = 0, a.shadowBlur = 0, a.shadowOpacity = 1
}, cc._renderType === cc._RENDER_TYPE_WEBGL && (cc.assert(cc.isFunction(cc._tmp.WebGLColor), cc._LogInfos.MissingFile, "CCTypesWebGL.js"), cc._tmp.WebGLColor(), delete cc._tmp.WebGLColor), cc.assert(cc.isFunction(cc._tmp.PrototypeColor), cc._LogInfos.MissingFile, "CCTypesPropertyDefine.js"), cc._tmp.PrototypeColor(), delete cc._tmp.PrototypeColor, cc.Touches = [], cc.TouchesIntergerDict = {}, cc.DENSITYDPI_DEVICE = "device-dpi", cc.DENSITYDPI_HIGH = "high-dpi", cc.DENSITYDPI_MEDIUM = "medium-dpi", cc.DENSITYDPI_LOW = "low-dpi", cc.__BrowserGetter = {
    init: function() {
        this.html = document.getElementsByTagName("html")[0]
    },
    availWidth: function(a) {
        return a && a !== this.html ? a.clientWidth : window.innerWidth
    },
    availHeight: function(a) {
        return a && a !== this.html ? a.clientHeight : window.innerHeight
    },
    meta: {
        width: "device-width",
        "user-scalable": "no"
    }
}, cc.sys.browserType) {
    case cc.sys.BROWSER_TYPE_SAFARI:
        cc.__BrowserGetter.meta["minimal-ui"] = "true";
        break;
    case cc.sys.BROWSER_TYPE_CHROME:
        cc.__BrowserGetter.__defineGetter__("target-densitydpi", function() {
            return cc.view._targetDensityDPI
        });
    case cc.sys.BROWSER_TYPE_UC:
        cc.__BrowserGetter.availWidth = function(a) {
            return a.clientWidth
        }, cc.__BrowserGetter.availHeight = function(a) {
            return a.clientHeight
        };
        break;
    case cc.sys.BROWSER_TYPE_MIUI:
        cc.__BrowserGetter.init = function(a) {
            if (!a.__resizeWithBrowserSize) {
                var b = function() {
                    a.setDesignResolutionSize(a._designResolutionSize.width, a._designResolutionSize.height, a._resolutionPolicy), window.removeEventListener("resize", b, !1)
                };
                window.addEventListener("resize", b, !1)
            }
        }
}
if (cc.EGLView = cc.Class.extend({
    _delegate: null,
    _frameSize: null,
    _designResolutionSize: null,
    _originalDesignResolutionSize: null,
    _viewPortRect: null,
    _visibleRect: null,
    _retinaEnabled: !1,
    _autoFullScreen: !0,
    _devicePixelRatio: 1,
    _viewName: "",
    _resizeCallback: null,
    _scaleX: 1,
    _originalScaleX: 1,
    _scaleY: 1,
    _originalScaleY: 1,
    _indexBitsUsed: 0,
    _maxTouches: 5,
    _resolutionPolicy: null,
    _rpExactFit: null,
    _rpShowAll: null,
    _rpNoBorder: null,
    _rpFixedHeight: null,
    _rpFixedWidth: null,
    _initialized: !1,
    _captured: !1,
    _wnd: null,
    _hDC: null,
    _hRC: null,
    _supportTouch: !1,
    _contentTranslateLeftTop: null,
    _frame: null,
    _frameZoomFactor: 1,
    __resizeWithBrowserSize: !1,
    _isAdjustViewPort: !0,
    _targetDensityDPI: null,
    ctor: function() {
        var a = this,
            b = document,
            c = cc.ContainerStrategy,
            d = cc.ContentStrategy;
        cc.__BrowserGetter.init(this), a._frame = cc.container.parentNode === b.body ? b.documentElement : cc.container.parentNode, a._frameSize = cc.size(0, 0), a._initFrameSize();
        var e = cc._canvas.width,
            f = cc._canvas.height;
        a._designResolutionSize = cc.size(e, f), a._originalDesignResolutionSize = cc.size(e, f), a._viewPortRect = cc.rect(0, 0, e, f), a._visibleRect = cc.rect(0, 0, e, f), a._contentTranslateLeftTop = {
            left: 0,
            top: 0
        }, a._viewName = "Cocos2dHTML5";
        var g = cc.sys;
        a.enableRetina(g.os == g.OS_IOS || g.os == g.OS_OSX), cc.visibleRect && cc.visibleRect.init(a._visibleRect), a._rpExactFit = new cc.ResolutionPolicy(c.EQUAL_TO_FRAME, d.EXACT_FIT), a._rpShowAll = new cc.ResolutionPolicy(c.PROPORTION_TO_FRAME, d.SHOW_ALL), a._rpNoBorder = new cc.ResolutionPolicy(c.EQUAL_TO_FRAME, d.NO_BORDER), a._rpFixedHeight = new cc.ResolutionPolicy(c.EQUAL_TO_FRAME, d.FIXED_HEIGHT), a._rpFixedWidth = new cc.ResolutionPolicy(c.EQUAL_TO_FRAME, d.FIXED_WIDTH), a._hDC = cc._canvas, a._hRC = cc._renderContext, a._targetDensityDPI = cc.DENSITYDPI_HIGH
    },
    _resizeEvent: function() {
        var a;
        a = this.setDesignResolutionSize ? this : cc.view, a._resizeCallback && (a._initFrameSize(), a._resizeCallback.call());
        var b = a._originalDesignResolutionSize.width,
            c = a._originalDesignResolutionSize.height;
        b > 0 && a.setDesignResolutionSize(b, c, a._resolutionPolicy)
    },
    setTargetDensityDPI: function(a) {
        this._targetDensityDPI = a, this._setViewPortMeta()
    },
    getTargetDensityDPI: function() {
        return this._targetDensityDPI
    },
    resizeWithBrowserSize: function(a) {
        a ? this.__resizeWithBrowserSize || (this.__resizeWithBrowserSize = !0, cc._addEventListener(window, "resize", this._resizeEvent, !1)) : this.__resizeWithBrowserSize && (this.__resizeWithBrowserSize = !1, window.removeEventListener("resize", this._resizeEvent, !1))
    },
    setResizeCallback: function(a) {
        (cc.isFunction(a) || null == a) && (this._resizeCallback = a)
    },
    _initFrameSize: function() {
        var a = this._frameSize;
        a.width = cc.__BrowserGetter.availWidth(this._frame), a.height = cc.__BrowserGetter.availHeight(this._frame)
    },
    _adjustSizeKeepCanvasSize: function() {
        var a = this._originalDesignResolutionSize.width,
            b = this._originalDesignResolutionSize.height;
        a > 0 && this.setDesignResolutionSize(a, b, this._resolutionPolicy)
    },
    _setViewPortMeta: function() {
        if (this._isAdjustViewPort) {
            var a = document.getElementById("cocosMetaElement");
            a && document.head.removeChild(a);
            var b, c, d = document.getElementsByName("viewport"),
                e = d ? d[0] : null;
            a = cc.newElement("meta"), a.id = "cocosMetaElement", a.name = "viewport", a.content = "", b = cc.__BrowserGetter.meta, c = e ? e.content : "";
            for (var f in b) {
                var g = new RegExp(f);
                g.test(c) || (c += "," + f + "=" + b[f])
            }
            /^,/.test(c) && (c = c.substr(1)), a.content = c, e && (e.content = c), document.head.appendChild(a)
        }
    },
    _setScaleXYForRenderTexture: function() {
        var a = cc.contentScaleFactor();
        this._scaleX = a, this._scaleY = a
    },
    _resetScale: function() {
        this._scaleX = this._originalScaleX, this._scaleY = this._originalScaleY
    },
    _adjustSizeToBrowser: function() {},
    initialize: function() {
        this._initialized = !0
    },
    adjustViewPort: function(a) {
        this._isAdjustViewPort = a
    },
    enableRetina: function(a) {
        this._retinaEnabled = a ? !0 : !1
    },
    isRetinaEnabled: function() {
        return this._retinaEnabled
    },
    enableAutoFullScreen: function(a) {
        this._autoFullScreen = a ? !0 : !1
    },
    isAutoFullScreenEnabled: function() {
        return this._autoFullScreen
    },
    end: function() {},
    isOpenGLReady: function() {
        return null != this._hDC && null != this._hRC
    },
    setFrameZoomFactor: function(a) {
        this._frameZoomFactor = a, this.centerWindow(), cc.director.setProjection(cc.director.getProjection())
    },
    swapBuffers: function() {},
    setIMEKeyboardState: function() {},
    setContentTranslateLeftTop: function(a, b) {
        this._contentTranslateLeftTop = {
            left: a,
            top: b
        }
    },
    getContentTranslateLeftTop: function() {
        return this._contentTranslateLeftTop
    },
    getFrameSize: function() {
        return cc.size(this._frameSize.width, this._frameSize.height)
    },
    setFrameSize: function(a, b) {
        this._frameSize.width = a, this._frameSize.height = b, this._frame.style.width = a + "px", this._frame.style.height = b + "px", this._resizeEvent(), cc.director.setProjection(cc.director.getProjection())
    },
    centerWindow: function() {},
    getVisibleSize: function() {
        return cc.size(this._visibleRect.width, this._visibleRect.height)
    },
    getVisibleOrigin: function() {
        return cc.p(this._visibleRect.x, this._visibleRect.y)
    },
    canSetContentScaleFactor: function() {
        return !0
    },
    getResolutionPolicy: function() {
        return this._resolutionPolicy
    },
    setResolutionPolicy: function(a) {
        var b = this;
        if (a instanceof cc.ResolutionPolicy) b._resolutionPolicy = a;
        else {
            var c = cc.ResolutionPolicy;
            a === c.EXACT_FIT && (b._resolutionPolicy = b._rpExactFit), a === c.SHOW_ALL && (b._resolutionPolicy = b._rpShowAll), a === c.NO_BORDER && (b._resolutionPolicy = b._rpNoBorder), a === c.FIXED_HEIGHT && (b._resolutionPolicy = b._rpFixedHeight), a === c.FIXED_WIDTH && (b._resolutionPolicy = b._rpFixedWidth)
        }
    },
    setDesignResolutionSize: function(a, b, c) {
        if (!(a > 0 || b > 0)) return void cc.log(cc._LogInfos.EGLView_setDesignResolutionSize);
        this.setResolutionPolicy(c);
        var d = this._resolutionPolicy;
        if (!d) return void cc.log(cc._LogInfos.EGLView_setDesignResolutionSize_2);
        d.preApply(this), cc.sys.isMobile && this._setViewPortMeta(), this._initFrameSize(), this._originalDesignResolutionSize.width = this._designResolutionSize.width = a, this._originalDesignResolutionSize.height = this._designResolutionSize.height = b;
        var e = d.apply(this, this._designResolutionSize);
        if (e.scale && 2 == e.scale.length && (this._scaleX = e.scale[0], this._scaleY = e.scale[1]), e.viewport) {
            var f = this._viewPortRect,
                g = this._visibleRect,
                h = e.viewport;
            f.x = h.x, f.y = h.y, f.width = h.width, f.height = h.height, g.x = -f.x / this._scaleX, g.y = -f.y / this._scaleY, g.width = cc._canvas.width / this._scaleX, g.height = cc._canvas.height / this._scaleY, cc._renderContext.setOffset && cc._renderContext.setOffset(f.x, -f.y)
        }
        var i = cc.director;
        i._winSizeInPoints.width = this._designResolutionSize.width, i._winSizeInPoints.height = this._designResolutionSize.height, d.postApply(this), cc.winSize.width = i._winSizeInPoints.width, cc.winSize.height = i._winSizeInPoints.height, cc._renderType == cc._RENDER_TYPE_WEBGL && (i._createStatsLabel(), i.setGLDefaultValues()), this._originalScaleX = this._scaleX, this._originalScaleY = this._scaleY, cc.DOM && cc.DOM._resetEGLViewDiv(), cc.visibleRect && cc.visibleRect.init(this._visibleRect)
    },
    getDesignResolutionSize: function() {
        return cc.size(this._designResolutionSize.width, this._designResolutionSize.height)
    },
    setViewPortInPoints: function(a, b, c, d) {
        var e = this._frameZoomFactor,
            f = this._scaleX,
            g = this._scaleY;
        cc._renderContext.viewport(a * f * e + this._viewPortRect.x * e, b * g * e + this._viewPortRect.y * e, c * f * e, d * g * e)
    },
    setScissorInPoints: function(a, b, c, d) {
        var e = this._frameZoomFactor,
            f = this._scaleX,
            g = this._scaleY;
        cc._renderContext.scissor(a * f * e + this._viewPortRect.x * e, b * g * e + this._viewPortRect.y * e, c * f * e, d * g * e)
    },
    isScissorEnabled: function() {
        var a = cc._renderContext;
        return a.isEnabled(a.SCISSOR_TEST)
    },
    getScissorRect: function() {
        var a = cc._renderContext,
            b = this._scaleX,
            c = this._scaleY,
            d = a.getParameter(a.SCISSOR_BOX);
        return cc.rect((d[0] - this._viewPortRect.x) / b, (d[1] - this._viewPortRect.y) / c, d[2] / b, d[3] / c)
    },
    setViewName: function(a) {
        null != a && a.length > 0 && (this._viewName = a)
    },
    getViewName: function() {
        return this._viewName
    },
    getViewPortRect: function() {
        return this._viewPortRect
    },
    getScaleX: function() {
        return this._scaleX
    },
    getScaleY: function() {
        return this._scaleY
    },
    getDevicePixelRatio: function() {
        return this._devicePixelRatio
    },
    convertToLocationInView: function(a, b, c) {
        return {
            x: this._devicePixelRatio * (a - c.left),
            y: this._devicePixelRatio * (c.top + c.height - b)
        }
    },
    _convertMouseToLocationInView: function(a, b) {
        var c = this._viewPortRect,
            d = this;
        a.x = (d._devicePixelRatio * (a.x - b.left) - c.x) / d._scaleX, a.y = (d._devicePixelRatio * (b.top + b.height - a.y) - c.y) / d._scaleY
    },
    _convertTouchesWithScale: function(a) {
        for (var b, c, d, e = this._viewPortRect, f = this._scaleX, g = this._scaleY, h = 0; h < a.length; h++) b = a[h], c = b._point, d = b._prevPoint, b._setPoint((c.x - e.x) / f, (c.y - e.y) / g), b._setPrevPoint((d.x - e.x) / f, (d.y - e.y) / g)
    }
}), cc.EGLView._getInstance = function() {
    return this._instance || (this._instance = this._instance || new cc.EGLView, this._instance.initialize()), this._instance
}, cc.ContainerStrategy = cc.Class.extend({
    preApply: function() {},
    apply: function() {},
    postApply: function() {},
    _setupContainer: function(a, b, c) {
        var d = a._frame;
        cc.view._autoFullScreen && cc.sys.isMobile && d == document.documentElement && cc.screen.autoFullScreen(d);
        var e = cc._canvas,
            f = cc.container;
        f.style.width = e.style.width = b + "px", f.style.height = e.style.height = c + "px";
        var g = a._devicePixelRatio = 1;
        a.isRetinaEnabled() && (g = a._devicePixelRatio = window.devicePixelRatio || 1), e.width = b * g, e.height = c * g, cc._renderContext.resetCache && cc._renderContext.resetCache();
        var h, i = document.body;
        i && (h = i.style) && (h.paddingTop = h.paddingTop || "0px", h.paddingRight = h.paddingRight || "0px", h.paddingBottom = h.paddingBottom || "0px", h.paddingLeft = h.paddingLeft || "0px", h.borderTop = h.borderTop || "0px", h.borderRight = h.borderRight || "0px", h.borderBottom = h.borderBottom || "0px", h.borderLeft = h.borderLeft || "0px", h.marginTop = h.marginTop || "0px", h.marginRight = h.marginRight || "0px", h.marginBottom = h.marginBottom || "0px", h.marginLeft = h.marginLeft || "0px")
    },
    _fixContainer: function() {
        document.body.insertBefore(cc.container, document.body.firstChild);
        var a = document.body.style;
        a.width = window.innerWidth + "px", a.height = window.innerHeight + "px", a.overflow = "hidden";
        var b = cc.container.style;
        b.position = "fixed", b.left = b.top = "0px", document.body.scrollTop = 0
    }
}), cc.ContentStrategy = cc.Class.extend({
    _result: {
        scale: [1, 1],
        viewport: null
    },
    _buildResult: function(a, b, c, d, e, f) {
        Math.abs(a - c) < 2 && (c = a), Math.abs(b - d) < 2 && (d = b);
        var g = cc.rect(Math.round((a - c) / 2), Math.round((b - d) / 2), c, d);
        return cc._renderType == cc._RENDER_TYPE_CANVAS, this._result.scale = [e, f], this._result.viewport = g, this._result
    },
    preApply: function() {},
    apply: function() {
        return {
            scale: [1, 1]
        }
    },
    postApply: function() {}
}), function() {
    var a = cc.ContainerStrategy.extend({
            apply: function(a) {
                this._setupContainer(a, a._frameSize.width, a._frameSize.height)
            }
        }),
        b = cc.ContainerStrategy.extend({
            apply: function(a, b) {
                var c, d, e = a._frameSize.width,
                    f = a._frameSize.height,
                    g = cc.container.style,
                    h = b.width,
                    i = b.height,
                    j = e / h,
                    k = f / i;
                k > j ? (c = e, d = i * j) : (c = h * k, d = f);
                var l = Math.round((e - c) / 2),
                    m = Math.round((f - d) / 2);
                c = e - 2 * l, d = f - 2 * m, this._setupContainer(a, c, d), g.marginLeft = l + "px", g.marginRight = l + "px", g.marginTop = m + "px", g.marginBottom = m + "px"
            }
        }),
        c = (a.extend({
            preApply: function(a) {
                this._super(a), a._frame = document.documentElement
            },
            apply: function(a) {
                this._super(a), this._fixContainer()
            }
        }), b.extend({
            preApply: function(a) {
                this._super(a), a._frame = document.documentElement
            },
            apply: function(a, b) {
                this._super(a, b), this._fixContainer()
            }
        }), cc.ContainerStrategy.extend({
            apply: function(a) {
                this._setupContainer(a, cc._canvas.width, cc._canvas.height)
            }
        }));
    cc.ContainerStrategy.EQUAL_TO_FRAME = new a, cc.ContainerStrategy.PROPORTION_TO_FRAME = new b, cc.ContainerStrategy.ORIGINAL_CONTAINER = new c;
    var d = cc.ContentStrategy.extend({
            apply: function(a, b) {
                var c = cc._canvas.width,
                    d = cc._canvas.height,
                    e = c / b.width,
                    f = d / b.height;
                return this._buildResult(c, d, c, d, e, f)
            }
        }),
        e = cc.ContentStrategy.extend({
            apply: function(a, b) {
                var c, d, e = cc._canvas.width,
                    f = cc._canvas.height,
                    g = b.width,
                    h = b.height,
                    i = e / g,
                    j = f / h,
                    k = 0;
                return j > i ? (k = i, c = e, d = h * k) : (k = j, c = g * k, d = f), this._buildResult(e, f, c, d, k, k)
            }
        }),
        f = cc.ContentStrategy.extend({
            apply: function(a, b) {
                var c, d, e, f = cc._canvas.width,
                    g = cc._canvas.height,
                    h = b.width,
                    i = b.height,
                    j = f / h,
                    k = g / i;
                return k > j ? (c = k, d = h * c, e = g) : (c = j, d = f, e = i * c), this._buildResult(f, g, d, e, c, c)
            }
        }),
        g = cc.ContentStrategy.extend({
            apply: function(a, b) {
                var c = cc._canvas.width,
                    d = cc._canvas.height,
                    e = b.height,
                    f = d / e,
                    g = c,
                    h = d;
                return this._buildResult(c, d, g, h, f, f)
            },
            postApply: function(a) {
                cc.director._winSizeInPoints = a.getVisibleSize()
            }
        }),
        h = cc.ContentStrategy.extend({
            apply: function(a, b) {
                var c = cc._canvas.width,
                    d = cc._canvas.height,
                    e = b.width,
                    f = c / e,
                    g = c,
                    h = d;
                return this._buildResult(c, d, g, h, f, f)
            },
            postApply: function(a) {
                cc.director._winSizeInPoints = a.getVisibleSize()
            }
        });
    cc.ContentStrategy.EXACT_FIT = new d, cc.ContentStrategy.SHOW_ALL = new e, cc.ContentStrategy.NO_BORDER = new f, cc.ContentStrategy.FIXED_HEIGHT = new g, cc.ContentStrategy.FIXED_WIDTH = new h
}(), cc.ResolutionPolicy = cc.Class.extend({
    _containerStrategy: null,
    _contentStrategy: null,
    ctor: function(a, b) {
        this.setContainerStrategy(a), this.setContentStrategy(b)
    },
    preApply: function(a) {
        this._containerStrategy.preApply(a), this._contentStrategy.preApply(a)
    },
    apply: function(a, b) {
        return this._containerStrategy.apply(a, b), this._contentStrategy.apply(a, b)
    },
    postApply: function(a) {
        this._containerStrategy.postApply(a), this._contentStrategy.postApply(a)
    },
    setContainerStrategy: function(a) {
        a instanceof cc.ContainerStrategy && (this._containerStrategy = a)
    },
    setContentStrategy: function(a) {
        a instanceof cc.ContentStrategy && (this._contentStrategy = a)
    }
}), cc.ResolutionPolicy.EXACT_FIT = 0, cc.ResolutionPolicy.NO_BORDER = 1, cc.ResolutionPolicy.SHOW_ALL = 2, cc.ResolutionPolicy.FIXED_HEIGHT = 3, cc.ResolutionPolicy.FIXED_WIDTH = 4, cc.ResolutionPolicy.UNKNOWN = 5, cc.screen = {
    _supportsFullScreen: !1,
    _preOnFullScreenChange: null,
    _touchEvent: "",
    _fn: null,
    _fnMap: [
        ["requestFullscreen", "exitFullscreen", "fullscreenchange", "fullscreenEnabled", "fullscreenElement"],
        ["requestFullScreen", "exitFullScreen", "fullScreenchange", "fullScreenEnabled", "fullScreenElement"],
        ["webkitRequestFullScreen", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitIsFullScreen", "webkitCurrentFullScreenElement"],
        ["mozRequestFullScreen", "mozCancelFullScreen", "mozfullscreenchange", "mozFullScreen", "mozFullScreenElement"],
        ["msRequestFullscreen", "msExitFullscreen", "MSFullscreenChange", "msFullscreenEnabled", "msFullscreenElement"]
    ],
    init: function() {
        this._fn = {};
        var a, b, c, d = this._fnMap;
        for (a = 0, l = d.length; a < l; a++)
            if (b = d[a], b && b[1] in document) {
                for (a = 0, c = b.length; c > a; a++) this._fn[d[0][a]] = b[a];
                break
            }
        this._supportsFullScreen = void 0 != this._fn.requestFullscreen, this._touchEvent = "ontouchstart" in window ? "touchstart" : "mousedown"
    },
    fullScreen: function() {
        return this._supportsFullScreen && document[this._fn.fullscreenEnabled]
    },
    requestFullScreen: function(a, b) {
        if (this._supportsFullScreen) {
            if (a = a || document.documentElement, a[this._fn.requestFullscreen](), b) {
                var c = this._fn.fullscreenchange;
                this._preOnFullScreenChange && document.removeEventListener(c, this._preOnFullScreenChange), this._preOnFullScreenChange = b, cc._addEventListener(document, c, b, !1)
            }
            return a[this._fn.requestFullscreen]()
        }
    },
    exitFullScreen: function() {
        return this._supportsFullScreen ? document[this._fn.exitFullscreen]() : !0
    },
    autoFullScreen: function(a, b) {
        function c() {
            e.requestFullScreen(a, b), d.removeEventListener(e._touchEvent, c)
        }
        a = a || document.body;
        var d = cc._canvas || a,
            e = this;
        this.requestFullScreen(a, b), cc._addEventListener(d, this._touchEvent, c)
    }
}, cc.screen.init(), cc.visibleRect = {
    topLeft: cc.p(0, 0),
    topRight: cc.p(0, 0),
    top: cc.p(0, 0),
    bottomLeft: cc.p(0, 0),
    bottomRight: cc.p(0, 0),
    bottom: cc.p(0, 0),
    center: cc.p(0, 0),
    left: cc.p(0, 0),
    right: cc.p(0, 0),
    width: 0,
    height: 0,
    init: function(a) {
        var b = this.width = a.width,
            c = this.height = a.height,
            d = a.x,
            e = a.y,
            f = e + c,
            g = d + b;
        this.topLeft.x = d, this.topLeft.y = f, this.topRight.x = g, this.topRight.y = f, this.top.x = d + b / 2, this.top.y = f, this.bottomLeft.x = d, this.bottomLeft.y = e, this.bottomRight.x = g, this.bottomRight.y = e, this.bottom.x = d + b / 2, this.bottom.y = e, this.center.x = d + b / 2, this.center.y = e + c / 2, this.left.x = d, this.left.y = e + c / 2, this.right.x = g, this.right.y = e + c / 2
    }
}, cc.UIInterfaceOrientationLandscapeLeft = -90, cc.UIInterfaceOrientationLandscapeRight = 90, cc.UIInterfaceOrientationPortraitUpsideDown = 180, cc.UIInterfaceOrientationPortrait = 0, cc.inputManager = {
    _mousePressed: !1,
    _isRegisterEvent: !1,
    _preTouchPoint: cc.p(0, 0),
    _prevMousePoint: cc.p(0, 0),
    _preTouchPool: [],
    _preTouchPoolPointer: 0,
    _touches: [],
    _touchesIntegerDict: {},
    _indexBitsUsed: 0,
    _maxTouches: 5,
    _accelEnabled: !1,
    _accelInterval: 1 / 30,
    _accelMinus: 1,
    _accelCurTime: 0,
    _acceleration: null,
    _accelDeviceEvent: null,
    _getUnUsedIndex: function() {
        for (var a = this._indexBitsUsed, b = 0; b < this._maxTouches; b++) {
            if (!(1 & a)) return this._indexBitsUsed |= 1 << b, b;
            a >>= 1
        }
        return -1
    },
    _removeUsedIndexBit: function(a) {
        if (!(0 > a || a >= this._maxTouches)) {
            var b = 1 << a;
            b = ~b, this._indexBitsUsed &= b
        }
    },
    _glView: null,
    handleTouchesBegin: function(a) {
        for (var b, c, d, e, f = [], g = this._touchesIntegerDict, h = 0, i = a.length; i > h; h++)
            if (b = a[h], e = b.getID(), c = g[e], null == c) {
                var j = this._getUnUsedIndex();
                if (-1 == j) {
                    cc.log(cc._LogInfos.inputManager_handleTouchesBegin, j);
                    continue
                }
                d = this._touches[j] = new cc.Touch(b._point.x, b._point.y, b.getID()), d._setPrevPoint(b._prevPoint), g[e] = j, f.push(d)
            }
        if (f.length > 0) {
            this._glView._convertTouchesWithScale(f);
            var k = new cc.EventTouch(f);
            k._eventCode = cc.EventTouch.EventCode.BEGAN, cc.eventManager.dispatchEvent(k)
        }
    },
    handleTouchesMove: function(a) {
        for (var b, c, d, e = [], f = this._touches, g = 0, h = a.length; h > g; g++) b = a[g], d = b.getID(), c = this._touchesIntegerDict[d], null != c && f[c] && (f[c]._setPoint(b._point), f[c]._setPrevPoint(b._prevPoint), e.push(f[c]));
        if (e.length > 0) {
            this._glView._convertTouchesWithScale(e);
            var i = new cc.EventTouch(e);
            i._eventCode = cc.EventTouch.EventCode.MOVED, cc.eventManager.dispatchEvent(i)
        }
    },
    handleTouchesEnd: function(a) {
        var b = this.getSetOfTouchesEndOrCancel(a);
        if (b.length > 0) {
            this._glView._convertTouchesWithScale(b);
            var c = new cc.EventTouch(b);
            c._eventCode = cc.EventTouch.EventCode.ENDED, cc.eventManager.dispatchEvent(c)
        }
    },
    handleTouchesCancel: function(a) {
        var b = this.getSetOfTouchesEndOrCancel(a);
        if (b.length > 0) {
            this._glView._convertTouchesWithScale(b);
            var c = new cc.EventTouch(b);
            c._eventCode = cc.EventTouch.EventCode.CANCELLED, cc.eventManager.dispatchEvent(c)
        }
    },
    getSetOfTouchesEndOrCancel: function(a) {
        for (var b, c, d, e = [], f = this._touches, g = this._touchesIntegerDict, h = 0, i = a.length; i > h; h++) b = a[h], d = b.getID(), c = g[d], null != c && f[c] && (f[c]._setPoint(b._point), f[c]._setPrevPoint(b._prevPoint), e.push(f[c]), this._removeUsedIndexBit(c), delete g[d]);
        return e
    },
    getHTMLElementPosition: function(a) {
        var b = document.documentElement,
            c = window,
            d = null;
        return d = cc.isFunction(a.getBoundingClientRect) ? a.getBoundingClientRect() : a instanceof HTMLCanvasElement ? {
            left: 0,
            top: 0,
            width: a.width,
            height: a.height
        } : {
            left: 0,
            top: 0,
            width: parseInt(a.style.width),
            height: parseInt(a.style.height)
        }, {
            left: d.left + c.pageXOffset - b.clientLeft,
            top: d.top + c.pageYOffset - b.clientTop,
            width: d.width,
            height: d.height
        }
    },
    getPreTouch: function(a) {
        for (var b = null, c = this._preTouchPool, d = a.getID(), e = c.length - 1; e >= 0; e--)
            if (c[e].getID() == d) {
                b = c[e];
                break
            }
        return b || (b = a), b
    },
    setPreTouch: function(a) {
        for (var b = !1, c = this._preTouchPool, d = a.getID(), e = c.length - 1; e >= 0; e--)
            if (c[e].getID() == d) {
                c[e] = a, b = !0;
                break
            }
        b || (c.length <= 50 ? c.push(a) : (c[this._preTouchPoolPointer] = a, this._preTouchPoolPointer = (this._preTouchPoolPointer + 1) % 50))
    },
    getTouchByXY: function(a, b, c) {
        var d = this._preTouchPoint,
            e = this._glView.convertToLocationInView(a, b, c),
            f = new cc.Touch(e.x, e.y);
        return f._setPrevPoint(d.x, d.y), d.x = e.x, d.y = e.y, f
    },
    getMouseEvent: function(a, b, c) {
        var d = this._prevMousePoint;
        this._glView._convertMouseToLocationInView(a, b);
        var e = new cc.EventMouse(c);
        return e.setLocation(a.x, a.y), e._setPrevCursor(d.x, d.y), d.x = a.x, d.y = a.y, e
    },
    getPointByEvent: function(a, b) {
        return null != a.pageX ? {
            x: a.pageX,
            y: a.pageY
        } : (b.left -= document.body.scrollLeft, b.top -= document.body.scrollTop, {
            x: a.clientX,
            y: a.clientY
        })
    },
    getTouchesByEvent: function(a, b) {
        for (var c, d, e, f = [], g = this._glView, h = this._preTouchPoint, i = a.changedTouches.length, j = 0; i > j; j++)
            if (c = a.changedTouches[j]) {
                var k;
                k = cc.sys.BROWSER_TYPE_FIREFOX === cc.sys.browserType ? g.convertToLocationInView(c.pageX, c.pageY, b) : g.convertToLocationInView(c.clientX, c.clientY, b), null != c.identifier ? (d = new cc.Touch(k.x, k.y, c.identifier), e = this.getPreTouch(d).getLocation(), d._setPrevPoint(e.x, e.y), this.setPreTouch(d)) : (d = new cc.Touch(k.x, k.y), d._setPrevPoint(h.x, h.y)), h.x = k.x, h.y = k.y, f.push(d)
            }
        return f
    },
    registerSystemEvent: function(a) {
        if (!this._isRegisterEvent) {
            var b = (this._glView = cc.view, this),
                c = "mouse" in cc.sys.capabilities,
                d = "touches" in cc.sys.capabilities,
                e = !1;
            if (cc.sys.isMobile && (e = !0), c && (cc._addEventListener(window, "mousedown", function() {
                b._mousePressed = !0
            }, !1), cc._addEventListener(window, "mouseup", function(c) {
                if (!e) {
                    var d = b._mousePressed;
                    if (b._mousePressed = !1, d) {
                        var f = b.getHTMLElementPosition(a),
                            g = b.getPointByEvent(c, f);
                        if (!cc.rectContainsPoint(new cc.Rect(f.left, f.top, f.width, f.height), g)) {
                            b.handleTouchesEnd([b.getTouchByXY(g.x, g.y, f)]);
                            var h = b.getMouseEvent(g, f, cc.EventMouse.UP);
                            h.setButton(c.button), cc.eventManager.dispatchEvent(h)
                        }
                    }
                }
            }, !1), cc._addEventListener(a, "mousedown", function(c) {
                if (!e) {
                    b._mousePressed = !0;
                    var d = b.getHTMLElementPosition(a),
                        f = b.getPointByEvent(c, d);
                    b.handleTouchesBegin([b.getTouchByXY(f.x, f.y, d)]);
                    var g = b.getMouseEvent(f, d, cc.EventMouse.DOWN);
                    g.setButton(c.button), cc.eventManager.dispatchEvent(g), c.stopPropagation(), c.preventDefault(), a.focus()
                }
            }, !1), cc._addEventListener(a, "mouseup", function(c) {
                if (!e) {
                    b._mousePressed = !1;
                    var d = b.getHTMLElementPosition(a),
                        f = b.getPointByEvent(c, d);
                    b.handleTouchesEnd([b.getTouchByXY(f.x, f.y, d)]);
                    var g = b.getMouseEvent(f, d, cc.EventMouse.UP);
                    g.setButton(c.button), cc.eventManager.dispatchEvent(g), c.stopPropagation(), c.preventDefault()
                }
            }, !1), cc._addEventListener(a, "mousemove", function(c) {
                if (!e) {
                    var d = b.getHTMLElementPosition(a),
                        f = b.getPointByEvent(c, d);
                    b.handleTouchesMove([b.getTouchByXY(f.x, f.y, d)]);
                    var g = b.getMouseEvent(f, d, cc.EventMouse.MOVE);
                    g.setButton(b._mousePressed ? c.button : null), cc.eventManager.dispatchEvent(g), c.stopPropagation(), c.preventDefault()
                }
            }, !1), cc._addEventListener(a, "mousewheel", function(c) {
                var d = b.getHTMLElementPosition(a),
                    e = b.getPointByEvent(c, d),
                    f = b.getMouseEvent(e, d, cc.EventMouse.SCROLL);
                f.setButton(c.button), f.setScrollData(0, c.wheelDelta), cc.eventManager.dispatchEvent(f), c.stopPropagation(), c.preventDefault()
            }, !1), cc._addEventListener(a, "DOMMouseScroll", function(c) {
                var d = b.getHTMLElementPosition(a),
                    e = b.getPointByEvent(c, d),
                    f = b.getMouseEvent(e, d, cc.EventMouse.SCROLL);
                f.setButton(c.button), f.setScrollData(0, -120 * c.detail), cc.eventManager.dispatchEvent(f), c.stopPropagation(), c.preventDefault()
            }, !1)), window.navigator.msPointerEnabled) {
                var f = {
                    MSPointerDown: b.handleTouchesBegin,
                    MSPointerMove: b.handleTouchesMove,
                    MSPointerUp: b.handleTouchesEnd,
                    MSPointerCancel: b.handleTouchesCancel
                };
                for (var g in f)! function(c, d) {
                    cc._addEventListener(a, c, function(c) {
                        var e = b.getHTMLElementPosition(a);
                        e.left -= document.documentElement.scrollLeft, e.top -= document.documentElement.scrollTop, d.call(b, [b.getTouchByXY(c.clientX, c.clientY, e)]), c.stopPropagation()
                    }, !1)
                }(g, f[g])
            }
            d && (cc._addEventListener(a, "touchstart", function(c) {
                if (c.changedTouches) {
                    var d = b.getHTMLElementPosition(a);
                    d.left -= document.body.scrollLeft, d.top -= document.body.scrollTop, b.handleTouchesBegin(b.getTouchesByEvent(c, d)), c.stopPropagation(), c.preventDefault(), a.focus()
                }
            }, !1), cc._addEventListener(a, "touchmove", function(c) {
                if (c.changedTouches) {
                    var d = b.getHTMLElementPosition(a);
                    d.left -= document.body.scrollLeft, d.top -= document.body.scrollTop, b.handleTouchesMove(b.getTouchesByEvent(c, d)), c.stopPropagation(), c.preventDefault()
                }
            }, !1), cc._addEventListener(a, "touchend", function(c) {
                if (c.changedTouches) {
                    var d = b.getHTMLElementPosition(a);
                    d.left -= document.body.scrollLeft, d.top -= document.body.scrollTop, b.handleTouchesEnd(b.getTouchesByEvent(c, d)), c.stopPropagation(), c.preventDefault()
                }
            }, !1), cc._addEventListener(a, "touchcancel", function(c) {
                if (c.changedTouches) {
                    var d = b.getHTMLElementPosition(a);
                    d.left -= document.body.scrollLeft, d.top -= document.body.scrollTop, b.handleTouchesCancel(b.getTouchesByEvent(c, d)), c.stopPropagation(), c.preventDefault()
                }
            }, !1)), this._registerKeyboardEvent(), this._registerAccelerometerEvent(), this._isRegisterEvent = !0
        }
    },
    _registerKeyboardEvent: function() {},
    _registerAccelerometerEvent: function() {},
    update: function(a) {
        this._accelCurTime > this._accelInterval && (this._accelCurTime -= this._accelInterval, cc.eventManager.dispatchEvent(new cc.EventAcceleration(this._acceleration))), this._accelCurTime += a
    }
}, cc.AffineTransform = function(a, b, c, d, e, f) {
    this.a = a, this.b = b, this.c = c, this.d = d, this.tx = e, this.ty = f
}, cc.affineTransformMake = function(a, b, c, d, e, f) {
    return {
        a: a,
        b: b,
        c: c,
        d: d,
        tx: e,
        ty: f
    }
}, cc.pointApplyAffineTransform = function(a, b) {
    return {
        x: b.a * a.x + b.c * a.y + b.tx,
        y: b.b * a.x + b.d * a.y + b.ty
    }
}, cc._pointApplyAffineTransform = function(a, b, c) {
    return {
        x: c.a * a + c.c * b + c.tx,
        y: c.b * a + c.d * b + c.ty
    }
}, cc.sizeApplyAffineTransform = function(a, b) {
    return {
        width: b.a * a.width + b.c * a.height,
        height: b.b * a.width + b.d * a.height
    }
}, cc.affineTransformMakeIdentity = function() {
    return {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
    }
}, cc.affineTransformIdentity = function() {
    return {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
    }
}, cc.rectApplyAffineTransform = function(a, b) {
    var c = cc.rectGetMinY(a),
        d = cc.rectGetMinX(a),
        e = cc.rectGetMaxX(a),
        f = cc.rectGetMaxY(a),
        g = cc._pointApplyAffineTransform(d, c, b),
        h = cc._pointApplyAffineTransform(e, c, b),
        i = cc._pointApplyAffineTransform(d, f, b),
        j = cc._pointApplyAffineTransform(e, f, b),
        k = Math.min(g.x, h.x, i.x, j.x),
        l = Math.max(g.x, h.x, i.x, j.x),
        m = Math.min(g.y, h.y, i.y, j.y),
        n = Math.max(g.y, h.y, i.y, j.y);
    return cc.rect(k, m, l - k, n - m)
}, cc._rectApplyAffineTransformIn = function(a, b) {
    var c = cc.rectGetMinY(a),
        d = cc.rectGetMinX(a),
        e = cc.rectGetMaxX(a),
        f = cc.rectGetMaxY(a),
        g = cc._pointApplyAffineTransform(d, c, b),
        h = cc._pointApplyAffineTransform(e, c, b),
        i = cc._pointApplyAffineTransform(d, f, b),
        j = cc._pointApplyAffineTransform(e, f, b),
        k = Math.min(g.x, h.x, i.x, j.x),
        l = Math.max(g.x, h.x, i.x, j.x),
        m = Math.min(g.y, h.y, i.y, j.y),
        n = Math.max(g.y, h.y, i.y, j.y);
    return a.x = k, a.y = m, a.width = l - k, a.height = n - m, a
}, cc.affineTransformTranslate = function(a, b, c) {
    return {
        a: a.a,
        b: a.b,
        c: a.c,
        d: a.d,
        tx: a.tx + a.a * b + a.c * c,
        ty: a.ty + a.b * b + a.d * c
    }
}, cc.affineTransformScale = function(a, b, c) {
    return {
        a: a.a * b,
        b: a.b * b,
        c: a.c * c,
        d: a.d * c,
        tx: a.tx,
        ty: a.ty
    }
}, cc.affineTransformRotate = function(a, b) {
    var c = Math.sin(b),
        d = Math.cos(b);
    return {
        a: a.a * d + a.c * c,
        b: a.b * d + a.d * c,
        c: a.c * d - a.a * c,
        d: a.d * d - a.b * c,
        tx: a.tx,
        ty: a.ty
    }
}, cc.affineTransformConcat = function(a, b) {
    return {
        a: a.a * b.a + a.b * b.c,
        b: a.a * b.b + a.b * b.d,
        c: a.c * b.a + a.d * b.c,
        d: a.c * b.b + a.d * b.d,
        tx: a.tx * b.a + a.ty * b.c + b.tx,
        ty: a.tx * b.b + a.ty * b.d + b.ty
    }
}, cc.affineTransformEqualToTransform = function(a, b) {
    return a.a === b.a && a.b === b.b && a.c === b.c && a.d === b.d && a.tx === b.tx && a.ty === b.ty
}, cc.affineTransformInvert = function(a) {
    var b = 1 / (a.a * a.d - a.b * a.c);
    return {
        a: b * a.d,
        b: -b * a.b,
        c: -b * a.c,
        d: b * a.a,
        tx: b * (a.c * a.ty - a.d * a.tx),
        ty: b * (a.b * a.tx - a.a * a.ty)
    }
}, cc.POINT_EPSILON = parseFloat("1.192092896e-07F"), cc.pNeg = function(a) {
    return cc.p(-a.x, -a.y)
}, cc.pAdd = function(a, b) {
    return cc.p(a.x + b.x, a.y + b.y)
}, cc.pSub = function(a, b) {
    return cc.p(a.x - b.x, a.y - b.y)
}, cc.pMult = function(a, b) {
    return cc.p(a.x * b, a.y * b)
}, cc.pMidpoint = function(a, b) {
    return cc.pMult(cc.pAdd(a, b), .5)
}, cc.pDot = function(a, b) {
    return a.x * b.x + a.y * b.y
}, cc.pCross = function(a, b) {
    return a.x * b.y - a.y * b.x
}, cc.pPerp = function(a) {
    return cc.p(-a.y, a.x)
}, cc.pRPerp = function(a) {
    return cc.p(a.y, -a.x)
}, cc.pProject = function(a, b) {
    return cc.pMult(b, cc.pDot(a, b) / cc.pDot(b, b))
}, cc.pRotate = function(a, b) {
    return cc.p(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x)
}, cc.pUnrotate = function(a, b) {
    return cc.p(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y)
}, cc.pLengthSQ = function(a) {
    return cc.pDot(a, a)
}, cc.pDistanceSQ = function(a, b) {
    return cc.pLengthSQ(cc.pSub(a, b))
}, cc.pLength = function(a) {
    return Math.sqrt(cc.pLengthSQ(a))
}, cc.pDistance = function(a, b) {
    return cc.pLength(cc.pSub(a, b))
}, cc.pNormalize = function(a) {
    return cc.pMult(a, 1 / cc.pLength(a))
}, cc.pForAngle = function(a) {
    return cc.p(Math.cos(a), Math.sin(a))
}, cc.pToAngle = function(a) {
    return Math.atan2(a.y, a.x)
}, cc.clampf = function(a, b, c) {
    if (b > c) {
        var d = b;
        b = c, c = d
    }
    return b > a ? b : c > a ? a : c
}, cc.pClamp = function(a, b, c) {
    return cc.p(cc.clampf(a.x, b.x, c.x), cc.clampf(a.y, b.y, c.y))
}, cc.pFromSize = function(a) {
    return cc.p(a.width, a.height)
}, cc.pCompOp = function(a, b) {
    return cc.p(b(a.x), b(a.y))
}, cc.pLerp = function(a, b, c) {
    return cc.pAdd(cc.pMult(a, 1 - c), cc.pMult(b, c))
}, cc.pFuzzyEqual = function(a, b, c) {
    return a.x - c <= b.x && b.x <= a.x + c && a.y - c <= b.y && b.y <= a.y + c ? !0 : !1
}, cc.pCompMult = function(a, b) {
    return cc.p(a.x * b.x, a.y * b.y)
}, cc.pAngleSigned = function(a, b) {
    var c = cc.pNormalize(a),
        d = cc.pNormalize(b),
        e = Math.atan2(c.x * d.y - c.y * d.x, cc.pDot(c, d));
    return Math.abs(e) < cc.POINT_EPSILON ? 0 : e
}, cc.pAngle = function(a, b) {
    var c = Math.acos(cc.pDot(cc.pNormalize(a), cc.pNormalize(b)));
    return Math.abs(c) < cc.POINT_EPSILON ? 0 : c
}, cc.pRotateByAngle = function(a, b, c) {
    var d = cc.pSub(a, b),
        e = Math.cos(c),
        f = Math.sin(c),
        g = d.x;
    return d.x = g * e - d.y * f + b.x, d.y = g * f + d.y * e + b.y, d
}, cc.pLineIntersect = function(a, b, c, d, e) {
    if (a.x == b.x && a.y == b.y || c.x == d.x && c.y == d.y) return !1;
    var f = b.x - a.x,
        g = b.y - a.y,
        h = d.x - c.x,
        i = d.y - c.y,
        j = a.x - c.x,
        k = a.y - c.y,
        l = i * f - h * g;
    return e.x = h * k - i * j, e.y = f * k - g * j, 0 == l ? 0 == e.x || 0 == e.y ? !0 : !1 : (e.x = e.x / l, e.y = e.y / l, !0)
}, cc.pSegmentIntersect = function(a, b, c, d) {
    var e = cc.p(0, 0);
    return cc.pLineIntersect(a, b, c, d, e) && e.x >= 0 && e.x <= 1 && e.y >= 0 && e.y <= 1 ? !0 : !1
}, cc.pIntersectPoint = function(a, b, c, d) {
    var e = cc.p(0, 0);
    if (cc.pLineIntersect(a, b, c, d, e)) {
        var f = cc.p(0, 0);
        return f.x = a.x + e.x * (b.x - a.x), f.y = a.y + e.x * (b.y - a.y), f
    }
    return cc.p(0, 0)
}, cc.pSameAs = function(a, b) {
    return null != a && null != b ? a.x == b.x && a.y == b.y : !1
}, cc.pZeroIn = function(a) {
    a.x = 0, a.y = 0
}, cc.pIn = function(a, b) {
    a.x = b.x, a.y = b.y
}, cc.pMultIn = function(a, b) {
    a.x *= b, a.y *= b
}, cc.pSubIn = function(a, b) {
    a.x -= b.x, a.y -= b.y
}, cc.pAddIn = function(a, b) {
    a.x += b.x, a.y += b.y
}, cc.pNormalizeIn = function(a) {
    cc.pMultIn(a, 1 / Math.sqrt(a.x * a.x + a.y * a.y))
}, cc.Touch = cc.Class.extend({
    _point: null,
    _prevPoint: null,
    _id: 0,
    _startPointCaptured: !1,
    _startPoint: null,
    ctor: function(a, b, c) {
        this._point = cc.p(a || 0, b || 0), this._id = c || 0
    },
    getLocation: function() {
        return {
            x: this._point.x,
            y: this._point.y
        }
    },
    getLocationX: function() {
        return this._point.x
    },
    getLocationY: function() {
        return this._point.y
    },
    getPreviousLocation: function() {
        return {
            x: this._prevPoint.x,
            y: this._prevPoint.y
        }
    },
    getStartLocation: function() {
        return {
            x: this._startPoint.x,
            y: this._startPoint.y
        }
    },
    getDelta: function() {
        return cc.pSub(this._point, this._prevPoint)
    },
    getLocationInView: function() {
        return {
            x: this._point.x,
            y: this._point.y
        }
    },
    getPreviousLocationInView: function() {
        return {
            x: this._prevPoint.x,
            y: this._prevPoint.y
        }
    },
    getStartLocationInView: function() {
        return {
            x: this._startPoint.x,
            y: this._startPoint.y
        }
    },
    getID: function() {
        return this._id
    },
    getId: function() {
        return cc.log("getId is deprecated. Please use getID instead."), this._id
    },
    setTouchInfo: function(a, b, c) {
        this._prevPoint = this._point, this._point = cc.p(b || 0, c || 0), this._id = a, this._startPointCaptured || (this._startPoint = cc.p(this._point), this._startPointCaptured = !0)
    },
    _setPoint: function(a, b) {
        void 0 === b ? (this._point.x = a.x, this._point.y = a.y) : (this._point.x = a, this._point.y = b)
    },
    _setPrevPoint: function(a, b) {
        this._prevPoint = void 0 === b ? cc.p(a.x, a.y) : cc.p(a || 0, b || 0)
    }
}), cc.Event = cc.Class.extend({
    _type: 0,
    _isStopped: !1,
    _currentTarget: null,
    _setCurrentTarget: function(a) {
        this._currentTarget = a
    },
    ctor: function(a) {
        this._type = a
    },
    getType: function() {
        return this._type
    },
    stopPropagation: function() {
        this._isStopped = !0
    },
    isStopped: function() {
        return this._isStopped
    },
    getCurrentTarget: function() {
        return this._currentTarget
    }
}), cc.Event.TOUCH = 0, cc.Event.KEYBOARD = 1, cc.Event.ACCELERATION = 2, cc.Event.MOUSE = 3, cc.Event.CUSTOM = 4, cc.EventCustom = cc.Event.extend({
    _eventName: null,
    _userData: null,
    ctor: function(a) {
        cc.Event.prototype.ctor.call(this, cc.Event.CUSTOM), this._eventName = a
    },
    setUserData: function(a) {
        this._userData = a
    },
    getUserData: function() {
        return this._userData
    },
    getEventName: function() {
        return this._eventName
    }
}), cc.EventMouse = cc.Event.extend({
    _eventType: 0,
    _button: 0,
    _x: 0,
    _y: 0,
    _prevX: 0,
    _prevY: 0,
    _scrollX: 0,
    _scrollY: 0,
    ctor: function(a) {
        cc.Event.prototype.ctor.call(this, cc.Event.MOUSE), this._eventType = a
    },
    setScrollData: function(a, b) {
        this._scrollX = a, this._scrollY = b
    },
    getScrollX: function() {
        return this._scrollX
    },
    getScrollY: function() {
        return this._scrollY
    },
    setLocation: function(a, b) {
        this._x = a, this._y = b
    },
    getLocation: function() {
        return {
            x: this._x,
            y: this._y
        }
    },
    getLocationInView: function() {
        return {
            x: this._x,
            y: cc.view._designResolutionSize.height - this._y
        }
    },
    _setPrevCursor: function(a, b) {
        this._prevX = a, this._prevY = b
    },
    getDelta: function() {
        return {
            x: this._x - this._prevX,
            y: this._y - this._prevY
        }
    },
    getDeltaX: function() {
        return this._x - this._prevX
    },
    getDeltaY: function() {
        return this._y - this._prevY
    },
    setButton: function(a) {
        this._button = a
    },
    getButton: function() {
        return this._button
    },
    getLocationX: function() {
        return this._x
    },
    getLocationY: function() {
        return this._y
    }
}), cc.EventMouse.NONE = 0, cc.EventMouse.DOWN = 1, cc.EventMouse.UP = 2, cc.EventMouse.MOVE = 3, cc.EventMouse.SCROLL = 4, cc.EventMouse.BUTTON_LEFT = 0, cc.EventMouse.BUTTON_RIGHT = 2, cc.EventMouse.BUTTON_MIDDLE = 1, cc.EventMouse.BUTTON_4 = 3, cc.EventMouse.BUTTON_5 = 4, cc.EventMouse.BUTTON_6 = 5, cc.EventMouse.BUTTON_7 = 6, cc.EventMouse.BUTTON_8 = 7, cc.EventTouch = cc.Event.extend({
    _eventCode: 0,
    _touches: null,
    ctor: function(a) {
        cc.Event.prototype.ctor.call(this, cc.Event.TOUCH), this._touches = a || []
    },
    getEventCode: function() {
        return this._eventCode
    },
    getTouches: function() {
        return this._touches
    },
    _setEventCode: function(a) {
        this._eventCode = a
    },
    _setTouches: function(a) {
        this._touches = a
    }
}), cc.EventTouch.MAX_TOUCHES = 5, cc.EventTouch.EventCode = {
    BEGAN: 0,
    MOVED: 1,
    ENDED: 2,
    CANCELLED: 3
}, cc.EventListener = cc.Class.extend({
    _onEvent: null,
    _type: 0,
    _listenerID: null,
    _registered: !1,
    _fixedPriority: 0,
    _node: null,
    _paused: !0,
    _isEnabled: !0,
    ctor: function(a, b, c) {
        this._onEvent = c, this._type = a || 0, this._listenerID = b || ""
    },
    _setPaused: function(a) {
        this._paused = a
    },
    _isPaused: function() {
        return this._paused
    },
    _setRegistered: function(a) {
        this._registered = a
    },
    _isRegistered: function() {
        return this._registered
    },
    _getType: function() {
        return this._type
    },
    _getListenerID: function() {
        return this._listenerID
    },
    _setFixedPriority: function(a) {
        this._fixedPriority = a
    },
    _getFixedPriority: function() {
        return this._fixedPriority
    },
    _setSceneGraphPriority: function(a) {
        this._node = a
    },
    _getSceneGraphPriority: function() {
        return this._node
    },
    checkAvailable: function() {
        return null != this._onEvent
    },
    clone: function() {
        return null
    },
    setEnabled: function(a) {
        this._isEnabled = a
    },
    isEnabled: function() {
        return this._isEnabled
    },
    retain: function() {},
    release: function() {}
}), cc.EventListener.UNKNOWN = 0, cc.EventListener.TOUCH_ONE_BY_ONE = 1, cc.EventListener.TOUCH_ALL_AT_ONCE = 2, cc.EventListener.KEYBOARD = 3, cc.EventListener.MOUSE = 4, cc.EventListener.ACCELERATION = 5, cc.EventListener.CUSTOM = 6, cc._EventListenerCustom = cc.EventListener.extend({
    _onCustomEvent: null,
    ctor: function(a, b) {
        this._onCustomEvent = b;
        var c = this,
            d = function(a) {
                null != c._onCustomEvent && c._onCustomEvent(a)
            };
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.CUSTOM, a, d)
    },
    checkAvailable: function() {
        return cc.EventListener.prototype.checkAvailable.call(this) && null != this._onCustomEvent
    },
    clone: function() {
        return new cc._EventListenerCustom(this._listenerID, this._onCustomEvent)
    }
}), cc._EventListenerCustom.create = function(a, b) {
    return new cc._EventListenerCustom(a, b)
}, cc._EventListenerMouse = cc.EventListener.extend({
    onMouseDown: null,
    onMouseUp: null,
    onMouseMove: null,
    onMouseScroll: null,
    ctor: function() {
        var a = this,
            b = function(b) {
                var c = cc.EventMouse;
                switch (b._eventType) {
                    case c.DOWN:
                        a.onMouseDown && a.onMouseDown(b);
                        break;
                    case c.UP:
                        a.onMouseUp && a.onMouseUp(b);
                        break;
                    case c.MOVE:
                        a.onMouseMove && a.onMouseMove(b);
                        break;
                    case c.SCROLL:
                        a.onMouseScroll && a.onMouseScroll(b)
                }
            };
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.MOUSE, cc._EventListenerMouse.LISTENER_ID, b)
    },
    clone: function() {
        var a = new cc._EventListenerMouse;
        return a.onMouseDown = this.onMouseDown, a.onMouseUp = this.onMouseUp, a.onMouseMove = this.onMouseMove, a.onMouseScroll = this.onMouseScroll, a
    },
    checkAvailable: function() {
        return !0
    }
}), cc._EventListenerMouse.LISTENER_ID = "__cc_mouse", cc._EventListenerMouse.create = function() {
    return new cc._EventListenerMouse
}, cc._EventListenerTouchOneByOne = cc.EventListener.extend({
    _claimedTouches: null,
    swallowTouches: !1,
    onTouchBegan: null,
    onTouchMoved: null,
    onTouchEnded: null,
    onTouchCancelled: null,
    ctor: function() {
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ONE_BY_ONE, cc._EventListenerTouchOneByOne.LISTENER_ID, null), this._claimedTouches = []
    },
    setSwallowTouches: function(a) {
        this.swallowTouches = a
    },
    clone: function() {
        var a = new cc._EventListenerTouchOneByOne;
        return a.onTouchBegan = this.onTouchBegan, a.onTouchMoved = this.onTouchMoved, a.onTouchEnded = this.onTouchEnded, a.onTouchCancelled = this.onTouchCancelled, a.swallowTouches = this.swallowTouches, a
    },
    checkAvailable: function() {
        return this.onTouchBegan ? !0 : (cc.log(cc._LogInfos._EventListenerTouchOneByOne_checkAvailable), !1)
    }
}), cc._EventListenerTouchOneByOne.LISTENER_ID = "__cc_touch_one_by_one", cc._EventListenerTouchOneByOne.create = function() {
    return new cc._EventListenerTouchOneByOne
}, cc._EventListenerTouchAllAtOnce = cc.EventListener.extend({
    onTouchesBegan: null,
    onTouchesMoved: null,
    onTouchesEnded: null,
    onTouchesCancelled: null,
    ctor: function() {
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ALL_AT_ONCE, cc._EventListenerTouchAllAtOnce.LISTENER_ID, null)
    },
    clone: function() {
        var a = new cc._EventListenerTouchAllAtOnce;
        return a.onTouchesBegan = this.onTouchesBegan, a.onTouchesMoved = this.onTouchesMoved, a.onTouchesEnded = this.onTouchesEnded, a.onTouchesCancelled = this.onTouchesCancelled, a
    },
    checkAvailable: function() {
        return null == this.onTouchesBegan && null == this.onTouchesMoved && null == this.onTouchesEnded && null == this.onTouchesCancelled ? (cc.log(cc._LogInfos._EventListenerTouchAllAtOnce_checkAvailable), !1) : !0
    }
}), cc._EventListenerTouchAllAtOnce.LISTENER_ID = "__cc_touch_all_at_once", cc._EventListenerTouchAllAtOnce.create = function() {
    return new cc._EventListenerTouchAllAtOnce
}, cc.EventListener.create = function(a) {
    cc.assert(a && a.event, cc._LogInfos.EventListener_create);
    var b = a.event;
    delete a.event;
    var c = null;
    b === cc.EventListener.TOUCH_ONE_BY_ONE ? c = new cc._EventListenerTouchOneByOne : b === cc.EventListener.TOUCH_ALL_AT_ONCE ? c = new cc._EventListenerTouchAllAtOnce : b === cc.EventListener.MOUSE ? c = new cc._EventListenerMouse : b === cc.EventListener.CUSTOM ? (c = new cc._EventListenerCustom(a.eventName, a.callback), delete a.eventName, delete a.callback) : b === cc.EventListener.KEYBOARD ? c = new cc._EventListenerKeyboard : b === cc.EventListener.ACCELERATION && (c = new cc._EventListenerAcceleration(a.callback), delete a.callback);
    for (var d in a) c[d] = a[d];
    return c
}, cc._EventListenerVector = cc.Class.extend({
    _fixedListeners: null,
    _sceneGraphListeners: null,
    gt0Index: 0,
    ctor: function() {
        this._fixedListeners = [], this._sceneGraphListeners = []
    },
    size: function() {
        return this._fixedListeners.length + this._sceneGraphListeners.length
    },
    empty: function() {
        return 0 === this._fixedListeners.length && 0 === this._sceneGraphListeners.length
    },
    push: function(a) {
        0 == a._getFixedPriority() ? this._sceneGraphListeners.push(a) : this._fixedListeners.push(a)
    },
    clearSceneGraphListeners: function() {
        this._sceneGraphListeners.length = 0
    },
    clearFixedListeners: function() {
        this._fixedListeners.length = 0
    },
    clear: function() {
        this._sceneGraphListeners.length = 0, this._fixedListeners.length = 0
    },
    getFixedPriorityListeners: function() {
        return this._fixedListeners
    },
    getSceneGraphPriorityListeners: function() {
        return this._sceneGraphListeners
    }
}), cc.__getListenerID = function(a) {
    var b = cc.Event,
        c = a.getType();
    return c === b.ACCELERATION ? cc._EventListenerAcceleration.LISTENER_ID : c === b.CUSTOM ? a.getEventName() : c === b.KEYBOARD ? cc._EventListenerKeyboard.LISTENER_ID : c === b.MOUSE ? cc._EventListenerMouse.LISTENER_ID : (c === b.TOUCH && cc.log(cc._LogInfos.__getListenerID), "")
}, cc.eventManager = {
    DIRTY_NONE: 0,
    DIRTY_FIXED_PRIORITY: 1,
    DIRTY_SCENE_GRAPH_PRIORITY: 2,
    DIRTY_ALL: 3,
    _listenersMap: {},
    _priorityDirtyFlagMap: {},
    _nodeListenersMap: {},
    _nodePriorityMap: {},
    _globalZOrderNodeMap: {},
    _toAddedListeners: [],
    _dirtyNodes: [],
    _inDispatch: 0,
    _isEnabled: !1,
    _nodePriorityIndex: 0,
    _internalCustomListenerIDs: [cc.game.EVENT_HIDE, cc.game.EVENT_SHOW],
    _setDirtyForNode: function(a) {
        null != this._nodeListenersMap[a.__instanceId] && this._dirtyNodes.push(a);
        for (var b = a.getChildren(), c = 0, d = b.length; d > c; c++) this._setDirtyForNode(b[c])
    },
    pauseTarget: function(a, b) {
        var c, d, e = this._nodeListenersMap[a.__instanceId];
        if (e)
            for (c = 0, d = e.length; d > c; c++) e[c]._setPaused(!0);
        if (b === !0) {
            var f = a.getChildren();
            for (c = 0, d = f.length; d > c; c++) this.pauseTarget(f[c], !0)
        }
    },
    resumeTarget: function(a, b) {
        var c, d, e = this._nodeListenersMap[a.__instanceId];
        if (e)
            for (c = 0, d = e.length; d > c; c++) e[c]._setPaused(!1);
        if (this._setDirtyForNode(a), b === !0) {
            var f = a.getChildren();
            for (c = 0, d = f.length; d > c; c++) this.resumeTarget(f[c], !0)
        }
    },
    _addListener: function(a) {
        0 === this._inDispatch ? this._forceAddEventListener(a) : this._toAddedListeners.push(a)
    },
    _forceAddEventListener: function(a) {
        var b = a._getListenerID(),
            c = this._listenersMap[b];
        if (c || (c = new cc._EventListenerVector, this._listenersMap[b] = c), c.push(a), 0 == a._getFixedPriority()) {
            this._setDirty(b, this.DIRTY_SCENE_GRAPH_PRIORITY);
            var d = a._getSceneGraphPriority();
            null == d && cc.log(cc._LogInfos.eventManager__forceAddEventListener), this._associateNodeAndEventListener(d, a), d.isRunning() && this.resumeTarget(d)
        } else this._setDirty(b, this.DIRTY_FIXED_PRIORITY)
    },
    _getListeners: function(a) {
        return this._listenersMap[a]
    },
    _updateDirtyFlagForSceneGraph: function() {
        if (0 != this._dirtyNodes.length) {
            for (var a, b, c = this._dirtyNodes, d = this._nodeListenersMap, e = 0, f = c.length; f > e; e++)
                if (a = d[c[e].__instanceId])
                    for (var g = 0, h = a.length; h > g; g++) b = a[g], b && this._setDirty(b._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY);
            this._dirtyNodes.length = 0
        }
    },
    _removeAllListenersInVector: function(a) {
        if (a)
            for (var b, c = 0; c < a.length;) b = a[c], b._setRegistered(!1), null != b._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(b._getSceneGraphPriority(), b), b._setSceneGraphPriority(null)), 0 === this._inDispatch ? cc.arrayRemoveObject(a, b) : ++c
    },
    _removeListenersForListenerID: function(a) {
        var b, c = this._listenersMap[a];
        if (c) {
            var d = c.getFixedPriorityListeners(),
                e = c.getSceneGraphPriorityListeners();
            this._removeAllListenersInVector(e), this._removeAllListenersInVector(d), delete this._priorityDirtyFlagMap[a], this._inDispatch || (c.clear(), delete this._listenersMap[a])
        }
        var f, g = this._toAddedListeners;
        for (b = 0; b < g.length;) f = g[b], f && f._getListenerID() == a ? cc.arrayRemoveObject(g, f) : ++b
    },
    _sortEventListeners: function(a) {
        var b = this.DIRTY_NONE,
            c = this._priorityDirtyFlagMap;
        if (c[a] && (b = c[a]), b != this.DIRTY_NONE && (c[a] = this.DIRTY_NONE, b & this.DIRTY_FIXED_PRIORITY && this._sortListenersOfFixedPriority(a), b & this.DIRTY_SCENE_GRAPH_PRIORITY)) {
            var d = cc.director.getRunningScene();
            d ? this._sortListenersOfSceneGraphPriority(a, d) : c[a] = this.DIRTY_SCENE_GRAPH_PRIORITY
        }
    },
    _sortListenersOfSceneGraphPriority: function(a, b) {
        var c = this._getListeners(a);
        if (c) {
            var d = c.getSceneGraphPriorityListeners();
            d && 0 !== d.length && (this._nodePriorityIndex = 0, this._nodePriorityMap = {}, this._visitTarget(b, !0), c.getSceneGraphPriorityListeners().sort(this._sortEventListenersOfSceneGraphPriorityDes))
        }
    },
    _sortEventListenersOfSceneGraphPriorityDes: function(a, b) {
        var c = cc.eventManager._nodePriorityMap;
        return a && b && a._getSceneGraphPriority() && b._getSceneGraphPriority() ? c[b._getSceneGraphPriority().__instanceId] - c[a._getSceneGraphPriority().__instanceId] : -1
    },
    _sortListenersOfFixedPriority: function(a) {
        var b = this._listenersMap[a];
        if (b) {
            var c = b.getFixedPriorityListeners();
            if (c && 0 !== c.length) {
                c.sort(this._sortListenersOfFixedPriorityAsc);
                for (var d = 0, e = c.length; e > d && !(c[d]._getFixedPriority() >= 0);)++d;
                b.gt0Index = d
            }
        }
    },
    _sortListenersOfFixedPriorityAsc: function(a, b) {
        return a._getFixedPriority() - b._getFixedPriority()
    },
    _onUpdateListeners: function(a) {
        var b = this._listenersMap[a];
        if (b) {
            var c, d, e = b.getFixedPriorityListeners(),
                f = b.getSceneGraphPriorityListeners();
            if (f)
                for (c = 0; c < f.length;) d = f[c], d._isRegistered() ? ++c : cc.arrayRemoveObject(f, d);
            if (e)
                for (c = 0; c < e.length;) d = e[c], d._isRegistered() ? ++c : cc.arrayRemoveObject(e, d);
            f && 0 === f.length && b.clearSceneGraphListeners(), e && 0 === e.length && b.clearFixedListeners()
        }
    },
    _updateListeners: function(a) {
        var b = this._inDispatch;
        if (cc.assert(b > 0, cc._LogInfos.EventManager__updateListeners), a.getType() == cc.Event.TOUCH ? (this._onUpdateListeners(cc._EventListenerTouchOneByOne.LISTENER_ID), this._onUpdateListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID)) : this._onUpdateListeners(cc.__getListenerID(a)), !(b > 1)) {
            cc.assert(1 == b, cc._LogInfos.EventManager__updateListeners_2);
            var c = this._listenersMap,
                d = this._priorityDirtyFlagMap;
            for (var e in c) c[e].empty() && (delete d[e], delete c[e]);
            var f = this._toAddedListeners;
            if (0 !== f.length) {
                for (var g = 0, h = f.length; h > g; g++) this._forceAddEventListener(f[g]);
                this._toAddedListeners.length = 0
            }
        }
    },
    _onTouchEventCallback: function(a, b) {
        if (!a._isRegistered) return !1;
        var c = b.event,
            d = b.selTouch;
        c._setCurrentTarget(a._node);
        var e, f = !1,
            g = c.getEventCode(),
            h = cc.EventTouch.EventCode;
        return g == h.BEGAN ? a.onTouchBegan && (f = a.onTouchBegan(d, c), f && a._registered && a._claimedTouches.push(d)) : a._claimedTouches.length > 0 && -1 != (e = a._claimedTouches.indexOf(d)) && (f = !0, g === h.MOVED && a.onTouchMoved ? a.onTouchMoved(d, c) : g === h.ENDED ? (a.onTouchEnded && a.onTouchEnded(d, c), a._registered && a._claimedTouches.splice(e, 1)) : g === h.CANCELLED && (a.onTouchCancelled && a.onTouchCancelled(d, c), a._registered && a._claimedTouches.splice(e, 1))), c.isStopped() ? (cc.eventManager._updateListeners(c), !0) : f && a._registered && a.swallowTouches ? (b.needsMutableSet && b.touches.splice(d, 1), !0) : !1
    },
    _dispatchTouchEvent: function(a) {
        this._sortEventListeners(cc._EventListenerTouchOneByOne.LISTENER_ID), this._sortEventListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
        var b = this._getListeners(cc._EventListenerTouchOneByOne.LISTENER_ID),
            c = this._getListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
        if (null != b || null != c) {
            var d = a.getTouches(),
                e = cc.copyArray(d),
                f = {
                    event: a,
                    needsMutableSet: b && c,
                    touches: e,
                    selTouch: null
                };
            if (b)
                for (var g = 0; g < d.length; g++)
                    if (f.selTouch = d[g], this._dispatchEventToListeners(b, this._onTouchEventCallback, f), a.isStopped()) return;
            c && e.length > 0 && (this._dispatchEventToListeners(c, this._onTouchesEventCallback, {
                event: a,
                touches: e
            }), a.isStopped()) || this._updateListeners(a)
        }
    },
    _onTouchesEventCallback: function(a, b) {
        if (!a._registered) return !1;
        var c = cc.EventTouch.EventCode,
            d = b.event,
            e = b.touches,
            f = d.getEventCode();
        return d._setCurrentTarget(a._node), f == c.BEGAN && a.onTouchesBegan ? a.onTouchesBegan(e, d) : f == c.MOVED && a.onTouchesMoved ? a.onTouchesMoved(e, d) : f == c.ENDED && a.onTouchesEnded ? a.onTouchesEnded(e, d) : f == c.CANCELLED && a.onTouchesCancelled && a.onTouchesCancelled(e, d), d.isStopped() ? (cc.eventManager._updateListeners(d), !0) : !1
    },
    _associateNodeAndEventListener: function(a, b) {
        var c = this._nodeListenersMap[a.__instanceId];
        c || (c = [], this._nodeListenersMap[a.__instanceId] = c), c.push(b)
    },
    _dissociateNodeAndEventListener: function(a, b) {
        var c = this._nodeListenersMap[a.__instanceId];
        c && (cc.arrayRemoveObject(c, b), 0 === c.length && delete this._nodeListenersMap[a.__instanceId])
    },
    _dispatchEventToListeners: function(a, b, c) {
        var d, e, f = !1,
            g = a.getFixedPriorityListeners(),
            h = a.getSceneGraphPriorityListeners(),
            i = 0;
        if (g && 0 !== g.length)
            for (; i < a.gt0Index; ++i)
                if (e = g[i], e.isEnabled() && !e._isPaused() && e._isRegistered() && b(e, c)) {
                    f = !0;
                    break
                }
        if (h && !f)
            for (d = 0; d < h.length; d++)
                if (e = h[d], e.isEnabled() && !e._isPaused() && e._isRegistered() && b(e, c)) {
                    f = !0;
                    break
                }
        if (g && !f)
            for (; i < g.length; ++i)
                if (e = g[i], e.isEnabled() && !e._isPaused() && e._isRegistered() && b(e, c)) {
                    f = !0;
                    break
                }
    },
    _setDirty: function(a, b) {
        var c = this._priorityDirtyFlagMap;
        c[a] = null == c[a] ? b : b | c[a]
    },
    _visitTarget: function(a, b) {
        var c = a.getChildren(),
            d = 0,
            e = c.length,
            f = this._globalZOrderNodeMap,
            g = this._nodeListenersMap;
        if (e > 0) {
            for (var h; e > d && (h = c[d], h && h.getLocalZOrder() < 0); d++) this._visitTarget(h, !1);
            for (null != g[a.__instanceId] && (f[a.getGlobalZOrder()] || (f[a.getGlobalZOrder()] = []), f[a.getGlobalZOrder()].push(a.__instanceId)); e > d; d++) h = c[d], h && this._visitTarget(h, !1)
        } else null != g[a.__instanceId] && (f[a.getGlobalZOrder()] || (f[a.getGlobalZOrder()] = []), f[a.getGlobalZOrder()].push(a.__instanceId)); if (b) {
            var i = [];
            for (var j in f) i.push(j);
            i.sort(this._sortNumberAsc);
            var k, l, m = i.length,
                n = this._nodePriorityMap;
            for (d = 0; m > d; d++)
                for (k = f[i[d]], l = 0; l < k.length; l++) n[k[l]] = ++this._nodePriorityIndex;
            this._globalZOrderNodeMap = {}
        }
    },
    _sortNumberAsc: function(a, b) {
        return a - b
    },
    addListener: function(a, b) {
        if (cc.assert(a && b, cc._LogInfos.eventManager_addListener_2), a instanceof cc.EventListener) {
            if (a._isRegistered()) return void cc.log(cc._LogInfos.eventManager_addListener_4)
        } else cc.assert(!cc.isNumber(b), cc._LogInfos.eventManager_addListener_3), a = cc.EventListener.create(a); if (a.checkAvailable()) {
            if (cc.isNumber(b)) {
                if (0 == b) return void cc.log(cc._LogInfos.eventManager_addListener);
                a._setSceneGraphPriority(null), a._setFixedPriority(b), a._setRegistered(!0), a._setPaused(!1), this._addListener(a)
            } else a._setSceneGraphPriority(b), a._setFixedPriority(0), a._setRegistered(!0), this._addListener(a);
            return a
        }
    },
    addCustomListener: function(a, b) {
        var c = new cc._EventListenerCustom(a, b);
        return this.addListener(c, 1), c
    },
    removeListener: function(a) {
        if (null != a) {
            var b, c = this._listenersMap;
            for (var d in c) {
                var e = c[d],
                    f = e.getFixedPriorityListeners(),
                    g = e.getSceneGraphPriorityListeners();
                if (b = this._removeListenerInVector(g, a), b ? this._setDirty(a._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY) : (b = this._removeListenerInVector(f, a), b && this._setDirty(a._getListenerID(), this.DIRTY_FIXED_PRIORITY)), e.empty() && (delete this._priorityDirtyFlagMap[a._getListenerID()], delete c[d]), b) break
            }
            if (!b)
                for (var h = this._toAddedListeners, i = 0, j = h.length; j > i; i++) {
                    var k = h[i];
                    if (k == a) {
                        cc.arrayRemoveObject(h, k), k._setRegistered(!1);
                        break
                    }
                }
        }
    },
    _removeListenerInVector: function(a, b) {
        if (null == a) return !1;
        for (var c = 0, d = a.length; d > c; c++) {
            var e = a[c];
            if (e == b) return e._setRegistered(!1), null != e._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(e._getSceneGraphPriority(), e), e._setSceneGraphPriority(null)), 0 == this._inDispatch && cc.arrayRemoveObject(a, e), !0
        }
        return !1
    },
    removeListeners: function(a, b) {
        var c = this;
        if (a instanceof cc.Node) {
            delete c._nodePriorityMap[a.__instanceId], cc.arrayRemoveObject(c._dirtyNodes, a);
            var d, e = c._nodeListenersMap[a.__instanceId];
            if (e) {
                var f = cc.copyArray(e);
                for (d = 0; d < f.length; d++) c.removeListener(f[d]);
                f.length = 0
            }
            var g = c._toAddedListeners;
            for (d = 0; d < g.length;) {
                var h = g[d];
                h._getSceneGraphPriority() == a ? (h._setSceneGraphPriority(null), h._setRegistered(!1), g.splice(d, 1)) : ++d
            }
            if (b === !0) {
                var i, j = a.getChildren();
                for (d = 0, i = j.length; i > d; d++) c.removeListeners(j[d], !0)
            }
        } else a == cc.EventListener.TOUCH_ONE_BY_ONE ? c._removeListenersForListenerID(cc._EventListenerTouchOneByOne.LISTENER_ID) : a == cc.EventListener.TOUCH_ALL_AT_ONCE ? c._removeListenersForListenerID(cc._EventListenerTouchAllAtOnce.LISTENER_ID) : a == cc.EventListener.MOUSE ? c._removeListenersForListenerID(cc._EventListenerMouse.LISTENER_ID) : a == cc.EventListener.ACCELERATION ? c._removeListenersForListenerID(cc._EventListenerAcceleration.LISTENER_ID) : a == cc.EventListener.KEYBOARD ? c._removeListenersForListenerID(cc._EventListenerKeyboard.LISTENER_ID) : cc.log(cc._LogInfos.eventManager_removeListeners)
    },
    removeCustomListeners: function(a) {
        this._removeListenersForListenerID(a)
    },
    removeAllListeners: function() {
        var a = this._listenersMap,
            b = this._internalCustomListenerIDs;
        for (var c in a) - 1 === b.indexOf(c) && this._removeListenersForListenerID(c)
    },
    setPriority: function(a, b) {
        if (null != a) {
            var c = this._listenersMap;
            for (var d in c) {
                var e = c[d],
                    f = e.getFixedPriorityListeners();
                if (f) {
                    var g = f.indexOf(a);
                    if (-1 != g) return null != a._getSceneGraphPriority() && cc.log(cc._LogInfos.eventManager_setPriority), void(a._getFixedPriority() !== b && (a._setFixedPriority(b), this._setDirty(a._getListenerID(), this.DIRTY_FIXED_PRIORITY)))
                }
            }
        }
    },
    setEnabled: function(a) {
        this._isEnabled = a
    },
    isEnabled: function() {
        return this._isEnabled
    },
    dispatchEvent: function(a) {
        if (this._isEnabled) {
            if (this._updateDirtyFlagForSceneGraph(), this._inDispatch++, !a || !a.getType) throw "event is undefined";
            if (a.getType() == cc.Event.TOUCH) return this._dispatchTouchEvent(a), void this._inDispatch--;
            var b = cc.__getListenerID(a);
            this._sortEventListeners(b);
            var c = this._listenersMap[b];
            null != c && this._dispatchEventToListeners(c, this._onListenerCallback, a), this._updateListeners(a), this._inDispatch--
        }
    },
    _onListenerCallback: function(a, b) {
        return b._setCurrentTarget(a._getSceneGraphPriority()), a._onEvent(b), b.isStopped()
    },
    dispatchCustomEvent: function(a, b) {
        var c = new cc.EventCustom(a);
        c.setUserData(b), this.dispatchEvent(c)
    }
}, cc.EventHelper = function() {}, cc.EventHelper.prototype = {
    constructor: cc.EventHelper,
    apply: function(a) {
        a.addEventListener = cc.EventHelper.prototype.addEventListener, a.hasEventListener = cc.EventHelper.prototype.hasEventListener, a.removeEventListener = cc.EventHelper.prototype.removeEventListener, a.dispatchEvent = cc.EventHelper.prototype.dispatchEvent
    },
    addEventListener: function(a, b, c) {
        void 0 === this._listeners && (this._listeners = {});
        var d = this._listeners;
        void 0 === d[a] && (d[a] = []), this.hasEventListener(a, b, c) || d[a].push({
            callback: b,
            eventTarget: c
        })
    },
    hasEventListener: function(a, b, c) {
        if (void 0 === this._listeners) return !1;
        var d = this._listeners;
        if (void 0 !== d[a])
            for (var e = 0, f = d.length; f > e; e++) {
                var g = d[e];
                if (g.callback == b && g.eventTarget == c) return !0
            }
        return !1
    },
    removeEventListener: function(a, b) {
        if (void 0 !== this._listeners) {
            var c = this._listeners,
                d = c[a];
            if (void 0 !== d)
                for (var e = 0; e < d.length;) {
                    var f = d[e];
                    f.eventTarget == b ? d.splice(e, 1) : e++
                }
        }
    },
    dispatchEvent: function(a, b) {
        if (void 0 !== this._listeners) {
            null == b && (b = !0);
            var c = this._listeners,
                d = c[a];
            if (void 0 !== d) {
                for (var e = [], f = d.length, g = 0; f > g; g++) e[g] = d[g];
                for (g = 0; f > g; g++) e[g].callback.call(e[g].eventTarget, this);
                b && (d.length = 0)
            }
        }
    }
}, cc._tmp.PrototypeCCNode = function() {
    var a = cc.Node.prototype;
    cc.defineGetterSetter(a, "x", a.getPositionX, a.setPositionX), cc.defineGetterSetter(a, "y", a.getPositionY, a.setPositionY), a.width, cc.defineGetterSetter(a, "width", a._getWidth, a._setWidth), a.height, cc.defineGetterSetter(a, "height", a._getHeight, a._setHeight), a.anchorX, cc.defineGetterSetter(a, "anchorX", a._getAnchorX, a._setAnchorX), a.anchorY, cc.defineGetterSetter(a, "anchorY", a._getAnchorY, a._setAnchorY), a.skewX, cc.defineGetterSetter(a, "skewX", a.getSkewX, a.setSkewX), a.skewY, cc.defineGetterSetter(a, "skewY", a.getSkewY, a.setSkewY), a.zIndex, cc.defineGetterSetter(a, "zIndex", a.getLocalZOrder, a.setLocalZOrder), a.vertexZ, cc.defineGetterSetter(a, "vertexZ", a.getVertexZ, a.setVertexZ), a.rotation, cc.defineGetterSetter(a, "rotation", a.getRotation, a.setRotation), a.rotationX, cc.defineGetterSetter(a, "rotationX", a.getRotationX, a.setRotationX), a.rotationY, cc.defineGetterSetter(a, "rotationY", a.getRotationY, a.setRotationY), a.scale, cc.defineGetterSetter(a, "scale", a.getScale, a.setScale), a.scaleX, cc.defineGetterSetter(a, "scaleX", a.getScaleX, a.setScaleX), a.scaleY, cc.defineGetterSetter(a, "scaleY", a.getScaleY, a.setScaleY), a.children, cc.defineGetterSetter(a, "children", a.getChildren), a.childrenCount, cc.defineGetterSetter(a, "childrenCount", a.getChildrenCount), a.parent, cc.defineGetterSetter(a, "parent", a.getParent, a.setParent), a.visible, cc.defineGetterSetter(a, "visible", a.isVisible, a.setVisible), a.running, cc.defineGetterSetter(a, "running", a.isRunning), a.ignoreAnchor, cc.defineGetterSetter(a, "ignoreAnchor", a.isIgnoreAnchorPointForPosition, a.ignoreAnchorPointForPosition), a.tag, a.userData, a.userObject, a.arrivalOrder, a.actionManager, cc.defineGetterSetter(a, "actionManager", a.getActionManager, a.setActionManager), a.scheduler, cc.defineGetterSetter(a, "scheduler", a.getScheduler, a.setScheduler), a.shaderProgram, cc.defineGetterSetter(a, "shaderProgram", a.getShaderProgram, a.setShaderProgram), a.opacity, cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity), a.opacityModifyRGB, cc.defineGetterSetter(a, "opacityModifyRGB", a.isOpacityModifyRGB), a.cascadeOpacity, cc.defineGetterSetter(a, "cascadeOpacity", a.isCascadeOpacityEnabled, a.setCascadeOpacityEnabled), a.color, cc.defineGetterSetter(a, "color", a.getColor, a.setColor), a.cascadeColor, cc.defineGetterSetter(a, "cascadeColor", a.isCascadeColorEnabled, a.setCascadeColorEnabled)
}, cc.NODE_TAG_INVALID = -1, cc.s_globalOrderOfArrival = 1, cc.Node = cc.Class.extend({
    _localZOrder: 0,
    _globalZOrder: 0,
    _vertexZ: 0,
    _rotationX: 0,
    _rotationY: 0,
    _scaleX: 1,
    _scaleY: 1,
    _position: null,
    _normalizedPosition: null,
    _usingNormalizedPosition: !1,
    _normalizedPositionDirty: !1,
    _skewX: 0,
    _skewY: 0,
    _children: null,
    _visible: !0,
    _anchorPoint: null,
    _contentSize: null,
    _running: !1,
    _parent: null,
    _ignoreAnchorPointForPosition: !1,
    tag: cc.NODE_TAG_INVALID,
    userData: null,
    userObject: null,
    _reorderChildDirty: !1,
    _shaderProgram: null,
    arrivalOrder: 0,
    _actionManager: null,
    _scheduler: null,
    _eventDispatcher: null,
    _additionalTransformDirty: !1,
    _additionalTransform: null,
    _componentContainer: null,
    _isTransitionFinished: !1,
    _className: "Node",
    _showNode: !1,
    _name: "",
    _realOpacity: 255,
    _realColor: null,
    _cascadeColorEnabled: !1,
    _cascadeOpacityEnabled: !1,
    _renderCmd: null,
    ctor: function() {
        this._initNode(), this._initRendererCmd()
    },
    _initNode: function() {
        var a = this;
        a._anchorPoint = cc.p(0, 0), a._contentSize = cc.size(0, 0), a._position = cc.p(0, 0), a._normalizedPosition = cc.p(0, 0), a._children = [];
        var b = cc.director;
        a._actionManager = b.getActionManager(), a._scheduler = b.getScheduler(), a._additionalTransform = cc.affineTransformMakeIdentity(), cc.ComponentContainer && (a._componentContainer = new cc.ComponentContainer(a)), this._realOpacity = 255, this._realColor = cc.color(255, 255, 255, 255), this._cascadeColorEnabled = !1, this._cascadeOpacityEnabled = !1
    },
    init: function() {
        return !0
    },
    _arrayMakeObjectsPerformSelector: function(a, b) {
        if (a && 0 !== a.length) {
            var c, d, e = a.length,
                f = cc.Node._stateCallbackType;
            switch (b) {
                case f.onEnter:
                    for (c = 0; e > c; c++) d = a[c], d && d.onEnter();
                    break;
                case f.onExit:
                    for (c = 0; e > c; c++) d = a[c], d && d.onExit();
                    break;
                case f.onEnterTransitionDidFinish:
                    for (c = 0; e > c; c++) d = a[c], d && d.onEnterTransitionDidFinish();
                    break;
                case f.cleanup:
                    for (c = 0; e > c; c++) d = a[c], d && d.cleanup();
                    break;
                case f.updateTransform:
                    for (c = 0; e > c; c++) d = a[c], d && d.updateTransform();
                    break;
                case f.onExitTransitionDidStart:
                    for (c = 0; e > c; c++) d = a[c], d && d.onExitTransitionDidStart();
                    break;
                case f.sortAllChildren:
                    for (c = 0; e > c; c++) d = a[c], d && d.sortAllChildren();
                    break;
                default:
                    cc.assert(0, cc._LogInfos.Node__arrayMakeObjectsPerformSelector)
            }
        }
    },
    attr: function(a) {
        for (var b in a) this[b] = a[b]
    },
    getSkewX: function() {
        return this._skewX
    },
    setSkewX: function(a) {
        this._skewX = a, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getSkewY: function() {
        return this._skewY
    },
    setSkewY: function(a) {
        this._skewY = a, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    setLocalZOrder: function(a) {
        this._localZOrder = a, this._parent && this._parent.reorderChild(this, a), cc.eventManager._setDirtyForNode(this)
    },
    _setLocalZOrder: function(a) {
        this._localZOrder = a
    },
    getLocalZOrder: function() {
        return this._localZOrder
    },
    getZOrder: function() {
        return cc.log(cc._LogInfos.Node_getZOrder), this.getLocalZOrder()
    },
    setZOrder: function(a) {
        cc.log(cc._LogInfos.Node_setZOrder), this.setLocalZOrder(a)
    },
    setGlobalZOrder: function(a) {
        this._globalZOrder != a && (this._globalZOrder = a, cc.eventManager._setDirtyForNode(this))
    },
    getGlobalZOrder: function() {
        return this._globalZOrder
    },
    getVertexZ: function() {
        return this._vertexZ
    },
    setVertexZ: function(a) {
        this._vertexZ = a
    },
    getRotation: function() {
        return this._rotationX !== this._rotationY && cc.log(cc._LogInfos.Node_getRotation), this._rotationX
    },
    setRotation: function(a) {
        this._rotationX = this._rotationY = a, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getRotationX: function() {
        return this._rotationX
    },
    setRotationX: function(a) {
        this._rotationX = a, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getRotationY: function() {
        return this._rotationY
    },
    setRotationY: function(a) {
        this._rotationY = a, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getScale: function() {
        return this._scaleX !== this._scaleY && cc.log(cc._LogInfos.Node_getScale), this._scaleX
    },
    setScale: function(a, b) {
        this._scaleX = a, this._scaleY = b || 0 === b ? b : a, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getScaleX: function() {
        return this._scaleX
    },
    setScaleX: function(a) {
        this._scaleX = a, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getScaleY: function() {
        return this._scaleY
    },
    setScaleY: function(a) {
        this._scaleY = a, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    setPosition: function(a, b) {
        var c = this._position;
        void 0 === b ? (c.x = a.x, c.y = a.y) : (c.x = a, c.y = b), this._usingNormalizedPosition = !1, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    setNormalizedPosition: function(a, b) {
        var c = this._normalizedPosition;
        void 0 === b ? (c.x = a.x, c.y = a.y) : (c.x = a, c.y = b), this._normalizedPositionDirty = this._usingNormalizedPosition = !0, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getPosition: function() {
        return cc.p(this._position)
    },
    getNormalizedPosition: function() {
        return cc.p(this._normalizedPosition)
    },
    getPositionX: function() {
        return this._position.x
    },
    setPositionX: function(a) {
        this._position.x = a, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getPositionY: function() {
        return this._position.y
    },
    setPositionY: function(a) {
        this._position.y = a, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getChildrenCount: function() {
        return this._children.length
    },
    getChildren: function() {
        return this._children
    },
    isVisible: function() {
        return this._visible
    },
    setVisible: function(a) {
        this._visible !== a && (this._visible = a, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty), cc.renderer.childrenOrderDirty = !0)
    },
    getAnchorPoint: function() {
        return cc.p(this._anchorPoint)
    },
    setAnchorPoint: function(a, b) {
        var c = this._anchorPoint;
        if (void 0 === b) {
            if (a.x === c.x && a.y === c.y) return;
            c.x = a.x, c.y = a.y
        } else {
            if (a === c.x && b === c.y) return;
            c.x = a, c.y = b
        }
        this._renderCmd._updateAnchorPointInPoint()
    },
    _getAnchorX: function() {
        return this._anchorPoint.x
    },
    _setAnchorX: function(a) {
        this._anchorPoint.x !== a && (this._anchorPoint.x = a, this._renderCmd._updateAnchorPointInPoint())
    },
    _getAnchorY: function() {
        return this._anchorPoint.y
    },
    _setAnchorY: function(a) {
        this._anchorPoint.y !== a && (this._anchorPoint.y = a, this._renderCmd._updateAnchorPointInPoint())
    },
    getAnchorPointInPoints: function() {
        return this._renderCmd.getAnchorPointInPoints()
    },
    _getWidth: function() {
        return this._contentSize.width
    },
    _setWidth: function(a) {
        this._contentSize.width = a, this._renderCmd._updateAnchorPointInPoint()
    },
    _getHeight: function() {
        return this._contentSize.height
    },
    _setHeight: function(a) {
        this._contentSize.height = a, this._renderCmd._updateAnchorPointInPoint()
    },
    getContentSize: function() {
        return cc.size(this._contentSize)
    },
    setContentSize: function(a, b) {
        var c = this._contentSize;
        if (void 0 === b) {
            if (a.width === c.width && a.height === c.height) return;
            c.width = a.width, c.height = a.height
        } else {
            if (a === c.width && b === c.height) return;
            c.width = a, c.height = b
        }
        this._renderCmd._updateAnchorPointInPoint()
    },
    isRunning: function() {
        return this._running
    },
    getParent: function() {
        return this._parent
    },
    setParent: function(a) {
        this._parent = a
    },
    isIgnoreAnchorPointForPosition: function() {
        return this._ignoreAnchorPointForPosition
    },
    ignoreAnchorPointForPosition: function(a) {
        a != this._ignoreAnchorPointForPosition && (this._ignoreAnchorPointForPosition = a, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty))
    },
    getTag: function() {
        return this.tag
    },
    setTag: function(a) {
        this.tag = a
    },
    setName: function(a) {
        this._name = a
    },
    getName: function() {
        return this._name
    },
    getUserData: function() {
        return this.userData
    },
    setUserData: function(a) {
        this.userData = a
    },
    getUserObject: function() {
        return this.userObject
    },
    setUserObject: function(a) {
        this.userObject != a && (this.userObject = a)
    },
    getOrderOfArrival: function() {
        return this.arrivalOrder
    },
    setOrderOfArrival: function(a) {
        this.arrivalOrder = a
    },
    getActionManager: function() {
        return this._actionManager || (this._actionManager = cc.director.getActionManager()), this._actionManager
    },
    setActionManager: function(a) {
        this._actionManager != a && (this.stopAllActions(), this._actionManager = a)
    },
    getScheduler: function() {
        return this._scheduler || (this._scheduler = cc.director.getScheduler()), this._scheduler
    },
    setScheduler: function(a) {
        this._scheduler != a && (this.unscheduleAllCallbacks(), this._scheduler = a)
    },
    boundingBox: function() {
        return cc.log(cc._LogInfos.Node_boundingBox), this.getBoundingBox()
    },
    getBoundingBox: function() {
        var a = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        return cc._rectApplyAffineTransformIn(a, this.getNodeToParentTransform())
    },
    cleanup: function() {
        this.stopAllActions(), this.unscheduleAllCallbacks(), cc.eventManager.removeListeners(this), this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.cleanup)
    },
    getChildByTag: function(a) {
        var b = this._children;
        if (null != b)
            for (var c = 0; c < b.length; c++) {
                var d = b[c];
                if (d && d.tag == a) return d
            }
        return null
    },
    getChildByName: function(a) {
        if (!a) return cc.log("Invalid name"), null;
        for (var b = this._children, c = 0, d = b.length; d > c; c++)
            if (b[c]._name == a) return b[c];
        return null
    },
    addChild: function(a, b, c) {
        b = void 0 === b ? a._localZOrder : b;
        var d, e = !1;
        cc.isUndefined(c) ? (c = void 0, d = a._name) : cc.isString(c) ? (d = c, c = void 0) : cc.isNumber(c) && (e = !0, d = ""), cc.assert(a, cc._LogInfos.Node_addChild_3), cc.assert(null === a._parent, "child already added. It can't be added again"), this._addChildHelper(a, b, c, d, e)
    },
    _addChildHelper: function(a, b, c, d, e) {
        this._children || (this._children = []), this._insertChild(a, b), e ? a.setTag(c) : a.setName(d), a.setParent(this), a.setOrderOfArrival(cc.s_globalOrderOfArrival++), this._running && (a.onEnter(), this._isTransitionFinished && a.onEnterTransitionDidFinish()), this._cascadeColorEnabled && a._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty), this._cascadeOpacityEnabled && a._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
    },
    removeFromParent: function(a) {
        this._parent && (null == a && (a = !0), this._parent.removeChild(this, a))
    },
    removeFromParentAndCleanup: function(a) {
        cc.log(cc._LogInfos.Node_removeFromParentAndCleanup), this.removeFromParent(a)
    },
    removeChild: function(a, b) {
        0 !== this._children.length && (null == b && (b = !0), this._children.indexOf(a) > -1 && this._detachChild(a, b), cc.renderer.childrenOrderDirty = !0)
    },
    removeChildByTag: function(a, b) {
        a === cc.NODE_TAG_INVALID && cc.log(cc._LogInfos.Node_removeChildByTag);
        var c = this.getChildByTag(a);
        null == c ? cc.log(cc._LogInfos.Node_removeChildByTag_2, a) : this.removeChild(c, b)
    },
    removeAllChildrenWithCleanup: function(a) {
        this.removeAllChildren(a)
    },
    removeAllChildren: function(a) {
        var b = this._children;
        if (null != b) {
            null == a && (a = !0);
            for (var c = 0; c < b.length; c++) {
                var d = b[c];
                d && (this._running && (d.onExitTransitionDidStart(), d.onExit()), a && d.cleanup(), d.parent = null)
            }
            this._children.length = 0
        }
    },
    _detachChild: function(a, b) {
        this._running && (a.onExitTransitionDidStart(), a.onExit()), b && a.cleanup(), a.parent = null, a._renderCmd.detachFromParent(), cc.arrayRemoveObject(this._children, a)
    },
    _insertChild: function(a, b) {
        cc.renderer.childrenOrderDirty = this._reorderChildDirty = !0, this._children.push(a), a._setLocalZOrder(b)
    },
    setNodeDirty: function() {
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    reorderChild: function(a, b) {
        cc.assert(a, cc._LogInfos.Node_reorderChild), cc.renderer.childrenOrderDirty = this._reorderChildDirty = !0, a.arrivalOrder = cc.s_globalOrderOfArrival, cc.s_globalOrderOfArrival++, a._setLocalZOrder(b)
    },
    sortAllChildren: function() {
        if (this._reorderChildDirty) {
            var a, b, c, d = this._children,
                e = d.length;
            for (a = 1; e > a; a++) {
                for (c = d[a], b = a - 1; b >= 0;) {
                    if (c._localZOrder < d[b]._localZOrder) d[b + 1] = d[b];
                    else {
                        if (!(c._localZOrder === d[b]._localZOrder && c.arrivalOrder < d[b].arrivalOrder)) break;
                        d[b + 1] = d[b]
                    }
                    b--
                }
                d[b + 1] = c
            }
            this._reorderChildDirty = !1
        }
    },
    draw: function() {},
    transformAncestors: function() {
        null != this._parent && (this._parent.transformAncestors(), this._parent.transform())
    },
    onEnter: function() {
        this._isTransitionFinished = !1, this._running = !0, this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.onEnter), this.resume()
    },
    onEnterTransitionDidFinish: function() {
        this._isTransitionFinished = !0, this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.onEnterTransitionDidFinish)
    },
    onExitTransitionDidStart: function() {
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.onExitTransitionDidStart)
    },
    onExit: function() {
        this._running = !1, this.pause(), this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.onExit), this.removeAllComponents()
    },
    runAction: function(a) {
        return cc.assert(a, cc._LogInfos.Node_runAction), this.actionManager.addAction(a, this, !this._running), a
    },
    stopAllActions: function() {
        this.actionManager && this.actionManager.removeAllActionsFromTarget(this)
    },
    stopAction: function(a) {
        this.actionManager.removeAction(a)
    },
    stopActionByTag: function(a) {
        return a === cc.ACTION_TAG_INVALID ? void cc.log(cc._LogInfos.Node_stopActionByTag) : void this.actionManager.removeActionByTag(a, this)
    },
    getActionByTag: function(a) {
        return a === cc.ACTION_TAG_INVALID ? (cc.log(cc._LogInfos.Node_getActionByTag), null) : this.actionManager.getActionByTag(a, this)
    },
    getNumberOfRunningActions: function() {
        return this.actionManager.numberOfRunningActionsInTarget(this)
    },
    scheduleUpdate: function() {
        this.scheduleUpdateWithPriority(0)
    },
    scheduleUpdateWithPriority: function(a) {
        this.scheduler.scheduleUpdateForTarget(this, a, !this._running)
    },
    unscheduleUpdate: function() {
        this.scheduler.unscheduleUpdateForTarget(this)
    },
    schedule: function(a, b, c, d) {
        b = b || 0, cc.assert(a, cc._LogInfos.Node_schedule), cc.assert(b >= 0, cc._LogInfos.Node_schedule_2), c = null == c ? cc.REPEAT_FOREVER : c, d = d || 0, this.scheduler.scheduleCallbackForTarget(this, a, b, c, d, !this._running)
    },
    scheduleOnce: function(a, b) {
        this.schedule(a, 0, 0, b)
    },
    unschedule: function(a) {
        a && this.scheduler.unscheduleCallbackForTarget(this, a)
    },
    unscheduleAllCallbacks: function() {
        this.scheduler.unscheduleAllCallbacksForTarget(this)
    },
    resumeSchedulerAndActions: function() {
        cc.log(cc._LogInfos.Node_resumeSchedulerAndActions), this.resume()
    },
    resume: function() {
        this.scheduler.resumeTarget(this), this.actionManager && this.actionManager.resumeTarget(this), cc.eventManager.resumeTarget(this)
    },
    pauseSchedulerAndActions: function() {
        cc.log(cc._LogInfos.Node_pauseSchedulerAndActions), this.pause()
    },
    pause: function() {
        this.scheduler.pauseTarget(this), this.actionManager && this.actionManager.pauseTarget(this), cc.eventManager.pauseTarget(this)
    },
    setAdditionalTransform: function(a) {
        this._additionalTransform = a, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty), this._additionalTransformDirty = !0
    },
    getParentToNodeTransform: function() {
        this._renderCmd.getParentToNodeTransform()
    },
    parentToNodeTransform: function() {
        return this.getParentToNodeTransform()
    },
    getNodeToWorldTransform: function() {
        for (var a = this.getNodeToParentTransform(), b = this._parent; null != b; b = b.parent) a = cc.affineTransformConcat(a, b.getNodeToParentTransform());
        return a
    },
    nodeToWorldTransform: function() {
        return this.getNodeToWorldTransform()
    },
    getWorldToNodeTransform: function() {
        return cc.affineTransformInvert(this.getNodeToWorldTransform())
    },
    worldToNodeTransform: function() {
        return this.getWorldToNodeTransform()
    },
    convertToNodeSpace: function(a) {
        return cc.pointApplyAffineTransform(a, this.getWorldToNodeTransform())
    },
    convertToWorldSpace: function(a) {
        return a = a || cc.p(0, 0), cc.pointApplyAffineTransform(a, this.getNodeToWorldTransform())
    },
    convertToNodeSpaceAR: function(a) {
        return cc.pSub(this.convertToNodeSpace(a), this._renderCmd.getAnchorPointInPoints())
    },
    convertToWorldSpaceAR: function(a) {
        a = a || cc.p(0, 0);
        var b = cc.pAdd(a, this._renderCmd.getAnchorPointInPoints());
        return this.convertToWorldSpace(b)
    },
    _convertToWindowSpace: function(a) {
        var b = this.convertToWorldSpace(a);
        return cc.director.convertToUI(b)
    },
    convertTouchToNodeSpace: function(a) {
        var b = a.getLocation();
        return this.convertToNodeSpace(b)
    },
    convertTouchToNodeSpaceAR: function(a) {
        var b = cc.director.convertToGL(a.getLocation());
        return this.convertToNodeSpaceAR(b)
    },
    update: function(a) {
        this._componentContainer && !this._componentContainer.isEmpty() && this._componentContainer.visit(a)
    },
    updateTransform: function() {
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.updateTransform)
    },
    retain: function() {},
    release: function() {},
    getComponent: function(a) {
        return this._componentContainer ? this._componentContainer.getComponent(a) : null
    },
    addComponent: function(a) {
        this._componentContainer && this._componentContainer.add(a)
    },
    removeComponent: function(a) {
        return this._componentContainer ? this._componentContainer.remove(a) : !1
    },
    removeAllComponents: function() {
        this._componentContainer && this._componentContainer.removeAll()
    },
    grid: null,
    visit: function(a) {
        this._renderCmd.visit(a)
    },
    transform: function(a, b) {
        this._renderCmd.transform(a, b)
    },
    nodeToParentTransform: function() {
        return this.getNodeToParentTransform()
    },
    getNodeToParentTransform: function() {
        return this._renderCmd.getNodeToParentTransform()
    },
    getCamera: function() {
        return this._camera || (this._camera = new cc.Camera), this._camera
    },
    getGrid: function() {
        return this.grid
    },
    setGrid: function(a) {
        this.grid = a
    },
    getShaderProgram: function() {
        return this._renderCmd.getShaderProgram()
    },
    setShaderProgram: function(a) {
        this._renderCmd.setShaderProgram(a)
    },
    getGLServerState: function() {
        return 0
    },
    setGLServerState: function() {},
    getBoundingBoxToWorld: function() {
        var a = cc.rect(0, 0, this._contentSize.width, this._contentSize.height),
            b = this.getNodeToWorldTransform();
        if (a = cc.rectApplyAffineTransform(a, b), !this._children) return a;
        for (var c = this._children, d = 0; d < c.length; d++) {
            var e = c[d];
            if (e && e._visible) {
                var f = e._getBoundingBoxToCurrentNode(b);
                f && (a = cc.rectUnion(a, f))
            }
        }
        return a
    },
    _getBoundingBoxToCurrentNode: function(a) {
        var b = cc.rect(0, 0, this._contentSize.width, this._contentSize.height),
            c = null == a ? this.getNodeToParentTransform() : cc.affineTransformConcat(this.getNodeToParentTransform(), a);
        if (b = cc.rectApplyAffineTransform(b, c), !this._children) return b;
        for (var d = this._children, e = 0; e < d.length; e++) {
            var f = d[e];
            if (f && f._visible) {
                var g = f._getBoundingBoxToCurrentNode(c);
                g && (b = cc.rectUnion(b, g))
            }
        }
        return b
    },
    getOpacity: function() {
        return this._realOpacity
    },
    getDisplayedOpacity: function() {
        return this._renderCmd.getDisplayedOpacity()
    },
    setOpacity: function(a) {
        this._realOpacity = a, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
    },
    updateDisplayedOpacity: function(a) {
        this._renderCmd._updateDisplayOpacity(a)
    },
    isCascadeOpacityEnabled: function() {
        return this._cascadeOpacityEnabled
    },
    setCascadeOpacityEnabled: function(a) {
        this._cascadeOpacityEnabled !== a && (this._cascadeOpacityEnabled = a, this._renderCmd.setCascadeOpacityEnabledDirty())
    },
    getColor: function() {
        var a = this._realColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    getDisplayedColor: function() {
        return this._renderCmd.getDisplayedColor()
    },
    setColor: function(a) {
        var b = this._realColor;
        b.r = a.r, b.g = a.g, b.b = a.b, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty)
    },
    updateDisplayedColor: function(a) {
        this._renderCmd._updateDisplayColor(a)
    },
    isCascadeColorEnabled: function() {
        return this._cascadeColorEnabled
    },
    setCascadeColorEnabled: function(a) {
        this._cascadeColorEnabled !== a && (this._cascadeColorEnabled = a, this._renderCmd.setCascadeColorEnabledDirty())
    },
    setOpacityModifyRGB: function() {},
    isOpacityModifyRGB: function() {
        return !1
    },
    _initRendererCmd: function() {
        this._renderCmd = cc.renderer.getRenderCmd(this)
    },
    _createRenderCmd: function() {
        return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.Node.CanvasRenderCmd(this) : new cc.Node.WebGLRenderCmd(this)
    }
}), cc.Node.create = function() {
    return new cc.Node
}, cc.Node._stateCallbackType = {
    onEnter: 1,
    onExit: 2,
    cleanup: 3,
    onEnterTransitionDidFinish: 4,
    updateTransform: 5,
    onExitTransitionDidStart: 6,
    sortAllChildren: 7
}, cc.assert(cc.isFunction(cc._tmp.PrototypeCCNode), cc._LogInfos.MissingFile, "BaseNodesPropertyDefine.js"), cc._tmp.PrototypeCCNode(), delete cc._tmp.PrototypeCCNode, cc.CustomRenderCmd = function(a, b) {
    this._needDraw = !0, this._target = a, this._callback = b, this.rendering = function(a, b, c) {
        this._callback && this._callback.call(this._target, a, b, c)
    }
}, cc.Node._dirtyFlags = {
    transformDirty: 1,
    visibleDirty: 2,
    colorDirty: 4,
    opacityDirty: 8,
    cacheDirty: 16,
    orderDirty: 32,
    textDirty: 64,
    gradientDirty: 128,
    all: 255
}, cc.Node.RenderCmd = function(a) {
    this._dirtyFlag = 1, this._node = a, this._needDraw = !1, this._anchorPointInPoints = new cc.Point(0, 0), this._transform = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
    }, this._worldTransform = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
    }, this._inverse = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
    }, this._displayedOpacity = 255, this._displayedColor = cc.color(255, 255, 255, 255), this._cascadeColorEnabledDirty = !1, this._cascadeOpacityEnabledDirty = !1, this._curLevel = -1
}, cc.Node.RenderCmd.prototype = {
    constructor: cc.Node.RenderCmd,
    getAnchorPointInPoints: function() {
        return cc.p(this._anchorPointInPoints)
    },
    getDisplayedColor: function() {
        var a = this._displayedColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    getDisplayedOpacity: function() {
        return this._displayedOpacity
    },
    setCascadeColorEnabledDirty: function() {
        this._cascadeColorEnabledDirty = !0, this.setDirtyFlag(cc.Node._dirtyFlags.colorDirty)
    },
    setCascadeOpacityEnabledDirty: function() {
        this._cascadeOpacityEnabledDirty = !0, this.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
    },
    getParentToNodeTransform: function() {
        return this._dirtyFlag & cc.Node._dirtyFlags.transformDirty && (this._inverse = cc.affineTransformInvert(this.getNodeToParentTransform())), this._inverse
    },
    detachFromParent: function() {},
    _updateAnchorPointInPoint: function() {
        var a = this._anchorPointInPoints,
            b = this._node._contentSize,
            c = this._node._anchorPoint;
        a.x = b.width * c.x, a.y = b.height * c.y, this.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    setDirtyFlag: function(a) {
        0 === this._dirtyFlag && 0 !== a && cc.renderer.pushDirtyNode(this), this._dirtyFlag |= a
    },
    getParentRenderCmd: function() {
        return this._node && this._node._parent && this._node._parent._renderCmd ? this._node._parent._renderCmd : null
    },
    _updateDisplayColor: function(a) {
        var b, c, d, e, f = this._node,
            g = this._displayedColor,
            h = f._realColor;
        if (this._cascadeColorEnabledDirty && !f._cascadeColorEnabled) {
            g.r = h.r, g.g = h.g, g.b = h.b;
            var i = new cc.Color(255, 255, 255, 255);
            for (d = f._children, b = 0, c = d.length; c > b; b++) e = d[b], e && e._renderCmd && e._renderCmd._updateDisplayColor(i);
            this._cascadeColorEnabledDirty = !1
        } else {
            if (void 0 === a) {
                var j = f._parent;
                a = j && j._cascadeColorEnabled ? j.getDisplayedColor() : cc.color.WHITE
            }
            if (g.r = 0 | h.r * a.r / 255, g.g = 0 | h.g * a.g / 255, g.b = 0 | h.b * a.b / 255, f._cascadeColorEnabled)
                for (d = f._children, b = 0, c = d.length; c > b; b++) e = d[b], e && e._renderCmd && (e._renderCmd._updateDisplayColor(g), e._renderCmd._updateColor())
        }
        this._dirtyFlag = this._dirtyFlag & cc.Node._dirtyFlags.colorDirty ^ this._dirtyFlag
    },
    _updateDisplayOpacity: function(a) {
        var b, c, d, e, f = this._node;
        if (this._cascadeOpacityEnabledDirty && !f._cascadeOpacityEnabled) {
            for (this._displayedOpacity = f._realOpacity, d = this._children, b = 0, c = d.length; c > b; b++) e = d[b], e && e._renderCmd && e._renderCmd._updateDisplayOpacity(255);
            this._cascadeOpacityEnabledDirty = !1
        } else {
            if (void 0 === a) {
                var g = f._parent;
                a = 255, g && g._cascadeOpacityEnabled && (a = g.getDisplayedOpacity())
            }
            if (this._displayedOpacity = f._realOpacity * a / 255, f._cascadeOpacityEnabled)
                for (d = f._children, b = 0, c = d.length; c > b; b++) e = d[b], e && e._renderCmd && (e._renderCmd._updateDisplayOpacity(this._displayedOpacity), e._renderCmd._updateColor())
        }
        this._dirtyFlag = this._dirtyFlag & cc.Node._dirtyFlags.opacityDirty ^ this._dirtyFlag
    },
    _syncDisplayColor: function(a) {
        var b = this._node,
            c = this._displayedColor,
            d = b._realColor;
        if (void 0 === a) {
            var e = b._parent;
            a = e && e._cascadeColorEnabled ? e.getDisplayedColor() : cc.color.WHITE
        }
        c.r = 0 | d.r * a.r / 255, c.g = 0 | d.g * a.g / 255, c.b = 0 | d.b * a.b / 255
    },
    _syncDisplayOpacity: function(a) {
        var b = this._node;
        if (void 0 === a) {
            var c = b._parent;
            a = 255, c && c._cascadeOpacityEnabled && (a = c.getDisplayedOpacity())
        }
        this._displayedOpacity = b._realOpacity * a / 255
    },
    _updateColor: function() {},
    updateStatus: function() {
        var a = cc.Node._dirtyFlags,
            b = this._dirtyFlag,
            c = b & a.colorDirty,
            d = b & a.opacityDirty;
        c && this._updateDisplayColor(), d && this._updateDisplayOpacity(), (c || d) && this._updateColor(), b & a.transformDirty && (this.transform(this.getParentRenderCmd(), !0), this._dirtyFlag = this._dirtyFlag & cc.Node._dirtyFlags.transformDirty ^ this._dirtyFlag)
    }
}, function() {
    cc.Node.CanvasRenderCmd = function(a) {
        cc.Node.RenderCmd.call(this, a), this._cachedParent = null, this._cacheDirty = !1
    };
    var a = cc.Node.CanvasRenderCmd.prototype = Object.create(cc.Node.RenderCmd.prototype);
    a.constructor = cc.Node.CanvasRenderCmd, a.transform = function(a, b) {
        var c = this.getNodeToParentTransform(),
            d = this._worldTransform;
        if (a) {
            var e = a._worldTransform;
            d.a = c.a * e.a + c.b * e.c, d.b = c.a * e.b + c.b * e.d, d.c = c.c * e.a + c.d * e.c, d.d = c.c * e.b + c.d * e.d;
            var f = a._transform,
                g = -(f.b + f.c) * c.ty,
                h = -(f.b + f.c) * c.tx;
            d.tx = c.tx * e.a + c.ty * e.c + e.tx + g, d.ty = c.tx * e.b + c.ty * e.d + e.ty + h
        } else d.a = c.a, d.b = c.b, d.c = c.c, d.d = c.d, d.tx = c.tx, d.ty = c.ty; if (b) {
            var i = this._node._children;
            if (!i || 0 === i.length) return;
            var j, k;
            for (j = 0, k = i.length; k > j; j++) i[j]._renderCmd.transform(this, b)
        }
    }, a.getNodeToParentTransform = function() {
        var a = this._node,
            b = !1;
        if (a._usingNormalizedPosition && a._parent) {
            var c = a._parent._contentSize;
            a._position.x = a._normalizedPosition.x * c.width, a._position.y = a._normalizedPosition.y * c.height, a._normalizedPositionDirty = !1, b = !0
        }
        if (b || this._dirtyFlag & cc.Node._dirtyFlags.transformDirty) {
            var d = this._transform;
            d.tx = a._position.x, d.ty = a._position.y;
            var e = 1,
                f = 0;
            if (a._rotationX) {
                var g = .017453292519943295 * a._rotationX;
                e = Math.cos(g), f = Math.sin(g)
            }
            d.a = d.d = e, d.b = -f, d.c = f;
            var h = a._scaleX,
                i = a._scaleY,
                j = this._anchorPointInPoints.x,
                k = this._anchorPointInPoints.y,
                l = 1e-6 > h && h > -1e-6 ? 1e-6 : h,
                m = 1e-6 > i && i > -1e-6 ? 1e-6 : i;
            if (a._skewX || a._skewY) {
                var n = Math.tan(-a._skewX * Math.PI / 180),
                    o = Math.tan(-a._skewY * Math.PI / 180);
                1 / 0 === n && (n = 99999999), 1 / 0 === o && (o = 99999999);
                var p = k * n * l,
                    q = j * o * m;
                d.a = e + -f * o, d.b = e * n + -f, d.c = f + e * o, d.d = f * n + e, d.tx += e * p + -f * q, d.ty += f * p + e * q
            }(1 !== h || 1 !== i) && (d.a *= l, d.c *= l, d.b *= m, d.d *= m), d.tx += e * -j * l + -f * k * m, d.ty -= f * -j * l + e * k * m, a._ignoreAnchorPointForPosition && (d.tx += j, d.ty += k), a._additionalTransformDirty && (this._transform = cc.affineTransformConcat(d, a._additionalTransform), a._additionalTransformDirty = !1)
        }
        return this._transform
    }, a.visit = function(a) {
        var b = this._node;
        if (b._visible) {
            a = a || this.getParentRenderCmd(), a && (this._curLevel = a._curLevel + 1);
            var c, d, e = b._children;
            this._syncStatus(a);
            var f = e.length;
            if (f > 0) {
                for (b.sortAllChildren(), c = 0; f > c && (d = e[c], d._localZOrder < 0); c++) d._renderCmd.visit(this);
                for (cc.renderer.pushRenderCommand(this); f > c; c++) e[c]._renderCmd.visit(this)
            } else cc.renderer.pushRenderCommand(this);
            this._dirtyFlag = 0
        }
    }, a._syncStatus = function(a) {
        var b = cc.Node._dirtyFlags,
            c = this._dirtyFlag,
            d = a ? a._node : null;
        d && d._cascadeColorEnabled && a._dirtyFlag & b.colorDirty && (c |= b.colorDirty), d && d._cascadeOpacityEnabled && a._dirtyFlag & b.opacityDirty && (c |= b.opacityDirty), a && a._dirtyFlag & b.transformDirty && (c |= b.transformDirty);
        var e = c & b.colorDirty,
            f = c & b.opacityDirty,
            g = c & b.transformDirty;
        this._dirtyFlag = c, e && this._syncDisplayColor(), f && this._syncDisplayOpacity(), e && this._updateColor(), g && this.transform(a)
    }, a.setDirtyFlag = function(a) {
        cc.Node.RenderCmd.prototype.setDirtyFlag.call(this, a), this._setCacheDirty(), this._cachedParent && this._cachedParent.setDirtyFlag(a)
    }, a._setCacheDirty = function() {
        if (this._cacheDirty === !1) {
            this._cacheDirty = !0;
            var a = this._cachedParent;
            a && a != this && a._setNodeDirtyForCache && a._setNodeDirtyForCache()
        }
    }, a._setCachedParent = function(a) {
        if (this._cachedParent != a) {
            this._cachedParent = a;
            for (var b = this._node._children, c = 0, d = b.length; d > c; c++) b[c]._renderCmd._setCachedParent(a)
        }
    }, a.detachFromParent = function() {
        this._cachedParent = null;
        for (var a, b = this._node._children, c = 0, d = b.length; d > c; c++) a = b[c], a && a._renderCmd && a._renderCmd.detachFromParent()
    }, a.setShaderProgram = function() {}, a.getShaderProgram = function() {
        return null
    }, cc.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc = function(a) {
        return a ? a.src == cc.SRC_ALPHA && a.dst == cc.ONE || a.src == cc.ONE && a.dst == cc.ONE ? "lighter" : a.src == cc.ZERO && a.dst == cc.SRC_ALPHA ? "destination-in" : a.src == cc.ZERO && a.dst == cc.ONE_MINUS_SRC_ALPHA ? "destination-out" : "source-over" : "source-over"
    }
}(), cc._tmp.PrototypeTexture2D = function() {
    var a = cc.Texture2D;
    a.PVRImagesHavePremultipliedAlpha = function(a) {
        cc.PVRHaveAlphaPremultiplied_ = a
    }, a.PIXEL_FORMAT_RGBA8888 = 2, a.PIXEL_FORMAT_RGB888 = 3, a.PIXEL_FORMAT_RGB565 = 4, a.PIXEL_FORMAT_A8 = 5, a.PIXEL_FORMAT_I8 = 6, a.PIXEL_FORMAT_AI88 = 7, a.PIXEL_FORMAT_RGBA4444 = 8, a.PIXEL_FORMAT_RGB5A1 = 7, a.PIXEL_FORMAT_PVRTC4 = 9, a.PIXEL_FORMAT_PVRTC2 = 10, a.PIXEL_FORMAT_DEFAULT = a.PIXEL_FORMAT_RGBA8888;
    var b = cc.Texture2D._M = {};
    b[a.PIXEL_FORMAT_RGBA8888] = "RGBA8888", b[a.PIXEL_FORMAT_RGB888] = "RGB888", b[a.PIXEL_FORMAT_RGB565] = "RGB565", b[a.PIXEL_FORMAT_A8] = "A8", b[a.PIXEL_FORMAT_I8] = "I8", b[a.PIXEL_FORMAT_AI88] = "AI88", b[a.PIXEL_FORMAT_RGBA4444] = "RGBA4444", b[a.PIXEL_FORMAT_RGB5A1] = "RGB5A1", b[a.PIXEL_FORMAT_PVRTC4] = "PVRTC4", b[a.PIXEL_FORMAT_PVRTC2] = "PVRTC2";
    var c = cc.Texture2D._B = {};
    c[a.PIXEL_FORMAT_RGBA8888] = 32, c[a.PIXEL_FORMAT_RGB888] = 24, c[a.PIXEL_FORMAT_RGB565] = 16, c[a.PIXEL_FORMAT_A8] = 8, c[a.PIXEL_FORMAT_I8] = 8, c[a.PIXEL_FORMAT_AI88] = 16, c[a.PIXEL_FORMAT_RGBA4444] = 16, c[a.PIXEL_FORMAT_RGB5A1] = 16, c[a.PIXEL_FORMAT_PVRTC4] = 4, c[a.PIXEL_FORMAT_PVRTC2] = 3;
    var d = cc.Texture2D.prototype;
    d.name, cc.defineGetterSetter(d, "name", d.getName), d.pixelFormat, cc.defineGetterSetter(d, "pixelFormat", d.getPixelFormat), d.pixelsWidth, cc.defineGetterSetter(d, "pixelsWidth", d.getPixelsWide), d.pixelsHeight, cc.defineGetterSetter(d, "pixelsHeight", d.getPixelsHigh), d.width, cc.defineGetterSetter(d, "width", d._getWidth), d.height, cc.defineGetterSetter(d, "height", d._getHeight), a.defaultPixelFormat = a.PIXEL_FORMAT_DEFAULT
}, cc._tmp.PrototypeTextureAtlas = function() {
    var a = cc.TextureAtlas.prototype;
    a.totalQuads, cc.defineGetterSetter(a, "totalQuads", a.getTotalQuads), a.capacity, cc.defineGetterSetter(a, "capacity", a.getCapacity), a.quads, cc.defineGetterSetter(a, "quads", a.getQuads, a.setQuads)
}, cc._tmp.WebGLTexture2D = function() {
    cc.Texture2D = cc.Class.extend({
        _pVRHaveAlphaPremultiplied: !0,
        _pixelFormat: null,
        _pixelsWide: 0,
        _pixelsHigh: 0,
        _name: "",
        _contentSize: null,
        maxS: 0,
        maxT: 0,
        _hasPremultipliedAlpha: !1,
        _hasMipmaps: !1,
        shaderProgram: null,
        _isLoaded: !1,
        _htmlElementObj: null,
        _webTextureObj: null,
        url: null,
        ctor: function() {
            this._contentSize = cc.size(0, 0), this._pixelFormat = cc.Texture2D.defaultPixelFormat
        },
        releaseTexture: function() {
            this._webTextureObj && cc._renderContext.deleteTexture(this._webTextureObj), cc.loader.release(this.url)
        },
        getPixelFormat: function() {
            return this._pixelFormat
        },
        getPixelsWide: function() {
            return this._pixelsWide
        },
        getPixelsHigh: function() {
            return this._pixelsHigh
        },
        getName: function() {
            return this._webTextureObj
        },
        getContentSize: function() {
            return cc.size(this._contentSize.width / cc.contentScaleFactor(), this._contentSize.height / cc.contentScaleFactor())
        },
        _getWidth: function() {
            return this._contentSize.width / cc.contentScaleFactor()
        },
        _getHeight: function() {
            return this._contentSize.height / cc.contentScaleFactor()
        },
        getContentSizeInPixels: function() {
            return this._contentSize
        },
        getMaxS: function() {
            return this.maxS
        },
        setMaxS: function(a) {
            this.maxS = a
        },
        getMaxT: function() {
            return this.maxT
        },
        setMaxT: function(a) {
            this.maxT = a
        },
        getShaderProgram: function() {
            return this.shaderProgram
        },
        setShaderProgram: function(a) {
            this.shaderProgram = a
        },
        hasPremultipliedAlpha: function() {
            return this._hasPremultipliedAlpha
        },
        hasMipmaps: function() {
            return this._hasMipmaps
        },
        description: function() {
            var a = this;
            return "<cc.Texture2D | Name = " + a._name + " | Dimensions = " + a._pixelsWide + " x " + a._pixelsHigh + " | Coordinates = (" + a.maxS + ", " + a.maxT + ")>"
        },
        releaseData: function(a) {
            a = null
        },
        keepData: function(a) {
            return a
        },
        initWithData: function(a, b, c, d, e) {
            var f = this,
                g = cc.Texture2D,
                h = cc._renderContext,
                i = h.RGBA,
                j = h.UNSIGNED_BYTE,
                k = cc.Texture2D._B[b],
                l = c * k / 8;
            switch (l % 8 === 0 ? h.pixelStorei(h.UNPACK_ALIGNMENT, 8) : l % 4 === 0 ? h.pixelStorei(h.UNPACK_ALIGNMENT, 4) : l % 2 === 0 ? h.pixelStorei(h.UNPACK_ALIGNMENT, 2) : h.pixelStorei(h.UNPACK_ALIGNMENT, 1), f._webTextureObj = h.createTexture(), cc.glBindTexture2D(f), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MIN_FILTER, h.LINEAR), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MAG_FILTER, h.LINEAR), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_S, h.CLAMP_TO_EDGE), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_T, h.CLAMP_TO_EDGE), b) {
                case g.PIXEL_FORMAT_RGBA8888:
                    i = h.RGBA;
                    break;
                case g.PIXEL_FORMAT_RGB888:
                    i = h.RGB;
                    break;
                case g.PIXEL_FORMAT_RGBA4444:
                    j = h.UNSIGNED_SHORT_4_4_4_4;
                    break;
                case g.PIXEL_FORMAT_RGB5A1:
                    j = h.UNSIGNED_SHORT_5_5_5_1;
                    break;
                case g.PIXEL_FORMAT_RGB565:
                    j = h.UNSIGNED_SHORT_5_6_5;
                    break;
                case g.PIXEL_FORMAT_AI88:
                    i = h.LUMINANCE_ALPHA;
                    break;
                case g.PIXEL_FORMAT_A8:
                    i = h.ALPHA;
                    break;
                case g.PIXEL_FORMAT_I8:
                    i = h.LUMINANCE;
                    break;
                default:
                    cc.assert(0, cc._LogInfos.Texture2D_initWithData)
            }
            return h.texImage2D(h.TEXTURE_2D, 0, i, c, d, 0, i, j, a), f._contentSize.width = e.width, f._contentSize.height = e.height, f._pixelsWide = c, f._pixelsHigh = d, f._pixelFormat = b, f.maxS = e.width / c, f.maxT = e.height / d, f._hasPremultipliedAlpha = !1, f._hasMipmaps = !1, f.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE), f._isLoaded = !0, !0
        },
        drawAtPoint: function(a) {
            var b = this,
                c = [0, b.maxT, b.maxS, b.maxT, 0, 0, b.maxS, 0],
                d = b._pixelsWide * b.maxS,
                e = b._pixelsHigh * b.maxT,
                f = [a.x, a.y, 0, d + a.x, a.y, 0, a.x, e + a.y, 0, d + a.x, e + a.y, 0];
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS), b._shaderProgram.use(), b._shaderProgram.setUniformsForBuiltins(), cc.glBindTexture2D(b);
            var g = cc._renderContext;
            g.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, g.FLOAT, !1, 0, f), g.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, g.FLOAT, !1, 0, c), g.drawArrays(g.TRIANGLE_STRIP, 0, 4)
        },
        drawInRect: function(a) {
            var b = this,
                c = [0, b.maxT, b.maxS, b.maxT, 0, 0, b.maxS, 0],
                d = [a.x, a.y, a.x + a.width, a.y, a.x, a.y + a.height, a.x + a.width, a.y + a.height];
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS), b._shaderProgram.use(), b._shaderProgram.setUniformsForBuiltins(), cc.glBindTexture2D(b);
            var e = cc._renderContext;
            e.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, e.FLOAT, !1, 0, d), e.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, e.FLOAT, !1, 0, c), e.drawArrays(e.TRIANGLE_STRIP, 0, 4)
        },
        initWithImage: function(a) {
            if (null == a) return cc.log(cc._LogInfos.Texture2D_initWithImage), !1;
            var b = a.getWidth(),
                c = a.getHeight(),
                d = cc.configuration.getMaxTextureSize();
            return b > d || c > d ? (cc.log(cc._LogInfos.Texture2D_initWithImage_2, b, c, d, d), !1) : (this._isLoaded = !0, this._initPremultipliedATextureWithImage(a, b, c))
        },
        initWithElement: function(a) {
            a && (this._webTextureObj = cc._renderContext.createTexture(), this._htmlElementObj = a)
        },
        getHtmlElementObj: function() {
            return this._htmlElementObj
        },
        isLoaded: function() {
            return this._isLoaded
        },
        handleLoadedTexture: function() {
            var a = this;
            if (cc._rendererInitialized) {
                if (!a._htmlElementObj) {
                    var b = cc.loader.getRes(a.url);
                    if (!b) return;
                    a.initWithElement(b)
                }
                if (a._htmlElementObj.width && a._htmlElementObj.height) {
                    a._isLoaded = !0;
                    var c = cc._renderContext;
                    cc.glBindTexture2D(a), c.pixelStorei(c.UNPACK_ALIGNMENT, 4), c.texImage2D(c.TEXTURE_2D, 0, c.RGBA, c.RGBA, c.UNSIGNED_BYTE, a._htmlElementObj), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, c.LINEAR), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MAG_FILTER, c.LINEAR), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE), a.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE), cc.glBindTexture2D(null);
                    var d = a._htmlElementObj.width,
                        e = a._htmlElementObj.height;
                    a._pixelsWide = a._contentSize.width = d, a._pixelsHigh = a._contentSize.height = e, a._pixelFormat = cc.Texture2D.PIXEL_FORMAT_RGBA8888, a.maxS = 1, a.maxT = 1, a._hasPremultipliedAlpha = !1, a._hasMipmaps = !1, a.dispatchEvent("load")
                }
            }
        },
        initWithString: function() {
            return cc.log(cc._LogInfos.Texture2D_initWithString), null
        },
        initWithETCFile: function() {
            return cc.log(cc._LogInfos.Texture2D_initWithETCFile_2), !1
        },
        initWithPVRFile: function() {
            return cc.log(cc._LogInfos.Texture2D_initWithPVRFile_2), !1
        },
        initWithPVRTCData: function() {
            return cc.log(cc._LogInfos.Texture2D_initWithPVRTCData_2), !1
        },
        setTexParameters: function(a, b, c, d) {
            var e = this,
                f = cc._renderContext;
            void 0 !== b && (a = {
                minFilter: a,
                magFilter: b,
                wrapS: c,
                wrapT: d
            }), cc.assert(e._pixelsWide == cc.NextPOT(e._pixelsWide) && e._pixelsHigh == cc.NextPOT(e._pixelsHigh) || a.wrapS == f.CLAMP_TO_EDGE && a.wrapT == f.CLAMP_TO_EDGE, "WebGLRenderingContext.CLAMP_TO_EDGE should be used in NPOT textures"), cc.glBindTexture2D(e), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MIN_FILTER, a.minFilter), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MAG_FILTER, a.magFilter), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_S, a.wrapS), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_T, a.wrapT)
        },
        setAntiAliasTexParameters: function() {
            var a = cc._renderContext;
            cc.glBindTexture2D(this), this._hasMipmaps ? a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR_MIPMAP_NEAREST) : a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.LINEAR)
        },
        setAliasTexParameters: function() {
            var a = cc._renderContext;
            cc.glBindTexture2D(this), this._hasMipmaps ? a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.NEAREST_MIPMAP_NEAREST) : a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.NEAREST), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.NEAREST)
        },
        generateMipmap: function() {
            var a = this;
            cc.assert(a._pixelsWide == cc.NextPOT(a._pixelsWide) && a._pixelsHigh == cc.NextPOT(a._pixelsHigh), "Mimpap texture only works in POT textures"), cc.glBindTexture2D(a), cc._renderContext.generateMipmap(cc._renderContext.TEXTURE_2D), a._hasMipmaps = !0
        },
        stringForFormat: function() {
            return cc.Texture2D._M[this._pixelFormat]
        },
        bitsPerPixelForFormat: function(a) {
            a = a || this._pixelFormat;
            var b = cc.Texture2D._B[a];
            return null != b ? b : (cc.log(cc._LogInfos.Texture2D_bitsPerPixelForFormat, a), -1)
        },
        _initPremultipliedATextureWithImage: function(a, b, c) {
            var d, e = cc.Texture2D,
                f = a.getData(),
                g = null,
                h = null,
                i = a.hasAlpha(),
                j = cc.size(a.getWidth(), a.getHeight()),
                k = e.defaultPixelFormat,
                l = a.getBitsPerComponent();
            i || (l >= 8 ? k = e.PIXEL_FORMAT_RGB888 : (cc.log(cc._LogInfos.Texture2D__initPremultipliedATextureWithImage), k = e.PIXEL_FORMAT_RGB565));
            var m = b * c;
            if (k == e.PIXEL_FORMAT_RGB565)
                if (i)
                    for (f = new Uint16Array(b * c), g = a.getData(), d = 0; m > d; ++d) f[d] = (g[d] >> 0 & 255) >> 3 << 11 | (g[d] >> 8 & 255) >> 2 << 5 | (g[d] >> 16 & 255) >> 3 << 0;
                else
                    for (f = new Uint16Array(b * c), h = a.getData(), d = 0; m > d; ++d) f[d] = (255 & h[d]) >> 3 << 11 | (255 & h[d]) >> 2 << 5 | (255 & h[d]) >> 3 << 0;
            else if (k == e.PIXEL_FORMAT_RGBA4444)
                for (f = new Uint16Array(b * c), g = a.getData(), d = 0; m > d; ++d) f[d] = (g[d] >> 0 & 255) >> 4 << 12 | (g[d] >> 8 & 255) >> 4 << 8 | (g[d] >> 16 & 255) >> 4 << 4 | (g[d] >> 24 & 255) >> 4 << 0;
            else if (k == e.PIXEL_FORMAT_RGB5A1)
                for (f = new Uint16Array(b * c), g = a.getData(), d = 0; m > d; ++d) f[d] = (g[d] >> 0 & 255) >> 3 << 11 | (g[d] >> 8 & 255) >> 3 << 6 | (g[d] >> 16 & 255) >> 3 << 1 | (g[d] >> 24 & 255) >> 7 << 0;
            else if (k == e.PIXEL_FORMAT_A8)
                for (f = new Uint8Array(b * c), g = a.getData(), d = 0; m > d; ++d) f[d] = g >> 24 & 255;
            if (i && k == e.PIXEL_FORMAT_RGB888)
                for (g = a.getData(), f = new Uint8Array(b * c * 3), d = 0; m > d; ++d) f[3 * d] = g >> 0 & 255, f[3 * d + 1] = g >> 8 & 255, f[3 * d + 2] = g >> 16 & 255;
            return this.initWithData(f, k, b, c, j), f != a.getData() && (f = null), this._hasPremultipliedAlpha = a.isPremultipliedAlpha(), !0
        },
        addLoadedEventListener: function(a, b) {
            this.addEventListener("load", a, b)
        },
        removeLoadedEventListener: function(a) {
            this.removeEventListener("load", a)
        }
    })
}, cc._tmp.WebGLTextureAtlas = function() {
    var a = cc.TextureAtlas.prototype;
    a._setupVBO = function() {
        var a = this,
            b = cc._renderContext;
        a._buffersVBO[0] = b.createBuffer(), a._buffersVBO[1] = b.createBuffer(), a._quadsWebBuffer = b.createBuffer(), a._mapBuffers()
    }, a._mapBuffers = function() {
        var a = this,
            b = cc._renderContext;
        b.bindBuffer(b.ARRAY_BUFFER, a._quadsWebBuffer), b.bufferData(b.ARRAY_BUFFER, a._quadsArrayBuffer, b.DYNAMIC_DRAW), b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, a._buffersVBO[1]), b.bufferData(b.ELEMENT_ARRAY_BUFFER, a._indices, b.STATIC_DRAW)
    }, a.drawNumberOfQuads = function(a, b) {
        var c = this;
        if (b = b || 0, 0 !== a && c.texture && c.texture.isLoaded()) {
            var d = cc._renderContext;
            cc.glBindTexture2D(c.texture), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), d.bindBuffer(d.ARRAY_BUFFER, c._quadsWebBuffer), c.dirty && (d.bufferData(d.ARRAY_BUFFER, c._quadsArrayBuffer, d.DYNAMIC_DRAW), c.dirty = !1), d.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, d.FLOAT, !1, 24, 0), d.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, d.UNSIGNED_BYTE, !0, 24, 12), d.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, d.FLOAT, !1, 24, 16), d.bindBuffer(d.ELEMENT_ARRAY_BUFFER, c._buffersVBO[1]), cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP ? d.drawElements(d.TRIANGLE_STRIP, 6 * a, d.UNSIGNED_SHORT, 6 * b * c._indices.BYTES_PER_ELEMENT) : d.drawElements(d.TRIANGLES, 6 * a, d.UNSIGNED_SHORT, 6 * b * c._indices.BYTES_PER_ELEMENT), cc.g_NumberOfDraws++
        }
    }
}, cc._tmp.WebGLTextureCache = function() {
    var a = cc.textureCache;
    a.handleLoadedTexture = function(a) {
        var b = this._textures;
        cc._rendererInitialized || (b = this._loadedTexturesBefore);
        var c = b[a];
        c || (c = b[a] = new cc.Texture2D, c.url = a), c.handleLoadedTexture()
    }, a.addImage = function(a, b, c) {
        cc.assert(a, cc._LogInfos.Texture2D_addImage_2);
        var d = this._textures;
        cc._rendererInitialized || (d = this._loadedTexturesBefore);
        var e = d[a] || d[cc.loader._aliases[a]];
        if (e) return b && b.call(c, e), e;
        e = d[a] = new cc.Texture2D, e.url = a;
        var f = cc.loader._checkIsImageURL(a) ? cc.loader.load : cc.loader.loadImg;
        return f.call(cc.loader, a, function(e) {
            if (e) return b && b.call(c, e);
            cc.textureCache.handleLoadedTexture(a);
            var f = d[a];
            b && b.call(c, f)
        }), e
    }, a = null
}, cc.ALIGN_CENTER = 51, cc.ALIGN_TOP = 19, cc.ALIGN_TOP_RIGHT = 18, cc.ALIGN_RIGHT = 50, cc.ALIGN_BOTTOM_RIGHT = 34, cc.ALIGN_BOTTOM = 35, cc.ALIGN_BOTTOM_LEFT = 33, cc.ALIGN_LEFT = 49, cc.ALIGN_TOP_LEFT = 17, cc.PVRHaveAlphaPremultiplied_ = !1, cc._renderType === cc._RENDER_TYPE_CANVAS ? cc.Texture2D = cc.Class.extend({
    _contentSize: null,
    _isLoaded: !1,
    _htmlElementObj: null,
    url: null,
    _pattern: null,
    ctor: function() {
        this._contentSize = cc.size(0, 0), this._isLoaded = !1, this._htmlElementObj = null, this._pattern = ""
    },
    getPixelsWide: function() {
        return this._contentSize.width
    },
    getPixelsHigh: function() {
        return this._contentSize.height
    },
    getContentSize: function() {
        var a = cc.contentScaleFactor();
        return cc.size(this._contentSize.width / a, this._contentSize.height / a)
    },
    _getWidth: function() {
        return this._contentSize.width / cc.contentScaleFactor()
    },
    _getHeight: function() {
        return this._contentSize.height / cc.contentScaleFactor()
    },
    getContentSizeInPixels: function() {
        return this._contentSize
    },
    initWithElement: function(a) {
        a && (this._htmlElementObj = a)
    },
    getHtmlElementObj: function() {
        return this._htmlElementObj
    },
    isLoaded: function() {
        return this._isLoaded
    },
    handleLoadedTexture: function() {
        var a = this;
        if (!a._isLoaded) {
            if (!a._htmlElementObj) {
                var b = cc.loader.getRes(a.url);
                if (!b) return;
                a.initWithElement(b)
            }
            a._isLoaded = !0;
            var c = a._htmlElementObj;
            a._contentSize.width = c.width, a._contentSize.height = c.height, a.dispatchEvent("load")
        }
    },
    description: function() {
        return "<cc.Texture2D | width = " + this._contentSize.width + " height " + this._contentSize.height + ">"
    },
    initWithData: function() {
        return !1
    },
    initWithImage: function() {
        return !1
    },
    initWithString: function() {
        return !1
    },
    releaseTexture: function() {},
    getName: function() {
        return null
    },
    getMaxS: function() {
        return 1
    },
    setMaxS: function() {},
    getMaxT: function() {
        return 1
    },
    setMaxT: function() {},
    getPixelFormat: function() {
        return null
    },
    getShaderProgram: function() {
        return null
    },
    setShaderProgram: function() {},
    hasPremultipliedAlpha: function() {
        return !1
    },
    hasMipmaps: function() {
        return !1
    },
    releaseData: function(a) {
        a = null
    },
    keepData: function(a) {
        return a
    },
    drawAtPoint: function() {},
    drawInRect: function() {},
    initWithETCFile: function() {
        return cc.log(cc._LogInfos.Texture2D_initWithETCFile), !1
    },
    initWithPVRFile: function() {
        return cc.log(cc._LogInfos.Texture2D_initWithPVRFile), !1
    },
    initWithPVRTCData: function() {
        return cc.log(cc._LogInfos.Texture2D_initWithPVRTCData), !1
    },
    setTexParameters: function(a, b, c, d) {
        return void 0 !== b && (a = {
            minFilter: a,
            magFilter: b,
            wrapS: c,
            wrapT: d
        }), a.wrapS === cc.REPEAT && a.wrapT === cc.REPEAT ? void(this._pattern = "repeat") : a.wrapS === cc.REPEAT ? void(this._pattern = "repeat-x") : a.wrapT === cc.REPEAT ? void(this._pattern = "repeat-y") : void(this._pattern = "")
    },
    setAntiAliasTexParameters: function() {},
    setAliasTexParameters: function() {},
    generateMipmap: function() {},
    stringForFormat: function() {
        return ""
    },
    bitsPerPixelForFormat: function() {
        return -1
    },
    addLoadedEventListener: function(a, b) {
        this.addEventListener("load", a, b)
    },
    removeLoadedEventListener: function(a) {
        this.removeEventListener("load", a)
    }
}) : (cc.assert(cc.isFunction(cc._tmp.WebGLTexture2D), cc._LogInfos.MissingFile, "TexturesWebGL.js"), cc._tmp.WebGLTexture2D(), delete cc._tmp.WebGLTexture2D), cc.EventHelper.prototype.apply(cc.Texture2D.prototype), cc.assert(cc.isFunction(cc._tmp.PrototypeTexture2D), cc._LogInfos.MissingFile, "TexturesPropertyDefine.js"), cc._tmp.PrototypeTexture2D(), delete cc._tmp.PrototypeTexture2D, cc.textureCache = {
    _textures: {},
    _textureColorsCache: {},
    _textureKeySeq: 0 | 1e3 * Math.random(),
    _loadedTexturesBefore: {},
    _initializingRenderer: function() {
        var a, b = this._loadedTexturesBefore,
            c = this._textures;
        for (a in b) {
            var d = b[a];
            d.handleLoadedTexture(), c[a] = d
        }
        this._loadedTexturesBefore = {}
    },
    addPVRTCImage: function() {
        cc.log(cc._LogInfos.textureCache_addPVRTCImage)
    },
    addETCImage: function() {
        cc.log(cc._LogInfos.textureCache_addETCImage)
    },
    description: function() {
        return "<TextureCache | Number of textures = " + this._textures.length + ">"
    },
    textureForKey: function(a) {
        return cc.log(cc._LogInfos.textureCache_textureForKey), this.getTextureForKey(a)
    },
    getTextureForKey: function(a) {
        return this._textures[a] || this._textures[cc.loader._aliases[a]]
    },
    getKeyByTexture: function(a) {
        for (var b in this._textures)
            if (this._textures[b] == a) return b;
        return null
    },
    _generalTextureKey: function() {
        return this._textureKeySeq++, "_textureKey_" + this._textureKeySeq
    },
    getTextureColors: function(a) {
        var b = this.getKeyByTexture(a);
        return b || (b = a instanceof HTMLImageElement ? a.src : this._generalTextureKey()), this._textureColorsCache[b] || (this._textureColorsCache[b] = cc.Sprite.CanvasRenderCmd._generateTextureCacheForColor(a)), this._textureColorsCache[b]
    },
    addPVRImage: function() {
        cc.log(cc._LogInfos.textureCache_addPVRImage)
    },
    removeAllTextures: function() {
        var a = this._textures;
        for (var b in a) a[b] && a[b].releaseTexture();
        this._textures = {}
    },
    removeTexture: function(a) {
        if (a) {
            var b = this._textures;
            for (var c in b) b[c] == a && (b[c].releaseTexture(), delete b[c])
        }
    },
    removeTextureForKey: function(a) {
        null != a && this._textures[a] && delete this._textures[a]
    },
    cacheImage: function(a, b) {
        if (b instanceof cc.Texture2D) return void(this._textures[a] = b);
        var c = new cc.Texture2D;
        c.initWithElement(b), c.handleLoadedTexture(), this._textures[a] = c
    },
    addUIImage: function(a, b) {
        if (cc.assert(a, cc._LogInfos.textureCache_addUIImage_2), b && this._textures[b]) return this._textures[b];
        var c = new cc.Texture2D;
        return c.initWithImage(a), null != b && null != c ? this._textures[b] = c : cc.log(cc._LogInfos.textureCache_addUIImage), c
    },
    dumpCachedTextureInfo: function() {
        var a = 0,
            b = 0,
            c = this._textures;
        for (var d in c) {
            var e = c[d];
            a++, e.getHtmlElementObj() instanceof HTMLImageElement ? cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo, d, e.getHtmlElementObj().src, e.pixelsWidth, e.pixelsHeight) : cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_2, d, e.pixelsWidth, e.pixelsHeight), b += e.pixelsWidth * e.pixelsHeight * 4
        }
        var f = this._textureColorsCache;
        for (d in f) {
            var g = f[d];
            for (var h in g) {
                var i = g[h];
                a++, cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_2, d, i.width, i.height), b += i.width * i.height * 4
            }
        }
        cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_3, a, b / 1024, (b / 1048576).toFixed(2))
    },
    _clear: function() {
        this._textures = {}, this._textureColorsCache = {}, this._textureKeySeq = 0 | 1e3 * Math.random(), this._loadedTexturesBefore = {}
    }
}, cc._renderType === cc._RENDER_TYPE_CANVAS) {
    var _p = cc.textureCache;
    _p.handleLoadedTexture = function(a) {
        var b = this._textures,
            c = b[a];
        c || (c = b[a] = new cc.Texture2D, c.url = a), c.handleLoadedTexture()
    }, _p.addImage = function(a, b, c) {
        cc.assert(a, cc._LogInfos.Texture2D_addImage);
        var d = this._textures,
            e = d[a] || d[cc.loader._aliases[a]];
        if (e) return b && b.call(c, e), e;
        e = d[a] = new cc.Texture2D, e.url = a;
        var f = cc.loader._checkIsImageURL(a) ? cc.loader.load : cc.loader.loadImg;
        return f.call(cc.loader, a, function(e) {
            if (e) return b && b.call(c, e);
            cc.textureCache.handleLoadedTexture(a);
            var f = d[a];
            b && b.call(c, f)
        }), e
    }, _p = null
} else cc.assert(cc.isFunction(cc._tmp.WebGLTextureCache), cc._LogInfos.MissingFile, "TexturesWebGL.js"), cc._tmp.WebGLTextureCache(), delete cc._tmp.WebGLTextureCache; if (cc.Scene = cc.Node.extend({
    _className: "Scene",
    ctor: function() {
        cc.Node.prototype.ctor.call(this), this._ignoreAnchorPointForPosition = !0, this.setAnchorPoint(.5, .5), this.setContentSize(cc.director.getWinSize())
    }
}), cc.Scene.create = function() {
    return new cc.Scene
}, cc.LoaderScene = cc.Scene.extend({
    _interval: null,
    _label: null,
    _className: "LoaderScene",
    init: function() {
        var a = this,
            b = 160,
            c = 200,
            d = a._bgLayer = new cc.LayerColor(cc.color(32, 32, 32, 255));
        a.addChild(d, 0);
        var e = 24,
            f = -c / 2 + 100;
        cc._loaderImage && (cc.loader.loadImg(cc._loaderImage, {
            isCrossOrigin: !1
        }, function(d, e) {
            b = e.width, c = e.height, a._initStage(e, cc.visibleRect.center)
        }), e = 14, f = -c / 2 - 10);
        var g = a._label = new cc.LabelTTF("Loading... 0%", "Arial", e);
        return g.setPosition(cc.pAdd(cc.visibleRect.center, cc.p(0, f))), g.setColor(cc.color(180, 180, 180)), d.addChild(this._label, 10), !0
    },
    _initStage: function(a, b) {
        var c = this,
            d = c._texture2d = new cc.Texture2D;
        d.initWithElement(a), d.handleLoadedTexture();
        var e = c._logo = new cc.Sprite(d);
        e.setScale(cc.contentScaleFactor()), e.x = b.x, e.y = b.y, c._bgLayer.addChild(e, 10)
    },
    onEnter: function() {
        var a = this;
        cc.Node.prototype.onEnter.call(a), a.schedule(a._startLoading, .3)
    },
    onExit: function() {
        cc.Node.prototype.onExit.call(this);
        var a = "Loading... 0%";
        this._label.setString(a)
    },
    initWithResources: function(a, b) {
        cc.isString(a) && (a = [a]), this.resources = a || [], this.cb = b
    },
    _startLoading: function() {
        var a = this;
        a.unschedule(a._startLoading);
        var b = a.resources;
        cc.loader.load(b, function(b, c, d) {
            var e = d / c * 100 | 0;
            e = Math.min(e, 100), a._label.setString("Loading... " + e + "%")
        }, function() {
            a.cb && a.cb()
        })
    }
}), cc.LoaderScene.preload = function(a, b) {
    var c = cc;
    return c.loaderScene || (c.loaderScene = new cc.LoaderScene, c.loaderScene.init()), c.loaderScene.initWithResources(a, b), cc.director.runScene(c.loaderScene), c.loaderScene
}, cc.Layer = cc.Node.extend({
    _className: "Layer",
    ctor: function() {
        var a = cc.Node.prototype;
        a.ctor.call(this), this._ignoreAnchorPointForPosition = !0, a.setAnchorPoint.call(this, .5, .5), a.setContentSize.call(this, cc.winSize)
    },
    init: function() {
        var a = this;
        return a._ignoreAnchorPointForPosition = !0, a.setAnchorPoint(.5, .5), a.setContentSize(cc.winSize), a._cascadeColorEnabled = !1, a._cascadeOpacityEnabled = !1, !0
    },
    bake: function() {
        this._renderCmd.bake()
    },
    unbake: function() {
        this._renderCmd.unbake()
    },
    isBaked: function() {
        return this._isBaked
    },
    addChild: function(a, b, c) {
        cc.Node.prototype.addChild.call(this, a, b, c), this._renderCmd._bakeForAddChild(a)
    },
    _createRenderCmd: function() {
        return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.Layer.CanvasRenderCmd(this) : new cc.Layer.WebGLRenderCmd(this)
    }
}), cc.Layer.create = function() {
    return new cc.Layer
}, cc.LayerColor = cc.Layer.extend({
    _blendFunc: null,
    _className: "LayerColor",
    getBlendFunc: function() {
        return this._blendFunc
    },
    changeWidthAndHeight: function(a, b) {
        this.width = a, this.height = b
    },
    changeWidth: function(a) {
        this.width = a
    },
    changeHeight: function(a) {
        this.height = a
    },
    setOpacityModifyRGB: function() {},
    isOpacityModifyRGB: function() {
        return !1
    },
    ctor: function(a, b, c) {
        cc.Layer.prototype.ctor.call(this), this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST), cc.LayerColor.prototype.init.call(this, a, b, c)
    },
    init: function(a, b, c) {
        cc._renderType !== cc._RENDER_TYPE_CANVAS && (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_COLOR));
        var d = cc.director.getWinSize();
        a = a || cc.color(0, 0, 0, 255), b = void 0 === b ? d.width : b, c = void 0 === c ? d.height : c;
        var e = this._realColor;
        return e.r = a.r, e.g = a.g, e.b = a.b, this._realOpacity = a.a, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty | cc.Node._dirtyFlags.opacityDirty), cc.LayerColor.prototype.setContentSize.call(this, b, c), !0
    },
    setBlendFunc: function(a, b) {
        var c = this._blendFunc;
        void 0 === b ? (c.src = a.src, c.dst = a.dst) : (c.src = a, c.dst = b), this._renderCmd.updateBlendFunc(c)
    },
    _setWidth: function(a) {
        cc.Node.prototype._setWidth.call(this, a), this._renderCmd._updateSquareVerticesWidth(a)
    },
    _setHeight: function(a) {
        cc.Node.prototype._setHeight.call(this, a), this._renderCmd._updateSquareVerticesHeight(a)
    },
    setContentSize: function(a, b) {
        cc.Layer.prototype.setContentSize.call(this, a, b), this._renderCmd._updateSquareVertices(a, b)
    },
    _createRenderCmd: function() {
        return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.LayerColor.CanvasRenderCmd(this) : new cc.LayerColor.WebGLRenderCmd(this)
    }
}), cc.LayerColor.create = function(a, b, c) {
    return new cc.LayerColor(a, b, c)
}, function() {
    var a = cc.LayerColor.prototype;
    cc.defineGetterSetter(a, "width", a._getWidth, a._setWidth), cc.defineGetterSetter(a, "height", a._getHeight, a._setHeight)
}(), cc.LayerGradient = cc.LayerColor.extend({
    _endColor: null,
    _startOpacity: 255,
    _endOpacity: 255,
    _alongVector: null,
    _compressedInterpolation: !1,
    _className: "LayerGradient",
    ctor: function(a, b, c) {
        var d = this;
        cc.LayerColor.prototype.ctor.call(d), d._endColor = cc.color(0, 0, 0, 255), d._alongVector = cc.p(0, -1), d._startOpacity = 255, d._endOpacity = 255, cc.LayerGradient.prototype.init.call(d, a, b, c)
    },
    init: function(a, b, c) {
        a = a || cc.color(0, 0, 0, 255), b = b || cc.color(0, 0, 0, 255), c = c || cc.p(0, -1);
        var d = this,
            e = d._endColor;
        return d._startOpacity = a.a, e.r = b.r, e.g = b.g, e.b = b.b, d._endOpacity = b.a, d._alongVector = c, d._compressedInterpolation = !0, cc.LayerColor.prototype.init.call(d, cc.color(a.r, a.g, a.b, 255)), this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty | cc.Node._dirtyFlags.opacityDirty | cc.Node._dirtyFlags.gradientDirty), !0
    },
    setContentSize: function(a, b) {
        cc.LayerColor.prototype.setContentSize.call(this, a, b), this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
    },
    _setWidth: function(a) {
        cc.LayerColor.prototype._setWidth.call(this, a), this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
    },
    _setHeight: function(a) {
        cc.LayerColor.prototype._setHeight.call(this, a), this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
    },
    getStartColor: function() {
        return this._realColor
    },
    setStartColor: function(a) {
        this.color = a
    },
    setEndColor: function(a) {
        this._endColor = a, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty)
    },
    getEndColor: function() {
        return this._endColor
    },
    setStartOpacity: function(a) {
        this._startOpacity = a, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
    },
    getStartOpacity: function() {
        return this._startOpacity
    },
    setEndOpacity: function(a) {
        this._endOpacity = a, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
    },
    getEndOpacity: function() {
        return this._endOpacity
    },
    setVector: function(a) {
        this._alongVector.x = a.x, this._alongVector.y = a.y, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
    },
    getVector: function() {
        return cc.p(this._alongVector.x, this._alongVector.y)
    },
    isCompressedInterpolation: function() {
        return this._compressedInterpolation
    },
    setCompressedInterpolation: function(a) {
        this._compressedInterpolation = a, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
    },
    _createRenderCmd: function() {
        return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.LayerGradient.CanvasRenderCmd(this) : new cc.LayerGradient.WebGLRenderCmd(this)
    }
}), cc.LayerGradient.create = function(a, b, c) {
    return new cc.LayerGradient(a, b, c)
}, function() {
    var a = cc.LayerGradient.prototype;
    a.startColor, cc.defineGetterSetter(a, "startColor", a.getStartColor, a.setStartColor), a.endColor, cc.defineGetterSetter(a, "endColor", a.getEndColor, a.setEndColor), a.startOpacity, cc.defineGetterSetter(a, "startOpacity", a.getStartOpacity, a.setStartOpacity), a.endOpacity, cc.defineGetterSetter(a, "endOpacity", a.getEndOpacity, a.setEndOpacity), a.vector, cc.defineGetterSetter(a, "vector", a.getVector, a.setVector)
}(), cc.LayerMultiplex = cc.Layer.extend({
    _enabledLayer: 0,
    _layers: null,
    _className: "LayerMultiplex",
    ctor: function(a) {
        cc.Layer.prototype.ctor.call(this), a instanceof Array ? cc.LayerMultiplex.prototype.initWithLayers.call(this, a) : cc.LayerMultiplex.prototype.initWithLayers.call(this, Array.prototype.slice.call(arguments))
    },
    initWithLayers: function(a) {
        return a.length > 0 && null == a[a.length - 1] && cc.log(cc._LogInfos.LayerMultiplex_initWithLayers), this._layers = a, this._enabledLayer = 0, this.addChild(this._layers[this._enabledLayer]), !0
    },
    switchTo: function(a) {
        return a >= this._layers.length ? void cc.log(cc._LogInfos.LayerMultiplex_switchTo) : (this.removeChild(this._layers[this._enabledLayer], !0), this._enabledLayer = a, void this.addChild(this._layers[a]))
    },
    switchToAndReleaseMe: function(a) {
        return a >= this._layers.length ? void cc.log(cc._LogInfos.LayerMultiplex_switchToAndReleaseMe) : (this.removeChild(this._layers[this._enabledLayer], !0), this._layers[this._enabledLayer] = null, this._enabledLayer = a, void this.addChild(this._layers[a]))
    },
    addLayer: function(a) {
        return a ? void this._layers.push(a) : void cc.log(cc._LogInfos.LayerMultiplex_addLayer)
    }
}), cc.LayerMultiplex.create = function() {
    return new cc.LayerMultiplex(Array.prototype.slice.call(arguments))
}, function() {
    cc.Layer.CanvasRenderCmd = function(a) {
        cc.Node.CanvasRenderCmd.call(this, a), this._isBaked = !1, this._bakeSprite = null
    };
    var a = cc.Layer.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    a.constructor = cc.Layer.CanvasRenderCmd, a.bake = function() {
        if (!this._isBaked) {
            this._needDraw = !0, cc.renderer.childrenOrderDirty = !0, this._isBaked = this._cacheDirty = !0;
            for (var a = this._node._children, b = 0, c = a.length; c > b; b++) a[b]._renderCmd._setCachedParent(this);
            this._bakeSprite || (this._bakeSprite = new cc.BakeSprite, this._bakeSprite._parent = this._node)
        }
    }, a.unbake = function() {
        if (this._isBaked) {
            cc.renderer.childrenOrderDirty = !0, this._needDraw = !1, this._isBaked = !1, this._cacheDirty = !0;
            for (var a = this._node._children, b = 0, c = a.length; c > b; b++) a[b]._renderCmd._setCachedParent(null)
        }
    }, a.isBaked = function() {
        return this._isBaked
    }, a.rendering = function() {
        if (this._cacheDirty) {
            var a = this._node,
                b = a._children,
                c = this._bakeSprite;
            this.transform(this.getParentRenderCmd(), !0);
            var d = this._getBoundingBoxForBake();
            d.width = 0 | d.width + .5, d.height = 0 | d.height + .5;
            var e = c.getCacheContext(),
                f = e.getContext();
            c.resetCanvasSize(d.width, d.height);
            var g = c.getAnchorPointInPoints(),
                h = a._position;
            if (a._ignoreAnchorPointForPosition) e.setOffset(0 - d.x, f.canvas.height - d.height + d.y), c.setPosition(g.x + d.x - h.x, g.y + d.y - h.y);
            else {
                var i = this.getAnchorPointInPoints(),
                    j = {
                        x: h.x - i.x,
                        y: h.y - i.y
                    };
                e.setOffset(0 - d.x, f.canvas.height - d.height + d.y), c.setPosition(g.x + d.x - j.x, g.y + d.y - j.y)
            }
            a.sortAllChildren(), cc.renderer._turnToCacheMode(this.__instanceId);
            for (var k = 0, l = b.length; l > k; k++) b[k].visit(this);
            cc.renderer._renderingToCacheCanvas(e, this.__instanceId), c.transform(this), this._cacheDirty = !1
        }
    }, a.visit = function(a) {
        if (!this._isBaked) return void cc.Node.CanvasRenderCmd.prototype.visit.call(this, a);
        var b = this,
            c = this._node,
            d = c._children,
            e = d.length;
        c._visible && 0 !== e && (b._syncStatus(a), cc.renderer.pushRenderCommand(this), this._bakeSprite.visit(this), this._dirtyFlag = 0)
    }, a._bakeForAddChild = function(a) {
        a._parent == this._node && this._isBaked && a._renderCmd._setCachedParent(this)
    }, a._getBoundingBoxForBake = function() {
        var a = null,
            b = this._node;
        if (!b._children || 0 === b._children.length) return cc.rect(0, 0, 10, 10);
        for (var c = b.getNodeToWorldTransform(), d = b._children, e = 0, f = d.length; f > e; e++) {
            var g = d[e];
            if (g && g._visible)
                if (a) {
                    var h = g._getBoundingBoxToCurrentNode(c);
                    h && (a = cc.rectUnion(a, h))
                } else a = g._getBoundingBoxToCurrentNode(c)
        }
        return a
    }
}(), function() {
    cc.LayerColor.CanvasRenderCmd = function(a) {
        cc.Layer.CanvasRenderCmd.call(this, a), this._needDraw = !0, this._blendFuncStr = "source-over", this._bakeRenderCmd = new cc.CustomRenderCmd(this, this._bakeRendering)
    };
    var a = cc.LayerColor.CanvasRenderCmd.prototype = Object.create(cc.Layer.CanvasRenderCmd.prototype);
    a.constructor = cc.LayerColor.CanvasRenderCmd, a.unbake = function() {
        cc.Layer.CanvasRenderCmd.prototype.unbake.call(this), this._needDraw = !0
    }, a.rendering = function(a, b, c) {
        var d = a || cc._renderContext,
            e = d.getContext(),
            f = this._node,
            g = this._displayedColor,
            h = this._displayedOpacity / 255,
            i = f._contentSize.width,
            j = f._contentSize.height;
        0 !== h && (d.setCompositeOperation(this._blendFuncStr), d.setGlobalAlpha(h), d.setFillStyle("rgba(" + (0 | g.r) + "," + (0 | g.g) + "," + (0 | g.b) + ", 1)"), d.setTransform(this._worldTransform, b, c), e.fillRect(0, 0, i * b, -j * c), cc.g_NumberOfDraws++)
    }, a.updateBlendFunc = function(a) {
        this._blendFuncStr = cc.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc(a)
    }, a._updateSquareVertices = a._updateSquareVerticesWidth = a._updateSquareVerticesHeight = function() {}, a._bakeRendering = function() {
        if (this._cacheDirty) {
            var a, b = this._node,
                c = this._bakeSprite,
                d = b._children,
                e = d.length;
            this.transform(this.getParentRenderCmd(), !0);
            var f = this._getBoundingBoxForBake();
            f.width = 0 | f.width + .5, f.height = 0 | f.height + .5;
            var g = c.getCacheContext(),
                h = g.getContext();
            c.resetCanvasSize(f.width, f.height);
            var i = c.getAnchorPointInPoints(),
                j = b._position;
            if (b._ignoreAnchorPointForPosition) g.setOffset(0 - f.x, h.canvas.height - f.height + f.y), c.setPosition(i.x + f.x - j.x, i.y + f.y - j.y);
            else {
                var k = this.getAnchorPointInPoints(),
                    l = {
                        x: j.x - k.x,
                        y: j.y - k.y
                    };
                g.setOffset(0 - f.x, h.canvas.height - f.height + f.y), c.setPosition(i.x + f.x - l.x, i.y + f.y - l.y)
            }
            var m;
            if (cc.renderer._turnToCacheMode(this.__instanceId), e > 0) {
                for (b.sortAllChildren(), a = 0; e > a && (m = d[a], m._localZOrder < 0); a++) m._renderCmd.visit(this);
                for (cc.renderer.pushRenderCommand(this); e > a; a++) d[a]._renderCmd.visit(this)
            } else cc.renderer.pushRenderCommand(this);
            cc.renderer._renderingToCacheCanvas(g, this.__instanceId), c.transform(this), this._cacheDirty = !1
        }
    }, a.visit = function(a) {
        if (!this._isBaked) return void cc.Node.CanvasRenderCmd.prototype.visit.call(this);
        var b = this._node;
        b._visible && (this._syncStatus(a), cc.renderer.pushRenderCommand(this._bakeRenderCmd), this._bakeSprite._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty), this._bakeSprite.visit(this), this._dirtyFlag = 0)
    }, a._getBoundingBoxForBake = function() {
        var a = this._node,
            b = cc.rect(0, 0, a._contentSize.width, a._contentSize.height),
            c = a.getNodeToWorldTransform();
        if (b = cc.rectApplyAffineTransform(b, a.getNodeToWorldTransform()), !a._children || 0 === a._children.length) return b;
        for (var d = a._children, e = 0; e < d.length; e++) {
            var f = d[e];
            if (f && f._visible) {
                var g = f._getBoundingBoxToCurrentNode(c);
                b = cc.rectUnion(b, g)
            }
        }
        return b
    }
}(), function() {
    cc.LayerGradient.RenderCmd = {
        updateStatus: function() {
            var a = cc.Node._dirtyFlags,
                b = this._dirtyFlag,
                c = b & a.colorDirty,
                d = b & a.opacityDirty;
            c && this._updateDisplayColor(), d && this._updateDisplayOpacity(), b & a.transformDirty && this.transform(null, !0), (c || d || b & a.gradientDirty) && this._updateColor(), this._dirtyFlag = 0
        }
    }
}(), function() {
    cc.LayerGradient.CanvasRenderCmd = function(a) {
        cc.LayerColor.CanvasRenderCmd.call(this, a), this._needDraw = !0, this._startPoint = cc.p(0, 0), this._endPoint = cc.p(0, 0), this._startStopStr = null, this._endStopStr = null
    };
    var a = cc.LayerGradient.CanvasRenderCmd.prototype = Object.create(cc.LayerColor.CanvasRenderCmd.prototype);
    cc.inject(cc.LayerGradient.RenderCmd, a), a.constructor = cc.LayerGradient.CanvasRenderCmd, a.rendering = function(a, b, c) {
        var d = a || cc._renderContext,
            e = d.getContext(),
            f = this._node,
            g = this._displayedOpacity / 255;
        if (0 !== g) {
            var h = f._contentSize.width,
                i = f._contentSize.height;
            d.setCompositeOperation(this._blendFuncStr), d.setGlobalAlpha(g);
            var j = e.createLinearGradient(this._startPoint.x, this._startPoint.y, this._endPoint.x, this._endPoint.y);
            j.addColorStop(0, this._startStopStr), j.addColorStop(1, this._endStopStr), d.setFillStyle(j), d.setTransform(this._worldTransform, b, c), e.fillRect(0, 0, h * b, -i * c), cc.g_NumberOfDraws++
        }
    }, a._syncStatus = function(a) {
        var b = cc.Node._dirtyFlags,
            c = this._dirtyFlag,
            d = a ? a._node : null;
        d && d._cascadeColorEnabled && a._dirtyFlag & b.colorDirty && (c |= b.colorDirty), d && d._cascadeOpacityEnabled && a._dirtyFlag & b.opacityDirty && (c |= b.opacityDirty), a && a._dirtyFlag & b.transformDirty && (c |= b.transformDirty);
        var e = c & b.colorDirty,
            f = c & b.opacityDirty;
        this._dirtyFlag = c, e && this._syncDisplayColor(), f && this._syncDisplayOpacity(), c & b.transformDirty && this.transform(a), (e || f || c & b.gradientDirty) && this._updateColor()
    }, a._updateColor = function() {
        var a = this._node,
            b = a._contentSize,
            c = a._alongVector,
            d = .5 * b.width,
            e = .5 * b.height;
        this._dirtyFlag = this._dirtyFlag & cc.Node._dirtyFlags.gradientDirty ^ this._dirtyFlag, this._startPoint.x = d * -c.x + d, this._startPoint.y = e * c.y - e, this._endPoint.x = d * c.x + d, this._endPoint.y = e * -c.y - e;
        var f = this._displayedColor,
            g = a._endColor,
            h = a._startOpacity / 255,
            i = a._endOpacity / 255;
        this._startStopStr = "rgba(" + Math.round(f.r) + "," + Math.round(f.g) + "," + Math.round(f.b) + "," + h.toFixed(4) + ")", this._endStopStr = "rgba(" + Math.round(g.r) + "," + Math.round(g.g) + "," + Math.round(g.b) + "," + i.toFixed(4) + ")"
    }
}(), cc._tmp.PrototypeSprite = function() {
    var a = cc.Sprite.prototype;
    cc.defineGetterSetter(a, "opacityModifyRGB", a.isOpacityModifyRGB, a.setOpacityModifyRGB), cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity), cc.defineGetterSetter(a, "color", a.getColor, a.setColor), a.dirty, a.flippedX, cc.defineGetterSetter(a, "flippedX", a.isFlippedX, a.setFlippedX), a.flippedY, cc.defineGetterSetter(a, "flippedY", a.isFlippedY, a.setFlippedY), a.offsetX, cc.defineGetterSetter(a, "offsetX", a._getOffsetX), a.offsetY, cc.defineGetterSetter(a, "offsetY", a._getOffsetY), a.atlasIndex, a.texture, cc.defineGetterSetter(a, "texture", a.getTexture, a.setTexture), a.textureRectRotated, cc.defineGetterSetter(a, "textureRectRotated", a.isTextureRectRotated), a.textureAtlas, a.batchNode, cc.defineGetterSetter(a, "batchNode", a.getBatchNode, a.setBatchNode), a.quad, cc.defineGetterSetter(a, "quad", a.getQuad)
}, cc.Sprite = cc.Node.extend({
    dirty: !1,
    atlasIndex: 0,
    textureAtlas: null,
    _batchNode: null,
    _recursiveDirty: null,
    _hasChildren: null,
    _shouldBeHidden: !1,
    _transformToBatch: null,
    _blendFunc: null,
    _texture: null,
    _rect: null,
    _rectRotated: !1,
    _offsetPosition: null,
    _unflippedOffsetPositionFromCenter: null,
    _opacityModifyRGB: !1,
    _flippedX: !1,
    _flippedY: !1,
    _textureLoaded: !1,
    _className: "Sprite",
    ctor: function(a, b, c) {
        var d = this;
        cc.Node.prototype.ctor.call(d), d._shouldBeHidden = !1, d._offsetPosition = cc.p(0, 0), d._unflippedOffsetPositionFromCenter = cc.p(0, 0), d._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        }, d._rect = cc.rect(0, 0, 0, 0), d._textureLoaded = !0, d._softInit(a, b, c)
    },
    textureLoaded: function() {
        return this._textureLoaded
    },
    addLoadedEventListener: function(a, b) {
        this.addEventListener("load", a, b)
    },
    isDirty: function() {
        return this.dirty
    },
    setDirty: function(a) {
        this.dirty = a
    },
    isTextureRectRotated: function() {
        return this._rectRotated
    },
    getAtlasIndex: function() {
        return this.atlasIndex
    },
    setAtlasIndex: function(a) {
        this.atlasIndex = a
    },
    getTextureRect: function() {
        return cc.rect(this._rect)
    },
    getTextureAtlas: function() {
        return this.textureAtlas
    },
    setTextureAtlas: function(a) {
        this.textureAtlas = a
    },
    getOffsetPosition: function() {
        return cc.p(this._offsetPosition)
    },
    _getOffsetX: function() {
        return this._offsetPosition.x
    },
    _getOffsetY: function() {
        return this._offsetPosition.y
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    initWithSpriteFrame: function(a) {
        cc.assert(a, cc._LogInfos.Sprite_initWithSpriteFrame), a.textureLoaded() || (this._textureLoaded = !1, a.addEventListener("load", this._renderCmd._spriteFrameLoadedCallback, this));
        var b = cc._renderType === cc._RENDER_TYPE_CANVAS ? !1 : a._rotated,
            c = this.initWithTexture(a.getTexture(), a.getRect(), b);
        return this.setSpriteFrame(a), c
    },
    initWithSpriteFrameName: function(a) {
        cc.assert(a, cc._LogInfos.Sprite_initWithSpriteFrameName);
        var b = cc.spriteFrameCache.getSpriteFrame(a);
        return cc.assert(b, a + cc._LogInfos.Sprite_initWithSpriteFrameName1), this.initWithSpriteFrame(b)
    },
    useBatchNode: function(a) {
        this.textureAtlas = a.getTextureAtlas(), this._batchNode = a
    },
    setVertexRect: function(a) {
        var b = this._rect;
        b.x = a.x, b.y = a.y, b.width = a.width, b.height = a.height
    },
    sortAllChildren: function() {
        if (this._reorderChildDirty) {
            var a, b, c, d = this._children,
                e = d.length;
            for (a = 1; e > a; a++) {
                for (c = d[a], b = a - 1; b >= 0;) {
                    if (c._localZOrder < d[b]._localZOrder) d[b + 1] = d[b];
                    else {
                        if (!(c._localZOrder === d[b]._localZOrder && c.arrivalOrder < d[b].arrivalOrder)) break;
                        d[b + 1] = d[b]
                    }
                    b--
                }
                d[b + 1] = c
            }
            this._batchNode && this._arrayMakeObjectsPerformSelector(d, cc.Node._stateCallbackType.sortAllChildren), this._reorderChildDirty = !1
        }
    },
    reorderChild: function(a, b) {
        return cc.assert(a, cc._LogInfos.Sprite_reorderChild_2), -1 === this._children.indexOf(a) ? void cc.log(cc._LogInfos.Sprite_reorderChild) : void(b !== a.zIndex && (this._batchNode && !this._reorderChildDirty && (this._setReorderChildDirtyRecursively(), this._batchNode.reorderBatch(!0)), cc.Node.prototype.reorderChild.call(this, a, b)))
    },
    removeChild: function(a, b) {
        this._batchNode && this._batchNode.removeSpriteFromAtlas(a), cc.Node.prototype.removeChild.call(this, a, b)
    },
    setVisible: function(a) {
        cc.Node.prototype.setVisible.call(this, a), this._renderCmd.setDirtyRecursively(!0)
    },
    removeAllChildren: function(a) {
        var b = this._children,
            c = this._batchNode;
        if (c && null != b)
            for (var d = 0, e = b.length; e > d; d++) c.removeSpriteFromAtlas(b[d]);
        cc.Node.prototype.removeAllChildren.call(this, a), this._hasChildren = !1
    },
    ignoreAnchorPointForPosition: function(a) {
        return this._batchNode ? void cc.log(cc._LogInfos.Sprite_ignoreAnchorPointForPosition) : void cc.Node.prototype.ignoreAnchorPointForPosition.call(this, a)
    },
    setFlippedX: function(a) {
        this._flippedX != a && (this._flippedX = a, this.setTextureRect(this._rect, this._rectRotated, this._contentSize), this.setNodeDirty(!0))
    },
    setFlippedY: function(a) {
        this._flippedY != a && (this._flippedY = a, this.setTextureRect(this._rect, this._rectRotated, this._contentSize), this.setNodeDirty(!0))
    },
    isFlippedX: function() {
        return this._flippedX
    },
    isFlippedY: function() {
        return this._flippedY
    },
    setOpacityModifyRGB: function(a) {
        this._opacityModifyRGB !== a && (this._opacityModifyRGB = a, this._renderCmd._setColorDirty())
    },
    isOpacityModifyRGB: function() {
        return this._opacityModifyRGB
    },
    setDisplayFrameWithAnimationName: function(a, b) {
        cc.assert(a, cc._LogInfos.Sprite_setDisplayFrameWithAnimationName_3);
        var c = cc.animationCache.getAnimation(a);
        if (!c) return void cc.log(cc._LogInfos.Sprite_setDisplayFrameWithAnimationName);
        var d = c.getFrames()[b];
        return d ? void this.setSpriteFrame(d.getSpriteFrame()) : void cc.log(cc._LogInfos.Sprite_setDisplayFrameWithAnimationName_2)
    },
    getBatchNode: function() {
        return this._batchNode
    },
    _setReorderChildDirtyRecursively: function() {
        if (!this._reorderChildDirty) {
            this._reorderChildDirty = !0;
            for (var a = this._parent; a && a != this._batchNode;) a._setReorderChildDirtyRecursively(), a = a.parent
        }
    },
    getTexture: function() {
        return this._texture
    },
    _softInit: function(a, b, c) {
        if (void 0 === a) cc.Sprite.prototype.init.call(this);
        else if (cc.isString(a))
            if ("#" === a[0]) {
                var d = a.substr(1, a.length - 1),
                    e = cc.spriteFrameCache.getSpriteFrame(d);
                this.initWithSpriteFrame(e)
            } else cc.Sprite.prototype.init.call(this, a, b);
        else if (cc.isObject(a))
            if (a instanceof cc.Texture2D) this.initWithTexture(a, b, c);
            else if (a instanceof cc.SpriteFrame) this.initWithSpriteFrame(a);
        else if (a instanceof HTMLImageElement || a instanceof HTMLCanvasElement) {
            var f = new cc.Texture2D;
            f.initWithElement(a), f.handleLoadedTexture(), this.initWithTexture(f)
        }
    },
    getQuad: function() {
        return this._renderCmd.getQuad()
    },
    setBlendFunc: function(a, b) {
        var c = this._blendFunc;
        void 0 === b ? (c.src = a.src, c.dst = a.dst) : (c.src = a, c.dst = b), this._renderCmd.updateBlendFunc(c)
    },
    init: function() {
        var a = this;
        return arguments.length > 0 ? a.initWithFile(arguments[0], arguments[1]) : (cc.Node.prototype.init.call(a), a.dirty = a._recursiveDirty = !1, a._blendFunc.src = cc.BLEND_SRC, a._blendFunc.dst = cc.BLEND_DST, a.texture = null, a._textureLoaded = !0, a._flippedX = a._flippedY = !1, a.anchorX = .5, a.anchorY = .5, a._offsetPosition.x = 0, a._offsetPosition.y = 0, a._hasChildren = !1, this._renderCmd._init(), a.setTextureRect(cc.rect(0, 0, 0, 0), !1, cc.size(0, 0)), !0)
    },
    initWithFile: function(a, b) {
        cc.assert(a, cc._LogInfos.Sprite_initWithFile);
        var c = cc.textureCache.getTextureForKey(a);
        if (c) {
            if (!b) {
                var d = c.getContentSize();
                b = cc.rect(0, 0, d.width, d.height)
            }
            return this.initWithTexture(c, b)
        }
        return c = cc.textureCache.addImage(a), this.initWithTexture(c, b || cc.rect(0, 0, c._contentSize.width, c._contentSize.height))
    },
    initWithTexture: function(a, b, c) {
        var d = this;
        if (cc.assert(0 != arguments.length, cc._LogInfos.CCSpriteBatchNode_initWithTexture), c = c || !1, a = this._renderCmd._handleTextureForRotatedTexture(a, b, c), !cc.Node.prototype.init.call(d)) return !1;
        d._batchNode = null, d._recursiveDirty = !1, d.dirty = !1, d._opacityModifyRGB = !0, d._blendFunc.src = cc.BLEND_SRC, d._blendFunc.dst = cc.BLEND_DST, d._flippedX = d._flippedY = !1, d.setAnchorPoint(.5, .5), d._offsetPosition.x = 0, d._offsetPosition.y = 0, d._hasChildren = !1, this._renderCmd._init();
        var e = a.isLoaded();
        return d._textureLoaded = e, e ? (b || (b = cc.rect(0, 0, a.width, a.height)), this._renderCmd._checkTextureBoundary(a, b, c), d.texture = a, d.setTextureRect(b, c), d.setBatchNode(null), !0) : (d._rectRotated = c, b && (d._rect.x = b.x, d._rect.y = b.y, d._rect.width = b.width, d._rect.height = b.height), d.texture && d.texture.removeEventListener("load", d), a.addEventListener("load", d._renderCmd._textureLoadedCallback, d), d.texture = a, !0)
    },
    setTextureRect: function(a, b, c, d) {
        var e = this;
        e._rectRotated = b || !1, e.setContentSize(c || a), e.setVertexRect(a), e._renderCmd._setTextureCoords(a, d);
        var f = e._unflippedOffsetPositionFromCenter;
        e._flippedX && (f.x = -f.x), e._flippedY && (f.y = -f.y);
        var g = e._rect;
        e._offsetPosition.x = f.x + (e._contentSize.width - g.width) / 2, e._offsetPosition.y = f.y + (e._contentSize.height - g.height) / 2, e._batchNode ? e.dirty = !0 : this._renderCmd._resetForBatchNode()
    },
    updateTransform: function() {
        this._renderCmd.updateTransform()
    },
    addChild: function(a, b, c) {
        cc.assert(a, cc._LogInfos.CCSpriteBatchNode_addChild_2), null == b && (b = a._localZOrder), null == c && (c = a.tag), this._renderCmd._setBatchNodeForAddChild(a) && (cc.Node.prototype.addChild.call(this, a, b, c), this._hasChildren = !0)
    },
    setSpriteFrame: function(a) {
        var b = this;
        cc.isString(a) && (a = cc.spriteFrameCache.getSpriteFrame(a), cc.assert(a, cc._LogInfos.Sprite_setSpriteFrame)), this.setNodeDirty(!0);
        var c = a.getOffset();
        b._unflippedOffsetPositionFromCenter.x = c.x, b._unflippedOffsetPositionFromCenter.y = c.y, b._rectRotated = a.isRotated();
        var d = a.getTexture(),
            e = a.textureLoaded();
        e || (b._textureLoaded = !1, a.addEventListener("load", function(a) {
            b._textureLoaded = !0;
            var c = a.getTexture();
            c != b._texture && (b.texture = c), b.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize()), b.dispatchEvent("load")
        }, b)), d != b._texture && (b.texture = d), b.setTextureRect(a.getRect(), b._rectRotated, a.getOriginalSize()), this._renderCmd._updateForSetSpriteFrame(d)
    },
    setDisplayFrame: function(a) {
        cc.log(cc._LogInfos.Sprite_setDisplayFrame), this.setSpriteFrame(a)
    },
    isFrameDisplayed: function(a) {
        return this._renderCmd.isFrameDisplayed(a)
    },
    displayFrame: function() {
        return new cc.SpriteFrame(this._texture, cc.rectPointsToPixels(this._rect), this._rectRotated, cc.pointPointsToPixels(this._unflippedOffsetPositionFromCenter), cc.sizePointsToPixels(this._contentSize))
    },
    setBatchNode: function(a) {
        var b = this;
        b._batchNode = a, b._batchNode ? (b._transformToBatch = cc.affineTransformIdentity(), b.textureAtlas = b._batchNode.getTextureAtlas()) : (b.atlasIndex = cc.Sprite.INDEX_NOT_INITIALIZED, b.textureAtlas = null, b._recursiveDirty = !1, b.dirty = !1, this._renderCmd._resetForBatchNode())
    },
    setTexture: function(a) {
        var b = this;
        if (a && cc.isString(a)) {
            a = cc.textureCache.addImage(a), b.setTexture(a);
            var c = a.getContentSize();
            return b.setTextureRect(cc.rect(0, 0, c.width, c.height)), void(a._isLoaded || a.addEventListener("load", function() {
                var c = a.getContentSize();
                b.setTextureRect(cc.rect(0, 0, c.width, c.height))
            }, this))
        }
        cc.assert(!a || a instanceof cc.Texture2D, cc._LogInfos.Sprite_setTexture_2), this._renderCmd._setTexture(a)
    },
    _createRenderCmd: function() {
        return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.Sprite.CanvasRenderCmd(this) : new cc.Sprite.WebGLRenderCmd(this)
    }
}), cc.Sprite.create = function(a, b, c) {
    return new cc.Sprite(a, b, c)
}, cc.Sprite.createWithTexture = cc.Sprite.create, cc.Sprite.createWithSpriteFrameName = cc.Sprite.create, cc.Sprite.createWithSpriteFrame = cc.Sprite.create, cc.Sprite.INDEX_NOT_INITIALIZED = -1, cc.EventHelper.prototype.apply(cc.Sprite.prototype), cc.assert(cc.isFunction(cc._tmp.PrototypeSprite), cc._LogInfos.MissingFile, "SpritesPropertyDefine.js"), cc._tmp.PrototypeSprite(), delete cc._tmp.PrototypeSprite, function() {
    cc.Sprite.CanvasRenderCmd = function(a) {
        cc.Node.CanvasRenderCmd.call(this, a), this._needDraw = !0, this._textureCoord = {
            renderX: 0,
            renderY: 0,
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            validRect: !1
        }, this._blendFuncStr = "source-over", this._colorized = !1, this._originalTexture = null
    };
    var a = cc.Sprite.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    a.constructor = cc.Sprite.CanvasRenderCmd, a._init = function() {}, a._setBlendFuncStr = function(a) {
        this._blendFuncStr = a
    }, a.setDirtyRecursively = function() {}, a._resetForBatchNode = function() {}, a._setTexture = function(a) {
        var b = this._node;
        b._texture != a && (a && a.getHtmlElementObj() instanceof HTMLImageElement && (this._originalTexture = a), b._texture = a)
    }, a._setColorDirty = function() {
        this.setDirtyFlag(cc.Node._dirtyFlags.colorDirty | cc.Node._dirtyFlags.opacityDirty)
    }, a.isFrameDisplayed = function(a) {
        var b = this._node;
        return a.getTexture() != b._texture ? !1 : cc.rectEqualToRect(a.getRect(), b._rect)
    }, a.updateBlendFunc = function(a) {
        this._blendFuncStr = cc.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc(a)
    }, a._setBatchNodeForAddChild = function() {
        return !0
    }, a._handleTextureForRotatedTexture = function(a, b, c) {
        if (c && a.isLoaded()) {
            var d = a.getHtmlElementObj();
            d = cc.Sprite.CanvasRenderCmd._cutRotateImageToCanvas(d, b);
            var e = new cc.Texture2D;
            e.initWithElement(d), e.handleLoadedTexture(), a = e, this._node._rect = cc.rect(0, 0, b.width, b.height)
        }
        return a
    }, a._checkTextureBoundary = function(a, b) {
        if (a && a.url) {
            var c = b.x + b.width,
                d = b.y + b.height;
            c > a.width && cc.error(cc._LogInfos.RectWidth, a.url), d > a.height && cc.error(cc._LogInfos.RectHeight, a.url)
        }
        this._node._originalTexture = a
    }, a.rendering = function(a, b, c) {
        var d = this._node,
            e = this._textureCoord,
            f = this._displayedOpacity / 255;
        if ((!d._texture || 0 !== e.width && 0 !== e.height && d._texture._isLoaded) && 0 !== f) {
            var g, h = a || cc._renderContext,
                i = h.getContext(),
                j = d._offsetPosition.x,
                k = d._rect.height,
                l = d._rect.width,
                m = -d._offsetPosition.y - k;
            if (h.setCompositeOperation(this._blendFuncStr), h.setGlobalAlpha(f), h.setTransform(this._worldTransform, b, c), (d._flippedX || d._flippedY) && h.save(), d._flippedX && (j = -j - l, i.scale(-1, 1)), d._flippedY && (m = d._offsetPosition.y, i.scale(1, -1)), d._texture) g = d._texture._htmlElementObj, "" != d._texture._pattern ? (h.setFillStyle(i.createPattern(g, d._texture._pattern)), i.fillRect(j * b, m * c, l * b, k * c)) : this._colorized ? i.drawImage(g, 0, 0, e.width, e.height, j * b, m * c, l * b, k * c) : i.drawImage(g, e.renderX, e.renderY, e.width, e.height, j * b, m * c, l * b, k * c);
            else {
                var n = d._contentSize;
                if (e.validRect) {
                    var o = this._displayedColor;
                    h.setFillStyle("rgba(" + o.r + "," + o.g + "," + o.b + ",1)"), i.fillRect(j * b, m * c, n.width * b, n.height * c)
                }
            }(d._flippedX || d._flippedY) && h.restore(), cc.g_NumberOfDraws++
        }
    }, a._updateColor = function() {
        var a = this._node,
            b = this._displayedColor;
        if (this._colorized) {
            if (255 === b.r && 255 === b.g && 255 === b.b) return this._colorized = !1, void(a.texture = this._originalTexture)
        } else if (255 === b.r && 255 === b.g && 255 === b.b) return;
        var c, d = a._texture,
            e = this._textureCoord;
        if (d && e.validRect && this._originalTexture) {
            if (c = d.getHtmlElementObj(), !c) return;
            if (cc.sys._supportCanvasNewBlendModes) this._colorized = !0, c instanceof HTMLCanvasElement && !this._rectRotated && !this._newTextureWhenChangeColor && this._originalTexture._htmlElementObj != c ? cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply(this._originalTexture._htmlElementObj, b, e, c) : (c = cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply(this._originalTexture._htmlElementObj, b, e), d = new cc.Texture2D, d.initWithElement(c), d.handleLoadedTexture(), a.texture = d);
            else {
                var f = cc.textureCache.getTextureColors(this._originalTexture.getHtmlElementObj());
                f && (this._colorized = !0, c instanceof HTMLCanvasElement && !this._rectRotated && !this._newTextureWhenChangeColor ? cc.Sprite.CanvasRenderCmd._generateTintImage(c, f, b, e, c) : (c = cc.Sprite.CanvasRenderCmd._generateTintImage(c, f, b, e), d = new cc.Texture2D, d.initWithElement(c), d.handleLoadedTexture(), a.texture = d))
            }
        }
    }, a.getQuad = function() {
        return null
    }, a._updateForSetSpriteFrame = function(a, b) {
        var c = this._node;
        if (c._rectRotated && (c._originalTexture = a), this._colorized = !1, this._textureCoord.renderX = this._textureCoord.x, this._textureCoord.renderY = this._textureCoord.y, b) {
            var d = c.getColor();
            (255 !== d.r || 255 !== d.g || 255 !== d.b) && this._updateColor()
        }
    }, a.updateTransform = function() {
        var a = this,
            b = this._node;
        if (b.dirty) {
            var c = b._parent;
            !b._visible || c && c != b._batchNode && c._shouldBeHidden ? b._shouldBeHidden = !0 : (b._shouldBeHidden = !1, b._transformToBatch = c && c != b._batchNode ? cc.affineTransformConcat(a.getNodeToParentTransform(), c._transformToBatch) : a.getNodeToParentTransform()), b._recursiveDirty = !1, b.dirty = !1
        }
        b._hasChildren && b._arrayMakeObjectsPerformSelector(b._children, cc.Node._stateCallbackType.updateTransform)
    }, a._updateDisplayColor = function(a) {
        cc.Node.CanvasRenderCmd.prototype._updateDisplayColor.call(this, a), this._updateColor()
    }, a._spriteFrameLoadedCallback = function(a) {
        var b = this;
        b.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize());
        var c = b.getColor();
        (255 !== c.r || 255 !== c.g || 255 !== c.b) && b._updateColor(), b.dispatchEvent("load")
    }, a._textureLoadedCallback = function(a) {
        var b = this;
        if (!b._textureLoaded) {
            b._textureLoaded = !0;
            var c = b._rect,
                d = this._renderCmd;
            c ? cc._rectEqualToZero(c) && (c.width = a.width, c.height = a.height) : c = cc.rect(0, 0, a.width, a.height), d._originalTexture = a, b.texture = a, b.setTextureRect(c, b._rectRotated);
            var e = d._displayedColor;
            (255 != e.r || 255 != e.g || 255 != e.b) && d._updateColor(), b.setBatchNode(b._batchNode), b.dispatchEvent("load")
        }
    }, a._setTextureCoords = function(a, b) {
        void 0 === b && (b = !0);
        var c = this._textureCoord,
            d = b ? cc.contentScaleFactor() : 1;
        c.renderX = c.x = 0 | a.x * d, c.renderY = c.y = 0 | a.y * d, c.width = 0 | a.width * d, c.height = 0 | a.height * d, c.validRect = !(0 === c.width || 0 === c.height || c.x < 0 || c.y < 0)
    }, cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply = function(a, b, c, d) {
        d = d || cc.newElement("canvas"), c = c || cc.rect(0, 0, a.width, a.height);
        var e = d.getContext("2d");
        return d.width != c.width || d.height != c.height ? (d.width = c.width, d.height = c.height) : e.globalCompositeOperation = "source-over", e.fillStyle = "rgb(" + (0 | b.r) + "," + (0 | b.g) + "," + (0 | b.b) + ")", e.fillRect(0, 0, c.width, c.height), e.globalCompositeOperation = "multiply", e.drawImage(a, c.x, c.y, c.width, c.height, 0, 0, c.width, c.height), e.globalCompositeOperation = "destination-atop", e.drawImage(a, c.x, c.y, c.width, c.height, 0, 0, c.width, c.height), d
    }, cc.Sprite.CanvasRenderCmd._generateTintImage = function(a, b, c, d, e) {
        d || (d = cc.rect(0, 0, a.width, a.height));
        var f, g = c.r / 255,
            h = c.g / 255,
            i = c.b / 255,
            j = Math.min(d.width, b[0].width),
            k = Math.min(d.height, b[0].height),
            l = e;
        l ? (f = l.getContext("2d"), f.clearRect(0, 0, j, k)) : (l = cc.newElement("canvas"), l.width = j, l.height = k, f = l.getContext("2d")), f.globalCompositeOperation = "lighter";
        var m = f.globalAlpha;
        return g > 0 && (f.globalAlpha = g * m, f.drawImage(b[0], d.x, d.y, j, k, 0, 0, j, k)), h > 0 && (f.globalAlpha = h * m, f.drawImage(b[1], d.x, d.y, j, k, 0, 0, j, k)), i > 0 && (f.globalAlpha = i * m, f.drawImage(b[2], d.x, d.y, j, k, 0, 0, j, k)), 1 > g + h + i && (f.globalAlpha = m, f.drawImage(b[3], d.x, d.y, j, k, 0, 0, j, k)), l
    }, cc.Sprite.CanvasRenderCmd._generateTextureCacheForColor = function(a) {
        function b() {
            var b = cc.Sprite.CanvasRenderCmd._generateTextureCacheForColor,
                d = a.width,
                e = a.height;
            c[0].width = d, c[0].height = e, c[1].width = d, c[1].height = e, c[2].width = d, c[2].height = e, c[3].width = d, c[3].height = e, b.canvas.width = d, b.canvas.height = e;
            var f = b.canvas.getContext("2d");
            f.drawImage(a, 0, 0), b.tempCanvas.width = d, b.tempCanvas.height = e;
            for (var g = f.getImageData(0, 0, d, e).data, h = 0; 4 > h; h++) {
                var i = c[h].getContext("2d");
                i.getImageData(0, 0, d, e).data, b.tempCtx.drawImage(a, 0, 0);
                for (var j = b.tempCtx.getImageData(0, 0, d, e), k = j.data, l = 0; l < g.length; l += 4) k[l] = 0 === h ? g[l] : 0, k[l + 1] = 1 === h ? g[l + 1] : 0, k[l + 2] = 2 === h ? g[l + 2] : 0, k[l + 3] = g[l + 3];
                i.putImageData(j, 0, 0)
            }
            a.onload = null
        }
        if (a.channelCache) return a.channelCache;
        var c = [cc.newElement("canvas"), cc.newElement("canvas"), cc.newElement("canvas"), cc.newElement("canvas")];
        try {
            b()
        } catch (d) {
            a.onload = b
        }
        return a.channelCache = c, c
    }, cc.Sprite.CanvasRenderCmd._generateTextureCacheForColor.canvas = cc.newElement("canvas"), cc.Sprite.CanvasRenderCmd._generateTextureCacheForColor.tempCanvas = cc.newElement("canvas"), cc.Sprite.CanvasRenderCmd._generateTextureCacheForColor.tempCtx = cc.Sprite.CanvasRenderCmd._generateTextureCacheForColor.tempCanvas.getContext("2d"), cc.Sprite.CanvasRenderCmd._cutRotateImageToCanvas = function(a, b) {
        if (!a) return null;
        if (!b) return a;
        var c = cc.newElement("canvas");
        c.width = b.width, c.height = b.height;
        var d = c.getContext("2d");
        return d.translate(c.width / 2, c.height / 2), d.rotate(-1.5707963267948966), d.drawImage(a, b.x, b.y, b.height, b.width, -b.height / 2, -b.width / 2, b.height, b.width), c
    }
}(), cc.BakeSprite = cc.Sprite.extend({
    _cacheCanvas: null,
    _cacheContext: null,
    ctor: function() {
        cc.Sprite.prototype.ctor.call(this);
        var a = document.createElement("canvas");
        a.width = a.height = 10, this._cacheCanvas = a, this._cacheContext = new cc.CanvasContextWrapper(a.getContext("2d"));
        var b = new cc.Texture2D;
        b.initWithElement(a), b.handleLoadedTexture(), this.setTexture(b)
    },
    getCacheContext: function() {
        return this._cacheContext
    },
    getCacheCanvas: function() {
        return this._cacheCanvas
    },
    resetCanvasSize: function(a, b) {
        void 0 === b && (b = a.height, a = a.width);
        var c = this._cacheCanvas;
        c.width = a, c.height = b, this.getTexture().handleLoadedTexture(), this.setTextureRect(cc.rect(0, 0, a, b), !1)
    }
}), cc.AnimationFrame = cc.Class.extend({
    _spriteFrame: null,
    _delayPerUnit: 0,
    _userInfo: null,
    ctor: function(a, b, c) {
        this._spriteFrame = a || null, this._delayPerUnit = b || 0, this._userInfo = c || null
    },
    clone: function() {
        var a = new cc.AnimationFrame;
        return a.initWithSpriteFrame(this._spriteFrame.clone(), this._delayPerUnit, this._userInfo), a
    },
    copyWithZone: function() {
        return cc.clone(this)
    },
    copy: function() {
        var a = new cc.AnimationFrame;
        return a.initWithSpriteFrame(this._spriteFrame.clone(), this._delayPerUnit, this._userInfo), a
    },
    initWithSpriteFrame: function(a, b, c) {
        return this._spriteFrame = a, this._delayPerUnit = b, this._userInfo = c, !0
    },
    getSpriteFrame: function() {
        return this._spriteFrame
    },
    setSpriteFrame: function(a) {
        this._spriteFrame = a
    },
    getDelayUnits: function() {
        return this._delayPerUnit
    },
    setDelayUnits: function(a) {
        this._delayPerUnit = a
    },
    getUserInfo: function() {
        return this._userInfo
    },
    setUserInfo: function(a) {
        this._userInfo = a
    }
}), cc.AnimationFrame.create = function(a, b, c) {
    return new cc.AnimationFrame(a, b, c)
}, cc.Animation = cc.Class.extend({
    _frames: null,
    _loops: 0,
    _restoreOriginalFrame: !1,
    _duration: 0,
    _delayPerUnit: 0,
    _totalDelayUnits: 0,
    ctor: function(a, b, c) {
        if (this._frames = [], void 0 === a) this.initWithSpriteFrames(null, 0);
        else {
            var d = a[0];
            d && (d instanceof cc.SpriteFrame ? this.initWithSpriteFrames(a, b, c) : d instanceof cc.AnimationFrame && this.initWithAnimationFrames(a, b, c))
        }
    },
    getFrames: function() {
        return this._frames
    },
    setFrames: function(a) {
        this._frames = a
    },
    addSpriteFrame: function(a) {
        var b = new cc.AnimationFrame;
        b.initWithSpriteFrame(a, 1, null), this._frames.push(b), this._totalDelayUnits++
    },
    addSpriteFrameWithFile: function(a) {
        var b = cc.textureCache.addImage(a),
            c = cc.rect(0, 0, 0, 0);
        c.width = b.width, c.height = b.height;
        var d = new cc.SpriteFrame(b, c);
        this.addSpriteFrame(d)
    },
    addSpriteFrameWithTexture: function(a, b) {
        var c = new cc.SpriteFrame(a, b);
        this.addSpriteFrame(c)
    },
    initWithAnimationFrames: function(a, b, c) {
        cc.arrayVerifyType(a, cc.AnimationFrame), this._delayPerUnit = b, this._loops = void 0 === c ? 1 : c, this._totalDelayUnits = 0;
        var d = this._frames;
        d.length = 0;
        for (var e = 0; e < a.length; e++) {
            var f = a[e];
            d.push(f), this._totalDelayUnits += f.getDelayUnits()
        }
        return !0
    },
    clone: function() {
        var a = new cc.Animation;
        return a.initWithAnimationFrames(this._copyFrames(), this._delayPerUnit, this._loops), a.setRestoreOriginalFrame(this._restoreOriginalFrame), a
    },
    copyWithZone: function() {
        var a = new cc.Animation;
        return a.initWithAnimationFrames(this._copyFrames(), this._delayPerUnit, this._loops), a.setRestoreOriginalFrame(this._restoreOriginalFrame), a
    },
    _copyFrames: function() {
        for (var a = [], b = 0; b < this._frames.length; b++) a.push(this._frames[b].clone());
        return a
    },
    copy: function() {
        return this.copyWithZone(null)
    },
    getLoops: function() {
        return this._loops
    },
    setLoops: function(a) {
        this._loops = a
    },
    setRestoreOriginalFrame: function(a) {
        this._restoreOriginalFrame = a
    },
    getRestoreOriginalFrame: function() {
        return this._restoreOriginalFrame
    },
    getDuration: function() {
        return this._totalDelayUnits * this._delayPerUnit
    },
    getDelayPerUnit: function() {
        return this._delayPerUnit
    },
    setDelayPerUnit: function(a) {
        this._delayPerUnit = a
    },
    getTotalDelayUnits: function() {
        return this._totalDelayUnits
    },
    initWithSpriteFrames: function(a, b, c) {
        cc.arrayVerifyType(a, cc.SpriteFrame), this._loops = void 0 === c ? 1 : c, this._delayPerUnit = b || 0, this._totalDelayUnits = 0;
        var d = this._frames;
        if (d.length = 0, a) {
            for (var e = 0; e < a.length; e++) {
                var f = a[e],
                    g = new cc.AnimationFrame;
                g.initWithSpriteFrame(f, 1, null), d.push(g)
            }
            this._totalDelayUnits += a.length
        }
        return !0
    },
    retain: function() {},
    release: function() {}
}), cc.Animation.create = function(a, b, c) {
    return new cc.Animation(a, b, c)
}, cc.Animation.createWithAnimationFrames = cc.Animation.create, cc.animationCache = {
    _animations: {},
    addAnimation: function(a, b) {
        this._animations[b] = a
    },
    removeAnimation: function(a) {
        a && this._animations[a] && delete this._animations[a]
    },
    getAnimation: function(a) {
        return this._animations[a] ? this._animations[a] : null
    },
    _addAnimationsWithDictionary: function(a, b) {
        var c = a.animations;
        if (!c) return void cc.log(cc._LogInfos.animationCache__addAnimationsWithDictionary);
        var d = 1,
            e = a.properties;
        if (e) {
            d = null != e.format ? parseInt(e.format) : d;
            for (var f = e.spritesheets, g = cc.spriteFrameCache, h = cc.path, i = 0; i < f.length; i++) g.addSpriteFrames(h.changeBasename(b, f[i]))
        }
        switch (d) {
            case 1:
                this._parseVersion1(c);
                break;
            case 2:
                this._parseVersion2(c);
                break;
            default:
                cc.log(cc._LogInfos.animationCache__addAnimationsWithDictionary_2)
        }
    },
    addAnimations: function(a) {
        cc.assert(a, cc._LogInfos.animationCache_addAnimations_2);
        var b = cc.loader.getRes(a);
        return b ? void this._addAnimationsWithDictionary(b, a) : void cc.log(cc._LogInfos.animationCache_addAnimations)
    },
    _parseVersion1: function(a) {
        var b = cc.spriteFrameCache;
        for (var c in a) {
            var d = a[c],
                e = d.frames,
                f = parseFloat(d.delay) || 0,
                g = null;
            if (e) {
                for (var h = [], i = 0; i < e.length; i++) {
                    var j = b.getSpriteFrame(e[i]);
                    if (j) {
                        var k = new cc.AnimationFrame;
                        k.initWithSpriteFrame(j, 1, null), h.push(k)
                    } else cc.log(cc._LogInfos.animationCache__parseVersion1_2, c, e[i])
                }
                0 !== h.length ? (h.length != e.length && cc.log(cc._LogInfos.animationCache__parseVersion1_4, c), g = new cc.Animation(h, f, 1), cc.animationCache.addAnimation(g, c)) : cc.log(cc._LogInfos.animationCache__parseVersion1_3, c)
            } else cc.log(cc._LogInfos.animationCache__parseVersion1, c)
        }
    },
    _parseVersion2: function(a) {
        var b = cc.spriteFrameCache;
        for (var c in a) {
            var d = a[c],
                e = d.loop,
                f = parseInt(d.loops),
                g = e ? cc.REPEAT_FOREVER : isNaN(f) ? 1 : f,
                h = d.restoreOriginalFrame && 1 == d.restoreOriginalFrame ? !0 : !1,
                i = d.frames;
            if (i) {
                for (var j = [], k = 0; k < i.length; k++) {
                    var l = i[k],
                        m = l.spriteframe,
                        n = b.getSpriteFrame(m);
                    if (n) {
                        var o = parseFloat(l.delayUnits) || 0,
                            p = l.notification,
                            q = new cc.AnimationFrame;
                        q.initWithSpriteFrame(n, o, p), j.push(q)
                    } else cc.log(cc._LogInfos.animationCache__parseVersion2_2, c, m)
                }
                var r = parseFloat(d.delayPerUnit) || 0,
                    s = new cc.Animation;
                s.initWithAnimationFrames(j, r, g), s.setRestoreOriginalFrame(h), cc.animationCache.addAnimation(s, c)
            } else cc.log(cc._LogInfos.animationCache__parseVersion2, c)
        }
    },
    _clear: function() {
        this._animations = {}
    }
}, cc.SpriteFrame = cc.Class.extend({
    _offset: null,
    _originalSize: null,
    _rectInPixels: null,
    _rotated: !1,
    _rect: null,
    _offsetInPixels: null,
    _originalSizeInPixels: null,
    _texture: null,
    _textureFilename: "",
    _textureLoaded: !1,
    ctor: function(a, b, c, d, e) {
        this._offset = cc.p(0, 0), this._offsetInPixels = cc.p(0, 0), this._originalSize = cc.size(0, 0), this._rotated = !1, this._originalSizeInPixels = cc.size(0, 0), this._textureFilename = "", this._texture = null, this._textureLoaded = !1, void 0 !== a && void 0 !== b && (void 0 === c || void 0 === d || void 0 === e ? this.initWithTexture(a, b) : this.initWithTexture(a, b, c, d, e))
    },
    textureLoaded: function() {
        return this._textureLoaded
    },
    addLoadedEventListener: function(a, b) {
        this.addEventListener("load", a, b)
    },
    getRectInPixels: function() {
        var a = this._rectInPixels;
        return cc.rect(a.x, a.y, a.width, a.height)
    },
    setRectInPixels: function(a) {
        this._rectInPixels || (this._rectInPixels = cc.rect(0, 0, 0, 0)), this._rectInPixels.x = a.x, this._rectInPixels.y = a.y, this._rectInPixels.width = a.width, this._rectInPixels.height = a.height, this._rect = cc.rectPixelsToPoints(a)
    },
    isRotated: function() {
        return this._rotated
    },
    setRotated: function(a) {
        this._rotated = a
    },
    getRect: function() {
        var a = this._rect;
        return cc.rect(a.x, a.y, a.width, a.height)
    },
    setRect: function(a) {
        this._rect || (this._rect = cc.rect(0, 0, 0, 0)), this._rect.x = a.x, this._rect.y = a.y, this._rect.width = a.width, this._rect.height = a.height, this._rectInPixels = cc.rectPointsToPixels(this._rect)
    },
    getOffsetInPixels: function() {
        return cc.p(this._offsetInPixels)
    },
    setOffsetInPixels: function(a) {
        this._offsetInPixels.x = a.x, this._offsetInPixels.y = a.y, cc._pointPixelsToPointsOut(this._offsetInPixels, this._offset)
    },
    getOriginalSizeInPixels: function() {
        return cc.size(this._originalSizeInPixels)
    },
    setOriginalSizeInPixels: function(a) {
        this._originalSizeInPixels.width = a.width, this._originalSizeInPixels.height = a.height
    },
    getOriginalSize: function() {
        return cc.size(this._originalSize)
    },
    setOriginalSize: function(a) {
        this._originalSize.width = a.width, this._originalSize.height = a.height
    },
    getTexture: function() {
        if (this._texture) return this._texture;
        if ("" !== this._textureFilename) {
            var a = cc.textureCache.addImage(this._textureFilename);
            return a && (this._textureLoaded = a.isLoaded()), a
        }
        return null
    },
    setTexture: function(a) {
        if (this._texture != a) {
            var b = a.isLoaded();
            this._textureLoaded = b, this._texture = a, b || a.addEventListener("load", function(a) {
                if (this._textureLoaded = !0, this._rotated && cc._renderType === cc._RENDER_TYPE_CANVAS) {
                    var b = a.getHtmlElementObj();
                    b = cc.Sprite.CanvasRenderCmd._cutRotateImageToCanvas(b, this.getRect());
                    var c = new cc.Texture2D;
                    c.initWithElement(b), c.handleLoadedTexture(), this.setTexture(c);
                    var d = this.getRect();
                    this.setRect(cc.rect(0, 0, d.width, d.height))
                }
                var e = this._rect;
                if (0 === e.width && 0 === e.height) {
                    var f = a.width,
                        g = a.height;
                    this._rect.width = f, this._rect.height = g, this._rectInPixels = cc.rectPointsToPixels(this._rect), this._originalSizeInPixels.width = this._rectInPixels.width, this._originalSizeInPixels.height = this._rectInPixels.height, this._originalSize.width = f, this._originalSize.height = g
                }
                this.dispatchEvent("load")
            }, this)
        }
    },
    getOffset: function() {
        return cc.p(this._offset)
    },
    setOffset: function(a) {
        this._offset.x = a.x, this._offset.y = a.y
    },
    clone: function() {
        var a = new cc.SpriteFrame;
        return a.initWithTexture(this._textureFilename, this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels), a.setTexture(this._texture), a
    },
    copyWithZone: function() {
        var a = new cc.SpriteFrame;
        return a.initWithTexture(this._textureFilename, this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels), a.setTexture(this._texture), a
    },
    copy: function() {
        return this.copyWithZone()
    },
    initWithTexture: function(a, b, c, d, e) {
        if (2 === arguments.length && (b = cc.rectPointsToPixels(b)), d = d || cc.p(0, 0), e = e || b, c = c || !1, cc.isString(a) ? (this._texture = null, this._textureFilename = a) : a instanceof cc.Texture2D && this.setTexture(a), a = this.getTexture(), this._rectInPixels = b, b = this._rect = cc.rectPixelsToPoints(b), a && a.url && a.isLoaded()) {
            var f, g;
            c ? (f = b.x + b.height, g = b.y + b.width) : (f = b.x + b.width, g = b.y + b.height), f > a.getPixelsWide() && cc.error(cc._LogInfos.RectWidth, a.url), g > a.getPixelsHigh() && cc.error(cc._LogInfos.RectHeight, a.url)
        }
        return this._offsetInPixels.x = d.x, this._offsetInPixels.y = d.y, cc._pointPixelsToPointsOut(d, this._offset), this._originalSizeInPixels.width = e.width, this._originalSizeInPixels.height = e.height, cc._sizePixelsToPointsOut(e, this._originalSize), this._rotated = c, !0
    }
}), cc.EventHelper.prototype.apply(cc.SpriteFrame.prototype), cc.SpriteFrame.create = function(a, b, c, d, e) {
    return new cc.SpriteFrame(a, b, c, d, e)
}, cc.SpriteFrame.createWithTexture = cc.SpriteFrame.create, cc.SpriteFrame._frameWithTextureForCanvas = function(a, b, c, d, e) {
    var f = new cc.SpriteFrame;
    return f._texture = a, f._rectInPixels = b, f._rect = cc.rectPixelsToPoints(b), f._offsetInPixels.x = d.x, f._offsetInPixels.y = d.y, cc._pointPixelsToPointsOut(f._offsetInPixels, f._offset), f._originalSizeInPixels.width = e.width, f._originalSizeInPixels.height = e.height, cc._sizePixelsToPointsOut(f._originalSizeInPixels, f._originalSize), f._rotated = c, f
}, cc.spriteFrameCache = {
    _CCNS_REG1: /^\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*$/,
    _CCNS_REG2: /^\s*\{\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*,\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*\}\s*$/,
    _spriteFrames: {},
    _spriteFramesAliases: {},
    _frameConfigCache: {},
    _rectFromString: function(a) {
        var b = this._CCNS_REG2.exec(a);
        return b ? cc.rect(parseFloat(b[1]), parseFloat(b[2]), parseFloat(b[3]), parseFloat(b[4])) : cc.rect(0, 0, 0, 0)
    },
    _pointFromString: function(a) {
        var b = this._CCNS_REG1.exec(a);
        return b ? cc.p(parseFloat(b[1]), parseFloat(b[2])) : cc.p(0, 0)
    },
    _sizeFromString: function(a) {
        var b = this._CCNS_REG1.exec(a);
        return b ? cc.size(parseFloat(b[1]), parseFloat(b[2])) : cc.size(0, 0)
    },
    _getFrameConfig: function(a) {
        var b = cc.loader.getRes(a);
        if (cc.assert(b, cc._LogInfos.spriteFrameCache__getFrameConfig_2, a), cc.loader.release(a), b._inited) return this._frameConfigCache[a] = b, b;
        var c = b.frames,
            d = b.metadata || b.meta,
            e = {},
            f = {},
            g = 0;
        if (d) {
            var h = d.format;
            g = h.length <= 1 ? parseInt(h) : h, f.image = d.textureFileName || d.textureFileName || d.image
        }
        for (var i in c) {
            var j = c[i];
            if (j) {
                var k = {};
                if (0 == g) {
                    k.rect = cc.rect(j.x, j.y, j.width, j.height), k.rotated = !1, k.offset = cc.p(j.offsetX, j.offsetY);
                    var l = j.originalWidth,
                        m = j.originalHeight;
                    l && m || cc.log(cc._LogInfos.spriteFrameCache__getFrameConfig), l = Math.abs(l), m = Math.abs(m), k.size = cc.size(l, m)
                } else if (1 == g || 2 == g) k.rect = this._rectFromString(j.frame), k.rotated = j.rotated || !1, k.offset = this._pointFromString(j.offset), k.size = this._sizeFromString(j.sourceSize);
                else if (3 == g) {
                    var n = this._sizeFromString(j.spriteSize),
                        o = this._rectFromString(j.textureRect);
                    n && (o = cc.rect(o.x, o.y, n.width, n.height)), k.rect = o, k.rotated = j.textureRotated || !1, k.offset = this._pointFromString(j.spriteOffset), k.size = this._sizeFromString(j.spriteSourceSize), k.aliases = j.aliases
                } else {
                    var p = j.frame,
                        q = j.sourceSize;
                    i = j.filename || i, k.rect = cc.rect(p.x, p.y, p.w, p.h), k.rotated = j.rotated || !1, k.offset = cc.p(0, 0), k.size = cc.size(q.w, q.h)
                }
                e[i] = k
            }
        }
        var r = this._frameConfigCache[a] = {
            _inited: !0,
            frames: e,
            meta: f
        };
        return r
    },
    addSpriteFrames: function(a, b) {
        cc.assert(a, cc._LogInfos.spriteFrameCache_addSpriteFrames_2);
        var c = this._frameConfigCache[a] || cc.loader.getRes(a);
        if (c && c.frames) {
            var d = this,
                e = d._frameConfigCache[a] || d._getFrameConfig(a),
                f = e.frames,
                g = e.meta;
            if (b) b instanceof cc.Texture2D || (cc.isString(b) ? b = cc.textureCache.addImage(b) : cc.assert(0, cc._LogInfos.spriteFrameCache_addSpriteFrames_3));
            else {
                var h = cc.path.changeBasename(a, g.image || ".png");
                b = cc.textureCache.addImage(h)
            }
            var i = d._spriteFramesAliases,
                j = d._spriteFrames;
            for (var k in f) {
                var l = f[k],
                    m = j[k];
                if (!m) {
                    m = new cc.SpriteFrame(b, l.rect, l.rotated, l.offset, l.size);
                    var n = l.aliases;
                    if (n)
                        for (var o = 0, p = n.length; p > o; o++) {
                            var q = n[o];
                            i[q] && cc.log(cc._LogInfos.spriteFrameCache_addSpriteFrames, q), i[q] = k
                        }
                    if (cc._renderType === cc._RENDER_TYPE_CANVAS && m.isRotated()) {
                        var r = m.getTexture();
                        if (r.isLoaded()) {
                            var s = m.getTexture().getHtmlElementObj();
                            s = cc.Sprite.CanvasRenderCmd._cutRotateImageToCanvas(s, m.getRectInPixels());
                            var t = new cc.Texture2D;
                            t.initWithElement(s), t.handleLoadedTexture(), m.setTexture(t);
                            var u = m._rect;
                            m.setRect(cc.rect(0, 0, u.width, u.height))
                        }
                    }
                    j[k] = m
                }
            }
        }
    },
    _checkConflict: function(a) {
        var b = a.frames;
        for (var c in b) this._spriteFrames[c] && cc.log(cc._LogInfos.spriteFrameCache__checkConflict, c)
    },
    addSpriteFrame: function(a, b) {
        this._spriteFrames[b] = a
    },
    removeSpriteFrames: function() {
        this._spriteFrames = {}, this._spriteFramesAliases = {}
    },
    removeSpriteFrameByName: function(a) {
        a && (this._spriteFramesAliases[a] && delete this._spriteFramesAliases[a], this._spriteFrames[a] && delete this._spriteFrames[a])
    },
    removeSpriteFramesFromFile: function(a) {
        var b = this,
            c = b._spriteFrames,
            d = b._spriteFramesAliases,
            e = b._frameConfigCache[a];
        if (e) {
            var f = e.frames;
            for (var g in f)
                if (c[g]) {
                    delete c[g];
                    for (var h in d) d[h] == g && delete d[h]
                }
        }
    },
    removeSpriteFramesFromTexture: function(a) {
        var b = this,
            c = b._spriteFrames,
            d = b._spriteFramesAliases;
        for (var e in c) {
            var f = c[e];
            if (f && f.getTexture() == a) {
                delete c[e];
                for (var g in d) d[g] == e && delete d[g]
            }
        }
    },
    getSpriteFrame: function(a) {
        var b = this,
            c = b._spriteFrames[a];
        if (!c) {
            var d = b._spriteFramesAliases[a];
            d && (c = b._spriteFrames[d.toString()], c || delete b._spriteFramesAliases[a])
        }
        return c || cc.log(cc._LogInfos.spriteFrameCache_getSpriteFrame, a), c
    },
    _clear: function() {
        this._spriteFrames = {}, this._spriteFramesAliases = {}, this._frameConfigCache = {}
    }
}, cc.g_NumberOfDraws = 0, cc.GLToClipTransform = function(a) {
    var b = new cc.kmMat4;
    cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, b);
    var c = new cc.kmMat4;
    cc.kmGLGetMatrix(cc.KM_GL_MODELVIEW, c), cc.kmMat4Multiply(a, b, c)
}, cc.Director = cc.Class.extend({
    _landscape: !1,
    _nextDeltaTimeZero: !1,
    _paused: !1,
    _purgeDirectorInNextLoop: !1,
    _sendCleanupToScene: !1,
    _animationInterval: 0,
    _oldAnimationInterval: 0,
    _projection: 0,
    _accumDt: 0,
    _contentScaleFactor: 1,
    _displayStats: !1,
    _deltaTime: 0,
    _frameRate: 0,
    _FPSLabel: null,
    _SPFLabel: null,
    _drawsLabel: null,
    _winSizeInPoints: null,
    _lastUpdate: null,
    _nextScene: null,
    _notificationNode: null,
    _openGLView: null,
    _scenesStack: null,
    _projectionDelegate: null,
    _runningScene: null,
    _frames: 0,
    _totalFrames: 0,
    _secondsPerFrame: 0,
    _dirtyRegion: null,
    _scheduler: null,
    _actionManager: null,
    _eventProjectionChanged: null,
    _eventAfterDraw: null,
    _eventAfterVisit: null,
    _eventAfterUpdate: null,
    ctor: function() {
        var a = this;
        a._lastUpdate = Date.now(), cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function() {
            a._lastUpdate = Date.now()
        })
    },
    init: function() {
        return this._oldAnimationInterval = this._animationInterval = 1 / cc.defaultFPS, this._scenesStack = [], this._projection = cc.Director.PROJECTION_DEFAULT, this._projectionDelegate = null, this._accumDt = 0, this._frameRate = 0, this._displayStats = !1, this._totalFrames = this._frames = 0, this._lastUpdate = Date.now(), this._paused = !1, this._purgeDirectorInNextLoop = !1, this._winSizeInPoints = cc.size(0, 0), this._openGLView = null, this._contentScaleFactor = 1, this._scheduler = new cc.Scheduler, this._actionManager = cc.ActionManager ? new cc.ActionManager : null, this._scheduler.scheduleUpdateForTarget(this._actionManager, cc.Scheduler.PRIORITY_SYSTEM, !1), this._eventAfterDraw = new cc.EventCustom(cc.Director.EVENT_AFTER_DRAW), this._eventAfterDraw.setUserData(this), this._eventAfterVisit = new cc.EventCustom(cc.Director.EVENT_AFTER_VISIT), this._eventAfterVisit.setUserData(this), this._eventAfterUpdate = new cc.EventCustom(cc.Director.EVENT_AFTER_UPDATE), this._eventAfterUpdate.setUserData(this), this._eventProjectionChanged = new cc.EventCustom(cc.Director.EVENT_PROJECTION_CHANGED), this._eventProjectionChanged.setUserData(this), !0
    },
    calculateDeltaTime: function() {
        var a = Date.now();
        this._nextDeltaTimeZero ? (this._deltaTime = 0, this._nextDeltaTimeZero = !1) : this._deltaTime = (a - this._lastUpdate) / 1e3, cc.game.config[cc.game.CONFIG_KEY.debugMode] > 0 && this._deltaTime > .2 && (this._deltaTime = 1 / 60), this._lastUpdate = a
    },
    convertToGL: null,
    convertToUI: null,
    drawScene: function() {
        var a = cc.renderer;
        this.calculateDeltaTime(), this._paused || (this._scheduler.update(this._deltaTime), cc.eventManager.dispatchEvent(this._eventAfterUpdate)), this._clear(), this._nextScene && this.setNextScene(), this._beforeVisitScene && this._beforeVisitScene(), this._runningScene && (a.childrenOrderDirty === !0 ? (cc.renderer.clearRenderCommands(), this._runningScene._renderCmd._curLevel = 0, this._runningScene.visit(), a.resetFlag()) : a.transformDirty() === !0 && a.transform(), cc.eventManager.dispatchEvent(this._eventAfterVisit)), this._notificationNode && this._notificationNode.visit(), this._displayStats && this._showStats(), this._afterVisitScene && this._afterVisitScene(), a.rendering(cc._renderContext), cc.eventManager.dispatchEvent(this._eventAfterDraw), this._totalFrames++, this._displayStats && this._calculateMPF()
    },
    _beforeVisitScene: null,
    _afterVisitScene: null,
    end: function() {
        this._purgeDirectorInNextLoop = !0
    },
    getContentScaleFactor: function() {
        return this._contentScaleFactor
    },
    getNotificationNode: function() {
        return this._notificationNode
    },
    getWinSize: function() {
        return cc.size(this._winSizeInPoints)
    },
    getWinSizeInPixels: function() {
        return cc.size(this._winSizeInPoints.width * this._contentScaleFactor, this._winSizeInPoints.height * this._contentScaleFactor)
    },
    getVisibleSize: null,
    getVisibleOrigin: null,
    getZEye: null,
    pause: function() {
        this._paused || (this._oldAnimationInterval = this._animationInterval, this.setAnimationInterval(.25), this._paused = !0)
    },
    popScene: function() {
        cc.assert(this._runningScene, cc._LogInfos.Director_popScene), this._scenesStack.pop();
        var a = this._scenesStack.length;
        0 == a ? this.end() : (this._sendCleanupToScene = !0, this._nextScene = this._scenesStack[a - 1])
    },
    purgeCachedData: function() {
        cc.animationCache._clear(), cc.spriteFrameCache._clear(), cc.textureCache._clear()
    },
    purgeDirector: function() {
        this.getScheduler().unscheduleAllCallbacks(), cc.eventManager && cc.eventManager.setEnabled(!1), this._runningScene && (this._runningScene.onExitTransitionDidStart(), this._runningScene.onExit(), this._runningScene.cleanup()), this._runningScene = null, this._nextScene = null, this._scenesStack.length = 0, this.stopAnimation(), this.purgeCachedData(), cc.checkGLErrorDebug()
    },
    pushScene: function(a) {
        cc.assert(a, cc._LogInfos.Director_pushScene), this._sendCleanupToScene = !1, this._scenesStack.push(a), this._nextScene = a
    },
    runScene: function(a) {
        if (cc.assert(a, cc._LogInfos.Director_pushScene), this._runningScene) {
            var b = this._scenesStack.length;
            0 === b ? (this._sendCleanupToScene = !0, this._scenesStack[b] = a, this._nextScene = a) : (this._sendCleanupToScene = !0, this._scenesStack[b - 1] = a, this._nextScene = a)
        } else this.pushScene(a), this.startAnimation()
    },
    resume: function() {
        this._paused && (this.setAnimationInterval(this._oldAnimationInterval), this._lastUpdate = Date.now(), this._lastUpdate || cc.log(cc._LogInfos.Director_resume), this._paused = !1, this._deltaTime = 0)
    },
    setContentScaleFactor: function(a) {
        a != this._contentScaleFactor && (this._contentScaleFactor = a, this._createStatsLabel())
    },
    setDepthTest: null,
    setDefaultValues: function() {},
    setNextDeltaTimeZero: function(a) {
        this._nextDeltaTimeZero = a
    },
    setNextScene: function() {
        var a = !1,
            b = !1;
        if (cc.TransitionScene && (a = this._runningScene ? this._runningScene instanceof cc.TransitionScene : !1, b = this._nextScene ? this._nextScene instanceof cc.TransitionScene : !1), !b) {
            var c = this._runningScene;
            c && (c.onExitTransitionDidStart(), c.onExit()), this._sendCleanupToScene && c && c.cleanup()
        }
        this._runningScene = this._nextScene, cc.renderer.childrenOrderDirty = !0, this._nextScene = null, a || null == this._runningScene || (this._runningScene.onEnter(), this._runningScene.onEnterTransitionDidFinish())
    },
    setNotificationNode: function(a) {
        this._notificationNode = a
    },
    getDelegate: function() {
        return this._projectionDelegate
    },
    setDelegate: function(a) {
        this._projectionDelegate = a
    },
    setOpenGLView: null,
    setProjection: null,
    setViewport: null,
    getOpenGLView: null,
    getProjection: null,
    setAlphaBlending: null,
    _showStats: function() {
        this._frames++, this._accumDt += this._deltaTime, this._FPSLabel && this._SPFLabel && this._drawsLabel ? (this._accumDt > cc.DIRECTOR_FPS_INTERVAL && (this._SPFLabel.string = this._secondsPerFrame.toFixed(3), this._frameRate = this._frames / this._accumDt, this._frames = 0, this._accumDt = 0, this._FPSLabel.string = this._frameRate.toFixed(1), this._drawsLabel.string = (0 | cc.g_NumberOfDraws).toString()), this._FPSLabel.visit(), this._SPFLabel.visit(), this._drawsLabel.visit()) : this._createStatsLabel(), cc.g_NumberOfDraws = 0
    },
    isSendCleanupToScene: function() {
        return this._sendCleanupToScene
    },
    getRunningScene: function() {
        return this._runningScene
    },
    getAnimationInterval: function() {
        return this._animationInterval
    },
    isDisplayStats: function() {
        return this._displayStats
    },
    setDisplayStats: function(a) {
        this._displayStats = a
    },
    getSecondsPerFrame: function() {
        return this._secondsPerFrame
    },
    isNextDeltaTimeZero: function() {
        return this._nextDeltaTimeZero
    },
    isPaused: function() {
        return this._paused
    },
    getTotalFrames: function() {
        return this._totalFrames
    },
    popToRootScene: function() {
        this.popToSceneStackLevel(1)
    },
    popToSceneStackLevel: function(a) {
        cc.assert(this._runningScene, cc._LogInfos.Director_popToSceneStackLevel_2);
        var b = this._scenesStack,
            c = b.length;
        if (0 == c) return void this.end();
        if (!(a > c)) {
            for (; c > a;) {
                var d = b.pop();
                d.running && (d.onExitTransitionDidStart(), d.onExit()), d.cleanup(), c--
            }
            this._nextScene = b[b.length - 1], this._sendCleanupToScene = !1
        }
    },
    getScheduler: function() {
        return this._scheduler
    },
    setScheduler: function(a) {
        this._scheduler != a && (this._scheduler = a)
    },
    getActionManager: function() {
        return this._actionManager
    },
    setActionManager: function(a) {
        this._actionManager != a && (this._actionManager = a)
    },
    getDeltaTime: function() {
        return this._deltaTime
    },
    _createStatsLabel: null,
    _calculateMPF: function() {
        var a = Date.now();
        this._secondsPerFrame = (a - this._lastUpdate) / 1e3
    }
}), cc.Director.EVENT_PROJECTION_CHANGED = "director_projection_changed", cc.Director.EVENT_AFTER_DRAW = "director_after_draw", cc.Director.EVENT_AFTER_VISIT = "director_after_visit", cc.Director.EVENT_AFTER_UPDATE = "director_after_update", cc.DisplayLinkDirector = cc.Director.extend({
    invalid: !1,
    startAnimation: function() {
        this._nextDeltaTimeZero = !0, this.invalid = !1
    },
    mainLoop: function() {
        this._purgeDirectorInNextLoop ? (this._purgeDirectorInNextLoop = !1, this.purgeDirector()) : this.invalid || this.drawScene()
    },
    stopAnimation: function() {
        this.invalid = !0
    },
    setAnimationInterval: function(a) {
        this._animationInterval = a, this.invalid || (this.stopAnimation(), this.startAnimation())
    }
}), cc.Director.sharedDirector = null, cc.Director.firstUseDirector = !0, cc.Director._getInstance = function() {
    return cc.Director.firstUseDirector && (cc.Director.firstUseDirector = !1, cc.Director.sharedDirector = new cc.DisplayLinkDirector, cc.Director.sharedDirector.init()), cc.Director.sharedDirector
}, cc.defaultFPS = 60, cc.Director.PROJECTION_2D = 0, cc.Director.PROJECTION_3D = 1, cc.Director.PROJECTION_CUSTOM = 3, cc.Director.PROJECTION_DEFAULT = cc.Director.PROJECTION_3D, cc._renderType === cc._RENDER_TYPE_CANVAS) {
    var _p = cc.Director.prototype;
    _p.setProjection = function(a) {
        this._projection = a, cc.eventManager.dispatchEvent(this._eventProjectionChanged)
    }, _p.setDepthTest = function() {}, _p.setOpenGLView = function(a) {
        this._winSizeInPoints.width = cc._canvas.width, this._winSizeInPoints.height = cc._canvas.height, this._openGLView = a || cc.view, cc.eventManager && cc.eventManager.setEnabled(!0)
    }, _p._clear = function() {
        var a = this._openGLView.getViewPortRect(),
            b = cc._renderContext.getContext();
        b.setTransform(1, 0, 0, 1, 0, 0), b.clearRect(-a.x, a.y, a.width, a.height)
    }, _p._createStatsLabel = function() {
        var a = this,
            b = 0;
        b = a._winSizeInPoints.width > a._winSizeInPoints.height ? 0 | a._winSizeInPoints.height / 320 * 24 : 0 | a._winSizeInPoints.width / 320 * 24, a._FPSLabel = new cc.LabelTTF("000.0", "Arial", b), a._SPFLabel = new cc.LabelTTF("0.000", "Arial", b), a._drawsLabel = new cc.LabelTTF("0000", "Arial", b);
        var c = cc.DIRECTOR_STATS_POSITION;
        a._drawsLabel.setPosition(a._drawsLabel.width / 2 + c.x, 5 * a._drawsLabel.height / 2 + c.y), a._SPFLabel.setPosition(a._SPFLabel.width / 2 + c.x, 3 * a._SPFLabel.height / 2 + c.y), a._FPSLabel.setPosition(a._FPSLabel.width / 2 + c.x, a._FPSLabel.height / 2 + c.y)
    }, _p.getVisibleSize = function() {
        return this.getWinSize()
    }, _p.getVisibleOrigin = function() {
        return cc.p(0, 0)
    }
} else cc.Director._fpsImage = new Image, cc._addEventListener(cc.Director._fpsImage, "load", function() {
    cc.Director._fpsImageLoaded = !0
}), cc._fpsImage && (cc.Director._fpsImage.src = cc._fpsImage);
cc.PRIORITY_NON_SYSTEM = cc.PRIORITY_SYSTEM + 1, cc.ListEntry = function(a, b, c, d, e, f) {
        this.prev = a, this.next = b, this.target = c, this.priority = d, this.paused = e, this.markedForDeletion = f
    }, cc.HashUpdateEntry = function(a, b, c, d) {
        this.list = a, this.entry = b, this.target = c, this.hh = d
    }, cc.HashTimerEntry = function(a, b, c, d, e, f, g) {
        var h = this;
        h.timers = a, h.target = b, h.timerIndex = c, h.currentTimer = d, h.currentTimerSalvaged = e, h.paused = f, h.hh = g
    }, cc.Timer = cc.Class.extend({
        _interval: 0,
        _callback: null,
        _target: null,
        _elapsed: 0,
        _runForever: !1,
        _useDelay: !1,
        _timesExecuted: 0,
        _repeat: 0,
        _delay: 0,
        getInterval: function() {
            return this._interval
        },
        setInterval: function(a) {
            this._interval = a
        },
        getCallback: function() {
            return this._callback
        },
        ctor: function(a, b, c, d, e) {
            var f = this;
            f._target = a, f._callback = b, f._elapsed = -1, f._interval = c || 0, f._delay = e || 0, f._useDelay = f._delay > 0, f._repeat = null == d ? cc.REPEAT_FOREVER : d, f._runForever = f._repeat == cc.REPEAT_FOREVER
        },
        _doCallback: function() {
            var a = this;
            cc.isString(a._callback) ? a._target[a._callback](a._elapsed) : a._callback.call(a._target, a._elapsed)
        },
        update: function(a) {
            var b = this;
            if (-1 == b._elapsed) b._elapsed = 0, b._timesExecuted = 0;
            else {
                var c = b._target,
                    d = b._callback;
                b._elapsed += a, b._runForever && !b._useDelay ? b._elapsed >= b._interval && (c && d && b._doCallback(), b._elapsed = 0) : (b._useDelay ? b._elapsed >= b._delay && (c && d && b._doCallback(), b._elapsed = b._elapsed - b._delay, b._timesExecuted += 1, b._useDelay = !1) : b._elapsed >= b._interval && (c && d && b._doCallback(), b._elapsed = 0, b._timesExecuted += 1), b._timesExecuted > b._repeat && cc.director.getScheduler().unscheduleCallbackForTarget(c, d))
            }
        }
    }), cc.Scheduler = cc.Class.extend({
        _timeScale: 1,
        _updates: null,
        _hashForUpdates: null,
        _arrayForUpdates: null,
        _hashForTimers: null,
        _arrayForTimes: null,
        _currentTarget: null,
        _currentTargetSalvaged: !1,
        _updateHashLocked: !1,
        ctor: function() {
            var a = this;
            a._timeScale = 1, a._updates = [
                [],
                [],
                []
            ], a._hashForUpdates = {}, a._arrayForUpdates = [], a._hashForTimers = {}, a._arrayForTimers = [], a._currentTarget = null, a._currentTargetSalvaged = !1, a._updateHashLocked = !1
        },
        _removeHashElement: function(a) {
            delete this._hashForTimers[a.target.__instanceId], cc.arrayRemoveObject(this._arrayForTimers, a), a.Timer = null, a.target = null, a = null
        },
        _removeUpdateFromHash: function(a) {
            var b = this,
                c = b._hashForUpdates[a.target.__instanceId];
            c && (cc.arrayRemoveObject(c.list, c.entry), delete b._hashForUpdates[c.target.__instanceId], cc.arrayRemoveObject(b._arrayForUpdates, c), c.entry = null, c.target = null)
        },
        _priorityIn: function(a, b, c, d) {
            var e = this,
                f = new cc.ListEntry(null, null, b, c, d, !1);
            if (a) {
                for (var g = a.length - 1, h = 0; g >= h; h++)
                    if (c < a[h].priority) {
                        g = h;
                        break
                    }
                a.splice(h, 0, f)
            } else a = [], a.push(f);
            var i = new cc.HashUpdateEntry(a, f, b, null);
            return e._arrayForUpdates.push(i), e._hashForUpdates[b.__instanceId] = i, a
        },
        _appendIn: function(a, b, c) {
            var d = this,
                e = new cc.ListEntry(null, null, b, 0, c, !1);
            a.push(e);
            var f = new cc.HashUpdateEntry(a, e, b, null);
            d._arrayForUpdates.push(f), d._hashForUpdates[b.__instanceId] = f
        },
        setTimeScale: function(a) {
            this._timeScale = a
        },
        getTimeScale: function() {
            return this._timeScale
        },
        update: function(a) {
            var b, c, d, e, f = this,
                g = f._updates,
                h = f._arrayForTimers;
            for (f._updateHashLocked = !0, 1 != this._timeScale && (a *= this._timeScale), d = 0, e = g.length; e > d && d >= 0; d++)
                for (var i = f._updates[d], j = 0, k = i.length; k > j; j++) b = i[j], b.paused || b.markedForDeletion || b.target.update(a);
            for (d = 0, e = h.length; e > d && (c = h[d], c); d++) {
                if (f._currentTarget = c, f._currentTargetSalvaged = !1, !c.paused)
                    for (c.timerIndex = 0; c.timerIndex < c.timers.length; c.timerIndex++) c.currentTimer = c.timers[c.timerIndex], c.currentTimerSalvaged = !1, c.currentTimer.update(a), c.currentTimer = null;
                f._currentTargetSalvaged && 0 == c.timers.length && (f._removeHashElement(c), d--)
            }
            for (d = 0, e = g.length; e > d; d++)
                for (var i = f._updates[d], j = 0, k = i.length; k > j && (b = i[j], b);) b.markedForDeletion ? f._removeUpdateFromHash(b) : j++;
            f._updateHashLocked = !1, f._currentTarget = null
        },
        scheduleCallbackForTarget: function(a, b, c, d, e, f) {
            cc.assert(b, cc._LogInfos.Scheduler_scheduleCallbackForTarget_2), cc.assert(a, cc._LogInfos.Scheduler_scheduleCallbackForTarget_3), c = c || 0, d = null == d ? cc.REPEAT_FOREVER : d, e = e || 0, f = f || !1;
            var g, h = this,
                i = h._hashForTimers[a.__instanceId];
            if (i || (i = new cc.HashTimerEntry(null, a, 0, null, null, f, null), h._arrayForTimers.push(i), h._hashForTimers[a.__instanceId] = i), null == i.timers) i.timers = [];
            else
                for (var j = 0; j < i.timers.length; j++)
                    if (g = i.timers[j], b == g._callback) return cc.log(cc._LogInfos.Scheduler_scheduleCallbackForTarget, g.getInterval().toFixed(4), c.toFixed(4)), void(g._interval = c);
            g = new cc.Timer(a, b, c, d, e), i.timers.push(g)
        },
        scheduleUpdateForTarget: function(a, b, c) {
            if (null !== a) {
                var d = this,
                    e = d._updates,
                    f = d._hashForUpdates[a.__instanceId];
                return f ? void(f.entry.markedForDeletion = !1) : void(0 == b ? d._appendIn(e[1], a, c) : 0 > b ? e[0] = d._priorityIn(e[0], a, b, c) : e[2] = d._priorityIn(e[2], a, b, c))
            }
        },
        unscheduleCallbackForTarget: function(a, b) {
            if (null != a && null != b) {
                var c = this,
                    d = c._hashForTimers[a.__instanceId];
                if (d)
                    for (var e = d.timers, f = 0, g = e.length; g > f; f++) {
                        var h = e[f];
                        if (b == h._callback) return h != d.currentTimer || d.currentTimerSalvaged || (d.currentTimerSalvaged = !0), e.splice(f, 1), d.timerIndex >= f && d.timerIndex--, void(0 == e.length && (c._currentTarget == d ? c._currentTargetSalvaged = !0 : c._removeHashElement(d)))
                    }
            }
        },
        unscheduleUpdateForTarget: function(a) {
            if (null != a) {
                var b = this,
                    c = b._hashForUpdates[a.__instanceId];
                null != c && (b._updateHashLocked ? c.entry.markedForDeletion = !0 : b._removeUpdateFromHash(c.entry))
            }
        },
        unscheduleAllCallbacksForTarget: function(a) {
            if (null != a) {
                var b = this,
                    c = b._hashForTimers[a.__instanceId];
                if (c) {
                    var d = c.timers;
                    !c.currentTimerSalvaged && d.indexOf(c.currentTimer) >= 0 && (c.currentTimerSalvaged = !0), d.length = 0, b._currentTarget == c ? b._currentTargetSalvaged = !0 : b._removeHashElement(c)
                }
                b.unscheduleUpdateForTarget(a)
            }
        },
        unscheduleAllCallbacks: function() {
            this.unscheduleAllCallbacksWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM)
        },
        unscheduleAllCallbacksWithMinPriority: function(a) {
            for (var b = this, c = b._arrayForTimers, d = b._updates, e = 0, f = c.length; f > e; e++) b.unscheduleAllCallbacksForTarget(c[e].target);
            for (var e = 2; e >= 0; e--)
                if (!(1 == e && a > 0 || 0 == e && a >= 0))
                    for (var g = d[e], h = 0, i = g.length; i > h; h++) b.unscheduleUpdateForTarget(g[h].target)
        },
        pauseAllTargets: function() {
            return this.pauseAllTargetsWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM)
        },
        pauseAllTargetsWithMinPriority: function() {
            for (var a, b = [], c = this, d = c._arrayForTimers, e = c._updates, f = 0, g = d.length; g > f; f++) a = d[f], a && (a.paused = !0, b.push(a.target));
            for (var f = 0, g = e.length; g > f; f++)
                for (var h = e[f], i = 0, j = h.length; j > i; i++) a = h[i], a && (a.paused = !0, b.push(a.target));
            return b
        },
        resumeTargets: function(a) {
            if (a)
                for (var b = 0; b < a.length; b++) this.resumeTarget(a[b])
        },
        pauseTarget: function(a) {
            cc.assert(a, cc._LogInfos.Scheduler_pauseTarget);
            var b = this,
                c = b._hashForTimers[a.__instanceId];
            c && (c.paused = !0);
            var d = b._hashForUpdates[a.__instanceId];
            d && (d.entry.paused = !0)
        },
        resumeTarget: function(a) {
            cc.assert(a, cc._LogInfos.Scheduler_resumeTarget);
            var b = this,
                c = b._hashForTimers[a.__instanceId];
            c && (c.paused = !1);
            var d = b._hashForUpdates[a.__instanceId];
            d && (d.entry.paused = !1)
        },
        isTargetPaused: function(a) {
            cc.assert(a, cc._LogInfos.Scheduler_isTargetPaused);
            var b = this._hashForTimers[a.__instanceId];
            return b ? b.paused : !1
        }
    }), cc.Scheduler.PRIORITY_SYSTEM = -2147483648, cc._tmp.PrototypeLabelTTF = function() {
        var a = cc.LabelTTF.prototype;
        cc.defineGetterSetter(a, "color", a.getColor, a.setColor), cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity), a.string, cc.defineGetterSetter(a, "string", a.getString, a.setString), a.textAlign, cc.defineGetterSetter(a, "textAlign", a.getHorizontalAlignment, a.setHorizontalAlignment), a.verticalAlign, cc.defineGetterSetter(a, "verticalAlign", a.getVerticalAlignment, a.setVerticalAlignment), a.fontSize, cc.defineGetterSetter(a, "fontSize", a.getFontSize, a.setFontSize), a.fontName, cc.defineGetterSetter(a, "fontName", a.getFontName, a.setFontName), a.font, cc.defineGetterSetter(a, "font", a._getFont, a._setFont), a.boundingSize, a.boundingWidth, cc.defineGetterSetter(a, "boundingWidth", a._getBoundingWidth, a._setBoundingWidth), a.boundingHeight, cc.defineGetterSetter(a, "boundingHeight", a._getBoundingHeight, a._setBoundingHeight), a.fillStyle, cc.defineGetterSetter(a, "fillStyle", a._getFillStyle, a.setFontFillColor), a.strokeStyle, cc.defineGetterSetter(a, "strokeStyle", a._getStrokeStyle, a._setStrokeStyle), a.lineWidth, cc.defineGetterSetter(a, "lineWidth", a._getLineWidth, a._setLineWidth), a.shadowOffset, a.shadowOffsetX, cc.defineGetterSetter(a, "shadowOffsetX", a._getShadowOffsetX, a._setShadowOffsetX), a.shadowOffsetY, cc.defineGetterSetter(a, "shadowOffsetY", a._getShadowOffsetY, a._setShadowOffsetY), a.shadowOpacity, cc.defineGetterSetter(a, "shadowOpacity", a._getShadowOpacity, a._setShadowOpacity), a.shadowBlur, cc.defineGetterSetter(a, "shadowBlur", a._getShadowBlur, a._setShadowBlur)
    }, cc.LabelTTF = cc.Sprite.extend({
        _dimensions: null,
        _hAlignment: cc.TEXT_ALIGNMENT_CENTER,
        _vAlignment: cc.VERTICAL_TEXT_ALIGNMENT_TOP,
        _fontName: null,
        _fontSize: 0,
        _string: "",
        _originalText: null,
        _shadowEnabled: !1,
        _shadowOffset: null,
        _shadowOpacity: 0,
        _shadowBlur: 0,
        _shadowColor: null,
        _strokeEnabled: !1,
        _strokeColor: null,
        _strokeSize: 0,
        _textFillColor: null,
        _strokeShadowOffsetX: 0,
        _strokeShadowOffsetY: 0,
        _needUpdateTexture: !1,
        _lineWidths: null,
        _className: "LabelTTF",
        _lineHeight: 0,
        initWithString: function(a, b, c, d, e, f) {
            var g;
            return g = a ? a + "" : "", c = c || 16, d = d || cc.size(0, 0), e = e || cc.TEXT_ALIGNMENT_LEFT, f = f || cc.VERTICAL_TEXT_ALIGNMENT_TOP, this._opacityModifyRGB = !1, this._dimensions = cc.size(d.width, d.height), this._fontName = b || "Arial", this._hAlignment = e, this._vAlignment = f, this._fontSize = c, this._renderCmd._setFontStyle(this._fontName, c), this.string = g, this._renderCmd._setColorsString(), this._renderCmd._updateTexture(), this._setUpdateTextureDirty(), !0
        },
        _setUpdateTextureDirty: function() {
            this._needUpdateTexture = !0, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.textDirty)
        },
        ctor: function(a, b, c, d, e, f) {
            cc.Sprite.prototype.ctor.call(this), this._dimensions = cc.size(0, 0), this._hAlignment = cc.TEXT_ALIGNMENT_LEFT, this._vAlignment = cc.VERTICAL_TEXT_ALIGNMENT_TOP, this._opacityModifyRGB = !1, this._fontName = "Arial", this._shadowEnabled = !1, this._shadowOffset = cc.p(0, 0), this._shadowOpacity = 0, this._shadowBlur = 0, this._strokeEnabled = !1, this._strokeColor = cc.color(255, 255, 255, 255), this._strokeSize = 0, this._textFillColor = cc.color(255, 255, 255, 255), this._strokeShadowOffsetX = 0, this._strokeShadowOffsetY = 0, this._needUpdateTexture = !1, this._lineWidths = [], this._renderCmd._setColorsString(), b && b instanceof cc.FontDefinition ? this.initWithStringAndTextDefinition(a, b) : cc.LabelTTF.prototype.initWithString.call(this, a, b, c, d, e, f)
        },
        init: function() {
            return this.initWithString(" ", this._fontName, this._fontSize)
        },
        description: function() {
            return "<cc.LabelTTF | FontName =" + this._fontName + " FontSize = " + this._fontSize.toFixed(1) + ">"
        },
        getLineHeight: function() {
            return this._lineHeight || this._renderCmd._getFontClientHeight()
        },
        setLineHeight: function(a) {
            this._lineHeight = a
        },
        getString: function() {
            return this._string
        },
        getHorizontalAlignment: function() {
            return this._hAlignment
        },
        getVerticalAlignment: function() {
            return this._vAlignment
        },
        getDimensions: function() {
            return cc.size(this._dimensions)
        },
        getFontSize: function() {
            return this._fontSize
        },
        getFontName: function() {
            return this._fontName
        },
        initWithStringAndTextDefinition: function(a, b) {
            return this._updateWithTextDefinition(b, !1), this.string = a, !0
        },
        setTextDefinition: function(a) {
            a && this._updateWithTextDefinition(a, !0)
        },
        getTextDefinition: function() {
            return this._prepareTextDefinition(!1)
        },
        enableShadow: function(a, b, c, d) {
            null != a.r && null != a.g && null != a.b && null != a.a ? this._enableShadow(a, b, c) : this._enableShadowNoneColor(a, b, c, d)
        },
        _enableShadowNoneColor: function(a, b, c, d) {
            c = c || .5, !1 === this._shadowEnabled && (this._shadowEnabled = !0);
            var e = this._shadowOffset;
            (e && e.x != a || e._y != b) && (e.x = a, e.y = b), this._shadowOpacity != c && (this._shadowOpacity = c), this._renderCmd._setColorsString(), this._shadowBlur != d && (this._shadowBlur = d), this._setUpdateTextureDirty()
        },
        _enableShadow: function(a, b, c) {
            this._shadowColor || (this._shadowColor = cc.color(255, 255, 255, 128)), this._shadowColor.r = a.r, this._shadowColor.g = a.g, this._shadowColor.b = a.b;
            var d, e, f, g;
            d = b.width || b.x || 0, e = b.height || b.y || 0, f = null != a.a ? a.a / 255 : .5, g = c, this._enableShadowNoneColor(d, e, f, g)
        },
        _getShadowOffsetX: function() {
            return this._shadowOffset.x
        },
        _setShadowOffsetX: function(a) {
            !1 === this._shadowEnabled && (this._shadowEnabled = !0), this._shadowOffset.x != a && (this._shadowOffset.x = a, this._setUpdateTextureDirty())
        },
        _getShadowOffsetY: function() {
            return this._shadowOffset._y
        },
        _setShadowOffsetY: function(a) {
            !1 === this._shadowEnabled && (this._shadowEnabled = !0), this._shadowOffset._y != a && (this._shadowOffset._y = a, this._setUpdateTextureDirty())
        },
        _getShadowOffset: function() {
            return cc.p(this._shadowOffset.x, this._shadowOffset.y)
        },
        _setShadowOffset: function(a) {
            !1 === this._shadowEnabled && (this._shadowEnabled = !0), (this._shadowOffset.x != a.x || this._shadowOffset.y != a.y) && (this._shadowOffset.x = a.x, this._shadowOffset.y = a.y, this._setUpdateTextureDirty())
        },
        _getShadowOpacity: function() {
            return this._shadowOpacity
        },
        _setShadowOpacity: function(a) {
            !1 === this._shadowEnabled && (this._shadowEnabled = !0), this._shadowOpacity != a && (this._shadowOpacity = a, this._renderCmd._setColorsString(), this._setUpdateTextureDirty())
        },
        _getShadowBlur: function() {
            return this._shadowBlur
        },
        _setShadowBlur: function(a) {
            !1 === this._shadowEnabled && (this._shadowEnabled = !0), this._shadowBlur != a && (this._shadowBlur = a, this._setUpdateTextureDirty())
        },
        disableShadow: function() {
            this._shadowEnabled && (this._shadowEnabled = !1, this._setUpdateTextureDirty())
        },
        enableStroke: function(a, b) {
            this._strokeEnabled === !1 && (this._strokeEnabled = !0);
            var c = this._strokeColor;
            (c.r !== a.r || c.g !== a.g || c.b !== a.b) && (c.r = a.r, c.g = a.g, c.b = a.b, this._renderCmd._setColorsString()), this._strokeSize !== b && (this._strokeSize = b || 0), this._setUpdateTextureDirty()
        },
        _getStrokeStyle: function() {
            return this._strokeColor
        },
        _setStrokeStyle: function(a) {
            this._strokeEnabled === !1 && (this._strokeEnabled = !0);
            var b = this._strokeColor;
            (b.r !== a.r || b.g !== a.g || b.b !== a.b) && (b.r = a.r, b.g = a.g, b.b = a.b, this._renderCmd._setColorsString(), this._setUpdateTextureDirty())
        },
        _getLineWidth: function() {
            return this._strokeSize
        },
        _setLineWidth: function(a) {
            this._strokeEnabled === !1 && (this._strokeEnabled = !0), this._strokeSize !== a && (this._strokeSize = a || 0, this._setUpdateTextureDirty())
        },
        disableStroke: function() {
            this._strokeEnabled && (this._strokeEnabled = !1, this._setUpdateTextureDirty())
        },
        setFontFillColor: function(a) {
            var b = this._textFillColor;
            (b.r != a.r || b.g != a.g || b.b != a.b) && (b.r = a.r, b.g = a.g, b.b = a.b, this._renderCmd._setColorsString(), this._needUpdateTexture = !0)
        },
        _getFillStyle: function() {
            return this._textFillColor
        },
        _updateWithTextDefinition: function(a, b) {
            a.fontDimensions ? (this._dimensions.width = a.boundingWidth, this._dimensions.height = a.boundingHeight) : (this._dimensions.width = 0, this._dimensions.height = 0), this._hAlignment = a.textAlign, this._vAlignment = a.verticalAlign, this._fontName = a.fontName, this._fontSize = a.fontSize || 12, this._renderCmd._setFontStyle(this._fontName, this._fontSize), a.shadowEnabled && this.enableShadow(a.shadowOffsetX, a.shadowOffsetY, a.shadowOpacity, a.shadowBlur), a.strokeEnabled && this.enableStroke(a.strokeStyle, a.lineWidth), this.setFontFillColor(a.fillStyle), b && this._renderCmd._updateTexture();
            var c = cc.Node._dirtyFlags;
            this._renderCmd.setDirtyFlag(c.colorDirty | c.opacityDirty | c.textDirty)
        },
        _prepareTextDefinition: function(a) {
            var b = new cc.FontDefinition;
            if (a ? (b.fontSize = this._fontSize, b.boundingWidth = cc.contentScaleFactor() * this._dimensions.width, b.boundingHeight = cc.contentScaleFactor() * this._dimensions.height) : (b.fontSize = this._fontSize, b.boundingWidth = this._dimensions.width, b.boundingHeight = this._dimensions.height), b.fontName = this._fontName, b.textAlign = this._hAlignment, b.verticalAlign = this._vAlignment, this._strokeEnabled) {
                b.strokeEnabled = !0;
                var c = this._strokeColor;
                b.strokeStyle = cc.color(c.r, c.g, c.b), b.lineWidth = this._strokeSize
            } else b.strokeEnabled = !1;
            this._shadowEnabled ? (b.shadowEnabled = !0, b.shadowBlur = this._shadowBlur, b.shadowOpacity = this._shadowOpacity, b.shadowOffsetX = (a ? cc.contentScaleFactor() : 1) * this._shadowOffset.x, b.shadowOffsetY = (a ? cc.contentScaleFactor() : 1) * this._shadowOffset.y) : b._shadowEnabled = !1;
            var d = this._textFillColor;
            return b.fillStyle = cc.color(d.r, d.g, d.b), b
        },
        setString: function(a) {
            a = String(a), this._originalText != a && (this._originalText = a + "", this._updateString(), this._setUpdateTextureDirty(), this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty))
        },
        _updateString: function() {
            this._string && "" !== this._string || this._string === this._originalText || (cc.renderer.childrenOrderDirty = !0), this._string = this._originalText
        },
        setHorizontalAlignment: function(a) {
            a !== this._hAlignment && (this._hAlignment = a, this._setUpdateTextureDirty())
        },
        setVerticalAlignment: function(a) {
            a != this._vAlignment && (this._vAlignment = a, this._setUpdateTextureDirty())
        },
        setDimensions: function(a, b) {
            var c;
            void 0 === b ? (c = a.width, b = a.height) : c = a, (c != this._dimensions.width || b != this._dimensions.height) && (this._dimensions.width = c, this._dimensions.height = b, this._updateString(), this._setUpdateTextureDirty())
        },
        _getBoundingWidth: function() {
            return this._dimensions.width
        },
        _setBoundingWidth: function(a) {
            a != this._dimensions.width && (this._dimensions.width = a, this._updateString(), this._setUpdateTextureDirty())
        },
        _getBoundingHeight: function() {
            return this._dimensions.height
        },
        _setBoundingHeight: function(a) {
            a != this._dimensions.height && (this._dimensions.height = a, this._updateString(), this._setUpdateTextureDirty())
        },
        setFontSize: function(a) {
            this._fontSize !== a && (this._fontSize = a, this._renderCmd._setFontStyle(this._fontName, this._fontSize), this._setUpdateTextureDirty())
        },
        setFontName: function(a) {
            this._fontName && this._fontName != a && (this._fontName = a, this._renderCmd._setFontStyle(this._fontName, this._fontSize), this._setUpdateTextureDirty())
        },
        _getFont: function() {
            return this._renderCmd._getFontStyle()
        },
        _setFont: function(a) {
            var b = cc.LabelTTF._fontStyleRE.exec(a);
            b && (this._fontSize = parseInt(b[1]), this._fontName = b[2], this._renderCmd._setFontStyle(this._fontName, this._fontSize), this._setUpdateTextureDirty())
        },
        getContentSize: function() {
            return this._needUpdateTexture && this._renderCmd._updateTTF(), cc.Sprite.prototype.getContentSize.call(this)
        },
        _getWidth: function() {
            return this._needUpdateTexture && this._renderCmd._updateTTF(), cc.Sprite.prototype._getWidth.call(this)
        },
        _getHeight: function() {
            return this._needUpdateTexture && this._renderCmd._updateTTF(), cc.Sprite.prototype._getHeight.call(this)
        },
        setTextureRect: function(a, b, c) {
            cc.Sprite.prototype.setTextureRect.call(this, a, b, c, !1)
        },
        _createRenderCmd: function() {
            return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.LabelTTF.CanvasRenderCmd(this) : new cc.LabelTTF.WebGLRenderCmd(this)
        }
    }), cc.assert(cc.isFunction(cc._tmp.PrototypeLabelTTF), cc._LogInfos.MissingFile, "LabelTTFPropertyDefine.js"), cc._tmp.PrototypeLabelTTF(), delete cc._tmp.PrototypeLabelTTF, cc.LabelTTF._fontStyleRE = /^(\d+)px\s+['"]?([\w\s\d]+)['"]?$/, cc.LabelTTF.create = function(a, b, c, d, e, f) {
        return new cc.LabelTTF(a, b, c, d, e, f)
    }, cc.LabelTTF.createWithFontDefinition = cc.LabelTTF.create, cc.LabelTTF._SHADER_PROGRAM = cc.USE_LA88_LABELS ? cc.SHADER_POSITION_TEXTURECOLOR : cc.SHADER_POSITION_TEXTUREA8COLOR, cc.LabelTTF.__labelHeightDiv = cc.newElement("div"), cc.LabelTTF.__labelHeightDiv.style.fontFamily = "Arial", cc.LabelTTF.__labelHeightDiv.style.position = "absolute", cc.LabelTTF.__labelHeightDiv.style.left = "-100px", cc.LabelTTF.__labelHeightDiv.style.top = "-100px", cc.LabelTTF.__labelHeightDiv.style.lineHeight = "normal", document.body ? document.body.appendChild(cc.LabelTTF.__labelHeightDiv) : cc._addEventListener(window, "load", function() {
        this.removeEventListener("load", arguments.callee, !1), document.body.appendChild(cc.LabelTTF.__labelHeightDiv)
    }, !1), cc.LabelTTF.__getFontHeightByDiv = function(a, b) {
        var c = cc.LabelTTF.__fontHeightCache[a + "." + b];
        if (c > 0) return c;
        var d = cc.LabelTTF.__labelHeightDiv;
        return d.innerHTML = "ajghl~!", d.style.fontFamily = a, d.style.fontSize = b + "px", c = d.clientHeight, cc.LabelTTF.__fontHeightCache[a + "." + b] = c, d.innerHTML = "", c
    }, cc.LabelTTF.__fontHeightCache = {}, cc.LabelTTF._textAlign = ["left", "center", "right"], cc.LabelTTF._textBaseline = ["top", "middle", "bottom"], cc.LabelTTF.wrapInspection = !0, cc.LabelTTF._wordRex = /([а-яА-ЯёЁa-zA-Z0-9ÄÖÜäöüßéèçàùêâîôû]+|\S)/, cc.LabelTTF._symbolRex = /^[!,.:;}\]%\?>、‘“》？。，！]/, cc.LabelTTF._lastWordRex = /([а-яА-ЯёЁa-zA-Z0-9ÄÖÜäöüßéèçàùêâîôû]+|\S)$/, cc.LabelTTF._lastEnglish = /[а-яА-ЯёЁa-zA-Z0-9ÄÖÜäöüßéèçàùêâîôû]+$/, cc.LabelTTF._firsrEnglish = /^[а-яА-ЯёЁa-zA-Z0-9ÄÖÜäöüßéèçàùêâîôû]/,
    function() {
        cc.LabelTTF.RenderCmd = function() {
            this._fontClientHeight = 18, this._fontStyleStr = "", this._shadowColorStr = "rgba(128, 128, 128, 0.5)", this._strokeColorStr = "", this._fillColorStr = "rgba(255,255,255,1)", this._labelCanvas = null, this._labelContext = null, this._lineWidths = [], this._strings = [], this._isMultiLine = !1
        };
        var a = cc.LabelTTF.RenderCmd.prototype;
        a.constructor = cc.LabelTTF.RenderCmd, a._getLabelContext = function() {
            if (this._labelContext) return this._labelContext;
            var a = this._node;
            if (!this._labelCanvas) {
                var b = cc.newElement("canvas"),
                    c = new cc.Texture2D;
                c.initWithElement(b), a.setTexture(c), this._labelCanvas = b
            }
            return this._labelContext = this._labelCanvas.getContext("2d"), this._labelContext
        }, a._setFontStyle = function(a, b) {
            this._fontStyleStr = b + "px '" + a + "'", this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(a, b)
        }, a._getFontStyle = function() {
            return this._fontStyleStr
        }, a._getFontClientHeight = function() {
            return this._fontClientHeight
        }, a._updateTexture = function() {
            this._dirtyFlag = this._dirtyFlag & cc.Node._dirtyFlags.textDirty ^ this._dirtyFlag;
            var a = this._node,
                b = this._getLabelContext(),
                c = this._labelCanvas,
                d = a._contentSize;
            if (0 === a._string.length) return c.width = 1, c.height = d.height || 1, a._texture && a._texture.handleLoadedTexture(), a.setTextureRect(cc.rect(0, 0, 1, d.height)), !0;
            b.font = this._fontStyleStr, this._updateTTF();
            var e = d.width,
                f = d.height,
                g = c.width == e && c.height == f;
            return c.width = e, c.height = f, g && b.clearRect(0, 0, e, f), this._drawTTFInCanvas(b), a._texture && a._texture.handleLoadedTexture(), a.setTextureRect(cc.rect(0, 0, e, f)), !0
        }, a._measureConfig = function() {
            this._getLabelContext().font = this._fontStyleStr
        }, a._measure = function(a) {
            return this._getLabelContext().measureText(a).width
        }, a._updateTTF = function() {
            var a, b, c = this._node,
                d = c._dimensions.width,
                e = this._lineWidths;
            if (e.length = 0, this._isMultiLine = !1, this._measureConfig(), 0 !== d)
                for (this._strings = c._string.split("\n"), a = 0; a < this._strings.length; a++) this._checkWarp(this._strings, a, d);
            else
                for (this._strings = c._string.split("\n"), a = 0, b = this._strings.length; b > a; a++) e.push(this._measure(this._strings[a]));
            this._strings.length > 0 && (this._isMultiLine = !0);
            var f, g = 0,
                h = 0;
            if (c._strokeEnabled && (g = h = 2 * c._strokeSize), c._shadowEnabled) {
                var i = c._shadowOffset;
                g += 2 * Math.abs(i.x), h += 2 * Math.abs(i.y)
            }
            f = 0 === d ? this._isMultiLine ? cc.size(0 | Math.max.apply(Math, e) + g, 0 | this._fontClientHeight * this._strings.length + h) : cc.size(0 | this._measure(c._string) + g, 0 | this._fontClientHeight + h) : 0 === c._dimensions.height ? this._isMultiLine ? cc.size(0 | d + g, 0 | c.getLineHeight() * this._strings.length + h) : cc.size(0 | d + g, 0 | c.getLineHeight() + h) : cc.size(0 | d + g, 0 | c._dimensions.height + h), c.setContentSize(f), c._strokeShadowOffsetX = g, c._strokeShadowOffsetY = h;
            var j = c._anchorPoint;
            this._anchorPointInPoints.x = .5 * g + (f.width - g) * j.x, this._anchorPointInPoints.y = .5 * h + (f.height - h) * j.y
        }, a._drawTTFInCanvas = function(a) {
            if (a) {
                var b = this._node,
                    c = b._strokeShadowOffsetX,
                    d = b._strokeShadowOffsetY,
                    e = b._contentSize.height - d,
                    f = b._vAlignment,
                    g = b._hAlignment,
                    h = b._strokeSize;
                a.setTransform(1, 0, 0, 1, 0 + .5 * c, e + .5 * d), a.font != this._fontStyleStr && (a.font = this._fontStyleStr), a.fillStyle = this._fillColorStr;
                var i = 0,
                    j = 0,
                    k = b._strokeEnabled;
                if (k && (a.lineWidth = 2 * h, a.strokeStyle = this._strokeColorStr), b._shadowEnabled) {
                    var l = b._shadowOffset;
                    a.shadowColor = this._shadowColorStr, a.shadowOffsetX = l.x, a.shadowOffsetY = -l.y, a.shadowBlur = b._shadowBlur
                }
                a.textBaseline = cc.LabelTTF._textBaseline[f], a.textAlign = cc.LabelTTF._textAlign[g];
                var m = b._contentSize.width - c,
                    n = b.getLineHeight(),
                    o = (n - this._fontClientHeight) / 2;
                if (i += g === cc.TEXT_ALIGNMENT_RIGHT ? m : g === cc.TEXT_ALIGNMENT_CENTER ? m / 2 : 0, this._isMultiLine) {
                    var p = this._strings.length;
                    f === cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM ? j = n - 2 * o + e - n * p : f === cc.VERTICAL_TEXT_ALIGNMENT_CENTER && (j = (n - 2 * o) / 2 + (e - n * p) / 2);
                    for (var q = 0; p > q; q++) {
                        var r = this._strings[q],
                            s = -e + (n * q + o) + j;
                        k && a.strokeText(r, i, s), a.fillText(r, i, s)
                    }
                } else f === cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM || (j -= f === cc.VERTICAL_TEXT_ALIGNMENT_TOP ? e : .5 * e), k && a.strokeText(b._string, i, j), a.fillText(b._string, i, j)
            }
        }, a._checkWarp = function(a, b, c) {
            var d = a[b],
                e = this._measure(d);
            if (e > c && d.length > 1) {
                for (var f, g = d.length * (c / e) | 0, h = d.substr(g), i = e - this._measure(h), j = 0, k = 0; i > c && k++ < 100;) g *= c / i, g = 0 | g, h = d.substr(g), i = e - this._measure(h);
                for (k = 0; c > i && k++ < 100;) {
                    if (h) {
                        var l = cc.LabelTTF._wordRex.exec(h);
                        j = l ? l[0].length : 1, f = h
                    }
                    g += j, h = d.substr(g), i = e - this._measure(h)
                }
                g -= j, 0 === g && (g = 1, f = f.substr(1));
                var m, n = d.substr(0, g);
                cc.LabelTTF.wrapInspection && cc.LabelTTF._symbolRex.test(f || h) && (m = cc.LabelTTF._lastWordRex.exec(n), g -= m ? m[0].length : 0, f = d.substr(g), n = d.substr(0, g)), cc.LabelTTF._firsrEnglish.test(f) && (m = cc.LabelTTF._lastEnglish.exec(n), m && n !== m[0] && (g -= m[0].length, f = d.substr(g), n = d.substr(0, g))), a[b] = f || h, a.splice(b, 0, n)
            }
        }
    }(),
    function() {
        cc.LabelTTF.CanvasRenderCmd = function(a) {
            cc.Sprite.CanvasRenderCmd.call(this, a), cc.LabelTTF.RenderCmd.call(this)
        }, cc.LabelTTF.CanvasRenderCmd.prototype = Object.create(cc.Sprite.CanvasRenderCmd.prototype), cc.inject(cc.LabelTTF.RenderCmd.prototype, cc.LabelTTF.CanvasRenderCmd.prototype);
        var a = cc.LabelTTF.CanvasRenderCmd.prototype;
        a.constructor = cc.LabelTTF.CanvasRenderCmd, a.updateStatus = function() {
            var a = cc.Node._dirtyFlags,
                b = this._dirtyFlag,
                c = b & a.colorDirty,
                d = b & a.opacityDirty;
            c && this._updateDisplayColor(), d && this._updateDisplayOpacity(), c ? this._updateColor() : b & a.textDirty && this._updateTexture(), this._dirtyFlag & a.transformDirty && (this.transform(this.getParentRenderCmd(), !0), this._dirtyFlag = this._dirtyFlag & cc.Node._dirtyFlags.transformDirty ^ this._dirtyFlag)
        }, a._syncStatus = function(a) {
            var b = cc.Node._dirtyFlags,
                c = this._dirtyFlag,
                d = a ? a._node : null;
            d && d._cascadeColorEnabled && a._dirtyFlag & b.colorDirty && (c |= b.colorDirty), d && d._cascadeOpacityEnabled && a._dirtyFlag & b.opacityDirty && (c |= b.opacityDirty), a && a._dirtyFlag & b.transformDirty && (c |= b.transformDirty);
            var e = c & b.colorDirty,
                f = c & b.opacityDirty;
            this._dirtyFlag = c, e && this._syncDisplayColor(), f && this._syncDisplayOpacity(), e ? this._updateColor() : c & b.textDirty && this._updateTexture(), c & b.transformDirty && this.transform(a)
        }, a._setColorsString = function() {
            var a = this._displayedColor,
                b = this._node,
                c = b._shadowColor || this._displayedColor,
                d = b._strokeColor,
                e = b._textFillColor;
            this._shadowColorStr = "rgba(" + (0 | .5 * c.r) + "," + (0 | .5 * c.g) + "," + (0 | .5 * c.b) + "," + b._shadowOpacity + ")", this._fillColorStr = "rgba(" + (0 | a.r / 255 * e.r) + "," + (0 | a.g / 255 * e.g) + "," + (0 | a.b / 255 * e.b) + ", 1)", this._strokeColorStr = "rgba(" + (0 | a.r / 255 * d.r) + "," + (0 | a.g / 255 * d.g) + "," + (0 | a.b / 255 * d.b) + ", 1)"
        }, a._updateColor = function() {
            this._setColorsString(), this._updateTexture()
        }
    }();
var cc = cc || {};
cc._tmp = cc._tmp || {}, cc.associateWithNative = function() {}, cc.KEY = {
        backspace: 8,
        tab: 9,
        enter: 13,
        shift: 16,
        ctrl: 17,
        alt: 18,
        pause: 19,
        capslock: 20,
        escape: 27,
        pageup: 33,
        pagedown: 34,
        end: 35,
        home: 36,
        left: 37,
        up: 38,
        right: 39,
        down: 40,
        insert: 45,
        Delete: 46,
        0: 48,
        1: 49,
        2: 50,
        3: 51,
        4: 52,
        5: 53,
        6: 54,
        7: 55,
        8: 56,
        9: 57,
        a: 65,
        b: 66,
        c: 67,
        d: 68,
        e: 69,
        f: 70,
        g: 71,
        h: 72,
        i: 73,
        j: 74,
        k: 75,
        l: 76,
        m: 77,
        n: 78,
        o: 79,
        p: 80,
        q: 81,
        r: 82,
        s: 83,
        t: 84,
        u: 85,
        v: 86,
        w: 87,
        x: 88,
        y: 89,
        z: 90,
        num0: 96,
        num1: 97,
        num2: 98,
        num3: 99,
        num4: 100,
        num5: 101,
        num6: 102,
        num7: 103,
        num8: 104,
        num9: 105,
        "*": 106,
        "+": 107,
        "-": 109,
        numdel: 110,
        "/": 111,
        f1: 112,
        f2: 113,
        f3: 114,
        f4: 115,
        f5: 116,
        f6: 117,
        f7: 118,
        f8: 119,
        f9: 120,
        f10: 121,
        f11: 122,
        f12: 123,
        numlock: 144,
        scrolllock: 145,
        semicolon: 186,
        ",": 186,
        equal: 187,
        "=": 187,
        ";": 188,
        comma: 188,
        dash: 189,
        ".": 190,
        period: 190,
        forwardslash: 191,
        grave: 192,
        "[": 219,
        openbracket: 219,
        "]": 221,
        closebracket: 221,
        backslash: 220,
        quote: 222,
        space: 32
    }, cc.FMT_JPG = 0, cc.FMT_PNG = 1, cc.FMT_TIFF = 2, cc.FMT_RAWDATA = 3, cc.FMT_WEBP = 4, cc.FMT_UNKNOWN = 5, cc.getImageFormatByData = function(a) {
        return a.length > 8 && 137 == a[0] && 80 == a[1] && 78 == a[2] && 71 == a[3] && 13 == a[4] && 10 == a[5] && 26 == a[6] && 10 == a[7] ? cc.FMT_PNG : a.length > 2 && (73 == a[0] && 73 == a[1] || 77 == a[0] && 77 == a[1] || 255 == a[0] && 216 == a[1]) ? cc.FMT_TIFF : cc.FMT_UNKNOWN
    }, cc.inherits = function(a, b) {
        function c() {}
        c.prototype = b.prototype, a.superClass_ = b.prototype, a.prototype = new c, a.prototype.constructor = a
    }, cc.base = function(a, b) {
        var c = arguments.callee.caller;
        if (c.superClass_) return ret = c.superClass_.constructor.apply(a, Array.prototype.slice.call(arguments, 1)), ret;
        for (var d = Array.prototype.slice.call(arguments, 2), e = !1, f = a.constructor; f; f = f.superClass_ && f.superClass_.constructor)
            if (f.prototype[b] === c) e = !0;
            else if (e) return f.prototype[b].apply(a, d);
        if (a[b] === c) return a.constructor.prototype[b].apply(a, d);
        throw Error("cc.base called from a method of one name to a method of a different name")
    }, cc.rendererCanvas = {
        childrenOrderDirty: !0,
        _transformNodePool: [],
        _renderCmds: [],
        _isCacheToCanvasOn: !1,
        _cacheToCanvasCmds: {},
        _cacheInstanceIds: [],
        _currentID: 0,
        getRenderCmd: function(a) {
            return a._createRenderCmd()
        },
        rendering: function(a) {
            var b, c, d = this._renderCmds,
                e = cc.view.getScaleX(),
                f = cc.view.getScaleY(),
                g = a || cc._renderContext;
            for (g.computeRealOffsetY(), b = 0, c = d.length; c > b; b++) d[b].rendering(g, e, f)
        },
        _renderingToCacheCanvas: function(a, b, c, d) {
            a || cc.log("The context of RenderTexture is invalid."), c = cc.isUndefined(c) ? 1 : c, d = cc.isUndefined(d) ? 1 : d, b = b || this._currentID;
            var e, f, g = this._cacheToCanvasCmds[b];
            for (a.computeRealOffsetY(), e = 0, f = g.length; f > e; e++) g[e].rendering(a, c, d);
            g.length = 0;
            var h = this._cacheInstanceIds;
            delete this._cacheToCanvasCmds[b], cc.arrayRemoveObject(h, b), 0 === h.length ? this._isCacheToCanvasOn = !1 : this._currentID = h[h.length - 1]
        },
        _turnToCacheMode: function(a) {
            this._isCacheToCanvasOn = !0, a = a || 0, this._cacheToCanvasCmds[a] = [], -1 === this._cacheInstanceIds.indexOf(a) && this._cacheInstanceIds.push(a), this._currentID = a
        },
        _turnToNormalMode: function() {
            this._isCacheToCanvasOn = !1
        },
        resetFlag: function() {
            this.childrenOrderDirty = !1, this._transformNodePool.length = 0
        },
        transform: function() {
            var a = this._transformNodePool;
            a.sort(this._sortNodeByLevelAsc);
            for (var b = 0, c = a.length; c > b; b++) 0 !== a[b]._dirtyFlag && a[b].updateStatus();
            a.length = 0
        },
        transformDirty: function() {
            return this._transformNodePool.length > 0
        },
        _sortNodeByLevelAsc: function(a, b) {
            return a._curLevel - b._curLevel
        },
        pushDirtyNode: function(a) {
            this._transformNodePool.push(a)
        },
        clearRenderCommands: function() {
            this._renderCmds.length = 0
        },
        pushRenderCommand: function(a) {
            if (a._needDraw)
                if (this._isCacheToCanvasOn) {
                    var b = this._currentID,
                        c = this._cacheToCanvasCmds,
                        d = c[b]; - 1 === d.indexOf(a) && d.push(a)
                } else -1 === this._renderCmds.indexOf(a) && this._renderCmds.push(a)
        }
    }, cc._renderType === cc._RENDER_TYPE_CANVAS && (cc.renderer = cc.rendererCanvas),
    function() {
        cc.CanvasContextWrapper = function(a) {
            this._context = a, this._saveCount = 0, this._currentAlpha = a.globalAlpha, this._currentCompositeOperation = a.globalCompositeOperation, this._currentFillStyle = a.fillStyle, this._currentStrokeStyle = a.strokeStyle, this._offsetX = 0, this._offsetY = 0, this._realOffsetY = this.height, this._armatureMode = 0
        };
        var a = cc.CanvasContextWrapper.prototype;
        a.resetCache = function() {
            var a = this._context;
            this._currentAlpha = a.globalAlpha, this._currentCompositeOperation = a.globalCompositeOperation, this._currentFillStyle = a.fillStyle, this._currentStrokeStyle = a.strokeStyle, this._realOffsetY = this._context.canvas.height + this._offsetY
        }, a.setOffset = function(a, b) {
            this._offsetX = a, this._offsetY = b, this._realOffsetY = this._context.canvas.height + this._offsetY
        }, a.computeRealOffsetY = function() {
            this._realOffsetY = this._context.canvas.height + this._offsetY
        }, a.setViewScale = function(a, b) {
            this._scaleX = a, this._scaleY = b
        }, a.getContext = function() {
            return this._context
        }, a.save = function() {
            this._context.save(), this._saveCount++
        }, a.restore = function() {
            this._context.restore(), this._saveCount--
        }, a.setGlobalAlpha = function(a) {
            this._saveCount > 0 ? this._context.globalAlpha = a : this._currentAlpha !== a && (this._currentAlpha = a, this._context.globalAlpha = a)
        }, a.setCompositeOperation = function(a) {
            this._saveCount > 0 ? this._context.globalCompositeOperation = a : this._currentCompositeOperation !== a && (this._currentCompositeOperation = a, this._context.globalCompositeOperation = a)
        }, a.setFillStyle = function(a) {
            this._saveCount > 0 ? this._context.fillStyle = a : this._currentFillStyle !== a && (this._currentFillStyle = a, this._context.fillStyle = a)
        }, a.setStrokeStyle = function(a) {
            this._saveCount > 0 ? this._context.strokeStyle = a : this._currentStrokeStyle !== a && (this._currentStrokeStyle = a, this._context.strokeStyle = a)
        }, a.setTransform = function(a, b, c) {
            this._armatureMode > 0 ? (this.restore(), this.save(), this._context.transform(a.a, a.c, a.b, a.d, a.tx * b, -(a.ty * c))) : this._context.setTransform(a.a, a.c, a.b, a.d, this._offsetX + a.tx * b, this._realOffsetY - a.ty * c)
        }, a._switchToArmatureMode = function(a, b, c, d) {
            a ? (this._armatureMode++, this._context.setTransform(b.a, b.c, b.b, b.d, this._offsetX + b.tx * c, this._realOffsetY - b.ty * d), this.save()) : (this._armatureMode--, this.restore())
        }
    }();
cc._renderType === cc._RENDER_TYPE_WEBGL && ! function() {
        cc.DirectorDelegate = cc.Class.extend({
            updateProjection: function() {}
        });
        var a = cc.Director.prototype;
        a.setProjection = function(a) {
            var b = this,
                c = b._winSizeInPoints;
            b.setViewport();
            var d = b._openGLView,
                e = d._viewPortRect.x / d._scaleX,
                f = d._viewPortRect.y / d._scaleY;
            switch (a) {
                case cc.Director.PROJECTION_2D:
                    cc.kmGLMatrixMode(cc.KM_GL_PROJECTION), cc.kmGLLoadIdentity();
                    var g = new cc.kmMat4;
                    cc.kmMat4OrthographicProjection(g, -e, c.width - e, -f, c.height - f, -1024, 1024), cc.kmGLMultMatrix(g), cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW), cc.kmGLLoadIdentity();
                    break;
                case cc.Director.PROJECTION_3D:
                    var h = b.getZEye(),
                        i = new cc.kmMat4,
                        j = new cc.kmMat4;
                    cc.kmGLMatrixMode(cc.KM_GL_PROJECTION), cc.kmGLLoadIdentity(), cc.kmMat4PerspectiveProjection(i, 60, c.width / c.height, .1, 2 * h), cc.kmGLMultMatrix(i), cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW), cc.kmGLLoadIdentity();
                    var k = cc.kmVec3Fill(null, -e + c.width / 2, -f + c.height / 2, h),
                        l = cc.kmVec3Fill(null, -e + c.width / 2, -f + c.height / 2, 0),
                        m = cc.kmVec3Fill(null, 0, 1, 0);
                    cc.kmMat4LookAt(j, k, l, m), cc.kmGLMultMatrix(j);
                    break;
                case cc.Director.PROJECTION_CUSTOM:
                    b._projectionDelegate && b._projectionDelegate.updateProjection();
                    break;
                default:
                    cc.log(cc._LogInfos.Director_setProjection)
            }
            b._projection = a, cc.eventManager.dispatchEvent(b._eventProjectionChanged), cc.setProjectionMatrixDirty(), cc.renderer.childrenOrderDirty = !0
        }, a.setDepthTest = function(a) {
            var b = cc._renderContext;
            a ? (b.clearDepth(1), b.enable(b.DEPTH_TEST), b.depthFunc(b.LEQUAL)) : b.disable(b.DEPTH_TEST)
        }, a.setOpenGLView = function(a) {
            var b = this;
            b._winSizeInPoints.width = cc._canvas.width, b._winSizeInPoints.height = cc._canvas.height, b._openGLView = a || cc.view;
            var c = cc.configuration;
            c.gatherGPUInfo(), c.dumpInfo(), b._createStatsLabel(), b.setGLDefaultValues(), cc.eventManager && cc.eventManager.setEnabled(!0)
        }, a._clear = function() {
            var a = cc._renderContext;
            a.clear(a.COLOR_BUFFER_BIT | a.DEPTH_BUFFER_BIT)
        }, a._beforeVisitScene = function() {
            cc.kmGLPushMatrix()
        }, a._afterVisitScene = function() {
            cc.kmGLPopMatrix()
        }, a._createStatsLabel = function() {
            var a = this;
            if (!cc.LabelAtlas) return void a._createStatsLabelForCanvas();
            if (null != cc.Director._fpsImageLoaded && 0 != cc.Director._fpsImageLoaded) {
                var b = new cc.Texture2D;
                b.initWithElement(cc.Director._fpsImage), b.handleLoadedTexture();
                var c = cc.view.getDesignResolutionSize().height / 320;
                0 === c && (c = a._winSizeInPoints.height / 320);
                var d = new cc.LabelAtlas;
                d._setIgnoreContentScaleFactor(!0), d.initWithString("00.0", b, 12, 32, "."), d.scale = c, a._FPSLabel = d, d = new cc.LabelAtlas, d._setIgnoreContentScaleFactor(!0), d.initWithString("0.000", b, 12, 32, "."), d.scale = c, a._SPFLabel = d, d = new cc.LabelAtlas, d._setIgnoreContentScaleFactor(!0), d.initWithString("000", b, 12, 32, "."), d.scale = c, a._drawsLabel = d;
                var e = cc.DIRECTOR_STATS_POSITION;
                a._drawsLabel.setPosition(e.x, 34 * c + e.y), a._SPFLabel.setPosition(e.x, 17 * c + e.y), a._FPSLabel.setPosition(e)
            }
        }, a._createStatsLabelForCanvas = function() {
            var a = this,
                b = 0;
            b = a._winSizeInPoints.width > a._winSizeInPoints.height ? 0 | a._winSizeInPoints.height / 320 * 24 : 0 | a._winSizeInPoints.width / 320 * 24, a._FPSLabel = new cc.LabelTTF("000.0", "Arial", b), a._SPFLabel = new cc.LabelTTF("0.000", "Arial", b), a._drawsLabel = new cc.LabelTTF("0000", "Arial", b);
            var c = cc.DIRECTOR_STATS_POSITION;
            a._drawsLabel.setPosition(a._drawsLabel.width / 2 + c.x, 5 * a._drawsLabel.height / 2 + c.y), a._SPFLabel.setPosition(a._SPFLabel.width / 2 + c.x, 3 * a._SPFLabel.height / 2 + c.y), a._FPSLabel.setPosition(a._FPSLabel.width / 2 + c.x, a._FPSLabel.height / 2 + c.y)
        }, a.convertToGL = function(a) {
            var b = new cc.kmMat4;
            cc.GLToClipTransform(b);
            var c = new cc.kmMat4;
            cc.kmMat4Inverse(c, b);
            var d = b.mat[14] / b.mat[15],
                e = this._openGLView.getDesignResolutionSize(),
                f = new cc.kmVec3(2 * a.x / e.width - 1, 1 - 2 * a.y / e.height, d),
                g = new cc.kmVec3;
            return cc.kmVec3TransformCoord(g, f, c), cc.p(g.x, g.y)
        }, a.convertToUI = function(a) {
            var b = new cc.kmMat4;
            cc.GLToClipTransform(b);
            var c = new cc.kmVec3,
                d = new cc.kmVec3(a.x, a.y, 0);
            cc.kmVec3TransformCoord(c, d, b);
            var e = this._openGLView.getDesignResolutionSize();
            return cc.p(e.width * (.5 * c.x + .5), e.height * (.5 * -c.y + .5))
        }, a.getVisibleSize = function() {
            return this._openGLView.getVisibleSize()
        }, a.getVisibleOrigin = function() {
            return this._openGLView.getVisibleOrigin()
        }, a.getZEye = function() {
            return this._winSizeInPoints.height / 1.1566
        }, a.setViewport = function() {
            var a = this._openGLView;
            if (a) {
                var b = this._winSizeInPoints;
                a.setViewPortInPoints(-a._viewPortRect.x / a._scaleX, -a._viewPortRect.y / a._scaleY, b.width, b.height)
            }
        }, a.getOpenGLView = function() {
            return this._openGLView
        }, a.getProjection = function() {
            return this._projection
        }, a.setAlphaBlending = function(a) {
            a ? cc.glBlendFunc(cc.BLEND_SRC, cc.BLEND_DST) : cc.glBlendFunc(cc._renderContext.ONE, cc._renderContext.ZERO)
        }, a.setGLDefaultValues = function() {
            var a = this;
            a.setAlphaBlending(!0), a.setDepthTest(!1), a.setProjection(a._projection), cc._renderContext.clearColor(0, 0, 0, 1)
        }
    }(), cc.configuration = {
        ERROR: 0,
        STRING: 1,
        INT: 2,
        DOUBLE: 3,
        BOOLEAN: 4,
        _maxTextureSize: 0,
        _maxModelviewStackDepth: 0,
        _supportsPVRTC: !1,
        _supportsNPOT: !1,
        _supportsBGRA8888: !1,
        _supportsDiscardFramebuffer: !1,
        _supportsShareableVAO: !1,
        _maxSamplesAllowed: 0,
        _maxTextureUnits: 0,
        _GlExtensions: "",
        _valueDict: {},
        _inited: !1,
        _init: function() {
            var a = this._valueDict;
            a["cocos2d.x.version"] = cc.ENGINE_VERSION, a["cocos2d.x.compiled_with_profiler"] = !1, a["cocos2d.x.compiled_with_gl_state_cache"] = cc.ENABLE_GL_STATE_CACHE, this._inited = !0
        },
        getMaxTextureSize: function() {
            return this._maxTextureSize
        },
        getMaxModelviewStackDepth: function() {
            return this._maxModelviewStackDepth
        },
        getMaxTextureUnits: function() {
            return this._maxTextureUnits
        },
        supportsNPOT: function() {
            return this._supportsNPOT
        },
        supportsPVRTC: function() {
            return this._supportsPVRTC
        },
        supportsETC: function() {
            return !1
        },
        supportsS3TC: function() {
            return !1
        },
        supportsATITC: function() {
            return !1
        },
        supportsBGRA8888: function() {
            return this._supportsBGRA8888
        },
        supportsDiscardFramebuffer: function() {
            return this._supportsDiscardFramebuffer
        },
        supportsShareableVAO: function() {
            return this._supportsShareableVAO
        },
        checkForGLExtension: function(a) {
            return this._GlExtensions.indexOf(a) > -1
        },
        getValue: function(a, b) {
            this._inited || this._init();
            var c = this._valueDict;
            return c[a] ? c[a] : b
        },
        setValue: function(a, b) {
            this._valueDict[a] = b
        },
        dumpInfo: function() {
            0 === cc.ENABLE_GL_STATE_CACHE && (cc.log(""), cc.log(cc._LogInfos.configuration_dumpInfo), cc.log(""))
        },
        gatherGPUInfo: function() {
            if (cc._renderType !== cc._RENDER_TYPE_CANVAS) {
                this._inited || this._init();
                var a = cc._renderContext,
                    b = this._valueDict;
                b["gl.vendor"] = a.getParameter(a.VENDOR), b["gl.renderer"] = a.getParameter(a.RENDERER), b["gl.version"] = a.getParameter(a.VERSION), this._GlExtensions = "";
                for (var c = a.getSupportedExtensions(), d = 0; d < c.length; d++) this._GlExtensions += c[d] + " ";
                this._maxTextureSize = a.getParameter(a.MAX_TEXTURE_SIZE), b["gl.max_texture_size"] = this._maxTextureSize, this._maxTextureUnits = a.getParameter(a.MAX_COMBINED_TEXTURE_IMAGE_UNITS), b["gl.max_texture_units"] = this._maxTextureUnits, this._supportsPVRTC = this.checkForGLExtension("GL_IMG_texture_compression_pvrtc"), b["gl.supports_PVRTC"] = this._supportsPVRTC, this._supportsNPOT = !1, b["gl.supports_NPOT"] = this._supportsNPOT, this._supportsBGRA8888 = this.checkForGLExtension("GL_IMG_texture_format_BGRA888"), b["gl.supports_BGRA8888"] = this._supportsBGRA8888, this._supportsDiscardFramebuffer = this.checkForGLExtension("GL_EXT_discard_framebuffer"), b["gl.supports_discard_framebuffer"] = this._supportsDiscardFramebuffer, this._supportsShareableVAO = this.checkForGLExtension("vertex_array_object"), b["gl.supports_vertex_array_object"] = this._supportsShareableVAO, cc.checkGLErrorDebug()
            }
        },
        loadConfigFile: function(a) {
            this._inited || this._init();
            var b = cc.loader.getRes(a);
            if (!b) throw "Please load the resource first : " + a;
            cc.assert(b, cc._LogInfos.configuration_loadConfigFile_2, a);
            var c = b.data;
            if (!c) return void cc.log(cc._LogInfos.configuration_loadConfigFile, a);
            for (var d in c) this._valueDict[d] = c[d]
        }
    }, cc.rendererWebGL = {
        childrenOrderDirty: !0,
        _transformNodePool: [],
        _renderCmds: [],
        _isCacheToBufferOn: !1,
        _cacheToBufferCmds: {},
        _cacheInstanceIds: [],
        _currentID: 0,
        getRenderCmd: function(a) {
            return a._createRenderCmd()
        },
        rendering: function(a) {
            var b, c, d = this._renderCmds,
                e = a || cc._renderContext;
            for (b = 0, c = d.length; c > b; b++) d[b].rendering(e)
        },
        _turnToCacheMode: function(a) {
            this._isCacheToBufferOn = !0, a = a || 0, this._cacheToBufferCmds[a] = [], this._cacheInstanceIds.push(a), this._currentID = a
        },
        _turnToNormalMode: function() {
            this._isCacheToBufferOn = !1
        },
        _renderingToBuffer: function(a) {
            a = a || this._currentID;
            var b, c, d = this._cacheToBufferCmds[a],
                e = cc._renderContext,
                f = this._cacheInstanceIds;
            for (b = 0, c = d.length; c > b; b++) d[b].rendering(e);
            d.length = 0, delete this._cacheToBufferCmds[a], cc.arrayRemoveObject(f, a), 0 === f.length ? this._isCacheToBufferOn = !1 : this._currentID = f[f.length - 1]
        },
        resetFlag: function() {
            this.childrenOrderDirty = !1, this._transformNodePool.length = 0
        },
        transform: function() {
            var a = this._transformNodePool;
            a.sort(this._sortNodeByLevelAsc);
            for (var b = 0, c = a.length; c > b; b++) a[b].updateStatus();
            a.length = 0
        },
        transformDirty: function() {
            return this._transformNodePool.length > 0
        },
        _sortNodeByLevelAsc: function(a, b) {
            return a._curLevel - b._curLevel
        },
        pushDirtyNode: function(a) {
            this._transformNodePool.push(a)
        },
        clearRenderCommands: function() {
            this._renderCmds.length = 0
        },
        pushRenderCommand: function(a) {
            if (a._needDraw)
                if (this._isCacheToBufferOn) {
                    var b = this._currentID,
                        c = this._cacheToBufferCmds,
                        d = c[b]; - 1 === d.indexOf(a) && d.push(a)
                } else -1 === this._renderCmds.indexOf(a) && this._renderCmds.push(a)
        }
    }, cc._renderType === cc._RENDER_TYPE_WEBGL && (cc.renderer = cc.rendererWebGL),
    function() {
        cc.Node.WebGLRenderCmd = function(a) {
            cc.Node.RenderCmd.call(this, a);
            var b = new cc.kmMat4;
            b.mat[2] = b.mat[3] = b.mat[6] = b.mat[7] = b.mat[8] = b.mat[9] = b.mat[11] = b.mat[14] = 0, b.mat[10] = b.mat[15] = 1, this._transform4x4 = b, this._stackMatrix = new cc.kmMat4, this._shaderProgram = null, this._camera = null
        };
        var a = cc.Node.WebGLRenderCmd.prototype = Object.create(cc.Node.RenderCmd.prototype);
        a.constructor = cc.Node.WebGLRenderCmd, a.getNodeToParentTransform = function() {
            var a = this._node;
            if (a._usingNormalizedPosition && a._parent) {
                var b = a._parent._contentSize;
                a._position.x = a._normalizedPosition.x * b.width, a._position.y = a._normalizedPosition.y * b.height, a._normalizedPositionDirty = !1
            }
            if (this._dirtyFlag & cc.Node._dirtyFlags.transformDirty) {
                var c = a._position.x,
                    d = a._position.y,
                    e = this._anchorPointInPoints.x,
                    f = -e,
                    g = this._anchorPointInPoints.y,
                    h = -g,
                    i = a._scaleX,
                    j = a._scaleY,
                    k = .017453292519943295 * a._rotationX,
                    l = .017453292519943295 * a._rotationY;
                a._ignoreAnchorPointForPosition && (c += e, d += g);
                var m = 1,
                    n = 0,
                    o = 1,
                    p = 0;
                (0 !== a._rotationX || 0 !== a._rotationY) && (m = Math.cos(-k), n = Math.sin(-k), o = Math.cos(-l), p = Math.sin(-l));
                var q = a._skewX || a._skewY;
                q || 0 === e && 0 === g || (c += o * f * i + -n * h * j, d += p * f * i + m * h * j);
                var r = this._transform;
                r.a = o * i, r.b = p * i, r.c = -n * j, r.d = m * j, r.tx = c, r.ty = d, q && (r = cc.affineTransformConcat({
                    a: 1,
                    b: Math.tan(cc.degreesToRadians(a._skewY)),
                    c: Math.tan(cc.degreesToRadians(a._skewX)),
                    d: 1,
                    tx: 0,
                    ty: 0
                }, r), (0 !== e || 0 !== g) && (r = cc.affineTransformTranslate(r, f, h))), a._additionalTransformDirty && (r = cc.affineTransformConcat(r, a._additionalTransform), a._additionalTransformDirty = !1), this._transform = r
            }
            return this._transform
        }, a._syncStatus = function(a) {
            var b = cc.Node._dirtyFlags,
                c = this._dirtyFlag,
                d = a ? a._node : null;
            d && d._cascadeColorEnabled && a._dirtyFlag & b.colorDirty && (c |= b.colorDirty), d && d._cascadeOpacityEnabled && a._dirtyFlag & b.opacityDirty && (c |= b.opacityDirty), a && a._dirtyFlag & b.transformDirty && (c |= b.transformDirty);
            var e = c & b.colorDirty,
                f = c & b.opacityDirty;
            this._dirtyFlag = c, e && this._syncDisplayColor(), f && this._syncDisplayOpacity(), (e || f) && this._updateColor(), this.transform(a)
        }, a._updateColor = function() {}, a.visit = function(a) {
            var b = this._node;
            if (b._visible) {
                a = a || this.getParentRenderCmd(), b._parent && b._parent._renderCmd && (this._curLevel = b._parent._renderCmd._curLevel + 1);
                var c, d = cc.current_stack;
                d.stack.push(d.top), this._syncStatus(a), d.top = this._stackMatrix;
                var e = b._children;
                if (e && e.length > 0) {
                    var f = e.length;
                    for (b.sortAllChildren(), c = 0; f > c && (e[c] && e[c]._localZOrder < 0); c++) e[c]._renderCmd.visit(this);
                    for (cc.renderer.pushRenderCommand(this); f > c; c++) e[c] && e[c]._renderCmd.visit(this)
                } else cc.renderer.pushRenderCommand(this);
                this._dirtyFlag = 0, d.top = d.stack.pop()
            }
        }, a.transform = function(a, b) {
            var c = this._transform4x4,
                d = this._stackMatrix,
                e = this._node;
            a = a || this.getParentRenderCmd();
            var f = a ? a._stackMatrix : cc.current_stack.top,
                g = this.getNodeToParentTransform();
            this._dirtyFlag = this._dirtyFlag & cc.Node._dirtyFlags.transformDirty ^ this._dirtyFlag;
            var h = c.mat;
            if (h[0] = g.a, h[4] = g.c, h[12] = g.tx, h[1] = g.b, h[5] = g.d, h[13] = g.ty, h[14] = e._vertexZ, cc.kmMat4Multiply(d, f, c), null != e._camera && (null == e.grid || !e.grid.isActive())) {
                var i = this._anchorPointInPoints.x,
                    j = this._anchorPointInPoints.y,
                    k = 0 !== i || 0 !== j;
                if (k) {
                    cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (i = 0 | i, j = 0 | j);
                    var l = new cc.kmMat4;
                    cc.kmMat4Translation(l, i, j, 0), cc.kmMat4Multiply(d, d, l), e._camera._locateForRenderer(d), cc.kmMat4Translation(l, -i, -j, 0), cc.kmMat4Multiply(d, d, l)
                } else e._camera._locateForRenderer(d)
            }
            if (b && e._children && 0 !== e._children.length) {
                var m, n, o = e._children;
                for (m = 0, n = o.length; n > m; m++) o[m]._renderCmd.transform(this, b)
            }
        }, a.setShaderProgram = function(a) {
            this._shaderProgram = a
        }, a.getShaderProgram = function() {
            return this._shaderProgram
        }
    }(),
    function() {
        cc.Layer.WebGLRenderCmd = function(a) {
            cc.Node.WebGLRenderCmd.call(this, a)
        };
        var a = cc.Layer.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
        a.constructor = cc.Layer.WebGLRenderCmd, a.bake = function() {}, a.unbake = function() {}, a._bakeForAddChild = function() {}
    }(),
    function() {
        cc.LayerColor.WebGLRenderCmd = function(a) {
            cc.Layer.WebGLRenderCmd.call(this, a), this._needDraw = !0;
            var b = this;
            b._squareVerticesAB = new ArrayBuffer(32), b._squareColorsAB = new ArrayBuffer(16);
            var c = b._squareVerticesAB,
                d = b._squareColorsAB,
                e = cc.Vertex2F.BYTES_PER_ELEMENT,
                f = cc.Color.BYTES_PER_ELEMENT;
            b._squareVertices = [new cc.Vertex2F(0, 0, c, 0), new cc.Vertex2F(0, 0, c, e), new cc.Vertex2F(0, 0, c, 2 * e), new cc.Vertex2F(0, 0, c, 3 * e)], b._squareColors = [cc.color(0, 0, 0, 255, d, 0), cc.color(0, 0, 0, 255, d, f), cc.color(0, 0, 0, 255, d, 2 * f), cc.color(0, 0, 0, 255, d, 3 * f)], b._verticesFloat32Buffer = cc._renderContext.createBuffer(), b._colorsUint8Buffer = cc._renderContext.createBuffer()
        };
        var a = cc.LayerColor.WebGLRenderCmd.prototype = Object.create(cc.Layer.WebGLRenderCmd.prototype);
        a.constructor = cc.LayerColor.WebGLRenderCmd, cc.LayerColor.WebGLRenderCmd.prototype.rendering = function(a) {
            var b = a || cc._renderContext,
                c = this._node;
            this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR), cc.glBlendFunc(c._blendFunc.src, c._blendFunc.dst), b.bindBuffer(b.ARRAY_BUFFER, this._verticesFloat32Buffer), b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, b.FLOAT, !1, 0, 0), b.bindBuffer(b.ARRAY_BUFFER, this._colorsUint8Buffer), b.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, b.UNSIGNED_BYTE, !0, 0, 0), b.drawArrays(b.TRIANGLE_STRIP, 0, 4)
        }, a._updateSquareVertices = function(a, b) {
            var c = this._squareVertices;
            void 0 === b ? (c[1].x = a.width, c[2].y = a.height, c[3].x = a.width, c[3].y = a.height) : (c[1].x = a, c[2].y = b, c[3].x = a, c[3].y = b), this._bindLayerVerticesBufferData()
        }, a._updateSquareVerticesWidth = function(a) {
            var b = this._squareVertices;
            b[1].x = a, b[3].x = a, this._bindLayerVerticesBufferData()
        }, a._updateSquareVerticesHeight = function(a) {
            var b = this._squareVertices;
            b[2].y = a, b[3].y = a, this._bindLayerVerticesBufferData()
        }, a._updateColor = function() {
            for (var a = this._displayedColor, b = this._displayedOpacity, c = this._squareColors, d = 0; 4 > d; d++) c[d].r = a.r, c[d].g = a.g, c[d].b = a.b, c[d].a = b;
            this._bindLayerColorsBufferData()
        }, a._bindLayerVerticesBufferData = function() {
            var a = cc._renderContext;
            a.bindBuffer(a.ARRAY_BUFFER, this._verticesFloat32Buffer), a.bufferData(a.ARRAY_BUFFER, this._squareVerticesAB, a.STATIC_DRAW)
        }, a._bindLayerColorsBufferData = function() {
            var a = cc._renderContext;
            a.bindBuffer(a.ARRAY_BUFFER, this._colorsUint8Buffer), a.bufferData(a.ARRAY_BUFFER, this._squareColorsAB, a.STATIC_DRAW)
        }, a.updateBlendFunc = function() {}
    }(),
    function() {
        cc.LayerGradient.WebGLRenderCmd = function(a) {
            cc.LayerColor.WebGLRenderCmd.call(this, a), this._needDraw = !0
        };
        var a = cc.LayerGradient.WebGLRenderCmd.prototype = Object.create(cc.LayerColor.WebGLRenderCmd.prototype);
        cc.inject(cc.LayerGradient.RenderCmd, a), a.constructor = cc.LayerGradient.WebGLRenderCmd, a._syncStatus = function(a) {
            var b = cc.Node._dirtyFlags,
                c = this._dirtyFlag,
                d = a ? a._node : null;
            d && d._cascadeColorEnabled && a._dirtyFlag & b.colorDirty && (c |= b.colorDirty), d && d._cascadeOpacityEnabled && a._dirtyFlag & b.opacityDirty && (c |= b.opacityDirty), a && a._dirtyFlag & b.transformDirty && (c |= b.transformDirty);
            var e = c & b.colorDirty,
                f = c & b.opacityDirty;
            this._dirtyFlag = c, e && this._syncDisplayColor(), f && this._syncDisplayOpacity(), this.transform(a), (e || f || c & b.gradientDirty) && this._updateColor()
        }, a._updateColor = function() {
            this._dirtyFlag = this._dirtyFlag & cc.Node._dirtyFlags.gradientDirty ^ this._dirtyFlag;
            var a = this,
                b = this._node,
                c = b._alongVector,
                d = cc.pLength(c);
            if (0 !== d) {
                var e = Math.sqrt(2),
                    f = cc.p(c.x / d, c.y / d);
                if (b._compressedInterpolation) {
                    var g = 1 / (Math.abs(f.x) + Math.abs(f.y));
                    f = cc.pMult(f, g * e)
                }
                var h = a._displayedOpacity / 255,
                    i = a._displayedColor,
                    j = b._endColor,
                    k = {
                        r: i.r,
                        g: i.g,
                        b: i.b,
                        a: b._startOpacity * h
                    },
                    l = {
                        r: j.r,
                        g: j.g,
                        b: j.b,
                        a: b._endOpacity * h
                    },
                    m = a._squareColors,
                    n = m[0],
                    o = m[1],
                    p = m[2],
                    q = m[3];
                n.r = l.r + (k.r - l.r) * ((e + f.x + f.y) / (2 * e)), n.g = l.g + (k.g - l.g) * ((e + f.x + f.y) / (2 * e)), n.b = l.b + (k.b - l.b) * ((e + f.x + f.y) / (2 * e)), n.a = l.a + (k.a - l.a) * ((e + f.x + f.y) / (2 * e)), o.r = l.r + (k.r - l.r) * ((e - f.x + f.y) / (2 * e)), o.g = l.g + (k.g - l.g) * ((e - f.x + f.y) / (2 * e)), o.b = l.b + (k.b - l.b) * ((e - f.x + f.y) / (2 * e)), o.a = l.a + (k.a - l.a) * ((e - f.x + f.y) / (2 * e)), p.r = l.r + (k.r - l.r) * ((e + f.x - f.y) / (2 * e)), p.g = l.g + (k.g - l.g) * ((e + f.x - f.y) / (2 * e)), p.b = l.b + (k.b - l.b) * ((e + f.x - f.y) / (2 * e)), p.a = l.a + (k.a - l.a) * ((e + f.x - f.y) / (2 * e)), q.r = l.r + (k.r - l.r) * ((e - f.x - f.y) / (2 * e)), q.g = l.g + (k.g - l.g) * ((e - f.x - f.y) / (2 * e)), q.b = l.b + (k.b - l.b) * ((e - f.x - f.y) / (2 * e)), q.a = l.a + (k.a - l.a) * ((e - f.x - f.y) / (2 * e)), a._bindLayerColorsBufferData()
            }
        }
    }(),
    function() {
        cc.Sprite.WebGLRenderCmd = function(a) {
            cc.Node.WebGLRenderCmd.call(this, a), this._needDraw = !0, this._quad = new cc.V3F_C4B_T2F_Quad, this._quadWebBuffer = cc._renderContext.createBuffer(), this._quadDirty = !0, this._dirty = !1, this._recursiveDirty = !1
        };
        var a = cc.Sprite.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
        a.constructor = cc.Sprite.WebGLRenderCmd, a.updateBlendFunc = function() {}, a.setDirtyFlag = function(a) {
            cc.Node.WebGLRenderCmd.prototype.setDirtyFlag.call(this, a), this._dirty = !0
        }, a.setDirtyRecursively = function(a) {
            this._recursiveDirty = a, this._dirty = a;
            for (var b, c = this._node._children, d = c ? c.length : 0, e = 0; d > e; e++) b = c[e], b instanceof cc.Sprite && b._renderCmd.setDirtyRecursively(a)
        }, a._setBatchNodeForAddChild = function(a) {
            var b = this._node;
            if (b._batchNode) {
                if (!(a instanceof cc.Sprite)) return cc.log(cc._LogInfos.Sprite_addChild), !1;
                a.texture._webTextureObj !== b.textureAtlas.texture._webTextureObj && cc.log(cc._LogInfos.Sprite_addChild_2), b._batchNode.appendChild(a), b._reorderChildDirty || b._setReorderChildDirtyRecursively()
            }
            return !0
        }, a._handleTextureForRotatedTexture = function(a) {
            return a
        }, a.isFrameDisplayed = function(a) {
            var b = this._node;
            return cc.rectEqualToRect(a.getRect(), b._rect) && a.getTexture().getName() == b._texture.getName() && cc.pointEqualToPoint(a.getOffset(), b._unflippedOffsetPositionFromCenter)
        }, a._init = function() {
            var a = {
                    r: 255,
                    g: 255,
                    b: 255,
                    a: 255
                },
                b = this._quad;
            b.bl.colors = a, b.br.colors = a, b.tl.colors = a, b.tr.colors = a, this._quadDirty = !0
        }, a._resetForBatchNode = function() {
            var a = this._node,
                b = a._offsetPosition.x,
                c = a._offsetPosition.y,
                d = b + a._rect.width,
                e = c + a._rect.height,
                f = this._quad;
            f.bl.vertices = {
                x: b,
                y: c,
                z: 0
            }, f.br.vertices = {
                x: d,
                y: c,
                z: 0
            }, f.tl.vertices = {
                x: b,
                y: e,
                z: 0
            }, f.tr.vertices = {
                x: d,
                y: e,
                z: 0
            }, this._quadDirty = !0
        }, a.getQuad = function() {
            return this._quad
        }, a._updateForSetSpriteFrame = function() {}, a._spriteFrameLoadedCallback = function(a) {
            this.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize()), this.dispatchEvent("load")
        }, a._textureLoadedCallback = function(a) {
            var b = this._renderCmd;
            if (!this._textureLoaded) {
                this._textureLoaded = !0;
                var c = this._rect;
                c ? cc._rectEqualToZero(c) && (c.width = a.width, c.height = a.height) : c = cc.rect(0, 0, a.width, a.height), this.texture = a, this.setTextureRect(c, this._rectRotated), this.setBatchNode(this._batchNode), b._quadDirty = !0, this.dispatchEvent("load")
            }
        }, a._setTextureCoords = function(a, b) {
            void 0 === b && (b = !0), b && (a = cc.rectPointsToPixels(a));
            var c = this._node,
                d = c._batchNode ? c.textureAtlas.texture : c._texture;
            if (d) {
                var e, f, g, h, i, j = d.pixelsWidth,
                    k = d.pixelsHeight,
                    l = this._quad;
                c._rectRotated ? (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (e = (2 * a.x + 1) / (2 * j), f = e + (2 * a.height - 2) / (2 * j), g = (2 * a.y + 1) / (2 * k), h = g + (2 * a.width - 2) / (2 * k)) : (e = a.x / j, f = (a.x + a.height) / j, g = a.y / k, h = (a.y + a.width) / k), c._flippedX && (i = g, g = h, h = i), c._flippedY && (i = e, e = f, f = i), l.bl.texCoords.u = e, l.bl.texCoords.v = g, l.br.texCoords.u = e, l.br.texCoords.v = h, l.tl.texCoords.u = f, l.tl.texCoords.v = g, l.tr.texCoords.u = f, l.tr.texCoords.v = h) : (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (e = (2 * a.x + 1) / (2 * j), f = e + (2 * a.width - 2) / (2 * j), g = (2 * a.y + 1) / (2 * k), h = g + (2 * a.height - 2) / (2 * k)) : (e = a.x / j, f = (a.x + a.width) / j, g = a.y / k, h = (a.y + a.height) / k), c._flippedX && (i = e, e = f, f = i), c._flippedY && (i = g, g = h, h = i), l.bl.texCoords.u = e, l.bl.texCoords.v = h, l.br.texCoords.u = f, l.br.texCoords.v = h, l.tl.texCoords.u = e, l.tl.texCoords.v = g, l.tr.texCoords.u = f, l.tr.texCoords.v = g), this._quadDirty = !0
            }
        }, a.transform = function(a, b) {
            cc.Node.WebGLRenderCmd.prototype.transform.call(this, a, b), this._dirty = !0
        }, a._setColorDirty = function() {}, a._updateColor = function() {
            var a = this._displayedColor,
                b = this._displayedOpacity,
                c = this._node,
                d = {
                    r: a.r,
                    g: a.g,
                    b: a.b,
                    a: b
                };
            c._opacityModifyRGB && (d.r *= b / 255, d.g *= b / 255, d.b *= b / 255);
            var e = this._quad;
            e.bl.colors = d, e.br.colors = d, e.tl.colors = d, e.tr.colors = d, c._batchNode && (c.atlasIndex != cc.Sprite.INDEX_NOT_INITIALIZED ? c.textureAtlas.updateQuad(e, c.atlasIndex) : this._dirty = !0), this._quadDirty = !0
        }, a._updateBlendFunc = function() {
            if (this._batchNode) return void cc.log(cc._LogInfos.Sprite__updateBlendFunc);
            var a = this._node;
            a._texture && a._texture.hasPremultipliedAlpha() ? (a._blendFunc.src = cc.BLEND_SRC, a._blendFunc.dst = cc.BLEND_DST, a.opacityModifyRGB = !0) : (a._blendFunc.src = cc.SRC_ALPHA, a._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA, a.opacityModifyRGB = !1)
        }, a._setTexture = function(a) {
            var b = this._node;
            return b._batchNode && b._batchNode.texture != a ? void cc.log(cc._LogInfos.Sprite_setTexture) : (this._shaderProgram = cc.shaderCache.programForKey(a ? cc.SHADER_POSITION_TEXTURECOLOR : cc.SHADER_POSITION_COLOR), void(b._batchNode || b._texture == a || (b._texture = a, this._updateBlendFunc())))
        }, a.updateTransform = function() {
            var a = this,
                b = this._node;
            if (this._dirty) {
                var c = a._quad,
                    d = b._parent;
                if (!b._visible || d && d != b._batchNode && d._shouldBeHidden) c.br.vertices = c.tl.vertices = c.tr.vertices = c.bl.vertices = {
                    x: 0,
                    y: 0,
                    z: 0
                }, b._shouldBeHidden = !0;
                else {
                    b._shouldBeHidden = !1, 0 !== this._dirtyFlag && (this.updateStatus(), this._dirtyFlag = 0), b._transformToBatch = d && d != b._batchNode ? cc.affineTransformConcat(a.getNodeToParentTransform(), d._transformToBatch) : a.getNodeToParentTransform();
                    var e = b._transformToBatch,
                        f = b._rect,
                        g = b._offsetPosition.x,
                        h = b._offsetPosition.y,
                        i = g + f.width,
                        j = h + f.height,
                        k = e.tx,
                        l = e.ty,
                        m = e.a,
                        n = e.b,
                        o = e.d,
                        p = -e.c,
                        q = g * m - h * p + k,
                        r = g * n + h * o + l,
                        s = i * m - h * p + k,
                        t = i * n + h * o + l,
                        u = i * m - j * p + k,
                        v = i * n + j * o + l,
                        w = g * m - j * p + k,
                        x = g * n + j * o + l,
                        y = b._vertexZ;
                    cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (q = 0 | q, r = 0 | r, s = 0 | s, t = 0 | t, u = 0 | u, v = 0 | v, w = 0 | w, x = 0 | x), c.bl.vertices = {
                        x: q,
                        y: r,
                        z: y
                    }, c.br.vertices = {
                        x: s,
                        y: t,
                        z: y
                    }, c.tl.vertices = {
                        x: w,
                        y: x,
                        z: y
                    }, c.tr.vertices = {
                        x: u,
                        y: v,
                        z: y
                    }
                }
                b.textureAtlas.updateQuad(c, b.atlasIndex), b._recursiveDirty = !1, this._dirty = !1
            }
            b._hasChildren && b._arrayMakeObjectsPerformSelector(b._children, cc.Node._stateCallbackType.updateTransform)
        }, a._checkTextureBoundary = function(a, b, c) {
            if (a && a.url) {
                var d, e;
                c ? (d = b.x + b.height, e = b.y + b.width) : (d = b.x + b.width, e = b.y + b.height), d > a.width && cc.error(cc._LogInfos.RectWidth, a.url), e > a.height && cc.error(cc._LogInfos.RectHeight, a.url)
            }
        }, a.rendering = function(a) {
            var b = this._node;
            if (b._textureLoaded && 0 !== this._displayedOpacity) {
                var c = a || cc._renderContext,
                    d = b._texture;
                if (d ? d._isLoaded && (this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix), cc.glBlendFunc(b._blendFunc.src, b._blendFunc.dst), cc.glBindTexture2DN(0, d), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), c.bindBuffer(c.ARRAY_BUFFER, this._quadWebBuffer), this._quadDirty && (c.bufferData(c.ARRAY_BUFFER, this._quad.arrayBuffer, c.DYNAMIC_DRAW), this._quadDirty = !1), c.vertexAttribPointer(0, 3, c.FLOAT, !1, 24, 0), c.vertexAttribPointer(1, 4, c.UNSIGNED_BYTE, !0, 24, 12), c.vertexAttribPointer(2, 2, c.FLOAT, !1, 24, 16), c.drawArrays(c.TRIANGLE_STRIP, 0, 4)) : (this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix), cc.glBlendFunc(b._blendFunc.src, b._blendFunc.dst), cc.glBindTexture2D(null), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR), c.bindBuffer(c.ARRAY_BUFFER, this._quadWebBuffer), this._quadDirty && (c.bufferData(c.ARRAY_BUFFER, this._quad.arrayBuffer, c.STATIC_DRAW), this._quadDirty = !1), c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, c.FLOAT, !1, 24, 0), c.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, c.UNSIGNED_BYTE, !0, 24, 12), c.drawArrays(c.TRIANGLE_STRIP, 0, 4)), cc.g_NumberOfDraws++, 0 !== cc.SPRITE_DEBUG_DRAW || b._showNode) {
                    if (cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW), cc.current_stack.stack.push(cc.current_stack.top), cc.current_stack.top = this._stackMatrix, 1 === cc.SPRITE_DEBUG_DRAW || b._showNode) {
                        var e = this._quad,
                            f = [cc.p(e.tl.vertices.x, e.tl.vertices.y), cc.p(e.bl.vertices.x, e.bl.vertices.y), cc.p(e.br.vertices.x, e.br.vertices.y), cc.p(e.tr.vertices.x, e.tr.vertices.y)];
                        cc._drawingUtil.drawPoly(f, 4, !0)
                    } else if (2 === cc.SPRITE_DEBUG_DRAW) {
                        var g = b.getTextureRect(),
                            h = b.getOffsetPosition(),
                            i = [cc.p(h.x, h.y), cc.p(h.x + g.width, h.y), cc.p(h.x + g.width, h.y + g.height), cc.p(h.x, h.y + g.height)];
                        cc._drawingUtil.drawPoly(i, 4, !0)
                    }
                    cc.current_stack.top = cc.current_stack.stack.pop()
                }
            }
        }
    }(),
    function() {
        cc.LabelTTF.WebGLRenderCmd = function(a) {
            cc.Sprite.WebGLRenderCmd.call(this, a), cc.LabelTTF.RenderCmd.call(this), this.setShaderProgram(cc.shaderCache.programForKey(cc.LabelTTF._SHADER_PROGRAM))
        };
        var a = cc.LabelTTF.WebGLRenderCmd.prototype = Object.create(cc.Sprite.WebGLRenderCmd.prototype);
        cc.inject(cc.LabelTTF.RenderCmd.prototype, a), a.constructor = cc.LabelTTF.WebGLRenderCmd, a._setColorsString = function() {
            this.setDirtyFlag(cc.Node._dirtyFlags.textDirty);
            var a = this._node,
                b = a._strokeColor,
                c = a._textFillColor;
            this._shadowColorStr = "rgba(128,128,128," + a._shadowOpacity + ")", this._fillColorStr = "rgba(" + (0 | c.r) + "," + (0 | c.g) + "," + (0 | c.b) + ", 1)", this._strokeColorStr = "rgba(" + (0 | b.r) + "," + (0 | b.g) + "," + (0 | b.b) + ", 1)"
        }, a.updateStatus = function() {
            var a = cc.Node._dirtyFlags,
                b = this._dirtyFlag,
                c = b & a.colorDirty,
                d = b & a.opacityDirty;
            c && this._updateDisplayColor(), d && this._updateDisplayOpacity(), c || d ? (this._setColorsString(), this._updateColor(), this._updateTexture()) : b & a.textDirty && this._updateTexture(), this._dirtyFlag & a.transformDirty && (this.transform(this.getParentRenderCmd(), !0), this._dirtyFlag = this._dirtyFlag & cc.Node._dirtyFlags.transformDirty ^ this._dirtyFlag)
        }, a._syncStatus = function(a) {
            var b = cc.Node._dirtyFlags,
                c = this._dirtyFlag,
                d = a ? a._node : null;
            d && d._cascadeColorEnabled && a._dirtyFlag & b.colorDirty && (c |= b.colorDirty), d && d._cascadeOpacityEnabled && a._dirtyFlag & b.opacityDirty && (c |= b.opacityDirty), a && a._dirtyFlag & b.transformDirty && (c |= b.transformDirty);
            var e = c & b.colorDirty,
                f = c & b.opacityDirty;
            this._dirtyFlag = c, e && this._syncDisplayColor(), f && this._syncDisplayOpacity(), e || f ? (this._setColorsString(), this._updateColor(), this._updateTexture()) : c & b.textDirty && this._updateTexture(), this.transform(a)
        }
    }();
var _p = cc.inputManager;
_p.setAccelerometerEnabled = function(a) {
    var b = this;
    if (b._accelEnabled !== a) {
        b._accelEnabled = a;
        var c = cc.director.getScheduler();
        b._accelEnabled ? (b._accelCurTime = 0, c.scheduleUpdateForTarget(b)) : (b._accelCurTime = 0, c.unscheduleUpdateForTarget(b))
    }
}, _p.setAccelerometerInterval = function(a) {
    this._accelInterval !== a && (this._accelInterval = a)
}, _p._registerKeyboardEvent = function() {
    cc._addEventListener(cc._canvas, "keydown", function(a) {
        cc.eventManager.dispatchEvent(new cc.EventKeyboard(a.keyCode, !0)), a.stopPropagation(), a.preventDefault()
    }, !1), cc._addEventListener(cc._canvas, "keyup", function(a) {
        cc.eventManager.dispatchEvent(new cc.EventKeyboard(a.keyCode, !1)), a.stopPropagation(), a.preventDefault()
    }, !1)
}, _p._registerAccelerometerEvent = function() {
    var a = window,
        b = this;
    b._acceleration = new cc.Acceleration, b._accelDeviceEvent = a.DeviceMotionEvent || a.DeviceOrientationEvent, cc.sys.browserType == cc.sys.BROWSER_TYPE_MOBILE_QQ && (b._accelDeviceEvent = window.DeviceOrientationEvent);
    var c = b._accelDeviceEvent == a.DeviceMotionEvent ? "devicemotion" : "deviceorientation",
        d = navigator.userAgent;
    (/Android/.test(d) || /Adr/.test(d) && cc.sys.browserType == cc.BROWSER_TYPE_UC) && (b._minus = -1), cc._addEventListener(a, c, b.didAccelerate.bind(b), !1)
}, _p.didAccelerate = function(a) {
    var b = this,
        c = window;
    if (b._accelEnabled) {
        var d, e, f, g = b._acceleration;
        if (b._accelDeviceEvent == window.DeviceMotionEvent) {
            var h = a.accelerationIncludingGravity;
            d = b._accelMinus * h.x * .1, e = b._accelMinus * h.y * .1, f = .1 * h.z
        } else d = a.gamma / 90 * .981, e = .981 * -(a.beta / 90), f = a.alpha / 90 * .981;
        cc.sys.os === cc.sys.OS_ANDROID ? (g.x = -d, g.y = -e) : (g.x = d, g.y = e), g.z = f, g.timestamp = a.timeStamp || Date.now();
        var i = g.x;
        c.orientation === cc.UIInterfaceOrientationLandscapeRight ? (g.x = -g.y, g.y = i) : c.orientation === cc.UIInterfaceOrientationLandscapeLeft ? (g.x = g.y, g.y = -i) : c.orientation === cc.UIInterfaceOrientationPortraitUpsideDown && (g.x = -g.x, g.y = -g.y)
    }
}, delete _p, cc.vertexLineToPolygon = function(a, b, c, d, e) {
    if (e += d, !(1 >= e)) {
        b *= .5;
        for (var f, g = e - 1, h = d; e > h; h++) {
            f = 2 * h;
            var i, j = cc.p(a[2 * h], a[2 * h + 1]);
            if (0 === h) i = cc.pPerp(cc.pNormalize(cc.pSub(j, cc.p(a[2 * (h + 1)], a[2 * (h + 1) + 1]))));
            else if (h === g) i = cc.pPerp(cc.pNormalize(cc.pSub(cc.p(a[2 * (h - 1)], a[2 * (h - 1) + 1]), j)));
            else {
                var k = cc.p(a[2 * (h - 1)], a[2 * (h - 1) + 1]),
                    l = cc.p(a[2 * (h + 1)], a[2 * (h + 1) + 1]),
                    m = cc.pNormalize(cc.pSub(l, j)),
                    n = cc.pNormalize(cc.pSub(k, j)),
                    o = Math.acos(cc.pDot(m, n));
                i = o < cc.degreesToRadians(70) ? cc.pPerp(cc.pNormalize(cc.pMidpoint(m, n))) : o < cc.degreesToRadians(170) ? cc.pNormalize(cc.pMidpoint(m, n)) : cc.pPerp(cc.pNormalize(cc.pSub(l, k)))
            }
            i = cc.pMult(i, b), c[2 * f] = j.x + i.x, c[2 * f + 1] = j.y + i.y, c[2 * (f + 1)] = j.x - i.x, c[2 * (f + 1) + 1] = j.y - i.y
        }
        for (d = 0 == d ? 0 : d - 1, h = d; g > h; h++) {
            f = 2 * h;
            var p = f + 2,
                q = cc.vertex2(c[2 * f], c[2 * f + 1]),
                r = cc.vertex2(c[2 * (f + 1)], c[2 * (f + 1) + 1]),
                s = cc.vertex2(c[2 * p], c[2 * p]),
                t = cc.vertex2(c[2 * (p + 1)], c[2 * (p + 1) + 1]),
                u = !cc.vertexLineIntersect(q.x, q.y, t.x, t.y, r.x, r.y, s.x, s.y);
            u.isSuccess || (u.value < 0 || u.value > 1) && (u.isSuccess = !0), u.isSuccess && (c[2 * p] = t.x, c[2 * p + 1] = t.y, c[2 * (p + 1)] = s.x, c[2 * (p + 1) + 1] = s.y)
        }
    }
}, cc.vertexLineIntersect = function(a, b, c, d, e, f, g, h) {
    var i, j, k, l;
    if (a == c && b == d || e == g && f == h) return {
        isSuccess: !1,
        value: 0
    };
    if (c -= a, d -= b, e -= a, f -= b, g -= a, h -= b, i = Math.sqrt(c * c + d * d), j = c / i, k = d / i, l = e * j + f * k, f = f * j - e * k, e = l, l = g * j + h * k, h = h * j - g * k, g = l, f == h) return {
        isSuccess: !1,
        value: 0
    };
    var m = (g + (e - g) * h / (h - f)) / i;
    return {
        isSuccess: !0,
        value: m
    }
}, cc.vertexListIsClockwise = function(a) {
    for (var b = 0, c = a.length; c > b; b++) {
        var d = a[b],
            e = a[(b + 1) % c],
            f = a[(b + 2) % c];
        if (cc.pCross(cc.pSub(e, d), cc.pSub(f, e)) > 0) return !1
    }
    return !0
}, cc.CGAffineToGL = function(a, b) {
    b[2] = b[3] = b[6] = b[7] = b[8] = b[9] = b[11] = b[14] = 0, b[10] = b[15] = 1, b[0] = a.a, b[4] = a.c, b[12] = a.tx, b[1] = a.b, b[5] = a.d, b[13] = a.ty
}, cc.GLToCGAffine = function(a, b) {
    b.a = a[0], b.c = a[4], b.tx = a[12], b.b = a[1], b.d = a[5], b.ty = a[13]
}, cc.EventAcceleration = cc.Event.extend({
    _acc: null,
    ctor: function(a) {
        cc.Event.prototype.ctor.call(this, cc.Event.ACCELERATION), this._acc = a
    }
}), cc.EventKeyboard = cc.Event.extend({
    _keyCode: 0,
    _isPressed: !1,
    ctor: function(a, b) {
        cc.Event.prototype.ctor.call(this, cc.Event.KEYBOARD), this._keyCode = a, this._isPressed = b
    }
}), cc._EventListenerAcceleration = cc.EventListener.extend({
    _onAccelerationEvent: null,
    ctor: function(a) {
        this._onAccelerationEvent = a;
        var b = this,
            c = function(a) {
                b._onAccelerationEvent(a._acc, a)
            };
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.ACCELERATION, cc._EventListenerAcceleration.LISTENER_ID, c)
    },
    checkAvailable: function() {
        return cc.assert(this._onAccelerationEvent, cc._LogInfos._EventListenerAcceleration_checkAvailable), !0
    },
    clone: function() {
        return new cc._EventListenerAcceleration(this._onAccelerationEvent)
    }
}), cc._EventListenerAcceleration.LISTENER_ID = "__cc_acceleration", cc._EventListenerAcceleration.create = function(a) {
    return new cc._EventListenerAcceleration(a)
}, cc._EventListenerKeyboard = cc.EventListener.extend({
    onKeyPressed: null,
    onKeyReleased: null,
    ctor: function() {
        var a = this,
            b = function(b) {
                b._isPressed ? a.onKeyPressed && a.onKeyPressed(b._keyCode, b) : a.onKeyReleased && a.onKeyReleased(b._keyCode, b)
            };
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.KEYBOARD, cc._EventListenerKeyboard.LISTENER_ID, b)
    },
    clone: function() {
        var a = new cc._EventListenerKeyboard;
        return a.onKeyPressed = this.onKeyPressed, a.onKeyReleased = this.onKeyReleased, a
    },
    checkAvailable: function() {
        return null == this.onKeyPressed && null == this.onKeyReleased ? (cc.log(cc._LogInfos._EventListenerKeyboard_checkAvailable), !1) : !0
    }
}), cc._EventListenerKeyboard.LISTENER_ID = "__cc_keyboard", cc._EventListenerKeyboard.create = function() {
    return new cc._EventListenerKeyboard
}, cc.AtlasNode = cc.Node.extend({
    textureAtlas: null,
    quadsToDraw: 0,
    _itemsPerRow: 0,
    _itemsPerColumn: 0,
    _itemWidth: 0,
    _itemHeight: 0,
    _opacityModifyRGB: !1,
    _blendFunc: null,
    _ignoreContentScaleFactor: !1,
    _className: "AtlasNode",
    _textureForCanvas: null,
    ctor: function(a, b, c, d) {
        cc.Node.prototype.ctor.call(this), this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        }, this._ignoreContentScaleFactor = !1, void 0 !== d && this.initWithTileFile(a, b, c, d)
    },
    _createRenderCmd: function() {
        this._renderCmd = cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.AtlasNode.CanvasRenderCmd(this) : new cc.AtlasNode.WebGLRenderCmd(this)
    },
    updateAtlasValues: function() {
        cc.log(cc._LogInfos.AtlasNode_updateAtlasValues)
    },
    getColor: function() {
        return this._opacityModifyRGB ? this._renderCmd._colorUnmodified : cc.Node.prototype.getColor.call(this)
    },
    setOpacityModifyRGB: function(a) {
        var b = this.color;
        this._opacityModifyRGB = a, this.setColor(b)
    },
    isOpacityModifyRGB: function() {
        return this._opacityModifyRGB
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    setBlendFunc: function(a, b) {
        this._blendFunc = void 0 === b ? a : {
            src: a,
            dst: b
        }
    },
    setTextureAtlas: function(a) {
        this.textureAtlas = a
    },
    getTextureAtlas: function() {
        return this.textureAtlas
    },
    getQuadsToDraw: function() {
        return this.quadsToDraw
    },
    setQuadsToDraw: function(a) {
        this.quadsToDraw = a
    },
    initWithTileFile: function(a, b, c, d) {
        if (!a) throw "cc.AtlasNode.initWithTileFile(): title should not be null";
        var e = cc.textureCache.addImage(a);
        return this.initWithTexture(e, b, c, d)
    },
    initWithTexture: function(a, b, c, d) {
        return this._renderCmd.initWithTexture(a, b, c, d)
    },
    setColor: function(a) {
        this._renderCmd.setColor(a)
    },
    setOpacity: function(a) {
        this._renderCmd.setOpacity(a)
    },
    getTexture: function() {
        return this._renderCmd.getTexture()
    },
    setTexture: function(a) {
        this._renderCmd.setTexture(a)
    },
    _setIgnoreContentScaleFactor: function(a) {
        this._ignoreContentScaleFactor = a
    }
});
var _p = cc.AtlasNode.prototype;
cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity), cc.defineGetterSetter(_p, "color", _p.getColor, _p.setColor), _p.texture, cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture), _p.textureAtlas, _p.quadsToDraw, cc.EventHelper.prototype.apply(_p), cc.AtlasNode.create = function(a, b, c, d) {
        return new cc.AtlasNode(a, b, c, d)
    },
    function() {
        cc.AtlasNode.CanvasRenderCmd = function(a) {
            cc.Node.CanvasRenderCmd.call(this, a), this._needDraw = !1, this._colorUnmodified = cc.color.WHITE, this._originalTexture = null, this._texture = null
        };
        var a = cc.AtlasNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
        a.constructor = cc.AtlasNode.CanvasRenderCmd, a.initWithTexture = function(a, b, c, d) {
            var e = this._node;
            return e._itemWidth = b, e._itemHeight = c, e._opacityModifyRGB = !0, this._originalTexture = a, this._originalTexture ? (this._texture = this._originalTexture, this._calculateMaxItems(), e.quadsToDraw = d, !0) : (cc.log(cc._LogInfos.AtlasNode__initWithTexture), !1)
        }, a.setColor = function(a) {
            var b = this._node,
                c = b._realColor;
            (c.r != a.r || c.g != a.g || c.b != a.b) && (this._colorUnmodified = a, this._changeTextureColor())
        }, a._changeTextureColor = cc.sys._supportCanvasNewBlendModes ? function() {
            var a = this._node,
                b = a.getTexture();
            if (b && this._originalTexture) {
                var c = this._originalTexture.getHtmlElementObj();
                if (!c) return;
                var d = b.getHtmlElementObj(),
                    e = cc.rect(0, 0, c.width, c.height);
                d instanceof HTMLCanvasElement ? cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply(c, this._colorUnmodified, e, d) : (d = cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply(c, this._colorUnmodified, e), b = new cc.Texture2D, b.initWithElement(d), b.handleLoadedTexture(), a.setTexture(b))
            }
        } : function() {
            var a, b = this._node,
                c = b.getTexture();
            if (c && this._originalTexture) {
                if (a = c.getHtmlElementObj(), !a) return;
                var d = this._originalTexture.getHtmlElementObj(),
                    e = cc.textureCache.getTextureColors(d);
                if (e) {
                    var f = cc.rect(0, 0, d.width, d.height);
                    a instanceof HTMLCanvasElement ? cc.Sprite.CanvasRenderCmd._generateTintImage(a, e, this._displayedColor, f, a) : (a = cc.Sprite.CanvasRenderCmd._generateTintImage(a, e, this._displayedColor, f), c = new cc.Texture2D, c.initWithElement(a), c.handleLoadedTexture(), b.setTexture(c))
                }
            }
        }, a.setOpacity = function(a) {
            var b = this._node;
            cc.Node.prototype.setOpacity.call(b, a)
        }, a.getTexture = function() {
            return this._texture
        }, a.setTexture = function(a) {
            this._texture = a
        }, a._calculateMaxItems = function() {
            var a = this._node,
                b = this._texture,
                c = b.getContentSize();
            a._itemsPerColumn = 0 | c.height / a._itemHeight, a._itemsPerRow = 0 | c.width / a._itemWidth
        }
    }(), cc.TextureAtlas = cc.Class.extend({
        dirty: !1,
        texture: null,
        _indices: null,
        _buffersVBO: null,
        _capacity: 0,
        _quads: null,
        _quadsArrayBuffer: null,
        _quadsWebBuffer: null,
        _quadsReader: null,
        ctor: function(a, b) {
            this._buffersVBO = [], cc.isString(a) ? this.initWithFile(a, b) : a instanceof cc.Texture2D && this.initWithTexture(a, b)
        },
        getTotalQuads: function() {
            return this._totalQuads
        },
        getCapacity: function() {
            return this._capacity
        },
        getTexture: function() {
            return this.texture
        },
        setTexture: function(a) {
            this.texture = a
        },
        setDirty: function(a) {
            this.dirty = a
        },
        isDirty: function() {
            return this.dirty
        },
        getQuads: function() {
            return this._quads
        },
        setQuads: function(a) {
            this._quads = a
        },
        _copyQuadsToTextureAtlas: function(a, b) {
            if (a)
                for (var c = 0; c < a.length; c++) this._setQuadToArray(a[c], b + c)
        },
        _setQuadToArray: function(a, b) {
            var c = this._quads;
            return c[b] ? (c[b].bl = a.bl, c[b].br = a.br, c[b].tl = a.tl, void(c[b].tr = a.tr)) : void(c[b] = new cc.V3F_C4B_T2F_Quad(a.tl, a.bl, a.tr, a.br, this._quadsArrayBuffer, b * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT))
        },
        description: function() {
            return "<cc.TextureAtlas | totalQuads =" + this._totalQuads + ">"
        },
        _setupIndices: function() {
            if (0 !== this._capacity)
                for (var a = this._indices, b = this._capacity, c = 0; b > c; c++) cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP ? (a[6 * c + 0] = 4 * c + 0, a[6 * c + 1] = 4 * c + 0, a[6 * c + 2] = 4 * c + 2, a[6 * c + 3] = 4 * c + 1, a[6 * c + 4] = 4 * c + 3, a[6 * c + 5] = 4 * c + 3) : (a[6 * c + 0] = 4 * c + 0, a[6 * c + 1] = 4 * c + 1, a[6 * c + 2] = 4 * c + 2, a[6 * c + 3] = 4 * c + 3, a[6 * c + 4] = 4 * c + 2, a[6 * c + 5] = 4 * c + 1)
        },
        _setupVBO: function() {
            var a = cc._renderContext;
            this._buffersVBO[0] = a.createBuffer(), this._buffersVBO[1] = a.createBuffer(), this._quadsWebBuffer = a.createBuffer(), this._mapBuffers()
        },
        _mapBuffers: function() {
            var a = cc._renderContext;
            a.bindBuffer(a.ARRAY_BUFFER, this._quadsWebBuffer), a.bufferData(a.ARRAY_BUFFER, this._quadsArrayBuffer, a.DYNAMIC_DRAW), a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]), a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indices, a.STATIC_DRAW)
        },
        initWithFile: function(a, b) {
            var c = cc.textureCache.addImage(a);
            return c ? this.initWithTexture(c, b) : (cc.log(cc._LogInfos.TextureAtlas_initWithFile, a), !1)
        },
        initWithTexture: function(a, b) {
            cc.assert(a, cc._LogInfos.TextureAtlas_initWithTexture), b = 0 | b, this._capacity = b, this._totalQuads = 0, this.texture = a, this._quads = [], this._indices = new Uint16Array(6 * b);
            var c = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
            if (this._quadsArrayBuffer = new ArrayBuffer(c * b), this._quadsReader = new Uint8Array(this._quadsArrayBuffer), (!this._quads || !this._indices) && b > 0) return !1;
            for (var d = this._quads, e = 0; b > e; e++) d[e] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, e * c);
            return this._setupIndices(), this._setupVBO(), this.dirty = !0, !0
        },
        updateQuad: function(a, b) {
            cc.assert(a, cc._LogInfos.TextureAtlas_updateQuad), cc.assert(b >= 0 && b < this._capacity, cc._LogInfos.TextureAtlas_updateQuad_2), this._totalQuads = Math.max(b + 1, this._totalQuads), this._setQuadToArray(a, b), this.dirty = !0
        },
        insertQuad: function(a, b) {
            if (cc.assert(b < this._capacity, cc._LogInfos.TextureAtlas_insertQuad_2), this._totalQuads++, this._totalQuads > this._capacity) return void cc.log(cc._LogInfos.TextureAtlas_insertQuad);
            var c = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
                d = this._totalQuads - 1 - b,
                e = b * c,
                f = d * c;
            this._quads[this._totalQuads - 1] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, (this._totalQuads - 1) * c), this._quadsReader.set(this._quadsReader.subarray(e, e + f), e + c), this._setQuadToArray(a, b), this.dirty = !0
        },
        insertQuads: function(a, b, c) {
            c = c || a.length, cc.assert(b + c <= this._capacity, cc._LogInfos.TextureAtlas_insertQuads);
            var d = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
            if (this._totalQuads += c, this._totalQuads > this._capacity) return void cc.log(cc._LogInfos.TextureAtlas_insertQuad);
            var e, f = this._totalQuads - 1 - b - c,
                g = b * d,
                h = f * d,
                i = this._totalQuads - 1 - c;
            for (e = 0; c > e; e++) this._quads[i + e] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, (this._totalQuads - 1) * d);
            for (this._quadsReader.set(this._quadsReader.subarray(g, g + h), g + d * c), e = 0; c > e; e++) this._setQuadToArray(a[e], b + e);
            this.dirty = !0
        },
        insertQuadFromIndex: function(a, b) {
            if (a !== b) {
                cc.assert(b >= 0 || b < this._totalQuads, cc._LogInfos.TextureAtlas_insertQuadFromIndex), cc.assert(a >= 0 || a < this._totalQuads, cc._LogInfos.TextureAtlas_insertQuadFromIndex_2);
                var c, d, e = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
                    f = this._quadsReader,
                    g = f.subarray(a * e, e);
                a > b ? (c = b * e, d = (a - b) * e, f.set(f.subarray(c, c + d), c + e), f.set(g, c)) : (c = (a + 1) * e, d = (b - a) * e, f.set(f.subarray(c, c + d), c - e), f.set(g, b * e)), this.dirty = !0
            }
        },
        removeQuadAtIndex: function(a) {
            cc.assert(a < this._totalQuads, cc._LogInfos.TextureAtlas_removeQuadAtIndex);
            var b = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
            if (this._totalQuads--, this._quads.length = this._totalQuads, a !== this._totalQuads) {
                var c = (a + 1) * b,
                    d = (this._totalQuads - a) * b;
                this._quadsReader.set(this._quadsReader.subarray(c, c + d), c - b)
            }
            this.dirty = !0
        },
        removeQuadsAtIndex: function(a, b) {
            if (cc.assert(a + b <= this._totalQuads, cc._LogInfos.TextureAtlas_removeQuadsAtIndex), this._totalQuads -= b, a !== this._totalQuads) {
                var c = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
                    d = (a + b) * c,
                    e = (this._totalQuads - a) * c,
                    f = a * c;
                this._quadsReader.set(this._quadsReader.subarray(d, d + e), f)
            }
            this.dirty = !0
        },
        removeAllQuads: function() {
            this._quads.length = 0, this._totalQuads = 0
        },
        _setDirty: function(a) {
            this.dirty = a
        },
        resizeCapacity: function(a) {
            if (a == this._capacity) return !0;
            var b = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
                c = this._capacity;
            this._totalQuads = Math.min(this._totalQuads, a), this._capacity = 0 | a;
            var d, e = this._capacity,
                f = this._totalQuads;
            if (null == this._quads)
                for (this._quads = [], this._quadsArrayBuffer = new ArrayBuffer(b * e), this._quadsReader = new Uint8Array(this._quadsArrayBuffer), d = 0; e > d; d++) this._quads = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, d * b);
            else {
                var g, h, i = this._quads;
                if (e > c) {
                    for (g = [], h = new ArrayBuffer(b * e), d = 0; f > d; d++) g[d] = new cc.V3F_C4B_T2F_Quad(i[d].tl, i[d].bl, i[d].tr, i[d].br, h, d * b);
                    for (; e > d; d++) g[d] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, h, d * b);
                    this._quadsReader = new Uint8Array(h), this._quads = g, this._quadsArrayBuffer = h
                } else {
                    var j = Math.max(f, e);
                    for (g = [], h = new ArrayBuffer(b * e), d = 0; j > d; d++) g[d] = new cc.V3F_C4B_T2F_Quad(i[d].tl, i[d].bl, i[d].tr, i[d].br, h, d * b);
                    this._quadsReader = new Uint8Array(h), this._quads = g, this._quadsArrayBuffer = h
                }
            } if (null == this._indices) this._indices = new Uint16Array(6 * e);
            else if (e > c) {
                var k = new Uint16Array(6 * e);
                k.set(this._indices, 0), this._indices = k
            } else this._indices = this._indices.subarray(0, 6 * e);
            return this._setupIndices(), this._mapBuffers(), this.dirty = !0, !0
        },
        increaseTotalQuadsWith: function(a) {
            this._totalQuads += a
        },
        moveQuadsFromIndex: function(a, b, c) {
            if (void 0 === c) {
                if (c = b, b = this._totalQuads - a, cc.assert(c + (this._totalQuads - a) <= this._capacity, cc._LogInfos.TextureAtlas_moveQuadsFromIndex), 0 === b) return
            } else if (cc.assert(c + b <= this._totalQuads, cc._LogInfos.TextureAtlas_moveQuadsFromIndex_2), cc.assert(a < this._totalQuads, cc._LogInfos.TextureAtlas_moveQuadsFromIndex_3), a == c) return;
            var d, e, f = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
                g = a * f,
                h = b * f,
                i = this._quadsReader,
                j = i.subarray(g, g + h),
                k = c * f;
            a > c ? (d = (a - c) * f, e = c * f, i.set(i.subarray(e, e + d), e + h)) : (d = (c - a) * f, e = (a + b) * f, i.set(i.subarray(e, e + d), g)), i.set(j, k), this.dirty = !0
        },
        fillWithEmptyQuadsFromIndex: function(a, b) {
            for (var c = b * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, d = new Uint8Array(this._quadsArrayBuffer, a * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, c), e = 0; c > e; e++) d[e] = 0
        },
        drawQuads: function() {
            this.drawNumberOfQuads(this._totalQuads, 0)
        },
        _releaseBuffer: function() {
            var a = cc._renderContext;
            this._buffersVBO && (this._buffersVBO[0] && a.deleteBuffer(this._buffersVBO[0]), this._buffersVBO[1] && a.deleteBuffer(this._buffersVBO[1])), this._quadsWebBuffer && a.deleteBuffer(this._quadsWebBuffer)
        }
    });
var _p = cc.TextureAtlas.prototype;
_p.totalQuads, cc.defineGetterSetter(_p, "totalQuads", _p.getTotalQuads), _p.capacity, cc.defineGetterSetter(_p, "capacity", _p.getCapacity), _p.quads, cc.defineGetterSetter(_p, "quads", _p.getQuads, _p.setQuads), cc.TextureAtlas.create = function(a, b) {
    return new cc.TextureAtlas(a, b)
}, cc.TextureAtlas.createWithTexture = cc.TextureAtlas.create, cc._renderType === cc._RENDER_TYPE_WEBGL && (cc.assert(cc.isFunction(cc._tmp.WebGLTextureAtlas), cc._LogInfos.MissingFile, "TexturesWebGL.js"), cc._tmp.WebGLTextureAtlas(), delete cc._tmp.WebGLTextureAtlas), cc.assert(cc.isFunction(cc._tmp.PrototypeTextureAtlas), cc._LogInfos.MissingFile, "TexturesPropertyDefine.js"), cc._tmp.PrototypeTextureAtlas(), delete cc._tmp.PrototypeTextureAtlas, cc.Camera = cc.Class.extend({
    _eyeX: null,
    _eyeY: null,
    _eyeZ: null,
    _centerX: null,
    _centerY: null,
    _centerZ: null,
    _upX: null,
    _upY: null,
    _upZ: null,
    _dirty: !1,
    _lookupMatrix: null,
    ctor: function() {
        this._lookupMatrix = new cc.kmMat4, this.restore()
    },
    description: function() {
        return "<CCCamera | center =(" + this._centerX + "," + this._centerY + "," + this._centerZ + ")>"
    },
    setDirty: function(a) {
        this._dirty = a
    },
    isDirty: function() {
        return this._dirty
    },
    restore: function() {
        this._eyeX = this._eyeY = 0, this._eyeZ = cc.Camera.getZEye(), this._centerX = this._centerY = this._centerZ = 0, this._upX = 0, this._upY = 1, this._upZ = 0, cc.kmMat4Identity(this._lookupMatrix), this._dirty = !1
    },
    locate: function() {
        if (this._dirty) {
            var a = new cc.kmVec3,
                b = new cc.kmVec3,
                c = new cc.kmVec3;
            cc.kmVec3Fill(a, this._eyeX, this._eyeY, this._eyeZ), cc.kmVec3Fill(b, this._centerX, this._centerY, this._centerZ), cc.kmVec3Fill(c, this._upX, this._upY, this._upZ), cc.kmMat4LookAt(this._lookupMatrix, a, b, c), this._dirty = !1
        }
        cc.kmGLMultMatrix(this._lookupMatrix)
    },
    _locateForRenderer: function(a) {
        if (this._dirty) {
            var b = new cc.kmVec3,
                c = new cc.kmVec3,
                d = new cc.kmVec3;
            cc.kmVec3Fill(b, this._eyeX, this._eyeY, this._eyeZ), cc.kmVec3Fill(c, this._centerX, this._centerY, this._centerZ), cc.kmVec3Fill(d, this._upX, this._upY, this._upZ), cc.kmMat4LookAt(this._lookupMatrix, b, c, d), this._dirty = !1
        }
        cc.kmMat4Multiply(a, a, this._lookupMatrix)
    },
    setEyeXYZ: function(a, b, c) {
        this.setEye(a, b, c)
    },
    setEye: function(a, b, c) {
        this._eyeX = a, this._eyeY = b, this._eyeZ = c, this._dirty = !0
    },
    setCenterXYZ: function(a, b, c) {
        this.setCenter(a, b, c)
    },
    setCenter: function(a, b, c) {
        this._centerX = a, this._centerY = b, this._centerZ = c, this._dirty = !0
    },
    setUpXYZ: function(a, b, c) {
        this.setUp(a, b, c)
    },
    setUp: function(a, b, c) {
        this._upX = a, this._upY = b, this._upZ = c, this._dirty = !0
    },
    getEyeXYZ: function() {
        return {
            x: this._eyeX,
            y: this._eyeY,
            z: this._eyeZ
        }
    },
    getEye: function() {
        return {
            x: this._eyeX,
            y: this._eyeY,
            z: this._eyeZ
        }
    },
    getCenterXYZ: function() {
        return {
            x: this._centerX,
            y: this._centerY,
            z: this._centerZ
        }
    },
    getCenter: function() {
        return {
            x: this._centerX,
            y: this._centerY,
            z: this._centerZ
        }
    },
    getUpXYZ: function() {
        return {
            x: this._upX,
            y: this._upY,
            z: this._upZ
        }
    },
    getUp: function() {
        return {
            x: this._upX,
            y: this._upY,
            z: this._upZ
        }
    },
    _DISALLOW_COPY_AND_ASSIGN: function() {}
}), cc.Camera.getZEye = function() {
    return cc.FLT_EPSILON
}, cc.PI2 = 2 * Math.PI, cc.DrawingPrimitiveCanvas = cc.Class.extend({
    _cacheArray: [],
    _renderContext: null,
    ctor: function(a) {
        this._renderContext = a
    },
    drawPoint: function(a, b) {
        b || (b = 1);
        var c = cc.view.getScaleX(),
            d = cc.view.getScaleY(),
            e = cc.p(a.x * c, a.y * d),
            f = this._renderContext.getContext();
        f.beginPath(), f.arc(e.x, -e.y, b * c, 0, 2 * Math.PI, !1), f.closePath(), f.fill()
    },
    drawPoints: function(a, b, c) {
        if (null != a) {
            c || (c = 1);
            var d = this._renderContext.getContext(),
                e = cc.view.getScaleX(),
                f = cc.view.getScaleY();
            d.beginPath();
            for (var g = 0, h = a.length; h > g; g++) d.arc(a[g].x * e, -a[g].y * f, c * e, 0, 2 * Math.PI, !1);
            d.closePath(), d.fill()
        }
    },
    drawLine: function(a, b) {
        var c = this._renderContext.getContext(),
            d = cc.view.getScaleX(),
            e = cc.view.getScaleY();
        c.beginPath(), c.moveTo(a.x * d, -a.y * e), c.lineTo(b.x * d, -b.y * e), c.closePath(), c.stroke()
    },
    drawRect: function(a, b) {
        this.drawLine(cc.p(a.x, a.y), cc.p(b.x, a.y)), this.drawLine(cc.p(b.x, a.y), cc.p(b.x, b.y)), this.drawLine(cc.p(b.x, b.y), cc.p(a.x, b.y)), this.drawLine(cc.p(a.x, b.y), cc.p(a.x, a.y))
    },
    drawSolidRect: function(a, b, c) {
        var d = [a, cc.p(b.x, a.y), b, cc.p(a.x, b.y)];
        this.drawSolidPoly(d, 4, c)
    },
    drawPoly: function(a, b, c, d) {
        if (d = d || !1, null != a) {
            if (a.length < 3) throw new Error("Polygon's point must greater than 2");
            var e = a[0],
                f = this._renderContext.getContext(),
                g = cc.view.getScaleX(),
                h = cc.view.getScaleY();
            f.beginPath(), f.moveTo(e.x * g, -e.y * h);
            for (var i = 1, j = a.length; j > i; i++) f.lineTo(a[i].x * g, -a[i].y * h);
            c && f.closePath(), d ? f.fill() : f.stroke()
        }
    },
    drawSolidPoly: function(a, b, c) {
        this.setDrawColor(c.r, c.g, c.b, c.a), this.drawPoly(a, b, !0, !0)
    },
    drawCircle: function(a, b, c, d, e) {
        e = e || !1;
        var f = this._renderContext.getContext(),
            g = cc.view.getScaleX(),
            h = cc.view.getScaleY();
        f.beginPath();
        var i = c - 2 * Math.PI;
        f.arc(0 | a.x * g, 0 | -(a.y * h), b * g, -c, -i, !1), e && f.lineTo(0 | a.x * g, 0 | -(a.y * h)), f.stroke()
    },
    drawQuadBezier: function(a, b, c, d) {
        var e = this._cacheArray;
        e.length = 0;
        for (var f = 0, g = 0; d > g; g++) {
            var h = Math.pow(1 - f, 2) * a.x + 2 * (1 - f) * f * b.x + f * f * c.x,
                i = Math.pow(1 - f, 2) * a.y + 2 * (1 - f) * f * b.y + f * f * c.y;
            e.push(cc.p(h, i)), f += 1 / d
        }
        e.push(cc.p(c.x, c.y)), this.drawPoly(e, d + 1, !1, !1)
    },
    drawCubicBezier: function(a, b, c, d, e) {
        var f = this._cacheArray;
        f.length = 0;
        for (var g = 0, h = 0; e > h; h++) {
            var i = Math.pow(1 - g, 3) * a.x + 3 * Math.pow(1 - g, 2) * g * b.x + 3 * (1 - g) * g * g * c.x + g * g * g * d.x,
                j = Math.pow(1 - g, 3) * a.y + 3 * Math.pow(1 - g, 2) * g * b.y + 3 * (1 - g) * g * g * c.y + g * g * g * d.y;
            f.push(cc.p(i, j)), g += 1 / e
        }
        f.push(cc.p(d.x, d.y)), this.drawPoly(f, e + 1, !1, !1)
    },
    drawCatmullRom: function(a, b) {
        this.drawCardinalSpline(a, .5, b)
    },
    drawCardinalSpline: function(a, b, c) {
        cc._renderContext.setStrokeStyle("rgba(255,255,255,1)");
        var d = this._cacheArray;
        d.length = 0;
        for (var e, f, g = 1 / a.length, h = 0; c + 1 > h; h++) {
            var i = h / c;
            1 == i ? (e = a.length - 1, f = 1) : (e = 0 | i / g, f = (i - g * e) / g);
            var j = cc.CardinalSplineAt(cc.getControlPointAt(a, e - 1), cc.getControlPointAt(a, e - 0), cc.getControlPointAt(a, e + 1), cc.getControlPointAt(a, e + 2), b, f);
            d.push(j)
        }
        this.drawPoly(d, c + 1, !1, !1)
    },
    drawImage: function(a, b, c, d, e) {
        var f = arguments.length,
            g = this._renderContext.getContext();
        switch (f) {
            case 2:
                var h = a.height;
                g.drawImage(a, b.x, -(b.y + h));
                break;
            case 3:
                g.drawImage(a, b.x, -(b.y + c.height), c.width, c.height);
                break;
            case 5:
                g.drawImage(a, b.x, b.y, c.width, c.height, d.x, -(d.y + e.height), e.width, e.height);
                break;
            default:
                throw new Error("Argument must be non-nil")
        }
    },
    drawStar: function(a, b, c) {
        var d = a || this._renderContext,
            e = d.getContext();
        b *= cc.view.getScaleX();
        var f = "rgba(" + (0 | c.r) + "," + (0 | c.g) + "," + (0 | c.b);
        d.setFillStyle(f + ",1)");
        var g = b / 10;
        e.beginPath(), e.moveTo(-b, b), e.lineTo(0, g), e.lineTo(b, b), e.lineTo(g, 0), e.lineTo(b, -b), e.lineTo(0, -g), e.lineTo(-b, -b), e.lineTo(-g, 0), e.lineTo(-b, b), e.closePath(), e.fill();
        var h = e.createRadialGradient(0, 0, g, 0, 0, b);
        h.addColorStop(0, f + ", 1)"), h.addColorStop(.3, f + ", 0.8)"), h.addColorStop(1, f + ", 0.0)"), d.setFillStyle(h), e.beginPath();
        var i = 0,
            j = cc.PI2;
        e.arc(0, 0, b - g, i, j, !1), e.closePath(), e.fill()
    },
    drawColorBall: function(a, b, c) {
        var d = a || this._renderContext,
            e = d.getContext();
        b *= cc.view.getScaleX();
        var f = "rgba(" + (0 | c.r) + "," + (0 | c.g) + "," + (0 | c.b),
            g = b / 10,
            h = e.createRadialGradient(0, 0, g, 0, 0, b);
        h.addColorStop(0, f + ", 1)"), h.addColorStop(.3, f + ", 0.8)"), h.addColorStop(.6, f + ", 0.4)"), h.addColorStop(1, f + ", 0.0)"), d.setFillStyle(h), e.beginPath();
        var i = 0,
            j = cc.PI2;
        e.arc(0, 0, b, i, j, !1), e.closePath(), e.fill()
    },
    fillText: function(a, b, c) {
        this._renderContext.getContext().fillText(a, b, -c)
    },
    setDrawColor: function(a, b, c, d) {
        this._renderContext.setFillStyle("rgba(" + a + "," + b + "," + c + "," + d / 255 + ")"), this._renderContext.setStrokeStyle("rgba(" + a + "," + b + "," + c + "," + d / 255 + ")")
    },
    setPointSize: function() {},
    setLineWidth: function(a) {
        this._renderContext.getContext().lineWidth = a * cc.view.getScaleX()
    }
});
! function() {
    cc.AtlasNode.WebGLRenderCmd = function(a) {
        cc.Node.WebGLRenderCmd.call(this, a), this._needDraw = !0, this._textureAtlas = null, this._colorUnmodified = cc.color.WHITE, this._colorF32Array = null, this._uniformColor = null
    };
    var a = cc.AtlasNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    a.constructor = cc.AtlasNode.WebGLRenderCmd, a._updateBlendFunc = function() {
        var a = this._node;
        this._textureAtlas.texture.hasPremultipliedAlpha() || (a._blendFunc.src = cc.SRC_ALPHA, a._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA)
    }, a._updateOpacityModifyRGB = function() {
        this._node._opacityModifyRGB = this._textureAtlas.texture.hasPremultipliedAlpha()
    }, a.rendering = function(a) {
        var b = a || cc._renderContext,
            c = this._node;
        this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix), cc.glBlendFunc(c._blendFunc.src, c._blendFunc.dst), this._uniformColor && this._colorF32Array && (b.uniform4fv(this._uniformColor, this._colorF32Array), this._textureAtlas.drawNumberOfQuads(c.quadsToDraw, 0))
    }, a.initWithTexture = function(a, b, c, d) {
        var e = this._node;
        e._itemWidth = b, e._itemHeight = c, this._colorUnmodified = cc.color.WHITE, e._opacityModifyRGB = !0, e._blendFunc.src = cc.BLEND_SRC, e._blendFunc.dst = cc.BLEND_DST;
        var f = e._realColor;
        return this._colorF32Array = new Float32Array([f.r / 255, f.g / 255, f.b / 255, e._realOpacity / 255]), this._textureAtlas = new cc.TextureAtlas, this._textureAtlas.initWithTexture(a, d), this._textureAtlas ? (this._updateBlendFunc(), this._updateOpacityModifyRGB(), this._calculateMaxItems(), e.quadsToDraw = d, this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE_UCOLOR), this._uniformColor = cc._renderContext.getUniformLocation(e.shaderProgram.getProgram(), "u_color"), !0) : (cc.log(cc._LogInfos.AtlasNode__initWithTexture), !1)
    }, a.setColor = function(a) {
        var b = cc.color(a.r, a.g, a.b),
            c = this._node;
        this._colorUnmodified = a;
        var d = this._displayedOpacity;
        c._opacityModifyRGB && (b.r = b.r * d / 255, b.g = b.g * d / 255, b.b = b.b * d / 255), cc.Node.prototype.setColor.call(c, b)
    }, a.setOpacity = function(a) {
        var b = this._node;
        cc.Node.prototype.setOpacity.call(b, a), b._opacityModifyRGB && (b.color = this._colorUnmodified)
    }, a._updateColor = function() {
        var a = this._displayedColor;
        this._colorF32Array = new Float32Array([a.r / 255, a.g / 255, a.b / 255, this._displayedOpacity / 255])
    }, a.getTexture = function() {
        return this._textureAtlas.texture
    }, a.setTexture = function(a) {
        this._textureAtlas.texture = a, this._updateBlendFunc(), this._updateOpacityModifyRGB()
    }, a._calculateMaxItems = function() {
        var a = this._node,
            b = this._textureAtlas.texture,
            c = b.getContentSize();
        a._ignoreContentScaleFactor && (c = b.getContentSizeInPixels()), a._itemsPerColumn = 0 | c.height / a._itemHeight, a._itemsPerRow = 0 | c.width / a._itemWidth
    }
}(), cc.DrawingPrimitiveWebGL = cc.Class.extend({
    _renderContext: null,
    _initialized: !1,
    _shader: null,
    _colorLocation: -1,
    _colorArray: null,
    _pointSizeLocation: -1,
    _pointSize: -1,
    ctor: function(a) {
        if (null == a && (a = cc._renderContext), !a instanceof WebGLRenderingContext) throw "Can't initialise DrawingPrimitiveWebGL. context need is WebGLRenderingContext";
        this._renderContext = a, this._colorArray = new Float32Array([1, 1, 1, 1])
    },
    lazy_init: function() {
        var a = this;
        a._initialized || (a._shader = cc.shaderCache.programForKey(cc.SHADER_POSITION_UCOLOR), a._colorLocation = a._renderContext.getUniformLocation(a._shader.getProgram(), "u_color"), a._pointSizeLocation = a._renderContext.getUniformLocation(a._shader.getProgram(), "u_pointSize"), a._initialized = !0)
    },
    drawInit: function() {
        this._initialized = !1
    },
    drawPoint: function(a) {
        this.lazy_init();
        var b = this._renderContext;
        this._shader.use(), this._shader.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION), b.uniform4fv(this._colorLocation, this._colorArray), this._shader.setUniformLocationWith1f(this._pointSizeLocation, this._pointSize);
        var c = b.createBuffer();
        b.bindBuffer(b.ARRAY_BUFFER, c), b.bufferData(b.ARRAY_BUFFER, new Float32Array([a.x, a.y]), b.STATIC_DRAW), b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, b.FLOAT, !1, 0, 0), b.drawArrays(b.POINTS, 0, 1), b.deleteBuffer(c), cc.incrementGLDraws(1)
    },
    drawPoints: function(a) {
        if (a && 0 != a.length) {
            this.lazy_init();
            var b = this._renderContext;
            this._shader.use(), this._shader.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION), b.uniform4fv(this._colorLocation, this._colorArray), this._shader.setUniformLocationWith1f(this._pointSizeLocation, this._pointSize);
            var c = b.createBuffer();
            b.bindBuffer(b.ARRAY_BUFFER, c), b.bufferData(b.ARRAY_BUFFER, this._pointsToTypeArray(a), b.STATIC_DRAW), b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, b.FLOAT, !1, 0, 0), b.drawArrays(b.POINTS, 0, a.length), b.deleteBuffer(c), cc.incrementGLDraws(1)
        }
    },
    _pointsToTypeArray: function(a) {
        for (var b = new Float32Array(2 * a.length), c = 0; c < a.length; c++) b[2 * c] = a[c].x, b[2 * c + 1] = a[c].y;
        return b
    },
    drawLine: function(a, b) {
        this.lazy_init();
        var c = this._renderContext;
        this._shader.use(), this._shader.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION), c.uniform4fv(this._colorLocation, this._colorArray);
        var d = c.createBuffer();
        c.bindBuffer(c.ARRAY_BUFFER, d), c.bufferData(c.ARRAY_BUFFER, this._pointsToTypeArray([a, b]), c.STATIC_DRAW), c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, c.FLOAT, !1, 0, 0), c.drawArrays(c.LINES, 0, 2), c.deleteBuffer(d), cc.incrementGLDraws(1)
    },
    drawRect: function(a, b) {
        this.drawLine(cc.p(a.x, a.y), cc.p(b.x, a.y)), this.drawLine(cc.p(b.x, a.y), cc.p(b.x, b.y)), this.drawLine(cc.p(b.x, b.y), cc.p(a.x, b.y)), this.drawLine(cc.p(a.x, b.y), cc.p(a.x, a.y))
    },
    drawSolidRect: function(a, b, c) {
        var d = [a, cc.p(b.x, a.y), b, cc.p(a.x, b.y)];
        this.drawSolidPoly(d, 4, c)
    },
    drawPoly: function(a, b, c) {
        this.lazy_init();
        var d = this._renderContext;
        this._shader.use(), this._shader.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION), d.uniform4fv(this._colorLocation, this._colorArray);
        var e = d.createBuffer();
        d.bindBuffer(d.ARRAY_BUFFER, e), d.bufferData(d.ARRAY_BUFFER, this._pointsToTypeArray(a), d.STATIC_DRAW), d.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, d.FLOAT, !1, 0, 0), c ? d.drawArrays(d.LINE_LOOP, 0, a.length) : d.drawArrays(d.LINE_STRIP, 0, a.length), d.deleteBuffer(e), cc.incrementGLDraws(1)
    },
    drawSolidPoly: function(a, b, c) {
        this.lazy_init(), c && this.setDrawColor(c.r, c.g, c.b, c.a);
        var d = this._renderContext;
        this._shader.use(), this._shader.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION), d.uniform4fv(this._colorLocation, this._colorArray);
        var e = d.createBuffer();
        d.bindBuffer(d.ARRAY_BUFFER, e), d.bufferData(d.ARRAY_BUFFER, this._pointsToTypeArray(a), d.STATIC_DRAW), d.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, d.FLOAT, !1, 0, 0), d.drawArrays(d.TRIANGLE_FAN, 0, a.length), d.deleteBuffer(e), cc.incrementGLDraws(1)
    },
    drawCircle: function(a, b, c, d, e) {
        this.lazy_init();
        var f = 1;
        e && f++;
        var g = 2 * Math.PI / d,
            h = new Float32Array(2 * (d + 2));
        if (h) {
            for (var i = 0; d >= i; i++) {
                var j = i * g,
                    k = b * Math.cos(j + c) + a.x,
                    l = b * Math.sin(j + c) + a.y;
                h[2 * i] = k, h[2 * i + 1] = l
            }
            h[2 * (d + 1)] = a.x, h[2 * (d + 1) + 1] = a.y;
            var m = this._renderContext;
            this._shader.use(), this._shader.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION), m.uniform4fv(this._colorLocation, this._colorArray);
            var n = m.createBuffer();
            m.bindBuffer(m.ARRAY_BUFFER, n), m.bufferData(m.ARRAY_BUFFER, h, m.STATIC_DRAW), m.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, m.FLOAT, !1, 0, 0), m.drawArrays(m.LINE_STRIP, 0, d + f), m.deleteBuffer(n), cc.incrementGLDraws(1)
        }
    },
    drawQuadBezier: function(a, b, c, d) {
        this.lazy_init();
        for (var e = new Float32Array(2 * (d + 1)), f = 0, g = 0; d > g; g++) e[2 * g] = Math.pow(1 - f, 2) * a.x + 2 * (1 - f) * f * b.x + f * f * c.x, e[2 * g + 1] = Math.pow(1 - f, 2) * a.y + 2 * (1 - f) * f * b.y + f * f * c.y, f += 1 / d;
        e[2 * d] = c.x, e[2 * d + 1] = c.y;
        var h = this._renderContext;
        this._shader.use(), this._shader.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION), h.uniform4fv(this._colorLocation, this._colorArray);
        var i = h.createBuffer();
        h.bindBuffer(h.ARRAY_BUFFER, i), h.bufferData(h.ARRAY_BUFFER, e, h.STATIC_DRAW), h.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, h.FLOAT, !1, 0, 0), h.drawArrays(h.LINE_STRIP, 0, d + 1), h.deleteBuffer(i), cc.incrementGLDraws(1)
    },
    drawCubicBezier: function(a, b, c, d, e) {
        this.lazy_init();
        for (var f = new Float32Array(2 * (e + 1)), g = 0, h = 0; e > h; h++) f[2 * h] = Math.pow(1 - g, 3) * a.x + 3 * Math.pow(1 - g, 2) * g * b.x + 3 * (1 - g) * g * g * c.x + g * g * g * d.x, f[2 * h + 1] = Math.pow(1 - g, 3) * a.y + 3 * Math.pow(1 - g, 2) * g * b.y + 3 * (1 - g) * g * g * c.y + g * g * g * d.y, g += 1 / e;
        f[2 * e] = d.x, f[2 * e + 1] = d.y;
        var i = this._renderContext;
        this._shader.use(), this._shader.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION), i.uniform4fv(this._colorLocation, this._colorArray);
        var j = i.createBuffer();
        i.bindBuffer(i.ARRAY_BUFFER, j), i.bufferData(i.ARRAY_BUFFER, f, i.STATIC_DRAW), i.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, i.FLOAT, !1, 0, 0), i.drawArrays(i.LINE_STRIP, 0, e + 1), i.deleteBuffer(j), cc.incrementGLDraws(1)
    },
    drawCatmullRom: function(a, b) {
        this.drawCardinalSpline(a, .5, b)
    },
    drawCardinalSpline: function(a, b, c) {
        this.lazy_init();
        for (var d, e, f = new Float32Array(2 * (c + 1)), g = 1 / a.length, h = 0; c + 1 > h; h++) {
            var i = h / c;
            1 == i ? (d = a.length - 1, e = 1) : (d = 0 | i / g, e = (i - g * d) / g);
            var j = cc.CardinalSplineAt(cc.getControlPointAt(a, d - 1), cc.getControlPointAt(a, d), cc.getControlPointAt(a, d + 1), cc.getControlPointAt(a, d + 2), b, e);
            f[2 * h] = j.x, f[2 * h + 1] = j.y
        }
        var k = this._renderContext;
        this._shader.use(), this._shader.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION), k.uniform4fv(this._colorLocation, this._colorArray);
        var l = k.createBuffer();
        k.bindBuffer(k.ARRAY_BUFFER, l), k.bufferData(k.ARRAY_BUFFER, f, k.STATIC_DRAW), k.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, k.FLOAT, !1, 0, 0), k.drawArrays(k.LINE_STRIP, 0, c + 1), k.deleteBuffer(l), cc.incrementGLDraws(1)
    },
    setDrawColor: function(a, b, c, d) {
        this._colorArray[0] = a / 255, this._colorArray[1] = b / 255, this._colorArray[2] = c / 255, this._colorArray[3] = d / 255
    },
    setPointSize: function(a) {
        this._pointSize = a * cc.contentScaleFactor()
    },
    setLineWidth: function(a) {
        this._renderContext.lineWidth && this._renderContext.lineWidth(a)
    }
});
cc._LogInfos = {
    ActionManager_addAction: "cc.ActionManager.addAction(): action must be non-null",
    ActionManager_removeAction: "cocos2d: removeAction: Target not found",
    ActionManager_removeActionByTag: "cc.ActionManager.removeActionByTag(): an invalid tag",
    ActionManager_removeActionByTag_2: "cc.ActionManager.removeActionByTag(): target must be non-null",
    ActionManager_getActionByTag: "cc.ActionManager.getActionByTag(): an invalid tag",
    ActionManager_getActionByTag_2: "cocos2d : getActionByTag(tag = %s): Action not found",
    configuration_dumpInfo: "cocos2d: **** WARNING **** CC_ENABLE_PROFILERS is defined. Disable it when you finish profiling (from ccConfig.js)",
    configuration_loadConfigFile: "Expected 'data' dict, but not found. Config file: %s",
    configuration_loadConfigFile_2: "Please load the resource first : %s",
    Director_resume: "cocos2d: Director: Error in gettimeofday",
    Director_setProjection: "cocos2d: Director: unrecognized projection",
    Director_popToSceneStackLevel: "cocos2d: Director: unrecognized projection",
    Director_popToSceneStackLevel_2: "cocos2d: Director: Error in gettimeofday",
    Director_popScene: "running scene should not null",
    Director_pushScene: "the scene should not null",
    arrayVerifyType: "element type is wrong!",
    Scheduler_scheduleCallbackForTarget: "CCSheduler#scheduleCallback. Callback already scheduled. Updating interval from:%s to %s",
    Scheduler_scheduleCallbackForTarget_2: "cc.scheduler.scheduleCallbackForTarget(): callback_fn should be non-null.",
    Scheduler_scheduleCallbackForTarget_3: "cc.scheduler.scheduleCallbackForTarget(): target should be non-null.",
    Scheduler_pauseTarget: "cc.Scheduler.pauseTarget():target should be non-null",
    Scheduler_resumeTarget: "cc.Scheduler.resumeTarget():target should be non-null",
    Scheduler_isTargetPaused: "cc.Scheduler.isTargetPaused():target should be non-null",
    Node_getZOrder: "getZOrder is deprecated. Please use getLocalZOrder instead.",
    Node_setZOrder: "setZOrder is deprecated. Please use setLocalZOrder instead.",
    Node_getRotation: "RotationX != RotationY. Don't know which one to return",
    Node_getScale: "ScaleX != ScaleY. Don't know which one to return",
    Node_addChild: "An Node can't be added as a child of itself.",
    Node_addChild_2: "child already added. It can't be added again",
    Node_addChild_3: "child must be non-null",
    Node_removeFromParentAndCleanup: "removeFromParentAndCleanup is deprecated. Use removeFromParent instead",
    Node_boundingBox: "boundingBox is deprecated. Use getBoundingBox instead",
    Node_removeChildByTag: "argument tag is an invalid tag",
    Node_removeChildByTag_2: "cocos2d: removeChildByTag(tag = %s): child not found!",
    Node_removeAllChildrenWithCleanup: "removeAllChildrenWithCleanup is deprecated. Use removeAllChildren instead",
    Node_stopActionByTag: "cc.Node.stopActionBy(): argument tag an invalid tag",
    Node_getActionByTag: "cc.Node.getActionByTag(): argument tag is an invalid tag",
    Node_resumeSchedulerAndActions: "resumeSchedulerAndActions is deprecated, please use resume instead.",
    Node_pauseSchedulerAndActions: "pauseSchedulerAndActions is deprecated, please use pause instead.",
    Node__arrayMakeObjectsPerformSelector: "Unknown callback function",
    Node_reorderChild: "child must be non-null",
    Node_runAction: "cc.Node.runAction(): action must be non-null",
    Node_schedule: "callback function must be non-null",
    Node_schedule_2: "interval must be positive",
    Node_initWithTexture: "cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.",
    AtlasNode_updateAtlasValues: "cc.AtlasNode.updateAtlasValues(): Shall be overridden in subclasses",
    AtlasNode_initWithTileFile: "",
    AtlasNode__initWithTexture: "cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.",
    _EventListenerKeyboard_checkAvailable: "cc._EventListenerKeyboard.checkAvailable(): Invalid EventListenerKeyboard!",
    _EventListenerTouchOneByOne_checkAvailable: "cc._EventListenerTouchOneByOne.checkAvailable(): Invalid EventListenerTouchOneByOne!",
    _EventListenerTouchAllAtOnce_checkAvailable: "cc._EventListenerTouchAllAtOnce.checkAvailable(): Invalid EventListenerTouchAllAtOnce!",
    _EventListenerAcceleration_checkAvailable: "cc._EventListenerAcceleration.checkAvailable(): _onAccelerationEvent must be non-nil",
    EventListener_create: "Invalid parameter.",
    __getListenerID: "Don't call this method if the event is for touch.",
    eventManager__forceAddEventListener: "Invalid scene graph priority!",
    eventManager_addListener: "0 priority is forbidden for fixed priority since it's used for scene graph based priority.",
    eventManager_removeListeners: "Invalid listener type!",
    eventManager_setPriority: "Can't set fixed priority with scene graph based listener.",
    eventManager_addListener_2: "Invalid parameters.",
    eventManager_addListener_3: "listener must be a cc.EventListener object when adding a fixed priority listener",
    eventManager_addListener_4: "The listener has been registered, please don't register it again.",
    LayerMultiplex_initWithLayers: "parameters should not be ending with null in Javascript",
    LayerMultiplex_switchTo: "Invalid index in MultiplexLayer switchTo message",
    LayerMultiplex_switchToAndReleaseMe: "Invalid index in MultiplexLayer switchTo message",
    LayerMultiplex_addLayer: "cc.Layer.addLayer(): layer should be non-null",
    EGLView_setDesignResolutionSize: "Resolution not valid",
    EGLView_setDesignResolutionSize_2: "should set resolutionPolicy",
    inputManager_handleTouchesBegin: "The touches is more than MAX_TOUCHES, nUnusedIndex = %s",
    swap: "cc.swap is being modified from original macro, please check usage",
    checkGLErrorDebug: "WebGL error %s",
    animationCache__addAnimationsWithDictionary: "cocos2d: cc.AnimationCache: No animations were found in provided dictionary.",
    animationCache__addAnimationsWithDictionary_2: "cc.AnimationCache. Invalid animation format",
    animationCache_addAnimations: "cc.AnimationCache.addAnimations(): File could not be found",
    animationCache__parseVersion1: "cocos2d: cc.AnimationCache: Animation '%s' found in dictionary without any frames - cannot add to animation cache.",
    animationCache__parseVersion1_2: "cocos2d: cc.AnimationCache: Animation '%s' refers to frame '%s' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.",
    animationCache__parseVersion1_3: "cocos2d: cc.AnimationCache: None of the frames for animation '%s' were found in the cc.SpriteFrameCache. Animation is not being added to the Animation Cache.",
    animationCache__parseVersion1_4: "cocos2d: cc.AnimationCache: An animation in your dictionary refers to a frame which is not in the cc.SpriteFrameCache. Some or all of the frames for the animation '%s' may be missing.",
    animationCache__parseVersion2: "cocos2d: CCAnimationCache: Animation '%s' found in dictionary without any frames - cannot add to animation cache.",
    animationCache__parseVersion2_2: "cocos2d: cc.AnimationCache: Animation '%s' refers to frame '%s' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.",
    animationCache_addAnimations_2: "cc.AnimationCache.addAnimations(): Invalid texture file name",
    Sprite_reorderChild: "cc.Sprite.reorderChild(): this child is not in children list",
    Sprite_ignoreAnchorPointForPosition: "cc.Sprite.ignoreAnchorPointForPosition(): it is invalid in cc.Sprite when using SpriteBatchNode",
    Sprite_setDisplayFrameWithAnimationName: "cc.Sprite.setDisplayFrameWithAnimationName(): Frame not found",
    Sprite_setDisplayFrameWithAnimationName_2: "cc.Sprite.setDisplayFrameWithAnimationName(): Invalid frame index",
    Sprite_setDisplayFrame: "setDisplayFrame is deprecated, please use setSpriteFrame instead.",
    Sprite__updateBlendFunc: "cc.Sprite._updateBlendFunc(): _updateBlendFunc doesn't work when the sprite is rendered using a cc.CCSpriteBatchNode",
    Sprite_initWithSpriteFrame: "cc.Sprite.initWithSpriteFrame(): spriteFrame should be non-null",
    Sprite_initWithSpriteFrameName: "cc.Sprite.initWithSpriteFrameName(): spriteFrameName should be non-null",
    Sprite_initWithSpriteFrameName1: " is null, please check.",
    Sprite_initWithFile: "cc.Sprite.initWithFile(): filename should be non-null",
    Sprite_setDisplayFrameWithAnimationName_3: "cc.Sprite.setDisplayFrameWithAnimationName(): animationName must be non-null",
    Sprite_reorderChild_2: "cc.Sprite.reorderChild(): child should be non-null",
    Sprite_addChild: "cc.Sprite.addChild(): cc.Sprite only supports cc.Sprites as children when using cc.SpriteBatchNode",
    Sprite_addChild_2: "cc.Sprite.addChild(): cc.Sprite only supports a sprite using same texture as children when using cc.SpriteBatchNode",
    Sprite_addChild_3: "cc.Sprite.addChild(): child should be non-null",
    Sprite_setTexture: "cc.Sprite.texture setter: Batched sprites should use the same texture as the batchnode",
    Sprite_updateQuadFromSprite: "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    Sprite_insertQuadFromSprite: "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    Sprite_addChild_4: "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children",
    Sprite_addChild_5: "cc.SpriteBatchNode.addChild(): cc.Sprite is not using the same texture",
    Sprite_initWithTexture: "Sprite.initWithTexture(): Argument must be non-nil ",
    Sprite_setSpriteFrame: "Invalid spriteFrameName",
    Sprite_setTexture_2: "Invalid argument: cc.Sprite.texture setter expects a CCTexture2D.",
    Sprite_updateQuadFromSprite_2: "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
    Sprite_insertQuadFromSprite_2: "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null",
    SpriteBatchNode_addSpriteWithoutQuad: "cc.SpriteBatchNode.addQuadFromSprite(): SpriteBatchNode only supports cc.Sprites as children",
    SpriteBatchNode_increaseAtlasCapacity: "cocos2d: CCSpriteBatchNode: resizing TextureAtlas capacity from %s to %s.",
    SpriteBatchNode_increaseAtlasCapacity_2: "cocos2d: WARNING: Not enough memory to resize the atlas",
    SpriteBatchNode_reorderChild: "cc.SpriteBatchNode.addChild(): Child doesn't belong to Sprite",
    SpriteBatchNode_removeChild: "cc.SpriteBatchNode.addChild(): sprite batch node should contain the child",
    SpriteBatchNode_addSpriteWithoutQuad_2: "cc.SpriteBatchNode.addQuadFromSprite(): child should be non-null",
    SpriteBatchNode_reorderChild_2: "cc.SpriteBatchNode.addChild(): child should be non-null",
    spriteFrameCache__getFrameConfig: "cocos2d: WARNING: originalWidth/Height not found on the cc.SpriteFrame. AnchorPoint won't work as expected. Regenrate the .plist",
    spriteFrameCache_addSpriteFrames: "cocos2d: WARNING: an alias with name %s already exists",
    spriteFrameCache__checkConflict: "cocos2d: WARNING: Sprite frame: %s has already been added by another source, please fix name conflit",
    spriteFrameCache_getSpriteFrame: "cocos2d: cc.SpriteFrameCahce: Frame %s not found",
    spriteFrameCache__getFrameConfig_2: "Please load the resource first : %s",
    spriteFrameCache_addSpriteFrames_2: "cc.SpriteFrameCache.addSpriteFrames(): plist should be non-null",
    spriteFrameCache_addSpriteFrames_3: "Argument must be non-nil",
    CCSpriteBatchNode_updateQuadFromSprite: "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    CCSpriteBatchNode_insertQuadFromSprite: "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    CCSpriteBatchNode_addChild: "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children",
    CCSpriteBatchNode_initWithTexture: "Sprite.initWithTexture(): Argument must be non-nil ",
    CCSpriteBatchNode_addChild_2: "cc.Sprite.addChild(): child should be non-null",
    CCSpriteBatchNode_setSpriteFrame: "Invalid spriteFrameName",
    CCSpriteBatchNode_setTexture: "Invalid argument: cc.Sprite texture setter expects a CCTexture2D.",
    CCSpriteBatchNode_updateQuadFromSprite_2: "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
    CCSpriteBatchNode_insertQuadFromSprite_2: "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null",
    CCSpriteBatchNode_addChild_3: "cc.SpriteBatchNode.addChild(): child should be non-null",
    TextureAtlas_initWithFile: "cocos2d: Could not open file: %s",
    TextureAtlas_insertQuad: "cc.TextureAtlas.insertQuad(): invalid totalQuads",
    TextureAtlas_initWithTexture: "cc.TextureAtlas.initWithTexture():texture should be non-null",
    TextureAtlas_updateQuad: "cc.TextureAtlas.updateQuad(): quad should be non-null",
    TextureAtlas_updateQuad_2: "cc.TextureAtlas.updateQuad(): Invalid index",
    TextureAtlas_insertQuad_2: "cc.TextureAtlas.insertQuad(): Invalid index",
    TextureAtlas_insertQuads: "cc.TextureAtlas.insertQuad(): Invalid index + amount",
    TextureAtlas_insertQuadFromIndex: "cc.TextureAtlas.insertQuadFromIndex(): Invalid newIndex",
    TextureAtlas_insertQuadFromIndex_2: "cc.TextureAtlas.insertQuadFromIndex(): Invalid fromIndex",
    TextureAtlas_removeQuadAtIndex: "cc.TextureAtlas.removeQuadAtIndex(): Invalid index",
    TextureAtlas_removeQuadsAtIndex: "cc.TextureAtlas.removeQuadsAtIndex(): index + amount out of bounds",
    TextureAtlas_moveQuadsFromIndex: "cc.TextureAtlas.moveQuadsFromIndex(): move is out of bounds",
    TextureAtlas_moveQuadsFromIndex_2: "cc.TextureAtlas.moveQuadsFromIndex(): Invalid newIndex",
    TextureAtlas_moveQuadsFromIndex_3: "cc.TextureAtlas.moveQuadsFromIndex(): Invalid oldIndex",
    textureCache_addPVRTCImage: "TextureCache:addPVRTCImage does not support on HTML5",
    textureCache_addETCImage: "TextureCache:addPVRTCImage does not support on HTML5",
    textureCache_textureForKey: "textureForKey is deprecated. Please use getTextureForKey instead.",
    textureCache_addPVRImage: "addPVRImage does not support on HTML5",
    textureCache_addUIImage: "cocos2d: Couldn't add UIImage in TextureCache",
    textureCache_dumpCachedTextureInfo: "cocos2d: '%s' id=%s %s x %s",
    textureCache_dumpCachedTextureInfo_2: "cocos2d: '%s' id= HTMLCanvasElement %s x %s",
    textureCache_dumpCachedTextureInfo_3: "cocos2d: TextureCache dumpDebugInfo: %s textures, HTMLCanvasElement for %s KB (%s MB)",
    textureCache_addUIImage_2: "cc.Texture.addUIImage(): image should be non-null",
    Texture2D_initWithETCFile: "initWithETCFile does not support on HTML5",
    Texture2D_initWithPVRFile: "initWithPVRFile does not support on HTML5",
    Texture2D_initWithPVRTCData: "initWithPVRTCData does not support on HTML5",
    Texture2D_addImage: "cc.Texture.addImage(): path should be non-null",
    Texture2D_initWithImage: "cocos2d: cc.Texture2D. Can't create Texture. UIImage is nil",
    Texture2D_initWithImage_2: "cocos2d: WARNING: Image (%s x %s) is bigger than the supported %s x %s",
    Texture2D_initWithString: "initWithString isn't supported on cocos2d-html5",
    Texture2D_initWithETCFile_2: "initWithETCFile does not support on HTML5",
    Texture2D_initWithPVRFile_2: "initWithPVRFile does not support on HTML5",
    Texture2D_initWithPVRTCData_2: "initWithPVRTCData does not support on HTML5",
    Texture2D_bitsPerPixelForFormat: "bitsPerPixelForFormat: %s, cannot give useful result, it's a illegal pixel format",
    Texture2D__initPremultipliedATextureWithImage: "cocos2d: cc.Texture2D: Using RGB565 texture since image has no alpha",
    Texture2D_addImage_2: "cc.Texture.addImage(): path should be non-null",
    Texture2D_initWithData: "NSInternalInconsistencyException",
    MissingFile: "Missing file: %s",
    radiansToDegress: "cc.radiansToDegress() should be called cc.radiansToDegrees()",
    RectWidth: "Rect width exceeds maximum margin: %s",
    RectHeight: "Rect height exceeds maximum margin: %s",
    EventManager__updateListeners: "If program goes here, there should be event in dispatch.",
    EventManager__updateListeners_2: "_inDispatch should be 1 here."
}, cc._logToWebPage = function(a) {
    if (cc._canvas) {
        var b = cc._logList,
            c = document;
        if (!b) {
            var d = c.createElement("Div"),
                e = d.style;
            d.setAttribute("id", "logInfoDiv"), cc._canvas.parentNode.appendChild(d), d.setAttribute("width", "200"), d.setAttribute("height", cc._canvas.height), e.zIndex = "99999", e.position = "absolute", e.top = "0", e.left = "0", b = cc._logList = c.createElement("textarea");
            var f = b.style;
            b.setAttribute("rows", "20"), b.setAttribute("cols", "30"), b.setAttribute("disabled", !0), d.appendChild(b), f.backgroundColor = "transparent", f.borderBottom = "1px solid #cccccc", f.borderRightWidth = "0px", f.borderLeftWidth = "0px", f.borderTopWidth = "0px", f.borderTopStyle = "none", f.borderRightStyle = "none", f.borderLeftStyle = "none", f.padding = "0px", f.margin = 0
        }
        b.value = b.value + a + "\r\n", b.scrollTop = b.scrollHeight
    }
}, cc._formatString = function(a) {
    if (!cc.isObject(a)) return a;
    try {
        return JSON.stringify(a)
    } catch (b) {
        return ""
    }
}, cc._initDebugSetting = function(a) {
    var b = cc.game;
    if (a != b.DEBUG_MODE_NONE) {
        var c;
        a > b.DEBUG_MODE_ERROR ? (c = cc._logToWebPage.bind(cc), cc.error = function() {
            c("ERROR :  " + cc.formatStr.apply(cc, arguments))
        }, cc.assert = function(a, b) {
            if (!a && b) {
                for (var d = 2; d < arguments.length; d++) b = b.replace(/(%s)|(%d)/, cc._formatString(arguments[d]));
                c("Assert: " + b)
            }
        }, a != b.DEBUG_MODE_ERROR_FOR_WEB_PAGE && (cc.warn = function() {
            c("WARN :  " + cc.formatStr.apply(cc, arguments))
        }), a == b.DEBUG_MODE_INFO_FOR_WEB_PAGE && (cc.log = function() {
            c(cc.formatStr.apply(cc, arguments))
        })) : console && console.log.apply && (cc.error = function() {
            return console.error.apply(console, arguments)
        }, cc.assert = function(a, b) {
            if (!a && b) {
                for (var c = 2; c < arguments.length; c++) b = b.replace(/(%s)|(%d)/, cc._formatString(arguments[c]));
                throw b
            }
        }, a != b.DEBUG_MODE_ERROR && (cc.warn = function() {
            return console.warn.apply(console, arguments)
        }), a == b.DEBUG_MODE_INFO && (cc.log = function() {
            return console.log.apply(console, arguments)
        }))
    }
}, cc._initDebugSetting(cc.game.config[cc.game.CONFIG_KEY.debugMode]);
cc.HashElement = cc.Class.extend({
    actions: null,
    target: null,
    actionIndex: 0,
    currentAction: null,
    currentActionSalvaged: !1,
    paused: !1,
    hh: null,
    ctor: function() {
        this.actions = [], this.target = null, this.actionIndex = 0, this.currentAction = null, this.currentActionSalvaged = !1, this.paused = !1, this.hh = null
    }
}), cc.ActionManager = cc.Class.extend({
    _hashTargets: null,
    _arrayTargets: null,
    _currentTarget: null,
    _currentTargetSalvaged: !1,
    _searchElementByTarget: function(a, b) {
        for (var c = 0; c < a.length; c++)
            if (b == a[c].target) return a[c];
        return null
    },
    ctor: function() {
        this._hashTargets = {}, this._arrayTargets = [], this._currentTarget = null, this._currentTargetSalvaged = !1
    },
    addAction: function(a, b, c) {
        if (!a) throw "cc.ActionManager.addAction(): action must be non-null";
        if (!b) throw "cc.ActionManager.addAction(): action must be non-null";
        var d = this._hashTargets[b.__instanceId];
        d || (d = new cc.HashElement, d.paused = c, d.target = b, this._hashTargets[b.__instanceId] = d, this._arrayTargets.push(d)), this._actionAllocWithHashElement(d), d.actions.push(a), a.startWithTarget(b)
    },
    removeAllActions: function() {
        for (var a = this._arrayTargets, b = 0; b < a.length; b++) {
            var c = a[b];
            c && this.removeAllActionsFromTarget(c.target, !0)
        }
    },
    removeAllActionsFromTarget: function(a, b) {
        if (null != a) {
            var c = this._hashTargets[a.__instanceId];
            c && (-1 === c.actions.indexOf(c.currentAction) || c.currentActionSalvaged || (c.currentActionSalvaged = !0), c.actions.length = 0, this._currentTarget != c || b ? this._deleteHashElement(c) : this._currentTargetSalvaged = !0)
        }
    },
    removeAction: function(a) {
        if (null != a) {
            var b = a.getOriginalTarget(),
                c = this._hashTargets[b.__instanceId];
            if (c) {
                for (var d = 0; d < c.actions.length; d++)
                    if (c.actions[d] == a) {
                        c.actions.splice(d, 1);
                        break
                    }
            } else cc.log(cc._LogInfos.ActionManager_removeAction)
        }
    },
    removeActionByTag: function(a, b) {
        a == cc.ACTION_TAG_INVALID && cc.log(cc._LogInfos.ActionManager_addAction), cc.assert(b, cc._LogInfos.ActionManager_addAction);
        var c = this._hashTargets[b.__instanceId];
        if (c)
            for (var d = c.actions.length, e = 0; d > e; ++e) {
                var f = c.actions[e];
                if (f && f.getTag() === a && f.getOriginalTarget() == b) {
                    this._removeActionAtIndex(e, c);
                    break
                }
            }
    },
    getActionByTag: function(a, b) {
        a == cc.ACTION_TAG_INVALID && cc.log(cc._LogInfos.ActionManager_getActionByTag);
        var c = this._hashTargets[b.__instanceId];
        if (c) {
            if (null != c.actions)
                for (var d = 0; d < c.actions.length; ++d) {
                    var e = c.actions[d];
                    if (e && e.getTag() === a) return e
                }
            cc.log(cc._LogInfos.ActionManager_getActionByTag_2, a)
        }
        return null
    },
    numberOfRunningActionsInTarget: function(a) {
        var b = this._hashTargets[a.__instanceId];
        return b && b.actions ? b.actions.length : 0
    },
    pauseTarget: function(a) {
        var b = this._hashTargets[a.__instanceId];
        b && (b.paused = !0)
    },
    resumeTarget: function(a) {
        var b = this._hashTargets[a.__instanceId];
        b && (b.paused = !1)
    },
    pauseAllRunningActions: function() {
        for (var a = [], b = this._arrayTargets, c = 0; c < b.length; c++) {
            var d = b[c];
            d && !d.paused && (d.paused = !0, a.push(d.target))
        }
        return a
    },
    resumeTargets: function(a) {
        if (a)
            for (var b = 0; b < a.length; b++) a[b] && this.resumeTarget(a[b])
    },
    purgeSharedManager: function() {
        cc.director.getScheduler().unscheduleUpdateForTarget(this)
    },
    _removeActionAtIndex: function(a, b) {
        var c = b.actions[a];
        c != b.currentAction || b.currentActionSalvaged || (b.currentActionSalvaged = !0), b.actions.splice(a, 1), b.actionIndex >= a && b.actionIndex--, 0 == b.actions.length && (this._currentTarget == b ? this._currentTargetSalvaged = !0 : this._deleteHashElement(b))
    },
    _deleteHashElement: function(a) {
        a && (delete this._hashTargets[a.target.__instanceId], cc.arrayRemoveObject(this._arrayTargets, a), a.actions = null, a.target = null)
    },
    _actionAllocWithHashElement: function(a) {
        null == a.actions && (a.actions = [])
    },
    update: function(a) {
        for (var b, c = this._arrayTargets, d = 0; d < c.length; d++) {
            if (this._currentTarget = c[d], b = this._currentTarget, !b.paused)
                for (b.actionIndex = 0; b.actionIndex < b.actions.length; b.actionIndex++)
                    if (b.currentAction = b.actions[b.actionIndex], b.currentAction) {
                        if (b.currentActionSalvaged = !1, b.currentAction.step(a * (b.currentAction._speedMethod ? b.currentAction._speed : 1)), b.currentActionSalvaged) b.currentAction = null;
                        else if (b.currentAction.isDone()) {
                            b.currentAction.stop();
                            var e = b.currentAction;
                            b.currentAction = null, this.removeAction(e)
                        }
                        b.currentAction = null
                    }
            this._currentTargetSalvaged && 0 === b.actions.length && this._deleteHashElement(b)
        }
    }
}), cc.ACTION_TAG_INVALID = -1, cc.Action = cc.Class.extend({
    originalTarget: null,
    target: null,
    tag: cc.ACTION_TAG_INVALID,
    ctor: function() {
        this.originalTarget = null, this.target = null, this.tag = cc.ACTION_TAG_INVALID
    },
    copy: function() {
        return cc.log("copy is deprecated. Please use clone instead."), this.clone()
    },
    clone: function() {
        var a = new cc.Action;
        return a.originalTarget = null, a.target = null, a.tag = this.tag, a
    },
    isDone: function() {
        return !0
    },
    startWithTarget: function(a) {
        this.originalTarget = a, this.target = a
    },
    stop: function() {
        this.target = null
    },
    step: function() {
        cc.log("[Action step]. override me")
    },
    update: function() {
        cc.log("[Action update]. override me")
    },
    getTarget: function() {
        return this.target
    },
    setTarget: function(a) {
        this.target = a
    },
    getOriginalTarget: function() {
        return this.originalTarget
    },
    setOriginalTarget: function(a) {
        this.originalTarget = a
    },
    getTag: function() {
        return this.tag
    },
    setTag: function(a) {
        this.tag = a
    },
    retain: function() {},
    release: function() {}
}), cc.action = function() {
    return new cc.Action
}, cc.Action.create = cc.action, cc.FiniteTimeAction = cc.Action.extend({
    _duration: 0,
    ctor: function() {
        cc.Action.prototype.ctor.call(this), this._duration = 0
    },
    getDuration: function() {
        return this._duration * (this._times || 1)
    },
    setDuration: function(a) {
        this._duration = a
    },
    reverse: function() {
        return cc.log("cocos2d: FiniteTimeAction#reverse: Implement me"), null
    },
    clone: function() {
        return new cc.FiniteTimeAction
    }
}), cc.Speed = cc.Action.extend({
    _speed: 0,
    _innerAction: null,
    ctor: function(a, b) {
        cc.Action.prototype.ctor.call(this), this._speed = 0, this._innerAction = null, a && this.initWithAction(a, b)
    },
    getSpeed: function() {
        return this._speed
    },
    setSpeed: function(a) {
        this._speed = a
    },
    initWithAction: function(a, b) {
        if (!a) throw "cc.Speed.initWithAction(): action must be non nil";
        return this._innerAction = a, this._speed = b, !0
    },
    clone: function() {
        var a = new cc.Speed;
        return a.initWithAction(this._innerAction.clone(), this._speed), a
    },
    startWithTarget: function(a) {
        cc.Action.prototype.startWithTarget.call(this, a), this._innerAction.startWithTarget(a)
    },
    stop: function() {
        this._innerAction.stop(), cc.Action.prototype.stop.call(this)
    },
    step: function(a) {
        this._innerAction.step(a * this._speed)
    },
    isDone: function() {
        return this._innerAction.isDone()
    },
    reverse: function() {
        return new cc.Speed(this._innerAction.reverse(), this._speed)
    },
    setInnerAction: function(a) {
        this._innerAction != a && (this._innerAction = a)
    },
    getInnerAction: function() {
        return this._innerAction
    }
}), cc.speed = function(a, b) {
    return new cc.Speed(a, b)
}, cc.Speed.create = cc.speed, cc.Follow = cc.Action.extend({
    _followedNode: null,
    _boundarySet: !1,
    _boundaryFullyCovered: !1,
    _halfScreenSize: null,
    _fullScreenSize: null,
    _worldRect: null,
    leftBoundary: 0,
    rightBoundary: 0,
    topBoundary: 0,
    bottomBoundary: 0,
    ctor: function(a, b) {
        cc.Action.prototype.ctor.call(this), this._followedNode = null, this._boundarySet = !1, this._boundaryFullyCovered = !1, this._halfScreenSize = null, this._fullScreenSize = null, this.leftBoundary = 0, this.rightBoundary = 0, this.topBoundary = 0, this.bottomBoundary = 0, this._worldRect = cc.rect(0, 0, 0, 0), a && (b ? this.initWithTarget(a, b) : this.initWithTarget(a))
    },
    clone: function() {
        var a = new cc.Follow,
            b = this._worldRect,
            c = new cc.Rect(b.x, b.y, b.width, b.height);
        return a.initWithTarget(this._followedNode, c), a
    },
    isBoundarySet: function() {
        return this._boundarySet
    },
    setBoudarySet: function(a) {
        this._boundarySet = a
    },
    initWithTarget: function(a, b) {
        if (!a) throw "cc.Follow.initWithAction(): followedNode must be non nil";
        var c = this;
        b = b || cc.rect(0, 0, 0, 0), c._followedNode = a, c._worldRect = b, c._boundarySet = !cc._rectEqualToZero(b), c._boundaryFullyCovered = !1;
        var d = cc.director.getWinSize();
        return c._fullScreenSize = cc.p(d.width, d.height), c._halfScreenSize = cc.pMult(c._fullScreenSize, .5), c._boundarySet && (c.leftBoundary = -(b.x + b.width - c._fullScreenSize.x), c.rightBoundary = -b.x, c.topBoundary = -b.y, c.bottomBoundary = -(b.y + b.height - c._fullScreenSize.y), c.rightBoundary < c.leftBoundary && (c.rightBoundary = c.leftBoundary = (c.leftBoundary + c.rightBoundary) / 2), c.topBoundary < c.bottomBoundary && (c.topBoundary = c.bottomBoundary = (c.topBoundary + c.bottomBoundary) / 2), c.topBoundary == c.bottomBoundary && c.leftBoundary == c.rightBoundary && (c._boundaryFullyCovered = !0)), !0
    },
    step: function() {
        var a = this._followedNode.x,
            b = this._followedNode.y;
        if (a = this._halfScreenSize.x - a, b = this._halfScreenSize.y - b, this.target._renderCmd._dirtyFlag = 0, this._boundarySet) {
            if (this._boundaryFullyCovered) return;
            this.target.setPosition(cc.clampf(a, this.leftBoundary, this.rightBoundary), cc.clampf(b, this.bottomBoundary, this.topBoundary))
        } else this.target.setPosition(a, b)
    },
    isDone: function() {
        return !this._followedNode.running
    },
    stop: function() {
        this.target = null, cc.Action.prototype.stop.call(this)
    }
}), cc.follow = function(a, b) {
    return new cc.Follow(a, b)
}, cc.Follow.create = cc.follow, cc.ActionInterval = cc.FiniteTimeAction.extend({
    _elapsed: 0,
    _firstTick: !1,
    _easeList: null,
    _times: 1,
    _repeatForever: !1,
    _repeatMethod: !1,
    _speed: 1,
    _speedMethod: !1,
    ctor: function(a) {
        this._speed = 1, this._times = 1, this._repeatForever = !1, this.MAX_VALUE = 2, this._repeatMethod = !1, this._speedMethod = !1, cc.FiniteTimeAction.prototype.ctor.call(this), void 0 !== a && this.initWithDuration(a)
    },
    getElapsed: function() {
        return this._elapsed
    },
    initWithDuration: function(a) {
        return this._duration = 0 === a ? cc.FLT_EPSILON : a, this._elapsed = 0, this._firstTick = !0, !0
    },
    isDone: function() {
        return this._elapsed >= this._duration
    },
    _cloneDecoration: function(a) {
        a._repeatForever = this._repeatForever, a._speed = this._speed, a._times = this._times, a._easeList = this._easeList, a._speedMethod = this._speedMethod, a._repeatMethod = this._repeatMethod
    },
    _reverseEaseList: function(a) {
        if (this._easeList) {
            a._easeList = [];
            for (var b = 0; b < this._easeList.length; b++) a._easeList.push(this._easeList[b].reverse())
        }
    },
    clone: function() {
        var a = new cc.ActionInterval(this._duration);
        return this._cloneDecoration(a), a
    },
    easing: function() {
        this._easeList ? this._easeList.length = 0 : this._easeList = [];
        for (var a = 0; a < arguments.length; a++) this._easeList.push(arguments[a]);
        return this
    },
    _computeEaseTime: function(a) {
        var b = this._easeList;
        if (!b || 0 === b.length) return a;
        for (var c = 0, d = b.length; d > c; c++) a = b[c].easing(a);
        return a
    },
    step: function(a) {
        this._firstTick ? (this._firstTick = !1, this._elapsed = 0) : this._elapsed += a;
        var b = this._elapsed / (this._duration > 1.192092896e-7 ? this._duration : 1.192092896e-7);
        b = 1 > b ? b : 1, this.update(b > 0 ? b : 0), this._repeatMethod && this._times > 1 && this.isDone() && (this._repeatForever || this._times--, this.startWithTarget(this.target), this.step(this._elapsed - this._duration))
    },
    startWithTarget: function(a) {
        cc.Action.prototype.startWithTarget.call(this, a), this._elapsed = 0, this._firstTick = !0
    },
    reverse: function() {
        return cc.log("cc.IntervalAction: reverse not implemented."), null
    },
    setAmplitudeRate: function() {
        cc.log("cc.ActionInterval.setAmplitudeRate(): it should be overridden in subclass.")
    },
    getAmplitudeRate: function() {
        return cc.log("cc.ActionInterval.getAmplitudeRate(): it should be overridden in subclass."), 0
    },
    speed: function(a) {
        return 0 >= a ? (cc.log("The speed parameter error"), this) : (this._speedMethod = !0, this._speed *= a, this)
    },
    getSpeed: function() {
        return this._speed
    },
    setSpeed: function(a) {
        return this._speed = a, this
    },
    repeat: function(a) {
        return a = Math.round(a), isNaN(a) || 1 > a ? (cc.log("The repeat parameter error"), this) : (this._repeatMethod = !0, this._times *= a, this)
    },
    repeatForever: function() {
        return this._repeatMethod = !0, this._times = this.MAX_VALUE, this._repeatForever = !0, this
    }
}), cc.actionInterval = function(a) {
    return new cc.ActionInterval(a)
}, cc.ActionInterval.create = cc.actionInterval, cc.Sequence = cc.ActionInterval.extend({
    _actions: null,
    _split: null,
    _last: 0,
    ctor: function(a) {
        cc.ActionInterval.prototype.ctor.call(this), this._actions = [];
        var b = a instanceof Array ? a : arguments,
            c = b.length - 1;
        if (c >= 0 && null == b[c] && cc.log("parameters should not be ending with null in Javascript"), c >= 0) {
            for (var d, e = b[0], f = 1; c > f; f++) b[f] && (d = e, e = cc.Sequence._actionOneTwo(d, b[f]));
            this.initWithTwoActions(e, b[c])
        }
    },
    initWithTwoActions: function(a, b) {
        if (!a || !b) throw "cc.Sequence.initWithTwoActions(): arguments must all be non nil";
        var c = a._duration + b._duration;
        return this.initWithDuration(c), this._actions[0] = a, this._actions[1] = b, !0
    },
    clone: function() {
        var a = new cc.Sequence;
        return this._cloneDecoration(a), a.initWithTwoActions(this._actions[0].clone(), this._actions[1].clone()), a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a), this._split = this._actions[0]._duration / this._duration, this._last = -1
    },
    stop: function() {
        -1 !== this._last && this._actions[this._last].stop(), cc.Action.prototype.stop.call(this)
    },
    update: function(a) {
        var b, c, d = 0,
            e = this._split,
            f = this._actions,
            g = this._last;
        a = this._computeEaseTime(a), e > a ? (b = 0 !== e ? a / e : 1, 0 === d && 1 === g && (f[1].update(0), f[1].stop())) : (d = 1, b = 1 === e ? 1 : (a - e) / (1 - e), -1 === g && (f[0].startWithTarget(this.target), f[0].update(1), f[0].stop()), g || (f[0].update(1), f[0].stop())), c = f[d], g === d && c.isDone() || (g !== d && c.startWithTarget(this.target), b *= c._times, c.update(b > 1 ? b % 1 : b), this._last = d)
    },
    reverse: function() {
        var a = cc.Sequence._actionOneTwo(this._actions[1].reverse(), this._actions[0].reverse());
        return this._cloneDecoration(a), this._reverseEaseList(a), a
    }
}), cc.sequence = function(a) {
    var b = a instanceof Array ? a : arguments;
    b.length > 0 && null == b[b.length - 1] && cc.log("parameters should not be ending with null in Javascript");
    for (var c = b[0], d = 1; d < b.length; d++) b[d] && (c = cc.Sequence._actionOneTwo(c, b[d]));
    return c
}, cc.Sequence.create = cc.sequence, cc.Sequence._actionOneTwo = function(a, b) {
    var c = new cc.Sequence;
    return c.initWithTwoActions(a, b), c
}, cc.Repeat = cc.ActionInterval.extend({
    _times: 0,
    _total: 0,
    _nextDt: 0,
    _actionInstant: !1,
    _innerAction: null,
    ctor: function(a, b) {
        cc.ActionInterval.prototype.ctor.call(this), void 0 !== b && this.initWithAction(a, b)
    },
    initWithAction: function(a, b) {
        var c = a._duration * b;
        return this.initWithDuration(c) ? (this._times = b, this._innerAction = a, a instanceof cc.ActionInstant && (this._actionInstant = !0, this._times -= 1), this._total = 0, !0) : !1
    },
    clone: function() {
        var a = new cc.Repeat;
        return this._cloneDecoration(a), a.initWithAction(this._innerAction.clone(), this._times), a
    },
    startWithTarget: function(a) {
        this._total = 0, this._nextDt = this._innerAction._duration / this._duration, cc.ActionInterval.prototype.startWithTarget.call(this, a), this._innerAction.startWithTarget(a)
    },
    stop: function() {
        this._innerAction.stop(), cc.Action.prototype.stop.call(this)
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        var b = this._innerAction,
            c = this._duration,
            d = this._times,
            e = this._nextDt;
        if (a >= e) {
            for (; a > e && this._total < d;) b.update(1), this._total++, b.stop(), b.startWithTarget(this.target), e += b._duration / c, this._nextDt = e;
            a >= 1 && this._total < d && this._total++, this._actionInstant || (this._total === d ? (b.update(1), b.stop()) : b.update(a - (e - b._duration / c)))
        } else b.update(a * d % 1)
    },
    isDone: function() {
        return this._total == this._times
    },
    reverse: function() {
        var a = new cc.Repeat(this._innerAction.reverse(), this._times);
        return this._cloneDecoration(a), this._reverseEaseList(a), a
    },
    setInnerAction: function(a) {
        this._innerAction != a && (this._innerAction = a)
    },
    getInnerAction: function() {
        return this._innerAction
    }
}), cc.repeat = function(a, b) {
    return new cc.Repeat(a, b)
}, cc.Repeat.create = cc.repeat, cc.RepeatForever = cc.ActionInterval.extend({
    _innerAction: null,
    ctor: function(a) {
        cc.ActionInterval.prototype.ctor.call(this), this._innerAction = null, a && this.initWithAction(a)
    },
    initWithAction: function(a) {
        if (!a) throw "cc.RepeatForever.initWithAction(): action must be non null";
        return this._innerAction = a, !0
    },
    clone: function() {
        var a = new cc.RepeatForever;
        return this._cloneDecoration(a), a.initWithAction(this._innerAction.clone()), a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a), this._innerAction.startWithTarget(a)
    },
    step: function(a) {
        var b = this._innerAction;
        b.step(a), b.isDone() && (b.startWithTarget(this.target), b.step(b.getElapsed() - b._duration))
    },
    isDone: function() {
        return !1
    },
    reverse: function() {
        var a = new cc.RepeatForever(this._innerAction.reverse());
        return this._cloneDecoration(a), this._reverseEaseList(a), a
    },
    setInnerAction: function(a) {
        this._innerAction != a && (this._innerAction = a)
    },
    getInnerAction: function() {
        return this._innerAction
    }
}), cc.repeatForever = function(a) {
    return new cc.RepeatForever(a)
}, cc.RepeatForever.create = cc.repeatForever, cc.Spawn = cc.ActionInterval.extend({
    _one: null,
    _two: null,
    ctor: function(a) {
        cc.ActionInterval.prototype.ctor.call(this), this._one = null, this._two = null;
        var b = a instanceof Array ? a : arguments,
            c = b.length - 1;
        if (c >= 0 && null == b[c] && cc.log("parameters should not be ending with null in Javascript"), c >= 0) {
            for (var d, e = b[0], f = 1; c > f; f++) b[f] && (d = e, e = cc.Spawn._actionOneTwo(d, b[f]));
            this.initWithTwoActions(e, b[c])
        }
    },
    initWithTwoActions: function(a, b) {
        if (!a || !b) throw "cc.Spawn.initWithTwoActions(): arguments must all be non null";
        var c = !1,
            d = a._duration,
            e = b._duration;
        return this.initWithDuration(Math.max(d, e)) && (this._one = a, this._two = b, d > e ? this._two = cc.Sequence._actionOneTwo(b, cc.delayTime(d - e)) : e > d && (this._one = cc.Sequence._actionOneTwo(a, cc.delayTime(e - d))), c = !0), c
    },
    clone: function() {
        var a = new cc.Spawn;
        return this._cloneDecoration(a), a.initWithTwoActions(this._one.clone(), this._two.clone()), a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a), this._one.startWithTarget(a), this._two.startWithTarget(a)
    },
    stop: function() {
        this._one.stop(), this._two.stop(), cc.Action.prototype.stop.call(this)
    },
    update: function(a) {
        a = this._computeEaseTime(a), this._one && this._one.update(a), this._two && this._two.update(a)
    },
    reverse: function() {
        var a = cc.Spawn._actionOneTwo(this._one.reverse(), this._two.reverse());
        return this._cloneDecoration(a), this._reverseEaseList(a), a
    }
}), cc.spawn = function(a) {
    var b = a instanceof Array ? a : arguments;
    b.length > 0 && null == b[b.length - 1] && cc.log("parameters should not be ending with null in Javascript");
    for (var c = b[0], d = 1; d < b.length; d++) null != b[d] && (c = cc.Spawn._actionOneTwo(c, b[d]));
    return c
}, cc.Spawn.create = cc.spawn, cc.Spawn._actionOneTwo = function(a, b) {
    var c = new cc.Spawn;
    return c.initWithTwoActions(a, b), c
}, cc.RotateTo = cc.ActionInterval.extend({
    _dstAngleX: 0,
    _startAngleX: 0,
    _diffAngleX: 0,
    _dstAngleY: 0,
    _startAngleY: 0,
    _diffAngleY: 0,
    ctor: function(a, b, c) {
        cc.ActionInterval.prototype.ctor.call(this), void 0 !== b && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._dstAngleX = b || 0, this._dstAngleY = c || this._dstAngleX, !0) : !1
    },
    clone: function() {
        var a = new cc.RotateTo;
        return this._cloneDecoration(a), a.initWithDuration(this._duration, this._dstAngleX, this._dstAngleY), a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        var b = a.rotationX % 360,
            c = this._dstAngleX - b;
        c > 180 && (c -= 360), -180 > c && (c += 360), this._startAngleX = b, this._diffAngleX = c, this._startAngleY = a.rotationY % 360;
        var d = this._dstAngleY - this._startAngleY;
        d > 180 && (d -= 360), -180 > d && (d += 360), this._diffAngleY = d
    },
    reverse: function() {
        cc.log("cc.RotateTo.reverse(): it should be overridden in subclass.")
    },
    update: function(a) {
        a = this._computeEaseTime(a), this.target && (this.target.rotationX = this._startAngleX + this._diffAngleX * a, this.target.rotationY = this._startAngleY + this._diffAngleY * a)
    }
}), cc.rotateTo = function(a, b, c) {
    return new cc.RotateTo(a, b, c)
}, cc.RotateTo.create = cc.rotateTo, cc.RotateBy = cc.ActionInterval.extend({
    _angleX: 0,
    _startAngleX: 0,
    _angleY: 0,
    _startAngleY: 0,
    ctor: function(a, b, c) {
        cc.ActionInterval.prototype.ctor.call(this), void 0 !== b && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._angleX = b || 0, this._angleY = c || this._angleX, !0) : !1
    },
    clone: function() {
        var a = new cc.RotateBy;
        return this._cloneDecoration(a), a.initWithDuration(this._duration, this._angleX, this._angleY), a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a), this._startAngleX = a.rotationX, this._startAngleY = a.rotationY
    },
    update: function(a) {
        a = this._computeEaseTime(a), this.target && (this.target.rotationX = this._startAngleX + this._angleX * a, this.target.rotationY = this._startAngleY + this._angleY * a)
    },
    reverse: function() {
        var a = new cc.RotateBy(this._duration, -this._angleX, -this._angleY);
        return this._cloneDecoration(a), this._reverseEaseList(a), a
    }
}), cc.rotateBy = function(a, b, c) {
    return new cc.RotateBy(a, b, c)
}, cc.RotateBy.create = cc.rotateBy, cc.MoveBy = cc.ActionInterval.extend({
    _positionDelta: null,
    _startPosition: null,
    _previousPosition: null,
    ctor: function(a, b, c) {
        cc.ActionInterval.prototype.ctor.call(this), this._positionDelta = cc.p(0, 0), this._startPosition = cc.p(0, 0), this._previousPosition = cc.p(0, 0), void 0 !== b && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (void 0 !== b.x && (c = b.y, b = b.x), this._positionDelta.x = b, this._positionDelta.y = c, !0) : !1
    },
    clone: function() {
        var a = new cc.MoveBy;
        return this._cloneDecoration(a), a.initWithDuration(this._duration, this._positionDelta), a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        var b = a.getPositionX(),
            c = a.getPositionY();
        this._previousPosition.x = b, this._previousPosition.y = c, this._startPosition.x = b, this._startPosition.y = c
    },
    update: function(a) {
        if (a = this._computeEaseTime(a), this.target) {
            var b = this._positionDelta.x * a,
                c = this._positionDelta.y * a,
                d = this._startPosition;
            if (cc.ENABLE_STACKABLE_ACTIONS) {
                var e = this.target.getPositionX(),
                    f = this.target.getPositionY(),
                    g = this._previousPosition;
                d.x = d.x + e - g.x, d.y = d.y + f - g.y, b += d.x, c += d.y, g.x = b, g.y = c, this.target.setPosition(b, c)
            } else this.target.setPosition(d.x + b, d.y + c)
        }
    },
    reverse: function() {
        var a = new cc.MoveBy(this._duration, cc.p(-this._positionDelta.x, -this._positionDelta.y));
        return this._cloneDecoration(a), this._reverseEaseList(a), a
    }
}), cc.moveBy = function(a, b, c) {
    return new cc.MoveBy(a, b, c)
}, cc.MoveBy.create = cc.moveBy, cc.MoveTo = cc.MoveBy.extend({
    _endPosition: null,
    ctor: function(a, b, c) {
        cc.MoveBy.prototype.ctor.call(this), this._endPosition = cc.p(0, 0), void 0 !== b && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        return cc.MoveBy.prototype.initWithDuration.call(this, a, b, c) ? (void 0 !== b.x && (c = b.y, b = b.x), this._endPosition.x = b, this._endPosition.y = c, !0) : !1
    },
    clone: function() {
        var a = new cc.MoveTo;
        return this._cloneDecoration(a), a.initWithDuration(this._duration, this._endPosition), a
    },
    startWithTarget: function(a) {
        cc.MoveBy.prototype.startWithTarget.call(this, a), this._positionDelta.x = this._endPosition.x - a.getPositionX(), this._positionDelta.y = this._endPosition.y - a.getPositionY()
    }
}), cc.moveTo = function(a, b, c) {
    return new cc.MoveTo(a, b, c)
}, cc.MoveTo.create = cc.moveTo, cc.SkewTo = cc.ActionInterval.extend({
    _skewX: 0,
    _skewY: 0,
    _startSkewX: 0,
    _startSkewY: 0,
    _endSkewX: 0,
    _endSkewY: 0,
    _deltaX: 0,
    _deltaY: 0,
    ctor: function(a, b, c) {
        cc.ActionInterval.prototype.ctor.call(this), void 0 !== c && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        var d = !1;
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) && (this._endSkewX = b, this._endSkewY = c, d = !0), d
    },
    clone: function() {
        var a = new cc.SkewTo;
        return this._cloneDecoration(a), a.initWithDuration(this._duration, this._endSkewX, this._endSkewY), a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a), this._startSkewX = a.skewX % 180, this._deltaX = this._endSkewX - this._startSkewX, this._deltaX > 180 && (this._deltaX -= 360), this._deltaX < -180 && (this._deltaX += 360), this._startSkewY = a.skewY % 360, this._deltaY = this._endSkewY - this._startSkewY, this._deltaY > 180 && (this._deltaY -= 360), this._deltaY < -180 && (this._deltaY += 360)
    },
    update: function(a) {
        a = this._computeEaseTime(a), this.target.skewX = this._startSkewX + this._deltaX * a, this.target.skewY = this._startSkewY + this._deltaY * a
    }
}), cc.skewTo = function(a, b, c) {
    return new cc.SkewTo(a, b, c)
}, cc.SkewTo.create = cc.skewTo, cc.SkewBy = cc.SkewTo.extend({
    ctor: function(a, b, c) {
        cc.SkewTo.prototype.ctor.call(this), void 0 !== c && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        var d = !1;
        return cc.SkewTo.prototype.initWithDuration.call(this, a, b, c) && (this._skewX = b, this._skewY = c, d = !0), d
    },
    clone: function() {
        var a = new cc.SkewBy;
        return this._cloneDecoration(a), a.initWithDuration(this._duration, this._skewX, this._skewY), a
    },
    startWithTarget: function(a) {
        cc.SkewTo.prototype.startWithTarget.call(this, a), this._deltaX = this._skewX, this._deltaY = this._skewY, this._endSkewX = this._startSkewX + this._deltaX, this._endSkewY = this._startSkewY + this._deltaY
    },
    reverse: function() {
        var a = new cc.SkewBy(this._duration, -this._skewX, -this._skewY);
        return this._cloneDecoration(a), this._reverseEaseList(a), a
    }
}), cc.skewBy = function(a, b, c) {
    return new cc.SkewBy(a, b, c)
}, cc.SkewBy.create = cc.skewBy, cc.JumpBy = cc.ActionInterval.extend({
    _startPosition: null,
    _delta: null,
    _height: 0,
    _jumps: 0,
    _previousPosition: null,
    ctor: function(a, b, c, d, e) {
        cc.ActionInterval.prototype.ctor.call(this), this._startPosition = cc.p(0, 0), this._previousPosition = cc.p(0, 0), this._delta = cc.p(0, 0), void 0 !== d && this.initWithDuration(a, b, c, d, e)
    },
    initWithDuration: function(a, b, c, d, e) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (void 0 === e && (e = d, d = c, c = b.y, b = b.x), this._delta.x = b, this._delta.y = c, this._height = d, this._jumps = e, !0) : !1
    },
    clone: function() {
        var a = new cc.JumpBy;
        return this._cloneDecoration(a), a.initWithDuration(this._duration, this._delta, this._height, this._jumps), a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        var b = a.getPositionX(),
            c = a.getPositionY();
        this._previousPosition.x = b, this._previousPosition.y = c, this._startPosition.x = b, this._startPosition.y = c
    },
    update: function(a) {
        if (a = this._computeEaseTime(a), this.target) {
            var b = a * this._jumps % 1,
                c = 4 * this._height * b * (1 - b);
            c += this._delta.y * a;
            var d = this._delta.x * a,
                e = this._startPosition;
            if (cc.ENABLE_STACKABLE_ACTIONS) {
                var f = this.target.getPositionX(),
                    g = this.target.getPositionY(),
                    h = this._previousPosition;
                e.x = e.x + f - h.x, e.y = e.y + g - h.y, d += e.x, c += e.y, h.x = d, h.y = c, this.target.setPosition(d, c)
            } else this.target.setPosition(e.x + d, e.y + c)
        }
    },
    reverse: function() {
        var a = new cc.JumpBy(this._duration, cc.p(-this._delta.x, -this._delta.y), this._height, this._jumps);
        return this._cloneDecoration(a), this._reverseEaseList(a), a
    }
}), cc.jumpBy = function(a, b, c, d, e) {
    return new cc.JumpBy(a, b, c, d, e)
}, cc.JumpBy.create = cc.jumpBy, cc.JumpTo = cc.JumpBy.extend({
    _endPosition: null,
    ctor: function(a, b, c, d, e) {
        cc.JumpBy.prototype.ctor.call(this), this._endPosition = cc.p(0, 0), void 0 !== d && this.initWithDuration(a, b, c, d, e)
    },
    initWithDuration: function(a, b, c, d, e) {
        return cc.JumpBy.prototype.initWithDuration.call(this, a, b, c, d, e) ? (void 0 === e && (c = b.y, b = b.x), this._endPosition.x = b, this._endPosition.y = c, !0) : !1
    },
    startWithTarget: function(a) {
        cc.JumpBy.prototype.startWithTarget.call(this, a), this._delta.x = this._endPosition.x - this._startPosition.x, this._delta.y = this._endPosition.y - this._startPosition.y
    },
    clone: function() {
        var a = new cc.JumpTo;
        return this._cloneDecoration(a), a.initWithDuration(this._duration, this._endPosition, this._height, this._jumps), a
    }
}), cc.jumpTo = function(a, b, c, d, e) {
    return new cc.JumpTo(a, b, c, d, e)
}, cc.JumpTo.create = cc.jumpTo, cc.bezierAt = function(a, b, c, d, e) {
    return Math.pow(1 - e, 3) * a + 3 * e * Math.pow(1 - e, 2) * b + 3 * Math.pow(e, 2) * (1 - e) * c + Math.pow(e, 3) * d
}, cc.BezierBy = cc.ActionInterval.extend({
    _config: null,
    _startPosition: null,
    _previousPosition: null,
    ctor: function(a, b) {
        cc.ActionInterval.prototype.ctor.call(this), this._config = [], this._startPosition = cc.p(0, 0), this._previousPosition = cc.p(0, 0), b && this.initWithDuration(a, b)
    },
    initWithDuration: function(a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._config = b, !0) : !1
    },
    clone: function() {
        var a = new cc.BezierBy;
        this._cloneDecoration(a);
        for (var b = [], c = 0; c < this._config.length; c++) {
            var d = this._config[c];
            b.push(cc.p(d.x, d.y))
        }
        return a.initWithDuration(this._duration, b), a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        var b = a.getPositionX(),
            c = a.getPositionY();
        this._previousPosition.x = b, this._previousPosition.y = c, this._startPosition.x = b, this._startPosition.y = c
    },
    update: function(a) {
        if (a = this._computeEaseTime(a), this.target) {
            var b = this._config,
                c = 0,
                d = b[0].x,
                e = b[1].x,
                f = b[2].x,
                g = 0,
                h = b[0].y,
                i = b[1].y,
                j = b[2].y,
                k = cc.bezierAt(c, d, e, f, a),
                l = cc.bezierAt(g, h, i, j, a),
                m = this._startPosition;
            if (cc.ENABLE_STACKABLE_ACTIONS) {
                var n = this.target.getPositionX(),
                    o = this.target.getPositionY(),
                    p = this._previousPosition;
                m.x = m.x + n - p.x, m.y = m.y + o - p.y, k += m.x, l += m.y, p.x = k, p.y = l, this.target.setPosition(k, l)
            } else this.target.setPosition(m.x + k, m.y + l)
        }
    },
    reverse: function() {
        var a = this._config,
            b = [cc.pAdd(a[1], cc.pNeg(a[2])), cc.pAdd(a[0], cc.pNeg(a[2])), cc.pNeg(a[2])],
            c = new cc.BezierBy(this._duration, b);
        return this._cloneDecoration(c), this._reverseEaseList(c), c
    }
}), cc.bezierBy = function(a, b) {
    return new cc.BezierBy(a, b)
}, cc.BezierBy.create = cc.bezierBy, cc.BezierTo = cc.BezierBy.extend({
    _toConfig: null,
    ctor: function(a, b) {
        cc.BezierBy.prototype.ctor.call(this), this._toConfig = [], b && this.initWithDuration(a, b)
    },
    initWithDuration: function(a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._toConfig = b, !0) : !1
    },
    clone: function() {
        var a = new cc.BezierTo;
        return this._cloneDecoration(a), a.initWithDuration(this._duration, this._toConfig), a
    },
    startWithTarget: function(a) {
        cc.BezierBy.prototype.startWithTarget.call(this, a);
        var b = this._startPosition,
            c = this._toConfig,
            d = this._config;
        d[0] = cc.pSub(c[0], b), d[1] = cc.pSub(c[1], b), d[2] = cc.pSub(c[2], b)
    }
}), cc.bezierTo = function(a, b) {
    return new cc.BezierTo(a, b)
}, cc.BezierTo.create = cc.bezierTo, cc.ScaleTo = cc.ActionInterval.extend({
    _scaleX: 1,
    _scaleY: 1,
    _startScaleX: 1,
    _startScaleY: 1,
    _endScaleX: 0,
    _endScaleY: 0,
    _deltaX: 0,
    _deltaY: 0,
    ctor: function(a, b, c) {
        cc.ActionInterval.prototype.ctor.call(this), void 0 !== b && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._endScaleX = b, this._endScaleY = null != c ? c : b, !0) : !1
    },
    clone: function() {
        var a = new cc.ScaleTo;
        return this._cloneDecoration(a), a.initWithDuration(this._duration, this._endScaleX, this._endScaleY), a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a), this._startScaleX = a.scaleX, this._startScaleY = a.scaleY, this._deltaX = this._endScaleX - this._startScaleX, this._deltaY = this._endScaleY - this._startScaleY
    },
    update: function(a) {
        a = this._computeEaseTime(a), this.target && (this.target.scaleX = this._startScaleX + this._deltaX * a, this.target.scaleY = this._startScaleY + this._deltaY * a)
    }
}), cc.scaleTo = function(a, b, c) {
    return new cc.ScaleTo(a, b, c)
}, cc.ScaleTo.create = cc.scaleTo, cc.ScaleBy = cc.ScaleTo.extend({
    startWithTarget: function(a) {
        cc.ScaleTo.prototype.startWithTarget.call(this, a), this._deltaX = this._startScaleX * this._endScaleX - this._startScaleX, this._deltaY = this._startScaleY * this._endScaleY - this._startScaleY
    },
    reverse: function() {
        var a = new cc.ScaleBy(this._duration, 1 / this._endScaleX, 1 / this._endScaleY);
        return this._cloneDecoration(a), this._reverseEaseList(a), a
    },
    clone: function() {
        var a = new cc.ScaleBy;
        return this._cloneDecoration(a), a.initWithDuration(this._duration, this._endScaleX, this._endScaleY), a
    }
}), cc.scaleBy = function(a, b, c) {
    return new cc.ScaleBy(a, b, c)
}, cc.ScaleBy.create = cc.scaleBy, cc.Blink = cc.ActionInterval.extend({
    _times: 0,
    _originalState: !1,
    ctor: function(a, b) {
        cc.ActionInterval.prototype.ctor.call(this), void 0 !== b && this.initWithDuration(a, b)
    },
    initWithDuration: function(a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._times = b, !0) : !1
    },
    clone: function() {
        var a = new cc.Blink;
        return this._cloneDecoration(a), a.initWithDuration(this._duration, this._times), a
    },
    update: function(a) {
        if (a = this._computeEaseTime(a), this.target && !this.isDone()) {
            var b = 1 / this._times,
                c = a % b;
            this.target.visible = c > b / 2
        }
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a), this._originalState = a.visible
    },
    stop: function() {
        this.target.visible = this._originalState, cc.ActionInterval.prototype.stop.call(this)
    },
    reverse: function() {
        var a = new cc.Blink(this._duration, this._times);
        return this._cloneDecoration(a), this._reverseEaseList(a), a
    }
}), cc.blink = function(a, b) {
    return new cc.Blink(a, b)
}, cc.Blink.create = cc.blink, cc.FadeTo = cc.ActionInterval.extend({
    _toOpacity: 0,
    _fromOpacity: 0,
    ctor: function(a, b) {
        cc.ActionInterval.prototype.ctor.call(this), void 0 !== b && this.initWithDuration(a, b)
    },
    initWithDuration: function(a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._toOpacity = b, !0) : !1
    },
    clone: function() {
        var a = new cc.FadeTo;
        return this._cloneDecoration(a), a.initWithDuration(this._duration, this._toOpacity), a
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        var b = void 0 !== this._fromOpacity ? this._fromOpacity : 255;
        this.target.opacity = b + (this._toOpacity - b) * a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a), this._fromOpacity = a.opacity
    }
}), cc.fadeTo = function(a, b) {
    return new cc.FadeTo(a, b)
}, cc.FadeTo.create = cc.fadeTo, cc.FadeIn = cc.FadeTo.extend({
    _reverseAction: null,
    ctor: function(a) {
        cc.FadeTo.prototype.ctor.call(this), a && this.initWithDuration(a, 255)
    },
    reverse: function() {
        var a = new cc.FadeOut;
        return a.initWithDuration(this._duration, 0), this._cloneDecoration(a), this._reverseEaseList(a), a
    },
    clone: function() {
        var a = new cc.FadeIn;
        return this._cloneDecoration(a), a.initWithDuration(this._duration, this._toOpacity), a
    },
    startWithTarget: function(a) {
        this._reverseAction && (this._toOpacity = this._reverseAction._fromOpacity), cc.FadeTo.prototype.startWithTarget.call(this, a)
    }
}), cc.fadeIn = function(a) {
    return new cc.FadeIn(a)
}, cc.FadeIn.create = cc.fadeIn, cc.FadeOut = cc.FadeTo.extend({
    ctor: function(a) {
        cc.FadeTo.prototype.ctor.call(this), a && this.initWithDuration(a, 0)
    },
    reverse: function() {
        var a = new cc.FadeIn;
        return a._reverseAction = this, a.initWithDuration(this._duration, 255), this._cloneDecoration(a), this._reverseEaseList(a), a
    },
    clone: function() {
        var a = new cc.FadeOut;
        return this._cloneDecoration(a), a.initWithDuration(this._duration, this._toOpacity), a
    }
}), cc.fadeOut = function(a) {
    return new cc.FadeOut(a)
}, cc.FadeOut.create = cc.fadeOut, cc.TintTo = cc.ActionInterval.extend({
    _to: null,
    _from: null,
    ctor: function(a, b, c, d) {
        cc.ActionInterval.prototype.ctor.call(this), this._to = cc.color(0, 0, 0), this._from = cc.color(0, 0, 0), void 0 !== d && this.initWithDuration(a, b, c, d)
    },
    initWithDuration: function(a, b, c, d) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._to = cc.color(b, c, d), !0) : !1
    },
    clone: function() {
        var a = new cc.TintTo;
        this._cloneDecoration(a);
        var b = this._to;
        return a.initWithDuration(this._duration, b.r, b.g, b.b), a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a), this._from = this.target.color
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        var b = this._from,
            c = this._to;
        b && (this.target.color = cc.color(b.r + (c.r - b.r) * a, b.g + (c.g - b.g) * a, b.b + (c.b - b.b) * a))
    }
}), cc.tintTo = function(a, b, c, d) {
    return new cc.TintTo(a, b, c, d)
}, cc.TintTo.create = cc.tintTo, cc.TintBy = cc.ActionInterval.extend({
    _deltaR: 0,
    _deltaG: 0,
    _deltaB: 0,
    _fromR: 0,
    _fromG: 0,
    _fromB: 0,
    ctor: function(a, b, c, d) {
        cc.ActionInterval.prototype.ctor.call(this), void 0 !== d && this.initWithDuration(a, b, c, d)
    },
    initWithDuration: function(a, b, c, d) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._deltaR = b, this._deltaG = c, this._deltaB = d, !0) : !1
    },
    clone: function() {
        var a = new cc.TintBy;
        return this._cloneDecoration(a), a.initWithDuration(this._duration, this._deltaR, this._deltaG, this._deltaB), a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        var b = a.color;
        this._fromR = b.r, this._fromG = b.g, this._fromB = b.b
    },
    update: function(a) {
        a = this._computeEaseTime(a), this.target.color = cc.color(this._fromR + this._deltaR * a, this._fromG + this._deltaG * a, this._fromB + this._deltaB * a)
    },
    reverse: function() {
        var a = new cc.TintBy(this._duration, -this._deltaR, -this._deltaG, -this._deltaB);
        return this._cloneDecoration(a), this._reverseEaseList(a), a
    }
}), cc.tintBy = function(a, b, c, d) {
    return new cc.TintBy(a, b, c, d)
}, cc.TintBy.create = cc.tintBy, cc.DelayTime = cc.ActionInterval.extend({
    update: function() {},
    reverse: function() {
        var a = new cc.DelayTime(this._duration);
        return this._cloneDecoration(a), this._reverseEaseList(a), a
    },
    clone: function() {
        var a = new cc.DelayTime;
        return this._cloneDecoration(a), a.initWithDuration(this._duration), a
    }
}), cc.delayTime = function(a) {
    return new cc.DelayTime(a)
}, cc.DelayTime.create = cc.delayTime, cc.ReverseTime = cc.ActionInterval.extend({
    _other: null,
    ctor: function(a) {
        cc.ActionInterval.prototype.ctor.call(this), this._other = null, a && this.initWithAction(a)
    },
    initWithAction: function(a) {
        if (!a) throw "cc.ReverseTime.initWithAction(): action must be non null";
        if (a == this._other) throw "cc.ReverseTime.initWithAction(): the action was already passed in.";
        return cc.ActionInterval.prototype.initWithDuration.call(this, a._duration) ? (this._other = a, !0) : !1
    },
    clone: function() {
        var a = new cc.ReverseTime;
        return this._cloneDecoration(a), a.initWithAction(this._other.clone()), a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a), this._other.startWithTarget(a)
    },
    update: function(a) {
        a = this._computeEaseTime(a), this._other && this._other.update(1 - a)
    },
    reverse: function() {
        return this._other.clone()
    },
    stop: function() {
        this._other.stop(), cc.Action.prototype.stop.call(this)
    }
}), cc.reverseTime = function(a) {
    return new cc.ReverseTime(a)
}, cc.ReverseTime.create = cc.reverseTime, cc.Animate = cc.ActionInterval.extend({
    _animation: null,
    _nextFrame: 0,
    _origFrame: null,
    _executedLoops: 0,
    _splitTimes: null,
    ctor: function(a) {
        cc.ActionInterval.prototype.ctor.call(this), this._splitTimes = [], a && this.initWithAnimation(a)
    },
    getAnimation: function() {
        return this._animation
    },
    setAnimation: function(a) {
        this._animation = a
    },
    initWithAnimation: function(a) {
        if (!a) throw "cc.Animate.initWithAnimation(): animation must be non-NULL";
        var b = a.getDuration();
        if (this.initWithDuration(b * a.getLoops())) {
            this._nextFrame = 0, this.setAnimation(a), this._origFrame = null, this._executedLoops = 0;
            var c = this._splitTimes;
            c.length = 0;
            var d = 0,
                e = b / a.getTotalDelayUnits(),
                f = a.getFrames();
            cc.arrayVerifyType(f, cc.AnimationFrame);
            for (var g = 0; g < f.length; g++) {
                var h = f[g],
                    i = d * e / b;
                d += h.getDelayUnits(), c.push(i)
            }
            return !0
        }
        return !1
    },
    clone: function() {
        var a = new cc.Animate;
        return this._cloneDecoration(a), a.initWithAnimation(this._animation.clone()), a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a), this._animation.getRestoreOriginalFrame() && (this._origFrame = a.displayFrame()), this._nextFrame = 0, this._executedLoops = 0
    },
    update: function(a) {
        if (a = this._computeEaseTime(a), 1 > a) {
            a *= this._animation.getLoops();
            var b = 0 | a;
            b > this._executedLoops && (this._nextFrame = 0, this._executedLoops++), a %= 1
        }
        for (var c = this._animation.getFrames(), d = c.length, e = this._splitTimes, f = this._nextFrame; d > f && e[f] <= a; f++) this.target.setSpriteFrame(c[f].getSpriteFrame()), this._nextFrame = f + 1
    },
    reverse: function() {
        var a = this._animation,
            b = a.getFrames(),
            c = [];
        if (cc.arrayVerifyType(b, cc.AnimationFrame), b.length > 0)
            for (var d = b.length - 1; d >= 0; d--) {
                var e = b[d];
                if (!e) break;
                c.push(e.clone())
            }
        var f = new cc.Animation(c, a.getDelayPerUnit(), a.getLoops());
        f.setRestoreOriginalFrame(a.getRestoreOriginalFrame());
        var g = new cc.Animate(f);
        return this._cloneDecoration(g), this._reverseEaseList(g), g
    },
    stop: function() {
        this._animation.getRestoreOriginalFrame() && this.target && this.target.setSpriteFrame(this._origFrame), cc.Action.prototype.stop.call(this)
    }
}), cc.animate = function(a) {
    return new cc.Animate(a)
}, cc.Animate.create = cc.animate, cc.TargetedAction = cc.ActionInterval.extend({
    _action: null,
    _forcedTarget: null,
    ctor: function(a, b) {
        cc.ActionInterval.prototype.ctor.call(this), b && this.initWithTarget(a, b)
    },
    initWithTarget: function(a, b) {
        return this.initWithDuration(b._duration) ? (this._forcedTarget = a, this._action = b, !0) : !1
    },
    clone: function() {
        var a = new cc.TargetedAction;
        return this._cloneDecoration(a), a.initWithTarget(this._forcedTarget, this._action.clone()), a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a), this._action.startWithTarget(this._forcedTarget)
    },
    stop: function() {
        this._action.stop()
    },
    update: function(a) {
        a = this._computeEaseTime(a), this._action.update(a)
    },
    getForcedTarget: function() {
        return this._forcedTarget
    },
    setForcedTarget: function(a) {
        this._forcedTarget != a && (this._forcedTarget = a)
    }
}), cc.targetedAction = function(a, b) {
    return new cc.TargetedAction(a, b)
}, cc.TargetedAction.create = cc.targetedAction, cc.ActionInstant = cc.FiniteTimeAction.extend({
    isDone: function() {
        return !0
    },
    step: function() {
        this.update(1)
    },
    update: function() {},
    reverse: function() {
        return this.clone()
    },
    clone: function() {
        return new cc.ActionInstant
    }
}), cc.Show = cc.ActionInstant.extend({
    update: function() {
        this.target.visible = !0
    },
    reverse: function() {
        return new cc.Hide
    },
    clone: function() {
        return new cc.Show
    }
}), cc.show = function() {
    return new cc.Show
}, cc.Show.create = cc.show, cc.Hide = cc.ActionInstant.extend({
    update: function() {
        this.target.visible = !1
    },
    reverse: function() {
        return new cc.Show
    },
    clone: function() {
        return new cc.Hide
    }
}), cc.hide = function() {
    return new cc.Hide
}, cc.Hide.create = cc.hide, cc.ToggleVisibility = cc.ActionInstant.extend({
    update: function() {
        this.target.visible = !this.target.visible
    },
    reverse: function() {
        return new cc.ToggleVisibility
    },
    clone: function() {
        return new cc.ToggleVisibility
    }
}), cc.toggleVisibility = function() {
    return new cc.ToggleVisibility
}, cc.ToggleVisibility.create = cc.toggleVisibility, cc.RemoveSelf = cc.ActionInstant.extend({
    _isNeedCleanUp: !0,
    ctor: function(a) {
        cc.FiniteTimeAction.prototype.ctor.call(this), void 0 !== a && this.init(a)
    },
    update: function() {
        this.target.removeFromParent(this._isNeedCleanUp)
    },
    init: function(a) {
        return this._isNeedCleanUp = a, !0
    },
    reverse: function() {
        return new cc.RemoveSelf(this._isNeedCleanUp)
    },
    clone: function() {
        return new cc.RemoveSelf(this._isNeedCleanUp)
    }
}), cc.removeSelf = function(a) {
    return new cc.RemoveSelf(a)
}, cc.RemoveSelf.create = cc.removeSelf, cc.FlipX = cc.ActionInstant.extend({
    _flippedX: !1,
    ctor: function(a) {
        cc.FiniteTimeAction.prototype.ctor.call(this), this._flippedX = !1, void 0 !== a && this.initWithFlipX(a)
    },
    initWithFlipX: function(a) {
        return this._flippedX = a, !0
    },
    update: function() {
        this.target.flippedX = this._flippedX
    },
    reverse: function() {
        return new cc.FlipX(!this._flippedX)
    },
    clone: function() {
        var a = new cc.FlipX;
        return a.initWithFlipX(this._flippedX), a
    }
}), cc.flipX = function(a) {
    return new cc.FlipX(a)
}, cc.FlipX.create = cc.flipX, cc.FlipY = cc.ActionInstant.extend({
    _flippedY: !1,
    ctor: function(a) {
        cc.FiniteTimeAction.prototype.ctor.call(this), this._flippedY = !1, void 0 !== a && this.initWithFlipY(a)
    },
    initWithFlipY: function(a) {
        return this._flippedY = a, !0
    },
    update: function() {
        this.target.flippedY = this._flippedY
    },
    reverse: function() {
        return new cc.FlipY(!this._flippedY)
    },
    clone: function() {
        var a = new cc.FlipY;
        return a.initWithFlipY(this._flippedY), a
    }
}), cc.flipY = function(a) {
    return new cc.FlipY(a)
}, cc.FlipY.create = cc.flipY, cc.Place = cc.ActionInstant.extend({
    _x: 0,
    _y: 0,
    ctor: function(a, b) {
        cc.FiniteTimeAction.prototype.ctor.call(this), this._x = 0, this._y = 0, void 0 !== a && (void 0 !== a.x && (b = a.y, a = a.x), this.initWithPosition(a, b))
    },
    initWithPosition: function(a, b) {
        return this._x = a, this._y = b, !0
    },
    update: function() {
        this.target.setPosition(this._x, this._y)
    },
    clone: function() {
        var a = new cc.Place;
        return a.initWithPosition(this._x, this._y), a
    }
}), cc.place = function(a, b) {
    return new cc.Place(a, b)
}, cc.Place.create = cc.place, cc.CallFunc = cc.ActionInstant.extend({
    _selectorTarget: null,
    _callFunc: null,
    _function: null,
    _data: null,
    ctor: function(a, b, c) {
        cc.FiniteTimeAction.prototype.ctor.call(this), void 0 !== a && (void 0 === b ? this.initWithFunction(a) : this.initWithFunction(a, b, c))
    },
    initWithFunction: function(a, b, c) {
        return b ? (this._data = c, this._callFunc = a, this._selectorTarget = b) : a && (this._function = a), !0
    },
    execute: function() {
        null != this._callFunc ? this._callFunc.call(this._selectorTarget, this.target, this._data) : this._function && this._function.call(null, this.target)
    },
    update: function() {
        this.execute()
    },
    getTargetCallback: function() {
        return this._selectorTarget
    },
    setTargetCallback: function(a) {
        a != this._selectorTarget && (this._selectorTarget && (this._selectorTarget = null), this._selectorTarget = a)
    },
    clone: function() {
        var a = new cc.CallFunc;
        return this._selectorTarget ? a.initWithFunction(this._callFunc, this._selectorTarget, this._data) : this._function && a.initWithFunction(this._function), a
    }
}), cc.callFunc = function(a, b, c) {
    return new cc.CallFunc(a, b, c)
}, cc.CallFunc.create = cc.callFunc, cc.ActionCamera = cc.ActionInterval.extend({
    _centerXOrig: 0,
    _centerYOrig: 0,
    _centerZOrig: 0,
    _eyeXOrig: 0,
    _eyeYOrig: 0,
    _eyeZOrig: 0,
    _upXOrig: 0,
    _upYOrig: 0,
    _upZOrig: 0,
    ctor: function() {
        var a = this;
        cc.ActionInterval.prototype.ctor.call(a), a._centerXOrig = 0, a._centerYOrig = 0, a._centerZOrig = 0, a._eyeXOrig = 0, a._eyeYOrig = 0, a._eyeZOrig = 0, a._upXOrig = 0, a._upYOrig = 0, a._upZOrig = 0
    },
    startWithTarget: function(a) {
        var b = this;
        cc.ActionInterval.prototype.startWithTarget.call(b, a);
        var c = a.getCamera(),
            d = c.getCenter();
        b._centerXOrig = d.x, b._centerYOrig = d.y, b._centerZOrig = d.z;
        var e = c.getEye();
        b._eyeXOrig = e.x, b._eyeYOrig = e.y, b._eyeZOrig = e.z;
        var f = c.getUp();
        b._upXOrig = f.x, b._upYOrig = f.y, b._upZOrig = f.z
    },
    clone: function() {
        return new cc.ActionCamera
    },
    reverse: function() {
        return new cc.ReverseTime(this)
    }
}), cc.OrbitCamera = cc.ActionCamera.extend({
    _radius: 0,
    _deltaRadius: 0,
    _angleZ: 0,
    _deltaAngleZ: 0,
    _angleX: 0,
    _deltaAngleX: 0,
    _radZ: 0,
    _radDeltaZ: 0,
    _radX: 0,
    _radDeltaX: 0,
    ctor: function(a, b, c, d, e, f, g) {
        cc.ActionCamera.prototype.ctor.call(this), void 0 !== g && this.initWithDuration(a, b, c, d, e, f, g)
    },
    initWithDuration: function(a, b, c, d, e, f, g) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, a)) {
            var h = this;
            return h._radius = b, h._deltaRadius = c, h._angleZ = d, h._deltaAngleZ = e, h._angleX = f, h._deltaAngleX = g, h._radDeltaZ = cc.degreesToRadians(e), h._radDeltaX = cc.degreesToRadians(g), !0
        }
        return !1
    },
    sphericalRadius: function() {
        var a, b, c, d = this.target.getCamera(),
            e = d.getEye(),
            f = d.getCenter(),
            g = e.x - f.x,
            h = e.y - f.y,
            i = e.z - f.z,
            j = Math.sqrt(Math.pow(g, 2) + Math.pow(h, 2) + Math.pow(i, 2)),
            k = Math.sqrt(Math.pow(g, 2) + Math.pow(h, 2));
        return 0 === k && (k = cc.FLT_EPSILON), 0 === j && (j = cc.FLT_EPSILON), b = Math.acos(i / j), c = 0 > g ? Math.PI - Math.asin(h / k) : Math.asin(h / k), a = j / cc.Camera.getZEye(), {
            newRadius: a,
            zenith: b,
            azimuth: c
        }
    },
    startWithTarget: function(a) {
        var b = this;
        cc.ActionInterval.prototype.startWithTarget.call(b, a);
        var c = b.sphericalRadius();
        isNaN(b._radius) && (b._radius = c.newRadius), isNaN(b._angleZ) && (b._angleZ = cc.radiansToDegrees(c.zenith)), isNaN(b._angleX) && (b._angleX = cc.radiansToDegrees(c.azimuth)), b._radZ = cc.degreesToRadians(b._angleZ), b._radX = cc.degreesToRadians(b._angleX)
    },
    clone: function() {
        var a = new cc.OrbitCamera,
            b = this;
        return a.initWithDuration(b._duration, b._radius, b._deltaRadius, b._angleZ, b._deltaAngleZ, b._angleX, b._deltaAngleX), a
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        var b = (this._radius + this._deltaRadius * a) * cc.Camera.getZEye(),
            c = this._radZ + this._radDeltaZ * a,
            d = this._radX + this._radDeltaX * a,
            e = Math.sin(c) * Math.cos(d) * b + this._centerXOrig,
            f = Math.sin(c) * Math.sin(d) * b + this._centerYOrig,
            g = Math.cos(c) * b + this._centerZOrig;
        this.target.getCamera().setEye(e, f, g), this.target.setNodeDirty()
    }
}), cc.orbitCamera = function(a, b, c, d, e, f, g) {
    return new cc.OrbitCamera(a, b, c, d, e, f, g)
}, cc.OrbitCamera.create = cc.orbitCamera, cc.ActionEase = cc.ActionInterval.extend({
    _inner: null,
    ctor: function(a) {
        cc.ActionInterval.prototype.ctor.call(this), a && this.initWithAction(a)
    },
    initWithAction: function(a) {
        if (!a) throw "cc.ActionEase.initWithAction(): action must be non nil";
        return this.initWithDuration(a.getDuration()) ? (this._inner = a, !0) : !1
    },
    clone: function() {
        var a = new cc.ActionEase;
        return a.initWithAction(this._inner.clone()), a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a), this._inner.startWithTarget(this.target)
    },
    stop: function() {
        this._inner.stop(), cc.ActionInterval.prototype.stop.call(this)
    },
    update: function(a) {
        this._inner.update(a)
    },
    reverse: function() {
        return new cc.ActionEase(this._inner.reverse())
    },
    getInnerAction: function() {
        return this._inner
    }
}), cc.actionEase = function(a) {
    return new cc.ActionEase(a)
}, cc.ActionEase.create = cc.actionEase, cc.EaseRateAction = cc.ActionEase.extend({
    _rate: 0,
    ctor: function(a, b) {
        cc.ActionEase.prototype.ctor.call(this), void 0 !== b && this.initWithAction(a, b)
    },
    setRate: function(a) {
        this._rate = a
    },
    getRate: function() {
        return this._rate
    },
    initWithAction: function(a, b) {
        return cc.ActionEase.prototype.initWithAction.call(this, a) ? (this._rate = b, !0) : !1
    },
    clone: function() {
        var a = new cc.EaseRateAction;
        return a.initWithAction(this._inner.clone(), this._rate), a
    },
    reverse: function() {
        return new cc.EaseRateAction(this._inner.reverse(), 1 / this._rate)
    }
}), cc.easeRateAction = function(a, b) {
    return new cc.EaseRateAction(a, b)
}, cc.EaseRateAction.create = cc.easeRateAction, cc.EaseIn = cc.EaseRateAction.extend({
    update: function(a) {
        this._inner.update(Math.pow(a, this._rate))
    },
    reverse: function() {
        return new cc.EaseIn(this._inner.reverse(), 1 / this._rate)
    },
    clone: function() {
        var a = new cc.EaseIn;
        return a.initWithAction(this._inner.clone(), this._rate), a
    }
}), cc.EaseIn.create = function(a, b) {
    return new cc.EaseIn(a, b)
}, cc.easeIn = function(a) {
    return {
        _rate: a,
        easing: function(a) {
            return Math.pow(a, this._rate)
        },
        reverse: function() {
            return cc.easeIn(1 / this._rate)
        }
    }
}, cc.EaseOut = cc.EaseRateAction.extend({
    update: function(a) {
        this._inner.update(Math.pow(a, 1 / this._rate))
    },
    reverse: function() {
        return new cc.EaseOut(this._inner.reverse(), 1 / this._rate)
    },
    clone: function() {
        var a = new cc.EaseOut;
        return a.initWithAction(this._inner.clone(), this._rate), a
    }
}), cc.EaseOut.create = function(a, b) {
    return new cc.EaseOut(a, b)
}, cc.easeOut = function(a) {
    return {
        _rate: a,
        easing: function(a) {
            return Math.pow(a, 1 / this._rate)
        },
        reverse: function() {
            return cc.easeOut(1 / this._rate)
        }
    }
}, cc.EaseInOut = cc.EaseRateAction.extend({
    update: function(a) {
        a *= 2, this._inner.update(1 > a ? .5 * Math.pow(a, this._rate) : 1 - .5 * Math.pow(2 - a, this._rate))
    },
    clone: function() {
        var a = new cc.EaseInOut;
        return a.initWithAction(this._inner.clone(), this._rate), a
    },
    reverse: function() {
        return new cc.EaseInOut(this._inner.reverse(), this._rate)
    }
}), cc.EaseInOut.create = function(a, b) {
    return new cc.EaseInOut(a, b)
}, cc.easeInOut = function(a) {
    return {
        _rate: a,
        easing: function(a) {
            return a *= 2, 1 > a ? .5 * Math.pow(a, this._rate) : 1 - .5 * Math.pow(2 - a, this._rate)
        },
        reverse: function() {
            return cc.easeInOut(this._rate)
        }
    }
}, cc.EaseExponentialIn = cc.ActionEase.extend({
    update: function(a) {
        this._inner.update(0 === a ? 0 : Math.pow(2, 10 * (a - 1)))
    },
    reverse: function() {
        return new cc.EaseExponentialOut(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseExponentialIn;
        return a.initWithAction(this._inner.clone()), a
    }
}), cc.EaseExponentialIn.create = function(a) {
    return new cc.EaseExponentialIn(a)
}, cc._easeExponentialInObj = {
    easing: function(a) {
        return 0 === a ? 0 : Math.pow(2, 10 * (a - 1))
    },
    reverse: function() {
        return cc._easeExponentialOutObj
    }
}, cc.easeExponentialIn = function() {
    return cc._easeExponentialInObj
}, cc.EaseExponentialOut = cc.ActionEase.extend({
    update: function(a) {
        this._inner.update(1 == a ? 1 : -Math.pow(2, -10 * a) + 1)
    },
    reverse: function() {
        return new cc.EaseExponentialIn(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseExponentialOut;
        return a.initWithAction(this._inner.clone()), a
    }
}), cc.EaseExponentialOut.create = function(a) {
    return new cc.EaseExponentialOut(a)
}, cc._easeExponentialOutObj = {
    easing: function(a) {
        return 1 == a ? 1 : -Math.pow(2, -10 * a) + 1
    },
    reverse: function() {
        return cc._easeExponentialInObj
    }
}, cc.easeExponentialOut = function() {
    return cc._easeExponentialOutObj
}, cc.EaseExponentialInOut = cc.ActionEase.extend({
    update: function(a) {
        1 != a && 0 !== a && (a *= 2, a = 1 > a ? .5 * Math.pow(2, 10 * (a - 1)) : .5 * (-Math.pow(2, -10 * (a - 1)) + 2)), this._inner.update(a)
    },
    reverse: function() {
        return new cc.EaseExponentialInOut(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseExponentialInOut;
        return a.initWithAction(this._inner.clone()), a
    }
}), cc.EaseExponentialInOut.create = function(a) {
    return new cc.EaseExponentialInOut(a)
}, cc._easeExponentialInOutObj = {
    easing: function(a) {
        return 1 !== a && 0 !== a ? (a *= 2, 1 > a ? .5 * Math.pow(2, 10 * (a - 1)) : .5 * (-Math.pow(2, -10 * (a - 1)) + 2)) : a
    },
    reverse: function() {
        return cc._easeExponentialInOutObj
    }
}, cc.easeExponentialInOut = function() {
    return cc._easeExponentialInOutObj
}, cc.EaseSineIn = cc.ActionEase.extend({
    update: function(a) {
        a = 0 === a || 1 === a ? a : -1 * Math.cos(a * Math.PI / 2) + 1, this._inner.update(a)
    },
    reverse: function() {
        return new cc.EaseSineOut(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseSineIn;
        return a.initWithAction(this._inner.clone()), a
    }
}), cc.EaseSineIn.create = function(a) {
    return new cc.EaseSineIn(a)
}, cc._easeSineInObj = {
    easing: function(a) {
        return 0 === a || 1 === a ? a : -1 * Math.cos(a * Math.PI / 2) + 1
    },
    reverse: function() {
        return cc._easeSineOutObj
    }
}, cc.easeSineIn = function() {
    return cc._easeSineInObj
}, cc.EaseSineOut = cc.ActionEase.extend({
    update: function(a) {
        a = 0 === a || 1 === a ? a : Math.sin(a * Math.PI / 2), this._inner.update(a)
    },
    reverse: function() {
        return new cc.EaseSineIn(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseSineOut;
        return a.initWithAction(this._inner.clone()), a
    }
}), cc.EaseSineOut.create = function(a) {
    return new cc.EaseSineOut(a)
}, cc._easeSineOutObj = {
    easing: function(a) {
        return 0 === a || 1 == a ? a : Math.sin(a * Math.PI / 2)
    },
    reverse: function() {
        return cc._easeSineInObj
    }
}, cc.easeSineOut = function() {
    return cc._easeSineOutObj
}, cc.EaseSineInOut = cc.ActionEase.extend({
    update: function(a) {
        a = 0 === a || 1 === a ? a : -.5 * (Math.cos(Math.PI * a) - 1), this._inner.update(a)
    },
    clone: function() {
        var a = new cc.EaseSineInOut;
        return a.initWithAction(this._inner.clone()), a
    },
    reverse: function() {
        return new cc.EaseSineInOut(this._inner.reverse())
    }
}), cc.EaseSineInOut.create = function(a) {
    return new cc.EaseSineInOut(a)
}, cc._easeSineInOutObj = {
    easing: function(a) {
        return 0 === a || 1 === a ? a : -.5 * (Math.cos(Math.PI * a) - 1)
    },
    reverse: function() {
        return cc._easeSineInOutObj
    }
}, cc.easeSineInOut = function() {
    return cc._easeSineInOutObj
}, cc.EaseElastic = cc.ActionEase.extend({
    _period: .3,
    ctor: function(a, b) {
        cc.ActionEase.prototype.ctor.call(this), a && this.initWithAction(a, b)
    },
    getPeriod: function() {
        return this._period
    },
    setPeriod: function(a) {
        this._period = a
    },
    initWithAction: function(a, b) {
        return cc.ActionEase.prototype.initWithAction.call(this, a), this._period = null == b ? .3 : b, !0
    },
    reverse: function() {
        return cc.log("cc.EaseElastic.reverse(): it should be overridden in subclass."), null
    },
    clone: function() {
        var a = new cc.EaseElastic;
        return a.initWithAction(this._inner.clone(), this._period), a
    }
}), cc.EaseElastic.create = function(a, b) {
    return new cc.EaseElastic(a, b)
}, cc.EaseElasticIn = cc.EaseElastic.extend({
    update: function(a) {
        var b = 0;
        if (0 === a || 1 === a) b = a;
        else {
            var c = this._period / 4;
            a -= 1, b = -Math.pow(2, 10 * a) * Math.sin((a - c) * Math.PI * 2 / this._period)
        }
        this._inner.update(b)
    },
    reverse: function() {
        return new cc.EaseElasticOut(this._inner.reverse(), this._period)
    },
    clone: function() {
        var a = new cc.EaseElasticIn;
        return a.initWithAction(this._inner.clone(), this._period), a
    }
}), cc.EaseElasticIn.create = function(a, b) {
    return new cc.EaseElasticIn(a, b)
}, cc._easeElasticInObj = {
    easing: function(a) {
        return 0 === a || 1 === a ? a : (a -= 1, -Math.pow(2, 10 * a) * Math.sin((a - .075) * Math.PI * 2 / .3))
    },
    reverse: function() {
        return cc._easeElasticOutObj
    }
}, cc.easeElasticIn = function(a) {
    return a && .3 !== a ? {
        _period: a,
        easing: function(a) {
            return 0 === a || 1 === a ? a : (a -= 1, -Math.pow(2, 10 * a) * Math.sin((a - this._period / 4) * Math.PI * 2 / this._period))
        },
        reverse: function() {
            return cc.easeElasticOut(this._period)
        }
    } : cc._easeElasticInObj
}, cc.EaseElasticOut = cc.EaseElastic.extend({
    update: function(a) {
        var b = 0;
        if (0 === a || 1 == a) b = a;
        else {
            var c = this._period / 4;
            b = Math.pow(2, -10 * a) * Math.sin((a - c) * Math.PI * 2 / this._period) + 1
        }
        this._inner.update(b)
    },
    reverse: function() {
        return new cc.EaseElasticIn(this._inner.reverse(), this._period)
    },
    clone: function() {
        var a = new cc.EaseElasticOut;
        return a.initWithAction(this._inner.clone(), this._period), a
    }
}), cc.EaseElasticOut.create = function(a, b) {
    return new cc.EaseElasticOut(a, b)
}, cc._easeElasticOutObj = {
    easing: function(a) {
        return 0 === a || 1 === a ? a : Math.pow(2, -10 * a) * Math.sin((a - .075) * Math.PI * 2 / .3) + 1
    },
    reverse: function() {
        return cc._easeElasticInObj
    }
}, cc.easeElasticOut = function(a) {
    return a && .3 !== a ? {
        _period: a,
        easing: function(a) {
            return 0 === a || 1 === a ? a : Math.pow(2, -10 * a) * Math.sin((a - this._period / 4) * Math.PI * 2 / this._period) + 1
        },
        reverse: function() {
            return cc.easeElasticIn(this._period)
        }
    } : cc._easeElasticOutObj
}, cc.EaseElasticInOut = cc.EaseElastic.extend({
    update: function(a) {
        var b = 0,
            c = this._period;
        if (0 === a || 1 == a) b = a;
        else {
            a = 2 * a, c || (c = this._period = .3 * 1.5);
            var d = c / 4;
            a -= 1, b = 0 > a ? -.5 * Math.pow(2, 10 * a) * Math.sin((a - d) * Math.PI * 2 / c) : Math.pow(2, -10 * a) * Math.sin((a - d) * Math.PI * 2 / c) * .5 + 1
        }
        this._inner.update(b)
    },
    reverse: function() {
        return new cc.EaseElasticInOut(this._inner.reverse(), this._period)
    },
    clone: function() {
        var a = new cc.EaseElasticInOut;
        return a.initWithAction(this._inner.clone(), this._period), a
    }
}), cc.EaseElasticInOut.create = function(a, b) {
    return new cc.EaseElasticInOut(a, b)
}, cc.easeElasticInOut = function(a) {
    return a = a || .3, {
        _period: a,
        easing: function(a) {
            var b = 0,
                c = this._period;
            if (0 === a || 1 === a) b = a;
            else {
                a = 2 * a, c || (c = this._period = .3 * 1.5);
                var d = c / 4;
                a -= 1, b = 0 > a ? -.5 * Math.pow(2, 10 * a) * Math.sin((a - d) * Math.PI * 2 / c) : Math.pow(2, -10 * a) * Math.sin((a - d) * Math.PI * 2 / c) * .5 + 1
            }
            return b
        },
        reverse: function() {
            return cc.easeElasticInOut(this._period)
        }
    }
}, cc.EaseBounce = cc.ActionEase.extend({
    bounceTime: function(a) {
        return 1 / 2.75 > a ? 7.5625 * a * a : 2 / 2.75 > a ? (a -= 1.5 / 2.75, 7.5625 * a * a + .75) : 2.5 / 2.75 > a ? (a -= 2.25 / 2.75, 7.5625 * a * a + .9375) : (a -= 2.625 / 2.75, 7.5625 * a * a + .984375)
    },
    clone: function() {
        var a = new cc.EaseBounce;
        return a.initWithAction(this._inner.clone()), a
    },
    reverse: function() {
        return new cc.EaseBounce(this._inner.reverse())
    }
}), cc.EaseBounce.create = function(a) {
    return new cc.EaseBounce(a)
}, cc.EaseBounceIn = cc.EaseBounce.extend({
    update: function(a) {
        var b = 1 - this.bounceTime(1 - a);
        this._inner.update(b)
    },
    reverse: function() {
        return new cc.EaseBounceOut(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseBounceIn;
        return a.initWithAction(this._inner.clone()), a
    }
}), cc.EaseBounceIn.create = function(a) {
    return new cc.EaseBounceIn(a)
}, cc._bounceTime = function(a) {
    return 1 / 2.75 > a ? 7.5625 * a * a : 2 / 2.75 > a ? (a -= 1.5 / 2.75, 7.5625 * a * a + .75) : 2.5 / 2.75 > a ? (a -= 2.25 / 2.75, 7.5625 * a * a + .9375) : (a -= 2.625 / 2.75, 7.5625 * a * a + .984375)
}, cc._easeBounceInObj = {
    easing: function(a) {
        return 1 - cc._bounceTime(1 - a)
    },
    reverse: function() {
        return cc._easeBounceOutObj
    }
}, cc.easeBounceIn = function() {
    return cc._easeBounceInObj
}, cc.EaseBounceOut = cc.EaseBounce.extend({
    update: function(a) {
        var b = this.bounceTime(a);
        this._inner.update(b)
    },
    reverse: function() {
        return new cc.EaseBounceIn(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseBounceOut;
        return a.initWithAction(this._inner.clone()), a
    }
}), cc.EaseBounceOut.create = function(a) {
    return new cc.EaseBounceOut(a)
}, cc._easeBounceOutObj = {
    easing: function(a) {
        return cc._bounceTime(a)
    },
    reverse: function() {
        return cc._easeBounceInObj
    }
}, cc.easeBounceOut = function() {
    return cc._easeBounceOutObj
}, cc.EaseBounceInOut = cc.EaseBounce.extend({
    update: function(a) {
        var b = 0;.5 > a ? (a = 2 * a, b = .5 * (1 - this.bounceTime(1 - a))) : b = .5 * this.bounceTime(2 * a - 1) + .5, this._inner.update(b)
    },
    clone: function() {
        var a = new cc.EaseBounceInOut;
        return a.initWithAction(this._inner.clone()), a
    },
    reverse: function() {
        return new cc.EaseBounceInOut(this._inner.reverse())
    }
}), cc.EaseBounceInOut.create = function(a) {
    return new cc.EaseBounceInOut(a)
}, cc._easeBounceInOutObj = {
    easing: function(a) {
        var b;
        return .5 > a ? (a = 2 * a, b = .5 * (1 - cc._bounceTime(1 - a))) : b = .5 * cc._bounceTime(2 * a - 1) + .5, b
    },
    reverse: function() {
        return cc._easeBounceInOutObj
    }
}, cc.easeBounceInOut = function() {
    return cc._easeBounceInOutObj
}, cc.EaseBackIn = cc.ActionEase.extend({
    update: function(a) {
        var b = 1.70158;
        a = 0 === a || 1 == a ? a : a * a * ((b + 1) * a - b), this._inner.update(a)
    },
    reverse: function() {
        return new cc.EaseBackOut(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseBackIn;
        return a.initWithAction(this._inner.clone()), a
    }
}), cc.EaseBackIn.create = function(a) {
    return new cc.EaseBackIn(a)
}, cc._easeBackInObj = {
    easing: function(a) {
        var b = 1.70158;
        return 0 === a || 1 === a ? a : a * a * ((b + 1) * a - b)
    },
    reverse: function() {
        return cc._easeBackOutObj
    }
}, cc.easeBackIn = function() {
    return cc._easeBackInObj
}, cc.EaseBackOut = cc.ActionEase.extend({
    update: function(a) {
        var b = 1.70158;
        a -= 1, this._inner.update(a * a * ((b + 1) * a + b) + 1)
    },
    reverse: function() {
        return new cc.EaseBackIn(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseBackOut;
        return a.initWithAction(this._inner.clone()), a
    }
}), cc.EaseBackOut.create = function(a) {
    return new cc.EaseBackOut(a)
}, cc._easeBackOutObj = {
    easing: function(a) {
        var b = 1.70158;
        return a -= 1, a * a * ((b + 1) * a + b) + 1
    },
    reverse: function() {
        return cc._easeBackInObj
    }
}, cc.easeBackOut = function() {
    return cc._easeBackOutObj
}, cc.EaseBackInOut = cc.ActionEase.extend({
    update: function(a) {
        var b = 2.5949095;
        a = 2 * a, 1 > a ? this._inner.update(a * a * ((b + 1) * a - b) / 2) : (a -= 2, this._inner.update(a * a * ((b + 1) * a + b) / 2 + 1))
    },
    clone: function() {
        var a = new cc.EaseBackInOut;
        return a.initWithAction(this._inner.clone()), a
    },
    reverse: function() {
        return new cc.EaseBackInOut(this._inner.reverse())
    }
}), cc.EaseBackInOut.create = function(a) {
    return new cc.EaseBackInOut(a)
}, cc._easeBackInOutObj = {
    easing: function(a) {
        var b = 2.5949095;
        return a = 2 * a, 1 > a ? a * a * ((b + 1) * a - b) / 2 : (a -= 2, a * a * ((b + 1) * a + b) / 2 + 1)
    },
    reverse: function() {
        return cc._easeBackInOutObj
    }
}, cc.easeBackInOut = function() {
    return cc._easeBackInOutObj
}, cc.EaseBezierAction = cc.ActionEase.extend({
    _p0: null,
    _p1: null,
    _p2: null,
    _p3: null,
    ctor: function(a) {
        cc.ActionEase.prototype.ctor.call(this, a)
    },
    _updateTime: function(a, b, c, d, e) {
        return Math.pow(1 - e, 3) * a + 3 * e * Math.pow(1 - e, 2) * b + 3 * Math.pow(e, 2) * (1 - e) * c + Math.pow(e, 3) * d
    },
    update: function(a) {
        var b = this._updateTime(this._p0, this._p1, this._p2, this._p3, a);
        this._inner.update(b)
    },
    clone: function() {
        var a = new cc.EaseBezierAction;
        return a.initWithAction(this._inner.clone()), a.setBezierParamer(this._p0, this._p1, this._p2, this._p3), a
    },
    reverse: function() {
        var a = new cc.EaseBezierAction(this._inner.reverse());
        return a.setBezierParamer(this._p3, this._p2, this._p1, this._p0), a
    },
    setBezierParamer: function(a, b, c, d) {
        this._p0 = a || 0, this._p1 = b || 0, this._p2 = c || 0, this._p3 = d || 0
    }
}), cc.EaseBezierAction.create = function(a) {
    return new cc.EaseBezierAction(a)
}, cc.easeBezierAction = function(a, b, c, d) {
    return {
        easing: function(e) {
            return cc.EaseBezierAction.prototype._updateTime(a, b, c, d, e)
        },
        reverse: function() {
            return cc.easeBezierAction(d, c, b, a)
        }
    }
}, cc.EaseQuadraticActionIn = cc.ActionEase.extend({
    _updateTime: function(a) {
        return Math.pow(a, 2)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuadraticActionIn;
        return a.initWithAction(this._inner.clone()), a
    },
    reverse: function() {
        return new cc.EaseQuadraticActionIn(this._inner.reverse())
    }
}), cc.EaseQuadraticActionIn.create = function(a) {
    return new cc.EaseQuadraticActionIn(a)
}, cc._easeQuadraticActionIn = {
    easing: cc.EaseQuadraticActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeQuadraticActionIn
    }
}, cc.easeQuadraticActionIn = function() {
    return cc._easeQuadraticActionIn
}, cc.EaseQuadraticActionOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        return -a * (a - 2)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuadraticActionOut;
        return a.initWithAction(), a
    },
    reverse: function() {
        return new cc.EaseQuadraticActionOut(this._inner.reverse())
    }
}), cc.EaseQuadraticActionOut.create = function(a) {
    return new cc.EaseQuadraticActionOut(a)
}, cc._easeQuadraticActionOut = {
    easing: cc.EaseQuadraticActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuadraticActionOut
    }
}, cc.easeQuadraticActionOut = function() {
    return cc._easeQuadraticActionOut
}, cc.EaseQuadraticActionInOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        var b = a;
        return a *= 2, 1 > a ? b = a * a * .5 : (--a, b = -.5 * (a * (a - 2) - 1)), b
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuadraticActionInOut;
        return a.initWithAction(this._inner.clone()), a
    },
    reverse: function() {
        return new cc.EaseQuadraticActionInOut(this._inner.reverse())
    }
}), cc.EaseQuadraticActionInOut.create = function(a) {
    return new cc.EaseQuadraticActionInOut(a)
}, cc._easeQuadraticActionInOut = {
    easing: cc.EaseQuadraticActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuadraticActionInOut
    }
}, cc.easeQuadraticActionInOut = function() {
    return cc._easeQuadraticActionInOut
}, cc.EaseQuarticActionIn = cc.ActionEase.extend({
    _updateTime: function(a) {
        return a * a * a * a
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuarticActionIn;
        return a.initWithAction(this._inner.clone()), a
    },
    reverse: function() {
        return new cc.EaseQuarticActionIn(this._inner.reverse())
    }
}), cc.EaseQuarticActionIn.create = function(a) {
    return new cc.EaseQuarticActionIn(a)
}, cc._easeQuarticActionIn = {
    easing: cc.EaseQuarticActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeQuarticActionIn
    }
}, cc.easeQuarticActionIn = function() {
    return cc._easeQuarticActionIn
}, cc.EaseQuarticActionOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        return a -= 1, -(a * a * a * a - 1)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuarticActionOut;
        return a.initWithAction(this._inner.clone()), a
    },
    reverse: function() {
        return new cc.EaseQuarticActionOut(this._inner.reverse())
    }
}), cc.EaseQuarticActionOut.create = function(a) {
    return new cc.EaseQuarticActionOut(a)
}, cc._easeQuarticActionOut = {
    easing: cc.EaseQuarticActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuarticActionOut
    }
}, cc.easeQuarticActionOut = function() {
    return cc._easeQuarticActionOut
}, cc.EaseQuarticActionInOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        return a = 2 * a, 1 > a ? .5 * a * a * a * a : (a -= 2, -.5 * (a * a * a * a - 2))
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuarticActionInOut;
        return a.initWithAction(this._inner.clone()), a
    },
    reverse: function() {
        return new cc.EaseQuarticActionInOut(this._inner.reverse())
    }
}), cc.EaseQuarticActionInOut.create = function(a) {
    return new cc.EaseQuarticActionInOut(a)
}, cc._easeQuarticActionInOut = {
    easing: cc.EaseQuarticActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuarticActionInOut
    }
}, cc.easeQuarticActionInOut = function() {
    return cc._easeQuarticActionInOut
}, cc.EaseQuinticActionIn = cc.ActionEase.extend({
    _updateTime: function(a) {
        return a * a * a * a * a
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuinticActionIn;
        return a.initWithAction(this._inner.clone()), a
    },
    reverse: function() {
        return new cc.EaseQuinticActionIn(this._inner.reverse())
    }
}), cc.EaseQuinticActionIn.create = function(a) {
    return new cc.EaseQuinticActionIn(a)
}, cc._easeQuinticActionIn = {
    easing: cc.EaseQuinticActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeQuinticActionIn
    }
}, cc.easeQuinticActionIn = function() {
    return cc._easeQuinticActionIn
}, cc.EaseQuinticActionOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        return a -= 1, a * a * a * a * a + 1
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuinticActionOut;
        return a.initWithAction(this._inner.clone()), a
    },
    reverse: function() {
        return new cc.EaseQuinticActionOut(this._inner.reverse())
    }
}), cc.EaseQuinticActionOut.create = function(a) {
    return new cc.EaseQuinticActionOut(a)
}, cc._easeQuinticActionOut = {
    easing: cc.EaseQuinticActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuinticActionOut
    }
}, cc.easeQuinticActionOut = function() {
    return cc._easeQuinticActionOut
}, cc.EaseQuinticActionInOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        return a = 2 * a, 1 > a ? .5 * a * a * a * a * a : (a -= 2, .5 * (a * a * a * a * a + 2))
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuinticActionInOut;
        return a.initWithAction(this._inner.clone()), a
    },
    reverse: function() {
        return new cc.EaseQuinticActionInOut(this._inner.reverse())
    }
}), cc.EaseQuinticActionInOut.create = function(a) {
    return new cc.EaseQuinticActionInOut(a)
}, cc._easeQuinticActionInOut = {
    easing: cc.EaseQuinticActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuinticActionInOut
    }
}, cc.easeQuinticActionInOut = function() {
    return cc._easeQuinticActionInOut
}, cc.EaseCircleActionIn = cc.ActionEase.extend({
    _updateTime: function(a) {
        return -1 * (Math.sqrt(1 - a * a) - 1)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseCircleActionIn;
        return a.initWithAction(this._inner.clone()), a
    },
    reverse: function() {
        return new cc.EaseCircleActionIn(this._inner.reverse())
    }
}), cc.EaseCircleActionIn.create = function(a) {
    return new cc.EaseCircleActionIn(a)
}, cc._easeCircleActionIn = {
    easing: cc.EaseCircleActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeCircleActionIn
    }
}, cc.easeCircleActionIn = function() {
    return cc._easeCircleActionIn
}, cc.EaseCircleActionOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        return a -= 1, Math.sqrt(1 - a * a)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseCircleActionOut;
        return a.initWithAction(this._inner.clone()), a
    },
    reverse: function() {
        return new cc.EaseCircleActionOut(this._inner.reverse())
    }
}), cc.EaseCircleActionOut.create = function(a) {
    return new cc.EaseCircleActionOut(a)
}, cc._easeCircleActionOut = {
    easing: cc.EaseCircleActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeCircleActionOut
    }
}, cc.easeCircleActionOut = function() {
    return cc._easeCircleActionOut
}, cc.EaseCircleActionInOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        return a = 2 * a, 1 > a ? -.5 * (Math.sqrt(1 - a * a) - 1) : (a -= 2, .5 * (Math.sqrt(1 - a * a) + 1))
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseCircleActionInOut;
        return a.initWithAction(this._inner.clone()), a
    },
    reverse: function() {
        return new cc.EaseCircleActionInOut(this._inner.reverse())
    }
}), cc.EaseCircleActionInOut.create = function(a) {
    return new cc.EaseCircleActionInOut(a)
}, cc._easeCircleActionInOut = {
    easing: cc.EaseCircleActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeCircleActionInOut
    }
}, cc.easeCircleActionInOut = function() {
    return cc._easeCircleActionInOut
}, cc.EaseCubicActionIn = cc.ActionEase.extend({
    _updateTime: function(a) {
        return a * a * a
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseCubicActionIn;
        return a.initWithAction(this._inner.clone()), a
    },
    reverse: function() {
        return new cc.EaseCubicActionIn(this._inner.reverse())
    }
}), cc.EaseCubicActionIn.create = function(a) {
    return new cc.EaseCubicActionIn(a)
}, cc._easeCubicActionIn = {
    easing: cc.EaseCubicActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeCubicActionIn
    }
}, cc.easeCubicActionIn = function() {
    return cc._easeCubicActionIn
}, cc.EaseCubicActionOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        return a -= 1, a * a * a + 1
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseCubicActionOut;
        return a.initWithAction(this._inner.clone()), a
    },
    reverse: function() {
        return new cc.EaseCubicActionOut(this._inner.reverse())
    }
}), cc.EaseCubicActionOut.create = function(a) {
    return new cc.EaseCubicActionOut(a)
}, cc._easeCubicActionOut = {
    easing: cc.EaseCubicActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeCubicActionOut
    }
}, cc.easeCubicActionOut = function() {
    return cc._easeCubicActionOut
}, cc.EaseCubicActionInOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        return a = 2 * a, 1 > a ? .5 * a * a * a : (a -= 2, .5 * (a * a * a + 2))
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseCubicActionInOut;
        return a.initWithAction(this._inner.clone()), a
    },
    reverse: function() {
        return new cc.EaseCubicActionInOut(this._inner.reverse())
    }
}), cc.EaseCubicActionInOut.create = function(a) {
    return new cc.EaseCubicActionInOut(a)
}, cc._easeCubicActionInOut = {
    easing: cc.EaseCubicActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeCubicActionInOut
    }
}, cc.easeCubicActionInOut = function() {
    return cc._easeCubicActionInOut
}, cc.cardinalSplineAt = function(a, b, c, d, e, f) {
    var g = f * f,
        h = g * f,
        i = (1 - e) / 2,
        j = i * (-h + 2 * g - f),
        k = i * (-h + g) + (2 * h - 3 * g + 1),
        l = i * (h - 2 * g + f) + (-2 * h + 3 * g),
        m = i * (h - g),
        n = a.x * j + b.x * k + c.x * l + d.x * m,
        o = a.y * j + b.y * k + c.y * l + d.y * m;
    return cc.p(n, o)
}, cc.reverseControlPoints = function(a) {
    for (var b = [], c = a.length - 1; c >= 0; c--) b.push(cc.p(a[c].x, a[c].y));
    return b
}, cc.cloneControlPoints = function(a) {
    for (var b = [], c = 0; c < a.length; c++) b.push(cc.p(a[c].x, a[c].y));
    return b
}, cc.copyControlPoints = cc.cloneControlPoints, cc.getControlPointAt = function(a, b) {
    var c = Math.min(a.length - 1, Math.max(b, 0));
    return a[c]
}, cc.reverseControlPointsInline = function(a) {
    for (var b = a.length, c = 0 | b / 2, d = 0; c > d; ++d) {
        var e = a[d];
        a[d] = a[b - d - 1], a[b - d - 1] = e
    }
}, cc.CardinalSplineTo = cc.ActionInterval.extend({
    _points: null,
    _deltaT: 0,
    _tension: 0,
    _previousPosition: null,
    _accumulatedDiff: null,
    ctor: function(a, b, c) {
        cc.ActionInterval.prototype.ctor.call(this), this._points = [], void 0 !== c && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        if (!b || 0 == b.length) throw "Invalid configuration. It must at least have one control point";
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this.setPoints(b), this._tension = c, !0) : !1
    },
    clone: function() {
        var a = new cc.CardinalSplineTo;
        return a.initWithDuration(this._duration, cc.copyControlPoints(this._points), this._tension), a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a), this._deltaT = 1 / (this._points.length - 1), this._previousPosition = cc.p(this.target.getPositionX(), this.target.getPositionY()), this._accumulatedDiff = cc.p(0, 0)
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        var b, c, d = this._points;
        if (1 == a) b = d.length - 1, c = 1;
        else {
            var e = this._deltaT;
            b = 0 | a / e, c = (a - e * b) / e
        }
        var f = cc.cardinalSplineAt(cc.getControlPointAt(d, b - 1), cc.getControlPointAt(d, b - 0), cc.getControlPointAt(d, b + 1), cc.getControlPointAt(d, b + 2), this._tension, c);
        if (cc.ENABLE_STACKABLE_ACTIONS) {
            var g, h;
            if (g = this.target.getPositionX() - this._previousPosition.x, h = this.target.getPositionY() - this._previousPosition.y, 0 != g || 0 != h) {
                var i = this._accumulatedDiff;
                g = i.x + g, h = i.y + h, i.x = g, i.y = h, f.x += g, f.y += h
            }
        }
        this.updatePosition(f)
    },
    reverse: function() {
        var a = cc.reverseControlPoints(this._points);
        return cc.cardinalSplineTo(this._duration, a, this._tension)
    },
    updatePosition: function(a) {
        this.target.setPosition(a), this._previousPosition = a
    },
    getPoints: function() {
        return this._points
    },
    setPoints: function(a) {
        this._points = a
    }
}), cc.cardinalSplineTo = function(a, b, c) {
    return new cc.CardinalSplineTo(a, b, c)
}, cc.CardinalSplineTo.create = cc.cardinalSplineTo, cc.CardinalSplineBy = cc.CardinalSplineTo.extend({
    _startPosition: null,
    ctor: function(a, b, c) {
        cc.CardinalSplineTo.prototype.ctor.call(this), this._startPosition = cc.p(0, 0), void 0 !== c && this.initWithDuration(a, b, c)
    },
    startWithTarget: function(a) {
        cc.CardinalSplineTo.prototype.startWithTarget.call(this, a), this._startPosition.x = a.getPositionX(), this._startPosition.y = a.getPositionY()
    },
    reverse: function() {
        for (var a, b = this._points.slice(), c = b[0], d = 1; d < b.length; ++d) a = b[d], b[d] = cc.pSub(a, c), c = a;
        var e = cc.reverseControlPoints(b);
        c = e[e.length - 1], e.pop(), c.x = -c.x, c.y = -c.y, e.unshift(c);
        for (var d = 1; d < e.length; ++d) a = e[d], a.x = -a.x, a.y = -a.y, a.x += c.x, a.y += c.y, e[d] = a, c = a;
        return cc.cardinalSplineBy(this._duration, e, this._tension)
    },
    updatePosition: function(a) {
        var b = this._startPosition,
            c = a.x + b.x,
            d = a.y + b.y;
        this._previousPosition.x = c, this._previousPosition.y = d, this.target.setPosition(c, d)
    },
    clone: function() {
        var a = new cc.CardinalSplineBy;
        return a.initWithDuration(this._duration, cc.copyControlPoints(this._points), this._tension), a
    }
}), cc.cardinalSplineBy = function(a, b, c) {
    return new cc.CardinalSplineBy(a, b, c)
}, cc.CardinalSplineBy.create = cc.cardinalSplineBy, cc.CatmullRomTo = cc.CardinalSplineTo.extend({
    ctor: function(a, b) {
        b && this.initWithDuration(a, b)
    },
    initWithDuration: function(a, b) {
        return cc.CardinalSplineTo.prototype.initWithDuration.call(this, a, b, .5)
    },
    clone: function() {
        var a = new cc.CatmullRomTo;
        return a.initWithDuration(this._duration, cc.copyControlPoints(this._points)), a
    }
}), cc.catmullRomTo = function(a, b) {
    return new cc.CatmullRomTo(a, b)
}, cc.CatmullRomTo.create = cc.catmullRomTo, cc.CatmullRomBy = cc.CardinalSplineBy.extend({
    ctor: function(a, b) {
        cc.CardinalSplineBy.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    initWithDuration: function(a, b) {
        return cc.CardinalSplineTo.prototype.initWithDuration.call(this, a, b, .5)
    },
    clone: function() {
        var a = new cc.CatmullRomBy;
        return a.initWithDuration(this._duration, cc.copyControlPoints(this._points)), a
    }
}), cc.catmullRomBy = function(a, b) {
    return new cc.CatmullRomBy(a, b)
}, cc.CatmullRomBy.create = cc.catmullRomBy, cc.ActionTweenDelegate = cc.Class.extend({
    updateTweenAction: function() {}
}), cc.ActionTween = cc.ActionInterval.extend({
    key: "",
    from: 0,
    to: 0,
    delta: 0,
    ctor: function(a, b, c, d) {
        cc.ActionInterval.prototype.ctor.call(this), this.key = "", void 0 !== d && this.initWithDuration(a, b, c, d)
    },
    initWithDuration: function(a, b, c, d) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this.key = b, this.to = d, this.from = c, !0) : !1
    },
    startWithTarget: function(a) {
        if (!a || !a.updateTweenAction) throw "cc.ActionTween.startWithTarget(): target must be non-null, and target must implement updateTweenAction function";
        cc.ActionInterval.prototype.startWithTarget.call(this, a), this.delta = this.to - this.from
    },
    update: function(a) {
        this.target.updateTweenAction(this.to - this.delta * (1 - a), this.key)
    },
    reverse: function() {
        return new cc.ActionTween(this.duration, this.key, this.to, this.from)
    },
    clone: function() {
        var a = new cc.ActionTween;
        return a.initWithDuration(this._duration, this.key, this.from, this.to), a
    }
}), cc.actionTween = function(a, b, c, d) {
    return new cc.ActionTween(a, b, c, d)
}, cc.ActionTween.create = cc.actionTween;
! function() {
    var a = !1,
        b = cc.sys,
        c = {
            common: {
                multichannel: !0,
                webAudio: cc.sys._supportWebAudio,
                auto: !0
            }
        };
    c[b.BROWSER_TYPE_IE] = {
        multichannel: !0,
        webAudio: cc.sys._supportWebAudio,
        auto: !0,
        emptied: !0
    }, c[b.BROWSER_TYPE_ANDROID] = {
        multichannel: !1,
        webAudio: !1,
        auto: !1
    }, c[b.BROWSER_TYPE_CHROME] = {
        multichannel: !0,
        webAudio: !0,
        auto: !1
    }, c[b.BROWSER_TYPE_FIREFOX] = {
        multichannel: !0,
        webAudio: !0,
        auto: !0
    }, c[b.BROWSER_TYPE_UC] = {
        multichannel: !0,
        webAudio: !1,
        auto: !1
    }, c[b.BROWSER_TYPE_QQ] = {
        multichannel: !1,
        webAudio: !1,
        auto: !0
    }, c[b.BROWSER_TYPE_OUPENG] = {
        multichannel: !1,
        webAudio: !1,
        auto: !1,
        replay: !0,
        emptied: !0
    }, c[b.BROWSER_TYPE_WECHAT] = {
        multichannel: !1,
        webAudio: !1,
        auto: !1,
        replay: !0,
        emptied: !0
    }, c[b.BROWSER_TYPE_360] = {
        multichannel: !1,
        webAudio: !1,
        auto: !0
    }, c[b.BROWSER_TYPE_MIUI] = {
        multichannel: !1,
        webAudio: !1,
        auto: !0
    }, c[b.BROWSER_TYPE_BAIDU] = {
        multichannel: !1,
        webAudio: !1,
        auto: !0,
        emptied: !0
    }, c[b.BROWSER_TYPE_BAIDU_APP] = {
        multichannel: !1,
        webAudio: !1,
        auto: !0,
        emptied: !0
    }, c[b.BROWSER_TYPE_LIEBAO] = {
        multichannel: !1,
        webAudio: !1,
        auto: !1,
        replay: !0,
        emptied: !0
    }, c[b.BROWSER_TYPE_SOUGOU] = {
        multichannel: !1,
        webAudio: !1,
        auto: !1,
        replay: !0,
        emptied: !0
    }, c[b.BROWSER_TYPE_SAFARI] = {
        multichannel: !0,
        webAudio: !0,
        auto: !1,
        webAudioCallback: function(a) {
            document.createElement("audio").src = a
        }
    };
    var d, e;
    try {
        var f = navigator.userAgent.toLowerCase();
        switch (b.browserType) {
            case b.BROWSER_TYPE_IE:
                e = f.match(/(msie |rv:)([\d.]+)/);
                break;
            case b.BROWSER_TYPE_FIREFOX:
                e = f.match(/(firefox\/|rv:)([\d.]+)/);
                break;
            case b.BROWSER_TYPE_CHROME:
                e = f.match(/chrome\/([\d.]+)/);
                break;
            case b.BROWSER_TYPE_BAIDU:
                e = f.match(/baidubrowser\/([\d.]+)/);
                break;
            case b.BROWSER_TYPE_UC:
                e = f.match(/ucbrowser\/([\d.]+)/);
                break;
            case b.BROWSER_TYPE_QQ:
                e = f.match(/qqbrowser\/([\d.]+)/);
                break;
            case b.BROWSER_TYPE_OUPENG:
                e = f.match(/oupeng\/([\d.]+)/);
                break;
            case b.BROWSER_TYPE_WECHAT:
                e = f.match(/micromessenger\/([\d.]+)/);
                break;
            case b.BROWSER_TYPE_SAFARI:
                e = f.match(/safari\/([\d.]+)/);
                break;
            case b.BROWSER_TYPE_MIUI:
                e = f.match(/miuibrowser\/([\d.]+)/)
        }
        d = e ? e[1] : ""
    } catch (g) {
        console.log(g)
    }
    if (d) switch (b.browserType) {
        case b.BROWSER_TYPE_CHROME:
            parseInt(d) < 30 && (c[b.BROWSER_TYPE_CHROME] = {
                multichannel: !1,
                webAudio: !0,
                auto: !1
            });
            break;
        case b.BROWSER_TYPE_MIUI:
            d = d.match(/\d+/g), (d[0] < 2 || 2 == d[0] && 0 == d[1] && d[2] <= 1) && (c[b.BROWSER_TYPE_MIUI].auto = !1)
    }
    cc.__audioSupport = cc.sys.isMobile ? cc.sys.os != cc.sys.OS_IOS ? c[b.browserType] || c.common : c[b.BROWSER_TYPE_SAFARI] : cc.sys.browserType != cc.sys.BROWSER_TYPE_IE ? c.common : c[b.BROWSER_TYPE_IE], a && setTimeout(function() {
        cc.log("browse type: " + b.browserType), cc.log("browse version: " + d), cc.log("multichannel: " + cc.__audioSupport.multichannel), cc.log("webAudio: " + cc.__audioSupport.webAudio), cc.log("auto: " + cc.__audioSupport.auto)
    }, 0)
}(), cc.Audio = cc.Class.extend({
        volume: 1,
        loop: !1,
        src: null,
        _touch: !1,
        _playing: !1,
        _AUDIO_TYPE: "AUDIO",
        _pause: !1,
        _buffer: null,
        _currentSource: null,
        _startTime: null,
        _currentTime: null,
        _context: null,
        _volume: null,
        _element: null,
        ctor: function(a, b, c) {
            a && (this._context = a), b && (this._volume = b), a && b && (this._AUDIO_TYPE = "WEBAUDIO"), this.src = c
        },
        _setBufferCallback: null,
        setBuffer: function(a) {
            if (a) {
                var b = this._playing;
                this._AUDIO_TYPE = "WEBAUDIO", this._buffer && this._buffer != a && this.getPlaying() && this.stop(), this._buffer = a, b && this.play(), this._volume.gain.value = this.volume, this._setBufferCallback && this._setBufferCallback(a)
            }
        },
        _setElementCallback: null,
        setElement: function(a) {
            if (a) {
                var b = this._playing;
                this._AUDIO_TYPE = "AUDIO", this._element && this._element != a && this.getPlaying() && this.stop(), this._element = a, b && this.play(), a.volume = this.volume, a.loop = this.loop, this._setElementCallback && this._setElementCallback(a)
            }
        },
        play: function(a, b) {
            this._playing = !0, this.loop = void 0 === b ? this.loop : b, "AUDIO" === this._AUDIO_TYPE ? this._playOfAudio(a) : this._playOfWebAudio(a)
        },
        getPlaying: function() {
            if (!this._playing) return this._playing;
            if ("AUDIO" === this._AUDIO_TYPE) {
                var a = this._element;
                return !a || this._pause ? (this._playing = !1, !1) : a.ended ? (this._playing = !1, !1) : !0
            }
            var b = this._currentSource;
            return this._playing || b ? null == b.playbackState ? this._playing : this._currentTime + this._context.currentTime - this._startTime < this._currentSource.buffer.duration : !0
        },
        _playOfWebAudio: function(a) {
            var b = this._currentSource;
            if (this._buffer) {
                if (!this._pause && b) {
                    if (!(0 === this._context.currentTime || this._currentTime + this._context.currentTime - this._startTime > this._currentSource.buffer.duration)) return;
                    this._stopOfWebAudio()
                }
                var c = this._context.createBufferSource();
                if (c.buffer = this._buffer, c.connect(this._volume), c.loop = this.loop, this._startTime = this._context.currentTime, this._currentTime = 0, c.start) c.start(0, a || 0);
                else if (c.noteGrainOn) {
                    var d = c.buffer.duration;
                    this.loop ? c.noteGrainOn(0, a, d) : c.noteGrainOn(0, a, d - a)
                } else c.noteOn(0);
                this._currentSource = c;
                var e = this;
                c.onended = function() {
                    e._playing = !1
                }
            }
        },
        _playOfAudio: function() {
            var a = this._element;
            a && (a.loop = this.loop, a.play())
        },
        stop: function() {
            this._playing = !1, "AUDIO" === this._AUDIO_TYPE ? this._stopOfAudio() : this._stopOfWebAudio()
        },
        _stopOfWebAudio: function() {
            var a = this._currentSource;
            a && (a.stop(0), this._currentSource = null)
        },
        _stopOfAudio: function() {
            var a = this._element;
            a && (a.pause(), a.duration && 1 / 0 != a.duration && (a.currentTime = 0))
        },
        pause: function() {
            this._playing = !1, this._pause = !0, "AUDIO" === this._AUDIO_TYPE ? this._pauseOfAudio() : this._pauseOfWebAudio()
        },
        _pauseOfWebAudio: function() {
            this._currentTime += this._context.currentTime - this._startTime;
            var a = this._currentSource;
            a && a.stop(0)
        },
        _pauseOfAudio: function() {
            var a = this._element;
            a && a.pause()
        },
        resume: function() {
            this._pause && ("AUDIO" === this._AUDIO_TYPE ? this._resumeOfAudio() : this._resumeOfWebAudio(), this._pause = !1, this._playing = !0)
        },
        _resumeOfWebAudio: function() {
            var a = this._currentSource;
            if (a) {
                this._startTime = this._context.currentTime;
                var b = this._currentTime % a.buffer.duration;
                this._playOfWebAudio(b)
            }
        },
        _resumeOfAudio: function() {
            var a = this._element;
            a && a.play()
        },
        setVolume: function(a) {
            a > 1 && (a = 1), 0 > a && (a = 0), this.volume = a, "AUDIO" === this._AUDIO_TYPE ? this._element && (this._element.volume = a) : this._volume && (this._volume.gain.value = a)
        },
        getVolume: function() {
            return this.volume
        },
        cloneNode: function() {
            var a, b;
            if ("AUDIO" === this._AUDIO_TYPE) {
                a = new cc.Audio;
                var c = document.createElement("audio");
                c.src = this.src, a.setElement(c)
            } else {
                var d = this._context.createGain();
                d.gain.value = 1, d.connect(this._context.destination), a = new cc.Audio(this._context, d, this.src), this._buffer ? a.setBuffer(this._buffer) : (b = this, this._setBufferCallback = function(c) {
                    a.setBuffer(c), b._setBufferCallback = null
                })
            }
            return a._AUDIO_TYPE = this._AUDIO_TYPE, a
        }
    }),
    function(a) {
        var b = a.webAudio,
            c = a.multichannel,
            d = a.auto,
            e = [];
        ! function() {
            var a = document.createElement("audio");
            if (a.canPlayType) {
                var b = a.canPlayType('audio/ogg; codecs="vorbis"');
                b && "" !== b && e.push(".ogg");
                var c = a.canPlayType("audio/mpeg");
                c && "" !== c && e.push(".mp3");
                var d = a.canPlayType('audio/wav; codecs="1"');
                d && "" !== d && e.push(".wav");
                var f = a.canPlayType("audio/mp4");
                f && "" !== f && e.push(".mp4");
                var g = a.canPlayType("audio/x-m4a");
                g && "" !== g && e.push(".m4a")
            }
        }();
        try {
            if (b) var f = new(window.AudioContext || window.webkitAudioContext || window.mozAudioContext)
        } catch (g) {
            b = !1, cc.log("browser don't support webAudio")
        }
        var h = {
            cache: {},
            load: function(a, c, d, g) {
                if (0 === e.length) return g("can not support audio!");
                var i, j = cc.path.extname(a),
                    k = [j];
                for (i = 0; i < e.length; i++) j !== e[i] && k.push(e[i]);
                var l;
                if (h.cache[a]) return g(null, h.cache[a]);
                if (b) {
                    var m = f.createGain();
                    m.gain.value = 1, m.connect(f.destination), l = new cc.Audio(f, m, a)
                } else l = new cc.Audio(null, null, a);
                this.loadAudioFromExtList(a, k, l, g), h.cache[a] = l
            },
            loadAudioFromExtList: function(c, d, g, i) {
                if (0 === d.length) {
                    var j = "can not found the resource of audio! Last match url is : ";
                    return j += c.replace(/\.(.*)?$/, "("), e.forEach(function(a) {
                        j += a + "|"
                    }), j = j.replace(/\|$/, ")"), i(j)
                }
                if (c = cc.path.changeExtname(c, d.splice(0, 1)), b) {
                    a.webAudioCallback && a.webAudioCallback(c);
                    var k = new XMLHttpRequest;
                    k.open("GET", c, !0), k.responseType = "arraybuffer", k.onload = function() {
                        f.decodeAudioData(k.response, function(a) {
                            g.setBuffer(a), i(null, g)
                        }, function() {
                            h.loadAudioFromExtList(c, d, g, i)
                        })
                    }, k.send()
                } else {
                    var l = document.createElement("audio"),
                        m = !1,
                        n = !1,
                        o = setTimeout(function() {
                            0 == l.readyState ? r() : (n = !0, i("audio load timeout : " + c, g))
                        }, 1e4),
                        p = function() {
                            m || (g.setElement(l), l.removeEventListener("canplaythrough", p, !1), l.removeEventListener("error", q, !1), l.removeEventListener("emptied", r, !1), !n && i(null, g), m = !0, clearTimeout(o))
                        },
                        q = function() {
                            m && (l.removeEventListener("canplaythrough", p, !1), l.removeEventListener("error", q, !1), l.removeEventListener("emptied", r, !1), !n && h.loadAudioFromExtList(c, d, g, i), m = !0, clearTimeout(o))
                        },
                        r = function() {
                            n = !0, p(), i(null, g)
                        };
                    cc._addEventListener(l, "canplaythrough", p, !1), cc._addEventListener(l, "error", q, !1), a.emptied && cc._addEventListener(l, "emptied", r, !1), l.src = c, l.load()
                }
            }
        };
        if (cc.loader.register(["mp3", "ogg", "wav", "mp4", "m4a"], h), cc.audioEngine = {
            _currMusic: null,
            _musicVolume: 1,
            willPlayMusic: function() {
                return !1
            },
            playMusic: function(a, b) {
                var c = this._currMusic;
                c && c.src !== a && c.getPlaying() && c.stop();
                var d = h.cache[a];
                d || (cc.loader.load(a), d = h.cache[a]), d.play(0, b), d.setVolume(this._musicVolume), this._currMusic = d
            },
            stopMusic: function(a) {
                var b = this._currMusic;
                b && (b.stop(), a && cc.loader.release(b.src))
            },
            pauseMusic: function() {
                var a = this._currMusic;
                a && a.pause()
            },
            resumeMusic: function() {
                var a = this._currMusic;
                a && a.resume()
            },
            rewindMusic: function() {
                var a = this._currMusic;
                a && (a.stop(), a.play())
            },
            getMusicVolume: function() {
                return this._musicVolume
            },
            setMusicVolume: function(a) {
                a -= 0, isNaN(a) && (a = 1), a > 1 && (a = 1), 0 > a && (a = 0), this._musicVolume = a;
                var b = this._currMusic;
                b && b.setVolume(a)
            },
            isMusicPlaying: function() {
                var a = this._currMusic;
                return a ? a.getPlaying() : !1
            },
            _audioPool: {},
            _maxAudioInstance: 5,
            _effectVolume: 1,
            playEffect: function(a, d) {
                if (!c) return null;
                var e = this._audioPool[a];
                e || (e = this._audioPool[a] = []);
                var f;
                for (f = 0; f < e.length && e[f].getPlaying(); f++);
                if (e[f]) g = e[f], g.setVolume(this._effectVolume), g.play(0, d);
                else if (!b && f > this._maxAudioInstance) cc.log("Error: %s greater than %d", a, this._maxAudioInstance);
                else {
                    var g = h.cache[a];
                    g || (cc.loader.load(a), g = h.cache[a]), g = g.cloneNode(), g.setVolume(this._effectVolume), g.loop = d || !1, g.play(), e.push(g)
                }
                return g
            },
            setEffectsVolume: function(a) {
                a -= 0, isNaN(a) && (a = 1), a > 1 && (a = 1), 0 > a && (a = 0), this._effectVolume = a;
                var b = this._audioPool;
                for (var c in b) {
                    var d = b[c];
                    if (Array.isArray(d))
                        for (var e = 0; e < d.length; e++) d[e].setVolume(a)
                }
            },
            getEffectsVolume: function() {
                return this._effectVolume
            },
            pauseEffect: function(a) {
                a && a.pause()
            },
            pauseAllEffects: function() {
                var a = this._audioPool;
                for (var b in a)
                    for (var c = a[b], d = 0; d < a[b].length; d++) c[d].getPlaying() && c[d].pause()
            },
            resumeEffect: function(a) {
                a && a.resume()
            },
            resumeAllEffects: function() {
                var a = this._audioPool;
                for (var b in a)
                    for (var c = a[b], d = 0; d < a[b].length; d++) c[d].resume()
            },
            stopEffect: function(a) {
                a && a.stop()
            },
            stopAllEffects: function() {
                var a = this._audioPool;
                for (var b in a)
                    for (var c = a[b], d = 0; d < a[b].length; d++) c[d].stop()
            },
            unloadEffect: function(a) {
                if (a) {
                    cc.loader.release(a);
                    var b = this._audioPool[a];
                    b && (b.length = 0), delete this._audioPool[a], delete h.cache[a]
                }
            },
            end: function() {
                this.stopMusic(), this.stopAllEffects()
            },
            _pauseCache: [],
            _pausePlaying: function() {
                var a = this._currMusic;
                a && a.getPlaying() && (a.pause(), this._pauseCache.push(a));
                var b = this._audioPool;
                for (var c in b)
                    for (var d = b[c], e = 0; e < b[c].length; e++) d[e].getPlaying() && (d[e].pause(), this._pauseCache.push(d[e]))
            },
            _resumePlaying: function() {
                for (var a = this._pauseCache, b = 0; b < a.length; b++) a[b].resume();
                a.length = 0
            }
        }, !d) {
            var i = function() {
                var b = cc.audioEngine._currMusic;
                b && b._touch === !1 && b._playing && b.getPlaying() && (b._touch = !0, b.play(0, b.loop), !a.replay && cc._canvas.removeEventListener("touchstart", i))
            };
            setTimeout(function() {
                cc._canvas && cc._canvas.addEventListener("touchstart", i, !1)
            }, 150)
        }
        cc.eventManager.addCustomListener(cc.game.EVENT_HIDE, function() {
            cc.audioEngine._pausePlaying()
        }), cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function() {
            cc.audioEngine._resumePlaying()
        })
    }(cc.__audioSupport);
cc._globalFontSize = cc.ITEM_SIZE, cc._globalFontName = "Arial", cc._globalFontNameRelease = !1, cc.MenuItem = cc.Node.extend({
    _enabled: !1,
    _target: null,
    _callback: null,
    _isSelected: !1,
    _className: "MenuItem",
    ctor: function(a, b) {
        var c = cc.Node.prototype;
        c.ctor.call(this), this._target = null, this._callback = null, this._isSelected = !1, this._enabled = !1, c.setAnchorPoint.call(this, .5, .5), this._target = b || null, this._callback = a || null, this._callback && (this._enabled = !0)
    },
    isSelected: function() {
        return this._isSelected
    },
    setOpacityModifyRGB: function() {},
    isOpacityModifyRGB: function() {
        return !1
    },
    setTarget: function(a, b) {
        this._target = b, this._callback = a
    },
    isEnabled: function() {
        return this._enabled
    },
    setEnabled: function(a) {
        this._enabled = a
    },
    initWithCallback: function(a, b) {
        return this.anchorX = .5, this.anchorY = .5, this._target = b, this._callback = a, this._enabled = !0, this._isSelected = !1, !0
    },
    rect: function() {
        var a = this._position,
            b = this._contentSize,
            c = this._anchorPoint;
        return cc.rect(a.x - b.width * c.x, a.y - b.height * c.y, b.width, b.height)
    },
    selected: function() {
        this._isSelected = !0
    },
    unselected: function() {
        this._isSelected = !1
    },
    setCallback: function(a, b) {
        this._target = b, this._callback = a
    },
    activate: function() {
        if (this._enabled) {
            var a = this._target,
                b = this._callback;
            if (!b) return;
            a && cc.isString(b) ? a[b](this) : a && cc.isFunction(b) ? b.call(a, this) : b(this)
        }
    }
});
var _p = cc.MenuItem.prototype;
_p.enabled, cc.defineGetterSetter(_p, "enabled", _p.isEnabled, _p.setEnabled), cc.MenuItem.create = function(a, b) {
    return new cc.MenuItem(a, b)
}, cc.MenuItemLabel = cc.MenuItem.extend({
    _disabledColor: null,
    _label: null,
    _originalScale: 0,
    _colorBackup: null,
    ctor: function(a, b, c) {
        cc.MenuItem.prototype.ctor.call(this, b, c), this._disabledColor = null, this._label = null, this._colorBackup = null, a && (this._originalScale = 1, this._colorBackup = cc.color.WHITE, this._disabledColor = cc.color(126, 126, 126), this.setLabel(a), this.cascadeColor = !0, this.cascadeOpacity = !0)
    },
    getDisabledColor: function() {
        return this._disabledColor
    },
    setDisabledColor: function(a) {
        this._disabledColor = a
    },
    getLabel: function() {
        return this._label
    },
    setLabel: function(a) {
        a && (this.addChild(a), a.anchorX = 0, a.anchorY = 0, this.width = a.width, this.height = a.height), this._label && this.removeChild(this._label, !0), this._label = a
    },
    setEnabled: function(a) {
        if (this._enabled != a) {
            var b = this._label;
            a ? b.color = this._colorBackup : (this._colorBackup = b.color, b.color = this._disabledColor)
        }
        cc.MenuItem.prototype.setEnabled.call(this, a)
    },
    setOpacity: function(a) {
        this._label.opacity = a
    },
    getOpacity: function() {
        return this._label.opacity
    },
    setColor: function(a) {
        this._label.color = a
    },
    getColor: function() {
        return this._label.color
    },
    initWithLabel: function(a, b, c) {
        return this.initWithCallback(b, c), this._originalScale = 1, this._colorBackup = cc.color.WHITE, this._disabledColor = cc.color(126, 126, 126), this.setLabel(a), this.cascadeColor = !0, this.cascadeOpacity = !0, !0
    },
    setString: function(a) {
        this._label.string = a, this.width = this._label.width, this.height = this._label.height
    },
    getString: function() {
        return this._label.string
    },
    activate: function() {
        this._enabled && (this.stopAllActions(), this.scale = this._originalScale, cc.MenuItem.prototype.activate.call(this))
    },
    selected: function() {
        if (this._enabled) {
            cc.MenuItem.prototype.selected.call(this);
            var a = this.getActionByTag(cc.ZOOM_ACTION_TAG);
            a ? this.stopAction(a) : this._originalScale = this.scale;
            var b = cc.scaleTo(.1, 1.2 * this._originalScale);
            b.setTag(cc.ZOOM_ACTION_TAG), this.runAction(b)
        }
    },
    unselected: function() {
        if (this._enabled) {
            cc.MenuItem.prototype.unselected.call(this), this.stopActionByTag(cc.ZOOM_ACTION_TAG);
            var a = cc.scaleTo(.1, this._originalScale);
            a.setTag(cc.ZOOM_ACTION_TAG), this.runAction(a)
        }
    }
});
var _p = cc.MenuItemLabel.prototype;
_p.string, cc.defineGetterSetter(_p, "string", _p.getString, _p.setString), _p.disabledColor, cc.defineGetterSetter(_p, "disabledColor", _p.getDisabledColor, _p.setDisabledColor), _p.label, cc.defineGetterSetter(_p, "label", _p.getLabel, _p.setLabel), cc.MenuItemLabel.create = function(a, b, c) {
    return new cc.MenuItemLabel(a, b, c)
}, cc.MenuItemAtlasFont = cc.MenuItemLabel.extend({
    ctor: function(a, b, c, d, e, f, g) {
        var h;
        a && a.length > 0 && (h = new cc.LabelAtlas(a, b, c, d, e)), cc.MenuItemLabel.prototype.ctor.call(this, h, f, g)
    },
    initWithString: function(a, b, c, d, e, f, g) {
        if (!a || 0 == a.length) throw "cc.MenuItemAtlasFont.initWithString(): value should be non-null and its length should be greater than 0";
        var h = new cc.LabelAtlas;
        return h.initWithString(a, b, c, d, e), this.initWithLabel(h, f, g), !0
    }
}), cc.MenuItemAtlasFont.create = function(a, b, c, d, e, f, g) {
    return new cc.MenuItemAtlasFont(a, b, c, d, e, f, g)
}, cc.MenuItemFont = cc.MenuItemLabel.extend({
    _fontSize: null,
    _fontName: null,
    ctor: function(a, b, c) {
        var d;
        a && a.length > 0 ? (this._fontName = cc._globalFontName, this._fontSize = cc._globalFontSize, d = new cc.LabelTTF(a, this._fontName, this._fontSize)) : (this._fontSize = 0, this._fontName = ""), cc.MenuItemLabel.prototype.ctor.call(this, d, b, c)
    },
    initWithString: function(a, b, c) {
        if (!a || 0 == a.length) throw "Value should be non-null and its length should be greater than 0";
        this._fontName = cc._globalFontName, this._fontSize = cc._globalFontSize;
        var d = new cc.LabelTTF(a, this._fontName, this._fontSize);
        return this.initWithLabel(d, b, c), !0
    },
    setFontSize: function(a) {
        this._fontSize = a, this._recreateLabel()
    },
    getFontSize: function() {
        return this._fontSize
    },
    setFontName: function(a) {
        this._fontName = a, this._recreateLabel()
    },
    getFontName: function() {
        return this._fontName
    },
    _recreateLabel: function() {
        var a = new cc.LabelTTF(this._label.string, this._fontName, this._fontSize);
        this.setLabel(a)
    }
}), cc.MenuItemFont.setFontSize = function(a) {
    cc._globalFontSize = a
}, cc.MenuItemFont.fontSize = function() {
    return cc._globalFontSize
}, cc.MenuItemFont.setFontName = function(a) {
    cc._globalFontNameRelease && (cc._globalFontName = ""), cc._globalFontName = a, cc._globalFontNameRelease = !0
};
var _p = cc.MenuItemFont.prototype;
_p.fontSize, cc.defineGetterSetter(_p, "fontSize", _p.getFontSize, _p.setFontSize), _p.fontName, cc.defineGetterSetter(_p, "fontName", _p.getFontName, _p.setFontName), cc.MenuItemFont.fontName = function() {
    return cc._globalFontName
}, cc.MenuItemFont.create = function(a, b, c) {
    return new cc.MenuItemFont(a, b, c)
}, cc.MenuItemSprite = cc.MenuItem.extend({
    _normalImage: null,
    _selectedImage: null,
    _disabledImage: null,
    ctor: function(a, b, c, d, e) {
        if (cc.MenuItem.prototype.ctor.call(this), this._normalImage = null, this._selectedImage = null, this._disabledImage = null, void 0 !== b) {
            a = a, b = b;
            var f, g, h;
            void 0 !== e ? (f = c, h = d, g = e) : void 0 !== d && cc.isFunction(d) ? (f = c, h = d) : void 0 !== d && cc.isFunction(c) ? (g = d, h = c, f = new cc.Sprite(b.getTexture(), b.getTextureRect())) : void 0 === c && (f = new cc.Sprite(b.getTexture(), b.getTextureRect())), this.initWithNormalSprite(a, b, f, h, g)
        }
    },
    getNormalImage: function() {
        return this._normalImage
    },
    setNormalImage: function(a) {
        this._normalImage != a && (a && (this.addChild(a, 0, cc.NORMAL_TAG), a.anchorX = 0, a.anchorY = 0), this._normalImage && this.removeChild(this._normalImage, !0), this._normalImage = a, this.width = this._normalImage.width, this.height = this._normalImage.height, this._updateImagesVisibility(), a.textureLoaded && !a.textureLoaded() && a.addEventListener("load", function(a) {
            this.width = a.width, this.height = a.height
        }, this))
    },
    getSelectedImage: function() {
        return this._selectedImage
    },
    setSelectedImage: function(a) {
        this._selectedImage != a && (a && (this.addChild(a, 0, cc.SELECTED_TAG), a.anchorX = 0, a.anchorY = 0), this._selectedImage && this.removeChild(this._selectedImage, !0), this._selectedImage = a, this._updateImagesVisibility())
    },
    getDisabledImage: function() {
        return this._disabledImage
    },
    setDisabledImage: function(a) {
        this._disabledImage != a && (a && (this.addChild(a, 0, cc.DISABLE_TAG), a.anchorX = 0, a.anchorY = 0), this._disabledImage && this.removeChild(this._disabledImage, !0), this._disabledImage = a, this._updateImagesVisibility())
    },
    initWithNormalSprite: function(a, b, c, d, e) {
        this.initWithCallback(d, e), this.setNormalImage(a), this.setSelectedImage(b), this.setDisabledImage(c);
        var f = this._normalImage;
        return f && (this.width = f.width, this.height = f.height, f.textureLoaded && !f.textureLoaded() && f.addEventListener("load", function(a) {
            this.width = a.width, this.height = a.height, this.cascadeColor = !0, this.cascadeOpacity = !0
        }, this)), this.cascadeColor = !0, this.cascadeOpacity = !0, !0
    },
    setColor: function(a) {
        this._normalImage.color = a, this._selectedImage && (this._selectedImage.color = a), this._disabledImage && (this._disabledImage.color = a)
    },
    getColor: function() {
        return this._normalImage.color
    },
    setOpacity: function(a) {
        this._normalImage.opacity = a, this._selectedImage && (this._selectedImage.opacity = a), this._disabledImage && (this._disabledImage.opacity = a)
    },
    getOpacity: function() {
        return this._normalImage.opacity
    },
    selected: function() {
        cc.MenuItem.prototype.selected.call(this), this._normalImage && (this._disabledImage && (this._disabledImage.visible = !1), this._selectedImage ? (this._normalImage.visible = !1, this._selectedImage.visible = !0) : this._normalImage.visible = !0)
    },
    unselected: function() {
        cc.MenuItem.prototype.unselected.call(this), this._normalImage && (this._normalImage.visible = !0, this._selectedImage && (this._selectedImage.visible = !1), this._disabledImage && (this._disabledImage.visible = !1))
    },
    setEnabled: function(a) {
        this._enabled != a && (cc.MenuItem.prototype.setEnabled.call(this, a), this._updateImagesVisibility())
    },
    _updateImagesVisibility: function() {
        var a = this._normalImage,
            b = this._selectedImage,
            c = this._disabledImage;
        this._enabled ? (a && (a.visible = !0), b && (b.visible = !1), c && (c.visible = !1)) : c ? (a && (a.visible = !1), b && (b.visible = !1), c && (c.visible = !0)) : (a && (a.visible = !0), b && (b.visible = !1))
    }
});
var _p = cc.MenuItemSprite.prototype;
_p.normalImage, cc.defineGetterSetter(_p, "normalImage", _p.getNormalImage, _p.setNormalImage), _p.selectedImage, cc.defineGetterSetter(_p, "selectedImage", _p.getSelectedImage, _p.setSelectedImage), _p.disabledImage, cc.defineGetterSetter(_p, "disabledImage", _p.getDisabledImage, _p.setDisabledImage), cc.MenuItemSprite.create = function(a, b, c, d, e) {
    return new cc.MenuItemSprite(a, b, c, d, e || void 0)
}, cc.MenuItemImage = cc.MenuItemSprite.extend({
    ctor: function(a, b, c, d, e) {
        var f = null,
            g = null,
            h = null,
            i = null,
            j = null;
        void 0 === a ? cc.MenuItemSprite.prototype.ctor.call(this) : (f = new cc.Sprite(a), b && (g = new cc.Sprite(b)), void 0 === d ? i = c : void 0 === e ? (i = c, j = d) : e && (h = new cc.Sprite(c), i = d, j = e), cc.MenuItemSprite.prototype.ctor.call(this, f, g, h, i, j))
    },
    setNormalSpriteFrame: function(a) {
        this.setNormalImage(new cc.Sprite(a))
    },
    setSelectedSpriteFrame: function(a) {
        this.setSelectedImage(new cc.Sprite(a))
    },
    setDisabledSpriteFrame: function(a) {
        this.setDisabledImage(new cc.Sprite(a))
    },
    initWithNormalImage: function(a, b, c, d, e) {
        var f = null,
            g = null,
            h = null;
        return a && (f = new cc.Sprite(a)), b && (g = new cc.Sprite(b)), c && (h = new cc.Sprite(c)), this.initWithNormalSprite(f, g, h, d, e)
    }
}), cc.MenuItemImage.create = function(a, b, c, d, e) {
    return new cc.MenuItemImage(a, b, c, d, e)
}, cc.MenuItemToggle = cc.MenuItem.extend({
    subItems: null,
    _selectedIndex: 0,
    _opacity: null,
    _color: null,
    ctor: function() {
        cc.MenuItem.prototype.ctor.call(this), this._selectedIndex = 0, this.subItems = [], this._opacity = 0, this._color = cc.color.WHITE, arguments.length > 0 && this.initWithItems(Array.prototype.slice.apply(arguments))
    },
    getOpacity: function() {
        return this._opacity
    },
    setOpacity: function(a) {
        if (this._opacity = a, this.subItems && this.subItems.length > 0)
            for (var b = 0; b < this.subItems.length; b++) this.subItems[b].opacity = a;
        this._color.a = a
    },
    getColor: function() {
        var a = this._color;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    setColor: function(a) {
        var b = this._color;
        if (b.r = a.r, b.g = a.g, b.b = a.b, this.subItems && this.subItems.length > 0)
            for (var c = 0; c < this.subItems.length; c++) this.subItems[c].setColor(a);
        void 0 === a.a || a.a_undefined || this.setOpacity(a.a)
    },
    getSelectedIndex: function() {
        return this._selectedIndex
    },
    setSelectedIndex: function(a) {
        if (a != this._selectedIndex) {
            this._selectedIndex = a;
            var b = this.getChildByTag(cc.CURRENT_ITEM);
            b && b.removeFromParent(!1);
            var c = this.subItems[this._selectedIndex];
            this.addChild(c, 0, cc.CURRENT_ITEM);
            var d = c.width,
                e = c.height;
            this.width = d, this.height = e, c.setPosition(d / 2, e / 2)
        }
    },
    getSubItems: function() {
        return this.subItems
    },
    setSubItems: function(a) {
        this.subItems = a
    },
    initWithItems: function(a) {
        var b = a.length;
        cc.isFunction(a[a.length - 2]) ? (this.initWithCallback(a[a.length - 2], a[a.length - 1]), b -= 2) : cc.isFunction(a[a.length - 1]) ? (this.initWithCallback(a[a.length - 1], null), b -= 1) : this.initWithCallback(null, null);
        var c = this.subItems;
        c.length = 0;
        for (var d = 0; b > d; d++) a[d] && c.push(a[d]);
        return this._selectedIndex = cc.UINT_MAX, this.setSelectedIndex(0), this.cascadeColor = !0, this.cascadeOpacity = !0, !0
    },
    addSubItem: function(a) {
        this.subItems.push(a)
    },
    activate: function() {
        if (this._enabled) {
            var a = (this._selectedIndex + 1) % this.subItems.length;
            this.setSelectedIndex(a)
        }
        cc.MenuItem.prototype.activate.call(this)
    },
    selected: function() {
        cc.MenuItem.prototype.selected.call(this), this.subItems[this._selectedIndex].selected()
    },
    unselected: function() {
        cc.MenuItem.prototype.unselected.call(this), this.subItems[this._selectedIndex].unselected()
    },
    setEnabled: function(a) {
        if (this._enabled != a) {
            cc.MenuItem.prototype.setEnabled.call(this, a);
            var b = this.subItems;
            if (b && b.length > 0)
                for (var c = 0; c < b.length; c++) b[c].enabled = a
        }
    },
    selectedItem: function() {
        return this.subItems[this._selectedIndex]
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this), this.setSelectedIndex(this._selectedIndex)
    }
});
var _p = cc.MenuItemToggle.prototype;
_p.selectedIndex, cc.defineGetterSetter(_p, "selectedIndex", _p.getSelectedIndex, _p.setSelectedIndex), cc.MenuItemToggle.create = function() {
    arguments.length > 0 && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
    var a = new cc.MenuItemToggle;
    return a.initWithItems(Array.prototype.slice.apply(arguments)), a
}, cc.MENU_STATE_WAITING = 0, cc.MENU_STATE_TRACKING_TOUCH = 1, cc.MENU_HANDLER_PRIORITY = -128, cc.DEFAULT_PADDING = 5, cc.Menu = cc.Layer.extend({
    enabled: !1,
    _selectedItem: null,
    _state: -1,
    _touchListener: null,
    _className: "Menu",
    ctor: function(a) {
        cc.Layer.prototype.ctor.call(this), this._color = cc.color.WHITE, this.enabled = !1, this._opacity = 255, this._selectedItem = null, this._state = -1, this._touchListener = cc.EventListener.create({
            event: cc.EventListener.TOUCH_ONE_BY_ONE,
            swallowTouches: !0,
            onTouchBegan: this._onTouchBegan,
            onTouchMoved: this._onTouchMoved,
            onTouchEnded: this._onTouchEnded,
            onTouchCancelled: this._onTouchCancelled
        }), arguments.length > 0 && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
        var b, c = arguments.length;
        if (0 == c) b = [];
        else if (1 == c) b = a instanceof Array ? a : [a];
        else if (c > 1) {
            b = [];
            for (var d = 0; c > d; d++) arguments[d] && b.push(arguments[d])
        }
        this.initWithArray(b)
    },
    onEnter: function() {
        var a = this._touchListener;
        a._isRegistered() || cc.eventManager.addListener(a, this), cc.Node.prototype.onEnter.call(this)
    },
    isEnabled: function() {
        return this.enabled
    },
    setEnabled: function(a) {
        this.enabled = a
    },
    initWithItems: function(a) {
        var b = [];
        if (a)
            for (var c = 0; c < a.length; c++) a[c] && b.push(a[c]);
        return this.initWithArray(b)
    },
    initWithArray: function(a) {
        if (cc.Layer.prototype.init.call(this)) {
            this.enabled = !0;
            var b = cc.winSize;
            if (this.setPosition(b.width / 2, b.height / 2), this.setContentSize(b), this.setAnchorPoint(.5, .5), this.ignoreAnchorPointForPosition(!0), a)
                for (var c = 0; c < a.length; c++) this.addChild(a[c], c);
            return this._selectedItem = null, this._state = cc.MENU_STATE_WAITING, this.cascadeColor = !0, this.cascadeOpacity = !0, !0
        }
        return !1
    },
    addChild: function(a, b, c) {
        if (!(a instanceof cc.MenuItem)) throw "cc.Menu.addChild() : Menu only supports MenuItem objects as children";
        cc.Layer.prototype.addChild.call(this, a, b, c)
    },
    alignItemsVertically: function() {
        this.alignItemsVerticallyWithPadding(cc.DEFAULT_PADDING)
    },
    alignItemsVerticallyWithPadding: function(a) {
        var b, c, d, e, f, g = -a,
            h = this._children;
        if (h && h.length > 0) {
            for (c = 0, b = h.length; b > c; c++) g += h[c].height * h[c].scaleY + a;
            var i = g / 2;
            for (c = 0, b = h.length; b > c; c++) f = h[c], e = f.height, d = f.scaleY, f.setPosition(0, i - e * d / 2), i -= e * d + a
        }
    },
    alignItemsHorizontally: function() {
        this.alignItemsHorizontallyWithPadding(cc.DEFAULT_PADDING)
    },
    alignItemsHorizontallyWithPadding: function(a) {
        var b, c, d, e, f, g = -a,
            h = this._children;
        if (h && h.length > 0) {
            for (b = 0, c = h.length; c > b; b++) g += h[b].width * h[b].scaleX + a;
            var i = -g / 2;
            for (b = 0, c = h.length; c > b; b++) f = h[b], d = f.scaleX, e = h[b].width, f.setPosition(i + e * d / 2, 0), i += e * d + a
        }
    },
    alignItemsInColumns: function() {
        arguments.length > 0 && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
        for (var a = [], b = 0; b < arguments.length; b++) a.push(arguments[b]);
        var c, d, e, f = -5,
            g = 0,
            h = 0,
            i = 0,
            j = this._children;
        if (j && j.length > 0)
            for (b = 0, e = j.length; e > b; b++) g >= a.length || (c = a[g], c && (d = j[b].height, h = h >= d || isNaN(d) ? h : d, ++i, i >= c && (f += h + 5, i = 0, h = 0, ++g)));
        var k = cc.director.getWinSize();
        g = 0, h = 0, c = 0;
        var l = 0,
            m = 0,
            n = f / 2;
        if (j && j.length > 0)
            for (b = 0, e = j.length; e > b; b++) {
                var o = j[b];
                0 == c && (c = a[g], l = k.width / (1 + c), m = l), d = o._getHeight(), h = h >= d || isNaN(d) ? h : d, o.setPosition(m - k.width / 2, n - d / 2), m += l, ++i, i >= c && (n -= h + 5, i = 0, c = 0, h = 0, ++g)
            }
    },
    alignItemsInRows: function() {
        arguments.length > 0 && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
        var a, b = [];
        for (a = 0; a < arguments.length; a++) b.push(arguments[a]);
        var c, d, e, f, g = [],
            h = [],
            i = -10,
            j = -5,
            k = 0,
            l = 0,
            m = 0,
            n = this._children;
        if (n && n.length > 0)
            for (a = 0, e = n.length; e > a; a++) d = n[a], k >= b.length || (c = b[k], c && (f = d.width, l = l >= f || isNaN(f) ? l : f, j += d.height + 5, ++m, m >= c && (g.push(l), h.push(j), i += l + 10, m = 0, l = 0, j = -5, ++k)));
        var o = cc.director.getWinSize();
        k = 0, l = 0, c = 0;
        var p = -i / 2,
            q = 0;
        if (n && n.length > 0)
            for (a = 0, e = n.length; e > a; a++) d = n[a], 0 == c && (c = b[k], q = h[k]), f = d._getWidth(), l = l >= f || isNaN(f) ? l : f, d.setPosition(p + g[k] / 2, q - o.height / 2), q -= d.height + 10, ++m, m >= c && (p += l + 5, m = 0, c = 0, l = 0, ++k)
    },
    removeChild: function(a, b) {
        if (null != a) {
            if (!(a instanceof cc.MenuItem)) return void cc.log("cc.Menu.removeChild():Menu only supports MenuItem objects as children");
            this._selectedItem == a && (this._selectedItem = null), cc.Node.prototype.removeChild.call(this, a, b)
        }
    },
    _onTouchBegan: function(a, b) {
        var c = b.getCurrentTarget();
        if (c._state != cc.MENU_STATE_WAITING || !c._visible || !c.enabled) return !1;
        for (var d = c.parent; null != d; d = d.parent)
            if (!d.isVisible()) return !1;
        return c._selectedItem = c._itemForTouch(a), c._selectedItem ? (c._state = cc.MENU_STATE_TRACKING_TOUCH, c._selectedItem.selected(), c._selectedItem.setNodeDirty(), !0) : !1
    },
    _onTouchEnded: function(a, b) {
        var c = b.getCurrentTarget();
        return c._state !== cc.MENU_STATE_TRACKING_TOUCH ? void cc.log("cc.Menu.onTouchEnded(): invalid state") : (c._selectedItem && (c._selectedItem.unselected(), c._selectedItem.setNodeDirty(), c._selectedItem.activate()), void(c._state = cc.MENU_STATE_WAITING))
    },
    _onTouchCancelled: function(a, b) {
        var c = b.getCurrentTarget();
        return c._state !== cc.MENU_STATE_TRACKING_TOUCH ? void cc.log("cc.Menu.onTouchCancelled(): invalid state") : (this._selectedItem && (c._selectedItem.unselected(), c._selectedItem.setNodeDirty()), void(c._state = cc.MENU_STATE_WAITING))
    },
    _onTouchMoved: function(a, b) {
        var c = b.getCurrentTarget();
        if (c._state !== cc.MENU_STATE_TRACKING_TOUCH) return void cc.log("cc.Menu.onTouchMoved(): invalid state");
        var d = c._itemForTouch(a);
        d != c._selectedItem && (c._selectedItem && (c._selectedItem.unselected(), c._selectedItem.setNodeDirty()), c._selectedItem = d, c._selectedItem && (c._selectedItem.selected(), c._selectedItem.setNodeDirty()))
    },
    onExit: function() {
        this._state == cc.MENU_STATE_TRACKING_TOUCH && (this._selectedItem && (this._selectedItem.unselected(), this._selectedItem = null), this._state = cc.MENU_STATE_WAITING), cc.Node.prototype.onExit.call(this)
    },
    setOpacityModifyRGB: function() {},
    isOpacityModifyRGB: function() {
        return !1
    },
    _itemForTouch: function(a) {
        var b, c = a.getLocation(),
            d = this._children;
        if (d && d.length > 0)
            for (var e = d.length - 1; e >= 0; e--)
                if (b = d[e], b.isVisible() && b.isEnabled()) {
                    var f = b.convertToNodeSpace(c),
                        g = b.rect();
                    if (g.x = 0, g.y = 0, cc.rectContainsPoint(g, f)) return b
                }
        return null
    }
});
var _p = cc.Menu.prototype;
_p.enabled, cc.Menu.create = function(a) {
    var b = arguments.length;
    b > 0 && null == arguments[b - 1] && cc.log("parameters should not be ending with null in Javascript");
    var c;
    return c = 0 == b ? new cc.Menu : new cc.Menu(1 == b ? a : Array.prototype.slice.call(arguments, 0))
};
cc.kmScalar = Number, cc.kmBool = Number, cc.kmEnum = Number, cc.KM_FALSE = 0, cc.KM_TRUE = 1, cc.kmPI = 3.141592, cc.kmPIOver180 = .017453, cc.kmPIUnder180 = 57.295779, cc.kmEpsilon = 1 / 64, cc.kmSQR = function(a) {
    return a * a
}, cc.kmDegreesToRadians = function(a) {
    return a * cc.kmPIOver180
}, cc.kmRadiansToDegrees = function(a) {
    return a * cc.kmPIUnder180
}, cc.kmMin = function(a, b) {
    return b > a ? a : b
}, cc.kmMax = function(a, b) {
    return a > b ? a : b
}, cc.kmAlmostEqual = function(a, b) {
    return a + cc.kmEpsilon > b && a - cc.kmEpsilon < b
}, cc.kmVec2 = function(a, b) {
    this.x = a || 0, this.y = b || 0
}, cc.kmVec2Fill = function(a, b, c) {
    return a.x = b, a.y = c, a
}, cc.kmVec2Length = function(a) {
    return Math.sqrt(cc.kmSQR(a.x) + cc.kmSQR(a.y))
}, cc.kmVec2LengthSq = function(a) {
    return cc.kmSQR(a.x) + cc.kmSQR(a.y)
}, cc.kmVec2Normalize = function(a, b) {
    var c = 1 / cc.kmVec2Length(b),
        d = new cc.kmVec2;
    return d.x = b.x * c, d.y = b.y * c, a.x = d.x, a.y = d.y, a
}, cc.kmVec2Add = function(a, b, c) {
    return a.x = b.x + c.x, a.y = b.y + c.y, a
}, cc.kmVec2Dot = function(a, b) {
    return a.x * b.x + a.y * b.y
}, cc.kmVec2Subtract = function(a, b, c) {
    return a.x = b.x - c.x, a.y = b.y - c.y, a
}, cc.kmVec2Transform = function(a, b, c) {
    var d = new cc.kmVec2;
    return d.x = b.x * c.mat[0] + b.y * c.mat[3] + c.mat[6], d.y = b.x * c.mat[1] + b.y * c.mat[4] + c.mat[7], a.x = d.x, a.y = d.y, a
}, cc.kmVec2TransformCoord = function() {
    return null
}, cc.kmVec2Scale = function(a, b, c) {
    return a.x = b.x * c, a.y = b.y * c, a
}, cc.kmVec2AreEqual = function(a, b) {
    return a.x < b.x + cc.kmEpsilon && a.x > b.x - cc.kmEpsilon && a.y < b.y + cc.kmEpsilon && a.y > b.y - cc.kmEpsilon
}, cc.kmVec3 = function(a, b, c) {
    this.x = a || 0, this.y = b || 0, this.z = c || 0
}, cc.kmVec3Fill = function(a, b, c, d) {
    return a ? (a.x = b, a.y = c, a.z = d, a) : new cc.kmVec3(b, c, d)
}, cc.kmVec3Length = function(a) {
    return Math.sqrt(cc.kmSQR(a.x) + cc.kmSQR(a.y) + cc.kmSQR(a.z))
}, cc.kmVec3LengthSq = function(a) {
    return cc.kmSQR(a.x) + cc.kmSQR(a.y) + cc.kmSQR(a.z)
}, cc.kmVec3Normalize = function(a, b) {
    var c = 1 / cc.kmVec3Length(b);
    return a.x = b.x * c, a.y = b.y * c, a.z = b.z * c, a
}, cc.kmVec3Cross = function(a, b, c) {
    return a.x = b.y * c.z - b.z * c.y, a.y = b.z * c.x - b.x * c.z, a.z = b.x * c.y - b.y * c.x, a
}, cc.kmVec3Dot = function(a, b) {
    return a.x * b.x + a.y * b.y + a.z * b.z
}, cc.kmVec3Add = function(a, b, c) {
    return a.x = b.x + c.x, a.y = b.y + c.y, a.z = b.z + c.z, a
}, cc.kmVec3Subtract = function(a, b, c) {
    return a.x = b.x - c.x, a.y = b.y - c.y, a.z = b.z - c.z, a
}, cc.kmVec3Transform = function(a, b, c) {
    return a.x = b.x * c.mat[0] + b.y * c.mat[4] + b.z * c.mat[8] + c.mat[12], a.y = b.x * c.mat[1] + b.y * c.mat[5] + b.z * c.mat[9] + c.mat[13], a.z = b.x * c.mat[2] + b.y * c.mat[6] + b.z * c.mat[10] + c.mat[14], a
}, cc.kmVec3TransformNormal = function(a, b, c) {
    return a.x = b.x * c.mat[0] + b.y * c.mat[4] + b.z * c.mat[8], a.y = b.x * c.mat[1] + b.y * c.mat[5] + b.z * c.mat[9], a.z = b.x * c.mat[2] + b.y * c.mat[6] + b.z * c.mat[10], a
}, cc.kmVec3TransformCoord = function(a, b, c) {
    var d = new cc.kmVec4,
        e = new cc.kmVec4;
    return cc.kmVec4Fill(e, b.x, b.y, b.z, 1), cc.kmVec4Transform(d, e, c), a.x = d.x / d.w, a.y = d.y / d.w, a.z = d.z / d.w, a
}, cc.kmVec3Scale = function(a, b, c) {
    return a.x = b.x * c, a.y = b.y * c, a.z = b.z * c, a
}, cc.kmVec3AreEqual = function(a, b) {
    return a.x < b.x + cc.kmEpsilon && a.x > b.x - cc.kmEpsilon && a.y < b.y + cc.kmEpsilon && a.y > b.y - cc.kmEpsilon && a.z < b.z + cc.kmEpsilon && a.z > b.z - cc.kmEpsilon ? 1 : 0
}, cc.kmVec3InverseTransform = function(a, b, c) {
    var d = new cc.kmVec3(b.x - c.mat[12], b.y - c.mat[13], b.z - c.mat[14]);
    return a.x = d.x * c.mat[0] + d.y * c.mat[1] + d.z * c.mat[2], a.y = d.x * c.mat[4] + d.y * c.mat[5] + d.z * c.mat[6], a.z = d.x * c.mat[8] + d.y * c.mat[9] + d.z * c.mat[10], a
}, cc.kmVec3InverseTransformNormal = function(a, b, c) {
    return a.x = b.x * c.mat[0] + b.y * c.mat[1] + b.z * c.mat[2], a.y = b.x * c.mat[4] + b.y * c.mat[5] + b.z * c.mat[6], a.z = b.x * c.mat[8] + b.y * c.mat[9] + b.z * c.mat[10], a
}, cc.kmVec3Assign = function(a, b) {
    return a == b ? a : (a.x = b.x, a.y = b.y, a.z = b.z, a)
}, cc.kmVec3Zero = function(a) {
    return a.x = 0, a.y = 0, a.z = 0, a
}, cc.kmVec3ToTypeArray = function(a) {
    if (!a) return null;
    var b = new Float32Array(3);
    return b[0] = a.x, b[1] = a.y, b[2] = a.z, b
}, cc.kmVec4 = function(a, b, c, d) {
    this.x = a || 0, this.y = b || 0, this.z = c || 0, this.w = d || 0
}, cc.kmVec4Fill = function(a, b, c, d, e) {
    return a.x = b, a.y = c, a.z = d, a.w = e, a
}, cc.kmVec4Add = function(a, b, c) {
    return a.x = b.x + c.x, a.y = b.y + c.y, a.z = b.z + c.z, a.w = b.w + c.w, a
}, cc.kmVec4Dot = function(a, b) {
    return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w
}, cc.kmVec4Length = function(a) {
    return Math.sqrt(cc.kmSQR(a.x) + cc.kmSQR(a.y) + cc.kmSQR(a.z) + cc.kmSQR(a.w))
}, cc.kmVec4LengthSq = function(a) {
    return cc.kmSQR(a.x) + cc.kmSQR(a.y) + cc.kmSQR(a.z) + cc.kmSQR(a.w)
}, cc.kmVec4Lerp = function(a) {
    return a
}, cc.kmVec4Normalize = function(a, b) {
    var c = 1 / cc.kmVec4Length(b);
    return a.x *= c, a.y *= c, a.z *= c, a.w *= c, a
}, cc.kmVec4Scale = function(a, b, c) {
    return cc.kmVec4Normalize(a, b), a.x *= c, a.y *= c, a.z *= c, a.w *= c, a
}, cc.kmVec4Subtract = function(a, b, c) {
    return a.x = b.x - c.x, a.y = b.y - c.y, a.z = b.z - c.z, a.w = b.w - c.w, a
}, cc.kmVec4Transform = function(a, b, c) {
    return a.x = b.x * c.mat[0] + b.y * c.mat[4] + b.z * c.mat[8] + b.w * c.mat[12], a.y = b.x * c.mat[1] + b.y * c.mat[5] + b.z * c.mat[9] + b.w * c.mat[13], a.z = b.x * c.mat[2] + b.y * c.mat[6] + b.z * c.mat[10] + b.w * c.mat[14], a.w = b.x * c.mat[3] + b.y * c.mat[7] + b.z * c.mat[11] + b.w * c.mat[15], a
}, cc.kmVec4TransformArray = function(a, b, c, d, e, f) {
    for (var g = 0; f > g;) {
        var h = c + g * d,
            i = a + g * b;
        cc.kmVec4Transform(i, h, e), ++g
    }
    return a
}, cc.kmVec4AreEqual = function(a, b) {
    return a.x < b.x + cc.kmEpsilon && a.x > b.x - cc.kmEpsilon && a.y < b.y + cc.kmEpsilon && a.y > b.y - cc.kmEpsilon && a.z < b.z + cc.kmEpsilon && a.z > b.z - cc.kmEpsilon && a.w < b.w + cc.kmEpsilon && a.w > b.w - cc.kmEpsilon
}, cc.kmVec4Assign = function(a, b) {
    return a == b ? (cc.log("destVec and srcVec are same object"), a) : (a.x = b.x, a.y = b.y, a.z = b.z, a.w = b.w, a)
}, cc.kmVec4ToTypeArray = function(a) {
    if (!a) return null;
    var b = new Float32Array(4);
    return b[0] = a.x, b[1] = a.y, b[2] = a.z, b[3] = a.w, b
}, cc.kmRay2 = function(a) {
    this.start = a || new cc.kmVec2, this.start = a || new cc.kmVec2
}, cc.kmRay2Fill = function(a, b, c, d, e) {
    a.start.x = b, a.start.y = c, a.dir.x = d, a.dir.y = e
}, cc.kmRay2IntersectLineSegment = function(a, b, c, d) {
    var e, f, g, h = a.start.x,
        i = a.start.y,
        j = a.start.x + a.dir.x,
        k = a.start.y + a.dir.y,
        l = b.x,
        m = b.y,
        n = c.x,
        o = c.y,
        p = (o - m) * (j - h) - (n - l) * (k - i);
    return p > -cc.kmEpsilon && p < cc.kmEpsilon ? cc.KM_FALSE : (e = ((n - l) * (i - m) - (o - m) * (h - l)) / p, f = h + e * (j - h), g = i + e * (k - i), f < cc.kmMin(b.x, c.x) - cc.kmEpsilon || f > cc.kmMax(b.x, c.x) + cc.kmEpsilon || g < cc.kmMin(b.y, c.y) - cc.kmEpsilon || g > cc.kmMax(b.y, c.y) + cc.kmEpsilon ? cc.KM_FALSE : f < cc.kmMin(h, j) - cc.kmEpsilon || f > cc.kmMax(h, j) + cc.kmEpsilon || g < cc.kmMin(i, k) - cc.kmEpsilon || g > cc.kmMax(i, k) + cc.kmEpsilon ? cc.KM_FALSE : (d.x = f, d.y = g, cc.KM_TRUE))
}, cc.calculate_line_normal = function(a, b, c) {
    var d = new cc.kmVec2;
    cc.kmVec2Subtract(d, b, a), c.x = -d.y, c.y = d.x, cc.kmVec2Normalize(c, c)
}, cc.kmRay2IntersectTriangle = function(a, b, c, d, e, f) {
    var g, h, i = new cc.kmVec2,
        j = new cc.kmVec2,
        k = new cc.kmVec2,
        l = 1e4,
        m = cc.KM_FALSE;
    return cc.kmRay2IntersectLineSegment(a, b, c, i) && (g = new cc.kmVec2, m = cc.KM_TRUE, h = cc.kmVec2Length(cc.kmVec2Subtract(g, i, a.start)), l > h && (j.x = i.x, j.y = i.y, l = h, cc.calculate_line_normal(b, c, k))), cc.kmRay2IntersectLineSegment(a, c, d, i) && (g = new cc.kmVec2, m = cc.KM_TRUE, h = cc.kmVec2Length(cc.kmVec2Subtract(g, i, a.start)), l > h && (j.x = i.x, j.y = i.y, l = h, cc.calculate_line_normal(c, d, k))), cc.kmRay2IntersectLineSegment(a, d, b, i) && (g = new cc.kmVec2, m = cc.KM_TRUE, h = cc.kmVec2Length(cc.kmVec2Subtract(g, i, a.start)), l > h && (j.x = i.x, j.y = i.y, l = h, cc.calculate_line_normal(d, b, k))), m && (e.x = j.x, e.y = j.y, f && (f.x = k.x, f.y = k.y)), m
}, cc.kmRay2IntersectCircle = function() {
    cc.log("cc.kmRay2IntersectCircle() has not been implemented.")
};
var Float32Array = Float32Array || Array;
cc.kmMat3 = function() {
    this.mat = new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0])
}, cc.kmMat3Fill = function(a, b) {
    for (var c = 0; 9 > c; c++) a.mat[c] = b;
    return a
}, cc.kmMat3Adjugate = function(a, b) {
    return a.mat[0] = b.mat[4] * b.mat[8] - b.mat[5] * b.mat[7], a.mat[1] = b.mat[2] * b.mat[7] - b.mat[1] * b.mat[8], a.mat[2] = b.mat[1] * b.mat[5] - b.mat[2] * b.mat[4], a.mat[3] = b.mat[5] * b.mat[6] - b.mat[3] * b.mat[8], a.mat[4] = b.mat[0] * b.mat[8] - b.mat[2] * b.mat[6], a.mat[5] = b.mat[2] * b.mat[3] - b.mat[0] * b.mat[5], a.mat[6] = b.mat[3] * b.mat[7] - b.mat[4] * b.mat[6], a.mat[8] = b.mat[0] * b.mat[4] - b.mat[1] * b.mat[3], a
}, cc.kmMat3Identity = function(a) {
    return a.mat[1] = a.mat[2] = a.mat[3] = a.mat[5] = a.mat[6] = a.mat[7] = 0, a.mat[0] = a.mat[4] = a.mat[8] = 1, a
}, cc.kmMat3Inverse = function(a, b, c) {
    var d, e = new cc.kmMat3;
    return 0 === b ? null : (d = 1 / b, cc.kmMat3Adjugate(e, c), cc.kmMat3ScalarMultiply(a, e, d), a)
}, cc.kmMat3._identity = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]), cc.kmMat3IsIdentity = function(a) {
    for (var b = 0; 9 > b; b++)
        if (cc.kmMat3._identity[b] !== a.mat[b]) return !1;
    return !0
}, cc.kmMat3Transpose = function(a, b) {
    var c, d;
    for (c = 0; 3 > c; ++c)
        for (d = 0; 3 > d; ++d) a.mat[3 * c + d] = b.mat[3 * d + c];
    return a
}, cc.kmMat3Determinant = function(a) {
    var b;
    return b = a.mat[0] * a.mat[4] * a.mat[8] + a.mat[1] * a.mat[5] * a.mat[6] + a.mat[2] * a.mat[3] * a.mat[7], b -= a.mat[2] * a.mat[4] * a.mat[6] + a.mat[0] * a.mat[5] * a.mat[7] + a.mat[1] * a.mat[3] * a.mat[8]
}, cc.kmMat3Multiply = function(a, b, c) {
    var d = b.mat,
        e = c.mat;
    return a.mat[0] = d[0] * e[0] + d[3] * e[1] + d[6] * e[2], a.mat[1] = d[1] * e[0] + d[4] * e[1] + d[7] * e[2], a.mat[2] = d[2] * e[0] + d[5] * e[1] + d[8] * e[2], a.mat[3] = d[0] * e[3] + d[3] * e[4] + d[6] * e[5], a.mat[4] = d[1] * e[3] + d[4] * e[4] + d[7] * e[5], a.mat[5] = d[2] * e[3] + d[5] * e[4] + d[8] * e[5], a.mat[6] = d[0] * e[6] + d[3] * e[7] + d[6] * e[8], a.mat[7] = d[1] * e[6] + d[4] * e[7] + d[7] * e[8], a.mat[8] = d[2] * e[6] + d[5] * e[7] + d[8] * e[8], a
}, cc.kmMat3ScalarMultiply = function(a, b, c) {
    for (var d = 0; 9 > d; d++) a.mat[d] = b.mat[d] * c;
    return a
}, cc.kmMat3RotationAxisAngle = function(a, b, c) {
    var d = Math.cos(c),
        e = Math.sin(c);
    return a.mat[0] = d + b.x * b.x * (1 - d), a.mat[1] = b.z * e + b.y * b.x * (1 - d), a.mat[2] = -b.y * e + b.z * b.x * (1 - d), a.mat[3] = -b.z * e + b.x * b.y * (1 - d), a.mat[4] = d + b.y * b.y * (1 - d), a.mat[5] = b.x * e + b.z * b.y * (1 - d), a.mat[6] = b.y * e + b.x * b.z * (1 - d), a.mat[7] = -b.x * e + b.y * b.z * (1 - d), a.mat[8] = d + b.z * b.z * (1 - d), a
}, cc.kmMat3Assign = function(a, b) {
    if (a == b) return cc.log("cc.kmMat3Assign(): pOut equals pIn"), a;
    for (var c = 0; 9 > c; c++) a.mat[c] = b.mat[c];
    return a
}, cc.kmMat3AreEqual = function(a, b) {
    if (a == b) return !0;
    for (var c = 0; 9 > c; ++c)
        if (!(a.mat[c] + cc.kmEpsilon > b.mat[c] && a.mat[c] - cc.kmEpsilon < b.mat[c])) return !1;
    return !0
}, cc.kmMat3RotationX = function(a, b) {
    return a.mat[0] = 1, a.mat[1] = 0, a.mat[2] = 0, a.mat[3] = 0, a.mat[4] = Math.cos(b), a.mat[5] = Math.sin(b), a.mat[6] = 0, a.mat[7] = -Math.sin(b), a.mat[8] = Math.cos(b), a
}, cc.kmMat3RotationY = function(a, b) {
    return a.mat[0] = Math.cos(b), a.mat[1] = 0, a.mat[2] = -Math.sin(b), a.mat[3] = 0, a.mat[4] = 1, a.mat[5] = 0, a.mat[6] = Math.sin(b), a.mat[7] = 0, a.mat[8] = Math.cos(b), a
}, cc.kmMat3RotationZ = function(a, b) {
    return a.mat[0] = Math.cos(b), a.mat[1] = -Math.sin(b), a.mat[2] = 0, a.mat[3] = Math.sin(b), a.mat[4] = Math.cos(b), a.mat[5] = 0, a.mat[6] = 0, a.mat[7] = 0, a.mat[8] = 1, a
}, cc.kmMat3Rotation = function(a, b) {
    return a.mat[0] = Math.cos(b), a.mat[1] = Math.sin(b), a.mat[2] = 0, a.mat[3] = -Math.sin(b), a.mat[4] = Math.cos(b), a.mat[5] = 0, a.mat[6] = 0, a.mat[7] = 0, a.mat[8] = 1, a
}, cc.kmMat3Scaling = function(a, b, c) {
    return cc.kmMat3Identity(a), a.mat[0] = b, a.mat[4] = c, a
}, cc.kmMat3Translation = function(a, b, c) {
    return cc.kmMat3Identity(a), a.mat[6] = b, a.mat[7] = c, a
}, cc.kmMat3RotationQuaternion = function(a, b) {
    return b && a ? (a.mat[0] = 1 - 2 * (b.y * b.y + b.z * b.z), a.mat[1] = 2 * (b.x * b.y - b.w * b.z), a.mat[2] = 2 * (b.x * b.z + b.w * b.y), a.mat[3] = 2 * (b.x * b.y + b.w * b.z), a.mat[4] = 1 - 2 * (b.x * b.x + b.z * b.z), a.mat[5] = 2 * (b.y * b.z - b.w * b.x), a.mat[6] = 2 * (b.x * b.z - b.w * b.y), a.mat[7] = 2 * (b.y * b.z + b.w * b.x), a.mat[8] = 1 - 2 * (b.x * b.x + b.y * b.y), a) : null
}, cc.kmMat3RotationToAxisAngle = function(a, b, c) {
    var d;
    return cc.kmQuaternionRotationMatrix(d, c), cc.kmQuaternionToAxisAngle(d, a, b), a
}, cc.kmMat4 = function() {
    this.mat = new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
}, cc.kmMat4Fill = function(a, b) {
    a.mat[0] = a.mat[1] = a.mat[2] = a.mat[3] = a.mat[4] = a.mat[5] = a.mat[6] = a.mat[7] = a.mat[8] = a.mat[9] = a.mat[10] = a.mat[11] = a.mat[12] = a.mat[13] = a.mat[14] = a.mat[15] = b
}, cc.kmMat4Identity = function(a) {
    return a.mat[1] = a.mat[2] = a.mat[3] = a.mat[4] = a.mat[6] = a.mat[7] = a.mat[8] = a.mat[9] = a.mat[11] = a.mat[12] = a.mat[13] = a.mat[14] = 0, a.mat[0] = a.mat[5] = a.mat[10] = a.mat[15] = 1, a
}, cc.kmMat4._get = function(a, b, c) {
    return a.mat[b + 4 * c]
}, cc.kmMat4._set = function(a, b, c, d) {
    a.mat[b + 4 * c] = d
}, cc.kmMat4._swap = function(a, b, c, d, e) {
    var f = cc.kmMat4._get(a, b, c);
    cc.kmMat4._set(a, b, c, cc.kmMat4._get(a, d, e)), cc.kmMat4._set(a, d, e, f)
}, cc.kmMat4._gaussj = function(a, b) {
    var c, d, e, f, g, h, i, j, k = 0,
        l = 0,
        m = 4,
        n = 4,
        o = [0, 0, 0, 0],
        p = [0, 0, 0, 0],
        q = [0, 0, 0, 0];
    for (c = 0; m > c; c++) {
        for (h = 0, d = 0; m > d; d++)
            if (1 != q[d])
                for (e = 0; m > e; e++) 0 == q[e] && Math.abs(cc.kmMat4._get(a, d, e)) >= h && (h = Math.abs(cc.kmMat4._get(a, d, e)), l = d, k = e);
        if (++q[k], l != k) {
            for (f = 0; m > f; f++) cc.kmMat4._swap(a, l, f, k, f);
            for (f = 0; n > f; f++) cc.kmMat4._swap(b, l, f, k, f)
        }
        if (p[c] = l, o[c] = k, 0 == cc.kmMat4._get(a, k, k)) return cc.KM_FALSE;
        for (j = 1 / cc.kmMat4._get(a, k, k), cc.kmMat4._set(a, k, k, 1), f = 0; m > f; f++) cc.kmMat4._set(a, k, f, cc.kmMat4._get(a, k, f) * j);
        for (f = 0; n > f; f++) cc.kmMat4._set(b, k, f, cc.kmMat4._get(b, k, f) * j);
        for (g = 0; m > g; g++)
            if (g != k) {
                for (i = cc.kmMat4._get(a, g, k), cc.kmMat4._set(a, g, k, 0), f = 0; m > f; f++) cc.kmMat4._set(a, g, f, cc.kmMat4._get(a, g, f) - cc.kmMat4._get(a, k, f) * i);
                for (f = 0; n > f; f++) cc.kmMat4._set(b, g, f, cc.kmMat4._get(a, g, f) - cc.kmMat4._get(b, k, f) * i)
            }
    }
    for (f = m - 1; f >= 0; f--)
        if (p[f] != o[f])
            for (e = 0; m > e; e++) cc.kmMat4._swap(a, e, p[f], e, o[f]);
    return cc.KM_TRUE
}, cc.kmMat4._identity = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), cc.kmMat4Inverse = function(a, b) {
    var c = new cc.kmMat4,
        d = new cc.kmMat4;
    return cc.kmMat4Assign(c, b), cc.kmMat4Identity(d), cc.kmMat4._gaussj(c, d) == cc.KM_FALSE ? null : (cc.kmMat4Assign(a, c), a)
}, cc.kmMat4IsIdentity = function(a) {
    for (var b = 0; 16 > b; b++)
        if (cc.kmMat4._identity[b] != a.mat[b]) return !1;
    return !0
}, cc.kmMat4Transpose = function(a, b) {
    var c, d, e = a.mat,
        f = b.mat;
    for (d = 0; 4 > d; ++d)
        for (c = 0; 4 > c; ++c) e[4 * d + c] = f[4 * c + d];
    return a
}, cc.kmMat4Multiply = function(a, b, c) {
    var d = a.mat,
        e = b.mat[0],
        f = b.mat[1],
        g = b.mat[2],
        h = b.mat[3],
        i = b.mat[4],
        j = b.mat[5],
        k = b.mat[6],
        l = b.mat[7],
        m = b.mat[8],
        n = b.mat[9],
        o = b.mat[10],
        p = b.mat[11],
        q = b.mat[12],
        r = b.mat[13],
        s = b.mat[14],
        t = b.mat[15],
        u = c.mat[0],
        v = c.mat[1],
        w = c.mat[2],
        x = c.mat[3],
        y = c.mat[4],
        z = c.mat[5],
        A = c.mat[6],
        B = c.mat[7],
        C = c.mat[8],
        D = c.mat[9],
        E = c.mat[10],
        F = c.mat[11],
        G = c.mat[12],
        H = c.mat[13],
        I = c.mat[14],
        J = c.mat[15];
    return d[0] = u * e + v * i + w * m + x * q, d[1] = u * f + v * j + w * n + x * r, d[2] = u * g + v * k + w * o + x * s, d[3] = u * h + v * l + w * p + x * t, d[4] = y * e + z * i + A * m + B * q, d[5] = y * f + z * j + A * n + B * r, d[6] = y * g + z * k + A * o + B * s, d[7] = y * h + z * l + A * p + B * t, d[8] = C * e + D * i + E * m + F * q, d[9] = C * f + D * j + E * n + F * r, d[10] = C * g + D * k + E * o + F * s, d[11] = C * h + D * l + E * p + F * t, d[12] = G * e + H * i + I * m + J * q, d[13] = G * f + H * j + I * n + J * r, d[14] = G * g + H * k + I * o + J * s, d[15] = G * h + H * l + I * p + J * t, a
}, cc.getMat4MultiplyValue = function(a, b) {
    var c = a.mat,
        d = b.mat,
        e = new Float32Array(16);
    return e[0] = c[0] * d[0] + c[4] * d[1] + c[8] * d[2] + c[12] * d[3], e[1] = c[1] * d[0] + c[5] * d[1] + c[9] * d[2] + c[13] * d[3], e[2] = c[2] * d[0] + c[6] * d[1] + c[10] * d[2] + c[14] * d[3], e[3] = c[3] * d[0] + c[7] * d[1] + c[11] * d[2] + c[15] * d[3], e[4] = c[0] * d[4] + c[4] * d[5] + c[8] * d[6] + c[12] * d[7], e[5] = c[1] * d[4] + c[5] * d[5] + c[9] * d[6] + c[13] * d[7], e[6] = c[2] * d[4] + c[6] * d[5] + c[10] * d[6] + c[14] * d[7], e[7] = c[3] * d[4] + c[7] * d[5] + c[11] * d[6] + c[15] * d[7], e[8] = c[0] * d[8] + c[4] * d[9] + c[8] * d[10] + c[12] * d[11], e[9] = c[1] * d[8] + c[5] * d[9] + c[9] * d[10] + c[13] * d[11], e[10] = c[2] * d[8] + c[6] * d[9] + c[10] * d[10] + c[14] * d[11], e[11] = c[3] * d[8] + c[7] * d[9] + c[11] * d[10] + c[15] * d[11], e[12] = c[0] * d[12] + c[4] * d[13] + c[8] * d[14] + c[12] * d[15], e[13] = c[1] * d[12] + c[5] * d[13] + c[9] * d[14] + c[13] * d[15], e[14] = c[2] * d[12] + c[6] * d[13] + c[10] * d[14] + c[14] * d[15], e[15] = c[3] * d[12] + c[7] * d[13] + c[11] * d[14] + c[15] * d[15], e
}, cc.getMat4MultiplyWithMat4 = function(a, b, c) {
    var d = a.mat,
        e = b.mat,
        f = c.mat;
    return f[0] = d[0] * e[0] + d[4] * e[1] + d[8] * e[2] + d[12] * e[3], f[1] = d[1] * e[0] + d[5] * e[1] + d[9] * e[2] + d[13] * e[3], f[2] = d[2] * e[0] + d[6] * e[1] + d[10] * e[2] + d[14] * e[3], f[3] = d[3] * e[0] + d[7] * e[1] + d[11] * e[2] + d[15] * e[3], f[4] = d[0] * e[4] + d[4] * e[5] + d[8] * e[6] + d[12] * e[7], f[5] = d[1] * e[4] + d[5] * e[5] + d[9] * e[6] + d[13] * e[7], f[6] = d[2] * e[4] + d[6] * e[5] + d[10] * e[6] + d[14] * e[7], f[7] = d[3] * e[4] + d[7] * e[5] + d[11] * e[6] + d[15] * e[7], f[8] = d[0] * e[8] + d[4] * e[9] + d[8] * e[10] + d[12] * e[11], f[9] = d[1] * e[8] + d[5] * e[9] + d[9] * e[10] + d[13] * e[11], f[10] = d[2] * e[8] + d[6] * e[9] + d[10] * e[10] + d[14] * e[11], f[11] = d[3] * e[8] + d[7] * e[9] + d[11] * e[10] + d[15] * e[11], f[12] = d[0] * e[12] + d[4] * e[13] + d[8] * e[14] + d[12] * e[15], f[13] = d[1] * e[12] + d[5] * e[13] + d[9] * e[14] + d[13] * e[15], f[14] = d[2] * e[12] + d[6] * e[13] + d[10] * e[14] + d[14] * e[15], f[15] = d[3] * e[12] + d[7] * e[13] + d[11] * e[14] + d[15] * e[15], c.mat
}, cc.kmMat4Assign = function(a, b) {
    if (a == b) return cc.log("cc.kmMat4Assign(): pOut equals pIn"), a;
    var c = a.mat,
        d = b.mat;
    return c[0] = d[0], c[1] = d[1], c[2] = d[2], c[3] = d[3], c[4] = d[4], c[5] = d[5], c[6] = d[6], c[7] = d[7], c[8] = d[8], c[9] = d[9], c[10] = d[10], c[11] = d[11], c[12] = d[12], c[13] = d[13], c[14] = d[14], c[15] = d[15], a
}, cc.kmMat4AreEqual = function(a, b) {
    if (a == b) return cc.log("cc.kmMat4AreEqual(): pMat1 and pMat2 are same object."), !0;
    for (var c = 0; 16 > c; c++)
        if (!(a.mat[c] + cc.kmEpsilon > b.mat[c] && a.mat[c] - cc.kmEpsilon < b.mat[c])) return !1;
    return !0
}, cc.kmMat4RotationX = function(a, b) {
    return a.mat[0] = 1, a.mat[1] = 0, a.mat[2] = 0, a.mat[3] = 0, a.mat[4] = 0, a.mat[5] = Math.cos(b), a.mat[6] = Math.sin(b), a.mat[7] = 0, a.mat[8] = 0, a.mat[9] = -Math.sin(b), a.mat[10] = Math.cos(b), a.mat[11] = 0, a.mat[12] = 0, a.mat[13] = 0, a.mat[14] = 0, a.mat[15] = 1, a
}, cc.kmMat4RotationY = function(a, b) {
    return a.mat[0] = Math.cos(b), a.mat[1] = 0, a.mat[2] = -Math.sin(b), a.mat[3] = 0, a.mat[4] = 0, a.mat[5] = 1, a.mat[6] = 0, a.mat[7] = 0, a.mat[8] = Math.sin(b), a.mat[9] = 0, a.mat[10] = Math.cos(b), a.mat[11] = 0, a.mat[12] = 0, a.mat[13] = 0, a.mat[14] = 0, a.mat[15] = 1, a
}, cc.kmMat4RotationZ = function(a, b) {
    return a.mat[0] = Math.cos(b), a.mat[1] = Math.sin(b), a.mat[2] = 0, a.mat[3] = 0, a.mat[4] = -Math.sin(b), a.mat[5] = Math.cos(b), a.mat[6] = 0, a.mat[7] = 0, a.mat[8] = 0, a.mat[9] = 0, a.mat[10] = 1, a.mat[11] = 0, a.mat[12] = 0, a.mat[13] = 0, a.mat[14] = 0, a.mat[15] = 1, a
}, cc.kmMat4RotationPitchYawRoll = function(a, b, c, d) {
    var e = Math.cos(b),
        f = Math.sin(b),
        g = Math.cos(c),
        h = Math.sin(c),
        i = Math.cos(d),
        j = Math.sin(d),
        k = f * h,
        l = e * h;
    return a.mat[0] = g * i, a.mat[4] = g * j, a.mat[8] = -h, a.mat[1] = k * i - e * j, a.mat[5] = k * j + e * i, a.mat[9] = f * g, a.mat[2] = l * i + f * j, a.mat[6] = l * j - f * i, a.mat[10] = e * g, a.mat[3] = a.mat[7] = a.mat[11] = 0, a.mat[15] = 1, a
}, cc.kmMat4RotationQuaternion = function(a, b) {
    return a.mat[0] = 1 - 2 * (b.y * b.y + b.z * b.z), a.mat[1] = 2 * (b.x * b.y + b.z * b.w), a.mat[2] = 2 * (b.x * b.z - b.y * b.w), a.mat[3] = 0, a.mat[4] = 2 * (b.x * b.y - b.z * b.w), a.mat[5] = 1 - 2 * (b.x * b.x + b.z * b.z), a.mat[6] = 2 * (b.z * b.y + b.x * b.w), a.mat[7] = 0, a.mat[8] = 2 * (b.x * b.z + b.y * b.w), a.mat[9] = 2 * (b.y * b.z - b.x * b.w), a.mat[10] = 1 - 2 * (b.x * b.x + b.y * b.y), a.mat[11] = 0, a.mat[12] = 0, a.mat[13] = 0, a.mat[14] = 0, a.mat[15] = 1, a
}, cc.kmMat4RotationTranslation = function(a, b, c) {
    return a.mat[0] = b.mat[0], a.mat[1] = b.mat[1], a.mat[2] = b.mat[2], a.mat[3] = 0, a.mat[4] = b.mat[3], a.mat[5] = b.mat[4], a.mat[6] = b.mat[5], a.mat[7] = 0, a.mat[8] = b.mat[6], a.mat[9] = b.mat[7], a.mat[10] = b.mat[8], a.mat[11] = 0, a.mat[12] = c.x, a.mat[13] = c.y, a.mat[14] = c.z, a.mat[15] = 1, a
}, cc.kmMat4Scaling = function(a, b, c, d) {
    return a.mat[0] = b, a.mat[5] = c, a.mat[10] = d, a.mat[15] = 1, a.mat[1] = a.mat[2] = a.mat[3] = a.mat[4] = a.mat[6] = a.mat[7] = a.mat[8] = a.mat[9] = a.mat[11] = a.mat[12] = a.mat[13] = a.mat[14] = 0, a
}, cc.kmMat4Translation = function(a, b, c, d) {
    return a.mat[0] = a.mat[5] = a.mat[10] = a.mat[15] = 1, a.mat[1] = a.mat[2] = a.mat[3] = a.mat[4] = a.mat[6] = a.mat[7] = a.mat[8] = a.mat[9] = a.mat[11] = 0, a.mat[12] = b, a.mat[13] = c, a.mat[14] = d, a
}, cc.kmMat4GetUpVec3 = function(a, b) {
    return a.x = b.mat[4], a.y = b.mat[5], a.z = b.mat[6], cc.kmVec3Normalize(a, a), a
}, cc.kmMat4GetRightVec3 = function(a, b) {
    return a.x = b.mat[0], a.y = b.mat[1], a.z = b.mat[2], cc.kmVec3Normalize(a, a), a
}, cc.kmMat4GetForwardVec3 = function(a, b) {
    return a.x = b.mat[8], a.y = b.mat[9], a.z = b.mat[10], cc.kmVec3Normalize(a, a), a
}, cc.kmMat4PerspectiveProjection = function(a, b, c, d, e) {
    var f = cc.kmDegreesToRadians(b / 2),
        g = e - d,
        h = Math.sin(f);
    if (0 == g || 0 == h || 0 == c) return null;
    var i = Math.cos(f) / h;
    return cc.kmMat4Identity(a), a.mat[0] = i / c, a.mat[5] = i, a.mat[10] = -(e + d) / g, a.mat[11] = -1, a.mat[14] = -2 * d * e / g, a.mat[15] = 0, a
}, cc.kmMat4OrthographicProjection = function(a, b, c, d, e, f, g) {
    return cc.kmMat4Identity(a), a.mat[0] = 2 / (c - b), a.mat[5] = 2 / (e - d), a.mat[10] = -2 / (g - f), a.mat[12] = -((c + b) / (c - b)), a.mat[13] = -((e + d) / (e - d)), a.mat[14] = -((g + f) / (g - f)), a
}, cc.kmMat4LookAt = function(a, b, c, d) {
    var e = new cc.kmVec3,
        f = new cc.kmVec3,
        g = new cc.kmVec3,
        h = new cc.kmVec3,
        i = new cc.kmMat4;
    return cc.kmVec3Subtract(e, c, b), cc.kmVec3Normalize(e, e), cc.kmVec3Assign(f, d), cc.kmVec3Normalize(f, f), cc.kmVec3Cross(g, e, f), cc.kmVec3Normalize(g, g), cc.kmVec3Cross(h, g, e), cc.kmVec3Normalize(g, g), cc.kmMat4Identity(a), a.mat[0] = g.x, a.mat[4] = g.y, a.mat[8] = g.z, a.mat[1] = h.x, a.mat[5] = h.y, a.mat[9] = h.z, a.mat[2] = -e.x, a.mat[6] = -e.y, a.mat[10] = -e.z, cc.kmMat4Translation(i, -b.x, -b.y, -b.z), cc.kmMat4Multiply(a, a, i), a
}, cc.kmMat4RotationAxisAngle = function(a, b, c) {
    var d = Math.cos(c),
        e = Math.sin(c),
        f = new cc.kmVec3;
    return cc.kmVec3Normalize(f, b), a.mat[0] = d + f.x * f.x * (1 - d), a.mat[1] = f.z * e + f.y * f.x * (1 - d), a.mat[2] = -f.y * e + f.z * f.x * (1 - d), a.mat[3] = 0, a.mat[4] = -f.z * e + f.x * f.y * (1 - d), a.mat[5] = d + f.y * f.y * (1 - d), a.mat[6] = f.x * e + f.z * f.y * (1 - d), a.mat[7] = 0, a.mat[8] = f.y * e + f.x * f.z * (1 - d), a.mat[9] = -f.x * e + f.y * f.z * (1 - d), a.mat[10] = d + f.z * f.z * (1 - d), a.mat[11] = 0, a.mat[12] = 0, a.mat[13] = 0, a.mat[14] = 0, a.mat[15] = 1, a
}, cc.kmMat4ExtractRotation = function(a, b) {
    return a.mat[0] = b.mat[0], a.mat[1] = b.mat[1], a.mat[2] = b.mat[2], a.mat[3] = b.mat[4], a.mat[4] = b.mat[5], a.mat[5] = b.mat[6], a.mat[6] = b.mat[8], a.mat[7] = b.mat[9], a.mat[8] = b.mat[10], a
}, cc.kmMat4ExtractPlane = function(a, b, c) {
    switch (c) {
        case cc.KM_PLANE_RIGHT:
            a.a = b.mat[3] - b.mat[0], a.b = b.mat[7] - b.mat[4], a.c = b.mat[11] - b.mat[8], a.d = b.mat[15] - b.mat[12];
            break;
        case cc.KM_PLANE_LEFT:
            a.a = b.mat[3] + b.mat[0], a.b = b.mat[7] + b.mat[4], a.c = b.mat[11] + b.mat[8], a.d = b.mat[15] + b.mat[12];
            break;
        case cc.KM_PLANE_BOTTOM:
            a.a = b.mat[3] + b.mat[1], a.b = b.mat[7] + b.mat[5], a.c = b.mat[11] + b.mat[9], a.d = b.mat[15] + b.mat[13];
            break;
        case cc.KM_PLANE_TOP:
            a.a = b.mat[3] - b.mat[1], a.b = b.mat[7] - b.mat[5], a.c = b.mat[11] - b.mat[9], a.d = b.mat[15] - b.mat[13];
            break;
        case cc.KM_PLANE_FAR:
            a.a = b.mat[3] - b.mat[2], a.b = b.mat[7] - b.mat[6], a.c = b.mat[11] - b.mat[10], a.d = b.mat[15] - b.mat[14];
            break;
        case cc.KM_PLANE_NEAR:
            a.a = b.mat[3] + b.mat[2], a.b = b.mat[7] + b.mat[6], a.c = b.mat[11] + b.mat[10], a.d = b.mat[15] + b.mat[14];
            break;
        default:
            cc.log("cc.kmMat4ExtractPlane(): Invalid plane index")
    }
    var d = Math.sqrt(a.a * a.a + a.b * a.b + a.c * a.c);
    return a.a /= d, a.b /= d, a.c /= d, a.d /= d, a
}, cc.kmMat4RotationToAxisAngle = function(a, b, c) {
    var d = new cc.kmQuaternion,
        e = new cc.kmMat3;
    return cc.kmMat4ExtractRotation(e, c), cc.kmQuaternionRotationMatrix(d, e), cc.kmQuaternionToAxisAngle(d, a, b), a
}, cc.KM_PLANE_LEFT = 0, cc.KM_PLANE_RIGHT = 1, cc.KM_PLANE_BOTTOM = 2, cc.KM_PLANE_TOP = 3, cc.KM_PLANE_NEAR = 4, cc.KM_PLANE_FAR = 5, cc.kmPlane = function(a, b, c, d) {
    this.a = a || 0, this.b = b || 0, this.c = c || 0, this.d = d || 0
}, cc.POINT_INFRONT_OF_PLANE = 0, cc.POINT_BEHIND_PLANE = 1, cc.POINT_ON_PLANE = 2, cc.kmPlaneDot = function(a, b) {
    return a.a * b.x + a.b * b.y + a.c * b.z + a.d * b.w
}, cc.kmPlaneDotCoord = function(a, b) {
    return a.a * b.x + a.b * b.y + a.c * b.z + a.d
}, cc.kmPlaneDotNormal = function(a, b) {
    return a.a * b.x + a.b * b.y + a.c * b.z
}, cc.kmPlaneFromPointNormal = function(a, b, c) {
    return a.a = c.x, a.b = c.y, a.c = c.z, a.d = -cc.kmVec3Dot(c, b), a
}, cc.kmPlaneFromPoints = function(a, b, c, d) {
    var e = new cc.kmVec3,
        f = new cc.kmVec3,
        g = new cc.kmVec3;
    return cc.kmVec3Subtract(f, c, b), cc.kmVec3Subtract(g, d, b), cc.kmVec3Cross(e, f, g), cc.kmVec3Normalize(e, e), a.a = e.x, a.b = e.y, a.c = e.z, a.d = cc.kmVec3Dot(cc.kmVec3Scale(e, e, -1), b), a
}, cc.kmPlaneIntersectLine = function() {
    throw "cc.kmPlaneIntersectLine() hasn't been implemented."
}, cc.kmPlaneNormalize = function(a, b) {
    var c = new cc.kmVec3;
    c.x = b.a, c.y = b.b, c.z = b.c;
    var d = 1 / cc.kmVec3Length(c);
    return cc.kmVec3Normalize(c, c), a.a = c.x, a.b = c.y, a.c = c.z, a.d = b.d * d, a
}, cc.kmPlaneScale = function() {
    cc.log("cc.kmPlaneScale() has not been implemented.")
}, cc.kmPlaneClassifyPoint = function(a, b) {
    var c = a.a * b.x + a.b * b.y + a.c * b.z + a.d;
    return c > .001 ? cc.POINT_INFRONT_OF_PLANE : -.001 > c ? cc.POINT_BEHIND_PLANE : cc.POINT_ON_PLANE
}, cc.kmQuaternion = function(a, b, c, d) {
    this.x = a || 0, this.y = b || 0, this.z = c || 0, this.w = d || 0
}, cc.kmQuaternionConjugate = function(a, b) {
    return a.x = -b.x, a.y = -b.y, a.z = -b.z, a.w = b.w, a
}, cc.kmQuaternionDot = function(a, b) {
    return a.w * b.w + a.x * b.x + a.y * b.y + a.z * b.z
}, cc.kmQuaternionExp = function(a) {
    return a
}, cc.kmQuaternionIdentity = function(a) {
    return a.x = 0, a.y = 0, a.z = 0, a.w = 1, a
}, cc.kmQuaternionInverse = function(a, b) {
    var c = cc.kmQuaternionLength(b),
        d = new cc.kmQuaternion;
    return Math.abs(c) > cc.kmEpsilon ? (a.x = 0, a.y = 0, a.z = 0, a.w = 0, a) : (cc.kmQuaternionScale(a, cc.kmQuaternionConjugate(d, b), 1 / c), a)
}, cc.kmQuaternionIsIdentity = function(a) {
    return 0 == a.x && 0 == a.y && 0 == a.z && 1 == a.w
}, cc.kmQuaternionLength = function(a) {
    return Math.sqrt(cc.kmQuaternionLengthSq(a))
}, cc.kmQuaternionLengthSq = function(a) {
    return a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w
}, cc.kmQuaternionLn = function(a) {
    return a
}, cc.kmQuaternionMultiply = function(a, b, c) {
    return a.w = b.w * c.w - b.x * c.x - b.y * c.y - b.z * c.z, a.x = b.w * c.x + b.x * c.w + b.y * c.z - b.z * c.y, a.y = b.w * c.y + b.y * c.w + b.z * c.x - b.x * c.z, a.z = b.w * c.z + b.z * c.w + b.x * c.y - b.y * c.x, a
}, cc.kmQuaternionNormalize = function(a, b) {
    var c = cc.kmQuaternionLength(b);
    if (Math.abs(c) <= cc.kmEpsilon) throw "cc.kmQuaternionNormalize(): pIn is an invalid value";
    return cc.kmQuaternionScale(a, b, 1 / c), a
}, cc.kmQuaternionRotationAxis = function(a, b, c) {
    var d = .5 * c,
        e = Math.sin(d);
    return a.w = Math.cos(d), a.x = b.x * e, a.y = b.y * e, a.z = b.z * e, a
}, cc.kmQuaternionRotationMatrix = function(a, b) {
    var c, d, e, f, g = [],
        h = 0,
        i = 0;
    if (!b) return null;
    g[0] = b.mat[0], g[1] = b.mat[3], g[2] = b.mat[6], g[4] = b.mat[1], g[5] = b.mat[4], g[6] = b.mat[7], g[8] = b.mat[2], g[9] = b.mat[5], g[10] = b.mat[8], g[15] = 1;
    var j = g[0];
    return i = j[0] + j[5] + j[10] + 1, i > cc.kmEpsilon ? (h = 2 * Math.sqrt(i), c = (j[9] - j[6]) / h, d = (j[2] - j[8]) / h, e = (j[4] - j[1]) / h, f = .25 * h) : j[0] > j[5] && j[0] > j[10] ? (h = 2 * Math.sqrt(1 + j[0] - j[5] - j[10]), c = .25 * h, d = (j[4] + j[1]) / h, e = (j[2] + j[8]) / h, f = (j[9] - j[6]) / h) : j[5] > j[10] ? (h = 2 * Math.sqrt(1 + j[5] - j[0] - j[10]), c = (j[4] + j[1]) / h, d = .25 * h, e = (j[9] + j[6]) / h, f = (j[2] - j[8]) / h) : (h = 2 * Math.sqrt(1 + j[10] - j[0] - j[5]), c = (j[2] + j[8]) / h, d = (j[9] + j[6]) / h, e = .25 * h, f = (j[4] - j[1]) / h), a.x = c, a.y = d, a.z = e, a.w = f, a
}, cc.kmQuaternionRotationYawPitchRoll = function(a, b, c, d) {
    var e, f, g, h, i, j, k, l, m, n, o;
    return e = cc.kmDegreesToRadians(c) / 2, f = cc.kmDegreesToRadians(b) / 2, g = cc.kmDegreesToRadians(d) / 2, h = Math.cos(e), i = Math.cos(f), j = Math.cos(g), k = Math.sin(e), l = Math.sin(f), m = Math.sin(g), n = i * j, o = l * m, a.w = h * n + k * o, a.x = k * n - h * o, a.y = h * l * j + k * i * m, a.z = h * i * m - k * l * j, cc.kmQuaternionNormalize(a, a), a
}, cc.kmQuaternionSlerp = function(a, b, c, d) {
    if (b.x == c.x && b.y == c.y && b.z == c.z && b.w == c.w) return a.x = b.x, a.y = b.y, a.z = b.z, a.w = b.w, a;
    var e = cc.kmQuaternionDot(b, c),
        f = Math.acos(e),
        g = Math.sqrt(1 - cc.kmSQR(e)),
        h = Math.sin(d * f) / g,
        i = Math.sin((1 - d) * f) / g,
        j = new cc.kmQuaternion,
        k = new cc.kmQuaternion;
    return cc.kmQuaternionScale(j, b, i), cc.kmQuaternionScale(k, c, h), cc.kmQuaternionAdd(a, j, k), a
}, cc.kmQuaternionToAxisAngle = function(a, b, c) {
    var d, e;
    d = Math.acos(a.w), e = Math.sqrt(cc.kmSQR(a.x) + cc.kmSQR(a.y) + cc.kmSQR(a.z)), e > -cc.kmEpsilon && e < cc.kmEpsilon || e < 2 * cc.kmPI + cc.kmEpsilon && e > 2 * cc.kmPI - cc.kmEpsilon ? (c = 0, b.x = 0, b.y = 0, b.z = 1) : (c = 2 * d, b.x = a.x / e, b.y = a.y / e, b.z = a.z / e, cc.kmVec3Normalize(b, b))
}, cc.kmQuaternionScale = function(a, b, c) {
    return a.x = b.x * c, a.y = b.y * c, a.z = b.z * c, a.w = b.w * c, a
}, cc.kmQuaternionAssign = function(a, b) {
    return a.x = b.x, a.y = b.y, a.z = b.z, a.w = b.w, a
}, cc.kmQuaternionAdd = function(a, b, c) {
    return a.x = b.x + c.x, a.y = b.y + c.y, a.z = b.z + c.z, a.w = b.w + c.w, a
}, cc.kmQuaternionRotationBetweenVec3 = function(a, b, c, d) {
    var e, f = new cc.kmVec3,
        g = new cc.kmVec3;
    if (cc.kmVec3Assign(f, b), cc.kmVec3Assign(g, c), cc.kmVec3Normalize(f, f), cc.kmVec3Normalize(g, g), e = cc.kmVec3Dot(f, g), e >= 1) return cc.kmQuaternionIdentity(a), a;
    if (1e-6 - 1 > e)
        if (Math.abs(cc.kmVec3LengthSq(d)) < cc.kmEpsilon) cc.kmQuaternionRotationAxis(a, d, cc.kmPI);
        else {
            var h = new cc.kmVec3,
                i = new cc.kmVec3;
            if (i.x = 1, i.y = 0, i.z = 0, cc.kmVec3Cross(h, i, b), Math.abs(cc.kmVec3LengthSq(h)) < cc.kmEpsilon) {
                var j = new cc.kmVec3;
                j.x = 0, j.y = 1, j.z = 0, cc.kmVec3Cross(h, j, b)
            }
            cc.kmVec3Normalize(h, h), cc.kmQuaternionRotationAxis(a, h, cc.kmPI)
        } else {
        var k = Math.sqrt(2 * (1 + e)),
            l = 1 / k,
            m = new cc.kmVec3;
        cc.kmVec3Cross(m, f, g), a.x = m.x * l, a.y = m.y * l, a.z = m.z * l, a.w = .5 * k, cc.kmQuaternionNormalize(a, a)
    }
    return a
}, cc.kmQuaternionMultiplyVec3 = function(a, b, c) {
    var d = new cc.kmVec3,
        e = new cc.kmVec3,
        f = new cc.kmVec3;
    return f.x = b.x, f.y = b.y, f.z = b.z, cc.kmVec3Cross(d, f, c), cc.kmVec3Cross(e, f, d), cc.kmVec3Scale(d, d, 2 * b.w), cc.kmVec3Scale(e, e, 2), cc.kmVec3Add(a, c, d), cc.kmVec3Add(a, a, e), a
}, cc.kmAABB = function(a, b) {
    this.min = a || new cc.kmVec3, this.max = b || new cc.kmVec3
}, cc.kmAABBContainsPoint = function(a, b) {
    return a.x >= b.min.x && a.x <= b.max.x && a.y >= b.min.y && a.y <= b.max.y && a.z >= b.min.z && a.z <= b.max.z ? cc.KM_TRUE : cc.KM_FALSE
}, cc.kmAABBAssign = function(a, b) {
    return cc.kmVec3Assign(a.min, b.min), cc.kmVec3Assign(a.max, b.max), a
}, cc.kmAABBScale = function() {
    cc.log("cc.kmAABBScale hasn't been supported.")
}, cc.km_mat4_stack = function(a, b, c, d) {
    this.top = c, this.stack = d
}, cc.km_mat4_stack.INITIAL_SIZE = 30, cc.km_mat4_stack_initialize = function(a) {
    a.stack = [], a.top = null
}, cc.km_mat4_stack_push = function(a, b) {
    a.stack.push(a.top), a.top = new cc.kmMat4, cc.kmMat4Assign(a.top, b)
}, cc.km_mat4_stack_pop = function(a) {
    a.top = a.stack.pop()
}, cc.km_mat4_stack_release = function(a) {
    a.stack = null, a.top = null, a = null
}, cc.KM_GL_MODELVIEW = 5888, cc.KM_GL_PROJECTION = 5889, cc.KM_GL_TEXTURE = 5890, cc.modelview_matrix_stack = new cc.km_mat4_stack, cc.projection_matrix_stack = new cc.km_mat4_stack, cc.texture_matrix_stack = new cc.km_mat4_stack, cc.current_stack = null, cc.initialized = !1, cc.lazyInitialize = function() {
    if (!cc.initialized) {
        var a = new cc.kmMat4;
        cc.km_mat4_stack_initialize(cc.modelview_matrix_stack), cc.km_mat4_stack_initialize(cc.projection_matrix_stack), cc.km_mat4_stack_initialize(cc.texture_matrix_stack), cc.current_stack = cc.modelview_matrix_stack, cc.initialized = !0, cc.kmMat4Identity(a), cc.km_mat4_stack_push(cc.modelview_matrix_stack, a), cc.km_mat4_stack_push(cc.projection_matrix_stack, a), cc.km_mat4_stack_push(cc.texture_matrix_stack, a)
    }
}, cc.lazyInitialize(), cc.kmGLFreeAll = function() {
    cc.km_mat4_stack_release(cc.modelview_matrix_stack), cc.km_mat4_stack_release(cc.projection_matrix_stack), cc.km_mat4_stack_release(cc.texture_matrix_stack), cc.initialized = !1, cc.current_stack = null
}, cc.kmGLPushMatrix = function() {
    cc.km_mat4_stack_push(cc.current_stack, cc.current_stack.top)
}, cc.kmGLPushMatrixWitMat4 = function(a) {
    cc.current_stack.stack.push(cc.current_stack.top), cc.kmMat4Assign(a, cc.current_stack.top), cc.current_stack.top = a
}, cc.kmGLPopMatrix = function() {
    cc.current_stack.top = cc.current_stack.stack.pop()
}, cc.kmGLMatrixMode = function(a) {
    switch (a) {
        case cc.KM_GL_MODELVIEW:
            cc.current_stack = cc.modelview_matrix_stack;
            break;
        case cc.KM_GL_PROJECTION:
            cc.current_stack = cc.projection_matrix_stack;
            break;
        case cc.KM_GL_TEXTURE:
            cc.current_stack = cc.texture_matrix_stack;
            break;
        default:
            throw "Invalid matrix mode specified"
    }
}, cc.kmGLLoadIdentity = function() {
    cc.kmMat4Identity(cc.current_stack.top)
}, cc.kmGLLoadMatrix = function(a) {
    cc.kmMat4Assign(cc.current_stack.top, a)
}, cc.kmGLMultMatrix = function(a) {
    cc.kmMat4Multiply(cc.current_stack.top, cc.current_stack.top, a)
}, cc.kmGLTranslatef = function(a, b, c) {
    var d = new cc.kmMat4;
    cc.kmMat4Translation(d, a, b, c), cc.kmMat4Multiply(cc.current_stack.top, cc.current_stack.top, d)
}, cc.kmGLRotatef = function(a, b, c, d) {
    var e = new cc.kmVec3(b, c, d),
        f = new cc.kmMat4;
    cc.kmMat4RotationAxisAngle(f, e, cc.kmDegreesToRadians(a)), cc.kmMat4Multiply(cc.current_stack.top, cc.current_stack.top, f)
}, cc.kmGLScalef = function(a, b, c) {
    var d = new cc.kmMat4;
    cc.kmMat4Scaling(d, a, b, c), cc.kmMat4Multiply(cc.current_stack.top, cc.current_stack.top, d)
}, cc.kmGLGetMatrix = function(a, b) {
    switch (a) {
        case cc.KM_GL_MODELVIEW:
            cc.kmMat4Assign(b, cc.modelview_matrix_stack.top);
            break;
        case cc.KM_GL_PROJECTION:
            cc.kmMat4Assign(b, cc.projection_matrix_stack.top);
            break;
        case cc.KM_GL_TEXTURE:
            cc.kmMat4Assign(b, cc.texture_matrix_stack.top);
            break;
        default:
            throw "Invalid matrix mode specified"
    }
};
cc.SHADER_POSITION_UCOLOR_FRAG = "precision lowp float;\nvarying vec4 v_fragmentColor;\nvoid main()                              \n{ \n    gl_FragColor = v_fragmentColor;      \n}\n", cc.SHADER_POSITION_UCOLOR_VERT = "attribute vec4 a_position;\nuniform    vec4 u_color;\nuniform float u_pointSize;\nvarying lowp vec4 v_fragmentColor; \nvoid main(void)   \n{\n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n    gl_PointSize = u_pointSize;          \n    v_fragmentColor = u_color;           \n}", cc.SHADER_POSITION_COLOR_FRAG = "precision lowp float; \nvarying vec4 v_fragmentColor; \nvoid main() \n{ \n     gl_FragColor = v_fragmentColor; \n} ", cc.SHADER_POSITION_COLOR_VERT = "attribute vec4 a_position;\nattribute vec4 a_color;\nvarying lowp vec4 v_fragmentColor;\nvoid main()\n{\n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_fragmentColor = a_color;             \n}", cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_FRAG = "// #extension GL_OES_standard_derivatives : enable\nvarying mediump vec4 v_color;\nvarying mediump vec2 v_texcoord;\nvoid main()	\n{ \n// #if defined GL_OES_standard_derivatives	\n// gl_FragColor = v_color*smoothstep(0.0, length(fwidth(v_texcoord)), 1.0 - length(v_texcoord)); \n// #else	\ngl_FragColor = v_color * step(0.0, 1.0 - length(v_texcoord)); \n// #endif \n}", cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_VERT = "attribute mediump vec4 a_position; \nattribute mediump vec2 a_texcoord; \nattribute mediump vec4 a_color;	\nvarying mediump vec4 v_color; \nvarying mediump vec2 v_texcoord;	\nvoid main() \n{ \n     v_color = a_color;//vec4(a_color.rgb * a_color.a, a_color.a); \n     v_texcoord = a_texcoord; \n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n}", cc.SHADER_POSITION_TEXTURE_FRAG = "precision lowp float;   \nvarying vec2 v_texCoord;  \nvoid main() \n{  \n    gl_FragColor =  texture2D(CC_Texture0, v_texCoord);   \n}", cc.SHADER_POSITION_TEXTURE_VERT = "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_texCoord = a_texCoord;               \n}", cc.SHADER_POSITION_TEXTURE_UCOLOR_FRAG = "precision lowp float;  \nuniform vec4 u_color; \nvarying vec2 v_texCoord; \nvoid main() \n{  \n    gl_FragColor =  texture2D(CC_Texture0, v_texCoord) * u_color;    \n}", cc.SHADER_POSITION_TEXTURE_UCOLOR_VERT = "attribute vec4 a_position;\nattribute vec2 a_texCoord; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_texCoord = a_texCoord;                 \n}", cc.SHADER_POSITION_TEXTURE_A8COLOR_FRAG = "precision lowp float;  \nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nvoid main() \n{ \n    gl_FragColor = vec4( v_fragmentColor.rgb,         \n        v_fragmentColor.a * texture2D(CC_Texture0, v_texCoord).a   \n    ); \n}", cc.SHADER_POSITION_TEXTURE_A8COLOR_VERT = "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nattribute vec4 a_color;  \nvarying lowp vec4 v_fragmentColor; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_fragmentColor = a_color; \n    v_texCoord = a_texCoord; \n}", cc.SHADER_POSITION_TEXTURE_COLOR_FRAG = "precision lowp float;\nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nvoid main() \n{ \n    gl_FragColor = v_fragmentColor * texture2D(CC_Texture0, v_texCoord); \n}", cc.SHADER_POSITION_TEXTURE_COLOR_VERT = "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nattribute vec4 a_color;  \nvarying lowp vec4 v_fragmentColor; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_fragmentColor = a_color; \n    v_texCoord = a_texCoord; \n}", cc.SHADER_POSITION_TEXTURE_COLOR_ALPHATEST_FRAG = "precision lowp float;   \nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord;   \nuniform float CC_alpha_value; \nvoid main() \n{  \n    vec4 texColor = texture2D(CC_Texture0, v_texCoord);  \n    if ( texColor.a <= CC_alpha_value )          \n        discard; \n    gl_FragColor = texColor * v_fragmentColor;  \n}", cc.SHADEREX_SWITCHMASK_FRAG = "precision lowp float; \nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nuniform sampler2D u_texture;  \nuniform sampler2D   u_mask;   \nvoid main()  \n{  \n    vec4 texColor   = texture2D(u_texture, v_texCoord);  \n    vec4 maskColor  = texture2D(u_mask, v_texCoord); \n    vec4 finalColor = vec4(texColor.r, texColor.g, texColor.b, maskColor.a * texColor.a);        \n    gl_FragColor    = v_fragmentColor * finalColor; \n}", cc.shaderCache = {
    TYPE_POSITION_TEXTURECOLOR: 0,
    TYPE_POSITION_TEXTURECOLOR_ALPHATEST: 1,
    TYPE_POSITION_COLOR: 2,
    TYPE_POSITION_TEXTURE: 3,
    TYPE_POSITION_TEXTURE_UCOLOR: 4,
    TYPE_POSITION_TEXTURE_A8COLOR: 5,
    TYPE_POSITION_UCOLOR: 6,
    TYPE_POSITION_LENGTH_TEXTURECOLOR: 7,
    TYPE_MAX: 8,
    _programs: {},
    _init: function() {
        return this.loadDefaultShaders(), !0
    },
    _loadDefaultShader: function(a, b) {
        switch (b) {
            case this.TYPE_POSITION_TEXTURECOLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_COLOR_VERT, cc.SHADER_POSITION_TEXTURE_COLOR_FRAG), a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION), a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR), a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                break;
            case this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_COLOR_VERT, cc.SHADER_POSITION_TEXTURE_COLOR_ALPHATEST_FRAG), a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION), a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR), a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                break;
            case this.TYPE_POSITION_COLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_COLOR_VERT, cc.SHADER_POSITION_COLOR_FRAG), a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION), a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
                break;
            case this.TYPE_POSITION_TEXTURE:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_VERT, cc.SHADER_POSITION_TEXTURE_FRAG), a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION), a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                break;
            case this.TYPE_POSITION_TEXTURE_UCOLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_UCOLOR_VERT, cc.SHADER_POSITION_TEXTURE_UCOLOR_FRAG), a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION), a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                break;
            case this.TYPE_POSITION_TEXTURE_A8COLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_A8COLOR_VERT, cc.SHADER_POSITION_TEXTURE_A8COLOR_FRAG), a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION), a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR), a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                break;
            case this.TYPE_POSITION_UCOLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_UCOLOR_VERT, cc.SHADER_POSITION_UCOLOR_FRAG), a.addAttribute("aVertex", cc.VERTEX_ATTRIB_POSITION);
                break;
            case this.TYPE_POSITION_LENGTH_TEXTURECOLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_VERT, cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_FRAG), a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION), a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS), a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
                break;
            default:
                return void cc.log("cocos2d: cc.shaderCache._loadDefaultShader, error shader type")
        }
        a.link(), a.updateUniforms()
    },
    loadDefaultShaders: function() {
        var a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURECOLOR), this._programs[cc.SHADER_POSITION_TEXTURECOLOR] = a, this._programs.ShaderPositionTextureColor = a, a = new cc.GLProgram, this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST), this._programs[cc.SHADER_POSITION_TEXTURECOLORALPHATEST] = a, this._programs.ShaderPositionTextureColorAlphaTest = a, a = new cc.GLProgram, this._loadDefaultShader(a, this.TYPE_POSITION_COLOR), this._programs[cc.SHADER_POSITION_COLOR] = a, this._programs.ShaderPositionColor = a, a = new cc.GLProgram, this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE), this._programs[cc.SHADER_POSITION_TEXTURE] = a, this._programs.ShaderPositionTexture = a, a = new cc.GLProgram, this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE_UCOLOR), this._programs[cc.SHADER_POSITION_TEXTURE_UCOLOR] = a, this._programs.ShaderPositionTextureUColor = a, a = new cc.GLProgram, this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE_A8COLOR), this._programs[cc.SHADER_POSITION_TEXTUREA8COLOR] = a, this._programs.ShaderPositionTextureA8Color = a, a = new cc.GLProgram, this._loadDefaultShader(a, this.TYPE_POSITION_UCOLOR), this._programs[cc.SHADER_POSITION_UCOLOR] = a, this._programs.ShaderPositionUColor = a, a = new cc.GLProgram, this._loadDefaultShader(a, this.TYPE_POSITION_LENGTH_TEXTURECOLOR), this._programs[cc.SHADER_POSITION_LENGTHTEXTURECOLOR] = a, this._programs.ShaderPositionLengthTextureColor = a
    },
    reloadDefaultShaders: function() {
        var a = this.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
        a.reset(), this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURECOLOR), a = this.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST), a.reset(), this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST), a = this.programForKey(cc.SHADER_POSITION_COLOR), a.reset(), this._loadDefaultShader(a, this.TYPE_POSITION_COLOR), a = this.programForKey(cc.SHADER_POSITION_TEXTURE), a.reset(), this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE), a = this.programForKey(cc.SHADER_POSITION_TEXTURE_UCOLOR), a.reset(), this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE_UCOLOR), a = this.programForKey(cc.SHADER_POSITION_TEXTUREA8COLOR), a.reset(), this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE_A8COLOR), a = this.programForKey(cc.SHADER_POSITION_UCOLOR), a.reset(), this._loadDefaultShader(a, this.TYPE_POSITION_UCOLOR)
    },
    programForKey: function(a) {
        return this._programs[a]
    },
    getProgram: function(a) {
        return this._programs[a]
    },
    addProgram: function(a, b) {
        this._programs[b] = a
    }
}, cc.HashUniformEntry = function(a, b, c) {
    this.value = a, this.location = b, this.hh = c || {}
}, cc.GLProgram = cc.Class.extend({
    _glContext: null,
    _programObj: null,
    _vertShader: null,
    _fragShader: null,
    _uniforms: null,
    _hashForUniforms: null,
    _usesTime: !1,
    _updateUniformLocation: function(a, b) {
        if (null == a) return !1;
        for (var c = !0, d = null, e = 0; e < this._hashForUniforms.length; e++) this._hashForUniforms[e].location == a && (d = this._hashForUniforms[e]);
        return d ? d.value == b ? c = !1 : d.value = b : (d = new cc.HashUniformEntry, d.location = a, d.value = b, this._hashForUniforms.push(d)), c
    },
    _description: function() {
        return "<CCGLProgram = " + this.toString() + " | Program = " + this._programObj.toString() + ", VertexShader = " + this._vertShader.toString() + ", FragmentShader = " + this._fragShader.toString() + ">"
    },
    _compileShader: function(a, b, c) {
        if (!c || !a) return !1;
        c = "precision highp float;        \nuniform mat4 CC_PMatrix;         \nuniform mat4 CC_MVMatrix;        \nuniform mat4 CC_MVPMatrix;       \nuniform vec4 CC_Time;            \nuniform vec4 CC_SinTime;         \nuniform vec4 CC_CosTime;         \nuniform vec4 CC_Random01;        \nuniform sampler2D CC_Texture0;   \n//CC INCLUDES END                \n" + c, this._glContext.shaderSource(a, c), this._glContext.compileShader(a);
        var d = this._glContext.getShaderParameter(a, this._glContext.COMPILE_STATUS);
        return d || (cc.log("cocos2d: ERROR: Failed to compile shader:\n" + this._glContext.getShaderSource(a)), cc.log(b == this._glContext.VERTEX_SHADER ? "cocos2d: \n" + this.vertexShaderLog() : "cocos2d: \n" + this.fragmentShaderLog())), 1 == d
    },
    ctor: function(a, b, c) {
        this._uniforms = [], this._hashForUniforms = [], this._glContext = c || cc._renderContext, a && b && this.init(a, b)
    },
    destroyProgram: function() {
        this._vertShader = null, this._fragShader = null, this._uniforms = null, this._hashForUniforms = null, this._glContext.deleteProgram(this._programObj)
    },
    initWithVertexShaderByteArray: function(a, b) {
        var c = this._glContext;
        return this._programObj = c.createProgram(), this._vertShader = null, this._fragShader = null, a && (this._vertShader = c.createShader(c.VERTEX_SHADER), this._compileShader(this._vertShader, c.VERTEX_SHADER, a) || cc.log("cocos2d: ERROR: Failed to compile vertex shader")), b && (this._fragShader = c.createShader(c.FRAGMENT_SHADER), this._compileShader(this._fragShader, c.FRAGMENT_SHADER, b) || cc.log("cocos2d: ERROR: Failed to compile fragment shader")), this._vertShader && c.attachShader(this._programObj, this._vertShader), cc.checkGLErrorDebug(), this._fragShader && c.attachShader(this._programObj, this._fragShader), this._hashForUniforms.length = 0, cc.checkGLErrorDebug(), !0
    },
    initWithString: function(a, b) {
        return this.initWithVertexShaderByteArray(a, b)
    },
    initWithVertexShaderFilename: function(a, b) {
        var c = cc.loader.getRes(a);
        if (!c) throw "Please load the resource firset : " + a;
        var d = cc.loader.getRes(b);
        if (!d) throw "Please load the resource firset : " + b;
        return this.initWithVertexShaderByteArray(c, d)
    },
    init: function(a, b) {
        return this.initWithVertexShaderFilename(a, b)
    },
    addAttribute: function(a, b) {
        this._glContext.bindAttribLocation(this._programObj, b, a)
    },
    link: function() {
        if (!this._programObj) return cc.log("cc.GLProgram.link(): Cannot link invalid program"), !1;
        if (this._glContext.linkProgram(this._programObj), this._vertShader && this._glContext.deleteShader(this._vertShader), this._fragShader && this._glContext.deleteShader(this._fragShader), this._vertShader = null, this._fragShader = null, cc.game.config[cc.game.CONFIG_KEY.debugMode]) {
            var a = this._glContext.getProgramParameter(this._programObj, this._glContext.LINK_STATUS);
            if (!a) return cc.log("cocos2d: ERROR: Failed to link program: " + this._glContext.getProgramInfoLog(this._programObj)), cc.glDeleteProgram(this._programObj), this._programObj = null, !1
        }
        return !0
    },
    use: function() {
        cc.glUseProgram(this._programObj)
    },
    updateUniforms: function() {
        this._uniforms[cc.UNIFORM_PMATRIX] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_PMATRIX_S), this._uniforms[cc.UNIFORM_MVMATRIX] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_MVMATRIX_S), this._uniforms[cc.UNIFORM_MVPMATRIX] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_MVPMATRIX_S), this._uniforms[cc.UNIFORM_TIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_TIME_S), this._uniforms[cc.UNIFORM_SINTIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_SINTIME_S), this._uniforms[cc.UNIFORM_COSTIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_COSTIME_S), this._usesTime = null != this._uniforms[cc.UNIFORM_TIME] || null != this._uniforms[cc.UNIFORM_SINTIME] || null != this._uniforms[cc.UNIFORM_COSTIME], this._uniforms[cc.UNIFORM_RANDOM01] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_RANDOM01_S), this._uniforms[cc.UNIFORM_SAMPLER] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_SAMPLER_S), this.use(), this.setUniformLocationWith1i(this._uniforms[cc.UNIFORM_SAMPLER], 0)
    },
    getUniformLocationForName: function(a) {
        if (!a) throw "cc.GLProgram.getUniformLocationForName(): uniform name should be non-null";
        if (!this._programObj) throw "cc.GLProgram.getUniformLocationForName(): Invalid operation. Cannot get uniform location when program is not initialized";
        return this._glContext.getUniformLocation(this._programObj, a)
    },
    getUniformMVPMatrix: function() {
        return this._uniforms[cc.UNIFORM_MVPMATRIX]
    },
    getUniformSampler: function() {
        return this._uniforms[cc.UNIFORM_SAMPLER]
    },
    setUniformLocationWith1i: function(a, b) {
        var c = this._updateUniformLocation(a, b);
        c && this._glContext.uniform1i(a, b)
    },
    setUniformLocationWith2i: function(a, b, c) {
        var d = [b, c],
            e = this._updateUniformLocation(a, d);
        e && this._glContext.uniform2i(a, b, c)
    },
    setUniformLocationWith3i: function(a, b, c, d) {
        var e = [b, c, d],
            f = this._updateUniformLocation(a, e);
        f && this._glContext.uniform3i(a, b, c, d)
    },
    setUniformLocationWith4i: function(a, b, c, d, e) {
        var f = [b, c, d, e],
            g = this._updateUniformLocation(a, f);
        g && this._glContext.uniform4i(a, b, c, d, e)
    },
    setUniformLocationWith2iv: function(a, b) {
        var c = this._updateUniformLocation(a, b);
        c && this._glContext.uniform2iv(a, b)
    },
    setUniformLocationWith3iv: function(a, b) {
        var c = this._updateUniformLocation(a, b);
        c && this._glContext.uniform3iv(a, b)
    },
    setUniformLocationWith4iv: function(a, b) {
        var c = this._updateUniformLocation(a, b);
        c && this._glContext.uniform4iv(a, b)
    },
    setUniformLocationI32: function() {
        this.setUniformLocationWith1i(arguments[0], arguments[1])
    },
    setUniformLocationWith1f: function(a, b) {
        var c = this._updateUniformLocation(a, b);
        c && this._glContext.uniform1f(a, b)
    },
    setUniformLocationWith2f: function(a, b, c) {
        var d = [b, c],
            e = this._updateUniformLocation(a, d);
        e && this._glContext.uniform2f(a, b, c)
    },
    setUniformLocationWith3f: function(a, b, c, d) {
        var e = [b, c, d],
            f = this._updateUniformLocation(a, e);
        f && this._glContext.uniform3f(a, b, c, d)
    },
    setUniformLocationWith4f: function(a, b, c, d, e) {
        var f = [b, c, d, e],
            g = this._updateUniformLocation(a, f);
        g && this._glContext.uniform4f(a, b, c, d, e)
    },
    setUniformLocationWith2fv: function(a, b) {
        var c = this._updateUniformLocation(a, b);
        c && this._glContext.uniform2fv(a, b)
    },
    setUniformLocationWith3fv: function(a, b) {
        var c = this._updateUniformLocation(a, b);
        c && this._glContext.uniform3fv(a, b)
    },
    setUniformLocationWith4fv: function(a, b) {
        var c = this._updateUniformLocation(a, b);
        c && this._glContext.uniform4fv(a, b)
    },
    setUniformLocationWithMatrix4fv: function(a, b) {
        var c = this._updateUniformLocation(a, b);
        c && this._glContext.uniformMatrix4fv(a, !1, b)
    },
    setUniformLocationF32: function() {
        if (!(arguments.length < 2)) switch (arguments.length) {
            case 2:
                this.setUniformLocationWith1f(arguments[0], arguments[1]);
                break;
            case 3:
                this.setUniformLocationWith2f(arguments[0], arguments[1], arguments[2]);
                break;
            case 4:
                this.setUniformLocationWith3f(arguments[0], arguments[1], arguments[2], arguments[3]);
                break;
            case 5:
                this.setUniformLocationWith4f(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4])
        }
    },
    setUniformsForBuiltins: function() {
        var a = new cc.kmMat4,
            b = new cc.kmMat4,
            c = new cc.kmMat4;
        if (cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, a), cc.kmGLGetMatrix(cc.KM_GL_MODELVIEW, b), cc.kmMat4Multiply(c, a, b), this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], a.mat, 1), this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], b.mat, 1), this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], c.mat, 1), this._usesTime) {
            var d = cc.director,
                e = d.getTotalFrames() * d.getAnimationInterval();
            this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_TIME], e / 10, e, 2 * e, 4 * e), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_SINTIME], e / 8, e / 4, e / 2, Math.sin(e)), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_COSTIME], e / 8, e / 4, e / 2, Math.cos(e))
        } - 1 != this._uniforms[cc.UNIFORM_RANDOM01] && this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_RANDOM01], Math.random(), Math.random(), Math.random(), Math.random())
    },
    _setUniformsForBuiltinsForRenderer: function(a) {
        if (a && a._renderCmd) {
            var b = new cc.kmMat4,
                c = new cc.kmMat4;
            if (cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, b), cc.kmMat4Multiply(c, b, a._renderCmd._stackMatrix), this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], b.mat, 1), this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], a._renderCmd._stackMatrix.mat, 1), this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], c.mat, 1), this._usesTime) {
                var d = cc.director,
                    e = d.getTotalFrames() * d.getAnimationInterval();
                this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_TIME], e / 10, e, 2 * e, 4 * e), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_SINTIME], e / 8, e / 4, e / 2, Math.sin(e)), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_COSTIME], e / 8, e / 4, e / 2, Math.cos(e))
            } - 1 != this._uniforms[cc.UNIFORM_RANDOM01] && this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_RANDOM01], Math.random(), Math.random(), Math.random(), Math.random())
        }
    },
    setUniformForModelViewProjectionMatrix: function() {
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], !1, cc.getMat4MultiplyValue(cc.projection_matrix_stack.top, cc.modelview_matrix_stack.top))
    },
    setUniformForModelViewProjectionMatrixWithMat4: function(a) {
        cc.kmMat4Multiply(a, cc.projection_matrix_stack.top, cc.modelview_matrix_stack.top), this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], !1, a.mat)
    },
    setUniformForModelViewAndProjectionMatrixWithMat4: function() {
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], !1, cc.modelview_matrix_stack.top.mat), this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], !1, cc.projection_matrix_stack.top.mat)
    },
    _setUniformForMVPMatrixWithMat4: function(a) {
        if (!a) throw "modelView matrix is undefined.";
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], !1, a.mat), this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], !1, cc.projection_matrix_stack.top.mat)
    },
    vertexShaderLog: function() {
        return this._glContext.getShaderInfoLog(this._vertShader)
    },
    getVertexShaderLog: function() {
        return this._glContext.getShaderInfoLog(this._vertShader)
    },
    getFragmentShaderLog: function() {
        return this._glContext.getShaderInfoLog(this._vertShader)
    },
    fragmentShaderLog: function() {
        return this._glContext.getShaderInfoLog(this._fragShader)
    },
    programLog: function() {
        return this._glContext.getProgramInfoLog(this._programObj)
    },
    getProgramLog: function() {
        return this._glContext.getProgramInfoLog(this._programObj)
    },
    reset: function() {
        this._vertShader = null, this._fragShader = null, this._uniforms.length = 0, this._glContext.deleteProgram(this._programObj), this._programObj = null;
        for (var a = 0; a < this._hashForUniforms.length; a++) this._hashForUniforms[a].value = null, this._hashForUniforms[a] = null;
        this._hashForUniforms.length = 0
    },
    getProgram: function() {
        return this._programObj
    },
    retain: function() {},
    release: function() {}
}), cc.GLProgram.create = function(a, b) {
    return new cc.GLProgram(a, b)
}, cc.setProgram = function(a, b) {
    a.shaderProgram = b;
    var c = a.children;
    if (c)
        for (var d = 0; d < c.length; d++) cc.setProgram(c[d], b)
}, cc._currentProjectionMatrix = -1, cc._vertexAttribPosition = !1, cc._vertexAttribColor = !1, cc._vertexAttribTexCoords = !1, cc.ENABLE_GL_STATE_CACHE && (cc.MAX_ACTIVETEXTURE = 16, cc._currentShaderProgram = -1, cc._currentBoundTexture = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], cc._blendingSource = -1, cc._blendingDest = -1, cc._GLServerState = 0, cc.TEXTURE_ATLAS_USE_VAO && (cc._uVAO = 0)), cc.glInvalidateStateCache = function() {
    if (cc.kmGLFreeAll(), cc._currentProjectionMatrix = -1, cc._vertexAttribPosition = !1, cc._vertexAttribColor = !1, cc._vertexAttribTexCoords = !1, cc.ENABLE_GL_STATE_CACHE) {
        cc._currentShaderProgram = -1;
        for (var a = 0; a < cc.MAX_ACTIVETEXTURE; a++) cc._currentBoundTexture[a] = -1;
        cc._blendingSource = -1, cc._blendingDest = -1, cc._GLServerState = 0
    }
}, cc.glUseProgram = function(a) {
    a !== cc._currentShaderProgram && (cc._currentShaderProgram = a, cc._renderContext.useProgram(a))
}, cc.ENABLE_GL_STATE_CACHE || (cc.glUseProgram = function(a) {
    cc._renderContext.useProgram(a)
}), cc.glDeleteProgram = function(a) {
    cc.ENABLE_GL_STATE_CACHE && a === cc._currentShaderProgram && (cc._currentShaderProgram = -1), gl.deleteProgram(a)
}, cc.glBlendFunc = function(a, b) {
    (a !== cc._blendingSource || b !== cc._blendingDest) && (cc._blendingSource = a, cc._blendingDest = b, cc.setBlending(a, b))
}, cc.setBlending = function(a, b) {
    var c = cc._renderContext;
    a === c.ONE && b === c.ZERO ? c.disable(c.BLEND) : (c.enable(c.BLEND), cc._renderContext.blendFunc(a, b))
}, cc.glBlendFuncForParticle = function(a, b) {
    if (a !== cc._blendingSource || b !== cc._blendingDest) {
        cc._blendingSource = a, cc._blendingDest = b;
        var c = cc._renderContext;
        a === c.ONE && b === c.ZERO ? c.disable(c.BLEND) : (c.enable(c.BLEND), c.blendFuncSeparate(c.SRC_ALPHA, b, a, b))
    }
}, cc.ENABLE_GL_STATE_CACHE || (cc.glBlendFunc = cc.setBlending), cc.glBlendResetToCache = function() {
    var a = cc._renderContext;
    a.blendEquation(a.FUNC_ADD), cc.ENABLE_GL_STATE_CACHE ? cc.setBlending(cc._blendingSource, cc._blendingDest) : cc.setBlending(a.BLEND_SRC, a.BLEND_DST)
}, cc.setProjectionMatrixDirty = function() {
    cc._currentProjectionMatrix = -1
}, cc.glEnableVertexAttribs = function(a) {
    var b = cc._renderContext,
        c = a & cc.VERTEX_ATTRIB_FLAG_POSITION;
    c !== cc._vertexAttribPosition && (c ? b.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION) : b.disableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION), cc._vertexAttribPosition = c);
    var d = a & cc.VERTEX_ATTRIB_FLAG_COLOR;
    d !== cc._vertexAttribColor && (d ? b.enableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR) : b.disableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR), cc._vertexAttribColor = d);
    var e = a & cc.VERTEX_ATTRIB_FLAG_TEX_COORDS;
    e !== cc._vertexAttribTexCoords && (e ? b.enableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS) : b.disableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS), cc._vertexAttribTexCoords = e)
}, cc.glBindTexture2D = function(a) {
    cc.glBindTexture2DN(0, a)
}, cc.glBindTexture2DN = function(a, b) {
    if (cc._currentBoundTexture[a] != b) {
        cc._currentBoundTexture[a] = b;
        var c = cc._renderContext;
        c.activeTexture(c.TEXTURE0 + a), b ? c.bindTexture(c.TEXTURE_2D, b._webTextureObj) : c.bindTexture(c.TEXTURE_2D, null)
    }
}, cc.ENABLE_GL_STATE_CACHE || (cc.glBindTexture2DN = function(a, b) {
    var c = cc._renderContext;
    c.activeTexture(c.TEXTURE0 + a), b ? c.bindTexture(c.TEXTURE_2D, b._webTextureObj) : c.bindTexture(c.TEXTURE_2D, null)
}), cc.glDeleteTexture = function(a) {
    cc.glDeleteTextureN(0, a)
}, cc.glDeleteTextureN = function(a, b) {
    cc.ENABLE_GL_STATE_CACHE && b == cc._currentBoundTexture[a] && (cc._currentBoundTexture[a] = -1), cc._renderContext.deleteTexture(b)
}, cc.glBindVAO = function(a) {
    cc.TEXTURE_ATLAS_USE_VAO && cc.ENABLE_GL_STATE_CACHE && cc._uVAO != a && (cc._uVAO = a)
}, cc.glEnable = function() {
    cc.ENABLE_GL_STATE_CACHE
};
cc.IMAGE_FORMAT_JPEG = 0, cc.IMAGE_FORMAT_PNG = 1, cc.IMAGE_FORMAT_RAWDATA = 9, cc.NextPOT = function(a) {
    return a -= 1, a |= a >> 1, a |= a >> 2, a |= a >> 4, a |= a >> 8, a |= a >> 16, a + 1
}, cc.RenderTexture = cc.Node.extend({
    sprite: null,
    clearFlags: 0,
    clearDepthVal: 0,
    autoDraw: !1,
    _texture: null,
    _pixelFormat: cc.Texture2D.PIXEL_FORMAT_RGBA8888,
    clearStencilVal: 0,
    _clearColor: null,
    _className: "RenderTexture",
    ctor: function(a, b, c, d) {
        cc.Node.prototype.ctor.call(this), this._cascadeColorEnabled = !0, this._cascadeOpacityEnabled = !0, this._clearColor = new cc.Color(0, 0, 0, 255), void 0 !== a && void 0 !== b && (c = c || cc.Texture2D.PIXEL_FORMAT_RGBA8888, d = d || 0, this.initWithWidthAndHeight(a, b, c, d)), this.setAnchorPoint(0, 0)
    },
    _createRenderCmd: function() {
        return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.RenderTexture.CanvasRenderCmd(this) : new cc.RenderTexture.WebGLRenderCmd(this)
    },
    cleanup: function() {
        cc.Node.prototype.onExit.call(this), this._renderCmd.cleanup()
    },
    getSprite: function() {
        return this.sprite
    },
    setSprite: function(a) {
        this.sprite = a
    },
    initWithWidthAndHeight: function(a, b, c, d) {
        return this._renderCmd.initWithWidthAndHeight(a, b, c, d)
    },
    begin: function() {
        cc.renderer._turnToCacheMode(this.__instanceId), this._renderCmd.begin()
    },
    beginWithClear: function(a, b, c, d, e, f) {
        var g = cc._renderContext;
        e = e || g.COLOR_BUFFER_BIT, f = f || g.COLOR_BUFFER_BIT | g.DEPTH_BUFFER_BIT, this._beginWithClear(a, b, c, d, e, f, g.COLOR_BUFFER_BIT | g.DEPTH_BUFFER_BIT | g.STENCIL_BUFFER_BIT)
    },
    _beginWithClear: function(a, b, c, d, e, f, g) {
        this.begin(), this._renderCmd._beginWithClear(a, b, c, d, e, f, g)
    },
    end: function() {
        this._renderCmd.end()
    },
    clear: function(a, b, c, d) {
        this.beginWithClear(a, b, c, d), this.end()
    },
    clearRect: function(a, b, c, d) {
        this._renderCmd.clearRect(a, b, c, d)
    },
    clearDepth: function(a) {
        this._renderCmd.clearDepth(a)
    },
    clearStencil: function(a) {
        this._renderCmd.clearStencil(a)
    },
    getClearFlags: function() {
        return this.clearFlags
    },
    setClearFlags: function(a) {
        this.clearFlags = a
    },
    getClearColor: function() {
        return this._clearColor
    },
    setClearColor: function(a) {
        var b = this._clearColor;
        b.r = a.r, b.g = a.g, b.b = a.b, b.a = a.a, this._renderCmd.updateClearColor(a)
    },
    getClearDepth: function() {
        return this.clearDepthVal
    },
    setClearDepth: function(a) {
        this.clearDepthVal = a
    },
    getClearStencil: function() {
        return this.clearStencilVal
    },
    setClearStencil: function(a) {
        this.clearStencilVal = a
    },
    isAutoDraw: function() {
        return this.autoDraw
    },
    setAutoDraw: function(a) {
        this.autoDraw = a
    },
    saveToFile: function() {
        cc.log("saveToFile isn't supported on Cocos2d-Html5")
    },
    newCCImage: function() {
        return cc.log("saveToFile isn't supported on cocos2d-html5"), null
    },
    listenToBackground: function() {},
    listenToForeground: function() {}
});
var _p = cc.RenderTexture.prototype;
_p.clearColorVal, cc.defineGetterSetter(_p, "clearColorVal", _p.getClearColor, _p.setClearColor), cc.RenderTexture.create = function(a, b, c, d) {
        return new cc.RenderTexture(a, b, c, d)
    },
    function() {
        cc.RenderTexture.CanvasRenderCmd = function(a) {
            cc.Node.CanvasRenderCmd.call(this, a), this._needDraw = !0, this._clearColorStr = "rgba(255,255,255,1)", this._cacheCanvas = cc.newElement("canvas"), this._cacheContext = new cc.CanvasContextWrapper(this._cacheCanvas.getContext("2d"))
        };
        var a = cc.RenderTexture.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
        a.constructor = cc.RenderTexture.CanvasRenderCmd, a.cleanup = function() {
            this._cacheContext = null, this._cacheCanvas = null
        }, a.clearStencil = function() {}, a.updateClearColor = function(a) {
            this._clearColorStr = "rgba(" + (0 | a.r) + "," + (0 | a.g) + "," + (0 | a.b) + "," + a.a / 255 + ")"
        }, a.initWithWidthAndHeight = function(a, b) {
            var c = this._node,
                d = this._cacheCanvas,
                e = cc.contentScaleFactor();
            d.width = 0 | a * e, d.height = 0 | b * e;
            var f = new cc.Texture2D;
            f.initWithElement(d), f.handleLoadedTexture();
            var g = c.sprite = new cc.Sprite(f);
            return g.setBlendFunc(cc.ONE, cc.ONE_MINUS_SRC_ALPHA), c.autoDraw = !1, c.addChild(g), !0
        }, a.begin = function() {}, a._beginWithClear = function(a, b, c, d) {
            a = a || 0, b = b || 0, c = c || 0, d = isNaN(d) ? 1 : d;
            var e = this._cacheContext.getContext(),
                f = this._cacheCanvas;
            e.setTransform(1, 0, 0, 1, 0, 0), this._cacheContext.setFillStyle("rgba(" + (0 | a) + "," + (0 | b) + "," + (0 | c) + "," + d / 255 + ")"), e.clearRect(0, 0, f.width, f.height), e.fillRect(0, 0, f.width, f.height)
        }, a.end = function() {
            var a = this._node,
                b = cc.contentScaleFactor();
            cc.renderer._renderingToCacheCanvas(this._cacheContext, a.__instanceId, b, b)
        }, a.clearRect = function(a, b, c, d) {
            this._cacheContext.clearRect(a, b, c, -d)
        }, a.clearDepth = function() {
            cc.log("clearDepth isn't supported on Cocos2d-Html5")
        }, a.visit = function(a) {
            var b = this._node;
            this._syncStatus(a), b.sprite.visit(this), this._dirtyFlag = 0
        }
    }();
! function() {
    cc.RenderTexture.WebGLRenderCmd = function(a) {
        cc.Node.WebGLRenderCmd.call(this, a), this._needDraw = !0, this._fBO = null, this._oldFBO = null, this._textureCopy = null, this._depthRenderBuffer = null
    };
    var a = cc.RenderTexture.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    a.constructor = cc.RenderTexture.WebGLRenderCmd, a.rendering = function(a) {
        var b = a || cc._renderContext,
            c = this._node;
        if (c.autoDraw) {
            c.begin();
            var d = c.clearFlags;
            if (d) {
                var e = [0, 0, 0, 0],
                    f = 0,
                    g = 0;
                d & b.COLOR_BUFFER_BIT && (e = b.getParameter(b.COLOR_CLEAR_VALUE), b.clearColor(c._clearColor.r / 255, c._clearColor.g / 255, c._clearColor.b / 255, c._clearColor.a / 255)), d & b.DEPTH_BUFFER_BIT && (f = b.getParameter(b.DEPTH_CLEAR_VALUE), b.clearDepth(c.clearDepthVal)), d & b.STENCIL_BUFFER_BIT && (g = b.getParameter(b.STENCIL_CLEAR_VALUE), b.clearStencil(c.clearStencilVal)), b.clear(d), d & b.COLOR_BUFFER_BIT && b.clearColor(e[0], e[1], e[2], e[3]), d & b.DEPTH_BUFFER_BIT && b.clearDepth(f), d & b.STENCIL_BUFFER_BIT && b.clearStencil(g)
            }
            c.sortAllChildren();
            for (var h = c._children, i = 0; i < h.length; i++) {
                var j = h[i];
                j != c.sprite && j._renderCmd.visit(c.sprite._renderCmd)
            }
            c.end()
        }
    }, a.clearStencil = function(a) {
        var b = cc._renderContext,
            c = b.getParameter(b.STENCIL_CLEAR_VALUE);
        b.clearStencil(a), b.clear(b.STENCIL_BUFFER_BIT), b.clearStencil(c)
    }, a.cleanup = function() {
        this._node;
        this._textureCopy = null;
        var a = cc._renderContext;
        a.deleteFramebuffer(this._fBO), this._depthRenderBuffer && a.deleteRenderbuffer(this._depthRenderBuffer)
    }, a.updateClearColor = function() {}, a.initWithWidthAndHeight = function(a, b, c, d) {
        var e = this._node;
        c == cc.Texture2D.PIXEL_FORMAT_A8 && cc.log("cc.RenderTexture._initWithWidthAndHeightForWebGL() : only RGB and RGBA formats are valid for a render texture;");
        var f = cc._renderContext,
            g = cc.contentScaleFactor();
        a = 0 | a * g, b = 0 | b * g, this._oldFBO = f.getParameter(f.FRAMEBUFFER_BINDING);
        var h, i;
        cc.configuration.supportsNPOT() ? (h = a, i = b) : (h = cc.NextPOT(a), i = cc.NextPOT(b));
        for (var j = h * i * 4, k = new Uint8Array(j), l = 0; h * i * 4 > l; l++) k[l] = 0;
        this._pixelFormat = c;
        var m = e._texture = new cc.Texture2D;
        if (!e._texture) return !1;
        m.initWithData(k, e._pixelFormat, h, i, cc.size(a, b));
        var n = f.getParameter(f.RENDERBUFFER_BINDING);
        if (cc.configuration.checkForGLExtension("GL_QCOM")) {
            if (this._textureCopy = new cc.Texture2D, !this._textureCopy) return !1;
            this._textureCopy.initWithData(k, e._pixelFormat, h, i, cc.size(a, b))
        }
        this._fBO = f.createFramebuffer(), f.bindFramebuffer(f.FRAMEBUFFER, this._fBO), f.framebufferTexture2D(f.FRAMEBUFFER, f.COLOR_ATTACHMENT0, f.TEXTURE_2D, m._webTextureObj, 0), 0 != d && (this._depthRenderBuffer = f.createRenderbuffer(), f.bindRenderbuffer(f.RENDERBUFFER, this._depthRenderBuffer), f.renderbufferStorage(f.RENDERBUFFER, d, h, i), d === f.DEPTH_STENCIL ? f.framebufferRenderbuffer(f.FRAMEBUFFER, f.DEPTH_STENCIL_ATTACHMENT, f.RENDERBUFFER, this._depthRenderBuffer) : d === f.STENCIL_INDEX || d === f.STENCIL_INDEX8 ? f.framebufferRenderbuffer(f.FRAMEBUFFER, f.STENCIL_ATTACHMENT, f.RENDERBUFFER, this._depthRenderBuffer) : d === f.DEPTH_COMPONENT16 && f.framebufferRenderbuffer(f.FRAMEBUFFER, f.DEPTH_ATTACHMENT, f.RENDERBUFFER, this._depthRenderBuffer)), f.checkFramebufferStatus(f.FRAMEBUFFER) !== f.FRAMEBUFFER_COMPLETE && cc.log("Could not attach texture to the framebuffer"), m.setAliasTexParameters();
        var o = e.sprite = new cc.Sprite(m);
        return o.scaleY = -1, o.setBlendFunc(f.ONE, f.ONE_MINUS_SRC_ALPHA), f.bindRenderbuffer(f.RENDERBUFFER, n), f.bindFramebuffer(f.FRAMEBUFFER, this._oldFBO), e.autoDraw = !1, e.addChild(o), !0
    }, a.begin = function() {
        var a = this._node;
        cc.kmGLMatrixMode(cc.KM_GL_PROJECTION), cc.kmGLPushMatrix(), cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW), cc.kmGLPushMatrix();
        var b = cc.director;
        b.setProjection(b.getProjection());
        var c = a._texture.getContentSizeInPixels(),
            d = cc.director.getWinSizeInPixels(),
            e = d.width / c.width,
            f = d.height / c.height,
            g = cc._renderContext;
        g.viewport(0, 0, c.width, c.height);
        var h = new cc.kmMat4;
        cc.kmMat4OrthographicProjection(h, -1 / e, 1 / e, -1 / f, 1 / f, -1, 1), cc.kmGLMultMatrix(h), this._oldFBO = g.getParameter(g.FRAMEBUFFER_BINDING), g.bindFramebuffer(g.FRAMEBUFFER, this._fBO), cc.configuration.checkForGLExtension("GL_QCOM") && (g.framebufferTexture2D(g.FRAMEBUFFER, g.COLOR_ATTACHMENT0, g.TEXTURE_2D, this._textureCopy._webTextureObj, 0), g.clear(g.COLOR_BUFFER_BIT | g.DEPTH_BUFFER_BIT), g.framebufferTexture2D(g.FRAMEBUFFER, g.COLOR_ATTACHMENT0, g.TEXTURE_2D, a._texture._webTextureObj, 0))
    }, a._beginWithClear = function(a, b, c, d, e, f, g) {
        a /= 255, b /= 255, c /= 255, d /= 255;
        var h = cc._renderContext,
            i = [0, 0, 0, 0],
            j = 0,
            k = 0;
        g & h.COLOR_BUFFER_BIT && (i = h.getParameter(h.COLOR_CLEAR_VALUE), h.clearColor(a, b, c, d)), g & h.DEPTH_BUFFER_BIT && (j = h.getParameter(h.DEPTH_CLEAR_VALUE), h.clearDepth(e)), g & h.STENCIL_BUFFER_BIT && (k = h.getParameter(h.STENCIL_CLEAR_VALUE), h.clearStencil(f)), h.clear(g), g & h.COLOR_BUFFER_BIT && h.clearColor(i[0], i[1], i[2], i[3]), g & h.DEPTH_BUFFER_BIT && h.clearDepth(j), g & h.STENCIL_BUFFER_BIT && h.clearStencil(k)
    }, a.end = function() {
        var a = this._node;
        cc.renderer._renderingToBuffer(a.__instanceId);
        var b = cc._renderContext,
            c = cc.director;
        b.bindFramebuffer(b.FRAMEBUFFER, this._oldFBO), c.setViewport(), cc.kmGLMatrixMode(cc.KM_GL_PROJECTION), cc.kmGLPopMatrix(), cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW), cc.kmGLPopMatrix()
    }, a.clearRect = function() {}, a.clearDepth = function(a) {
        var b = this._node;
        b.begin();
        var c = cc._renderContext,
            d = c.getParameter(c.DEPTH_CLEAR_VALUE);
        c.clearDepth(a), c.clear(c.DEPTH_BUFFER_BIT), c.clearDepth(d), b.end()
    }, a.visit = function(a) {
        var b = this._node;
        b._visible && (cc.kmGLPushMatrix(), this._syncStatus(a), cc.renderer.pushRenderCommand(this), b.sprite.visit(this), this._dirtyFlag = 0, cc.kmGLPopMatrix())
    }
}();
cc.SpriteBatchNode = cc.Node.extend({
    _blendFunc: null,
    _descendants: null,
    _className: "SpriteBatchNode",
    ctor: function(a, b) {
        cc.Node.prototype.ctor.call(this), this._descendants = [], this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
        var c;
        b = b || cc.SpriteBatchNode.DEFAULT_CAPACITY, cc.isString(a) ? (c = cc.textureCache.getTextureForKey(a), c || (c = cc.textureCache.addImage(a))) : a instanceof cc.Texture2D && (c = a), c && this.initWithTexture(c, b)
    },
    addSpriteWithoutQuad: function(a, b, c) {
        if (cc.assert(a, cc._LogInfos.SpriteBatchNode_addSpriteWithoutQuad_2), !(a instanceof cc.Sprite)) return cc.log(cc._LogInfos.SpriteBatchNode_addSpriteWithoutQuad), null;
        a.atlasIndex = b;
        var d, e = 0,
            f = this._descendants;
        if (f && f.length > 0)
            for (e = 0, d = f.length; d > e; e++) {
                var g = f[e];
                if (g && g.atlasIndex >= b) break
            }
        return f.splice(e, 0, a), cc.Node.prototype.addChild.call(this, a, b, c), this.reorderBatch(!1), this
    },
    getTextureAtlas: function() {
        return this._renderCmd.getTextureAtlas()
    },
    setTextureAtlas: function(a) {
        this._renderCmd.getTextureAtlas(a)
    },
    getDescendants: function() {
        return this._descendants
    },
    initWithFile: function(a, b) {
        var c = cc.textureCache.getTextureForKey(a);
        return c || (c = cc.textureCache.addImage(a)), this.initWithTexture(c, b)
    },
    _setNodeDirtyForCache: function() {
        this._renderCmd && this._renderCmd._setNodeDirtyForCache && this._renderCmd._setNodeDirtyForCache()
    },
    init: function(a, b) {
        var c = cc.textureCache.getTextureForKey(a);
        return c || (c = cc.textureCache.addImage(a)), this.initWithTexture(c, b)
    },
    increaseAtlasCapacity: function() {
        this._renderCmd.increaseAtlasCapacity()
    },
    removeChildAtIndex: function(a, b) {
        this.removeChild(this._children[a], b)
    },
    rebuildIndexInOrder: function(a, b) {
        var c = a.children;
        if (c && c.length > 0)
            for (var d = 0; d < c.length; d++) {
                var e = c[d];
                e && e.zIndex < 0 && (b = this.rebuildIndexInOrder(e, b))
            }
        if (!a == this && (a.atlasIndex = b, b++), c && c.length > 0)
            for (d = 0; d < c.length; d++) e = c[d], e && e.zIndex >= 0 && (b = this.rebuildIndexInOrder(e, b));
        return b
    },
    highestAtlasIndexInChild: function(a) {
        var b = a.children;
        return b && 0 != b.length ? this.highestAtlasIndexInChild(b[b.length - 1]) : a.atlasIndex
    },
    lowestAtlasIndexInChild: function(a) {
        var b = a.children;
        return b && 0 != b.length ? this.lowestAtlasIndexInChild(b[b.length - 1]) : a.atlasIndex
    },
    atlasIndexForChild: function(a, b) {
        var c = a.parent,
            d = c.children,
            e = d.indexOf(a),
            f = c == this,
            g = null;
        return e > 0 && e < cc.UINT_MAX && (g = d[e - 1]), f ? 0 == e ? 0 : this.highestAtlasIndexInChild(g) + 1 : 0 == e ? 0 > b ? c.atlasIndex : c.atlasIndex + 1 : g.zIndex < 0 && 0 > b || g.zIndex >= 0 && b >= 0 ? this.highestAtlasIndexInChild(g) + 1 : c.atlasIndex + 1
    },
    reorderBatch: function(a) {
        this._reorderChildDirty = a
    },
    setBlendFunc: function(a, b) {
        this._blendFunc = void 0 === b ? a : {
            src: a,
            dst: b
        }
    },
    getBlendFunc: function() {
        return new cc.BlendFunc(this._blendFunc.src, this._blendFunc.dst)
    },
    reorderChild: function(a, b) {
        return cc.assert(a, cc._LogInfos.SpriteBatchNode_reorderChild_2), -1 === this._children.indexOf(a) ? void cc.log(cc._LogInfos.SpriteBatchNode_reorderChild) : void(b !== a.zIndex && cc.Node.prototype.reorderChild.call(this, a, b))
    },
    removeChild: function(a, b) {
        if (null != a) {
            if (-1 === this._children.indexOf(a)) return void cc.log(cc._LogInfos.SpriteBatchNode_removeChild);
            this.removeSpriteFromAtlas(a), cc.Node.prototype.removeChild.call(this, a, b)
        }
    },
    updateQuadFromSprite: function(a, b) {
        return cc.assert(a, cc._LogInfos.CCSpriteBatchNode_updateQuadFromSprite_2), a instanceof cc.Sprite ? (this._renderCmd.checkAtlasCapacity(), a.batchNode = this, a.atlasIndex = b, a.dirty = !0, void a.updateTransform()) : void cc.log(cc._LogInfos.CCSpriteBatchNode_updateQuadFromSprite)
    },
    insertQuadFromSprite: function(a, b) {
        return cc.assert(a, cc._LogInfos.CCSpriteBatchNode_insertQuadFromSprite_2), a instanceof cc.Sprite ? (this._renderCmd.insertQuad(a, b), a.batchNode = this, a.atlasIndex = b, a.dirty = !0, a.updateTransform(), void this._renderCmd.cutting(a, b)) : void cc.log(cc._LogInfos.CCSpriteBatchNode_insertQuadFromSprite)
    },
    initWithTexture: function(a, b) {
        return this._children.length = 0, this._descendants.length = 0, b = b || cc.SpriteBatchNode.DEFAULT_CAPACITY, this._renderCmd.initWithTexture(a, b), !0
    },
    insertChild: function(a, b) {
        a.batchNode = this, a.atlasIndex = b, a.dirty = !0, this._renderCmd.insertQuad(a, b), this._descendants.splice(b, 0, a);
        var c = b + 1,
            d = this._descendants;
        if (d && d.length > 0)
            for (; c < d.length; c++) d[c].atlasIndex++;
        var e, f, g = a.children;
        if (g)
            for (c = 0, f = g.length || 0; f > c; c++)
                if (e = g[c]) {
                    var h = this.atlasIndexForChild(e, e.zIndex);
                    this.insertChild(e, h)
                }
    },
    appendChild: function(a) {
        this._reorderChildDirty = !0, a.batchNode = this, a.dirty = !0, this._descendants.push(a);
        var b = this._descendants.length - 1;
        a.atlasIndex = b, this._renderCmd.insertQuad(a, b);
        for (var c = a.children, d = 0, e = c.length || 0; e > d; d++) this.appendChild(c[d])
    },
    removeSpriteFromAtlas: function(a) {
        this._renderCmd.removeQuadAtIndex(a.atlasIndex), a.batchNode = null;
        var b = this._descendants,
            c = b.indexOf(a);
        if (-1 != c) {
            b.splice(c, 1);
            for (var d = b.length; d > c; ++c) {
                var e = b[c];
                e.atlasIndex--
            }
        }
        var f = a.children;
        if (f)
            for (var g = 0, h = f.length || 0; h > g; g++) f[g] && this.removeSpriteFromAtlas(f[g])
    },
    getTexture: function() {
        return this._renderCmd.getTexture()
    },
    setTexture: function(a) {
        this._renderCmd.setTexture(a)
    },
    addChild: function(a, b, c) {
        cc.assert(null != a, cc._LogInfos.CCSpriteBatchNode_addChild_3), this._renderCmd.isValidChild(a) && (b = null == b ? a.zIndex : b, c = null == c ? a.tag : c, cc.Node.prototype.addChild.call(this, a, b, c), this.appendChild(a))
    },
    removeAllChildren: function(a) {
        var b = this._descendants;
        if (b && b.length > 0)
            for (var c = 0, d = b.length; d > c; c++) b[c] && (b[c].batchNode = null);
        cc.Node.prototype.removeAllChildren.call(this, a), this._descendants.length = 0, this._renderCmd.removeAllQuads()
    },
    sortAllChildren: function() {
        if (this._reorderChildDirty) {
            var a, b, c = this._children,
                d = 0,
                e = c.length;
            for (a = 1; e > a; a++) {
                var f = c[a];
                for (d = a - 1, b = c[d]; d >= 0 && (f._localZOrder < b._localZOrder || f._localZOrder == b._localZOrder && f.arrivalOrder < b.arrivalOrder);) c[d + 1] = b, d -= 1, b = c[d];
                c[d + 1] = f
            }
            c.length > 0 && (this._arrayMakeObjectsPerformSelector(c, cc.Node._stateCallbackType.sortAllChildren), this._renderCmd.updateChildrenAtlasIndex(c)), this._reorderChildDirty = !1
        }
    },
    _createRenderCmd: function() {
        return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.SpriteBatchNode.CanvasRenderCmd(this) : new cc.SpriteBatchNode.WebGLRenderCmd(this)
    }
});
var _p = cc.SpriteBatchNode.prototype;
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture), cc.defineGetterSetter(_p, "textureAtlas", _p.getTextureAtlas, _p.setTextureAtlas), _p.descendants, cc.defineGetterSetter(_p, "descendants", _p.getDescendants), cc.SpriteBatchNode.DEFAULT_CAPACITY = 29, cc.SpriteBatchNode.create = function(a, b) {
        return new cc.SpriteBatchNode(a, b)
    }, cc.SpriteBatchNode.createWithTexture = cc.SpriteBatchNode.create,
    function() {
        cc.SpriteBatchNode.CanvasRenderCmd = function(a) {
            cc.Node.CanvasRenderCmd.call(this, a), this._texture = null, this._originalTexture = null
        };
        var a = cc.SpriteBatchNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
        a.constructor = cc.SpriteBatchNode.CanvasRenderCmd, a.checkAtlasCapacity = function() {}, a.isValidChild = function(a) {
            return a instanceof cc.Sprite ? !0 : (cc.log(cc._LogInfos.Sprite_addChild_4), !1)
        }, a.initWithTexture = function(a) {
            this._originalTexture = a, this._texture = a
        }, a.insertQuad = function() {}, a.increaseAtlasCapacity = function() {}, a.removeQuadAtIndex = function() {}, a.removeAllQuads = function() {}, a.getTexture = function() {
            return this._texture
        }, a.setTexture = function(a) {
            this._texture = a;
            for (var b = this._node._children, c = 0; c < b.length; c++) b[c].setTexture(a)
        }, a.updateChildrenAtlasIndex = function(a) {
            this._node._descendants.length = 0;
            for (var b = 0, c = a.length; c > b; b++) this._updateAtlasIndex(a[b])
        }, a._updateAtlasIndex = function(a) {
            var b, c = this._node._descendants,
                d = a.children,
                e = d.length;
            for (b = 0; e > b && d[b]._localZOrder < 0; b++) c.push(d[b]);
            for (c.push(a); e > b; b++) c.push(d[b])
        }, a.getTextureAtlas = function() {}, a.setTextureAtlas = function() {}, a.cutting = function(a, b) {
            var c = this._node;
            c._children.splice(b, 0, a)
        }
    }();
! function() {
    cc.SpriteBatchNode.WebGLRenderCmd = function(a) {
        cc.Node.WebGLRenderCmd.call(this, a), this._needDraw = !0, this._textureAtlas = null
    };
    var a = cc.SpriteBatchNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    a.constructor = cc.SpriteBatchNode.WebGLRenderCmd, a.isValidChild = function(a) {
        return a instanceof cc.Sprite ? a.texture != this.getTexture() ? (cc.log(cc._LogInfos.Sprite_addChild_5), !1) : !0 : (cc.log(cc._LogInfos.Sprite_addChild_4), !1)
    }, a.rendering = function() {
        var a = this._node;
        0 !== this._textureAtlas.totalQuads && (this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix), a._arrayMakeObjectsPerformSelector(a._children, cc.Node._stateCallbackType.updateTransform), cc.glBlendFunc(a._blendFunc.src, a._blendFunc.dst), this._textureAtlas.drawQuads())
    }, a.visit = function(a) {
        var b = this._node;
        if (b._visible) {
            b._parent && b._parent._renderCmd && (this._curLevel = b._parent._renderCmd._curLevel + 1);
            var c = cc.current_stack;
            c.stack.push(c.top), this._dirtyFlag & cc.Node._dirtyFlags.transformDirty || this.transform(a), this.updateStatus(a), c.top = this._stackMatrix, b.sortAllChildren(), cc.renderer.pushRenderCommand(this), this._dirtyFlag = 0, c.top = c.stack.pop()
        }
    }, a.checkAtlasCapacity = function(a) {
        for (var b = this._textureAtlas; a >= b.capacity || b.capacity == b.totalQuads;) this.increaseAtlasCapacity()
    }, a.increaseAtlasCapacity = function() {
        var a = this._textureAtlas.capacity,
            b = Math.floor(4 * (a + 1) / 3);
        cc.log(cc._LogInfos.SpriteBatchNode_increaseAtlasCapacity, a, b), this._textureAtlas.resizeCapacity(b) || cc.log(cc._LogInfos.SpriteBatchNode_increaseAtlasCapacity_2)
    }, a.initWithTexture = function(a, b) {
        this._textureAtlas = new cc.TextureAtlas, this._textureAtlas.initWithTexture(a, b), this._updateBlendFunc(), this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)
    }, a.insertQuad = function(a, b) {
        var c = this._textureAtlas;
        c.totalQuads >= c.capacity && this.increaseAtlasCapacity(), c.insertQuad(a.quad, b)
    }, a.removeQuadAtIndex = function(a) {
        this._textureAtlas.removeQuadAtIndex(a)
    }, a.getTexture = function() {
        return this._textureAtlas.texture
    }, a.setTexture = function(a) {
        this._textureAtlas.setTexture(a), this._updateBlendFunc()
    }, a.removeAllQuads = function() {
        this._textureAtlas.removeAllQuads()
    }, a._swap = function(a, b) {
        var c = this._node._descendants,
            d = this._textureAtlas,
            e = d.quads,
            f = c[a],
            g = cc.V3F_C4B_T2F_QuadCopy(e[a]);
        c[b].atlasIndex = a, c[a] = c[b], d.updateQuad(e[b], a), c[b] = f, d.updateQuad(g, b)
    }, a._updateAtlasIndex = function(a, b) {
        var c = 0,
            d = a.children;
        d && (c = d.length);
        var e = 0;
        if (0 === c) e = a.atlasIndex, a.atlasIndex = b, a.arrivalOrder = 0, e != b && this._swap(e, b), b++;
        else {
            var f = !0;
            d[0].zIndex >= 0 && (e = a.atlasIndex, a.atlasIndex = b, a.arrivalOrder = 0, e != b && this._swap(e, b), b++, f = !1);
            for (var g = 0; g < d.length; g++) {
                var h = d[g];
                f && h.zIndex >= 0 && (e = a.atlasIndex, a.atlasIndex = b, a.arrivalOrder = 0, e != b && this._swap(e, b), b++, f = !1), b = this._updateAtlasIndex(h, b)
            }
            f && (e = a.atlasIndex, a.atlasIndex = b, a.arrivalOrder = 0, e != b && this._swap(e, b), b++)
        }
        return b
    }, a.updateChildrenAtlasIndex = function(a) {
        for (var b = 0, c = 0; c < a.length; c++) b = this._updateAtlasIndex(a[c], b)
    }, a._updateBlendFunc = function() {
        if (!this._textureAtlas.texture.hasPremultipliedAlpha()) {
            var a = this._node._blendFunc;
            a.src = cc.SRC_ALPHA, a.dst = cc.ONE_MINUS_SRC_ALPHA
        }
    }, a.getTextureAtlas = function() {
        return this._textureAtlas
    }, a.setTextureAtlas = function(a) {
        a != this._textureAtlas && (this._textureAtlas = a)
    }, a.cutting = function() {}
}();
cc.LabelAtlas = cc.AtlasNode.extend({
        _string: null,
        _mapStartChar: null,
        _textureLoaded: !1,
        _className: "LabelAtlas",
        ctor: function(a, b, c, d, e) {
            cc.AtlasNode.prototype.ctor.call(this), this._renderCmd.setCascade(), b && cc.LabelAtlas.prototype.initWithString.call(this, a, b, c, d, e)
        },
        _createRenderCmd: function() {
            return cc._renderType === cc._RENDER_TYPE_WEBGL ? new cc.LabelAtlas.WebGLRenderCmd(this) : new cc.LabelAtlas.CanvasRenderCmd(this)
        },
        textureLoaded: function() {
            return this._textureLoaded
        },
        addLoadedEventListener: function(a, b) {
            this.addEventListener("load", a, b)
        },
        initWithString: function(a, b, c, d, e) {
            var f, g, h, i, j = a + "";
            if (void 0 === c) {
                var k = cc.loader.getRes(b);
                if (1 !== parseInt(k.version, 10)) return cc.log("cc.LabelAtlas.initWithString(): Unsupported version. Upgrade cocos2d version"), !1;
                f = cc.path.changeBasename(b, k.textureFilename);
                var l = cc.contentScaleFactor();
                g = parseInt(k.itemWidth, 10) / l, h = parseInt(k.itemHeight, 10) / l, i = String.fromCharCode(parseInt(k.firstChar, 10))
            } else f = b, g = c || 0, h = d || 0, i = e || " ";
            var m = null;
            m = f instanceof cc.Texture2D ? f : cc.textureCache.addImage(f);
            var n = m.isLoaded();
            return this._textureLoaded = n, n || m.addEventListener("load", function() {
                this.initWithTexture(m, g, h, j.length), this.string = j, this.dispatchEvent("load")
            }, this), this.initWithTexture(m, g, h, j.length) ? (this._mapStartChar = i, this.string = j, !0) : !1
        },
        setColor: function(a) {
            cc.AtlasNode.prototype.setColor.call(this, a), this._renderCmd.updateAtlasValues()
        },
        getString: function() {
            return this._string
        },
        addChild: function(a, b, c) {
            this._renderCmd._addChild(a), cc.Node.prototype.addChild.call(this, a, b, c)
        },
        updateAtlasValues: function() {
            this._renderCmd.updateAtlasValues()
        },
        setString: function(a) {
            a = String(a);
            var b = a.length;
            this._string = a, this.setContentSize(b * this._itemWidth, this._itemHeight), this._renderCmd.setString(a), this._renderCmd.updateAtlasValues(), this.quadsToDraw = b
        }
    }),
    function() {
        var a = cc.LabelAtlas.prototype;
        cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity), cc.defineGetterSetter(a, "color", a.getColor, a.setColor), a.string, cc.defineGetterSetter(a, "string", a.getString, a.setString)
    }(), cc.LabelAtlas.create = function(a, b, c, d, e) {
        return new cc.LabelAtlas(a, b, c, d, e)
    },
    function() {
        cc.LabelAtlas.CanvasRenderCmd = function(a) {
            cc.AtlasNode.CanvasRenderCmd.call(this, a), this._needDraw = !1
        };
        var a = cc.LabelAtlas.CanvasRenderCmd.prototype = Object.create(cc.AtlasNode.CanvasRenderCmd.prototype);
        a.constructor = cc.LabelAtlas.CanvasRenderCmd, a.setCascade = function() {
            var a = this._node;
            a._cascadeOpacityEnabled = !0, a._cascadeColorEnabled = !1
        }, a.updateAtlasValues = function() {
            for (var a = this._node, b = a._string || "", c = b.length, d = this._texture, e = a._itemWidth, f = a._itemHeight, g = 0; c > g; g++) {
                var h = b.charCodeAt(g) - a._mapStartChar.charCodeAt(0),
                    i = parseInt(h % a._itemsPerRow, 10),
                    j = parseInt(h / a._itemsPerRow, 10),
                    k = cc.rect(i * e, j * f, e, f),
                    l = b.charCodeAt(g),
                    m = a.getChildByTag(g);
                m ? 32 == l ? (m.init(), m.setTextureRect(cc.rect(0, 0, 10, 10), !1, cc.size(0, 0))) : (m.initWithTexture(d, k), m.visible = !0) : (m = new cc.Sprite, 32 == l ? (m.init(), m.setTextureRect(cc.rect(0, 0, 10, 10), !1, cc.size(0, 0))) : m.initWithTexture(d, k), cc.Node.prototype.addChild.call(a, m, 0, g)), m.setPosition(g * e + e / 2, f / 2)
            }
        }, a.setString = function() {
            var a = this._node;
            if (a._children)
                for (var b = a._children, c = b.length, d = 0; c > d; d++) {
                    var e = b[d];
                    e && !e._lateChild && (e.visible = !1)
                }
        }, a._addChild = function() {
            child._lateChild = !0
        }
    }(), cc.LABEL_AUTOMATIC_WIDTH = -1, cc.LabelBMFont = cc.SpriteBatchNode.extend({
        _opacityModifyRGB: !1,
        _string: "",
        _config: null,
        _fntFile: "",
        _initialString: "",
        _alignment: cc.TEXT_ALIGNMENT_CENTER,
        _width: -1,
        _lineBreakWithoutSpaces: !1,
        _imageOffset: null,
        _reusedChar: null,
        _textureLoaded: !1,
        _className: "LabelBMFont",
        _createRenderCmd: function() {
            return cc._renderType === cc._RENDER_TYPE_WEBGL ? new cc.LabelBMFont.WebGLRenderCmd(this) : new cc.LabelBMFont.CanvasRenderCmd(this)
        },
        _setString: function(a, b) {
            b ? this._initialString = a : this._string = a;
            var c = this._children;
            if (c)
                for (var d = 0; d < c.length; d++) {
                    var e = c[d];
                    e && e.setVisible(!1)
                }
            this._textureLoaded && (this.createFontChars(), b && this.updateLabel())
        },
        ctor: function(a, b, c, d, e) {
            cc.SpriteBatchNode.prototype.ctor.call(this), this._imageOffset = cc.p(0, 0), this._reusedChar = [], this._cascadeColorEnabled = !0, this._cascadeOpacityEnabled = !0, this.initWithString(a, b, c, d, e)
        },
        textureLoaded: function() {
            return this._textureLoaded
        },
        addLoadedEventListener: function(a, b) {
            this.addEventListener("load", a, b)
        },
        isOpacityModifyRGB: function() {
            return this._opacityModifyRGB
        },
        setOpacityModifyRGB: function(a) {
            this._opacityModifyRGB = a;
            var b = this._children;
            if (b)
                for (var c = 0; c < b.length; c++) {
                    var d = b[c];
                    d && (d.opacityModifyRGB = this._opacityModifyRGB)
                }
        },
        _changeTextureColor: function() {
            this._renderCmd._changeTextureColor()
        },
        init: function() {
            return this.initWithString(null, null, null, null, null)
        },
        initWithString: function(a, b, c, d, e) {
            {
                var f = this,
                    g = a || "";
                this._renderCmd
            }
            f._config && cc.log("cc.LabelBMFont.initWithString(): re-init is no longer supported");
            var h;
            if (b) {
                var i = cc.loader.getRes(b);
                if (!i) return cc.log("cc.LabelBMFont.initWithString(): Impossible to create font. Please check file"), !1;
                f._config = i, f._fntFile = b, h = cc.textureCache.addImage(i.atlasName);
                var j = h.isLoaded();
                f._textureLoaded = j, j || h.addEventListener("load", function(a) {
                    var b = this;
                    b._textureLoaded = !0, b.initWithTexture(a, b._initialString.length), b.setString(b._initialString, !0), b.dispatchEvent("load")
                }, f)
            } else {
                h = new cc.Texture2D;
                var k = new Image;
                h.initWithElement(k), f._textureLoaded = !1
            }
            return f.initWithTexture(h, g.length) ? (f._alignment = d || cc.TEXT_ALIGNMENT_LEFT, f._imageOffset = e || cc.p(0, 0), f._width = null == c ? -1 : c, f._realOpacity = 255, f._realColor = cc.color(255, 255, 255, 255), f._contentSize.width = 0, f._contentSize.height = 0, f.setAnchorPoint(.5, .5), this._renderCmd._initBatchTexture(), f.setString(g, !0), !0) : !1
        },
        createFontChars: function() {
            var a = this,
                b = this._renderCmd,
                c = b._texture || a.textureAtlas.texture,
                d = 0,
                e = cc.size(0, 0),
                f = 0,
                g = 1,
                h = a._string,
                i = h ? h.length : 0;
            if (0 !== i) {
                var j, k = a._config,
                    l = k.kerningDict,
                    m = k.commonHeight,
                    n = k.fontDefDictionary;
                for (j = 0; i - 1 > j; j++) 10 == h.charCodeAt(j) && g++;
                var o = m * g,
                    p = -(m - m * g),
                    q = -1;
                for (j = 0; i > j; j++) {
                    var r = h.charCodeAt(j);
                    if (0 != r)
                        if (10 !== r) {
                            var s = l[q << 16 | 65535 & r] || 0,
                                t = n[r];
                            if (t) {
                                var u = cc.rect(t.rect.x, t.rect.y, t.rect.width, t.rect.height);
                                u = cc.rectPixelsToPoints(u), u.x += a._imageOffset.x, u.y += a._imageOffset.y;
                                var v = a.getChildByTag(j);
                                v ? this._renderCmd._updateCharTexture(v, u, r) : (v = new cc.Sprite, v.initWithTexture(c, u, !1), v._newTextureWhenChangeColor = !0, this.addChild(v, 0, j)), v.opacityModifyRGB = this._opacityModifyRGB, this._renderCmd._updateCharColorAndOpacity(v);
                                var w = k.commonHeight - t.yOffset,
                                    x = cc.p(d + t.xOffset + .5 * t.rect.width + s, p + w - .5 * u.height * cc.contentScaleFactor());
                                v.setPosition(cc.pointPixelsToPoints(x)), d += t.xAdvance + s, q = r, d > f && (f = d)
                            } else cc.log("cocos2d: LabelBMFont: character not found " + h[j])
                        } else d = 0, p -= k.commonHeight
                }
                e.width = t && t.xAdvance < t.rect.width ? f - t.xAdvance + t.rect.width : f, e.height = o, a.setContentSize(cc.sizePixelsToPoints(e))
            }
        },
        updateString: function(a) {
            var b = this,
                c = b._children;
            if (c)
                for (var d = 0, e = c.length; e > d; d++) {
                    var f = c[d];
                    f && (f.visible = !1)
                }
            b._config && b.createFontChars(), a || b.updateLabel()
        },
        getString: function() {
            return this._initialString
        },
        setString: function(a, b) {
            a = String(a), null == b && (b = !0), null != a && cc.isString(a) || (a += ""), this._initialString = a, this._setString(a, b)
        },
        _setStringForSetter: function(a) {
            this.setString(a, !1)
        },
        setCString: function(a) {
            this.setString(a, !0)
        },
        updateLabel: function() {
            var a = this;
            if (a.string = a._initialString, a._width > 0) {
                for (var b, c = a._string.length, d = [], e = [], f = 1, g = 0, h = !1, i = !1, j = -1, k = -1, l = 0, m = 0, n = a._children.length; n > m; m++) {
                    for (var o = 0; !(b = a.getChildByTag(m + l + o));) o++;
                    if (l += o, g >= c) break;
                    var p = a._string[g];
                    if (i || (k = a._getLetterPosXLeft(b), i = !0), h || (j = k, h = !0), 10 != p.charCodeAt(0))
                        if (this._isspace_unicode(p)) e.push(p), d = d.concat(e), e.length = 0, i = !1, k = -1, g++;
                        else if (a._getLetterPosXRight(b) - j > a._width)
                        if (a._lineBreakWithoutSpaces) {
                            if (this._utf8_trim_ws(e), e.push("\n"), d = d.concat(e), e.length = 0, i = !1, h = !1, k = -1, j = -1, f++, g >= c) break;
                            k || (k = a._getLetterPosXLeft(b), i = !0), j || (j = k, h = !0), m--
                        } else {
                            e.push(p);
                            var q = d.lastIndexOf(" "); - 1 != q ? this._utf8_trim_ws(d) : d = [], d.length > 0 && d.push("\n"), f++, h = !1, j = -1, g++
                        } else e.push(p), g++;
                    else {
                        if (e.push("\n"), d = d.concat(e), e.length = 0, i = !1, h = !1, k = -1, j = -1, m--, l -= o, f++, g >= c) break;
                        p = a._string[g], k || (k = a._getLetterPosXLeft(b), i = !0), j || (j = k, h = !0), g++
                    }
                }
                d = d.concat(e);
                var r = d.length,
                    s = "";
                for (g = 0; r > g; ++g) s += d[g];
                s += String.fromCharCode(0), a._setString(s, !1)
            }
            if (a._alignment != cc.TEXT_ALIGNMENT_LEFT) {
                g = 0;
                for (var t = 0, u = a._string.length, v = [], w = 0; u > w; w++)
                    if (10 != a._string[w].charCodeAt(0) && 0 != a._string[w].charCodeAt(0)) v.push(a._string[g]);
                    else {
                        var x = 0,
                            y = v.length;
                        if (0 == y) {
                            t++;
                            continue
                        }
                        var z = g + y - 1 + t;
                        if (0 > z) continue;
                        var A = a.getChildByTag(z);
                        if (null == A) continue;
                        x = A.getPositionX() + A._getWidth() / 2;
                        var B = 0;
                        switch (a._alignment) {
                            case cc.TEXT_ALIGNMENT_CENTER:
                                B = a.width / 2 - x / 2;
                                break;
                            case cc.TEXT_ALIGNMENT_RIGHT:
                                B = a.width - x
                        }
                        if (0 != B)
                            for (m = 0; y > m; m++) z = g + m + t, 0 > z || (b = a.getChildByTag(z), b && (b.x += B));
                        g += y, t++, v.length = 0
                    }
            }
        },
        setAlignment: function(a) {
            this._alignment = a, this.updateLabel()
        },
        _getAlignment: function() {
            return this._alignment
        },
        setBoundingWidth: function(a) {
            this._width = a, this.updateLabel()
        },
        _getBoundingWidth: function() {
            return this._width
        },
        setLineBreakWithoutSpace: function(a) {
            this._lineBreakWithoutSpaces = a, this.updateLabel()
        },
        setScale: function(a, b) {
            cc.Node.prototype.setScale.call(this, a, b), this.updateLabel()
        },
        setScaleX: function(a) {
            cc.Node.prototype.setScaleX.call(this, a), this.updateLabel()
        },
        setScaleY: function(a) {
            cc.Node.prototype.setScaleY.call(this, a), this.updateLabel()
        },
        setFntFile: function(a) {
            var b = this;
            if (null != a && a != b._fntFile) {
                var c = cc.loader.getRes(a);
                if (!c) return void cc.log("cc.LabelBMFont.setFntFile() : Impossible to create font. Please check file");
                b._fntFile = a, b._config = c;
                var d = cc.textureCache.addImage(c.atlasName),
                    e = d.isLoaded();
                b._textureLoaded = e, b.texture = d, this._renderCmd._updateFntFileTexture(), e ? b.createFontChars() : d.addEventListener("load", function(a) {
                    var b = this;
                    b._textureLoaded = !0, b.texture = a, b.createFontChars(), b._changeTextureColor(), b.updateLabel(), b.dispatchEvent("load")
                }, b)
            }
        },
        getFntFile: function() {
            return this._fntFile
        },
        setTexture: function(a) {
            this._renderCmd.setTexture(a)
        },
        setAnchorPoint: function(a, b) {
            cc.Node.prototype.setAnchorPoint.call(this, a, b), this.updateLabel()
        },
        _setAnchorX: function(a) {
            cc.Node.prototype._setAnchorX.call(this, a), this.updateLabel()
        },
        _setAnchorY: function(a) {
            cc.Node.prototype._setAnchorY.call(this, a), this.updateLabel()
        },
        _atlasNameFromFntFile: function() {},
        _kerningAmountForFirst: function(a, b) {
            var c = 0,
                d = a << 16 | 65535 & b;
            if (this._configuration.kerningDictionary) {
                var e = this._configuration.kerningDictionary[d.toString()];
                e && (c = e.amount)
            }
            return c
        },
        _getLetterPosXLeft: function(a) {
            return a.getPositionX() * this._scaleX - a._getWidth() * this._scaleX * a._getAnchorX()
        },
        _getLetterPosXRight: function(a) {
            return a.getPositionX() * this._scaleX + a._getWidth() * this._scaleX * a._getAnchorX()
        },
        _isspace_unicode: function(a) {
            return a = a.charCodeAt(0), a >= 9 && 13 >= a || 32 == a || 133 == a || 160 == a || 5760 == a || a >= 8192 && 8202 >= a || 8232 == a || 8233 == a || 8239 == a || 8287 == a || 12288 == a
        },
        _utf8_trim_ws: function(a) {
            var b = a.length;
            if (!(0 >= b)) {
                var c = b - 1;
                if (this._isspace_unicode(a[c])) {
                    for (var d = c - 1; d >= 0 && this._isspace_unicode(a[d]); --d) c = d;
                    this._utf8_trim_from(a, c)
                }
            }
        },
        _utf8_trim_from: function(a, b) {
            var c = a.length;
            b >= c || 0 > b || a.splice(b, c)
        }
    }),
    function() {
        var a = cc.LabelBMFont.prototype;
        cc.EventHelper.prototype.apply(a), a.string, cc.defineGetterSetter(a, "string", a.getString, a._setStringForSetter), a.boundingWidth, cc.defineGetterSetter(a, "boundingWidth", a._getBoundingWidth, a.setBoundingWidth), a.textAlign, cc.defineGetterSetter(a, "textAlign", a._getAlignment, a.setAlignment)
    }(), cc.LabelBMFont.create = function(a, b, c, d, e) {
        return new cc.LabelBMFont(a, b, c, d, e)
    }, cc._fntLoader = {
        INFO_EXP: /info [^\n]*(\n|$)/gi,
        COMMON_EXP: /common [^\n]*(\n|$)/gi,
        PAGE_EXP: /page [^\n]*(\n|$)/gi,
        CHAR_EXP: /char [^\n]*(\n|$)/gi,
        KERNING_EXP: /kerning [^\n]*(\n|$)/gi,
        ITEM_EXP: /\w+=[^ \r\n]+/gi,
        INT_EXP: /^[\-]?\d+$/,
        _parseStrToObj: function(a) {
            var b = a.match(this.ITEM_EXP),
                c = {};
            if (b)
                for (var d = 0, e = b.length; e > d; d++) {
                    var f = b[d],
                        g = f.indexOf("="),
                        h = f.substring(0, g),
                        i = f.substring(g + 1);
                    i.match(this.INT_EXP) ? i = parseInt(i) : '"' == i[0] && (i = i.substring(1, i.length - 1)), c[h] = i
                }
            return c
        },
        parseFnt: function(a, b) {
            var c = this,
                d = {},
                e = c._parseStrToObj(a.match(c.INFO_EXP)[0]),
                f = e.padding.split(","),
                g = ({
                    left: parseInt(f[0]),
                    top: parseInt(f[1]),
                    right: parseInt(f[2]),
                    bottom: parseInt(f[3])
                }, c._parseStrToObj(a.match(c.COMMON_EXP)[0]));
            if (d.commonHeight = g.lineHeight, cc._renderType === cc._RENDER_TYPE_WEBGL) {
                var h = cc.configuration.getMaxTextureSize();
                (g.scaleW > h.width || g.scaleH > h.height) && cc.log("cc.LabelBMFont._parseCommonArguments(): page can't be larger than supported")
            }
            1 !== g.pages && cc.log("cc.LabelBMFont._parseCommonArguments(): only supports 1 page");
            var i = c._parseStrToObj(a.match(c.PAGE_EXP)[0]);
            0 !== i.id && cc.log("cc.LabelBMFont._parseImageFileName() : file could not be found"), d.atlasName = cc.path.changeBasename(b, i.file);
            for (var j = a.match(c.CHAR_EXP), k = d.fontDefDictionary = {}, l = 0, m = j.length; m > l; l++) {
                var n = c._parseStrToObj(j[l]),
                    o = n.id;
                k[o] = {
                    rect: {
                        x: n.x,
                        y: n.y,
                        width: n.width,
                        height: n.height
                    },
                    xOffset: n.xoffset,
                    yOffset: n.yoffset,
                    xAdvance: n.xadvance
                }
            }
            var p = d.kerningDict = {},
                q = a.match(c.KERNING_EXP);
            if (q)
                for (var l = 0, m = q.length; m > l; l++) {
                    var r = c._parseStrToObj(q[l]);
                    p[r.first << 16 | 65535 & r.second] = r.amount
                }
            return d
        },
        load: function(a, b, c, d) {
            var e = this;
            cc.loader.loadTxt(a, function(a, c) {
                return a ? d(a) : void d(null, e.parseFnt(c, b))
            })
        }
    }, cc.loader.register(["fnt"], cc._fntLoader),
    function() {
        cc.LabelBMFont.CanvasRenderCmd = function(a) {
            cc.SpriteBatchNode.CanvasRenderCmd.call(this, a), this._needDraw = !0
        };
        var a = cc.LabelBMFont.CanvasRenderCmd.prototype = Object.create(cc.SpriteBatchNode.CanvasRenderCmd.prototype);
        a.constructor = cc.LabelBMFont.CanvasRenderCmd, a.rendering = function() {}, a._updateCharTexture = function(a, b, c) {
            32 === c ? a.setTextureRect(b, !1, cc.size(0, 0)) : (a.setTextureRect(b, !1), a.visible = !0)
        }, a._updateCharColorAndOpacity = function(a) {
            a._displayedColor = this._displayedColor, a._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty), a._displayedOpacity = this._displayedOpacity, a._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
        }, a._updateFntFileTexture = function() {
            var a = this._node;
            a._originalTexture = a.texture
        }, a.setTexture = function(a) {
            for (var b = this._node, c = b._children, d = b._displayedColor, e = 0; e < c.length; e++) {
                var f = c[e],
                    g = f._renderCmd,
                    h = g._displayedColor;
                (this._texture == g._texture || h.r === d.r && h.g === d.g && h.b === d.b) && (f.texture = a)
            }
            this._texture = a
        }, a._changeTextureColor = cc.sys._supportCanvasNewBlendModes ? function() {
            var a = this._node,
                b = a.getTexture();
            if (b && b.getContentSize().width > 0) {
                var c = this._originalTexture.getHtmlElementObj();
                if (!c) return;
                var d = b.getHtmlElementObj(),
                    e = cc.rect(0, 0, c.width, c.height);
                d instanceof HTMLCanvasElement && !a._rectRotated ? (cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply(c, this._displayedColor, e, d), a.setTexture(b)) : (d = cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply(c, this._displayedColor, e), b = new cc.Texture2D, b.initWithElement(d), b.handleLoadedTexture(), a.setTexture(b))
            }
        } : function() {
            var a, b = this._node,
                c = b.getTexture();
            if (c && c.getContentSize().width > 0) {
                if (a = c.getHtmlElementObj(), !a) return;
                var d = cc.textureCache.getTextureColors(this._originalTexture.getHtmlElementObj());
                d && (a instanceof HTMLCanvasElement && !this._rectRotated ? (cc.Sprite.CanvasRenderCmd._generateTintImage(a, d, this._displayedColor, null, a), this.setTexture(c)) : (a = cc.Sprite.CanvasRenderCmd._generateTintImage(a, d, this._displayedColor), c = new cc.Texture2D, c.initWithElement(a), c.handleLoadedTexture(), b.setTexture(c)))
            }
        }, a._updateChildrenDisplayedOpacity = function(a) {
            cc.Node.prototype.updateDisplayedOpacity.call(a, this._displayedOpacity)
        }, a._updateChildrenDisplayedColor = function(a) {
            cc.Node.prototype.updateDisplayedColor.call(a, this._displayedColor)
        }, a._initBatchTexture = function() {}
    }();
! function() {
    cc.LabelAtlas.WebGLRenderCmd = function(a) {
        cc.AtlasNode.WebGLRenderCmd.call(this, a), this._needDraw = !0
    };
    var a = cc.LabelAtlas.WebGLRenderCmd.prototype = Object.create(cc.AtlasNode.WebGLRenderCmd.prototype);
    a.constructor = cc.LabelAtlas.WebGLRenderCmd, a.setCascade = function() {
        var a = this._node;
        a._cascadeOpacityEnabled = !0, a._cascadeColorEnabled = !0
    }, a.rendering = function(a) {
        if (cc.AtlasNode.WebGLRenderCmd.prototype.rendering.call(this, a), cc.LABELATLAS_DEBUG_DRAW) {
            var b = this._node.getContentSize(),
                c = [cc.p(0, 0), cc.p(b.width, 0), cc.p(b.width, b.height), cc.p(0, b.height)];
            cc._drawingUtil.drawPoly(c, 4, !0)
        }
    }, a.updateAtlasValues = function() {
        var a = this._node,
            b = a._string,
            c = b.length,
            d = this._textureAtlas,
            e = d.texture,
            f = e.pixelsWidth,
            g = e.pixelsHeight,
            h = a._itemWidth,
            i = a._itemHeight;
        a._ignoreContentScaleFactor || (h = a._itemWidth * cc.contentScaleFactor(), i = a._itemHeight * cc.contentScaleFactor()), c > d.getCapacity() && cc.log("cc.LabelAtlas._updateAtlasValues(): Invalid String length");
        for (var j = d.quads, k = this._displayedColor, l = {
            r: k.r,
            g: k.g,
            b: k.b,
            a: a._displayedOpacity
        }, m = a._itemWidth, n = 0; c > n; n++) {
            var o, p, q, r, s = b.charCodeAt(n) - a._mapStartChar.charCodeAt(0),
                t = s % a._itemsPerRow,
                u = 0 | s / a._itemsPerRow;
            cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (o = (2 * t * h + 1) / (2 * f), p = o + (2 * h - 2) / (2 * f), q = (2 * u * i + 1) / (2 * g), r = q + (2 * i - 2) / (2 * g)) : (o = t * h / f, p = o + h / f, q = u * i / g, r = q + i / g);
            var v = j[n],
                w = v.tl,
                x = v.tr,
                y = v.bl,
                z = v.br;
            w.texCoords.u = o, w.texCoords.v = q, x.texCoords.u = p, x.texCoords.v = q, y.texCoords.u = o, y.texCoords.v = r, z.texCoords.u = p, z.texCoords.v = r, y.vertices.x = n * m, y.vertices.y = 0, y.vertices.z = 0, z.vertices.x = n * m + m, z.vertices.y = 0, z.vertices.z = 0, w.vertices.x = n * m, w.vertices.y = a._itemHeight, w.vertices.z = 0, x.vertices.x = n * m + m, x.vertices.y = a._itemHeight, x.vertices.z = 0, w.colors = l, x.colors = l, y.colors = l, z.colors = l
        }
        if (c > 0) {
            d.dirty = !0;
            var A = d.totalQuads;
            c > A && d.increaseTotalQuadsWith(c - A)
        }
    }, a.setString = function(a) {
        var b = a.length;
        b > this._textureAtlas.totalQuads && this._textureAtlas.resizeCapacity(b)
    }, a._addChild = function() {}
}(),
function() {
    cc.LabelBMFont.WebGLRenderCmd = function(a) {
        cc.SpriteBatchNode.WebGLRenderCmd.call(this, a), this._needDraw = !0
    };
    var a = cc.LabelBMFont.WebGLRenderCmd.prototype = Object.create(cc.SpriteBatchNode.WebGLRenderCmd.prototype);
    a.constructor = cc.LabelBMFont.WebGLRenderCmd, a._updateCharTexture = function(a, b) {
        a.setTextureRect(b, !1), a.visible = !0
    }, a._updateFntFileTexture = function() {}, a._changeTextureColor = function() {}, a._updateChildrenDisplayedOpacity = function(a) {
        a.updateDisplayedOpacity(this._displayedOpacity)
    }, a._updateChildrenDisplayedColor = function(a) {
        a.updateDisplayedColor(this._displayedColor)
    }, a._initBatchTexture = function() {
        var a = this._node,
            b = a.textureAtlas.texture;
        a._opacityModifyRGB = b.hasPremultipliedAlpha();
        var c = a._reusedChar = new cc.Sprite;
        c.initWithTexture(b, cc.rect(0, 0, 0, 0), !1), c.batchNode = a
    }, a.rendering = function(a) {
        cc.SpriteBatchNode.WebGLRenderCmd.prototype.rendering.call(this, a);
        var b = this._node;
        if (cc.LABELBMFONT_DEBUG_DRAW) {
            var c = b.getContentSize(),
                d = cc.p(0 | -this._anchorPointInPoints.x, 0 | -this._anchorPointInPoints.y),
                e = [cc.p(d.x, d.y), cc.p(d.x + c.width, d.y), cc.p(d.x + c.width, d.y + c.height), cc.p(d.x, d.y + c.height)];
            cc._drawingUtil.setDrawColor(0, 255, 0, 255), cc._drawingUtil.drawPoly(e, 4, !0)
        }
    }, a._updateCharColorAndOpacity = function() {}
}();
cc.MotionStreak = cc.Node.extend({
    texture: null,
    fastMode: !1,
    startingPositionInitialized: !1,
    _blendFunc: null,
    _stroke: 0,
    _fadeDelta: 0,
    _minSeg: 0,
    _maxPoints: 0,
    _nuPoints: 0,
    _previousNuPoints: 0,
    _pointVertexes: null,
    _pointState: null,
    _vertices: null,
    _colorPointer: null,
    _texCoords: null,
    _verticesBuffer: null,
    _colorPointerBuffer: null,
    _texCoordsBuffer: null,
    _className: "MotionStreak",
    ctor: function(a, b, c, d, e) {
        cc.Node.prototype.ctor.call(this), this._positionR = cc.p(0, 0), this._blendFunc = new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA), this.fastMode = !1, this.startingPositionInitialized = !1, this.texture = null, this._stroke = 0, this._fadeDelta = 0, this._minSeg = 0, this._maxPoints = 0, this._nuPoints = 0, this._previousNuPoints = 0, this._pointVertexes = null, this._pointState = null, this._vertices = null, this._colorPointer = null, this._texCoords = null, this._verticesBuffer = null, this._colorPointerBuffer = null, this._texCoordsBuffer = null, void 0 !== e && this.initWithFade(a, b, c, d, e)
    },
    getTexture: function() {
        return this.texture
    },
    setTexture: function(a) {
        this.texture != a && (this.texture = a)
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    setBlendFunc: function(a, b) {
        void 0 === b ? this._blendFunc = a : (this._blendFunc.src = a, this._blendFunc.dst = b)
    },
    getOpacity: function() {
        return cc.log("cc.MotionStreak.getOpacity has not been supported."), 0
    },
    setOpacity: function() {
        cc.log("cc.MotionStreak.setOpacity has not been supported.")
    },
    setOpacityModifyRGB: function() {},
    isOpacityModifyRGB: function() {
        return !1
    },
    isFastMode: function() {
        return this.fastMode
    },
    setFastMode: function(a) {
        this.fastMode = a
    },
    isStartingPositionInitialized: function() {
        return this.startingPositionInitialized
    },
    setStartingPositionInitialized: function(a) {
        this.startingPositionInitialized = a
    },
    initWithFade: function(a, b, c, d, e) {
        if (!e) throw "cc.MotionStreak.initWithFade(): Invalid filename or texture";
        cc.isString(e) && (e = cc.textureCache.addImage(e)), cc.Node.prototype.setPosition.call(this, cc.p(0, 0)), this.anchorX = 0, this.anchorY = 0, this.ignoreAnchor = !0, this.startingPositionInitialized = !1, this.fastMode = !0, this._minSeg = -1 === b ? c / 5 : b, this._minSeg *= this._minSeg, this._stroke = c, this._fadeDelta = 1 / a;
        var f = (0 | 60 * a) + 2;
        return this._maxPoints = f, this._nuPoints = 0, this._pointState = new Float32Array(f), this._pointVertexes = new Float32Array(2 * f), this._vertices = new Float32Array(4 * f), this._texCoords = new Float32Array(4 * f), this._colorPointer = new Uint8Array(8 * f), this._verticesBuffer = gl.createBuffer(), this._texCoordsBuffer = gl.createBuffer(), this._colorPointerBuffer = gl.createBuffer(), this._blendFunc.src = gl.SRC_ALPHA, this._blendFunc.dst = gl.ONE_MINUS_SRC_ALPHA, this.texture = e, this.color = d, this.scheduleUpdate(), gl.bindBuffer(gl.ARRAY_BUFFER, this._verticesBuffer), gl.bufferData(gl.ARRAY_BUFFER, this._vertices, gl.DYNAMIC_DRAW), gl.bindBuffer(gl.ARRAY_BUFFER, this._texCoordsBuffer), gl.bufferData(gl.ARRAY_BUFFER, this._texCoords, gl.DYNAMIC_DRAW), gl.bindBuffer(gl.ARRAY_BUFFER, this._colorPointerBuffer), gl.bufferData(gl.ARRAY_BUFFER, this._colorPointer, gl.DYNAMIC_DRAW), !0
    },
    tintWithColor: function(a) {
        this.color = a;
        for (var b = this._colorPointer, c = 0, d = 2 * this._nuPoints; d > c; c++) b[4 * c] = a.r, b[4 * c + 1] = a.g, b[4 * c + 2] = a.b
    },
    reset: function() {
        this._nuPoints = 0
    },
    setPosition: function(a, b) {
        this.startingPositionInitialized = !0, void 0 === b ? (this._positionR.x = a.x, this._positionR.y = a.y) : (this._positionR.x = a, this._positionR.y = b)
    },
    getPositionX: function() {
        return this._positionR.x
    },
    setPositionX: function(a) {
        this._positionR.x = a, this.startingPositionInitialized || (this.startingPositionInitialized = !0)
    },
    getPositionY: function() {
        return this._positionR.y
    },
    setPositionY: function(a) {
        this._positionR.y = a, this.startingPositionInitialized || (this.startingPositionInitialized = !0)
    },
    update: function(a) {
        if (this.startingPositionInitialized) {
            this._renderCmd._updateDisplayColor(), a *= this._fadeDelta;
            var b, c, d, e, f = 0,
                g = this._nuPoints,
                h = this._pointState,
                i = this._pointVertexes,
                j = this._vertices,
                k = this._colorPointer;
            for (d = 0; g > d; d++)
                if (h[d] -= a, h[d] <= 0) f++;
                else {
                    b = d - f, f > 0 ? (h[b] = h[d], i[2 * b] = i[2 * d], i[2 * b + 1] = i[2 * d + 1], e = 2 * d, c = 2 * b, j[2 * c] = j[2 * e], j[2 * c + 1] = j[2 * e + 1], j[2 * (c + 1)] = j[2 * (e + 1)], j[2 * (c + 1) + 1] = j[2 * (e + 1) + 1], e *= 4, c *= 4, k[c + 0] = k[e + 0], k[c + 1] = k[e + 1], k[c + 2] = k[e + 2], k[c + 4] = k[e + 4], k[c + 5] = k[e + 5], k[c + 6] = k[e + 6]) : c = 8 * b;
                    var l = 255 * h[b];
                    k[c + 3] = l, k[c + 7] = l
                }
            g -= f;
            var m = !0;
            if (g >= this._maxPoints) m = !1;
            else if (g > 0) {
                var n = cc.pDistanceSQ(cc.p(i[2 * (g - 1)], i[2 * (g - 1) + 1]), this._positionR) < this._minSeg,
                    o = 1 == g ? !1 : cc.pDistanceSQ(cc.p(i[2 * (g - 2)], i[2 * (g - 2) + 1]), this._positionR) < 2 * this._minSeg;
                (n || o) && (m = !1)
            }
            if (m) {
                i[2 * g] = this._positionR.x, i[2 * g + 1] = this._positionR.y, h[g] = 1;
                var p = 8 * g,
                    q = this.getDisplayedColor();
                k[p] = q.r, k[p + 1] = q.g, k[p + 2] = q.b, k[p + 4] = q.r, k[p + 5] = q.g, k[p + 6] = q.b, k[p + 3] = 255, k[p + 7] = 255, g > 0 && this.fastMode && (g > 1 ? cc.vertexLineToPolygon(i, this._stroke, this._vertices, g, 1) : cc.vertexLineToPolygon(i, this._stroke, this._vertices, 0, 2)), g++
            }
            if (this.fastMode || cc.vertexLineToPolygon(i, this._stroke, this._vertices, 0, g), g && this._previousNuPoints != g) {
                var r = 1 / g,
                    s = this._texCoords;
                for (d = 0; g > d; d++) s[4 * d] = 0, s[4 * d + 1] = r * d, s[2 * (2 * d + 1)] = 1, s[2 * (2 * d + 1) + 1] = r * d;
                this._previousNuPoints = g
            }
            this._nuPoints = g
        }
    },
    _createRenderCmd: function() {
        return cc._renderType === cc._RENDER_TYPE_WEBGL ? new cc.MotionStreak.WebGLRenderCmd(this) : null
    }
}), cc.MotionStreak.create = function(a, b, c, d, e) {
    return new cc.MotionStreak(a, b, c, d, e)
}, cc.MotionStreak.WebGLRenderCmd = function(a) {
    cc.Node.WebGLRenderCmd.call(this, a), this._needDraw = !0, this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)
}, cc.MotionStreak.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype), cc.MotionStreak.WebGLRenderCmd.prototype.constructor = cc.Sprite.WebGLRenderCmd, cc.MotionStreak.WebGLRenderCmd.prototype.rendering = function(a) {
    var b = this._node;
    b._nuPoints <= 1 || b.texture && b.texture.isLoaded() && (a = a || cc._renderContext, this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), cc.glBlendFunc(b._blendFunc.src, b._blendFunc.dst), cc.glBindTexture2D(b.texture), a.bindBuffer(a.ARRAY_BUFFER, b._verticesBuffer), a.bufferData(a.ARRAY_BUFFER, b._vertices, a.DYNAMIC_DRAW), a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0), a.bindBuffer(a.ARRAY_BUFFER, b._texCoordsBuffer), a.bufferData(a.ARRAY_BUFFER, b._texCoords, a.DYNAMIC_DRAW), a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, 0, 0), a.bindBuffer(a.ARRAY_BUFFER, b._colorPointerBuffer), a.bufferData(a.ARRAY_BUFFER, b._colorPointer, a.DYNAMIC_DRAW), a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 0, 0), a.drawArrays(a.TRIANGLE_STRIP, 0, 2 * b._nuPoints), cc.g_NumberOfDraws++)
};
cc.NodeGrid = cc.Node.extend({
    grid: null,
    _target: null,
    getGrid: function() {
        return this.grid
    },
    setGrid: function(a) {
        this.grid = a
    },
    setTarget: function(a) {
        this._target = a
    },
    _transformForWebGL: function() {
        var a = this._transform4x4,
            b = cc.current_stack.top,
            c = this.getNodeToParentTransform(),
            d = a.mat;
        if (d[0] = c.a, d[4] = c.c, d[12] = c.tx, d[1] = c.b, d[5] = c.d, d[13] = c.ty, d[14] = this._vertexZ, cc.kmMat4Multiply(b, b, a), !(null == this._camera || this.grid && this.grid.isActive())) {
            var e = this._anchorPointInPoints.x,
                f = this._anchorPointInPoints.y,
                g = 0 !== e || 0 !== f;
            g ? (cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (e = 0 | e, f = 0 | f), cc.kmGLTranslatef(e, f, 0), this._camera.locate(), cc.kmGLTranslatef(-e, -f, 0)) : this._camera.locate()
        }
    },
    _createRenderCmd: function() {
        return cc._renderType === cc._RENDER_TYPE_WEBGL ? new cc.NodeGrid.WebGLRenderCmd(this) : new cc.Node.CanvasRenderCmd(this)
    }
});
var _p = cc.NodeGrid.prototype;
_p.grid, _p.target, cc.defineGetterSetter(_p, "target", null, _p.setTarget), cc.NodeGrid.create = function() {
        return new cc.NodeGrid
    },
    function() {
        cc.NodeGrid.WebGLRenderCmd = function(a) {
            cc.Node.WebGLRenderCmd.call(this, a), this._needDraw = !1, this._gridBeginCommand = new cc.CustomRenderCmd(this, this.onGridBeginDraw), this._gridEndCommand = new cc.CustomRenderCmd(this, this.onGridEndDraw)
        };
        var a = cc.NodeGrid.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
        a.constructor = cc.NodeGrid.WebGLRenderCmd, a.visit = function(a) {
            var b = this._node;
            if (b._visible) {
                a = a || this.getParentRenderCmd(), b._parent && b._parent._renderCmd && (this._curLevel = b._parent._renderCmd._curLevel + 1);
                var c = cc.current_stack;
                c.stack.push(c.top), this._syncStatus(a), c.top = this._stackMatrix, cc.renderer.pushRenderCommand(this._gridBeginCommand), b._target && b._target.visit();
                var d = b._children;
                if (d && d.length > 0) {
                    var e = d.length;
                    b.sortAllChildren();
                    for (var f = 0; e > f; f++) {
                        var g = d[f];
                        g && g.visit()
                    }
                }
                cc.renderer.pushRenderCommand(this._gridEndCommand), this._dirtyFlag = 0, c.top = c.stack.pop()
            }
        }, a.onGridBeginDraw = function() {
            var a = this._node.grid;
            a && a._active && a.beforeDraw()
        }, a.onGridEndDraw = function() {
            var a = this._node.grid;
            a && a._active && a.afterDraw(this._node)
        }
    }();
cc.v2fzero = function() {
        return {
            x: 0,
            y: 0
        }
    }, cc.v2f = function(a, b) {
        return {
            x: a,
            y: b
        }
    }, cc.v2fadd = function(a, b) {
        return cc.v2f(a.x + b.x, a.y + b.y)
    }, cc.v2fsub = function(a, b) {
        return cc.v2f(a.x - b.x, a.y - b.y)
    }, cc.v2fmult = function(a, b) {
        return cc.v2f(a.x * b, a.y * b)
    }, cc.v2fperp = function(a) {
        return cc.v2f(-a.y, a.x)
    }, cc.v2fneg = function(a) {
        return cc.v2f(-a.x, -a.y)
    }, cc.v2fdot = function(a, b) {
        return a.x * b.x + a.y * b.y
    }, cc.v2fforangle = function(a) {
        return cc.v2f(Math.cos(a), Math.sin(a))
    }, cc.v2fnormalize = function(a) {
        var b = cc.pNormalize(cc.p(a.x, a.y));
        return cc.v2f(b.x, b.y)
    }, cc.__v2f = function(a) {
        return cc.v2f(a.x, a.y)
    }, cc.__t = function(a) {
        return {
            u: a.x,
            v: a.y
        }
    }, cc.DrawNodeCanvas = cc.Node.extend({
        _buffer: null,
        _blendFunc: null,
        _lineWidth: 1,
        _drawColor: null,
        _className: "DrawNodeCanvas",
        ctor: function() {
            cc.Node.prototype.ctor.call(this);
            var a = this._renderCmd;
            a._buffer = this._buffer = [], a._drawColor = this._drawColor = cc.color(255, 255, 255, 255), a._blendFunc = this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST), this.init()
        },
        getBlendFunc: function() {
            return this._blendFunc
        },
        setBlendFunc: function(a, b) {
            void 0 === b ? (this._blendFunc.src = a.src, this._blendFunc.dst = a.dst) : (this._blendFunc.src = a, this._blendFunc.dst = b)
        },
        setLineWidth: function(a) {
            this._lineWidth = a
        },
        getLineWidth: function() {
            return this._lineWidth
        },
        setDrawColor: function(a) {
            var b = this._drawColor;
            b.r = a.r, b.g = a.g, b.b = a.b, b.a = null == a.a ? 255 : a.a
        },
        getDrawColor: function() {
            return cc.color(this._drawColor.r, this._drawColor.g, this._drawColor.b, this._drawColor.a)
        },
        drawRect: function(a, b, c, d, e) {
            d = d || this._lineWidth, e = e || this.getDrawColor(), null == e.a && (e.a = 255);
            var f = [a, cc.p(b.x, a.y), b, cc.p(a.x, b.y)],
                g = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
            g.verts = f, g.lineWidth = d, g.lineColor = e, g.isClosePolygon = !0, g.isStroke = !0, g.lineCap = "butt", g.fillColor = c, c && (null == c.a && (c.a = 255), g.isFill = !0), this._buffer.push(g)
        },
        drawCircle: function(a, b, c, d, e, f, g) {
            f = f || this._lineWidth, g = g || this.getDrawColor(), null == g.a && (g.a = 255);
            for (var h = 2 * Math.PI / d, i = [], j = 0; d >= j; j++) {
                var k = j * h,
                    l = b * Math.cos(k + c) + a.x,
                    m = b * Math.sin(k + c) + a.y;
                i.push(cc.p(l, m))
            }
            e && i.push(cc.p(a.x, a.y));
            var n = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
            n.verts = i, n.lineWidth = f, n.lineColor = g, n.isClosePolygon = !0, n.isStroke = !0, this._buffer.push(n)
        },
        drawQuadBezier: function(a, b, c, d, e, f) {
            e = e || this._lineWidth, f = f || this.getDrawColor(), null == f.a && (f.a = 255);
            for (var g = [], h = 0, i = 0; d > i; i++) {
                var j = Math.pow(1 - h, 2) * a.x + 2 * (1 - h) * h * b.x + h * h * c.x,
                    k = Math.pow(1 - h, 2) * a.y + 2 * (1 - h) * h * b.y + h * h * c.y;
                g.push(cc.p(j, k)), h += 1 / d
            }
            g.push(cc.p(c.x, c.y));
            var l = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
            l.verts = g, l.lineWidth = e, l.lineColor = f, l.isStroke = !0, l.lineCap = "round", this._buffer.push(l)
        },
        drawCubicBezier: function(a, b, c, d, e, f, g) {
            f = f || this._lineWidth, g = g || this.getDrawColor(), null == g.a && (g.a = 255);
            for (var h = [], i = 0, j = 0; e > j; j++) {
                var k = Math.pow(1 - i, 3) * a.x + 3 * Math.pow(1 - i, 2) * i * b.x + 3 * (1 - i) * i * i * c.x + i * i * i * d.x,
                    l = Math.pow(1 - i, 3) * a.y + 3 * Math.pow(1 - i, 2) * i * b.y + 3 * (1 - i) * i * i * c.y + i * i * i * d.y;
                h.push(cc.p(k, l)), i += 1 / e
            }
            h.push(cc.p(d.x, d.y));
            var m = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
            m.verts = h, m.lineWidth = f, m.lineColor = g, m.isStroke = !0, m.lineCap = "round", this._buffer.push(m)
        },
        drawCatmullRom: function(a, b, c, d) {
            this.drawCardinalSpline(a, .5, b, c, d)
        },
        drawCardinalSpline: function(a, b, c, d, e) {
            d = d || this._lineWidth, e = e || this.getDrawColor(), null == e.a && (e.a = 255);
            for (var f, g, h = [], i = 1 / a.length, j = 0; c + 1 > j; j++) {
                var k = j / c;
                1 == k ? (f = a.length - 1, g = 1) : (f = 0 | k / i, g = (k - i * f) / i);
                var l = cc.cardinalSplineAt(cc.getControlPointAt(a, f - 1), cc.getControlPointAt(a, f - 0), cc.getControlPointAt(a, f + 1), cc.getControlPointAt(a, f + 2), b, g);
                h.push(l)
            }
            var m = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
            m.verts = h, m.lineWidth = d, m.lineColor = e, m.isStroke = !0, m.lineCap = "round", this._buffer.push(m)
        },
        drawDot: function(a, b, c) {
            c = c || this.getDrawColor(), null == c.a && (c.a = 255);
            var d = new cc._DrawNodeElement(cc.DrawNode.TYPE_DOT);
            d.verts = [a], d.lineWidth = b, d.fillColor = c, this._buffer.push(d)
        },
        drawDots: function(a, b, c) {
            if (a && 0 != a.length) {
                c = c || this.getDrawColor(), null == c.a && (c.a = 255);
                for (var d = 0, e = a.length; e > d; d++) this.drawDot(a[d], b, c)
            }
        },
        drawSegment: function(a, b, c, d) {
            c = c || this._lineWidth, d = d || this.getDrawColor(), null == d.a && (d.a = 255);
            var e = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
            e.verts = [a, b], e.lineWidth = 2 * c, e.lineColor = d, e.isStroke = !0, e.lineCap = "round", this._buffer.push(e)
        },
        drawPoly_: function(a, b, c, d) {
            c = c || this._lineWidth, d = d || this.getDrawColor(), null == d.a && (d.a = 255);
            var e = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
            e.verts = a, e.fillColor = b, e.lineWidth = c, e.lineColor = d, e.isClosePolygon = !0, e.isStroke = !0, e.lineCap = "round", b && (e.isFill = !0), this._buffer.push(e)
        },
        drawPoly: function(a, b, c, d) {
            for (var e = [], f = 0; f < a.length; f++) e.push(cc.p(a[f].x, a[f].y));
            return this.drawPoly_(e, b, c, d)
        },
        clear: function() {
            this._buffer.length = 0
        },
        _createRenderCmd: function() {
            return new cc.DrawNode.CanvasRenderCmd(this)
        }
    }), cc.DrawNodeWebGL = cc.Node.extend({
        _bufferCapacity: 0,
        _buffer: null,
        _trianglesArrayBuffer: null,
        _trianglesWebBuffer: null,
        _trianglesReader: null,
        _lineWidth: 1,
        _drawColor: null,
        _blendFunc: null,
        _dirty: !1,
        _className: "DrawNodeWebGL",
        getBlendFunc: function() {
            return this._blendFunc
        },
        setBlendFunc: function(a, b) {
            void 0 === b ? (this._blendFunc.src = a.src, this._blendFunc.dst = a.dst) : (this._blendFunc.src = a, this._blendFunc.dst = b)
        },
        ctor: function() {
            cc.Node.prototype.ctor.call(this), this._buffer = [], this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST), this._drawColor = cc.color(255, 255, 255, 255), this.init()
        },
        init: function() {
            return cc.Node.prototype.init.call(this) ? (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_LENGTHTEXTURECOLOR), this._ensureCapacity(64), this._trianglesWebBuffer = cc._renderContext.createBuffer(), this._dirty = !0, !0) : !1
        },
        setLineWidth: function(a) {
            this._lineWidth = a
        },
        getLineWidth: function() {
            return this._lineWidth
        },
        setDrawColor: function(a) {
            var b = this._drawColor;
            b.r = a.r, b.g = a.g, b.b = a.b, b.a = a.a
        },
        getDrawColor: function() {
            return cc.color(this._drawColor.r, this._drawColor.g, this._drawColor.b, this._drawColor.a)
        },
        drawRect: function(a, b, c, d, e) {
            d = d || this._lineWidth, e = e || this.getDrawColor(), null == e.a && (e.a = 255);
            var f = [a, cc.p(b.x, a.y), b, cc.p(a.x, b.y)];
            null == c ? this._drawSegments(f, d, e, !0) : this.drawPoly(f, c, d, e)
        },
        drawCircle: function(a, b, c, d, e, f, g) {
            f = f || this._lineWidth, g = g || this.getDrawColor(), null == g.a && (g.a = 255);
            var h, i, j = 2 * Math.PI / d,
                k = [];
            for (h = 0; d >= h; h++) {
                var l = h * j,
                    m = b * Math.cos(l + c) + a.x,
                    n = b * Math.sin(l + c) + a.y;
                k.push(cc.p(m, n))
            }
            for (e && k.push(cc.p(a.x, a.y)), f *= .5, h = 0, i = k.length; i - 1 > h; h++) this.drawSegment(k[h], k[h + 1], f, g)
        },
        drawQuadBezier: function(a, b, c, d, e, f) {
            e = e || this._lineWidth, f = f || this.getDrawColor(), null == f.a && (f.a = 255);
            for (var g = [], h = 0, i = 0; d > i; i++) {
                var j = Math.pow(1 - h, 2) * a.x + 2 * (1 - h) * h * b.x + h * h * c.x,
                    k = Math.pow(1 - h, 2) * a.y + 2 * (1 - h) * h * b.y + h * h * c.y;
                g.push(cc.p(j, k)), h += 1 / d
            }
            g.push(cc.p(c.x, c.y)), this._drawSegments(g, e, f, !1)
        },
        drawCubicBezier: function(a, b, c, d, e, f, g) {
            f = f || this._lineWidth, g = g || this.getDrawColor(), null == g.a && (g.a = 255);
            for (var h = [], i = 0, j = 0; e > j; j++) {
                var k = Math.pow(1 - i, 3) * a.x + 3 * Math.pow(1 - i, 2) * i * b.x + 3 * (1 - i) * i * i * c.x + i * i * i * d.x,
                    l = Math.pow(1 - i, 3) * a.y + 3 * Math.pow(1 - i, 2) * i * b.y + 3 * (1 - i) * i * i * c.y + i * i * i * d.y;
                h.push(cc.p(k, l)), i += 1 / e
            }
            h.push(cc.p(d.x, d.y)), this._drawSegments(h, f, g, !1)
        },
        drawCatmullRom: function(a, b, c, d) {
            this.drawCardinalSpline(a, .5, b, c, d)
        },
        drawCardinalSpline: function(a, b, c, d, e) {
            d = d || this._lineWidth, e = e || this.getDrawColor(), null == e.a && (e.a = 255);
            for (var f, g, h = [], i = 1 / a.length, j = 0; c + 1 > j; j++) {
                var k = j / c;
                1 == k ? (f = a.length - 1, g = 1) : (f = 0 | k / i, g = (k - i * f) / i);
                var l = cc.cardinalSplineAt(cc.getControlPointAt(a, f - 1), cc.getControlPointAt(a, f - 0), cc.getControlPointAt(a, f + 1), cc.getControlPointAt(a, f + 2), b, g);
                h.push(l)
            }
            d *= .5;
            for (var m = 0, n = h.length; n - 1 > m; m++) this.drawSegment(h[m], h[m + 1], d, e)
        },
        _render: function() {
            var a = cc._renderContext;
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), a.bindBuffer(a.ARRAY_BUFFER, this._trianglesWebBuffer), this._dirty && (a.bufferData(a.ARRAY_BUFFER, this._trianglesArrayBuffer, a.STREAM_DRAW), this._dirty = !1);
            var b = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
            a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, b, 0), a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, b, 8), a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, b, 12), a.drawArrays(a.TRIANGLES, 0, 3 * this._buffer.length), cc.incrementGLDraws(1)
        },
        _ensureCapacity: function(a) {
            var b = this,
                c = b._buffer;
            if (c.length + a > b._bufferCapacity) {
                var d = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT;
                if (b._bufferCapacity += Math.max(b._bufferCapacity, a), null == c || 0 === c.length) b._buffer = [], b._trianglesArrayBuffer = new ArrayBuffer(d * b._bufferCapacity), b._trianglesReader = new Uint8Array(b._trianglesArrayBuffer);
                else {
                    for (var e = [], f = new ArrayBuffer(d * b._bufferCapacity), g = 0; g < c.length; g++) e[g] = new cc.V2F_C4B_T2F_Triangle(c[g].a, c[g].b, c[g].c, f, g * d);
                    b._trianglesReader = new Uint8Array(f), b._trianglesArrayBuffer = f, b._buffer = e
                }
            }
        },
        drawDot: function(a, b, c) {
            c = c || this.getDrawColor(), null == c.a && (c.a = 255);
            var d = {
                    r: 0 | c.r,
                    g: 0 | c.g,
                    b: 0 | c.b,
                    a: 0 | c.a
                },
                e = {
                    vertices: {
                        x: a.x - b,
                        y: a.y - b
                    },
                    colors: d,
                    texCoords: {
                        u: -1,
                        v: -1
                    }
                },
                f = {
                    vertices: {
                        x: a.x - b,
                        y: a.y + b
                    },
                    colors: d,
                    texCoords: {
                        u: -1,
                        v: 1
                    }
                },
                g = {
                    vertices: {
                        x: a.x + b,
                        y: a.y + b
                    },
                    colors: d,
                    texCoords: {
                        u: 1,
                        v: 1
                    }
                },
                h = {
                    vertices: {
                        x: a.x + b,
                        y: a.y - b
                    },
                    colors: d,
                    texCoords: {
                        u: 1,
                        v: -1
                    }
                };
            this._ensureCapacity(6), this._buffer.push(new cc.V2F_C4B_T2F_Triangle(e, f, g, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT)), this._buffer.push(new cc.V2F_C4B_T2F_Triangle(e, g, h, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT)), this._dirty = !0
        },
        drawDots: function(a, b, c) {
            if (a && 0 != a.length) {
                c = c || this.getDrawColor(), null == c.a && (c.a = 255);
                for (var d = 0, e = a.length; e > d; d++) this.drawDot(a[d], b, c)
            }
        },
        drawSegment: function(a, b, c, d) {
            d = d || this.getDrawColor(), null == d.a && (d.a = 255), c = c || .5 * this._lineWidth;
            var e = 18;
            this._ensureCapacity(e);
            var f = {
                    r: 0 | d.r,
                    g: 0 | d.g,
                    b: 0 | d.b,
                    a: 0 | d.a
                },
                g = cc.__v2f(a),
                h = cc.__v2f(b),
                i = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(h, g))),
                j = cc.v2fperp(i),
                k = cc.v2fmult(i, c),
                l = cc.v2fmult(j, c),
                m = cc.v2fsub(h, cc.v2fadd(k, l)),
                n = cc.v2fadd(h, cc.v2fsub(k, l)),
                o = cc.v2fsub(h, k),
                p = cc.v2fadd(h, k),
                q = cc.v2fsub(g, k),
                r = cc.v2fadd(g, k),
                s = cc.v2fsub(g, cc.v2fsub(k, l)),
                t = cc.v2fadd(g, cc.v2fadd(k, l)),
                u = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT,
                v = this._trianglesArrayBuffer,
                w = this._buffer;
            w.push(new cc.V2F_C4B_T2F_Triangle({
                vertices: m,
                colors: f,
                texCoords: cc.__t(cc.v2fneg(cc.v2fadd(i, j)))
            }, {
                vertices: n,
                colors: f,
                texCoords: cc.__t(cc.v2fsub(i, j))
            }, {
                vertices: o,
                colors: f,
                texCoords: cc.__t(cc.v2fneg(i))
            }, v, w.length * u)), w.push(new cc.V2F_C4B_T2F_Triangle({
                vertices: p,
                colors: f,
                texCoords: cc.__t(i)
            }, {
                vertices: n,
                colors: f,
                texCoords: cc.__t(cc.v2fsub(i, j))
            }, {
                vertices: o,
                colors: f,
                texCoords: cc.__t(cc.v2fneg(i))
            }, v, w.length * u)), w.push(new cc.V2F_C4B_T2F_Triangle({
                vertices: p,
                colors: f,
                texCoords: cc.__t(i)
            }, {
                vertices: q,
                colors: f,
                texCoords: cc.__t(cc.v2fneg(i))
            }, {
                vertices: o,
                colors: f,
                texCoords: cc.__t(cc.v2fneg(i))
            }, v, w.length * u)), w.push(new cc.V2F_C4B_T2F_Triangle({
                vertices: p,
                colors: f,
                texCoords: cc.__t(i)
            }, {
                vertices: q,
                colors: f,
                texCoords: cc.__t(cc.v2fneg(i))
            }, {
                vertices: r,
                colors: f,
                texCoords: cc.__t(i)
            }, v, w.length * u)), w.push(new cc.V2F_C4B_T2F_Triangle({
                vertices: s,
                colors: f,
                texCoords: cc.__t(cc.v2fsub(j, i))
            }, {
                vertices: q,
                colors: f,
                texCoords: cc.__t(cc.v2fneg(i))
            }, {
                vertices: r,
                colors: f,
                texCoords: cc.__t(i)
            }, v, w.length * u)), w.push(new cc.V2F_C4B_T2F_Triangle({
                vertices: s,
                colors: f,
                texCoords: cc.__t(cc.v2fsub(j, i))
            }, {
                vertices: t,
                colors: f,
                texCoords: cc.__t(cc.v2fadd(i, j))
            }, {
                vertices: r,
                colors: f,
                texCoords: cc.__t(i)
            }, v, w.length * u)), this._dirty = !0
        },
        drawPoly: function(a, b, c, d) {
            if (null == b) return void this._drawSegments(a, c, d, !0);
            null == b.a && (b.a = 255), null == d.a && (d.a = 255), c = c || this._lineWidth, c *= .5;
            var e, f, g, h, i = {
                    r: 0 | b.r,
                    g: 0 | b.g,
                    b: 0 | b.b,
                    a: 0 | b.a
                },
                j = {
                    r: 0 | d.r,
                    g: 0 | d.g,
                    b: 0 | d.b,
                    a: 0 | d.a
                },
                k = [],
                l = a.length;
            for (e = 0; l > e; e++) {
                f = cc.__v2f(a[(e - 1 + l) % l]), g = cc.__v2f(a[e]), h = cc.__v2f(a[(e + 1) % l]);
                var m = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(g, f))),
                    n = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(h, g))),
                    o = cc.v2fmult(cc.v2fadd(m, n), 1 / (cc.v2fdot(m, n) + 1));
                k[e] = {
                    offset: o,
                    n: n
                }
            }
            var p = c > 0,
                q = 3 * l - 2,
                r = 3 * q;
            this._ensureCapacity(r);
            var s = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT,
                t = this._trianglesArrayBuffer,
                u = this._buffer,
                v = 0 == p ? .5 : 0;
            for (e = 0; l - 2 > e; e++) f = cc.v2fsub(cc.__v2f(a[0]), cc.v2fmult(k[0].offset, v)), g = cc.v2fsub(cc.__v2f(a[e + 1]), cc.v2fmult(k[e + 1].offset, v)), h = cc.v2fsub(cc.__v2f(a[e + 2]), cc.v2fmult(k[e + 2].offset, v)), u.push(new cc.V2F_C4B_T2F_Triangle({
                vertices: f,
                colors: i,
                texCoords: cc.__t(cc.v2fzero())
            }, {
                vertices: g,
                colors: i,
                texCoords: cc.__t(cc.v2fzero())
            }, {
                vertices: h,
                colors: i,
                texCoords: cc.__t(cc.v2fzero())
            }, t, u.length * s));
            for (e = 0; l > e; e++) {
                var w = (e + 1) % l;
                f = cc.__v2f(a[e]), g = cc.__v2f(a[w]);
                var x = k[e].n,
                    y = k[e].offset,
                    z = k[w].offset,
                    A = p ? cc.v2fsub(f, cc.v2fmult(y, c)) : cc.v2fsub(f, cc.v2fmult(y, .5)),
                    B = p ? cc.v2fsub(g, cc.v2fmult(z, c)) : cc.v2fsub(g, cc.v2fmult(z, .5)),
                    C = p ? cc.v2fadd(f, cc.v2fmult(y, c)) : cc.v2fadd(f, cc.v2fmult(y, .5)),
                    D = p ? cc.v2fadd(g, cc.v2fmult(z, c)) : cc.v2fadd(g, cc.v2fmult(z, .5));
                p ? (u.push(new cc.V2F_C4B_T2F_Triangle({
                    vertices: A,
                    colors: j,
                    texCoords: cc.__t(cc.v2fneg(x))
                }, {
                    vertices: B,
                    colors: j,
                    texCoords: cc.__t(cc.v2fneg(x))
                }, {
                    vertices: D,
                    colors: j,
                    texCoords: cc.__t(x)
                }, t, u.length * s)), u.push(new cc.V2F_C4B_T2F_Triangle({
                    vertices: A,
                    colors: j,
                    texCoords: cc.__t(cc.v2fneg(x))
                }, {
                    vertices: C,
                    colors: j,
                    texCoords: cc.__t(x)
                }, {
                    vertices: D,
                    colors: j,
                    texCoords: cc.__t(x)
                }, t, u.length * s))) : (u.push(new cc.V2F_C4B_T2F_Triangle({
                    vertices: A,
                    colors: i,
                    texCoords: cc.__t(cc.v2fzero())
                }, {
                    vertices: B,
                    colors: i,
                    texCoords: cc.__t(cc.v2fzero())
                }, {
                    vertices: D,
                    colors: i,
                    texCoords: cc.__t(x)
                }, t, u.length * s)), u.push(new cc.V2F_C4B_T2F_Triangle({
                    vertices: A,
                    colors: i,
                    texCoords: cc.__t(cc.v2fzero())
                }, {
                    vertices: C,
                    colors: i,
                    texCoords: cc.__t(x)
                }, {
                    vertices: D,
                    colors: i,
                    texCoords: cc.__t(x)
                }, t, u.length * s)))
            }
            k = null, this._dirty = !0
        },
        _drawSegments: function(a, b, c, d) {
            if (b = b || this._lineWidth, c = c || this._drawColor, null == c.a && (c.a = 255), b *= .5, !(0 >= b)) {
                var e, f, g, h, i = {
                        r: 0 | c.r,
                        g: 0 | c.g,
                        b: 0 | c.b,
                        a: 0 | c.a
                    },
                    j = [],
                    k = a.length;
                for (e = 0; k > e; e++) {
                    f = cc.__v2f(a[(e - 1 + k) % k]), g = cc.__v2f(a[e]), h = cc.__v2f(a[(e + 1) % k]);
                    var l = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(g, f))),
                        m = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(h, g))),
                        n = cc.v2fmult(cc.v2fadd(l, m), 1 / (cc.v2fdot(l, m) + 1));
                    j[e] = {
                        offset: n,
                        n: m
                    }
                }
                var o = 3 * k - 2,
                    p = 3 * o;
                this._ensureCapacity(p);
                var q = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT,
                    r = this._trianglesArrayBuffer,
                    s = this._buffer,
                    t = d ? k : k - 1;
                for (e = 0; t > e; e++) {
                    var u = (e + 1) % k;
                    f = cc.__v2f(a[e]), g = cc.__v2f(a[u]);
                    var v = j[e].n,
                        w = j[e].offset,
                        x = j[u].offset,
                        y = cc.v2fsub(f, cc.v2fmult(w, b)),
                        z = cc.v2fsub(g, cc.v2fmult(x, b)),
                        A = cc.v2fadd(f, cc.v2fmult(w, b)),
                        B = cc.v2fadd(g, cc.v2fmult(x, b));
                    s.push(new cc.V2F_C4B_T2F_Triangle({
                        vertices: y,
                        colors: i,
                        texCoords: cc.__t(cc.v2fneg(v))
                    }, {
                        vertices: z,
                        colors: i,
                        texCoords: cc.__t(cc.v2fneg(v))
                    }, {
                        vertices: B,
                        colors: i,
                        texCoords: cc.__t(v)
                    }, r, s.length * q)), s.push(new cc.V2F_C4B_T2F_Triangle({
                        vertices: y,
                        colors: i,
                        texCoords: cc.__t(cc.v2fneg(v))
                    }, {
                        vertices: A,
                        colors: i,
                        texCoords: cc.__t(v)
                    }, {
                        vertices: B,
                        colors: i,
                        texCoords: cc.__t(v)
                    }, r, s.length * q))
                }
                j = null, this._dirty = !0
            }
        },
        clear: function() {
            this._buffer.length = 0, this._dirty = !0
        },
        _createRenderCmd: function() {
            return new cc.DrawNode.WebGLRenderCmd(this)
        }
    }), cc.DrawNode = cc._renderType == cc._RENDER_TYPE_WEBGL ? cc.DrawNodeWebGL : cc.DrawNodeCanvas, cc.DrawNode.create = function() {
        return new cc.DrawNode
    }, cc._DrawNodeElement = function(a, b, c, d, e, f, g, h, i) {
        var j = this;
        j.type = a, j.verts = b || null, j.fillColor = c || null, j.lineWidth = d || 0, j.lineColor = e || null, j.lineCap = f || "butt", j.isClosePolygon = g || !1, j.isFill = h || !1, j.isStroke = i || !1
    }, cc.DrawNode.TYPE_DOT = 0, cc.DrawNode.TYPE_SEGMENT = 1, cc.DrawNode.TYPE_POLY = 2,
    function() {
        cc.DrawNode.CanvasRenderCmd = function(a) {
            cc.Node.CanvasRenderCmd.call(this, a), this._needDraw = !0, this._buffer = null, this._drawColor = null, this._blendFunc = null
        }, cc.DrawNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype), cc.DrawNode.CanvasRenderCmd.prototype.constructor = cc.DrawNode.CanvasRenderCmd, cc.DrawNode.CanvasRenderCmd.prototype.rendering = function(a, b, c) {
            var d = a || cc._renderContext,
                e = (d.getContext(), this._node),
                f = e._displayedOpacity / 255;
            if (0 !== f) {
                d.setTransform(this._worldTransform, b, c), d.setGlobalAlpha(f), this._blendFunc && this._blendFunc.src == cc.SRC_ALPHA && this._blendFunc.dst == cc.ONE && d.setCompositeOperation("lighter");
                for (var g = this._buffer, h = 0, i = g.length; i > h; h++) {
                    var j = g[h];
                    switch (j.type) {
                        case cc.DrawNode.TYPE_DOT:
                            this._drawDot(d, j, b, c);
                            break;
                        case cc.DrawNode.TYPE_SEGMENT:
                            this._drawSegment(d, j, b, c);
                            break;
                        case cc.DrawNode.TYPE_POLY:
                            this._drawPoly(d, j, b, c)
                    }
                }
            }
        }, cc.DrawNode.CanvasRenderCmd.prototype._drawDot = function(a, b, c, d) {
            var e = b.fillColor,
                f = b.verts[0],
                g = b.lineWidth,
                h = a.getContext();
            a.setFillStyle("rgba(" + (0 | e.r) + "," + (0 | e.g) + "," + (0 | e.b) + "," + e.a / 255 + ")"), h.beginPath(), h.arc(f.x * c, -f.y * d, g * c, 0, 2 * Math.PI, !1), h.closePath(), h.fill()
        }, cc.DrawNode.CanvasRenderCmd.prototype._drawSegment = function(a, b, c, d) {
            var e = b.lineColor,
                f = b.verts[0],
                g = b.verts[1],
                h = b.lineWidth,
                i = b.lineCap,
                j = a.getContext();
            a.setStrokeStyle("rgba(" + (0 | e.r) + "," + (0 | e.g) + "," + (0 | e.b) + "," + e.a / 255 + ")"), j.lineWidth = h * c, j.beginPath(), j.lineCap = i, j.moveTo(f.x * c, -f.y * d), j.lineTo(g.x * c, -g.y * d), j.stroke()
        }, cc.DrawNode.CanvasRenderCmd.prototype._drawPoly = function(a, b, c, d) {
            var e = b.verts,
                f = b.lineCap;
            if (null != e) {
                var g = b.fillColor,
                    h = b.lineWidth,
                    i = b.lineColor,
                    j = b.isClosePolygon,
                    k = b.isFill,
                    l = b.isStroke,
                    m = a.getContext(),
                    n = e[0];
                m.lineCap = f, g && a.setFillStyle("rgba(" + (0 | g.r) + "," + (0 | g.g) + "," + (0 | g.b) + "," + g.a / 255 + ")"), h && (m.lineWidth = h * c), i && a.setStrokeStyle("rgba(" + (0 | i.r) + "," + (0 | i.g) + "," + (0 | i.b) + "," + i.a / 255 + ")"), m.beginPath(), m.moveTo(n.x * c, -n.y * d);
                for (var o = 1, p = e.length; p > o; o++) m.lineTo(e[o].x * c, -e[o].y * d);
                j && m.closePath(), k && m.fill(), l && m.stroke()
            }
        }
    }();
! function() {
    cc.DrawNode.WebGLRenderCmd = function(a) {
        cc.Node.WebGLRenderCmd.call(this, a), this._needDraw = !0
    }, cc.DrawNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype), cc.DrawNode.WebGLRenderCmd.prototype.constructor = cc.DrawNode.WebGLRenderCmd, cc.DrawNode.WebGLRenderCmd.prototype.rendering = function() {
        var a = this._node;
        cc.glBlendFunc(a._blendFunc.src, a._blendFunc.dst), this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix), a._render()
    }
}();
cc.stencilBits = -1, cc.ClippingNode = cc.Node.extend({
    alphaThreshold: 0,
    inverted: !1,
    _stencil: null,
    _className: "ClippingNode",
    ctor: function(a) {
        a = a || null, cc.Node.prototype.ctor.call(this), this._stencil = a, this.alphaThreshold = 1, this.inverted = !1, this._renderCmd.initStencilBits()
    },
    init: function(a) {
        return this._stencil = a, this.alphaThreshold = 1, this.inverted = !1, this._renderCmd.initStencilBits(), !0
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this), this._stencil.onEnter()
    },
    onEnterTransitionDidFinish: function() {
        cc.Node.prototype.onEnterTransitionDidFinish.call(this), this._stencil.onEnterTransitionDidFinish()
    },
    onExitTransitionDidStart: function() {
        this._stencil.onExitTransitionDidStart(), cc.Node.prototype.onExitTransitionDidStart.call(this)
    },
    onExit: function() {
        this._stencil.onExit(), cc.Node.prototype.onExit.call(this)
    },
    getAlphaThreshold: function() {
        return this.alphaThreshold
    },
    setAlphaThreshold: function(a) {
        this.alphaThreshold = a
    },
    isInverted: function() {
        return this.inverted
    },
    setInverted: function(a) {
        this.inverted = a
    },
    getStencil: function() {
        return this._stencil
    },
    setStencil: function(a) {
        this._stencil != a && this._renderCmd.setStencil(a)
    },
    _createRenderCmd: function() {
        return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.ClippingNode.CanvasRenderCmd(this) : new cc.ClippingNode.WebGLRenderCmd(this)
    }
});
var _p = cc.ClippingNode.prototype;
cc.defineGetterSetter(_p, "stencil", _p.getStencil, _p.setStencil), _p.stencil, cc.ClippingNode.create = function(a) {
        return new cc.ClippingNode(a)
    },
    function() {
        cc.ClippingNode.CanvasRenderCmd = function(a) {
            cc.Node.CanvasRenderCmd.call(this, a), this._needDraw = !1, this._godhelpme = !1, this._clipElemType = !1, this._rendererSaveCmd = new cc.CustomRenderCmd(this, this._saveCmdCallback), this._rendererClipCmd = new cc.CustomRenderCmd(this, this._clipCmdCallback), this._rendererRestoreCmd = new cc.CustomRenderCmd(this, this._restoreCmdCallback)
        };
        var a = cc.ClippingNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
        a.constructor = cc.ClippingNode.CanvasRenderCmd, a.initStencilBits = function() {}, a.setStencil = function(a) {
            if (null != a)
                if (this._node._stencil = a, a instanceof cc.DrawNode) {
                    if (a._buffer)
                        for (var b = 0; b < a._buffer.length; b++) a._buffer[b].isFill = !1, a._buffer[b].isStroke = !1;
                    a._renderCmd.rendering = function(b, c, d) {
                        c = c || cc.view.getScaleX(), d = d || cc.view.getScaleY();
                        var e = b || cc._renderContext,
                            f = e.getContext(),
                            g = this._transform;
                        e.save(), f.transform(g.a, g.b, g.c, g.d, g.tx * c, -g.ty * d), f.beginPath();
                        for (var h = 0; h < a._buffer.length; h++) {
                            var i = a._buffer[h].verts,
                                j = i[0];
                            f.moveTo(j.x * c, -j.y * d);
                            for (var k = 1, l = i.length; l > k; k++) f.lineTo(i[k].x * c, -i[k].y * d)
                        }
                        e.restore()
                    }
                } else a._parent = this._node
        }, a._saveCmdCallback = function(a, b, c) {
            var d = a || cc._renderContext,
                e = d.getContext();
            if (this._clipElemType) {
                var f = cc.ClippingNode.CanvasRenderCmd._getSharedCache(),
                    g = e.canvas;
                f.width = g.width, f.height = g.height;
                var h = f.getContext("2d");
                h.drawImage(g, 0, 0)
            } else d.save(), d.save(), d.setTransform(this._worldTransform, b, c)
        }, a._setStencilCompositionOperation = function(a) {
            if (a) {
                var b = this._node;
                if (a._renderCmd && a._renderCmd._setBlendFuncStr && a._renderCmd._setBlendFuncStr(b.inverted ? "destination-out" : "destination-in"), a._children)
                    for (var c = a._children, d = 0, e = c.length; e > d; d++) this._setStencilCompositionOperation(c[d])
            }
        }, a._clipCmdCallback = function(a) {
            var b = this._node,
                c = a || cc._renderContext,
                d = c.getContext();
            if (this._clipElemType) this._setStencilCompositionOperation(b._stencil);
            else {
                if (c.restore(), b.inverted) {
                    var e = d.canvas;
                    c.save(), d.setTransform(1, 0, 0, 1, 0, 0), d.moveTo(0, 0), d.lineTo(0, e.height), d.lineTo(e.width, e.height), d.lineTo(e.width, 0), d.lineTo(0, 0), c.restore()
                }
                d.closePath(), d.clip()
            }
        }, a._restoreCmdCallback = function(a) {
            var b = cc.ClippingNode.CanvasRenderCmd._getSharedCache(),
                c = a || cc._renderContext,
                d = c.getContext();
            this._clipElemType ? (d.save(), d.setTransform(1, 0, 0, 1, 0, 0), d.globalCompositeOperation = "destination-over", d.drawImage(b, 0, 0), d.restore(), this._dirtyFlag = 0) : c.restore()
        }, a.transform = function(a, b) {
            cc.Node.CanvasRenderCmd.prototype.transform.call(this, a, b);
            var c = this._node;
            c._stencil && c._stencil._renderCmd && c._stencil._renderCmd.transform(this, b)
        }, a._cangodhelpme = function(a) {
            return (a === !0 || a === !1) && (cc.ClippingNode.CanvasRenderCmd.prototype._godhelpme = a), cc.ClippingNode.CanvasRenderCmd.prototype._godhelpme
        }, a.visit = function(a) {
            var b = this._node;
            if (b._visible) {
                a = a || this.getParentRenderCmd(), a && (this._curLevel = a._curLevel + 1);
                var c = b._stencil instanceof cc.Sprite ? this : null;
                if (this._clipElemType = this._cangodhelpme() || b._stencil instanceof cc.Sprite, !b._stencil || !b._stencil.visible) return void(this.inverted && cc.Node.CanvasRenderCmd.prototype.visit.call(this, a));
                if (this._syncStatus(a), cc.renderer.pushRenderCommand(this._rendererSaveCmd), this._clipElemType ? cc.Node.CanvasRenderCmd.prototype.visit.call(this, a) : b._stencil.visit(this), cc.renderer.pushRenderCommand(this._rendererClipCmd), this._clipElemType) b._stencil.visit(c);
                else {
                    var d, e = b._children;
                    this._cangodhelpme(!0);
                    var f = e.length;
                    if (f > 0)
                        for (b.sortAllChildren(), d = 0; f > d; d++) e[d]._renderCmd.visit(this);
                    this._cangodhelpme(!1)
                }
                cc.renderer.pushRenderCommand(this._rendererRestoreCmd), this._dirtyFlag = 0
            }
        }, cc.ClippingNode.CanvasRenderCmd._sharedCache = null, cc.ClippingNode.CanvasRenderCmd._getSharedCache = function() {
            return cc.ClippingNode.CanvasRenderCmd._sharedCache || (cc.ClippingNode.CanvasRenderCmd._sharedCache = document.createElement("canvas"))
        }
    }();
! function() {
    cc.ClippingNode.WebGLRenderCmd = function(a) {
        cc.Node.WebGLRenderCmd.call(this, a), this._needDraw = !1, this._beforeVisitCmd = new cc.CustomRenderCmd(this, this._onBeforeVisit), this._afterDrawStencilCmd = new cc.CustomRenderCmd(this, this._onAfterDrawStencil), this._afterVisitCmd = new cc.CustomRenderCmd(this, this._onAfterVisit), this._currentStencilFunc = null, this._currentStencilRef = null, this._currentStencilValueMask = null, this._currentStencilFail = null, this._currentStencilPassDepthFail = null, this._currentStencilPassDepthPass = null, this._currentStencilWriteMask = null, this._currentStencilEnabled = null, this._currentDepthWriteMask = null, this._mask_layer_le = null
    };
    var a = cc.ClippingNode.WebGLRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    a.constructor = cc.ClippingNode.WebGLRenderCmd, cc.ClippingNode.WebGLRenderCmd._init_once = null, cc.ClippingNode.WebGLRenderCmd._visit_once = null, cc.ClippingNode.WebGLRenderCmd._layer = -1, a.initStencilBits = function() {
        cc.ClippingNode.WebGLRenderCmd._init_once = !0, cc.ClippingNode.WebGLRenderCmd._init_once && (cc.stencilBits = cc._renderContext.getParameter(cc._renderContext.STENCIL_BITS), cc.stencilBits <= 0 && cc.log("Stencil buffer is not enabled."), cc.ClippingNode.WebGLRenderCmd._init_once = !1)
    }, a.transform = function(a, b) {
        var c = this._node;
        cc.Node.WebGLRenderCmd.prototype.transform.call(this, a, b), c._stencil && c._stencil._renderCmd.transform(this, b)
    }, a.visit = function(a) {
        var b = this._node;
        if (b._visible) {
            if (b._parent && b._parent._renderCmd && (this._curLevel = b._parent._renderCmd._curLevel + 1), cc.stencilBits < 1) return void cc.Node.WebGLRenderCmd.prototype.visit.call(this, a);
            if (!b._stencil || !b._stencil.visible) return void(b.inverted && cc.Node.WebGLRenderCmd.prototype.visit.call(this, a));
            if (cc.ClippingNode.WebGLRenderCmd._layer + 1 == cc.stencilBits) return cc.ClippingNode.WebGLRenderCmd._visit_once = !0, cc.ClippingNode.WebGLRenderCmd._visit_once && (cc.log("Nesting more than " + cc.stencilBits + "stencils is not supported. Everything will be drawn without stencil for this node and its children."), cc.ClippingNode.WebGLRenderCmd._visit_once = !1), void cc.Node.WebGLRenderCmd.prototype.visit.call(this, a);
            cc.renderer.pushRenderCommand(this._beforeVisitCmd);
            var c = cc.current_stack;
            c.stack.push(c.top), this._syncStatus(a), c.top = this._stackMatrix, b._stencil._renderCmd.visit(this), cc.renderer.pushRenderCommand(this._afterDrawStencilCmd);
            var d = b._children;
            if (d && d.length > 0) {
                var e = d.length;
                b.sortAllChildren();
                for (var f = 0; e > f; f++) d[f]._renderCmd.visit(this)
            }
            cc.renderer.pushRenderCommand(this._afterVisitCmd), this._dirtyFlag = 0, c.top = c.stack.pop()
        }
    }, a.setStencil = function(a) {
        var b = this._node;
        b._stencil && (b._stencil._parent = null), b._stencil = a, b._stencil && (b._stencil._parent = b)
    }, a._drawFullScreenQuadClearStencil = function() {
        cc.kmGLMatrixMode(cc.KM_GL_PROJECTION), cc.kmGLPushMatrix(), cc.kmGLLoadIdentity(), cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW), cc.kmGLPushMatrix(), cc.kmGLLoadIdentity(), cc._drawingUtil.drawSolidRect(cc.p(-1, -1), cc.p(1, 1), cc.color(255, 255, 255, 255)), cc.kmGLMatrixMode(cc.KM_GL_PROJECTION), cc.kmGLPopMatrix(), cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW), cc.kmGLPopMatrix()
    }, a._onBeforeVisit = function(a) {
        var b = a || cc._renderContext,
            c = this._node;
        cc.ClippingNode.WebGLRenderCmd._layer++;
        var d = 1 << cc.ClippingNode.WebGLRenderCmd._layer,
            e = d - 1;
        if (this._mask_layer_le = d | e, this._currentStencilEnabled = b.isEnabled(b.STENCIL_TEST), this._currentStencilWriteMask = b.getParameter(b.STENCIL_WRITEMASK), this._currentStencilFunc = b.getParameter(b.STENCIL_FUNC), this._currentStencilRef = b.getParameter(b.STENCIL_REF), this._currentStencilValueMask = b.getParameter(b.STENCIL_VALUE_MASK), this._currentStencilFail = b.getParameter(b.STENCIL_FAIL), this._currentStencilPassDepthFail = b.getParameter(b.STENCIL_PASS_DEPTH_FAIL), this._currentStencilPassDepthPass = b.getParameter(b.STENCIL_PASS_DEPTH_PASS), b.enable(b.STENCIL_TEST), b.stencilMask(d), this._currentDepthWriteMask = b.getParameter(b.DEPTH_WRITEMASK), b.depthMask(!1), b.stencilFunc(b.NEVER, d, d), b.stencilOp(c.inverted ? b.REPLACE : b.ZERO, b.KEEP, b.KEEP), this._drawFullScreenQuadClearStencil(), b.stencilFunc(b.NEVER, d, d), b.stencilOp(c.inverted ? b.ZERO : b.REPLACE, b.KEEP, b.KEEP), c.alphaThreshold < 1) {
            var f = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST),
                g = b.getUniformLocation(f.getProgram(), cc.UNIFORM_ALPHA_TEST_VALUE_S);
            cc.glUseProgram(f.getProgram()), f.setUniformLocationWith1f(g, c.alphaThreshold), cc.setProgram(c._stencil, f)
        }
    }, a._onAfterDrawStencil = function(a) {
        var b = a || cc._renderContext;
        b.depthMask(this._currentDepthWriteMask), b.stencilFunc(b.EQUAL, this._mask_layer_le, this._mask_layer_le), b.stencilOp(b.KEEP, b.KEEP, b.KEEP)
    }, a._onAfterVisit = function(a) {
        var b = a || cc._renderContext;
        b.stencilFunc(this._currentStencilFunc, this._currentStencilRef, this._currentStencilValueMask), b.stencilOp(this._currentStencilFail, this._currentStencilPassDepthFail, this._currentStencilPassDepthPass), b.stencilMask(this._currentStencilWriteMask), this._currentStencilEnabled || b.disable(b.STENCIL_TEST), cc.ClippingNode.WebGLRenderCmd._layer--
    }
}();
cc.GridBase = cc.Class.extend({
    _active: !1,
    _reuseGrid: 0,
    _gridSize: null,
    _texture: null,
    _step: null,
    _grabber: null,
    _isTextureFlipped: !1,
    _shaderProgram: null,
    _directorProjection: 0,
    _dirty: !1,
    ctor: function(a, b, c) {
        cc._checkWebGLRenderMode(), this._active = !1, this._reuseGrid = 0, this._gridSize = null, this._texture = null, this._step = cc.p(0, 0), this._grabber = null, this._isTextureFlipped = !1, this._shaderProgram = null, this._directorProjection = 0, this._dirty = !1, void 0 !== a && this.initWithSize(a, b, c)
    },
    isActive: function() {
        return this._active
    },
    setActive: function(a) {
        if (this._active = a, !a) {
            var b = cc.director,
                c = b.getProjection();
            b.setProjection(c)
        }
    },
    getReuseGrid: function() {
        return this._reuseGrid
    },
    setReuseGrid: function(a) {
        this._reuseGrid = a
    },
    getGridSize: function() {
        return cc.size(this._gridSize.width, this._gridSize.height)
    },
    setGridSize: function(a) {
        this._gridSize.width = parseInt(a.width), this._gridSize.height = parseInt(a.height)
    },
    getStep: function() {
        return cc.p(this._step.x, this._step.y)
    },
    setStep: function(a) {
        this._step.x = a.x, this._step.y = a.y
    },
    isTextureFlipped: function() {
        return this._isTextureFlipped
    },
    setTextureFlipped: function(a) {
        this._isTextureFlipped != a && (this._isTextureFlipped = a, this.calculateVertexPoints())
    },
    initWithSize: function(a, b, c) {
        if (!b) {
            var d = cc.director,
                e = d.getWinSizeInPixels(),
                f = cc.NextPOT(e.width),
                g = cc.NextPOT(e.height),
                h = new Uint8Array(f * g * 4);
            if (!h) return cc.log("cocos2d: CCGrid: not enough memory."), !1;
            if (b = new cc.Texture2D, b.initWithData(h, cc.Texture2D.PIXEL_FORMAT_RGBA8888, f, g, e), !b) return cc.log("cocos2d: CCGrid: error creating texture"), !1
        }
        return c = c || !1, this._active = !1, this._reuseGrid = 0, this._gridSize = a, this._texture = b, this._isTextureFlipped = c, this._step.x = this._texture.width / a.width, this._step.y = this._texture.height / a.height, this._grabber = new cc.Grabber, this._grabber ? (this._grabber.grab(this._texture), this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE), this.calculateVertexPoints(), !0) : !1
    },
    beforeDraw: function() {
        this._directorProjection = cc.director.getProjection(), this._grabber.beforeRender(this._texture)
    },
    afterDraw: function(a) {
        if (this._grabber.afterRender(this._texture), a && a.getCamera().isDirty()) {
            var b = a.getAnchorPointInPoints(),
                c = a._renderCmd._stackMatrix,
                d = new cc.kmMat4;
            cc.kmMat4Translation(d, b.x, b.y, 0), cc.kmMat4Multiply(c, c, d), a._camera._locateForRenderer(c), cc.kmMat4Translation(d, -b.x, -b.y, 0), cc.kmMat4Multiply(c, c, d)
        }
        cc.glBindTexture2D(this._texture), this.blit(a)
    },
    blit: function() {
        cc.log("cc.GridBase.blit(): Shall be overridden in subclass.")
    },
    reuse: function() {
        cc.log("cc.GridBase.reuse(): Shall be overridden in subclass.")
    },
    calculateVertexPoints: function() {
        cc.log("cc.GridBase.calculateVertexPoints(): Shall be overridden in subclass.")
    },
    set2DProjection: function() {
        var a = cc.director.getWinSizeInPixels(),
            b = cc._renderContext;
        b.viewport(0, 0, a.width, a.height), cc.kmGLMatrixMode(cc.KM_GL_PROJECTION), cc.kmGLLoadIdentity();
        var c = new cc.kmMat4;
        cc.kmMat4OrthographicProjection(c, 0, a.width, 0, a.height, -1, 1), cc.kmGLMultMatrix(c), cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW), cc.kmGLLoadIdentity(), cc.setProjectionMatrixDirty()
    }
}), cc.GridBase.create = function(a, b, c) {
    return new cc.GridBase(a, b, c)
}, cc.Grid3D = cc.GridBase.extend({
    _texCoordinates: null,
    _vertices: null,
    _originalVertices: null,
    _indices: null,
    _texCoordinateBuffer: null,
    _verticesBuffer: null,
    _indicesBuffer: null,
    ctor: function(a, b, c) {
        cc.GridBase.prototype.ctor.call(this), this._texCoordinates = null, this._vertices = null, this._originalVertices = null, this._indices = null, this._texCoordinateBuffer = null, this._verticesBuffer = null, this._indicesBuffer = null, void 0 !== a && this.initWithSize(a, b, c)
    },
    vertex: function(a) {
        (a.x !== (0 | a.x) || a.y !== (0 | a.y)) && cc.log("cc.Grid3D.vertex() : Numbers must be integers");
        var b = 0 | 3 * (a.x * (this._gridSize.height + 1) + a.y),
            c = this._vertices;
        return new cc.Vertex3F(c[b], c[b + 1], c[b + 2])
    },
    originalVertex: function(a) {
        (a.x !== (0 | a.x) || a.y !== (0 | a.y)) && cc.log("cc.Grid3D.originalVertex() : Numbers must be integers");
        var b = 0 | 3 * (a.x * (this._gridSize.height + 1) + a.y),
            c = this._originalVertices;
        return new cc.Vertex3F(c[b], c[b + 1], c[b + 2])
    },
    setVertex: function(a, b) {
        (a.x !== (0 | a.x) || a.y !== (0 | a.y)) && cc.log("cc.Grid3D.setVertex() : Numbers must be integers");
        var c = 0 | 3 * (a.x * (this._gridSize.height + 1) + a.y),
            d = this._vertices;
        d[c] = b.x, d[c + 1] = b.y, d[c + 2] = b.z, this._dirty = !0
    },
    blit: function(a) {
        var b = this._gridSize.width * this._gridSize.height;
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS), this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(a._renderCmd._stackMatrix);
        var c = cc._renderContext,
            d = this._dirty;
        c.bindBuffer(c.ARRAY_BUFFER, this._verticesBuffer), d && c.bufferData(c.ARRAY_BUFFER, this._vertices, c.DYNAMIC_DRAW), c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, c.FLOAT, !1, 0, 0), c.bindBuffer(c.ARRAY_BUFFER, this._texCoordinateBuffer), d && c.bufferData(c.ARRAY_BUFFER, this._texCoordinates, c.DYNAMIC_DRAW), c.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, c.FLOAT, !1, 0, 0), c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, this._indicesBuffer), d && c.bufferData(c.ELEMENT_ARRAY_BUFFER, this._indices, c.STATIC_DRAW), c.drawElements(c.TRIANGLES, 6 * b, c.UNSIGNED_SHORT, 0), d && (this._dirty = !1), cc.incrementGLDraws(1)
    },
    reuse: function() {
        if (this._reuseGrid > 0) {
            for (var a = this._originalVertices, b = this._vertices, c = 0, d = this._vertices.length; d > c; c++) a[c] = b[c];
            --this._reuseGrid
        }
    },
    calculateVertexPoints: function() {
        var a = cc._renderContext,
            b = this._texture.pixelsWidth,
            c = this._texture.pixelsHeight,
            d = this._texture.getContentSizeInPixels().height,
            e = this._gridSize,
            f = (e.width + 1) * (e.height + 1);
        this._vertices = new Float32Array(3 * f), this._texCoordinates = new Float32Array(2 * f), this._indices = new Uint16Array(e.width * e.height * 6), this._verticesBuffer && a.deleteBuffer(this._verticesBuffer), this._verticesBuffer = a.createBuffer(), this._texCoordinateBuffer && a.deleteBuffer(this._texCoordinateBuffer), this._texCoordinateBuffer = a.createBuffer(), this._indicesBuffer && a.deleteBuffer(this._indicesBuffer), this._indicesBuffer = a.createBuffer();
        var g, h, i, j = this._indices,
            k = this._texCoordinates,
            l = this._isTextureFlipped,
            m = this._vertices;
        for (g = 0; g < e.width; ++g)
            for (h = 0; h < e.height; ++h) {
                var n = h * e.width + g,
                    o = g * this._step.x,
                    p = o + this._step.x,
                    q = h * this._step.y,
                    r = q + this._step.y,
                    s = g * (e.height + 1) + h,
                    t = (g + 1) * (e.height + 1) + h,
                    u = (g + 1) * (e.height + 1) + (h + 1),
                    v = g * (e.height + 1) + (h + 1);
                j[6 * n] = s, j[6 * n + 1] = t, j[6 * n + 2] = v, j[6 * n + 3] = t, j[6 * n + 4] = u, j[6 * n + 5] = v;
                var w = [3 * s, 3 * t, 3 * u, 3 * v],
                    x = {
                        x: o,
                        y: q,
                        z: 0
                    },
                    y = {
                        x: p,
                        y: q,
                        z: 0
                    },
                    z = {
                        x: p,
                        y: r,
                        z: 0
                    },
                    A = {
                        x: o,
                        y: r,
                        z: 0
                    },
                    B = [x, y, z, A],
                    C = [2 * s, 2 * t, 2 * u, 2 * v],
                    D = [cc.p(o, q), cc.p(p, q), cc.p(p, r), cc.p(o, r)];
                for (i = 0; 4 > i; ++i) m[w[i]] = B[i].x, m[w[i] + 1] = B[i].y, m[w[i] + 2] = B[i].z, k[C[i]] = D[i].x / b, k[C[i] + 1] = l ? (d - D[i].y) / c : D[i].y / c
            }
        this._originalVertices = new Float32Array(this._vertices), a.bindBuffer(a.ARRAY_BUFFER, this._verticesBuffer), a.bufferData(a.ARRAY_BUFFER, this._vertices, a.DYNAMIC_DRAW), a.bindBuffer(a.ARRAY_BUFFER, this._texCoordinateBuffer), a.bufferData(a.ARRAY_BUFFER, this._texCoordinates, a.DYNAMIC_DRAW), a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._indicesBuffer), a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indices, a.STATIC_DRAW), this._dirty = !0
    }
}), cc.Grid3D.create = function(a, b, c) {
    return new cc.Grid3D(a, b, c)
}, cc.TiledGrid3D = cc.GridBase.extend({
    _texCoordinates: null,
    _vertices: null,
    _originalVertices: null,
    _indices: null,
    _texCoordinateBuffer: null,
    _verticesBuffer: null,
    _indicesBuffer: null,
    ctor: function(a, b, c) {
        cc.GridBase.prototype.ctor.call(this), this._texCoordinates = null, this._vertices = null, this._originalVertices = null, this._indices = null, this._texCoordinateBuffer = null, this._verticesBuffer = null, this._indicesBuffer = null, void 0 !== a && this.initWithSize(a, b, c)
    },
    tile: function(a) {
        (a.x !== (0 | a.x) || a.y !== (0 | a.y)) && cc.log("cc.TiledGrid3D.tile() : Numbers must be integers");
        var b = 4 * (this._gridSize.height * a.x + a.y) * 3,
            c = this._vertices;
        return new cc.Quad3(new cc.Vertex3F(c[b], c[b + 1], c[b + 2]), new cc.Vertex3F(c[b + 3], c[b + 4], c[b + 5]), new cc.Vertex3F(c[b + 6], c[b + 7], c[b + 8]), new cc.Vertex3F(c[b + 9], c[b + 10], c[b + 11]))
    },
    originalTile: function(a) {
        (a.x !== (0 | a.x) || a.y !== (0 | a.y)) && cc.log("cc.TiledGrid3D.originalTile() : Numbers must be integers");
        var b = 4 * (this._gridSize.height * a.x + a.y) * 3,
            c = this._originalVertices;
        return new cc.Quad3(new cc.Vertex3F(c[b], c[b + 1], c[b + 2]), new cc.Vertex3F(c[b + 3], c[b + 4], c[b + 5]), new cc.Vertex3F(c[b + 6], c[b + 7], c[b + 8]), new cc.Vertex3F(c[b + 9], c[b + 10], c[b + 11]))
    },
    setTile: function(a, b) {
        (a.x !== (0 | a.x) || a.y !== (0 | a.y)) && cc.log("cc.TiledGrid3D.setTile() : Numbers must be integers");
        var c = 12 * (this._gridSize.height * a.x + a.y),
            d = this._vertices;
        d[c] = b.bl.x, d[c + 1] = b.bl.y, d[c + 2] = b.bl.z, d[c + 3] = b.br.x, d[c + 4] = b.br.y, d[c + 5] = b.br.z, d[c + 6] = b.tl.x, d[c + 7] = b.tl.y, d[c + 8] = b.tl.z, d[c + 9] = b.tr.x, d[c + 10] = b.tr.y, d[c + 11] = b.tr.z, this._dirty = !0
    },
    blit: function(a) {
        var b = this._gridSize.width * this._gridSize.height;
        this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(a._renderCmd._stackMatrix);
        var c = cc._renderContext,
            d = this._dirty;
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS), c.bindBuffer(c.ARRAY_BUFFER, this._verticesBuffer), d && c.bufferData(c.ARRAY_BUFFER, this._vertices, c.DYNAMIC_DRAW), c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, c.FLOAT, !1, 0, this._vertices), c.bindBuffer(c.ARRAY_BUFFER, this._texCoordinateBuffer), d && c.bufferData(c.ARRAY_BUFFER, this._texCoordinates, c.DYNAMIC_DRAW), c.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, c.FLOAT, !1, 0, this._texCoordinates), c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, this._indicesBuffer), d && c.bufferData(c.ELEMENT_ARRAY_BUFFER, this._indices, c.STATIC_DRAW), c.drawElements(c.TRIANGLES, 6 * b, c.UNSIGNED_SHORT, 0), d && (this._dirty = !1), cc.incrementGLDraws(1)
    },
    reuse: function() {
        if (this._reuseGrid > 0) {
            for (var a = this._vertices, b = this._originalVertices, c = 0; c < a.length; c++) b[c] = a[c];
            --this._reuseGrid
        }
    },
    calculateVertexPoints: function() {
        var a = this._texture.pixelsWidth,
            b = this._texture.pixelsHeight,
            c = this._texture.getContentSizeInPixels().height,
            d = this._gridSize,
            e = d.width * d.height;
        this._vertices = new Float32Array(12 * e), this._texCoordinates = new Float32Array(8 * e), this._indices = new Uint16Array(6 * e);
        var f = cc._renderContext;
        this._verticesBuffer && f.deleteBuffer(this._verticesBuffer), this._verticesBuffer = f.createBuffer(), this._texCoordinateBuffer && f.deleteBuffer(this._texCoordinateBuffer), this._texCoordinateBuffer = f.createBuffer(), this._indicesBuffer && f.deleteBuffer(this._indicesBuffer), this._indicesBuffer = f.createBuffer();
        var g, h, i = 0,
            j = this._step,
            k = this._vertices,
            l = this._texCoordinates,
            m = this._isTextureFlipped;
        for (g = 0; g < d.width; g++)
            for (h = 0; h < d.height; h++) {
                var n = g * j.x,
                    o = n + j.x,
                    p = h * j.y,
                    q = p + j.y;
                k[12 * i] = n, k[12 * i + 1] = p, k[12 * i + 2] = 0, k[12 * i + 3] = o, k[12 * i + 4] = p, k[12 * i + 5] = 0, k[12 * i + 6] = n, k[12 * i + 7] = q, k[12 * i + 8] = 0, k[12 * i + 9] = o, k[12 * i + 10] = q, k[12 * i + 11] = 0;
                var r = p,
                    s = q;
                m && (r = c - p, s = c - q), l[8 * i] = n / a, l[8 * i + 1] = r / b, l[8 * i + 2] = o / a, l[8 * i + 3] = r / b, l[8 * i + 4] = n / a, l[8 * i + 5] = s / b, l[8 * i + 6] = o / a, l[8 * i + 7] = s / b, i++
            }
        var t = this._indices;
        for (g = 0; e > g; g++) t[6 * g + 0] = 4 * g + 0, t[6 * g + 1] = 4 * g + 1, t[6 * g + 2] = 4 * g + 2, t[6 * g + 3] = 4 * g + 1, t[6 * g + 4] = 4 * g + 2, t[6 * g + 5] = 4 * g + 3;
        this._originalVertices = new Float32Array(this._vertices), f.bindBuffer(f.ARRAY_BUFFER, this._verticesBuffer), f.bufferData(f.ARRAY_BUFFER, this._vertices, f.DYNAMIC_DRAW), f.bindBuffer(f.ARRAY_BUFFER, this._texCoordinateBuffer), f.bufferData(f.ARRAY_BUFFER, this._texCoordinates, f.DYNAMIC_DRAW), f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, this._indicesBuffer), f.bufferData(f.ELEMENT_ARRAY_BUFFER, this._indices, f.DYNAMIC_DRAW), this._dirty = !0
    }
}), cc.TiledGrid3D.create = function(a, b, c) {
    return new cc.TiledGrid3D(a, b, c)
}, cc.Grabber = cc.Class.extend({
    _FBO: null,
    _oldFBO: null,
    _oldClearColor: null,
    _gl: null,
    ctor: function() {
        cc._checkWebGLRenderMode(), this._gl = cc._renderContext, this._oldClearColor = [0, 0, 0, 0], this._oldFBO = null, this._FBO = this._gl.createFramebuffer()
    },
    grab: function(a) {
        var b = this._gl;
        this._oldFBO = b.getParameter(b.FRAMEBUFFER_BINDING), b.bindFramebuffer(b.FRAMEBUFFER, this._FBO), b.framebufferTexture2D(b.FRAMEBUFFER, b.COLOR_ATTACHMENT0, b.TEXTURE_2D, a._webTextureObj, 0);
        var c = b.checkFramebufferStatus(b.FRAMEBUFFER);
        c != b.FRAMEBUFFER_COMPLETE && cc.log("Frame Grabber: could not attach texture to frmaebuffer"), b.bindFramebuffer(b.FRAMEBUFFER, this._oldFBO)
    },
    beforeRender: function() {
        var a = this._gl;
        this._oldFBO = a.getParameter(a.FRAMEBUFFER_BINDING), a.bindFramebuffer(a.FRAMEBUFFER, this._FBO), this._oldClearColor = a.getParameter(a.COLOR_CLEAR_VALUE), a.clearColor(0, 0, 0, 0), a.clear(a.COLOR_BUFFER_BIT | a.DEPTH_BUFFER_BIT)
    },
    afterRender: function() {
        var a = this._gl;
        a.bindFramebuffer(a.FRAMEBUFFER, this._oldFBO), a.colorMask(!0, !0, !0, !0)
    },
    destroy: function() {
        this._gl.deleteFramebuffer(this._FBO)
    }
});
cc.GridAction = cc.ActionInterval.extend({
    _gridSize: null,
    ctor: function(a, b) {
        cc._checkWebGLRenderMode(), cc.ActionInterval.prototype.ctor.call(this), this._gridSize = cc.size(0, 0), b && this.initWithDuration(a, b)
    },
    clone: function() {
        var a = new cc.GridAction,
            b = this._gridSize;
        return a.initWithDuration(this._duration, cc.size(b.width, b.height)), a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a), cc.renderer.childrenOrderDirty = !0;
        var b = this.getGrid(),
            c = this.target,
            d = c.grid;
        if (d && d.getReuseGrid() > 0) {
            var e = d.getGridSize();
            d.isActive() && e.width == this._gridSize.width && e.height == this._gridSize.height && d.reuse()
        } else d && d.isActive() && d.setActive(!1), c.grid = b, c.grid.setActive(!0)
    },
    reverse: function() {
        return new cc.ReverseTime(this)
    },
    initWithDuration: function(a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._gridSize.width = b.width, this._gridSize.height = b.height, !0) : !1
    },
    getGrid: function() {
        cc.log("cc.GridAction.getGrid(): it should be overridden in subclass.")
    }
}), cc.gridAction = function(a, b) {
    return new cc.GridAction(a, b)
}, cc.GridAction.create = cc.gridAction, cc.Grid3DAction = cc.GridAction.extend({
    getGrid: function() {
        return new cc.Grid3D(this._gridSize)
    },
    vertex: function(a) {
        return this.target.grid.vertex(a)
    },
    originalVertex: function(a) {
        return this.target.grid.originalVertex(a)
    },
    setVertex: function(a, b) {
        this.target.grid.setVertex(a, b)
    }
}), cc.grid3DAction = function(a, b) {
    return new cc.Grid3DAction(a, b)
}, cc.Grid3DAction.create = cc.grid3DAction, cc.TiledGrid3DAction = cc.GridAction.extend({
    tile: function(a) {
        return this.target.grid.tile(a)
    },
    originalTile: function(a) {
        return this.target.grid.originalTile(a)
    },
    setTile: function(a, b) {
        this.target.grid.setTile(a, b)
    },
    getGrid: function() {
        return new cc.TiledGrid3D(this._gridSize)
    }
}), cc.tiledGrid3DAction = function(a, b) {
    return new cc.TiledGrid3DAction(a, b)
}, cc.TiledGrid3DAction.create = cc.tiledGrid3DAction, cc.StopGrid = cc.ActionInstant.extend({
    startWithTarget: function(a) {
        cc.ActionInstant.prototype.startWithTarget.call(this, a), cc.renderer.childrenOrderDirty = !0;
        var b = this.target.grid;
        b && b.isActive() && b.setActive(!1)
    }
}), cc.stopGrid = function() {
    return new cc.StopGrid
}, cc.StopGrid.create = cc.stopGrid, cc.ReuseGrid = cc.ActionInstant.extend({
    _times: null,
    ctor: function(a) {
        cc.ActionInstant.prototype.ctor.call(this), void 0 !== a && this.initWithTimes(a)
    },
    initWithTimes: function(a) {
        return this._times = a, !0
    },
    startWithTarget: function(a) {
        cc.ActionInstant.prototype.startWithTarget.call(this, a), cc.renderer.childrenOrderDirty = !0, this.target.grid && this.target.grid.isActive() && this.target.grid.setReuseGrid(this.target.grid.getReuseGrid() + this._times)
    }
}), cc.reuseGrid = function(a) {
    return new cc.ReuseGrid(a)
}, cc.ReuseGrid.create = cc.reuseGrid, cc.Waves3D = cc.Grid3DAction.extend({
    _waves: 0,
    _amplitude: 0,
    _amplitudeRate: 0,
    ctor: function(a, b, c, d) {
        cc.GridAction.prototype.ctor.call(this), void 0 !== d && this.initWithDuration(a, b, c, d)
    },
    getAmplitude: function() {
        return this._amplitude
    },
    setAmplitude: function(a) {
        this._amplitude = a
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate
    },
    setAmplitudeRate: function(a) {
        this._amplitudeRate = a
    },
    initWithDuration: function(a, b, c, d) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._waves = c, this._amplitude = d, this._amplitudeRate = 1, !0) : !1
    },
    update: function(a) {
        for (var b = this._gridSize, c = this._amplitude, d = cc.p(0, 0), e = this._amplitudeRate, f = this._waves, g = 0; g < b.width + 1; ++g)
            for (var h = 0; h < b.height + 1; ++h) {
                d.x = g, d.y = h;
                var i = this.originalVertex(d);
                i.z += Math.sin(Math.PI * a * f * 2 + .01 * (i.y + i.x)) * c * e, this.setVertex(d, i)
            }
    }
}), cc.waves3D = function(a, b, c, d) {
    return new cc.Waves3D(a, b, c, d)
}, cc.Waves3D.create = cc.waves3D, cc.FlipX3D = cc.Grid3DAction.extend({
    ctor: function(a) {
        void 0 !== a ? cc.GridAction.prototype.ctor.call(this, a, cc.size(1, 1)) : cc.GridAction.prototype.ctor.call(this)
    },
    initWithDuration: function(a) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, cc.size(1, 1))
    },
    initWithSize: function(a, b) {
        return 1 != a.width || 1 != a.height ? (cc.log("Grid size must be (1,1)"), !1) : cc.Grid3DAction.prototype.initWithDuration.call(this, b, a)
    },
    update: function(a) {
        var b = Math.PI * a,
            c = Math.sin(b);
        b /= 2;
        var d = Math.cos(b),
            e = new cc.Vertex3F,
            f = cc.p(0, 0);
        f.x = f.y = 1;
        var g = this.originalVertex(f);
        f.x = f.y = 0;
        var h, i, j, k, l, m = this.originalVertex(f),
            n = g.x,
            o = m.x;
        n > o ? (i = cc.p(0, 0), j = cc.p(0, 1), k = cc.p(1, 0), l = cc.p(1, 1), h = n) : (k = cc.p(0, 0), l = cc.p(0, 1), i = cc.p(1, 0), j = cc.p(1, 1), h = o), e.x = h - h * d, e.z = Math.abs(parseFloat(h * c / 4));
        var p = this.originalVertex(i);
        p.x = e.x, p.z += e.z, this.setVertex(i, p), p = this.originalVertex(j), p.x = e.x, p.z += e.z, this.setVertex(j, p), p = this.originalVertex(k), p.x -= e.x, p.z -= e.z, this.setVertex(k, p), p = this.originalVertex(l), p.x -= e.x, p.z -= e.z, this.setVertex(l, p)
    }
}), cc.flipX3D = function(a) {
    return new cc.FlipX3D(a)
}, cc.FlipX3D.create = cc.flipX3D, cc.FlipY3D = cc.FlipX3D.extend({
    ctor: function(a) {
        void 0 !== a ? cc.GridAction.prototype.ctor.call(this, a, cc.size(1, 1)) : cc.GridAction.prototype.ctor.call(this)
    },
    update: function(a) {
        var b = Math.PI * a,
            c = Math.sin(b);
        b /= 2;
        var d = Math.cos(b),
            e = new cc.Vertex3F,
            f = cc.p(0, 0);
        f.x = f.y = 1;
        var g = this.originalVertex(f);
        f.x = f.y = 0;
        var h, i, j, k, l, m = this.originalVertex(f),
            n = g.y,
            o = m.y;
        n > o ? (i = cc.p(0, 0), j = cc.p(0, 1), k = cc.p(1, 0), l = cc.p(1, 1), h = n) : (j = cc.p(0, 0), i = cc.p(0, 1), l = cc.p(1, 0), k = cc.p(1, 1), h = o), e.y = h - h * d, e.z = Math.abs(parseFloat(h * c) / 4);
        var p = this.originalVertex(i);
        p.y = e.y, p.z += e.z, this.setVertex(i, p), p = this.originalVertex(j), p.y -= e.y, p.z -= e.z, this.setVertex(j, p), p = this.originalVertex(k), p.y = e.y, p.z += e.z, this.setVertex(k, p), p = this.originalVertex(l), p.y -= e.y, p.z -= e.z, this.setVertex(l, p)
    }
}), cc.flipY3D = function(a) {
    return new cc.FlipY3D(a)
}, cc.FlipY3D.create = cc.flipY3D, cc.Lens3D = cc.Grid3DAction.extend({
    _position: null,
    _radius: 0,
    _lensEffect: 0,
    _concave: !1,
    _dirty: !1,
    ctor: function(a, b, c, d) {
        cc.GridAction.prototype.ctor.call(this), this._position = cc.p(0, 0), void 0 !== d && this.initWithDuration(a, b, c, d)
    },
    getLensEffect: function() {
        return this._lensEffect
    },
    setLensEffect: function(a) {
        this._lensEffect = a
    },
    setConcave: function(a) {
        this._concave = a
    },
    getPosition: function() {
        return this._position
    },
    setPosition: function(a) {
        cc.pointEqualToPoint(a, this._position) || (this._position.x = a.x, this._position.y = a.y, this._dirty = !0)
    },
    initWithDuration: function(a, b, c, d) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, b) ? (this.setPosition(c), this._radius = d, this._lensEffect = .7, this._dirty = !0, !0) : !1
    },
    update: function() {
        if (this._dirty) {
            for (var a, b, c, d, e, f = this._gridSize.width, g = this._gridSize.height, h = this._radius, i = this._lensEffect, j = cc.p(0, 0), k = cc.p(0, 0), l = 0; f + 1 > l; ++l)
                for (var m = 0; g + 1 > m; ++m) j.x = l, j.y = m, a = this.originalVertex(j), k.x = this._position.x - a.x, k.y = this._position.y - a.y, b = cc.pLength(k), h > b && (b = h - b, e = b / h, 0 == e && (e = .001), c = Math.log(e) * i, d = Math.exp(c) * h, b = cc.pLength(k), b > 0 && (k.x = k.x / b, k.y = k.y / b, k.x = k.x * d, k.y = k.y * d, a.z += cc.pLength(k) * i)), this.setVertex(j, a);
            this._dirty = !1
        }
    }
}), cc.lens3D = function(a, b, c, d) {
    return new cc.Lens3D(a, b, c, d)
}, cc.Lens3D.create = cc.lens3D, cc.Ripple3D = cc.Grid3DAction.extend({
    _position: null,
    _radius: 0,
    _waves: 0,
    _amplitude: 0,
    _amplitudeRate: 0,
    ctor: function(a, b, c, d, e, f) {
        cc.GridAction.prototype.ctor.call(this), this._position = cc.p(0, 0), void 0 !== f && this.initWithDuration(a, b, c, d, e, f)
    },
    getPosition: function() {
        return this._position
    },
    setPosition: function(a) {
        this._position.x = a.x, this._position.y = a.y
    },
    getAmplitude: function() {
        return this._amplitude
    },
    setAmplitude: function(a) {
        this._amplitude = a
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate
    },
    setAmplitudeRate: function(a) {
        this._amplitudeRate = a
    },
    initWithDuration: function(a, b, c, d, e, f) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, b) ? (this.setPosition(c), this._radius = d, this._waves = e, this._amplitude = f, this._amplitudeRate = 1, !0) : !1
    },
    update: function(a) {
        for (var b, c, d = this._gridSize.width, e = this._gridSize.height, f = cc.p(0, 0), g = this._radius, h = this._waves, i = this._amplitude, j = this._amplitudeRate, k = cc.p(0, 0), l = 0; d + 1 > l; ++l)
            for (var m = 0; e + 1 > m; ++m) {
                if (f.x = l, f.y = m, b = this.originalVertex(f), k.x = this._position.x - b.x, k.y = this._position.y - b.y, c = cc.pLength(k), g > c) {
                    c = g - c;
                    var n = Math.pow(c / g, 2);
                    b.z += Math.sin(a * Math.PI * h * 2 + .1 * c) * i * j * n
                }
                this.setVertex(f, b)
            }
    }
}), cc.ripple3D = function(a, b, c, d, e, f) {
    return new cc.Ripple3D(a, b, c, d, e, f)
}, cc.Ripple3D.create = cc.ripple3D, cc.Shaky3D = cc.Grid3DAction.extend({
    _randRange: 0,
    _shakeZ: !1,
    ctor: function(a, b, c, d) {
        cc.GridAction.prototype.ctor.call(this), void 0 !== d && this.initWithDuration(a, b, c, d)
    },
    initWithDuration: function(a, b, c, d) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._randRange = c, this._shakeZ = d, !0) : !1
    },
    update: function() {
        for (var a, b = this._gridSize.width, c = this._gridSize.height, d = this._randRange, e = this._shakeZ, f = cc.p(0, 0), g = 0; b + 1 > g; ++g)
            for (var h = 0; c + 1 > h; ++h) f.x = g, f.y = h, a = this.originalVertex(f), a.x += cc.rand() % (2 * d) - d, a.y += cc.rand() % (2 * d) - d, e && (a.z += cc.rand() % (2 * d) - d), this.setVertex(f, a)
    }
}), cc.shaky3D = function(a, b, c, d) {
    return new cc.Shaky3D(a, b, c, d)
}, cc.Shaky3D.create = cc.shaky3D, cc.Liquid = cc.Grid3DAction.extend({
    _waves: 0,
    _amplitude: 0,
    _amplitudeRate: 0,
    ctor: function(a, b, c, d) {
        cc.GridAction.prototype.ctor.call(this), void 0 !== d && this.initWithDuration(a, b, c, d)
    },
    getAmplitude: function() {
        return this._amplitude
    },
    setAmplitude: function(a) {
        this._amplitude = a
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate
    },
    setAmplitudeRate: function(a) {
        this._amplitudeRate = a
    },
    initWithDuration: function(a, b, c, d) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._waves = c, this._amplitude = d, this._amplitudeRate = 1, !0) : !1
    },
    update: function(a) {
        for (var b, c = this._gridSize.width, d = this._gridSize.height, e = cc.p(0, 0), f = this._waves, g = this._amplitude, h = this._amplitudeRate, i = 1; c > i; ++i)
            for (var j = 1; d > j; ++j) e.x = i, e.y = j, b = this.originalVertex(e), b.x = b.x + Math.sin(a * Math.PI * f * 2 + .01 * b.x) * g * h, b.y = b.y + Math.sin(a * Math.PI * f * 2 + .01 * b.y) * g * h, this.setVertex(e, b)
    }
}), cc.liquid = function(a, b, c, d) {
    return new cc.Liquid(a, b, c, d)
}, cc.Liquid.create = cc.liquid, cc.Waves = cc.Grid3DAction.extend({
    _waves: 0,
    _amplitude: 0,
    _amplitudeRate: 0,
    _vertical: !1,
    _horizontal: !1,
    ctor: function(a, b, c, d, e, f) {
        cc.GridAction.prototype.ctor.call(this), void 0 !== f && this.initWithDuration(a, b, c, d, e, f)
    },
    getAmplitude: function() {
        return this._amplitude
    },
    setAmplitude: function(a) {
        this._amplitude = a
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate
    },
    setAmplitudeRate: function(a) {
        this._amplitudeRate = a
    },
    initWithDuration: function(a, b, c, d, e, f) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._waves = c, this._amplitude = d, this._amplitudeRate = 1, this._horizontal = e, this._vertical = f, !0) : !1
    },
    update: function(a) {
        for (var b, c = this._gridSize.width, d = this._gridSize.height, e = cc.p(0, 0), f = this._vertical, g = this._horizontal, h = this._waves, i = this._amplitude, j = this._amplitudeRate, k = 0; c + 1 > k; ++k)
            for (var l = 0; d + 1 > l; ++l) e.x = k, e.y = l, b = this.originalVertex(e), f && (b.x = b.x + Math.sin(a * Math.PI * h * 2 + .01 * b.y) * i * j), g && (b.y = b.y + Math.sin(a * Math.PI * h * 2 + .01 * b.x) * i * j), this.setVertex(e, b)
    }
}), cc.waves = function(a, b, c, d, e, f) {
    return new cc.Waves(a, b, c, d, e, f)
}, cc.Waves.create = cc.waves, cc.Twirl = cc.Grid3DAction.extend({
    _position: null,
    _twirls: 0,
    _amplitude: 0,
    _amplitudeRate: 0,
    ctor: function(a, b, c, d, e) {
        cc.GridAction.prototype.ctor.call(this), this._position = cc.p(0, 0), void 0 !== e && this.initWithDuration(a, b, c, d, e)
    },
    getPosition: function() {
        return this._position
    },
    setPosition: function(a) {
        this._position.x = a.x, this._position.y = a.y
    },
    getAmplitude: function() {
        return this._amplitude
    },
    setAmplitude: function(a) {
        this._amplitude = a
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate
    },
    setAmplitudeRate: function(a) {
        this._amplitudeRate = a
    },
    initWithDuration: function(a, b, c, d, e) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, b) ? (this.setPosition(c), this._twirls = d, this._amplitude = e, this._amplitudeRate = 1, !0) : !1
    },
    update: function(a) {
        for (var b, c, d, e, f = this._position, g = this._gridSize.width, h = this._gridSize.height, i = cc.p(0, 0), j = .1 * this._amplitude * this._amplitudeRate, k = this._twirls, l = cc.p(0, 0), m = 0; g + 1 > m; ++m)
            for (var n = 0; h + 1 > n; ++n) i.x = m, i.y = n, b = this.originalVertex(i), l.x = m - g / 2, l.y = n - h / 2, c = cc.pLength(l) * Math.cos(Math.PI / 2 + a * Math.PI * k * 2) * j, d = Math.sin(c) * (b.y - f.y) + Math.cos(c) * (b.x - f.x), e = Math.cos(c) * (b.y - f.y) - Math.sin(c) * (b.x - f.x), b.x = f.x + d, b.y = f.y + e, this.setVertex(i, b)
    }
}), cc.twirl = function(a, b, c, d, e) {
    return new cc.Twirl(a, b, c, d, e)
}, cc.Twirl.create = cc.twirl, cc.ShakyTiles3D = cc.TiledGrid3DAction.extend({
    _randRange: 0,
    _shakeZ: !1,
    ctor: function(a, b, c, d) {
        cc.GridAction.prototype.ctor.call(this), void 0 !== d && this.initWithDuration(a, b, c, d)
    },
    initWithDuration: function(a, b, c, d) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._randRange = c, this._shakeZ = d, !0) : !1
    },
    update: function() {
        for (var a = this._gridSize, b = this._randRange, c = cc.p(0, 0), d = 0; d < a.width; ++d)
            for (var e = 0; e < a.height; ++e) {
                c.x = d, c.y = e;
                var f = this.originalTile(c);
                f.bl.x += cc.rand() % (2 * b) - b, f.br.x += cc.rand() % (2 * b) - b, f.tl.x += cc.rand() % (2 * b) - b, f.tr.x += cc.rand() % (2 * b) - b, f.bl.y += cc.rand() % (2 * b) - b, f.br.y += cc.rand() % (2 * b) - b, f.tl.y += cc.rand() % (2 * b) - b, f.tr.y += cc.rand() % (2 * b) - b, this._shakeZ && (f.bl.z += cc.rand() % (2 * b) - b, f.br.z += cc.rand() % (2 * b) - b, f.tl.z += cc.rand() % (2 * b) - b, f.tr.z += cc.rand() % (2 * b) - b), this.setTile(c, f)
            }
    }
}), cc.shakyTiles3D = function(a, b, c, d) {
    return new cc.ShakyTiles3D(a, b, c, d)
}, cc.ShakyTiles3D.create = cc.shakyTiles3D, cc.ShatteredTiles3D = cc.TiledGrid3DAction.extend({
    _randRange: 0,
    _once: !1,
    _shatterZ: !1,
    ctor: function(a, b, c, d) {
        cc.GridAction.prototype.ctor.call(this), void 0 !== d && this.initWithDuration(a, b, c, d)
    },
    initWithDuration: function(a, b, c, d) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._once = !1, this._randRange = c, this._shatterZ = d, !0) : !1
    },
    update: function() {
        if (this._once === !1) {
            for (var a, b = this._gridSize, c = this._randRange, d = cc.p(0, 0), e = 0; e < b.width; ++e)
                for (var f = 0; f < b.height; ++f) d.x = e, d.y = f, a = this.originalTile(d), a.bl.x += cc.rand() % (2 * c) - c, a.br.x += cc.rand() % (2 * c) - c, a.tl.x += cc.rand() % (2 * c) - c, a.tr.x += cc.rand() % (2 * c) - c, a.bl.y += cc.rand() % (2 * c) - c, a.br.y += cc.rand() % (2 * c) - c, a.tl.y += cc.rand() % (2 * c) - c, a.tr.y += cc.rand() % (2 * c) - c, this._shatterZ && (a.bl.z += cc.rand() % (2 * c) - c, a.br.z += cc.rand() % (2 * c) - c, a.tl.z += cc.rand() % (2 * c) - c, a.tr.z += cc.rand() % (2 * c) - c), this.setTile(d, a);
            this._once = !0
        }
    }
}), cc.shatteredTiles3D = function(a, b, c, d) {
    return new cc.ShatteredTiles3D(a, b, c, d)
}, cc.ShatteredTiles3D.create = cc.shatteredTiles3D, cc.Tile = function(a, b, c) {
    this.position = a || cc.p(0, 0), this.startPosition = b || cc.p(0, 0), this.delta = c || cc.p(0, 0)
}, cc.ShuffleTiles = cc.TiledGrid3DAction.extend({
    _seed: 0,
    _tilesCount: 0,
    _tilesOrder: null,
    _tiles: null,
    ctor: function(a, b, c) {
        cc.GridAction.prototype.ctor.call(this), this._tilesOrder = [], this._tiles = [], void 0 !== c && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._seed = c, this._tilesOrder.length = 0, this._tiles.length = 0, !0) : !1
    },
    shuffle: function(a, b) {
        for (var c = b - 1; c >= 0; c--) {
            var d = 0 | cc.rand() % (c + 1),
                e = a[c];
            a[c] = a[d], a[d] = e
        }
    },
    getDelta: function(a) {
        var b = this._gridSize,
            c = a.width * b.height + a.height;
        return cc.size(this._tilesOrder[c] / b.height - a.width, this._tilesOrder[c] % b.height - a.height)
    },
    placeTile: function(a, b) {
        var c = this.originalTile(a),
            d = this.target.grid.getStep(),
            e = b.position;
        c.bl.x += e.x * d.x, c.bl.y += e.y * d.y, c.br.x += e.x * d.x, c.br.y += e.y * d.y, c.tl.x += e.x * d.x, c.tl.y += e.y * d.y, c.tr.x += e.x * d.x, c.tr.y += e.y * d.y, this.setTile(a, c)
    },
    startWithTarget: function(a) {
        cc.TiledGrid3DAction.prototype.startWithTarget.call(this, a);
        var b = this._gridSize;
        this._tilesCount = b.width * b.height;
        var c = this._tilesOrder;
        c.length = 0;
        for (var d = 0; d < this._tilesCount; ++d) c[d] = d;
        this.shuffle(c, this._tilesCount);
        var e = this._tiles;
        e.length = 0;
        for (var f = 0, g = cc.size(0, 0), h = 0; h < b.width; ++h)
            for (var i = 0; i < b.height; ++i) e[f] = new cc.Tile, e[f].position = cc.p(h, i), e[f].startPosition = cc.p(h, i), g.width = h, g.height = i, e[f].delta = this.getDelta(g), ++f
    },
    update: function(a) {
        for (var b, c = 0, d = this._gridSize, e = this._tiles, f = cc.p(0, 0), g = 0; g < d.width; ++g)
            for (var h = 0; h < d.height; ++h) f.x = g, f.y = h, b = e[c], b.position.x = b.delta.width * a, b.position.y = b.delta.height * a, this.placeTile(f, b), ++c
    }
}), cc.shuffleTiles = function(a, b, c) {
    return new cc.ShuffleTiles(a, b, c)
}, cc.ShuffleTiles.create = cc.shuffleTiles, cc.FadeOutTRTiles = cc.TiledGrid3DAction.extend({
    testFunc: function(a, b) {
        var c = this._gridSize.width * b,
            d = this._gridSize.height * b;
        return c + d == 0 ? 1 : Math.pow((a.width + a.height) / (c + d), 6)
    },
    turnOnTile: function(a) {
        this.setTile(a, this.originalTile(a))
    },
    turnOffTile: function(a) {
        this.setTile(a, new cc.Quad3)
    },
    transformTile: function(a, b) {
        var c = this.originalTile(a),
            d = this.target.grid.getStep();
        c.bl.x += d.x / 2 * (1 - b), c.bl.y += d.y / 2 * (1 - b), c.br.x -= d.x / 2 * (1 - b), c.br.y += d.y / 2 * (1 - b), c.tl.x += d.x / 2 * (1 - b), c.tl.y -= d.y / 2 * (1 - b), c.tr.x -= d.x / 2 * (1 - b), c.tr.y -= d.y / 2 * (1 - b), this.setTile(a, c)
    },
    update: function(a) {
        for (var b, c = this._gridSize, d = cc.p(0, 0), e = cc.size(0, 0), f = 0; f < c.width; ++f)
            for (var g = 0; g < c.height; ++g) d.x = f, d.y = g, e.width = f, e.height = g, b = this.testFunc(e, a), 0 == b ? this.turnOffTile(d) : 1 > b ? this.transformTile(d, b) : this.turnOnTile(d)
    }
}), cc.fadeOutTRTiles = function(a, b) {
    return new cc.FadeOutTRTiles(a, b)
}, cc.FadeOutTRTiles.create = cc.fadeOutTRTiles, cc.FadeOutBLTiles = cc.FadeOutTRTiles.extend({
    testFunc: function(a, b) {
        var c = this._gridSize.width * (1 - b),
            d = this._gridSize.height * (1 - b);
        return a.width + a.height == 0 ? 1 : Math.pow((c + d) / (a.width + a.height), 6)
    }
}), cc.fadeOutBLTiles = function(a, b) {
    return new cc.FadeOutBLTiles(a, b)
}, cc.FadeOutBLTiles.create = cc.fadeOutBLTiles, cc.FadeOutUpTiles = cc.FadeOutTRTiles.extend({
    testFunc: function(a, b) {
        var c = this._gridSize.height * b;
        return 0 == c ? 1 : Math.pow(a.height / c, 6)
    },
    transformTile: function(a, b) {
        var c = this.originalTile(a),
            d = this.target.grid.getStep();
        c.bl.y += d.y / 2 * (1 - b), c.br.y += d.y / 2 * (1 - b), c.tl.y -= d.y / 2 * (1 - b), c.tr.y -= d.y / 2 * (1 - b), this.setTile(a, c)
    }
}), cc.fadeOutUpTiles = function(a, b) {
    return new cc.FadeOutUpTiles(a, b)
}, cc.FadeOutUpTiles.create = cc.fadeOutUpTiles, cc.FadeOutDownTiles = cc.FadeOutUpTiles.extend({
    testFunc: function(a, b) {
        var c = this._gridSize.height * (1 - b);
        return 0 == a.height ? 1 : Math.pow(c / a.height, 6)
    }
}), cc.fadeOutDownTiles = function(a, b) {
    return new cc.FadeOutDownTiles(a, b)
}, cc.FadeOutDownTiles.create = cc.fadeOutDownTiles, cc.TurnOffTiles = cc.TiledGrid3DAction.extend({
    _seed: null,
    _tilesCount: 0,
    _tilesOrder: null,
    ctor: function(a, b, c) {
        cc.GridAction.prototype.ctor.call(this), this._tilesOrder = [], void 0 !== b && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._seed = c || 0, this._tilesOrder.length = 0, !0) : !1
    },
    shuffle: function(a, b) {
        for (var c = b - 1; c >= 0; c--) {
            var d = 0 | cc.rand() % (c + 1),
                e = a[c];
            a[c] = a[d], a[d] = e
        }
    },
    turnOnTile: function(a) {
        this.setTile(a, this.originalTile(a))
    },
    turnOffTile: function(a) {
        this.setTile(a, new cc.Quad3)
    },
    startWithTarget: function(a) {
        cc.TiledGrid3DAction.prototype.startWithTarget.call(this, a), this._tilesCount = this._gridSize.width * this._gridSize.height;
        var b = this._tilesOrder;
        b.length = 0;
        for (var c = 0; c < this._tilesCount; ++c) b[c] = c;
        this.shuffle(b, this._tilesCount)
    },
    update: function(a) {
        for (var b, c = 0 | a * this._tilesCount, d = this._gridSize, e = cc.p(0, 0), f = this._tilesOrder, g = 0; g < this._tilesCount; g++) b = f[g], e.x = 0 | b / d.height, e.y = b % (0 | d.height), c > g ? this.turnOffTile(e) : this.turnOnTile(e)
    }
}), cc.turnOffTiles = function(a, b, c) {
    return new cc.TurnOffTiles(a, b, c)
}, cc.TurnOffTiles.create = cc.turnOffTiles, cc.WavesTiles3D = cc.TiledGrid3DAction.extend({
    _waves: 0,
    _amplitude: 0,
    _amplitudeRate: 0,
    ctor: function(a, b, c, d) {
        cc.GridAction.prototype.ctor.call(this), void 0 !== d && this.initWithDuration(a, b, c, d)
    },
    getAmplitude: function() {
        return this._amplitude
    },
    setAmplitude: function(a) {
        this._amplitude = a
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate
    },
    setAmplitudeRate: function(a) {
        this._amplitudeRate = a
    },
    initWithDuration: function(a, b, c, d) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._waves = c, this._amplitude = d, this._amplitudeRate = 1, !0) : !1
    },
    update: function(a) {
        for (var b, c = this._gridSize, d = this._waves, e = this._amplitude, f = this._amplitudeRate, g = cc.p(0, 0), h = 0; h < c.width; h++)
            for (var i = 0; i < c.height; i++) g.x = h, g.y = i, b = this.originalTile(g), b.bl.z = Math.sin(a * Math.PI * d * 2 + .01 * (b.bl.y + b.bl.x)) * e * f, b.br.z = b.bl.z, b.tl.z = b.bl.z, b.tr.z = b.bl.z, this.setTile(g, b)
    }
}), cc.wavesTiles3D = function(a, b, c, d) {
    return new cc.WavesTiles3D(a, b, c, d)
}, cc.WavesTiles3D.create = cc.wavesTiles3D, cc.JumpTiles3D = cc.TiledGrid3DAction.extend({
    _jumps: 0,
    _amplitude: 0,
    _amplitudeRate: 0,
    ctor: function(a, b, c, d) {
        cc.GridAction.prototype.ctor.call(this), void 0 !== d && this.initWithDuration(a, b, c, d)
    },
    getAmplitude: function() {
        return this._amplitude
    },
    setAmplitude: function(a) {
        this._amplitude = a
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate
    },
    setAmplitudeRate: function(a) {
        this._amplitudeRate = a
    },
    initWithDuration: function(a, b, c, d) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._jumps = c, this._amplitude = d, this._amplitudeRate = 1, !0) : !1
    },
    update: function(a) {
        for (var b, c = Math.sin(Math.PI * a * this._jumps * 2) * this._amplitude * this._amplitudeRate, d = Math.sin(Math.PI * (a * this._jumps * 2 + 1)) * this._amplitude * this._amplitudeRate, e = this._gridSize, f = this.target.grid, g = cc.p(0, 0), h = 0; h < e.width; h++)
            for (var i = 0; i < e.height; i++) g.x = h, g.y = i, b = f.originalTile(g), (h + i) % 2 == 0 ? (b.bl.z += c, b.br.z += c, b.tl.z += c, b.tr.z += c) : (b.bl.z += d, b.br.z += d, b.tl.z += d, b.tr.z += d), f.setTile(g, b)
    }
}), cc.jumpTiles3D = function(a, b, c, d) {
    return new cc.JumpTiles3D(a, b, c, d)
}, cc.JumpTiles3D.create = cc.jumpTiles3D, cc.SplitRows = cc.TiledGrid3DAction.extend({
    _rows: 0,
    _winSize: null,
    ctor: function(a, b) {
        cc.GridAction.prototype.ctor.call(this), void 0 !== b && this.initWithDuration(a, b)
    },
    initWithDuration: function(a, b) {
        return this._rows = b, cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, cc.size(1, b))
    },
    update: function(a) {
        for (var b, c, d = this._gridSize, e = this._winSize.width, f = cc.p(0, 0), g = 0; g < d.height; ++g) f.y = g, b = this.originalTile(f), c = 1, g % 2 == 0 && (c = -1), b.bl.x += c * e * a, b.br.x += c * e * a, b.tl.x += c * e * a, b.tr.x += c * e * a, this.setTile(f, b)
    },
    startWithTarget: function(a) {
        cc.TiledGrid3DAction.prototype.startWithTarget.call(this, a), this._winSize = cc.director.getWinSizeInPixels()
    }
}), cc.splitRows = function(a, b) {
    return new cc.SplitRows(a, b)
}, cc.SplitRows.create = cc.splitRows, cc.SplitCols = cc.TiledGrid3DAction.extend({
    _cols: 0,
    _winSize: null,
    ctor: function(a, b) {
        cc.GridAction.prototype.ctor.call(this), void 0 !== b && this.initWithDuration(a, b)
    },
    initWithDuration: function(a, b) {
        return this._cols = b, cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, cc.size(b, 1))
    },
    update: function(a) {
        for (var b, c, d = this._gridSize.width, e = this._winSize.height, f = cc.p(0, 0), g = 0; d > g; ++g) f.x = g, b = this.originalTile(f), c = 1, g % 2 == 0 && (c = -1), b.bl.y += c * e * a, b.br.y += c * e * a, b.tl.y += c * e * a, b.tr.y += c * e * a, this.setTile(f, b);
        cc.renderer.childrenOrderDirty = !0
    },
    startWithTarget: function(a) {
        cc.TiledGrid3DAction.prototype.startWithTarget.call(this, a), this._winSize = cc.director.getWinSizeInPixels()
    }
}), cc.splitCols = function(a, b) {
    return new cc.SplitCols(a, b)
}, cc.SplitCols.create = cc.splitCols, cc.PageTurn3D = cc.Grid3DAction.extend({
    update: function(a) {
        for (var b = Math.max(0, a - .25), c = b * b * 500, d = -100 - c, e = -Math.PI / 2 * Math.sqrt(a), f = +Math.PI / 2 + e, g = Math.sin(f), h = Math.cos(f), i = this._gridSize, j = cc.p(0, 0), k = 0; k <= i.width; ++k)
            for (var l = 0; l <= i.height; ++l) {
                j.x = k, j.y = l;
                var m = this.originalVertex(j),
                    n = Math.sqrt(m.x * m.x + (m.y - d) * (m.y - d)),
                    o = n * g,
                    p = Math.asin(m.x / n),
                    q = p / g,
                    r = Math.cos(q);
                m.x = q <= Math.PI ? o * Math.sin(q) : 0, m.y = n + d - o * (1 - r) * g, m.z = o * (1 - r) * h / 7, m.z < .5 && (m.z = .5), this.setVertex(j, m)
            }
    }
}), cc.pageTurn3D = function(a, b) {
    return new cc.PageTurn3D(a, b)
}, cc.PageTurn3D.create = cc.pageTurn3D;
cc.ProgressTimer = cc.Node.extend({
    _type: null,
    _percentage: 0,
    _sprite: null,
    _midPoint: null,
    _barChangeRate: null,
    _reverseDirection: !1,
    _className: "ProgressTimer",
    ctor: function(a) {
        cc.Node.prototype.ctor.call(this), this._type = cc.ProgressTimer.TYPE_RADIAL, this._percentage = 0, this._midPoint = cc.p(0, 0), this._barChangeRate = cc.p(0, 0), this._reverseDirection = !1, this._sprite = null, a && this.initWithSprite(a)
    },
    getMidpoint: function() {
        return cc.p(this._midPoint.x, this._midPoint.y)
    },
    setMidpoint: function(a) {
        this._midPoint = cc.pClamp(a, cc.p(0, 0), cc.p(1, 1))
    },
    getBarChangeRate: function() {
        return cc.p(this._barChangeRate.x, this._barChangeRate.y)
    },
    setBarChangeRate: function(a) {
        this._barChangeRate = cc.pClamp(a, cc.p(0, 0), cc.p(1, 1))
    },
    getType: function() {
        return this._type
    },
    getPercentage: function() {
        return this._percentage
    },
    getSprite: function() {
        return this._sprite
    },
    setPercentage: function(a) {
        this._percentage != a && (this._percentage = cc.clampf(a, 0, 100), this._renderCmd._updateProgress())
    },
    setOpacityModifyRGB: function() {},
    isOpacityModifyRGB: function() {
        return !1
    },
    isReverseDirection: function() {
        return this._reverseDirection
    },
    setColor: function(a) {
        this._sprite.color = a, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty)
    },
    setOpacity: function(a) {
        this._sprite.opacity = a, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
    },
    getColor: function() {
        return this._sprite.color
    },
    getOpacity: function() {
        return this._sprite.opacity
    },
    setReverseProgress: function(a) {
        this._reverseDirection !== a && (this._reverseDirection = a, this._renderCmd.releaseData())
    },
    setSprite: function(a) {
        this._sprite != a && (this._sprite = a, a ? this.setContentSize(a.width, a.height) : this.setContentSize(0, 0), this._renderCmd.releaseData())
    },
    setType: function(a) {
        a !== this._type && (this._type = a, this._renderCmd.releaseData())
    },
    setReverseDirection: function(a) {
        this._reverseDirection !== a && (this._reverseDirection = a, this._renderCmd.releaseData())
    },
    initWithSprite: function(a) {
        return this.percentage = 0, this.setAnchorPoint(.5, .5), this._type = cc.ProgressTimer.TYPE_RADIAL, this._reverseDirection = !1, this.midPoint = cc.p(.5, .5), this.barChangeRate = cc.p(1, 1), this.setSprite(a), this._renderCmd.initCmd(), !0
    },
    _createRenderCmd: function() {
        return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.ProgressTimer.CanvasRenderCmd(this) : new cc.ProgressTimer.WebGLRenderCmd(this)
    }
});
var _p = cc.ProgressTimer.prototype;
_p.midPoint, cc.defineGetterSetter(_p, "midPoint", _p.getMidpoint, _p.setMidpoint), _p.barChangeRate, cc.defineGetterSetter(_p, "barChangeRate", _p.getBarChangeRate, _p.setBarChangeRate), _p.type, cc.defineGetterSetter(_p, "type", _p.getType, _p.setType), _p.percentage, cc.defineGetterSetter(_p, "percentage", _p.getPercentage, _p.setPercentage), _p.sprite, cc.defineGetterSetter(_p, "sprite", _p.getSprite, _p.setSprite), _p.reverseDir, cc.defineGetterSetter(_p, "reverseDir", _p.isReverseDirection, _p.setReverseDirection), cc.ProgressTimer.create = function(a) {
        return new cc.ProgressTimer(a)
    }, cc.ProgressTimer.TEXTURE_COORDS_COUNT = 4, cc.ProgressTimer.TEXTURE_COORDS = 75, cc.ProgressTimer.TYPE_RADIAL = 0, cc.ProgressTimer.TYPE_BAR = 1,
    function() {
        cc.ProgressTimer.CanvasRenderCmd = function(a) {
            cc.Node.CanvasRenderCmd.call(this, a), this._needDraw = !0, this._PI180 = Math.PI / 180, this._barRect = cc.rect(0, 0, 0, 0), this._origin = cc.p(0, 0), this._radius = 0, this._startAngle = 270, this._endAngle = 270, this._counterClockWise = !1
        };
        var a = cc.ProgressTimer.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
        a.constructor = cc.ProgressTimer.CanvasRenderCmd, a.rendering = function(a, b, c) {
            var d = a || cc._renderContext,
                e = d.getContext(),
                f = this._node,
                g = f._sprite,
                h = g._renderCmd._textureCoord,
                i = g._renderCmd._displayedOpacity / 255;
            if (0 !== h.width && 0 !== h.height && g._texture && h.validRect && 0 !== i) {
                d.setTransform(this._worldTransform, b, c), d.setCompositeOperation(g._blendFuncStr), d.setGlobalAlpha(i);
                var j = g._rect,
                    k = g._offsetPosition,
                    l = k.x,
                    m = -k.y - j.height,
                    n = j.width,
                    o = j.height;
                if (d.save(), g._flippedX && (l = -l - n, e.scale(-1, 1)), g._flippedY && (m = k.y, e.scale(1, -1)), f._type == cc.ProgressTimer.TYPE_BAR) {
                    var p = this._barRect;
                    e.beginPath(), e.rect(p.x * b, p.y * c, p.width * b, p.height * c), e.clip(), e.closePath()
                } else if (f._type == cc.ProgressTimer.TYPE_RADIAL) {
                    var q = this._origin.x * b,
                        r = this._origin.y * c;
                    e.beginPath(), e.arc(q, r, this._radius * c, this._PI180 * this._startAngle, this._PI180 * this._endAngle, this._counterClockWise), e.lineTo(q, r), e.clip(), e.closePath()
                }
                var s = g._texture.getHtmlElementObj();
                g._colorized ? e.drawImage(s, 0, 0, h.width, h.height, l * b, m * c, n * b, o * c) : e.drawImage(s, h.renderX, h.renderY, h.width, h.height, l * b, m * c, n * b, o * c), d.restore(), cc.g_NumberOfDraws++
            }
        }, a.releaseData = function() {}, a.initCmd = function() {}, a._updateProgress = function() {
            var a = this._node,
                b = a._sprite,
                c = b.width,
                d = b.height,
                e = a._midPoint;
            if (a._type == cc.ProgressTimer.TYPE_RADIAL) {
                this._radius = Math.round(Math.sqrt(c * c + d * d));
                var f, g, h = !1,
                    i = this._origin;
                i.x = c * e.x, i.y = -d * e.y, a._reverseDirection ? (g = 270, f = 270 - 3.6 * a._percentage) : (f = -90, g = -90 + 3.6 * a._percentage), b._flippedX && (i.x -= 2 * c * a._midPoint.x, f = -f, g = -g, f -= 180, g -= 180, h = !h), b._flippedY && (i.y += 2 * d * a._midPoint.y, h = !h, f = -f, g = -g), this._startAngle = f, this._endAngle = g, this._counterClockWise = h
            } else {
                var j = a._barChangeRate,
                    k = a._percentage / 100,
                    l = this._barRect,
                    m = cc.size(c * (1 - j.x), d * (1 - j.y)),
                    n = cc.size((c - m.width) * k, (d - m.height) * k),
                    o = cc.size(m.width + n.width, m.height + n.height),
                    p = cc.p(c * e.x, d * e.y),
                    q = p.x - o.width / 2;
                e.x > .5 && o.width / 2 >= c - p.x && (q = c - o.width);
                var r = p.y - o.height / 2;
                e.y > .5 && o.height / 2 >= d - p.y && (r = d - o.height), l.x = 0;
                var s = 1;
                b._flippedX && (l.x -= o.width, s = -1), q > 0 && (l.x += q * s), l.y = 0;
                var t = 1;
                b._flippedY && (l.y += o.height, t = -1), r > 0 && (l.y -= r * t), l.width = o.width, l.height = -o.height
            }
        }, a._updateColor = function() {}, a._syncStatus = function(a) {
            var b = this._node;
            if (b._sprite) {
                var c = cc.Node._dirtyFlags,
                    d = this._dirtyFlag,
                    e = a ? a._node : null;
                e && e._cascadeColorEnabled && a._dirtyFlag & c.colorDirty && (d |= c.colorDirty), e && e._cascadeOpacityEnabled && a._dirtyFlag & c.opacityDirty && (d |= c.opacityDirty), a && a._dirtyFlag & c.transformDirty && (d |= c.transformDirty), this._dirtyFlag = d;
                var f = b._sprite._renderCmd,
                    g = f._dirtyFlag,
                    h = g & c.colorDirty,
                    i = g & c.opacityDirty;
                h && f._syncDisplayColor(), i && f._syncDisplayOpacity(), d & c.transformDirty && this.transform(a)
            }
        }, a.updateStatus = function() {
            var a = this._node;
            if (a._sprite) {
                var b = cc.Node._dirtyFlags,
                    c = this._dirtyFlag,
                    d = a._sprite._renderCmd,
                    e = d._dirtyFlag,
                    f = e & b.colorDirty,
                    g = e & b.opacityDirty;
                f && d._updateDisplayColor(), g && d._updateDisplayOpacity(), c & b.transformDirty && this.transform(this.getParentRenderCmd(), !0), this._dirtyFlag = 0
            }
        }
    }(), cc.ProgressTo = cc.ActionInterval.extend({
        _to: 0,
        _from: 0,
        ctor: function(a, b) {
            cc.ActionInterval.prototype.ctor.call(this), this._to = 0, this._from = 0, void 0 !== b && this.initWithDuration(a, b)
        },
        initWithDuration: function(a, b) {
            return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._to = b, !0) : !1
        },
        clone: function() {
            var a = new cc.ProgressTo;
            return a.initWithDuration(this._duration, this._to), a
        },
        reverse: function() {
            return cc.log("cc.ProgressTo.reverse(): reverse hasn't been supported."), null
        },
        startWithTarget: function(a) {
            cc.ActionInterval.prototype.startWithTarget.call(this, a), this._from = a.percentage
        },
        update: function(a) {
            this.target instanceof cc.ProgressTimer && (this.target.percentage = this._from + (this._to - this._from) * a)
        }
    }), cc.progressTo = function(a, b) {
        return new cc.ProgressTo(a, b)
    }, cc.ProgressTo.create = cc.progressTo, cc.ProgressFromTo = cc.ActionInterval.extend({
        _to: 0,
        _from: 0,
        ctor: function(a, b, c) {
            cc.ActionInterval.prototype.ctor.call(this), this._to = 0, this._from = 0, void 0 !== c && this.initWithDuration(a, b, c)
        },
        initWithDuration: function(a, b, c) {
            return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._to = c, this._from = b, !0) : !1
        },
        clone: function() {
            var a = new cc.ProgressFromTo;
            return a.initWithDuration(this._duration, this._from, this._to), a
        },
        reverse: function() {
            return cc.progressFromTo(this._duration, this._to, this._from)
        },
        startWithTarget: function(a) {
            cc.ActionInterval.prototype.startWithTarget.call(this, a)
        },
        update: function(a) {
            this.target instanceof cc.ProgressTimer && (this.target.percentage = this._from + (this._to - this._from) * a)
        }
    }), cc.progressFromTo = function(a, b, c) {
        return new cc.ProgressFromTo(a, b, c)
    }, cc.ProgressFromTo.create = cc.progressFromTo;
! function() {
    cc.ProgressTimer.WebGLRenderCmd = function(a) {
        cc.Node.WebGLRenderCmd.call(this, a), this._needDraw = !0, this._vertexWebGLBuffer = cc._renderContext.createBuffer(), this._vertexDataCount = 0, this._vertexData = null, this._vertexArrayBuffer = null, this._vertexDataDirty = !1
    };
    var a = cc.ProgressTimer.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    a.constructor = cc.ProgressTimer.WebGLRenderCmd, a.rendering = function(a) {
        var b = this._node,
            c = a || cc._renderContext;
        if (this._vertexData && b._sprite) {
            this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
            var d = b._sprite._blendFunc;
            cc.glBlendFunc(d.src, d.dst), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), cc.glBindTexture2D(b._sprite.texture), c.bindBuffer(c.ARRAY_BUFFER, this._vertexWebGLBuffer), this._vertexDataDirty && (c.bufferData(c.ARRAY_BUFFER, this._vertexArrayBuffer, c.DYNAMIC_DRAW), this._vertexDataDirty = !1);
            var e = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
            c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, c.FLOAT, !1, e, 0), c.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, c.UNSIGNED_BYTE, !0, e, 8), c.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, c.FLOAT, !1, e, 12), b._type === cc.ProgressTimer.TYPE_RADIAL ? c.drawArrays(c.TRIANGLE_FAN, 0, this._vertexDataCount) : b._type == cc.ProgressTimer.TYPE_BAR && (b._reverseDirection ? (c.drawArrays(c.TRIANGLE_STRIP, 0, this._vertexDataCount / 2), c.drawArrays(c.TRIANGLE_STRIP, 4, this._vertexDataCount / 2), cc.g_NumberOfDraws++) : c.drawArrays(c.TRIANGLE_STRIP, 0, this._vertexDataCount)), cc.g_NumberOfDraws++
        }
    }, a._syncStatus = function(a) {
        var b = this._node;
        if (b._sprite) {
            var c = cc.Node._dirtyFlags,
                d = this._dirtyFlag,
                e = a ? a._node : null;
            e && e._cascadeColorEnabled && a._dirtyFlag & c.colorDirty && (d |= c.colorDirty), e && e._cascadeOpacityEnabled && a._dirtyFlag & c.opacityDirty && (d |= c.opacityDirty), a && a._dirtyFlag & c.transformDirty && (d |= c.transformDirty), this._dirtyFlag = d;
            var f = b._sprite._renderCmd,
                g = f._dirtyFlag,
                h = g & c.colorDirty,
                i = g & c.opacityDirty;
            h && f._syncDisplayColor(), i && f._syncDisplayOpacity(), (h || i) && (f._updateColor(), this._updateColor()), this.transform(a), f._dirtyFlag = 0
        }
    }, a.updateStatus = function() {
        var a = this._node;
        if (a._sprite) {
            var b = cc.Node._dirtyFlags,
                c = this._dirtyFlag,
                d = a._sprite._renderCmd,
                e = d._dirtyFlag,
                f = e & b.colorDirty,
                g = e & b.opacityDirty;
            f && (d._updateDisplayColor(), this._dirtyFlag = this._dirtyFlag & b.colorDirty ^ this._dirtyFlag), g && (d._updateDisplayOpacity(), this._dirtyFlag = this._dirtyFlag & b.opacityDirty ^ this._dirtyFlag), (f || g) && (d._updateColor(), this._updateColor()), c & b.transformDirty && this.transform(this.getParentRenderCmd(), !0)
        }
    }, a.releaseData = function() {
        this._vertexData && (this._vertexData = null, this._vertexArrayBuffer = null, this._vertexDataCount = 0)
    }, a.initCmd = function() {
        this._vertexData = null, this._vertexArrayBuffer = null, this._vertexDataCount = 0, this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)
    }, a._updateProgress = function() {
        var a = this._node,
            b = a._type;
        b === cc.ProgressTimer.TYPE_RADIAL ? this._updateRadial() : b === cc.ProgressTimer.TYPE_BAR && this._updateBar(), this._vertexDataDirty = !0
    }, a._updateBar = function() {
        var a = this._node;
        if (a._sprite) {
            var b, c = a._percentage / 100,
                d = a._barChangeRate,
                e = cc.pMult(cc.p(1 - d.x + c * d.x, 1 - d.y + c * d.y), .5),
                f = cc.pSub(a._midPoint, e),
                g = cc.pAdd(a._midPoint, e);
            f.x < 0 && (g.x += -f.x, f.x = 0), g.x > 1 && (f.x -= g.x - 1, g.x = 1), f.y < 0 && (g.y += -f.y, f.y = 0), g.y > 1 && (f.y -= g.y - 1, g.y = 1);
            var h;
            if (this._reverseDirection) {
                if (!this._vertexData) {
                    this._vertexDataCount = 8;
                    var i = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT,
                        j = 8;
                    this._vertexArrayBuffer = new ArrayBuffer(j * i);
                    var k = [];
                    for (b = 0; j > b; b++) k[b] = new cc.V2F_C4B_T2F(null, null, null, this._vertexArrayBuffer, b * i);
                    k[0].texCoords = this._textureCoordFromAlphaPoint(cc.p(0, 1)), k[0].vertices = this._vertexFromAlphaPoint(cc.p(0, 1)), k[1].texCoords = this._textureCoordFromAlphaPoint(cc.p(0, 0)), k[1].vertices = this._vertexFromAlphaPoint(cc.p(0, 0)), k[6].texCoords = this._textureCoordFromAlphaPoint(cc.p(1, 1)), k[6].vertices = this._vertexFromAlphaPoint(cc.p(1, 1)), k[7].texCoords = this._textureCoordFromAlphaPoint(cc.p(1, 0)), k[7].vertices = this._vertexFromAlphaPoint(cc.p(1, 0)), this._vertexData = k
                }
                h = this._vertexData, h[2].texCoords = this._textureCoordFromAlphaPoint(cc.p(f.x, g.y)), h[2].vertices = this._vertexFromAlphaPoint(cc.p(f.x, g.y)), h[3].texCoords = this._textureCoordFromAlphaPoint(cc.p(f.x, f.y)), h[3].vertices = this._vertexFromAlphaPoint(cc.p(f.x, f.y)), h[4].texCoords = this._textureCoordFromAlphaPoint(cc.p(g.x, g.y)), h[4].vertices = this._vertexFromAlphaPoint(cc.p(g.x, g.y)), h[5].texCoords = this._textureCoordFromAlphaPoint(cc.p(g.x, f.y)), h[5].vertices = this._vertexFromAlphaPoint(cc.p(g.x, f.y))
            } else {
                if (!this._vertexData) {
                    this._vertexDataCount = 4;
                    var l = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT,
                        m = 4;
                    for (this._vertexArrayBuffer = new ArrayBuffer(m * l), this._vertexData = [], b = 0; m > b; b++) this._vertexData[b] = new cc.V2F_C4B_T2F(null, null, null, this._vertexArrayBuffer, b * l)
                }
                h = this._vertexData, h[0].texCoords = this._textureCoordFromAlphaPoint(cc.p(f.x, g.y)), h[0].vertices = this._vertexFromAlphaPoint(cc.p(f.x, g.y)), h[1].texCoords = this._textureCoordFromAlphaPoint(cc.p(f.x, f.y)), h[1].vertices = this._vertexFromAlphaPoint(cc.p(f.x, f.y)), h[2].texCoords = this._textureCoordFromAlphaPoint(cc.p(g.x, g.y)), h[2].vertices = this._vertexFromAlphaPoint(cc.p(g.x, g.y)), h[3].texCoords = this._textureCoordFromAlphaPoint(cc.p(g.x, f.y)), h[3].vertices = this._vertexFromAlphaPoint(cc.p(g.x, f.y))
            }
            this._updateColor()
        }
    }, a._updateRadial = function() {
        var a = this._node;
        if (a._sprite) {
            var b, c, d = a._midPoint,
                e = a._percentage / 100,
                f = 2 * cc.PI * (a._reverseDirection ? e : 1 - e),
                g = cc.p(d.x, 1),
                h = cc.pRotateByAngle(g, d, f),
                i = 0;
            if (0 == e) c = g, i = 0;
            else if (1 == e) c = g, i = 4;
            else {
                var j = cc.FLT_MAX,
                    k = cc.ProgressTimer.TEXTURE_COORDS_COUNT;
                for (b = 0; k >= b; ++b) {
                    var l = (b + (k - 1)) % k,
                        m = this._boundaryTexCoord(b % k),
                        n = this._boundaryTexCoord(l);
                    0 == b ? n = cc.pLerp(m, n, 1 - d.x) : 4 == b && (m = cc.pLerp(m, n, 1 - d.x));
                    var o = cc.p(0, 0);
                    if (cc.pLineIntersect(m, n, d, h, o)) {
                        if (!(0 != b && 4 != b || 0 <= o.x && o.x <= 1)) continue;
                        o.y >= 0 && o.y < j && (j = o.y, i = b)
                    }
                }
                c = cc.pAdd(d, cc.pMult(cc.pSub(h, d), j))
            }
            var p = !0;
            if (this._vertexDataCount != i + 3 && (p = !1, this._vertexData = null, this._vertexArrayBuffer = null, this._vertexDataCount = 0), !this._vertexData) {
                this._vertexDataCount = i + 3;
                var q = this._vertexDataCount,
                    r = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
                this._vertexArrayBuffer = new ArrayBuffer(q * r);
                var s = [];
                for (b = 0; q > b; b++) s[b] = new cc.V2F_C4B_T2F(null, null, null, this._vertexArrayBuffer, b * r);
                if (this._vertexData = s, !this._vertexData) return void cc.log("cc.ProgressTimer._updateRadial() : Not enough memory")
            }
            this._updateColor();
            var t = this._vertexData;
            if (!p)
                for (t[0].texCoords = this._textureCoordFromAlphaPoint(d), t[0].vertices = this._vertexFromAlphaPoint(d), t[1].texCoords = this._textureCoordFromAlphaPoint(g), t[1].vertices = this._vertexFromAlphaPoint(g), b = 0; i > b; b++) {
                    var u = this._boundaryTexCoord(b);
                    t[b + 2].texCoords = this._textureCoordFromAlphaPoint(u), t[b + 2].vertices = this._vertexFromAlphaPoint(u)
                }
            t[this._vertexDataCount - 1].texCoords = this._textureCoordFromAlphaPoint(c), t[this._vertexDataCount - 1].vertices = this._vertexFromAlphaPoint(c)
        }
    }, a._boundaryTexCoord = function(a) {
        if (a < cc.ProgressTimer.TEXTURE_COORDS_COUNT) {
            var b = cc.ProgressTimer.TEXTURE_COORDS;
            return this._node._reverseDirection ? cc.p(b >> 7 - (a << 1) & 1, b >> 7 - ((a << 1) + 1) & 1) : cc.p(b >> (a << 1) + 1 & 1, b >> (a << 1) & 1)
        }
        return cc.p(0, 0)
    }, a._textureCoordFromAlphaPoint = function(a) {
        var b = this._node._sprite;
        if (!b) return {
            u: 0,
            v: 0
        };
        var c = b.quad,
            d = cc.p(c.bl.texCoords.u, c.bl.texCoords.v),
            e = cc.p(c.tr.texCoords.u, c.tr.texCoords.v);
        if (b.textureRectRotated) {
            var f = a.x;
            a.x = a.y, a.y = f
        }
        return {
            u: d.x * (1 - a.x) + e.x * a.x,
            v: d.y * (1 - a.y) + e.y * a.y
        }
    }, a._vertexFromAlphaPoint = function(a) {
        var b = this._node._sprite;
        if (!b) return {
            x: 0,
            y: 0
        };
        var c = b.quad,
            d = cc.p(c.bl.vertices.x, c.bl.vertices.y),
            e = cc.p(c.tr.vertices.x, c.tr.vertices.y);
        return {
            x: d.x * (1 - a.x) + e.x * a.x,
            y: d.y * (1 - a.y) + e.y * a.y
        }
    }, a._updateColor = function() {
        var a = this._node;
        if (a._sprite && this._vertexData) {
            for (var b = a._sprite.quad.tl.colors, c = this._vertexData, d = 0, e = this._vertexDataCount; e > d; ++d) c[d].colors = b;
            this._vertexDataDirty = !0
        }
    }
}();
cc.SCENE_FADE = 4208917214, cc.TRANSITION_ORIENTATION_LEFT_OVER = 0, cc.TRANSITION_ORIENTATION_RIGHT_OVER = 1, cc.TRANSITION_ORIENTATION_UP_OVER = 0, cc.TRANSITION_ORIENTATION_DOWN_OVER = 1, cc.TransitionScene = cc.Scene.extend({
    _inScene: null,
    _outScene: null,
    _duration: null,
    _isInSceneOnTop: !1,
    _isSendCleanupToScene: !1,
    _className: "TransitionScene",
    ctor: function(a, b) {
        cc.Scene.prototype.ctor.call(this), void 0 !== a && void 0 !== b && this.initWithDuration(a, b)
    },
    _setNewScene: function() {
        this.unschedule(this._setNewScene);
        var a = cc.director;
        this._isSendCleanupToScene = a.isSendCleanupToScene(), a.runScene(this._inScene), cc.eventManager.setEnabled(!0), this._outScene.visible = !0
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !0
    },
    visit: function() {
        this._isInSceneOnTop ? (this._outScene.visit(), this._inScene.visit()) : (this._inScene.visit(), this._outScene.visit()), cc.Node.prototype.visit.call(this)
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this), cc.eventManager.setEnabled(!1), this._outScene.onExitTransitionDidStart(), this._inScene.onEnter()
    },
    onExit: function() {
        cc.Node.prototype.onExit.call(this), cc.eventManager.setEnabled(!0), this._outScene.onExit(), this._inScene.onEnterTransitionDidFinish()
    },
    cleanup: function() {
        cc.Node.prototype.cleanup.call(this), this._isSendCleanupToScene && this._outScene.cleanup()
    },
    initWithDuration: function(a, b) {
        if (!b) throw "cc.TransitionScene.initWithDuration(): Argument scene must be non-nil";
        if (this.init()) {
            if (this._duration = a, this.attr({
                x: 0,
                y: 0,
                anchorX: 0,
                anchorY: 0
            }), this._inScene = b, this._outScene = cc.director.getRunningScene(), this._outScene || (this._outScene = new cc.Scene, this._outScene.init()), this._inScene == this._outScene) throw "cc.TransitionScene.initWithDuration(): Incoming scene must be different from the outgoing scene";
            return this._sceneOrder(), !0
        }
        return !1
    },
    finish: function() {
        this._inScene.attr({
            visible: !0,
            x: 0,
            y: 0,
            scale: 1,
            rotation: 0
        }), cc._renderType === cc._RENDER_TYPE_WEBGL && this._inScene.getCamera().restore(), this._outScene.attr({
            visible: !1,
            x: 0,
            y: 0,
            scale: 1,
            rotation: 0
        }), cc._renderType === cc._RENDER_TYPE_WEBGL && this._outScene.getCamera().restore(), this.schedule(this._setNewScene, 0)
    },
    hideOutShowIn: function() {
        this._inScene.visible = !0, this._outScene.visible = !1
    }
}), cc.TransitionScene.create = function(a, b) {
    return new cc.TransitionScene(a, b)
}, cc.TransitionSceneOriented = cc.TransitionScene.extend({
    _orientation: 0,
    ctor: function(a, b, c) {
        cc.TransitionScene.prototype.ctor.call(this), void 0 != c && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        return cc.TransitionScene.prototype.initWithDuration.call(this, a, b) && (this._orientation = c), !0
    }
}), cc.TransitionSceneOriented.create = function(a, b, c) {
    return new cc.TransitionSceneOriented(a, b, c)
}, cc.TransitionRotoZoom = cc.TransitionScene.extend({
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this), this._inScene.attr({
            scale: .001,
            anchorX: .5,
            anchorY: .5
        }), this._outScene.attr({
            scale: 1,
            anchorX: .5,
            anchorY: .5
        });
        var a = cc.sequence(cc.spawn(cc.scaleBy(this._duration / 2, .001), cc.rotateBy(this._duration / 2, 720)), cc.delayTime(this._duration / 2));
        this._outScene.runAction(a), this._inScene.runAction(cc.sequence(a.reverse(), cc.callFunc(this.finish, this)))
    }
}), cc.TransitionRotoZoom.create = function(a, b) {
    return new cc.TransitionRotoZoom(a, b)
}, cc.TransitionJumpZoom = cc.TransitionScene.extend({
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a = cc.director.getWinSize();
        this._inScene.attr({
            scale: .5,
            x: a.width,
            y: 0,
            anchorX: .5,
            anchorY: .5
        }), this._outScene.anchorX = .5, this._outScene.anchorY = .5;
        var b = cc.jumpBy(this._duration / 4, cc.p(-a.width, 0), a.width / 4, 2),
            c = cc.scaleTo(this._duration / 4, 1),
            d = cc.scaleTo(this._duration / 4, .5),
            e = cc.sequence(d, b),
            f = cc.sequence(b, c),
            g = cc.delayTime(this._duration / 2);
        this._outScene.runAction(e), this._inScene.runAction(cc.sequence(g, f, cc.callFunc(this.finish, this)))
    }
}), cc.TransitionJumpZoom.create = function(a, b) {
    return new cc.TransitionJumpZoom(a, b)
}, cc.TransitionMoveInL = cc.TransitionScene.extend({
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this), this.initScenes();
        var a = this.action();
        this._inScene.runAction(cc.sequence(this.easeActionWithAction(a), cc.callFunc(this.finish, this)))
    },
    initScenes: function() {
        this._inScene.setPosition(-cc.director.getWinSize().width, 0)
    },
    action: function() {
        return cc.moveTo(this._duration, cc.p(0, 0))
    },
    easeActionWithAction: function(a) {
        return new cc.EaseOut(a, 2)
    }
}), cc.TransitionMoveInL.create = function(a, b) {
    return new cc.TransitionMoveInL(a, b)
}, cc.TransitionMoveInR = cc.TransitionMoveInL.extend({
    ctor: function(a, b) {
        cc.TransitionMoveInL.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    initScenes: function() {
        this._inScene.setPosition(cc.director.getWinSize().width, 0)
    }
}), cc.TransitionMoveInR.create = function(a, b) {
    return new cc.TransitionMoveInR(a, b)
}, cc.TransitionMoveInT = cc.TransitionMoveInL.extend({
    ctor: function(a, b) {
        cc.TransitionMoveInL.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    initScenes: function() {
        this._inScene.setPosition(0, cc.director.getWinSize().height)
    }
}), cc.TransitionMoveInT.create = function(a, b) {
    return new cc.TransitionMoveInT(a, b)
}, cc.TransitionMoveInB = cc.TransitionMoveInL.extend({
    ctor: function(a, b) {
        cc.TransitionMoveInL.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    initScenes: function() {
        this._inScene.setPosition(0, -cc.director.getWinSize().height)
    }
}), cc.TransitionMoveInB.create = function(a, b) {
    return new cc.TransitionMoveInB(a, b)
}, cc.ADJUST_FACTOR = .5, cc.TransitionSlideInL = cc.TransitionScene.extend({
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !1
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this), this.initScenes();
        var a = this.action(),
            b = this.action(),
            c = this.easeActionWithAction(a),
            d = cc.sequence(this.easeActionWithAction(b), cc.callFunc(this.finish, this));
        this._inScene.runAction(c), this._outScene.runAction(d)
    },
    initScenes: function() {
        this._inScene.setPosition(-cc.director.getWinSize().width + cc.ADJUST_FACTOR, 0)
    },
    action: function() {
        return cc.moveBy(this._duration, cc.p(cc.director.getWinSize().width - cc.ADJUST_FACTOR, 0))
    },
    easeActionWithAction: function(a) {
        return new cc.EaseInOut(a, 2)
    }
}), cc.TransitionSlideInL.create = function(a, b) {
    return new cc.TransitionSlideInL(a, b)
}, cc.TransitionSlideInR = cc.TransitionSlideInL.extend({
    ctor: function(a, b) {
        cc.TransitionSlideInL.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !0
    },
    initScenes: function() {
        this._inScene.setPosition(cc.director.getWinSize().width - cc.ADJUST_FACTOR, 0)
    },
    action: function() {
        return cc.moveBy(this._duration, cc.p(-(cc.director.getWinSize().width - cc.ADJUST_FACTOR), 0))
    }
}), cc.TransitionSlideInR.create = function(a, b) {
    return new cc.TransitionSlideInR(a, b)
}, cc.TransitionSlideInB = cc.TransitionSlideInL.extend({
    ctor: function(a, b) {
        cc.TransitionSlideInL.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !1
    },
    initScenes: function() {
        this._inScene.setPosition(0, -(cc.director.getWinSize().height - cc.ADJUST_FACTOR))
    },
    action: function() {
        return cc.moveBy(this._duration, cc.p(0, cc.director.getWinSize().height - cc.ADJUST_FACTOR))
    }
}), cc.TransitionSlideInB.create = function(a, b) {
    return new cc.TransitionSlideInB(a, b)
}, cc.TransitionSlideInT = cc.TransitionSlideInL.extend({
    ctor: function(a, b) {
        cc.TransitionSlideInL.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !0
    },
    initScenes: function() {
        this._inScene.setPosition(0, cc.director.getWinSize().height - cc.ADJUST_FACTOR)
    },
    action: function() {
        return cc.moveBy(this._duration, cc.p(0, -(cc.director.getWinSize().height - cc.ADJUST_FACTOR)))
    }
}), cc.TransitionSlideInT.create = function(a, b) {
    return new cc.TransitionSlideInT(a, b)
}, cc.TransitionShrinkGrow = cc.TransitionScene.extend({
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this), this._inScene.attr({
            scale: .001,
            anchorX: 2 / 3,
            anchorY: .5
        }), this._outScene.attr({
            scale: 1,
            anchorX: 1 / 3,
            anchorY: .5
        });
        var a = cc.scaleTo(this._duration, .01),
            b = cc.scaleTo(this._duration, 1);
        this._inScene.runAction(this.easeActionWithAction(b)), this._outScene.runAction(cc.sequence(this.easeActionWithAction(a), cc.callFunc(this.finish, this)))
    },
    easeActionWithAction: function(a) {
        return new cc.EaseOut(a, 2)
    }
}), cc.TransitionShrinkGrow.create = function(a, b) {
    return new cc.TransitionShrinkGrow(a, b)
}, cc.TransitionFlipX = cc.TransitionSceneOriented.extend({
    ctor: function(a, b, c) {
        cc.TransitionSceneOriented.prototype.ctor.call(this), null == c && (c = cc.TRANSITION_ORIENTATION_RIGHT_OVER), b && this.initWithDuration(a, b, c)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, b;
        this._inScene.visible = !1;
        var c, d, e, f;
        this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (c = 90, d = 270, e = 90, f = 0) : (c = -90, d = 90, e = -90, f = 0), a = cc.sequence(cc.delayTime(this._duration / 2), cc.show(), cc.orbitCamera(this._duration / 2, 1, 0, d, c, 0, 0), cc.callFunc(this.finish, this)), b = cc.sequence(cc.orbitCamera(this._duration / 2, 1, 0, f, e, 0, 0), cc.hide(), cc.delayTime(this._duration / 2)), this._inScene.runAction(a), this._outScene.runAction(b)
    }
}), cc.TransitionFlipX.create = function(a, b, c) {
    return new cc.TransitionFlipX(a, b, c)
}, cc.TransitionFlipY = cc.TransitionSceneOriented.extend({
    ctor: function(a, b, c) {
        cc.TransitionSceneOriented.prototype.ctor.call(this), null == c && (c = cc.TRANSITION_ORIENTATION_UP_OVER), b && this.initWithDuration(a, b, c)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, b;
        this._inScene.visible = !1;
        var c, d, e, f;
        this._orientation == cc.TRANSITION_ORIENTATION_UP_OVER ? (c = 90, d = 270, e = 90, f = 0) : (c = -90, d = 90, e = -90, f = 0), a = cc.sequence(cc.delayTime(this._duration / 2), cc.show(), cc.orbitCamera(this._duration / 2, 1, 0, d, c, 90, 0), cc.callFunc(this.finish, this)), b = cc.sequence(cc.orbitCamera(this._duration / 2, 1, 0, f, e, 90, 0), cc.hide(), cc.delayTime(this._duration / 2)), this._inScene.runAction(a), this._outScene.runAction(b)
    }
}), cc.TransitionFlipY.create = function(a, b, c) {
    return new cc.TransitionFlipY(a, b, c)
}, cc.TransitionFlipAngular = cc.TransitionSceneOriented.extend({
    ctor: function(a, b, c) {
        cc.TransitionSceneOriented.prototype.ctor.call(this), null == c && (c = cc.TRANSITION_ORIENTATION_RIGHT_OVER), b && this.initWithDuration(a, b, c)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, b;
        this._inScene.visible = !1;
        var c, d, e, f;
        this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (c = 90, d = 270, e = 90, f = 0) : (c = -90, d = 90, e = -90, f = 0), a = cc.sequence(cc.delayTime(this._duration / 2), cc.show(), cc.orbitCamera(this._duration / 2, 1, 0, d, c, -45, 0), cc.callFunc(this.finish, this)), b = cc.sequence(cc.orbitCamera(this._duration / 2, 1, 0, f, e, 45, 0), cc.hide(), cc.delayTime(this._duration / 2)), this._inScene.runAction(a), this._outScene.runAction(b)
    }
}), cc.TransitionFlipAngular.create = function(a, b, c) {
    return new cc.TransitionFlipAngular(a, b, c)
}, cc.TransitionZoomFlipX = cc.TransitionSceneOriented.extend({
    ctor: function(a, b, c) {
        cc.TransitionSceneOriented.prototype.ctor.call(this), null == c && (c = cc.TRANSITION_ORIENTATION_RIGHT_OVER), b && this.initWithDuration(a, b, c)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, b;
        this._inScene.visible = !1;
        var c, d, e, f;
        this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (c = 90, d = 270, e = 90, f = 0) : (c = -90, d = 90, e = -90, f = 0), a = cc.sequence(cc.delayTime(this._duration / 2), cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, d, c, 0, 0), cc.scaleTo(this._duration / 2, 1), cc.show()), cc.callFunc(this.finish, this)), b = cc.sequence(cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, f, e, 0, 0), cc.scaleTo(this._duration / 2, .5)), cc.hide(), cc.delayTime(this._duration / 2)), this._inScene.scale = .5, this._inScene.runAction(a), this._outScene.runAction(b)
    }
}), cc.TransitionZoomFlipX.create = function(a, b, c) {
    return new cc.TransitionZoomFlipX(a, b, c)
}, cc.TransitionZoomFlipY = cc.TransitionSceneOriented.extend({
    ctor: function(a, b, c) {
        cc.TransitionSceneOriented.prototype.ctor.call(this), null == c && (c = cc.TRANSITION_ORIENTATION_UP_OVER), b && this.initWithDuration(a, b, c)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, b;
        this._inScene.visible = !1;
        var c, d, e, f;
        this._orientation === cc.TRANSITION_ORIENTATION_UP_OVER ? (c = 90, d = 270, e = 90, f = 0) : (c = -90, d = 90, e = -90, f = 0), a = cc.sequence(cc.delayTime(this._duration / 2), cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, d, c, 90, 0), cc.scaleTo(this._duration / 2, 1), cc.show()), cc.callFunc(this.finish, this)), b = cc.sequence(cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, f, e, 90, 0), cc.scaleTo(this._duration / 2, .5)), cc.hide(), cc.delayTime(this._duration / 2)), this._inScene.scale = .5, this._inScene.runAction(a), this._outScene.runAction(b)
    }
}), cc.TransitionZoomFlipY.create = function(a, b, c) {
    return new cc.TransitionZoomFlipY(a, b, c)
}, cc.TransitionZoomFlipAngular = cc.TransitionSceneOriented.extend({
    ctor: function(a, b, c) {
        cc.TransitionSceneOriented.prototype.ctor.call(this), null == c && (c = cc.TRANSITION_ORIENTATION_RIGHT_OVER), b && this.initWithDuration(a, b, c)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, b;
        this._inScene.visible = !1;
        var c, d, e, f;
        this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (c = 90, d = 270, e = 90, f = 0) : (c = -90, d = 90, e = -90, f = 0), a = cc.sequence(cc.delayTime(this._duration / 2), cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, d, c, -45, 0), cc.scaleTo(this._duration / 2, 1), cc.show()), cc.show(), cc.callFunc(this.finish, this)), b = cc.sequence(cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, f, e, 45, 0), cc.scaleTo(this._duration / 2, .5)), cc.hide(), cc.delayTime(this._duration / 2)), this._inScene.scale = .5, this._inScene.runAction(a), this._outScene.runAction(b)
    }
}), cc.TransitionZoomFlipAngular.create = function(a, b, c) {
    return new cc.TransitionZoomFlipAngular(a, b, c)
}, cc.TransitionFade = cc.TransitionScene.extend({
    _color: null,
    ctor: function(a, b, c) {
        cc.TransitionScene.prototype.ctor.call(this), this._color = cc.color(), b && this.initWithDuration(a, b, c)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a = new cc.LayerColor(this._color);
        this._inScene.visible = !1, this.addChild(a, 2, cc.SCENE_FADE);
        var b = this.getChildByTag(cc.SCENE_FADE),
            c = cc.sequence(cc.fadeIn(this._duration / 2), cc.callFunc(this.hideOutShowIn, this), cc.fadeOut(this._duration / 2), cc.callFunc(this.finish, this));
        b.runAction(c)
    },
    onExit: function() {
        cc.TransitionScene.prototype.onExit.call(this), this.removeChildByTag(cc.SCENE_FADE, !1)
    },
    initWithDuration: function(a, b, c) {
        return c = c || cc.color.BLACK, cc.TransitionScene.prototype.initWithDuration.call(this, a, b) && (this._color.r = c.r, this._color.g = c.g, this._color.b = c.b, this._color.a = 0), !0
    }
}), cc.TransitionFade.create = function(a, b, c) {
    return new cc.TransitionFade(a, b, c)
}, cc.TransitionCrossFade = cc.TransitionScene.extend({
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a = cc.color(0, 0, 0, 0),
            b = cc.director.getWinSize(),
            c = new cc.LayerColor(a),
            d = new cc.RenderTexture(b.width, b.height);
        if (null != d) {
            d.sprite.anchorX = .5, d.sprite.anchorY = .5, d.attr({
                x: b.width / 2,
                y: b.height / 2,
                anchorX: .5,
                anchorY: .5
            }), d.begin(), this._inScene.visit(), d.end();
            var e = new cc.RenderTexture(b.width, b.height);
            e.setPosition(b.width / 2, b.height / 2), e.sprite.anchorX = e.anchorX = .5, e.sprite.anchorY = e.anchorY = .5, e.begin(), this._outScene.visit(), e.end(), d.sprite.setBlendFunc(cc.ONE, cc.ONE), e.sprite.setBlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA), c.addChild(d), c.addChild(e), d.sprite.opacity = 255, e.sprite.opacity = 255;
            var f = cc.sequence(cc.fadeTo(this._duration, 0), cc.callFunc(this.hideOutShowIn, this), cc.callFunc(this.finish, this));
            e.sprite.runAction(f), this.addChild(c, 2, cc.SCENE_FADE)
        }
    },
    onExit: function() {
        this.removeChildByTag(cc.SCENE_FADE, !1), cc.TransitionScene.prototype.onExit.call(this)
    },
    visit: function() {
        cc.Node.prototype.visit.call(this)
    },
    draw: function() {}
}), cc.TransitionCrossFade.create = function(a, b) {
    return new cc.TransitionCrossFade(a, b)
}, cc.TransitionTurnOffTiles = cc.TransitionScene.extend({
    _gridProxy: null,
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this), this._gridProxy = new cc.NodeGrid, b && this.initWithDuration(a, b)
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !1
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this), this._gridProxy.setTarget(this._outScene), this._gridProxy.onEnter();
        var a = cc.director.getWinSize(),
            b = a.width / a.height,
            c = 0 | 12 * b,
            d = 12,
            e = cc.turnOffTiles(this._duration, cc.size(c, d)),
            f = this.easeActionWithAction(e);
        this._gridProxy.runAction(cc.sequence(f, cc.callFunc(this.finish, this), cc.stopGrid()))
    },
    visit: function() {
        this._inScene.visit(), this._gridProxy.visit()
    },
    easeActionWithAction: function(a) {
        return a
    }
}), cc.TransitionTurnOffTiles.create = function(a, b) {
    return new cc.TransitionTurnOffTiles(a, b)
}, cc.TransitionSplitCols = cc.TransitionScene.extend({
    _gridProxy: null,
    _switchTargetToInscene: function() {
        this._gridProxy.setTarget(this._inScene)
    },
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this), this._gridProxy = new cc.NodeGrid, b && this.initWithDuration(a, b)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this), this._gridProxy.setTarget(this._outScene), this._gridProxy.onEnter();
        var a = this.action(),
            b = cc.sequence(a, cc.callFunc(this._switchTargetToInscene, this), a.reverse());
        this._gridProxy.runAction(cc.sequence(this.easeActionWithAction(b), cc.callFunc(this.finish, this), cc.stopGrid()))
    },
    onExit: function() {
        this._gridProxy.setTarget(null), this._gridProxy.onExit(), cc.TransitionScene.prototype.onExit.call(this)
    },
    visit: function() {
        this._gridProxy.visit()
    },
    easeActionWithAction: function(a) {
        return new cc.EaseInOut(a, 3)
    },
    action: function() {
        return cc.splitCols(this._duration / 2, 3)
    }
}), cc.TransitionSplitCols.create = function(a, b) {
    return new cc.TransitionSplitCols(a, b)
}, cc.TransitionSplitRows = cc.TransitionSplitCols.extend({
    ctor: function(a, b) {
        cc.TransitionSplitCols.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    action: function() {
        return cc.splitRows(this._duration / 2, 3)
    }
}), cc.TransitionSplitRows.create = function(a, b) {
    return new cc.TransitionSplitRows(a, b)
}, cc.TransitionFadeTR = cc.TransitionScene.extend({
    _gridProxy: null,
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this), this._gridProxy = new cc.NodeGrid, b && this.initWithDuration(a, b)
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !1
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this), this._gridProxy.setTarget(this._outScene), this._gridProxy.onEnter();
        var a = cc.director.getWinSize(),
            b = a.width / a.height,
            c = 0 | 12 * b,
            d = 12,
            e = this.actionWithSize(cc.size(c, d));
        this._gridProxy.runAction(cc.sequence(this.easeActionWithAction(e), cc.callFunc(this.finish, this), cc.stopGrid()))
    },
    visit: function() {
        this._inScene.visit(), this._gridProxy.visit()
    },
    easeActionWithAction: function(a) {
        return a
    },
    actionWithSize: function(a) {
        return cc.fadeOutTRTiles(this._duration, a)
    }
}), cc.TransitionFadeTR.create = function(a, b) {
    return new cc.TransitionFadeTR(a, b)
}, cc.TransitionFadeBL = cc.TransitionFadeTR.extend({
    ctor: function(a, b) {
        cc.TransitionFadeTR.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    actionWithSize: function(a) {
        return cc.fadeOutBLTiles(this._duration, a)
    }
}), cc.TransitionFadeBL.create = function(a, b) {
    return new cc.TransitionFadeBL(a, b)
}, cc.TransitionFadeUp = cc.TransitionFadeTR.extend({
    ctor: function(a, b) {
        cc.TransitionFadeTR.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    actionWithSize: function(a) {
        return new cc.FadeOutUpTiles(this._duration, a)
    }
}), cc.TransitionFadeUp.create = function(a, b) {
    return new cc.TransitionFadeUp(a, b)
}, cc.TransitionFadeDown = cc.TransitionFadeTR.extend({
    ctor: function(a, b) {
        cc.TransitionFadeTR.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    actionWithSize: function(a) {
        return cc.fadeOutDownTiles(this._duration, a)
    }
}), cc.TransitionFadeDown.create = function(a, b) {
    return new cc.TransitionFadeDown(a, b)
}, cc.SCENE_RADIAL = 49153, cc.TransitionProgress = cc.TransitionScene.extend({
    _to: 0,
    _from: 0,
    _sceneToBeModified: null,
    _className: "TransitionProgress",
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    _setAttrs: function(a, b, c) {
        a.attr({
            x: b,
            y: c,
            anchorX: .5,
            anchorY: .5
        })
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this), this._setupTransition();
        var a = cc.director.getWinSize(),
            b = new cc.RenderTexture(a.width, a.height);
        b.sprite.anchorX = .5, b.sprite.anchorY = .5, this._setAttrs(b, a.width / 2, a.height / 2), b.clear(0, 0, 0, 1), b.begin(), this._sceneToBeModified.visit(), b.end(), this._sceneToBeModified == this._outScene && this.hideOutShowIn();
        var c = this._progressTimerNodeWithRenderTexture(b),
            d = cc.sequence(cc.progressFromTo(this._duration, this._from, this._to), cc.callFunc(this.finish, this));
        c.runAction(d), this.addChild(c, 2, cc.SCENE_RADIAL)
    },
    onExit: function() {
        this.removeChildByTag(cc.SCENE_RADIAL, !0), cc.TransitionScene.prototype.onExit.call(this)
    },
    _setupTransition: function() {
        this._sceneToBeModified = this._outScene, this._from = 100, this._to = 0
    },
    _progressTimerNodeWithRenderTexture: function() {
        return cc.log("cc.TransitionProgress._progressTimerNodeWithRenderTexture(): should be overridden in subclass"), null
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !1
    }
}), cc.TransitionProgress.create = function(a, b) {
    return new cc.TransitionProgress(a, b)
}, cc.TransitionProgressRadialCCW = cc.TransitionProgress.extend({
    ctor: function(a, b) {
        cc.TransitionProgress.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    _progressTimerNodeWithRenderTexture: function(a) {
        var b = cc.director.getWinSize(),
            c = new cc.ProgressTimer(a.sprite);
        return cc._renderType === cc._RENDER_TYPE_WEBGL && (c.sprite.flippedY = !0), c.type = cc.ProgressTimer.TYPE_RADIAL, c.reverseDir = !1, c.percentage = 100, this._setAttrs(c, b.width / 2, b.height / 2), c
    }
}), cc.TransitionProgressRadialCCW.create = function(a, b) {
    return new cc.TransitionProgressRadialCCW(a, b)
}, cc.TransitionProgressRadialCW = cc.TransitionProgress.extend({
    ctor: function(a, b) {
        cc.TransitionProgress.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    _progressTimerNodeWithRenderTexture: function(a) {
        var b = cc.director.getWinSize(),
            c = new cc.ProgressTimer(a.sprite);
        return cc._renderType === cc._RENDER_TYPE_WEBGL && (c.sprite.flippedY = !0), c.type = cc.ProgressTimer.TYPE_RADIAL, c.reverseDir = !0, c.percentage = 100, this._setAttrs(c, b.width / 2, b.height / 2), c
    }
}), cc.TransitionProgressRadialCW.create = function(a, b) {
    var c = new cc.TransitionProgressRadialCW;
    return null != c && c.initWithDuration(a, b) ? c : new cc.TransitionProgressRadialCW(a, b)
}, cc.TransitionProgressHorizontal = cc.TransitionProgress.extend({
    ctor: function(a, b) {
        cc.TransitionProgress.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    _progressTimerNodeWithRenderTexture: function(a) {
        var b = cc.director.getWinSize(),
            c = new cc.ProgressTimer(a.sprite);
        return cc._renderType === cc._RENDER_TYPE_WEBGL && (c.sprite.flippedY = !0), c.type = cc.ProgressTimer.TYPE_BAR, c.midPoint = cc.p(1, 0), c.barChangeRate = cc.p(1, 0), c.percentage = 100, this._setAttrs(c, b.width / 2, b.height / 2), c
    }
}), cc.TransitionProgressHorizontal.create = function(a, b) {
    return new cc.TransitionProgressHorizontal(a, b)
}, cc.TransitionProgressVertical = cc.TransitionProgress.extend({
    ctor: function(a, b) {
        cc.TransitionProgress.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    _progressTimerNodeWithRenderTexture: function(a) {
        var b = cc.director.getWinSize(),
            c = new cc.ProgressTimer(a.sprite);
        return cc._renderType === cc._RENDER_TYPE_WEBGL && (c.sprite.flippedY = !0), c.type = cc.ProgressTimer.TYPE_BAR, c.midPoint = cc.p(0, 0), c.barChangeRate = cc.p(0, 1), c.percentage = 100, this._setAttrs(c, b.width / 2, b.height / 2), c
    }
}), cc.TransitionProgressVertical.create = function(a, b) {
    return new cc.TransitionProgressVertical(a, b)
}, cc.TransitionProgressInOut = cc.TransitionProgress.extend({
    ctor: function(a, b) {
        cc.TransitionProgress.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    _progressTimerNodeWithRenderTexture: function(a) {
        var b = cc.director.getWinSize(),
            c = new cc.ProgressTimer(a.sprite);
        return cc._renderType === cc._RENDER_TYPE_WEBGL && (c.sprite.flippedY = !0), c.type = cc.ProgressTimer.TYPE_BAR, c.midPoint = cc.p(.5, .5), c.barChangeRate = cc.p(1, 1), c.percentage = 0, this._setAttrs(c, b.width / 2, b.height / 2), c
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !1
    },
    _setupTransition: function() {
        this._sceneToBeModified = this._inScene, this._from = 0, this._to = 100
    }
}), cc.TransitionProgressInOut.create = function(a, b) {
    return new cc.TransitionProgressInOut(a, b)
}, cc.TransitionProgressOutIn = cc.TransitionProgress.extend({
    ctor: function(a, b) {
        cc.TransitionProgress.prototype.ctor.call(this), b && this.initWithDuration(a, b)
    },
    _progressTimerNodeWithRenderTexture: function(a) {
        var b = cc.director.getWinSize(),
            c = new cc.ProgressTimer(a.sprite);
        return cc._renderType === cc._RENDER_TYPE_WEBGL && (c.sprite.flippedY = !0), c.type = cc.ProgressTimer.TYPE_BAR, c.midPoint = cc.p(.5, .5), c.barChangeRate = cc.p(1, 1), c.percentage = 100, this._setAttrs(c, b.width / 2, b.height / 2), c
    }
}), cc.TransitionProgressOutIn.create = function(a, b) {
    return new cc.TransitionProgressOutIn(a, b)
}, cc.TransitionPageTurn = cc.TransitionScene.extend({
    ctor: function(a, b, c) {
        cc.TransitionScene.prototype.ctor.call(this), this._gridProxy = new cc.NodeGrid, this.initWithDuration(a, b, c)
    },
    _back: !0,
    _gridProxy: null,
    _className: "TransitionPageTurn",
    initWithDuration: function(a, b, c) {
        return this._back = c, cc.TransitionScene.prototype.initWithDuration.call(this, a, b), !0
    },
    actionWithSize: function(a) {
        return this._back ? cc.reverseTime(cc.pageTurn3D(this._duration, a)) : cc.pageTurn3D(this._duration, a)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, b, c = cc.director.getWinSize();
        c.width > c.height ? (a = 16, b = 12) : (a = 12, b = 16);
        var d = this.actionWithSize(cc.size(a, b)),
            e = this._gridProxy;
        this._back ? (e.setTarget(this._inScene), e.onEnter(), this._inScene.visible = !1, e.runAction(cc.sequence(d, cc.callFunc(this.finish, this), cc.stopGrid())), this._inScene.runAction(cc.show())) : (e.setTarget(this._outScene), e.onEnter(), e.runAction(cc.sequence(d, cc.callFunc(this.finish, this), cc.stopGrid())))
    },
    visit: function() {
        this._back ? this._outScene.visit() : this._inScene.visit(), this._gridProxy.visit()
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = this._back
    }
}), cc.TransitionPageTurn.create = function(a, b, c) {
    return new cc.TransitionPageTurn(a, b, c)
};
cc.Codec = {
        name: "Jacob__Codec"
    }, cc.unzip = function() {
        return cc.Codec.GZip.gunzip.apply(cc.Codec.GZip, arguments)
    }, cc.unzipBase64 = function() {
        var a = cc.Codec.Base64.decode.apply(cc.Codec.Base64, arguments);
        return cc.Codec.GZip.gunzip.apply(cc.Codec.GZip, [a])
    }, cc.unzipBase64AsArray = function(a, b) {
        b = b || 1;
        var c, d, e, f = this.unzipBase64(a),
            g = [];
        for (c = 0, e = f.length / b; e > c; c++)
            for (g[c] = 0, d = b - 1; d >= 0; --d) g[c] += f.charCodeAt(c * b + d) << 8 * d;
        return g
    }, cc.unzipAsArray = function(a, b) {
        b = b || 1;
        var c, d, e, f = this.unzip(a),
            g = [];
        for (c = 0, e = f.length / b; e > c; c++)
            for (g[c] = 0, d = b - 1; d >= 0; --d) g[c] += f.charCodeAt(c * b + d) << 8 * d;
        return g
    }, cc.StringToArray = function(a) {
        var b, c = a.split(","),
            d = [];
        for (b = 0; b < c.length; b++) d.push(parseInt(c[b]));
        return d
    }, cc.Codec.Base64 = {
        name: "Jacob__Codec__Base64"
    }, cc.Codec.Base64._keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", cc.Codec.Base64.decode = function(a) {
        var b, c, d, e, f, g, h, i = [],
            j = 0;
        for (a = a.replace(/[^A-Za-z0-9\+\/\=]/g, ""); j < a.length;) e = this._keyStr.indexOf(a.charAt(j++)), f = this._keyStr.indexOf(a.charAt(j++)), g = this._keyStr.indexOf(a.charAt(j++)), h = this._keyStr.indexOf(a.charAt(j++)), b = e << 2 | f >> 4, c = (15 & f) << 4 | g >> 2, d = (3 & g) << 6 | h, i.push(String.fromCharCode(b)), 64 != g && i.push(String.fromCharCode(c)), 64 != h && i.push(String.fromCharCode(d));
        return i = i.join("")
    }, cc.Codec.Base64.decodeAsArray = function(a, b) {
        var c, d, e, f = this.decode(a),
            g = [];
        for (c = 0, e = f.length / b; e > c; c++)
            for (g[c] = 0, d = b - 1; d >= 0; --d) g[c] += f.charCodeAt(c * b + d) << 8 * d;
        return g
    }, cc.uint8ArrayToUint32Array = function(a) {
        if (a.length % 4 != 0) return null;
        for (var b = a.length / 4, c = window.Uint32Array ? new Uint32Array(b) : [], d = 0; b > d; d++) {
            var e = 4 * d;
            c[d] = a[e] + 256 * a[e + 1] + 65536 * a[e + 2] + a[e + 3] * (1 << 24)
        }
        return c
    }, cc.Codec.GZip = function(a) {
        this.data = a, this.debug = !1, this.gpflags = void 0, this.files = 0, this.unzipped = [], this.buf32k = new Array(32768), this.bIdx = 0, this.modeZIP = !1, this.bytepos = 0, this.bb = 1, this.bits = 0, this.nameBuf = [], this.fileout = void 0, this.literalTree = new Array(cc.Codec.GZip.LITERALS), this.distanceTree = new Array(32), this.treepos = 0, this.Places = null, this.len = 0, this.fpos = new Array(17), this.fpos[0] = 0, this.flens = void 0, this.fmax = void 0
    }, cc.Codec.GZip.gunzip = function(a) {
        a.constructor === Array || a.constructor === String;
        var b = new cc.Codec.GZip(a);
        return b.gunzip()[0][0]
    }, cc.Codec.GZip.HufNode = function() {
        this.b0 = 0, this.b1 = 0, this.jump = null, this.jumppos = -1
    }, cc.Codec.GZip.LITERALS = 288, cc.Codec.GZip.NAMEMAX = 256, cc.Codec.GZip.bitReverse = [0, 128, 64, 192, 32, 160, 96, 224, 16, 144, 80, 208, 48, 176, 112, 240, 8, 136, 72, 200, 40, 168, 104, 232, 24, 152, 88, 216, 56, 184, 120, 248, 4, 132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52, 180, 116, 244, 12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, 226, 18, 146, 82, 210, 50, 178, 114, 242, 10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250, 6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246, 14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254, 1, 129, 65, 193, 33, 161, 97, 225, 17, 145, 81, 209, 49, 177, 113, 241, 9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249, 5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245, 13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253, 3, 131, 67, 195, 35, 163, 99, 227, 19, 147, 83, 211, 51, 179, 115, 243, 11, 139, 75, 203, 43, 171, 107, 235, 27, 155, 91, 219, 59, 187, 123, 251, 7, 135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247, 15, 143, 79, 207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127, 255], cc.Codec.GZip.cplens = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], cc.Codec.GZip.cplext = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99], cc.Codec.GZip.cpdist = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577], cc.Codec.GZip.cpdext = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], cc.Codec.GZip.border = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], cc.Codec.GZip.prototype.gunzip = function() {
        return this.outputArr = [], this.nextFile(), this.unzipped
    }, cc.Codec.GZip.prototype.readByte = function() {
        return this.bits += 8, this.bytepos < this.data.length ? this.data.charCodeAt(this.bytepos++) : -1
    }, cc.Codec.GZip.prototype.byteAlign = function() {
        this.bb = 1
    }, cc.Codec.GZip.prototype.readBit = function() {
        var a;
        return this.bits++, a = 1 & this.bb, this.bb >>= 1, 0 == this.bb && (this.bb = this.readByte(), a = 1 & this.bb, this.bb = this.bb >> 1 | 128), a
    }, cc.Codec.GZip.prototype.readBits = function(a) {
        for (var b = 0, c = a; c--;) b = b << 1 | this.readBit();
        return a && (b = cc.Codec.GZip.bitReverse[b] >> 8 - a), b
    }, cc.Codec.GZip.prototype.flushBuffer = function() {
        this.bIdx = 0
    }, cc.Codec.GZip.prototype.addBuffer = function(a) {
        this.buf32k[this.bIdx++] = a, this.outputArr.push(String.fromCharCode(a)), 32768 == this.bIdx && (this.bIdx = 0)
    }, cc.Codec.GZip.prototype.IsPat = function() {
        for (;;) {
            if (this.fpos[this.len] >= this.fmax) return -1;
            if (this.flens[this.fpos[this.len]] == this.len) return this.fpos[this.len]++;
            this.fpos[this.len]++
        }
    }, cc.Codec.GZip.prototype.Rec = function() {
        var a, b = this.Places[this.treepos];
        if (17 == this.len) return -1;
        if (this.treepos++, this.len++, a = this.IsPat(), a >= 0) b.b0 = a;
        else if (b.b0 = 32768, this.Rec()) return -1;
        if (a = this.IsPat(), a >= 0) b.b1 = a, b.jump = null;
        else if (b.b1 = 32768, b.jump = this.Places[this.treepos], b.jumppos = this.treepos, this.Rec()) return -1;
        return this.len--, 0
    }, cc.Codec.GZip.prototype.CreateTree = function(a, b, c) {
        var d;
        for (this.Places = a, this.treepos = 0, this.flens = c, this.fmax = b, d = 0; 17 > d; d++) this.fpos[d] = 0;
        return this.len = 0, this.Rec() ? -1 : 0
    }, cc.Codec.GZip.prototype.DecodeValue = function(a) {
        for (var b, c, d, e = 0, f = a[e];;)
            if (d = this.readBit()) {
                if (!(32768 & f.b1)) return f.b1;
                for (f = f.jump, b = a.length, c = 0; b > c; c++)
                    if (a[c] === f) {
                        e = c;
                        break
                    }
            } else {
                if (!(32768 & f.b0)) return f.b0;
                e++, f = a[e]
            }
        return -1
    }, cc.Codec.GZip.prototype.DeflateLoop = function() {
        var a, b, c, d, e;
        do
            if (a = this.readBit(), c = this.readBits(2), 0 == c) {
                var f, g;
                for (this.byteAlign(), f = this.readByte(), f |= this.readByte() << 8, g = this.readByte(), g |= this.readByte() << 8, 65535 & (f ^ ~g) && document.write("BlockLen checksum mismatch\n"); f--;) b = this.readByte(), this.addBuffer(b)
            } else if (1 == c)
            for (var h;;)
                if (h = cc.Codec.GZip.bitReverse[this.readBits(7)] >> 1, h > 23 ? (h = h << 1 | this.readBit(), h > 199 ? (h -= 128, h = h << 1 | this.readBit()) : (h -= 48, h > 143 && (h += 136))) : h += 256, 256 > h) this.addBuffer(h);
                else {
                    if (256 == h) break;
                    var e, i;
                    for (h -= 257, e = this.readBits(cc.Codec.GZip.cplext[h]) + cc.Codec.GZip.cplens[h], h = cc.Codec.GZip.bitReverse[this.readBits(5)] >> 3, cc.Codec.GZip.cpdext[h] > 8 ? (i = this.readBits(8), i |= this.readBits(cc.Codec.GZip.cpdext[h] - 8) << 8) : i = this.readBits(cc.Codec.GZip.cpdext[h]), i += cc.Codec.GZip.cpdist[h], h = 0; e > h; h++) {
                        var b = this.buf32k[this.bIdx - i & 32767];
                        this.addBuffer(b)
                    }
                } else
        if (2 == c) {
            var h, j, k, l, m, n = new Array(320);
            for (k = 257 + this.readBits(5), l = 1 + this.readBits(5), m = 4 + this.readBits(4), h = 0; 19 > h; h++) n[h] = 0;
            for (h = 0; m > h; h++) n[cc.Codec.GZip.border[h]] = this.readBits(3);
            for (e = this.distanceTree.length, d = 0; e > d; d++) this.distanceTree[d] = new cc.Codec.GZip.HufNode;
            if (this.CreateTree(this.distanceTree, 19, n, 0)) return this.flushBuffer(), 1;
            j = k + l, d = 0;
            for (var o = -1; j > d;)
                if (o++, h = this.DecodeValue(this.distanceTree), 16 > h) n[d++] = h;
                else if (16 == h) {
                var p;
                if (h = 3 + this.readBits(2), d + h > j) return this.flushBuffer(), 1;
                for (p = d ? n[d - 1] : 0; h--;) n[d++] = p
            } else {
                if (h = 17 == h ? 3 + this.readBits(3) : 11 + this.readBits(7), d + h > j) return this.flushBuffer(), 1;
                for (; h--;) n[d++] = 0
            }
            for (e = this.literalTree.length, d = 0; e > d; d++) this.literalTree[d] = new cc.Codec.GZip.HufNode;
            if (this.CreateTree(this.literalTree, k, n, 0)) return this.flushBuffer(), 1;
            for (e = this.literalTree.length, d = 0; e > d; d++) this.distanceTree[d] = new cc.Codec.GZip.HufNode;
            var q = new Array;
            for (d = k; d < n.length; d++) q[d - k] = n[d];
            if (this.CreateTree(this.distanceTree, l, q, 0)) return this.flushBuffer(), 1;
            for (;;)
                if (h = this.DecodeValue(this.literalTree), h >= 256) {
                    var e, i;
                    if (h -= 256, 0 == h) break;
                    for (h--, e = this.readBits(cc.Codec.GZip.cplext[h]) + cc.Codec.GZip.cplens[h], h = this.DecodeValue(this.distanceTree), cc.Codec.GZip.cpdext[h] > 8 ? (i = this.readBits(8), i |= this.readBits(cc.Codec.GZip.cpdext[h] - 8) << 8) : i = this.readBits(cc.Codec.GZip.cpdext[h]), i += cc.Codec.GZip.cpdist[h]; e--;) {
                        var b = this.buf32k[this.bIdx - i & 32767];
                        this.addBuffer(b)
                    }
                } else this.addBuffer(h)
        }
        while (!a);
        return this.flushBuffer(), this.byteAlign(), 0
    }, cc.Codec.GZip.prototype.unzipFile = function(a) {
        var b;
        for (this.gunzip(), b = 0; b < this.unzipped.length; b++)
            if (this.unzipped[b][1] == a) return this.unzipped[b][0]
    }, cc.Codec.GZip.prototype.nextFile = function() {
        this.outputArr = [], this.modeZIP = !1;
        var a = [];
        if (a[0] = this.readByte(), a[1] = this.readByte(), 120 == a[0] && 218 == a[1] && (this.DeflateLoop(), this.unzipped[this.files] = [this.outputArr.join(""), "geonext.gxt"], this.files++), 31 == a[0] && 139 == a[1] && (this.skipdir(), this.unzipped[this.files] = [this.outputArr.join(""), "file"], this.files++), 80 == a[0] && 75 == a[1] && (this.modeZIP = !0, a[2] = this.readByte(), a[3] = this.readByte(), 3 == a[2] && 4 == a[3])) {
            a[0] = this.readByte(), a[1] = this.readByte(), this.gpflags = this.readByte(), this.gpflags |= this.readByte() << 8;
            var b = this.readByte();
            b |= this.readByte() << 8, this.readByte(), this.readByte(), this.readByte(), this.readByte();
            var c = this.readByte();
            c |= this.readByte() << 8, c |= this.readByte() << 16, c |= this.readByte() << 24;
            var d = this.readByte();
            d |= this.readByte() << 8, d |= this.readByte() << 16, d |= this.readByte() << 24;
            var e = this.readByte();
            e |= this.readByte() << 8;
            var f = this.readByte();
            for (f |= this.readByte() << 8, h = 0, this.nameBuf = []; e--;) {
                var g = this.readByte();
                "/" == g | ":" == g ? h = 0 : h < cc.Codec.GZip.NAMEMAX - 1 && (this.nameBuf[h++] = String.fromCharCode(g))
            }
            this.fileout || (this.fileout = this.nameBuf);
            for (var h = 0; f > h;) g = this.readByte(), h++;
            8 == b && (this.DeflateLoop(), this.unzipped[this.files] = [this.outputArr.join(""), this.nameBuf.join("")], this.files++), this.skipdir()
        }
    }, cc.Codec.GZip.prototype.skipdir = function() {
        var a, b, c, d, e, f = [];
        if (8 & this.gpflags && (f[0] = this.readByte(), f[1] = this.readByte(), f[2] = this.readByte(), f[3] = this.readByte(), a = this.readByte(), a |= this.readByte() << 8, a |= this.readByte() << 16, a |= this.readByte() << 24, b = this.readByte(), b |= this.readByte() << 8, b |= this.readByte() << 16, b |= this.readByte() << 24), this.modeZIP && this.nextFile(), f[0] = this.readByte(), 8 != f[0]) return 0;
        if (this.gpflags = this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), c = this.readByte(), 4 & this.gpflags)
            for (f[0] = this.readByte(), f[2] = this.readByte(), this.len = f[0] + 256 * f[1], d = 0; d < this.len; d++) this.readByte();
        if (8 & this.gpflags)
            for (d = 0, this.nameBuf = []; e = this.readByte();)("7" == e || ":" == e) && (d = 0), d < cc.Codec.GZip.NAMEMAX - 1 && (this.nameBuf[d++] = e);
        if (16 & this.gpflags)
            for (; e = this.readByte(););
        2 & this.gpflags && (this.readByte(), this.readByte()), this.DeflateLoop(), b = this.readByte(), b |= this.readByte() << 8, b |= this.readByte() << 16, b |= this.readByte() << 24, this.modeZIP && this.nextFile()
    },
    function() {
        "use strict";

        function a(a) {
            throw a
        }

        function b(a, b) {
            var c = a.split("."),
                d = u;
            !(c[0] in d) && d.execScript && d.execScript("var " + c[0]);
            for (var e; c.length && (e = c.shift());) c.length || b === s ? d = d[e] ? d[e] : d[e] = {} : d[e] = b
        }

        function c(a) {
            if ("string" == typeof a) {
                var b, c, d = a.split("");
                for (b = 0, c = d.length; c > b; b++) d[b] = (255 & d[b].charCodeAt(0)) >>> 0;
                a = d
            }
            for (var e, f = 1, g = 0, h = a.length, i = 0; h > 0;) {
                e = h > 1024 ? 1024 : h, h -= e;
                do f += a[i++], g += f; while (--e);
                f %= 65521, g %= 65521
            }
            return (g << 16 | f) >>> 0
        }

        function d(b, c) {
            this.index = "number" == typeof c ? c : 0, this.i = 0, this.buffer = b instanceof(v ? Uint8Array : Array) ? b : new(v ? Uint8Array : Array)(32768), 2 * this.buffer.length <= this.index && a(Error("invalid index")), this.buffer.length <= this.index && this.f()
        }

        function e(a) {
            this.buffer = new(v ? Uint16Array : Array)(2 * a), this.length = 0
        }

        function f(a) {
            var b, c, d, e, f, g, h, i, j, k = a.length,
                l = 0,
                m = Number.POSITIVE_INFINITY;
            for (i = 0; k > i; ++i) a[i] > l && (l = a[i]), a[i] < m && (m = a[i]);
            for (b = 1 << l, c = new(v ? Uint32Array : Array)(b), d = 1, e = 0, f = 2; l >= d;) {
                for (i = 0; k > i; ++i)
                    if (a[i] === d) {
                        for (g = 0, h = e, j = 0; d > j; ++j) g = g << 1 | 1 & h, h >>= 1;
                        for (j = g; b > j; j += f) c[j] = d << 16 | i;
                        ++e
                    }++d, e <<= 1, f <<= 1
            }
            return [c, l, m]
        }

        function g(a, b) {
            this.h = E, this.w = 0, this.input = a, this.b = 0, b && (b.lazy && (this.w = b.lazy), "number" == typeof b.compressionType && (this.h = b.compressionType), b.outputBuffer && (this.a = v && b.outputBuffer instanceof Array ? new Uint8Array(b.outputBuffer) : b.outputBuffer), "number" == typeof b.outputIndex && (this.b = b.outputIndex)), this.a || (this.a = new(v ? Uint8Array : Array)(32768))
        }

        function h(a, b) {
            this.length = a, this.G = b
        }

        function i() {
            var b = H;
            switch (t) {
                case 3 === b:
                    return [257, b - 3, 0];
                case 4 === b:
                    return [258, b - 4, 0];
                case 5 === b:
                    return [259, b - 5, 0];
                case 6 === b:
                    return [260, b - 6, 0];
                case 7 === b:
                    return [261, b - 7, 0];
                case 8 === b:
                    return [262, b - 8, 0];
                case 9 === b:
                    return [263, b - 9, 0];
                case 10 === b:
                    return [264, b - 10, 0];
                case 12 >= b:
                    return [265, b - 11, 1];
                case 14 >= b:
                    return [266, b - 13, 1];
                case 16 >= b:
                    return [267, b - 15, 1];
                case 18 >= b:
                    return [268, b - 17, 1];
                case 22 >= b:
                    return [269, b - 19, 2];
                case 26 >= b:
                    return [270, b - 23, 2];
                case 30 >= b:
                    return [271, b - 27, 2];
                case 34 >= b:
                    return [272, b - 31, 2];
                case 42 >= b:
                    return [273, b - 35, 3];
                case 50 >= b:
                    return [274, b - 43, 3];
                case 58 >= b:
                    return [275, b - 51, 3];
                case 66 >= b:
                    return [276, b - 59, 3];
                case 82 >= b:
                    return [277, b - 67, 4];
                case 98 >= b:
                    return [278, b - 83, 4];
                case 114 >= b:
                    return [279, b - 99, 4];
                case 130 >= b:
                    return [280, b - 115, 4];
                case 162 >= b:
                    return [281, b - 131, 5];
                case 194 >= b:
                    return [282, b - 163, 5];
                case 226 >= b:
                    return [283, b - 195, 5];
                case 257 >= b:
                    return [284, b - 227, 5];
                case 258 === b:
                    return [285, b - 258, 0];
                default:
                    a("invalid length: " + b)
            }
        }

        function j(b, c) {
            function d(b, c) {
                var d, e = b.G,
                    f = [],
                    g = 0;
                d = K[b.length], f[g++] = 65535 & d, f[g++] = d >> 16 & 255, f[g++] = d >> 24;
                var h;
                switch (t) {
                    case 1 === e:
                        h = [0, e - 1, 0];
                        break;
                    case 2 === e:
                        h = [1, e - 2, 0];
                        break;
                    case 3 === e:
                        h = [2, e - 3, 0];
                        break;
                    case 4 === e:
                        h = [3, e - 4, 0];
                        break;
                    case 6 >= e:
                        h = [4, e - 5, 1];
                        break;
                    case 8 >= e:
                        h = [5, e - 7, 1];
                        break;
                    case 12 >= e:
                        h = [6, e - 9, 2];
                        break;
                    case 16 >= e:
                        h = [7, e - 13, 2];
                        break;
                    case 24 >= e:
                        h = [8, e - 17, 3];
                        break;
                    case 32 >= e:
                        h = [9, e - 25, 3];
                        break;
                    case 48 >= e:
                        h = [10, e - 33, 4];
                        break;
                    case 64 >= e:
                        h = [11, e - 49, 4];
                        break;
                    case 96 >= e:
                        h = [12, e - 65, 5];
                        break;
                    case 128 >= e:
                        h = [13, e - 97, 5];
                        break;
                    case 192 >= e:
                        h = [14, e - 129, 6];
                        break;
                    case 256 >= e:
                        h = [15, e - 193, 6];
                        break;
                    case 384 >= e:
                        h = [16, e - 257, 7];
                        break;
                    case 512 >= e:
                        h = [17, e - 385, 7];
                        break;
                    case 768 >= e:
                        h = [18, e - 513, 8];
                        break;
                    case 1024 >= e:
                        h = [19, e - 769, 8];
                        break;
                    case 1536 >= e:
                        h = [20, e - 1025, 9];
                        break;
                    case 2048 >= e:
                        h = [21, e - 1537, 9];
                        break;
                    case 3072 >= e:
                        h = [22, e - 2049, 10];
                        break;
                    case 4096 >= e:
                        h = [23, e - 3073, 10];
                        break;
                    case 6144 >= e:
                        h = [24, e - 4097, 11];
                        break;
                    case 8192 >= e:
                        h = [25, e - 6145, 11];
                        break;
                    case 12288 >= e:
                        h = [26, e - 8193, 12];
                        break;
                    case 16384 >= e:
                        h = [27, e - 12289, 12];
                        break;
                    case 24576 >= e:
                        h = [28, e - 16385, 13];
                        break;
                    case 32768 >= e:
                        h = [29, e - 24577, 13];
                        break;
                    default:
                        a("invalid distance")
                }
                d = h, f[g++] = d[0], f[g++] = d[1], f[g++] = d[2];
                var i, j;
                for (i = 0, j = f.length; j > i; ++i) p[q++] = f[i];
                u[f[0]]++, w[f[3]]++, r = b.length + c - 1, m = null
            }
            var e, f, g, i, j, k, l, m, n, o = {},
                p = v ? new Uint16Array(2 * c.length) : [],
                q = 0,
                r = 0,
                u = new(v ? Uint32Array : Array)(286),
                w = new(v ? Uint32Array : Array)(30),
                x = b.w;
            if (!v) {
                for (g = 0; 285 >= g;) u[g++] = 0;
                for (g = 0; 29 >= g;) w[g++] = 0
            }
            for (u[256] = 1, e = 0, f = c.length; f > e; ++e) {
                for (g = j = 0, i = 3; i > g && e + g !== f; ++g) j = j << 8 | c[e + g];
                if (o[j] === s && (o[j] = []), k = o[j], !(0 < r--)) {
                    for (; 0 < k.length && 32768 < e - k[0];) k.shift();
                    if (e + 3 >= f) {
                        for (m && d(m, -1), g = 0, i = f - e; i > g; ++g) n = c[e + g], p[q++] = n, ++u[n];
                        break
                    }
                    if (0 < k.length) {
                        var y = s,
                            z = s,
                            A = 0,
                            B = s,
                            C = s,
                            D = s,
                            E = s,
                            F = c.length,
                            C = 0,
                            E = k.length;
                        a: for (; E > C; C++) {
                            if (y = k[E - C - 1], B = 3, A > 3) {
                                for (D = A; D > 3; D--)
                                    if (c[y + D - 1] !== c[e + D - 1]) continue a;
                                B = A
                            }
                            for (; 258 > B && F > e + B && c[y + B] === c[e + B];)++B;
                            if (B > A && (z = y, A = B), 258 === B) break
                        }
                        l = new h(A, e - z), m ? m.length < l.length ? (n = c[e - 1], p[q++] = n, ++u[n], d(l, 0)) : d(m, -1) : l.length < x ? m = l : d(l, 0)
                    } else m ? d(m, -1) : (n = c[e], p[q++] = n, ++u[n])
                }
                k.push(e)
            }
            return p[q++] = 256, u[256]++, b.L = u, b.K = w, v ? p.subarray(0, q) : p
        }

        function k(a, b) {
            function c(a) {
                var b = x[a][y[a]];
                b === r ? (c(a + 1), c(a + 1)) : --u[b], ++y[a]
            }
            var d, f, g, h, i, j = a.length,
                k = new e(572),
                l = new(v ? Uint8Array : Array)(j);
            if (!v)
                for (h = 0; j > h; h++) l[h] = 0;
            for (h = 0; j > h; ++h) 0 < a[h] && k.push(h, a[h]);
            if (d = Array(k.length / 2), f = new(v ? Uint32Array : Array)(k.length / 2), 1 === d.length) return l[k.pop().index] = 1, l;
            for (h = 0, i = k.length / 2; i > h; ++h) d[h] = k.pop(), f[h] = d[h].value;
            var m, n, o, p, q, r = f.length,
                s = new(v ? Uint16Array : Array)(b),
                t = new(v ? Uint8Array : Array)(b),
                u = new(v ? Uint8Array : Array)(r),
                w = Array(b),
                x = Array(b),
                y = Array(b),
                z = (1 << b) - r,
                A = 1 << b - 1;
            for (s[b - 1] = r, n = 0; b > n; ++n) A > z ? t[n] = 0 : (t[n] = 1, z -= A), z <<= 1, s[b - 2 - n] = (s[b - 1 - n] / 2 | 0) + r;
            for (s[0] = t[0], w[0] = Array(s[0]), x[0] = Array(s[0]), n = 1; b > n; ++n) s[n] > 2 * s[n - 1] + t[n] && (s[n] = 2 * s[n - 1] + t[n]), w[n] = Array(s[n]), x[n] = Array(s[n]);
            for (m = 0; r > m; ++m) u[m] = b;
            for (o = 0; o < s[b - 1]; ++o) w[b - 1][o] = f[o], x[b - 1][o] = o;
            for (m = 0; b > m; ++m) y[m] = 0;
            for (1 === t[b - 1] && (--u[0], ++y[b - 1]), n = b - 2; n >= 0; --n) {
                for (p = m = 0, q = y[n + 1], o = 0; o < s[n]; o++) p = w[n + 1][q] + w[n + 1][q + 1], p > f[m] ? (w[n][o] = p, x[n][o] = r, q += 2) : (w[n][o] = f[m], x[n][o] = m, ++m);
                y[n] = 0, 1 === t[n] && c(n)
            }
            for (g = u, h = 0, i = d.length; i > h; ++h) l[d[h].index] = g[h];
            return l
        }

        function l(b) {
            var c, d, e, f, g = new(v ? Uint16Array : Array)(b.length),
                h = [],
                i = [],
                j = 0;
            for (c = 0, d = b.length; d > c; c++) h[b[c]] = (0 | h[b[c]]) + 1;
            for (c = 1, d = 16; d >= c; c++) i[c] = j, j += 0 | h[c], j > 1 << c && a("overcommitted"), j <<= 1;
            for (65536 > j && a("undercommitted"), c = 0, d = b.length; d > c; c++)
                for (j = i[b[c]], i[b[c]] += 1, e = g[c] = 0, f = b[c]; f > e; e++) g[c] = g[c] << 1 | 1 & j, j >>>= 1;
            return g
        }

        function m(a, b) {
            this.input = a, this.a = new(v ? Uint8Array : Array)(32768), this.h = L.j;
            var c, d = {};
            !b && (b = {}) || "number" != typeof b.compressionType || (this.h = b.compressionType);
            for (c in b) d[c] = b[c];
            d.outputBuffer = this.a, this.z = new g(this.input, d)
        }

        function n(b, c) {
            switch (this.k = [], this.l = 32768, this.e = this.g = this.c = this.q = 0, this.input = v ? new Uint8Array(b) : b, this.s = !1, this.m = N, this.B = !1, (c || !(c = {})) && (c.index && (this.c = c.index), c.bufferSize && (this.l = c.bufferSize), c.bufferType && (this.m = c.bufferType), c.resize && (this.B = c.resize)), this.m) {
                case M:
                    this.b = 32768, this.a = new(v ? Uint8Array : Array)(32768 + this.l + 258);
                    break;
                case N:
                    this.b = 0, this.a = new(v ? Uint8Array : Array)(this.l), this.f = this.J, this.t = this.H, this.o = this.I;
                    break;
                default:
                    a(Error("invalid inflate mode"))
            }
        }

        function o(b, c) {
            for (var d, e = b.g, f = b.e, g = b.input, h = b.c; c > f;) d = g[h++], d === s && a(Error("input buffer is broken")), e |= d << f, f += 8;
            return d = e & (1 << c) - 1, b.g = e >>> c, b.e = f - c, b.c = h, d
        }

        function p(b, c) {
            for (var d, e, f, g = b.g, h = b.e, i = b.input, j = b.c, k = c[0], l = c[1]; l > h;) d = i[j++], d === s && a(Error("input buffer is broken")), g |= d << h, h += 8;
            return e = k[g & (1 << l) - 1], f = e >>> 16, b.g = g >> f, b.e = h - f, b.c = j, 65535 & e
        }

        function q(a) {
            function b(a, b, c) {
                var d, e, f, g;
                for (g = 0; a > g;) switch (d = p(this, b)) {
                    case 16:
                        for (f = 3 + o(this, 2); f--;) c[g++] = e;
                        break;
                    case 17:
                        for (f = 3 + o(this, 3); f--;) c[g++] = 0;
                        e = 0;
                        break;
                    case 18:
                        for (f = 11 + o(this, 7); f--;) c[g++] = 0;
                        e = 0;
                        break;
                    default:
                        e = c[g++] = d
                }
                return c
            }
            var c, d, e, g, h = o(a, 5) + 257,
                i = o(a, 5) + 1,
                j = o(a, 4) + 4,
                k = new(v ? Uint8Array : Array)(S.length);
            for (g = 0; j > g; ++g) k[S[g]] = o(a, 3);
            c = f(k), d = new(v ? Uint8Array : Array)(h), e = new(v ? Uint8Array : Array)(i), a.o(f(b.call(a, h, c, d)), f(b.call(a, i, c, e)))
        }

        function r(b, c) {
            var d, e;
            switch (this.input = b, this.c = 0, (c || !(c = {})) && (c.index && (this.c = c.index), c.verify && (this.M = c.verify)), d = b[this.c++], e = b[this.c++], 15 & d) {
                case qb:
                    this.method = qb;
                    break;
                default:
                    a(Error("unsupported compression method"))
            }
            0 !== ((d << 8) + e) % 31 && a(Error("invalid fcheck flag:" + ((d << 8) + e) % 31)), 32 & e && a(Error("fdict flag is not supported")), this.A = new n(b, {
                index: this.c,
                bufferSize: c.bufferSize,
                bufferType: c.bufferType,
                resize: c.resize
            })
        }
        var s = void 0,
            t = !0,
            u = this,
            v = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array;
        d.prototype.f = function() {
            var a, b = this.buffer,
                c = b.length,
                d = new(v ? Uint8Array : Array)(c << 1);
            if (v) d.set(b);
            else
                for (a = 0; c > a; ++a) d[a] = b[a];
            return this.buffer = d
        }, d.prototype.d = function(a, b, c) {
            var d, e = this.buffer,
                f = this.index,
                g = this.i,
                h = e[f];
            if (c && b > 1 && (a = b > 8 ? (B[255 & a] << 24 | B[a >>> 8 & 255] << 16 | B[a >>> 16 & 255] << 8 | B[a >>> 24 & 255]) >> 32 - b : B[a] >> 8 - b), 8 > b + g) h = h << b | a, g += b;
            else
                for (d = 0; b > d; ++d) h = h << 1 | a >> b - d - 1 & 1, 8 === ++g && (g = 0, e[f++] = B[h], h = 0, f === e.length && (e = this.f()));
            e[f] = h, this.buffer = e, this.i = g, this.index = f
        }, d.prototype.finish = function() {
            var a, b = this.buffer,
                c = this.index;
            return 0 < this.i && (b[c] <<= 8 - this.i, b[c] = B[b[c]], c++), v ? a = b.subarray(0, c) : (b.length = c, a = b), a
        };
        var w, x = new(v ? Uint8Array : Array)(256);
        for (w = 0; 256 > w; ++w) {
            for (var y = w, z = y, A = 7, y = y >>> 1; y; y >>>= 1) z <<= 1, z |= 1 & y, --A;
            x[w] = (z << A & 255) >>> 0
        }
        var B = x,
            C = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117];
        v && new Uint32Array(C), e.prototype.getParent = function(a) {
            return 2 * ((a - 2) / 4 | 0)
        }, e.prototype.push = function(a, b) {
            var c, d, e, f = this.buffer;
            for (c = this.length, f[this.length++] = b, f[this.length++] = a; c > 0 && (d = this.getParent(c), f[c] > f[d]);) e = f[c], f[c] = f[d], f[d] = e, e = f[c + 1], f[c + 1] = f[d + 1], f[d + 1] = e, c = d;
            return this.length
        }, e.prototype.pop = function() {
            var a, b, c, d, e, f = this.buffer;
            for (b = f[0], a = f[1], this.length -= 2, f[0] = f[this.length], f[1] = f[this.length + 1], e = 0;
                (d = 2 * e + 2, !(d >= this.length)) && (d + 2 < this.length && f[d + 2] > f[d] && (d += 2), f[d] > f[e]);) c = f[e], f[e] = f[d], f[d] = c, c = f[e + 1], f[e + 1] = f[d + 1], f[d + 1] = c, e = d;
            return {
                index: a,
                value: b,
                length: this.length
            }
        };
        var D, E = 2,
            F = {
                NONE: 0,
                r: 1,
                j: E,
                N: 3
            },
            G = [];
        for (D = 0; 288 > D; D++) switch (t) {
            case 143 >= D:
                G.push([D + 48, 8]);
                break;
            case 255 >= D:
                G.push([D - 144 + 400, 9]);
                break;
            case 279 >= D:
                G.push([D - 256 + 0, 7]);
                break;
            case 287 >= D:
                G.push([D - 280 + 192, 8]);
                break;
            default:
                a("invalid literal: " + D)
        }
        g.prototype.n = function() {
            var b, c, e, f, g = this.input;
            switch (this.h) {
                case 0:
                    for (e = 0, f = g.length; f > e;) {
                        c = v ? g.subarray(e, e + 65535) : g.slice(e, e + 65535), e += c.length;
                        var h = c,
                            i = e === f,
                            m = s,
                            n = s,
                            o = s,
                            p = s,
                            q = s,
                            r = this.a,
                            u = this.b;
                        if (v) {
                            for (r = new Uint8Array(this.a.buffer); r.length <= u + h.length + 5;) r = new Uint8Array(r.length << 1);
                            r.set(this.a)
                        }
                        if (m = i ? 1 : 0, r[u++] = 0 | m, n = h.length, o = ~n + 65536 & 65535, r[u++] = 255 & n, r[u++] = n >>> 8 & 255, r[u++] = 255 & o, r[u++] = o >>> 8 & 255, v) r.set(h, u), u += h.length, r = r.subarray(0, u);
                        else {
                            for (p = 0, q = h.length; q > p; ++p) r[u++] = h[p];
                            r.length = u
                        }
                        this.b = u, this.a = r
                    }
                    break;
                case 1:
                    var w = new d(new Uint8Array(this.a.buffer), this.b);
                    w.d(1, 1, t), w.d(1, 2, t);
                    var x, y, z, A = j(this, g);
                    for (x = 0, y = A.length; y > x; x++)
                        if (z = A[x], d.prototype.d.apply(w, G[z]), z > 256) w.d(A[++x], A[++x], t), w.d(A[++x], 5), w.d(A[++x], A[++x], t);
                        else if (256 === z) break;
                    this.a = w.finish(), this.b = this.a.length;
                    break;
                case E:
                    var B, C, D, F, H, I, J, K, L, M, N, O, P, Q, R, S = new d(new Uint8Array(this.a), this.b),
                        T = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
                        U = Array(19);
                    for (B = E, S.d(1, 1, t), S.d(B, 2, t), C = j(this, g), I = k(this.L, 15), J = l(I), K = k(this.K, 7), L = l(K), D = 286; D > 257 && 0 === I[D - 1]; D--);
                    for (F = 30; F > 1 && 0 === K[F - 1]; F--);
                    var V, W, X, Y, Z, $, _ = D,
                        ab = F,
                        bb = new(v ? Uint32Array : Array)(_ + ab),
                        cb = new(v ? Uint32Array : Array)(316),
                        db = new(v ? Uint8Array : Array)(19);
                    for (V = W = 0; _ > V; V++) bb[W++] = I[V];
                    for (V = 0; ab > V; V++) bb[W++] = K[V];
                    if (!v)
                        for (V = 0, Y = db.length; Y > V; ++V) db[V] = 0;
                    for (V = Z = 0, Y = bb.length; Y > V; V += W) {
                        for (W = 1; Y > V + W && bb[V + W] === bb[V]; ++W);
                        if (X = W, 0 === bb[V])
                            if (3 > X)
                                for (; 0 < X--;) cb[Z++] = 0, db[0]++;
                            else
                                for (; X > 0;) $ = 138 > X ? X : 138, $ > X - 3 && X > $ && ($ = X - 3), 10 >= $ ? (cb[Z++] = 17, cb[Z++] = $ - 3, db[17]++) : (cb[Z++] = 18, cb[Z++] = $ - 11, db[18]++), X -= $;
                        else if (cb[Z++] = bb[V], db[bb[V]]++, X--, 3 > X)
                            for (; 0 < X--;) cb[Z++] = bb[V], db[bb[V]]++;
                        else
                            for (; X > 0;) $ = 6 > X ? X : 6, $ > X - 3 && X > $ && ($ = X - 3), cb[Z++] = 16, cb[Z++] = $ - 3, db[16]++, X -= $
                    }
                    for (b = v ? cb.subarray(0, Z) : cb.slice(0, Z), M = k(db, 7), Q = 0; 19 > Q; Q++) U[Q] = M[T[Q]];
                    for (H = 19; H > 4 && 0 === U[H - 1]; H--);
                    for (N = l(M), S.d(D - 257, 5, t), S.d(F - 1, 5, t), S.d(H - 4, 4, t), Q = 0; H > Q; Q++) S.d(U[Q], 3, t);
                    for (Q = 0, R = b.length; R > Q; Q++)
                        if (O = b[Q], S.d(N[O], M[O], t), O >= 16) {
                            switch (Q++, O) {
                                case 16:
                                    P = 2;
                                    break;
                                case 17:
                                    P = 3;
                                    break;
                                case 18:
                                    P = 7;
                                    break;
                                default:
                                    a("invalid code: " + O)
                            }
                            S.d(b[Q], P, t)
                        }
                    var eb, fb, gb, hb, ib, jb, kb, lb, mb = [J, I],
                        nb = [L, K];
                    for (ib = mb[0], jb = mb[1], kb = nb[0], lb = nb[1], eb = 0, fb = C.length; fb > eb; ++eb)
                        if (gb = C[eb], S.d(ib[gb], jb[gb], t), gb > 256) S.d(C[++eb], C[++eb], t), hb = C[++eb], S.d(kb[hb], lb[hb], t), S.d(C[++eb], C[++eb], t);
                        else if (256 === gb) break;
                    this.a = S.finish(), this.b = this.a.length;
                    break;
                default:
                    a("invalid compression type")
            }
            return this.a
        };
        var H, I, J = [];
        for (H = 3; 258 >= H; H++) I = i(), J[H] = I[2] << 24 | I[1] << 16 | I[0];
        var K = v ? new Uint32Array(J) : J,
            L = F;
        m.prototype.n = function() {
            var b, d, e, f, g, h, i, j = 0;
            switch (i = this.a, b = qb) {
                case qb:
                    d = Math.LOG2E * Math.log(32768) - 8;
                    break;
                default:
                    a(Error("invalid compression method"))
            }
            switch (e = d << 4 | b, i[j++] = e, b) {
                case qb:
                    switch (this.h) {
                        case L.NONE:
                            g = 0;
                            break;
                        case L.r:
                            g = 1;
                            break;
                        case L.j:
                            g = 2;
                            break;
                        default:
                            a(Error("unsupported compression type"))
                    }
                    break;
                default:
                    a(Error("invalid compression method"))
            }
            return f = g << 6 | 0, i[j++] = f | 31 - (256 * e + f) % 31, h = c(this.input), this.z.b = j, i = this.z.n(), j = i.length, v && (i = new Uint8Array(i.buffer), i.length <= j + 4 && (this.a = new Uint8Array(i.length + 4), this.a.set(i), i = this.a), i = i.subarray(0, j + 4)), i[j++] = h >> 24 & 255, i[j++] = h >> 16 & 255, i[j++] = h >> 8 & 255, i[j++] = 255 & h, i
        }, b("Zlib.Deflate", m), b("Zlib.Deflate.compress", function(a, b) {
            return new m(a, b).n()
        }), b("Zlib.Deflate.CompressionType", L), b("Zlib.Deflate.CompressionType.NONE", L.NONE), b("Zlib.Deflate.CompressionType.FIXED", L.r), b("Zlib.Deflate.CompressionType.DYNAMIC", L.j);
        var M = 0,
            N = 1,
            O = {
                D: M,
                C: N
            };
        n.prototype.p = function() {
            for (; !this.s;) {
                var b = o(this, 3);
                switch (1 & b && (this.s = t), b >>>= 1) {
                    case 0:
                        var c = this.input,
                            d = this.c,
                            e = this.a,
                            f = this.b,
                            g = s,
                            h = s,
                            i = s,
                            j = e.length,
                            k = s;
                        switch (this.e = this.g = 0, g = c[d++], g === s && a(Error("invalid uncompressed block header: LEN (first byte)")), h = g, g = c[d++], g === s && a(Error("invalid uncompressed block header: LEN (second byte)")), h |= g << 8, g = c[d++], g === s && a(Error("invalid uncompressed block header: NLEN (first byte)")), i = g, g = c[d++], g === s && a(Error("invalid uncompressed block header: NLEN (second byte)")), i |= g << 8, h === ~i && a(Error("invalid uncompressed block header: length verify")), d + h > c.length && a(Error("input buffer is broken")), this.m) {
                            case M:
                                for (; f + h > e.length;) {
                                    if (k = j - f, h -= k, v) e.set(c.subarray(d, d + k), f), f += k, d += k;
                                    else
                                        for (; k--;) e[f++] = c[d++];
                                    this.b = f, e = this.f(), f = this.b
                                }
                                break;
                            case N:
                                for (; f + h > e.length;) e = this.f({
                                    v: 2
                                });
                                break;
                            default:
                                a(Error("invalid inflate mode"))
                        }
                        if (v) e.set(c.subarray(d, d + h), f), f += h, d += h;
                        else
                            for (; h--;) e[f++] = c[d++];
                        this.c = d, this.b = f, this.a = e;
                        break;
                    case 1:
                        this.o(cb, eb);
                        break;
                    case 2:
                        q(this);
                        break;
                    default:
                        a(Error("unknown BTYPE: " + b))
                }
            }
            return this.t()
        };
        var P, Q, R = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
            S = v ? new Uint16Array(R) : R,
            T = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258],
            U = v ? new Uint16Array(T) : T,
            V = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0],
            W = v ? new Uint8Array(V) : V,
            X = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577],
            Y = v ? new Uint16Array(X) : X,
            Z = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13],
            $ = v ? new Uint8Array(Z) : Z,
            _ = new(v ? Uint8Array : Array)(288);
        for (P = 0, Q = _.length; Q > P; ++P) _[P] = 143 >= P ? 8 : 255 >= P ? 9 : 279 >= P ? 7 : 8;
        var ab, bb, cb = f(_),
            db = new(v ? Uint8Array : Array)(30);
        for (ab = 0, bb = db.length; bb > ab; ++ab) db[ab] = 5;
        var eb = f(db);
        n.prototype.o = function(a, b) {
            var c = this.a,
                d = this.b;
            this.u = a;
            for (var e, f, g, h, i = c.length - 258; 256 !== (e = p(this, a));)
                if (256 > e) d >= i && (this.b = d, c = this.f(), d = this.b), c[d++] = e;
                else
                    for (f = e - 257, h = U[f], 0 < W[f] && (h += o(this, W[f])), e = p(this, b), g = Y[e], 0 < $[e] && (g += o(this, $[e])), d >= i && (this.b = d, c = this.f(), d = this.b); h--;) c[d] = c[d++-g];
            for (; 8 <= this.e;) this.e -= 8, this.c--;
            this.b = d
        }, n.prototype.I = function(a, b) {
            var c = this.a,
                d = this.b;
            this.u = a;
            for (var e, f, g, h, i = c.length; 256 !== (e = p(this, a));)
                if (256 > e) d >= i && (c = this.f(), i = c.length), c[d++] = e;
                else
                    for (f = e - 257, h = U[f], 0 < W[f] && (h += o(this, W[f])), e = p(this, b), g = Y[e], 0 < $[e] && (g += o(this, $[e])), d + h > i && (c = this.f(), i = c.length); h--;) c[d] = c[d++-g];
            for (; 8 <= this.e;) this.e -= 8, this.c--;
            this.b = d
        }, n.prototype.f = function() {
            var a, b, c = new(v ? Uint8Array : Array)(this.b - 32768),
                d = this.b - 32768,
                e = this.a;
            if (v) c.set(e.subarray(32768, c.length));
            else
                for (a = 0, b = c.length; b > a; ++a) c[a] = e[a + 32768]; if (this.k.push(c), this.q += c.length, v) e.set(e.subarray(d, d + 32768));
            else
                for (a = 0; 32768 > a; ++a) e[a] = e[d + a];
            return this.b = 32768, e
        }, n.prototype.J = function(a) {
            var b, c, d, e, f = this.input.length / this.c + 1 | 0,
                g = this.input,
                h = this.a;
            return a && ("number" == typeof a.v && (f = a.v), "number" == typeof a.F && (f += a.F)), 2 > f ? (c = (g.length - this.c) / this.u[2], e = 258 * (c / 2) | 0, d = e < h.length ? h.length + e : h.length << 1) : d = h.length * f, v ? (b = new Uint8Array(d), b.set(h)) : b = h, this.a = b
        }, n.prototype.t = function() {
            var a, b, c, d, e, f = 0,
                g = this.a,
                h = this.k,
                i = new(v ? Uint8Array : Array)(this.q + (this.b - 32768));
            if (0 === h.length) return v ? this.a.subarray(32768, this.b) : this.a.slice(32768, this.b);
            for (b = 0, c = h.length; c > b; ++b)
                for (a = h[b], d = 0, e = a.length; e > d; ++d) i[f++] = a[d];
            for (b = 32768, c = this.b; c > b; ++b) i[f++] = g[b];
            return this.k = [], this.buffer = i
        }, n.prototype.H = function() {
            var a, b = this.b;
            return v ? this.B ? (a = new Uint8Array(b), a.set(this.a.subarray(0, b))) : a = this.a.subarray(0, b) : (this.a.length > b && (this.a.length = b), a = this.a), this.buffer = a
        }, r.prototype.p = function() {
            var b, d, e = this.input;
            return b = this.A.p(), this.c = this.A.c, this.M && (d = (e[this.c++] << 24 | e[this.c++] << 16 | e[this.c++] << 8 | e[this.c++]) >>> 0, d !== c(b) && a(Error("invalid adler-32 checksum"))), b
        }, b("Zlib.Inflate", r), b("Zlib.Inflate.BufferType", O), O.ADAPTIVE = O.C, O.BLOCK = O.D, b("Zlib.Inflate.prototype.decompress", r.prototype.p);
        var fb = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        v && new Uint16Array(fb);
        var gb = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258];
        v && new Uint16Array(gb);
        var hb = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0];
        v && new Uint8Array(hb);
        var ib = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
        v && new Uint16Array(ib);
        var jb = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
        v && new Uint8Array(jb);
        var kb, lb, mb = new(v ? Uint8Array : Array)(288);
        for (kb = 0, lb = mb.length; lb > kb; ++kb) mb[kb] = 143 >= kb ? 8 : 255 >= kb ? 9 : 279 >= kb ? 7 : 8;
        f(mb);
        var nb, ob, pb = new(v ? Uint8Array : Array)(30);
        for (nb = 0, ob = pb.length; ob > nb; ++nb) pb[nb] = 5;
        f(pb);
        var qb = 8
    }.call(this);
var _p = window;
_p = _p.Zlib = _p.Zlib, _p.Deflate = _p.Deflate, _p.Deflate.compress = _p.Deflate.compress, _p.Inflate = _p.Inflate, _p.Inflate.BufferType = _p.Inflate.BufferType, _p.Inflate.prototype.decompress = _p.Inflate.prototype.decompress;
cc.PNGReader = cc.Class.extend({
    ctor: function(a) {
        var b, c, d, e, f, g, h, i, j, k, l, m, n, o;
        for (this.data = a, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, f = null;;) {
            switch (b = this.readUInt32(), j = function() {
                var a, b;
                for (b = [], g = a = 0; 4 > a; g = ++a) b.push(String.fromCharCode(this.data[this.pos++]));
                return b
            }.call(this).join("")) {
                case "IHDR":
                    this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
                    break;
                case "acTL":
                    this.animation = {
                        numFrames: this.readUInt32(),
                        numPlays: this.readUInt32() || 1 / 0,
                        frames: []
                    };
                    break;
                case "PLTE":
                    this.palette = this.read(b);
                    break;
                case "fcTL":
                    f && this.animation.frames.push(f), this.pos += 4, f = {
                        width: this.readUInt32(),
                        height: this.readUInt32(),
                        xOffset: this.readUInt32(),
                        yOffset: this.readUInt32()
                    }, e = this.readUInt16(), d = this.readUInt16() || 100, f.delay = 1e3 * e / d, f.disposeOp = this.data[this.pos++], f.blendOp = this.data[this.pos++], f.data = [];
                    break;
                case "IDAT":
                case "fdAT":
                    for ("fdAT" === j && (this.pos += 4, b -= 4), a = (null != f ? f.data : void 0) || this.imgData, g = m = 0; b >= 0 ? b > m : m > b; g = b >= 0 ? ++m : --m) a.push(this.data[this.pos++]);
                    break;
                case "tRNS":
                    switch (this.transparency = {}, this.colorType) {
                        case 3:
                            if (this.transparency.indexed = this.read(b), k = 255 - this.transparency.indexed.length, k > 0)
                                for (g = n = 0; k >= 0 ? k > n : n > k; g = k >= 0 ? ++n : --n) this.transparency.indexed.push(255);
                            break;
                        case 0:
                            this.transparency.grayscale = this.read(b)[0];
                            break;
                        case 2:
                            this.transparency.rgb = this.read(b)
                    }
                    break;
                case "tEXt":
                    l = this.read(b), h = l.indexOf(0), i = String.fromCharCode.apply(String, l.slice(0, h)), this.text[i] = String.fromCharCode.apply(String, l.slice(h + 1));
                    break;
                case "IEND":
                    return f && this.animation.frames.push(f), this.colors = function() {
                        switch (this.colorType) {
                            case 0:
                            case 3:
                            case 4:
                                return 1;
                            case 2:
                            case 6:
                                return 3
                        }
                    }.call(this), this.hasAlphaChannel = 4 === (o = this.colorType) || 6 === o, c = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * c, this.colorSpace = function() {
                        switch (this.colors) {
                            case 1:
                                return "DeviceGray";
                            case 3:
                                return "DeviceRGB"
                        }
                    }.call(this), void(Uint8Array != Array && (this.imgData = new Uint8Array(this.imgData)));
                default:
                    this.pos += b
            }
            if (this.pos += 4, this.pos > this.data.length) throw new Error("Incomplete or corrupt PNG file")
        }
    },
    read: function(a) {
        var b, c, d;
        for (d = [], b = c = 0; a >= 0 ? a > c : c > a; b = a >= 0 ? ++c : --c) d.push(this.data[this.pos++]);
        return d
    },
    readUInt32: function() {
        var a, b, c, d;
        return a = this.data[this.pos++] << 24, b = this.data[this.pos++] << 16, c = this.data[this.pos++] << 8, d = this.data[this.pos++], a | b | c | d
    },
    readUInt16: function() {
        var a, b;
        return a = this.data[this.pos++] << 8, b = this.data[this.pos++], a | b
    },
    decodePixels: function(a) {
        var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x;
        if (null == a && (a = this.imgData), 0 === a.length) return new Uint8Array(0);
        var y = new Zlib.Inflate(a, {
            index: 0,
            verify: !1
        });
        for (a = y.decompress(), m = this.pixelBitlength / 8, q = m * this.width, n = new Uint8Array(q * this.height), g = a.length, p = 0, o = 0, c = 0; g > o;) {
            switch (a[o++]) {
                case 0:
                    for (e = t = 0; q > t; e = t += 1) n[c++] = a[o++];
                    break;
                case 1:
                    for (e = u = 0; q > u; e = u += 1) b = a[o++], f = m > e ? 0 : n[c - m], n[c++] = (b + f) % 256;
                    break;
                case 2:
                    for (e = v = 0; q > v; e = v += 1) b = a[o++], d = (e - e % m) / m, r = p && n[(p - 1) * q + d * m + e % m], n[c++] = (r + b) % 256;
                    break;
                case 3:
                    for (e = w = 0; q > w; e = w += 1) b = a[o++], d = (e - e % m) / m, f = m > e ? 0 : n[c - m], r = p && n[(p - 1) * q + d * m + e % m], n[c++] = (b + Math.floor((f + r) / 2)) % 256;
                    break;
                case 4:
                    for (e = x = 0; q > x; e = x += 1) b = a[o++], d = (e - e % m) / m, f = m > e ? 0 : n[c - m], 0 === p ? r = s = 0 : (r = n[(p - 1) * q + d * m + e % m], s = d && n[(p - 1) * q + (d - 1) * m + e % m]), h = f + r - s, i = Math.abs(h - f), k = Math.abs(h - r), l = Math.abs(h - s), j = k >= i && l >= i ? f : l >= k ? r : s, n[c++] = (b + j) % 256;
                    break;
                default:
                    throw new Error("Invalid filter algorithm: " + a[o - 1])
            }
            p++
        }
        return n
    },
    copyToImageData: function(a, b) {
        var c, d, e, f, g, h, i, j, k, l, m;
        if (d = this.colors, k = null, c = this.hasAlphaChannel, this.palette.length && (k = null != (m = this._decodedPalette) ? m : this._decodedPalette = this.decodePalette(), d = 4, c = !0), e = a.data || a, j = e.length, g = k || b, f = h = 0, 1 === d)
            for (; j > f;) i = k ? 4 * b[f / 4] : h, l = g[i++], e[f++] = l, e[f++] = l, e[f++] = l, e[f++] = c ? g[i++] : 255, h = i;
        else
            for (; j > f;) i = k ? 4 * b[f / 4] : h, e[f++] = g[i++], e[f++] = g[i++], e[f++] = g[i++], e[f++] = c ? g[i++] : 255, h = i
    },
    decodePalette: function() {
        var a, b, c, d, e, f, g, h, i;
        for (c = this.palette, f = this.transparency.indexed || [], e = new Uint8Array((f.length || 0) + c.length), d = 0, a = 0, b = g = 0, h = c.length; h > g; b = g += 3) e[d++] = c[b], e[d++] = c[b + 1], e[d++] = c[b + 2], e[d++] = null != (i = f[a++]) ? i : 255;
        return e
    },
    render: function(a) {
        var b, c;
        return a.width = this.width, a.height = this.height, b = a.getContext("2d"), c = b.createImageData(this.width, this.height), this.copyToImageData(c, this.decodePixels()), b.putImageData(c, 0, 0)
    }
}), cc.tiffReader = {
    _littleEndian: !1,
    _tiffData: null,
    _fileDirectories: [],
    getUint8: function(a) {
        return this._tiffData[a]
    },
    getUint16: function(a) {
        return this._littleEndian ? this._tiffData[a + 1] << 8 | this._tiffData[a] : this._tiffData[a] << 8 | this._tiffData[a + 1]
    },
    getUint32: function(a) {
        var b = this._tiffData;
        return this._littleEndian ? b[a + 3] << 24 | b[a + 2] << 16 | b[a + 1] << 8 | b[a] : b[a] << 24 | b[a + 1] << 16 | b[a + 2] << 8 | b[a + 3]
    },
    checkLittleEndian: function() {
        var a = this.getUint16(0);
        if (18761 === a) this.littleEndian = !0;
        else {
            if (19789 !== a) throw console.log(a), TypeError("Invalid byte order value.");
            this.littleEndian = !1
        }
        return this.littleEndian
    },
    hasTowel: function() {
        if (42 !== this.getUint16(2)) throw RangeError("You forgot your towel!");
        return !0
    },
    getFieldTypeName: function(a) {
        var b = this.fieldTypeNames;
        return a in b ? b[a] : null
    },
    getFieldTagName: function(a) {
        var b = this.fieldTagNames;
        return a in b ? b[a] : (console.log("Unknown Field Tag:", a), "Tag" + a)
    },
    getFieldTypeLength: function(a) {
        return -1 !== ["BYTE", "ASCII", "SBYTE", "UNDEFINED"].indexOf(a) ? 1 : -1 !== ["SHORT", "SSHORT"].indexOf(a) ? 2 : -1 !== ["LONG", "SLONG", "FLOAT"].indexOf(a) ? 4 : -1 !== ["RATIONAL", "SRATIONAL", "DOUBLE"].indexOf(a) ? 8 : null
    },
    getFieldValues: function(a, b, c, d) {
        var e = [],
            f = this.getFieldTypeLength(b),
            g = f * c;
        if (4 >= g) e.push(this.littleEndian === !1 ? d >>> 8 * (4 - f) : d);
        else
            for (var h = 0; c > h; h++) {
                var i = f * h;
                f >= 8 ? -1 !== ["RATIONAL", "SRATIONAL"].indexOf(b) ? (e.push(this.getUint32(d + i)), e.push(this.getUint32(d + i + 4))) : cc.log("Can't handle this field type or size") : e.push(this.getBytes(f, d + i))
            }
        return "ASCII" === b && e.forEach(function(a, b, c) {
            c[b] = String.fromCharCode(a)
        }), e
    },
    getBytes: function(a, b) {
        if (0 >= a) cc.log("No bytes requested");
        else {
            if (1 >= a) return this.getUint8(b);
            if (2 >= a) return this.getUint16(b);
            if (3 >= a) return this.getUint32(b) >>> 8;
            if (4 >= a) return this.getUint32(b);
            cc.log("Too many bytes requested")
        }
    },
    getBits: function(a, b, c) {
        c = c || 0;
        var d, e, f = Math.floor(c / 8),
            g = b + f,
            h = c + a,
            i = 32 - a;
        return 0 >= h ? console.log("No bits requested") : 8 >= h ? (d = 24 + c, e = this.getUint8(g)) : 16 >= h ? (d = 16 + c, e = this.getUint16(g)) : 32 >= h ? (d = c, e = this.getUint32(g)) : console.log("Too many bits requested"), {
            bits: e << d >>> i,
            byteOffset: g + Math.floor(h / 8),
            bitOffset: h % 8
        }
    },
    parseFileDirectory: function(a) {
        for (var b = this.getUint16(a), c = [], d = a + 2, e = 0; b > e; d += 12, e++) {
            var f = this.getUint16(d),
                g = this.getUint16(d + 2),
                h = this.getUint32(d + 4),
                i = this.getUint32(d + 8),
                j = this.getFieldTagName(f),
                k = this.getFieldTypeName(g),
                l = this.getFieldValues(j, k, h, i);
            c[j] = {
                type: k,
                values: l
            }
        }
        this._fileDirectories.push(c);
        var m = this.getUint32(d);
        0 !== m && this.parseFileDirectory(m)
    },
    clampColorSample: function(a, b) {
        var c = Math.pow(2, 8 - b);
        return Math.floor(a * c + (c - 1))
    },
    parseTIFF: function(a, b) {
        if (b = b || cc.newElement("canvas"), this._tiffData = a, this.canvas = b, this.checkLittleEndian(), this.hasTowel()) {
            var c = this.getUint32(4);
            this._fileDirectories.length = 0, this.parseFileDirectory(c);
            var d = this._fileDirectories[0],
                e = d.ImageWidth.values[0],
                f = d.ImageLength.values[0];
            this.canvas.width = e, this.canvas.height = f;
            var g = [],
                h = d.Compression ? d.Compression.values[0] : 1,
                i = d.SamplesPerPixel.values[0],
                j = [],
                k = 0,
                l = !1;
            if (d.BitsPerSample.values.forEach(function(a, b) {
                j[b] = {
                    bitsPerSample: a,
                    hasBytesPerSample: !1,
                    bytesPerSample: void 0
                }, a % 8 === 0 && (j[b].hasBytesPerSample = !0, j[b].bytesPerSample = a / 8), k += a
            }, this), k % 8 === 0) {
                l = !0;
                var m = k / 8
            }
            var n = d.StripOffsets.values,
                o = n.length;
            if (d.StripByteCounts) var p = d.StripByteCounts.values;
            else {
                if (cc.log("Missing StripByteCounts!"), 1 !== o) throw Error("Cannot recover from missing StripByteCounts");
                var p = [Math.ceil(e * f * k / 8)]
            }
            for (var q = 0; o > q; q++) {
                var r = n[q];
                g[q] = [];
                for (var s = p[q], t = 0, u = 0, v = 1, w = !0, x = [], y = 0, z = 0, A = 0; s > t; t += v) switch (h) {
                    case 1:
                        for (var B = 0, x = []; i > B; B++) {
                            if (!j[B].hasBytesPerSample) {
                                var C = this.getBits(j[B].bitsPerSample, r + t, u);
                                throw x.push(C.bits), t = C.byteOffset - r, u = C.bitOffset, RangeError("Cannot handle sub-byte bits per sample")
                            }
                            var D = j[B].bytesPerSample * B;
                            x.push(this.getBytes(j[B].bytesPerSample, r + t + D))
                        }
                        if (g[q].push(x), !l) throw v = 0, RangeError("Cannot handle sub-byte bits per pixel");
                        v = m;
                        break;
                    case 2:
                        break;
                    case 3:
                        break;
                    case 4:
                        break;
                    case 5:
                        break;
                    case 6:
                        break;
                    case 7:
                        break;
                    case 32773:
                        if (w) {
                            w = !1;
                            var E = 1,
                                F = 1,
                                G = this.getInt8(r + t);
                            G >= 0 && 127 >= G ? E = G + 1 : G >= -127 && -1 >= G ? F = -G + 1 : w = !0
                        } else {
                            for (var H = this.getUint8(r + t), B = 0; F > B; B++) {
                                if (!j[z].hasBytesPerSample) throw RangeError("Cannot handle sub-byte bits per sample");
                                A = A << 8 * y | H, y++, y === j[z].bytesPerSample && (x.push(A), A = y = 0, z++), z === i && (g[q].push(x), x = [], z = 0)
                            }
                            E--, 0 === E && (w = !0)
                        }
                        v = 1
                }
            }
            if (b.getContext) {
                var I = this.canvas.getContext("2d");
                I.fillStyle = "rgba(255, 255, 255, 0)";
                var J = d.RowsPerStrip ? d.RowsPerStrip.values[0] : f,
                    K = g.length,
                    L = f % J,
                    M = 0 === L ? J : L,
                    N = J,
                    O = 0,
                    P = d.PhotometricInterpretation.values[0],
                    Q = [],
                    R = 0;
                if (d.ExtraSamples && (Q = d.ExtraSamples.values, R = Q.length), d.ColorMap) var S = d.ColorMap.values,
                    T = Math.pow(2, j[0].bitsPerSample);
                for (var q = 0; K > q; q++) {
                    q + 1 === K && (N = M);
                    for (var U = g[q].length, V = O * q, W = 0, X = 0; U > X; W++)
                        for (var Y = 0; e > Y; Y++, X++) {
                            var Z = g[q][X],
                                $ = 0,
                                _ = 0,
                                ab = 0,
                                bb = 1;
                            if (R > 0)
                                for (var cb = 0; R > cb; cb++)
                                    if (1 === Q[cb] || 2 === Q[cb]) {
                                        bb = Z[3 + cb] / 256;
                                        break
                                    }
                            switch (P) {
                                case 0:
                                    if (j[0].hasBytesPerSample) var db = Math.pow(16, 2 * j[0].bytesPerSample);
                                    Z.forEach(function(a, b, c) {
                                        c[b] = db - a
                                    });
                                case 1:
                                    $ = _ = ab = this.clampColorSample(Z[0], j[0].bitsPerSample);
                                    break;
                                case 2:
                                    $ = this.clampColorSample(Z[0], j[0].bitsPerSample), _ = this.clampColorSample(Z[1], j[1].bitsPerSample), ab = this.clampColorSample(Z[2], j[2].bitsPerSample);
                                    break;
                                case 3:
                                    if (void 0 === S) throw Error("Palette image missing color map");
                                    var eb = Z[0];
                                    $ = this.clampColorSample(S[eb], 16), _ = this.clampColorSample(S[T + eb], 16), ab = this.clampColorSample(S[2 * T + eb], 16);
                                    break;
                                default:
                                    throw RangeError("Unknown Photometric Interpretation:", P)
                            }
                            I.fillStyle = "rgba(" + $ + ", " + _ + ", " + ab + ", " + bb + ")", I.fillRect(Y, V + W, 1, 1)
                        }
                    O = N
                }
            }
            return this.canvas
        }
    },
    fieldTagNames: {
        315: "Artist",
        258: "BitsPerSample",
        265: "CellLength",
        264: "CellWidth",
        320: "ColorMap",
        259: "Compression",
        33432: "Copyright",
        306: "DateTime",
        338: "ExtraSamples",
        266: "FillOrder",
        289: "FreeByteCounts",
        288: "FreeOffsets",
        291: "GrayResponseCurve",
        290: "GrayResponseUnit",
        316: "HostComputer",
        270: "ImageDescription",
        257: "ImageLength",
        256: "ImageWidth",
        271: "Make",
        281: "MaxSampleValue",
        280: "MinSampleValue",
        272: "Model",
        254: "NewSubfileType",
        274: "Orientation",
        262: "PhotometricInterpretation",
        284: "PlanarConfiguration",
        296: "ResolutionUnit",
        278: "RowsPerStrip",
        277: "SamplesPerPixel",
        305: "Software",
        279: "StripByteCounts",
        273: "StripOffsets",
        255: "SubfileType",
        263: "Threshholding",
        282: "XResolution",
        283: "YResolution",
        326: "BadFaxLines",
        327: "CleanFaxData",
        343: "ClipPath",
        328: "ConsecutiveBadFaxLines",
        433: "Decode",
        434: "DefaultImageColor",
        269: "DocumentName",
        336: "DotRange",
        321: "HalftoneHints",
        346: "Indexed",
        347: "JPEGTables",
        285: "PageName",
        297: "PageNumber",
        317: "Predictor",
        319: "PrimaryChromaticities",
        532: "ReferenceBlackWhite",
        339: "SampleFormat",
        559: "StripRowCounts",
        330: "SubIFDs",
        292: "T4Options",
        293: "T6Options",
        325: "TileByteCounts",
        323: "TileLength",
        324: "TileOffsets",
        322: "TileWidth",
        301: "TransferFunction",
        318: "WhitePoint",
        344: "XClipPathUnits",
        286: "XPosition",
        529: "YCbCrCoefficients",
        531: "YCbCrPositioning",
        530: "YCbCrSubSampling",
        345: "YClipPathUnits",
        287: "YPosition",
        37378: "ApertureValue",
        40961: "ColorSpace",
        36868: "DateTimeDigitized",
        36867: "DateTimeOriginal",
        34665: "Exif IFD",
        36864: "ExifVersion",
        33434: "ExposureTime",
        41728: "FileSource",
        37385: "Flash",
        40960: "FlashpixVersion",
        33437: "FNumber",
        42016: "ImageUniqueID",
        37384: "LightSource",
        37500: "MakerNote",
        37377: "ShutterSpeedValue",
        37510: "UserComment",
        33723: "IPTC",
        34675: "ICC Profile",
        700: "XMP",
        42112: "GDAL_METADATA",
        42113: "GDAL_NODATA",
        34377: "Photoshop"
    },
    fieldTypeNames: {
        1: "BYTE",
        2: "ASCII",
        3: "SHORT",
        4: "LONG",
        5: "RATIONAL",
        6: "SBYTE",
        7: "UNDEFINED",
        8: "SSHORT",
        9: "SLONG",
        10: "SRATIONAL",
        11: "FLOAT",
        12: "DOUBLE"
    }
}, cc.Particle = function(a, b, c, d, e, f, g, h, i, j, k, l) {
    this.pos = a ? a : cc.p(0, 0), this.startPos = b ? b : cc.p(0, 0), this.color = c ? c : {
        r: 0,
        g: 0,
        b: 0,
        a: 255
    }, this.deltaColor = d ? d : {
        r: 0,
        g: 0,
        b: 0,
        a: 255
    }, this.size = e || 0, this.deltaSize = f || 0, this.rotation = g || 0, this.deltaRotation = h || 0, this.timeToLive = i || 0, this.atlasIndex = j || 0, this.modeA = k ? k : new cc.Particle.ModeA, this.modeB = l ? l : new cc.Particle.ModeB, this.isChangeColor = !1, this.drawPos = cc.p(0, 0)
}, cc.Particle.ModeA = function(a, b, c) {
    this.dir = a ? a : cc.p(0, 0), this.radialAccel = b || 0, this.tangentialAccel = c || 0
}, cc.Particle.ModeB = function(a, b, c, d) {
    this.angle = a || 0, this.degreesPerSecond = b || 0, this.radius = c || 0, this.deltaRadius = d || 0
}, cc.Particle.TemporaryPoints = [cc.p(), cc.p(), cc.p(), cc.p()], cc.ParticleSystem = cc.Node.extend({
    _className: "ParticleSystem",
    _plistFile: "",
    _elapsed: 0,
    _dontTint: !1,
    modeA: null,
    modeB: null,
    _pointZeroForParticle: cc.p(0, 0),
    _particles: null,
    _emitCounter: 0,
    _particleIdx: 0,
    _batchNode: null,
    atlasIndex: 0,
    _transformSystemDirty: !1,
    _allocatedParticles: 0,
    _isActive: !1,
    particleCount: 0,
    duration: 0,
    _sourcePosition: null,
    _posVar: null,
    life: 0,
    lifeVar: 0,
    angle: 0,
    angleVar: 0,
    startSize: 0,
    startSizeVar: 0,
    endSize: 0,
    endSizeVar: 0,
    _startColor: null,
    _startColorVar: null,
    _endColor: null,
    _endColorVar: null,
    startSpin: 0,
    startSpinVar: 0,
    endSpin: 0,
    endSpinVar: 0,
    emissionRate: 0,
    _totalParticles: 0,
    _texture: null,
    _blendFunc: null,
    _opacityModifyRGB: !1,
    positionType: null,
    autoRemoveOnFinish: !1,
    emitterMode: 0,
    _textureLoaded: null,
    ctor: function(a) {
        if (cc.Node.prototype.ctor.call(this), this.emitterMode = cc.ParticleSystem.MODE_GRAVITY, this.modeA = new cc.ParticleSystem.ModeA, this.modeB = new cc.ParticleSystem.ModeB, this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        }, this._particles = [], this._sourcePosition = cc.p(0, 0), this._posVar = cc.p(0, 0), this._startColor = cc.color(255, 255, 255, 255), this._startColorVar = cc.color(255, 255, 255, 255), this._endColor = cc.color(255, 255, 255, 255), this._endColorVar = cc.color(255, 255, 255, 255), this._plistFile = "", this._elapsed = 0, this._dontTint = !1, this._pointZeroForParticle = cc.p(0, 0), this._emitCounter = 0, this._particleIdx = 0, this._batchNode = null, this.atlasIndex = 0, this._transformSystemDirty = !1, this._allocatedParticles = 0, this._isActive = !1, this.particleCount = 0, this.duration = 0, this.life = 0, this.lifeVar = 0, this.angle = 0, this.angleVar = 0, this.startSize = 0, this.startSizeVar = 0, this.endSize = 0, this.endSizeVar = 0, this.startSpin = 0, this.startSpinVar = 0, this.endSpin = 0, this.endSpinVar = 0, this.emissionRate = 0, this._totalParticles = 0, this._texture = null, this._opacityModifyRGB = !1, this.positionType = cc.ParticleSystem.TYPE_FREE, this.autoRemoveOnFinish = !1, this._textureLoaded = !0, !a || cc.isNumber(a)) {
            var b = a || 100;
            this.setDrawMode(cc.ParticleSystem.TEXTURE_MODE), this.initWithTotalParticles(b)
        } else a && this.initWithFile(a)
    },
    _createRenderCmd: function() {
        return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.ParticleSystem.CanvasRenderCmd(this) : new cc.ParticleSystem.WebGLRenderCmd(this)
    },
    ignoreColor: function(a) {
        this._dontTint = a
    },
    initTexCoordsWithRect: function(a) {
        this._renderCmd.initTexCoordsWithRect(a)
    },
    getBatchNode: function() {
        return this._batchNode
    },
    setBatchNode: function(a) {
        this._renderCmd.setBatchNode(a)
    },
    getAtlasIndex: function() {
        return this.atlasIndex
    },
    setAtlasIndex: function(a) {
        this.atlasIndex = a
    },
    getDrawMode: function() {
        return this._renderCmd.getDrawMode()
    },
    setDrawMode: function(a) {
        this._renderCmd.setDrawMode(a)
    },
    getShapeType: function() {
        return this._renderCmd.getShapeType()
    },
    setShapeType: function(a) {
        this._renderCmd.setShapeType(a)
    },
    isActive: function() {
        return this._isActive
    },
    getParticleCount: function() {
        return this.particleCount
    },
    setParticleCount: function(a) {
        this.particleCount = a
    },
    getDuration: function() {
        return this.duration
    },
    setDuration: function(a) {
        this.duration = a
    },
    getSourcePosition: function() {
        return {
            x: this._sourcePosition.x,
            y: this._sourcePosition.y
        }
    },
    setSourcePosition: function(a) {
        this._sourcePosition = a
    },
    getPosVar: function() {
        return {
            x: this._posVar.x,
            y: this._posVar.y
        }
    },
    setPosVar: function(a) {
        this._posVar = a
    },
    getLife: function() {
        return this.life
    },
    setLife: function(a) {
        this.life = a
    },
    getLifeVar: function() {
        return this.lifeVar
    },
    setLifeVar: function(a) {
        this.lifeVar = a
    },
    getAngle: function() {
        return this.angle
    },
    setAngle: function(a) {
        this.angle = a
    },
    getAngleVar: function() {
        return this.angleVar
    },
    setAngleVar: function(a) {
        this.angleVar = a
    },
    getGravity: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getGravity() : Particle Mode should be Gravity");
        var a = this.modeA.gravity;
        return cc.p(a.x, a.y)
    },
    setGravity: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setGravity() : Particle Mode should be Gravity"), this.modeA.gravity = a
    },
    getSpeed: function() {
        return this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getSpeed() : Particle Mode should be Gravity"), this.modeA.speed
    },
    setSpeed: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setSpeed() : Particle Mode should be Gravity"), this.modeA.speed = a
    },
    getSpeedVar: function() {
        return this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getSpeedVar() : Particle Mode should be Gravity"), this.modeA.speedVar
    },
    setSpeedVar: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setSpeedVar() : Particle Mode should be Gravity"), this.modeA.speedVar = a
    },
    getTangentialAccel: function() {
        return this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getTangentialAccel() : Particle Mode should be Gravity"), this.modeA.tangentialAccel
    },
    setTangentialAccel: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setTangentialAccel() : Particle Mode should be Gravity"), this.modeA.tangentialAccel = a
    },
    getTangentialAccelVar: function() {
        return this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getTangentialAccelVar() : Particle Mode should be Gravity"), this.modeA.tangentialAccelVar
    },
    setTangentialAccelVar: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setTangentialAccelVar() : Particle Mode should be Gravity"), this.modeA.tangentialAccelVar = a
    },
    getRadialAccel: function() {
        return this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getRadialAccel() : Particle Mode should be Gravity"), this.modeA.radialAccel
    },
    setRadialAccel: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setRadialAccel() : Particle Mode should be Gravity"), this.modeA.radialAccel = a
    },
    getRadialAccelVar: function() {
        return this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getRadialAccelVar() : Particle Mode should be Gravity"), this.modeA.radialAccelVar
    },
    setRadialAccelVar: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setRadialAccelVar() : Particle Mode should be Gravity"), this.modeA.radialAccelVar = a
    },
    getRotationIsDir: function() {
        return this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getRotationIsDir() : Particle Mode should be Gravity"), this.modeA.rotationIsDir
    },
    setRotationIsDir: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setRotationIsDir() : Particle Mode should be Gravity"), this.modeA.rotationIsDir = a
    },
    getStartRadius: function() {
        return this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getStartRadius() : Particle Mode should be Radius"), this.modeB.startRadius
    },
    setStartRadius: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setStartRadius() : Particle Mode should be Radius"), this.modeB.startRadius = a
    },
    getStartRadiusVar: function() {
        return this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getStartRadiusVar() : Particle Mode should be Radius"), this.modeB.startRadiusVar
    },
    setStartRadiusVar: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setStartRadiusVar() : Particle Mode should be Radius"), this.modeB.startRadiusVar = a
    },
    getEndRadius: function() {
        return this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getEndRadius() : Particle Mode should be Radius"), this.modeB.endRadius
    },
    setEndRadius: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setEndRadius() : Particle Mode should be Radius"), this.modeB.endRadius = a
    },
    getEndRadiusVar: function() {
        return this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getEndRadiusVar() : Particle Mode should be Radius"), this.modeB.endRadiusVar
    },
    setEndRadiusVar: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setEndRadiusVar() : Particle Mode should be Radius"), this.modeB.endRadiusVar = a
    },
    getRotatePerSecond: function() {
        return this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getRotatePerSecond() : Particle Mode should be Radius"), this.modeB.rotatePerSecond
    },
    setRotatePerSecond: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setRotatePerSecond() : Particle Mode should be Radius"), this.modeB.rotatePerSecond = a
    },
    getRotatePerSecondVar: function() {
        return this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getRotatePerSecondVar() : Particle Mode should be Radius"), this.modeB.rotatePerSecondVar
    },
    setRotatePerSecondVar: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setRotatePerSecondVar() : Particle Mode should be Radius"), this.modeB.rotatePerSecondVar = a
    },
    setScale: function(a, b) {
        this._transformSystemDirty = !0, cc.Node.prototype.setScale.call(this, a, b)
    },
    setRotation: function(a) {
        this._transformSystemDirty = !0, cc.Node.prototype.setRotation.call(this, a)
    },
    setScaleX: function(a) {
        this._transformSystemDirty = !0, cc.Node.prototype.setScaleX.call(this, a)
    },
    setScaleY: function(a) {
        this._transformSystemDirty = !0, cc.Node.prototype.setScaleY.call(this, a)
    },
    getStartSize: function() {
        return this.startSize
    },
    setStartSize: function(a) {
        this.startSize = a
    },
    getStartSizeVar: function() {
        return this.startSizeVar
    },
    setStartSizeVar: function(a) {
        this.startSizeVar = a
    },
    getEndSize: function() {
        return this.endSize
    },
    setEndSize: function(a) {
        this.endSize = a
    },
    getEndSizeVar: function() {
        return this.endSizeVar
    },
    setEndSizeVar: function(a) {
        this.endSizeVar = a
    },
    getStartColor: function() {
        return cc.color(this._startColor.r, this._startColor.g, this._startColor.b, this._startColor.a)
    },
    setStartColor: function(a) {
        this._startColor = cc.color(a)
    },
    getStartColorVar: function() {
        return cc.color(this._startColorVar.r, this._startColorVar.g, this._startColorVar.b, this._startColorVar.a)
    },
    setStartColorVar: function(a) {
        this._startColorVar = cc.color(a)
    },
    getEndColor: function() {
        return cc.color(this._endColor.r, this._endColor.g, this._endColor.b, this._endColor.a)
    },
    setEndColor: function(a) {
        this._endColor = cc.color(a)
    },
    getEndColorVar: function() {
        return cc.color(this._endColorVar.r, this._endColorVar.g, this._endColorVar.b, this._endColorVar.a)
    },
    setEndColorVar: function(a) {
        this._endColorVar = cc.color(a)
    },
    getStartSpin: function() {
        return this.startSpin
    },
    setStartSpin: function(a) {
        this.startSpin = a
    },
    getStartSpinVar: function() {
        return this.startSpinVar
    },
    setStartSpinVar: function(a) {
        this.startSpinVar = a
    },
    getEndSpin: function() {
        return this.endSpin
    },
    setEndSpin: function(a) {
        this.endSpin = a
    },
    getEndSpinVar: function() {
        return this.endSpinVar
    },
    setEndSpinVar: function(a) {
        this.endSpinVar = a
    },
    getEmissionRate: function() {
        return this.emissionRate
    },
    setEmissionRate: function(a) {
        this.emissionRate = a
    },
    getTotalParticles: function() {
        return this._totalParticles
    },
    setTotalParticles: function(a) {
        this._renderCmd.setTotalParticles(a)
    },
    getTexture: function() {
        return this._texture
    },
    setTexture: function(a) {
        a && (a.isLoaded() ? this.setTextureWithRect(a, cc.rect(0, 0, a.width, a.height)) : (this._textureLoaded = !1, a.addEventListener("load", function(a) {
            this._textureLoaded = !0, this.setTextureWithRect(a, cc.rect(0, 0, a.width, a.height))
        }, this)))
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    setBlendFunc: function(a, b) {
        void 0 === b ? this._blendFunc != a && (this._blendFunc = a, this._updateBlendFunc()) : (this._blendFunc.src != a || this._blendFunc.dst != b) && (this._blendFunc = {
            src: a,
            dst: b
        }, this._updateBlendFunc())
    },
    isOpacityModifyRGB: function() {
        return this._opacityModifyRGB
    },
    setOpacityModifyRGB: function(a) {
        this._opacityModifyRGB = a
    },
    isBlendAdditive: function() {
        return this._blendFunc.src == cc.SRC_ALPHA && this._blendFunc.dst == cc.ONE || this._blendFunc.src == cc.ONE && this._blendFunc.dst == cc.ONE
    },
    setBlendAdditive: function(a) {
        var b = this._blendFunc;
        a ? (b.src = cc.SRC_ALPHA, b.dst = cc.ONE) : this._renderCmd._setBlendAdditive()
    },
    getPositionType: function() {
        return this.positionType
    },
    setPositionType: function(a) {
        this.positionType = a
    },
    isAutoRemoveOnFinish: function() {
        return this.autoRemoveOnFinish
    },
    setAutoRemoveOnFinish: function(a) {
        this.autoRemoveOnFinish = a
    },
    getEmitterMode: function() {
        return this.emitterMode
    },
    setEmitterMode: function(a) {
        this.emitterMode = a
    },
    init: function() {
        return this.initWithTotalParticles(150)
    },
    initWithFile: function(a) {
        this._plistFile = a;
        var b = cc.loader.getRes(a);
        return b ? this.initWithDictionary(b, "") : (cc.log("cc.ParticleSystem.initWithFile(): Particles: file not found"), !1)
    },
    getBoundingBoxToWorld: function() {
        return cc.rect(0, 0, cc._canvas.width, cc._canvas.height)
    },
    initWithDictionary: function(a) {
        var b = !1,
            c = null,
            d = this._valueForKey,
            e = parseInt(d("maxParticles", a));
        if (this.initWithTotalParticles(e)) {
            this.angle = parseFloat(d("angle", a)), this.angleVar = parseFloat(d("angleVariance", a)), this.duration = parseFloat(d("duration", a)), this._blendFunc.src = parseInt(d("blendFuncSource", a)), this._blendFunc.dst = parseInt(d("blendFuncDestination", a));
            var f = this._startColor;
            f.r = 255 * parseFloat(d("startColorRed", a)), f.g = 255 * parseFloat(d("startColorGreen", a)), f.b = 255 * parseFloat(d("startColorBlue", a)), f.a = 255 * parseFloat(d("startColorAlpha", a));
            var g = this._startColorVar;
            g.r = 255 * parseFloat(d("startColorVarianceRed", a)), g.g = 255 * parseFloat(d("startColorVarianceGreen", a)), g.b = 255 * parseFloat(d("startColorVarianceBlue", a)), g.a = 255 * parseFloat(d("startColorVarianceAlpha", a));
            var h = this._endColor;
            h.r = 255 * parseFloat(d("finishColorRed", a)), h.g = 255 * parseFloat(d("finishColorGreen", a)), h.b = 255 * parseFloat(d("finishColorBlue", a)), h.a = 255 * parseFloat(d("finishColorAlpha", a));
            var i = this._endColorVar;
            if (i.r = 255 * parseFloat(d("finishColorVarianceRed", a)), i.g = 255 * parseFloat(d("finishColorVarianceGreen", a)), i.b = 255 * parseFloat(d("finishColorVarianceBlue", a)), i.a = 255 * parseFloat(d("finishColorVarianceAlpha", a)), this.startSize = parseFloat(d("startParticleSize", a)), this.startSizeVar = parseFloat(d("startParticleSizeVariance", a)), this.endSize = parseFloat(d("finishParticleSize", a)), this.endSizeVar = parseFloat(d("finishParticleSizeVariance", a)), this.setPosition(parseFloat(d("sourcePositionx", a)), parseFloat(d("sourcePositiony", a))), this._posVar.x = parseFloat(d("sourcePositionVariancex", a)), this._posVar.y = parseFloat(d("sourcePositionVariancey", a)), this.startSpin = parseFloat(d("rotationStart", a)), this.startSpinVar = parseFloat(d("rotationStartVariance", a)), this.endSpin = parseFloat(d("rotationEnd", a)), this.endSpinVar = parseFloat(d("rotationEndVariance", a)), this.emitterMode = parseInt(d("emitterType", a)), this.emitterMode == cc.ParticleSystem.MODE_GRAVITY) {
                var j = this.modeA;
                j.gravity.x = parseFloat(d("gravityx", a)), j.gravity.y = parseFloat(d("gravityy", a)), j.speed = parseFloat(d("speed", a)), j.speedVar = parseFloat(d("speedVariance", a));
                var k = d("radialAcceleration", a);
                j.radialAccel = k ? parseFloat(k) : 0, k = d("radialAccelVariance", a), j.radialAccelVar = k ? parseFloat(k) : 0, k = d("tangentialAcceleration", a), j.tangentialAccel = k ? parseFloat(k) : 0, k = d("tangentialAccelVariance", a), j.tangentialAccelVar = k ? parseFloat(k) : 0;
                var l = d("rotationIsDir", a).toLowerCase();
                j.rotationIsDir = null != l && ("true" === l || "1" === l)
            } else {
                if (this.emitterMode != cc.ParticleSystem.MODE_RADIUS) return cc.log("cc.ParticleSystem.initWithDictionary(): Invalid emitterType in config file"), !1;
                var m = this.modeB;
                m.startRadius = parseFloat(d("maxRadius", a)), m.startRadiusVar = parseFloat(d("maxRadiusVariance", a)), m.endRadius = parseFloat(d("minRadius", a)), m.endRadiusVar = 0, m.rotatePerSecond = parseFloat(d("rotatePerSecond", a)), m.rotatePerSecondVar = parseFloat(d("rotatePerSecondVariance", a))
            } if (this.life = parseFloat(d("particleLifespan", a)), this.lifeVar = parseFloat(d("particleLifespanVariance", a)), this.emissionRate = this._totalParticles / this.life, !this._batchNode) {
                this._opacityModifyRGB = !1;
                var n = d("textureFileName", a),
                    o = cc.path.changeBasename(this._plistFile, n),
                    p = cc.textureCache.getTextureForKey(o);
                if (p) this.setTexture(p);
                else {
                    var q = d("textureImageData", a);
                    if (q && 0 !== q.length) {
                        if (c = cc.unzipBase64AsArray(q, 1), !c) return cc.log("cc.ParticleSystem: error decoding or ungzipping textureImageData"), !1;
                        var r = cc.getImageFormatByData(c);
                        if (r !== cc.FMT_TIFF && r !== cc.FMT_PNG) return cc.log("cc.ParticleSystem: unknown image format with Data"), !1;
                        var s = cc.newElement("canvas");
                        if (r === cc.FMT_PNG) {
                            var t = new cc.PNGReader(c);
                            t.render(s)
                        } else {
                            var u = cc.tiffReader;
                            u.parseTIFF(c, s)
                        }
                        cc.textureCache.cacheImage(o, s);
                        var v = cc.textureCache.getTextureForKey(o);
                        v || cc.log("cc.ParticleSystem.initWithDictionary() : error loading the texture"), this.setTexture(v)
                    } else {
                        if (p = cc.textureCache.addImage(o), !p) return !1;
                        this.setTexture(p)
                    }
                }
            }
            b = !0
        }
        return b
    },
    initWithTotalParticles: function(a) {
        this._totalParticles = a;
        var b, c = this._particles;
        for (c.length = 0, b = 0; a > b; b++) c[b] = new cc.Particle;
        if (!c) return cc.log("Particle system: not enough memory"), !1;
        if (this._allocatedParticles = a, this._batchNode)
            for (b = 0; b < this._totalParticles; b++) c[b].atlasIndex = b;
        return this._isActive = !0, this._blendFunc.src = cc.BLEND_SRC, this._blendFunc.dst = cc.BLEND_DST, this.positionType = cc.ParticleSystem.TYPE_FREE, this.emitterMode = cc.ParticleSystem.MODE_GRAVITY, this.autoRemoveOnFinish = !1, this._transformSystemDirty = !1, this.scheduleUpdateWithPriority(1), this._renderCmd._initWithTotalParticles(a), !0
    },
    destroyParticleSystem: function() {
        this.unscheduleUpdate()
    },
    addParticle: function() {
        if (this.isFull()) return !1;
        var a = this._renderCmd.addParticle();
        return this.initParticle(a), ++this.particleCount, !0
    },
    initParticle: function(a) {
        var b = cc.randomMinus1To1;
        a.timeToLive = this.life + this.lifeVar * b(), a.timeToLive = Math.max(0, a.timeToLive), a.pos.x = this._sourcePosition.x + this._posVar.x * b(), a.pos.y = this._sourcePosition.y + this._posVar.y * b();
        var c, d, e = this._startColor,
            f = this._startColorVar,
            g = this._endColor,
            h = this._endColorVar;
        c = {
            r: cc.clampf(e.r + f.r * b(), 0, 255),
            g: cc.clampf(e.g + f.g * b(), 0, 255),
            b: cc.clampf(e.b + f.b * b(), 0, 255),
            a: cc.clampf(e.a + f.a * b(), 0, 255)
        }, d = {
            r: cc.clampf(g.r + h.r * b(), 0, 255),
            g: cc.clampf(g.g + h.g * b(), 0, 255),
            b: cc.clampf(g.b + h.b * b(), 0, 255),
            a: cc.clampf(g.a + h.a * b(), 0, 255)
        }, a.color = c;
        var i = a.deltaColor,
            j = a.timeToLive;
        i.r = (d.r - c.r) / j, i.g = (d.g - c.g) / j, i.b = (d.b - c.b) / j, i.a = (d.a - c.a) / j;
        var k = this.startSize + this.startSizeVar * b();
        if (k = Math.max(0, k), a.size = k, this.endSize === cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE) a.deltaSize = 0;
        else {
            var l = this.endSize + this.endSizeVar * b();
            l = Math.max(0, l), a.deltaSize = (l - k) / j
        }
        var m = this.startSpin + this.startSpinVar * b(),
            n = this.endSpin + this.endSpinVar * b();
        a.rotation = m, a.deltaRotation = (n - m) / j, this.positionType == cc.ParticleSystem.TYPE_FREE ? a.startPos = this.convertToWorldSpace(this._pointZeroForParticle) : this.positionType == cc.ParticleSystem.TYPE_RELATIVE && (a.startPos.x = this._position.x, a.startPos.y = this._position.y);
        var o = cc.degreesToRadians(this.angle + this.angleVar * b());
        if (this.emitterMode === cc.ParticleSystem.MODE_GRAVITY) {
            var p = this.modeA,
                q = a.modeA,
                r = p.speed + p.speedVar * b();
            q.dir.x = Math.cos(o), q.dir.y = Math.sin(o), cc.pMultIn(q.dir, r), q.radialAccel = p.radialAccel + p.radialAccelVar * b(), q.tangentialAccel = p.tangentialAccel + p.tangentialAccelVar * b(), p.rotationIsDir && (a.rotation = -cc.radiansToDegrees(cc.pToAngle(q.dir)))
        } else {
            var s = this.modeB,
                t = a.modeB,
                u = s.startRadius + s.startRadiusVar * b(),
                v = s.endRadius + s.endRadiusVar * b();
            t.radius = u, t.deltaRadius = s.endRadius === cc.ParticleSystem.START_RADIUS_EQUAL_TO_END_RADIUS ? 0 : (v - u) / j, t.angle = o, t.degreesPerSecond = cc.degreesToRadians(s.rotatePerSecond + s.rotatePerSecondVar * b())
        }
    },
    stopSystem: function() {
        this._isActive = !1, this._elapsed = this.duration, this._emitCounter = 0
    },
    resetSystem: function() {
        this._isActive = !0, this._elapsed = 0;
        var a = this._particles;
        for (this._particleIdx = 0; this._particleIdx < this.particleCount; ++this._particleIdx) a[this._particleIdx].timeToLive = 0
    },
    isFull: function() {
        return this.particleCount >= this._totalParticles
    },
    updateQuadWithParticle: function(a, b) {
        this._renderCmd.updateQuadWithParticle(a, b)
    },
    postStep: function() {
        this._renderCmd.postStep()
    },
    update: function(a) {
        if (this._isActive && this.emissionRate) {
            var b = 1 / this.emissionRate;
            for (this.particleCount < this._totalParticles && (this._emitCounter += a); this.particleCount < this._totalParticles && this._emitCounter > b;) this.addParticle(), this._emitCounter -= b;
            this._elapsed += a, -1 != this.duration && this.duration < this._elapsed && this.stopSystem()
        }
        this._particleIdx = 0;
        var c = cc.Particle.TemporaryPoints[0];
        if (this.positionType == cc.ParticleSystem.TYPE_FREE ? cc.pIn(c, this.convertToWorldSpace(this._pointZeroForParticle)) : this.positionType == cc.ParticleSystem.TYPE_RELATIVE && (c.x = this._position.x, c.y = this._position.y), this._visible) {
            for (var d = cc.Particle.TemporaryPoints[1], e = cc.Particle.TemporaryPoints[2], f = cc.Particle.TemporaryPoints[3], g = this._particles; this._particleIdx < this.particleCount;) {
                cc.pZeroIn(d), cc.pZeroIn(e), cc.pZeroIn(f);
                var h = g[this._particleIdx];
                if (h.timeToLive -= a, h.timeToLive > 0) {
                    if (this.emitterMode == cc.ParticleSystem.MODE_GRAVITY) {
                        var i = f,
                            j = d,
                            k = e;
                        h.pos.x || h.pos.y ? (cc.pIn(j, h.pos), cc.pNormalizeIn(j)) : cc.pZeroIn(j), cc.pIn(k, j), cc.pMultIn(j, h.modeA.radialAccel);
                        var l = k.x;
                        k.x = -k.y, k.y = l, cc.pMultIn(k, h.modeA.tangentialAccel), cc.pIn(i, j), cc.pAddIn(i, k), cc.pAddIn(i, this.modeA.gravity), cc.pMultIn(i, a), cc.pAddIn(h.modeA.dir, i), cc.pIn(i, h.modeA.dir), cc.pMultIn(i, a), cc.pAddIn(h.pos, i)
                    } else {
                        var m = h.modeB;
                        m.angle += m.degreesPerSecond * a, m.radius += m.deltaRadius * a, h.pos.x = -Math.cos(m.angle) * m.radius, h.pos.y = -Math.sin(m.angle) * m.radius
                    }
                    this._renderCmd._updateDeltaColor(h, a), h.size += h.deltaSize * a, h.size = Math.max(0, h.size), h.rotation += h.deltaRotation * a;
                    var n = d;
                    if (this.positionType == cc.ParticleSystem.TYPE_FREE || this.positionType == cc.ParticleSystem.TYPE_RELATIVE) {
                        var o = e;
                        cc.pIn(o, c), cc.pSubIn(o, h.startPos), cc.pIn(n, h.pos), cc.pSubIn(n, o)
                    } else cc.pIn(n, h.pos);
                    this._batchNode && (n.x += this._position.x, n.y += this._position.y), this._renderCmd.updateParticlePosition(h, n), ++this._particleIdx
                } else {
                    var p = h.atlasIndex;
                    if (this._particleIdx !== this.particleCount - 1) {
                        var q = g[this._particleIdx];
                        g[this._particleIdx] = g[this.particleCount - 1], g[this.particleCount - 1] = q
                    }
                    if (this._batchNode && (this._batchNode.disableParticle(this.atlasIndex + p), g[this.particleCount - 1].atlasIndex = p), --this.particleCount, 0 == this.particleCount && this.autoRemoveOnFinish) return this.unscheduleUpdate(), void this._parent.removeChild(this, !0)
                }
            }
            this._transformSystemDirty = !1
        }
        this._batchNode || this.postStep()
    },
    updateWithNoTime: function() {
        this.update(0)
    },
    _valueForKey: function(a, b) {
        if (b) {
            var c = b[a];
            return null != c ? c : ""
        }
        return ""
    },
    _updateBlendFunc: function() {
        if (this._batchNode) return void cc.log("Can't change blending functions when the particle is being batched");
        var a = this._texture;
        if (a && a instanceof cc.Texture2D) {
            this._opacityModifyRGB = !1;
            var b = this._blendFunc;
            b.src == cc.BLEND_SRC && b.dst == cc.BLEND_DST && (a.hasPremultipliedAlpha() ? this._opacityModifyRGB = !0 : (b.src = cc.SRC_ALPHA, b.dst = cc.ONE_MINUS_SRC_ALPHA))
        }
    },
    clone: function() {
        var a = new cc.ParticleSystem;
        if (a.initWithTotalParticles(this.getTotalParticles())) {
            a.setAngle(this.getAngle()), a.setAngleVar(this.getAngleVar()), a.setDuration(this.getDuration());
            var b = this.getBlendFunc();
            if (a.setBlendFunc(b.src, b.dst), a.setStartColor(this.getStartColor()), a.setStartColorVar(this.getStartColorVar()), a.setEndColor(this.getEndColor()), a.setEndColorVar(this.getEndColorVar()), a.setStartSize(this.getStartSize()), a.setStartSizeVar(this.getStartSizeVar()), a.setEndSize(this.getEndSize()), a.setEndSizeVar(this.getEndSizeVar()), a.setPosition(cc.p(this.x, this.y)), a.setPosVar(cc.p(this.getPosVar().x, this.getPosVar().y)), a.setStartSpin(this.getStartSpin() || 0), a.setStartSpinVar(this.getStartSpinVar() || 0), a.setEndSpin(this.getEndSpin() || 0), a.setEndSpinVar(this.getEndSpinVar() || 0), a.setEmitterMode(this.getEmitterMode()), this.getEmitterMode() == cc.ParticleSystem.MODE_GRAVITY) {
                var c = this.getGravity();
                a.setGravity(cc.p(c.x, c.y)), a.setSpeed(this.getSpeed()), a.setSpeedVar(this.getSpeedVar()), a.setRadialAccel(this.getRadialAccel()), a.setRadialAccelVar(this.getRadialAccelVar()), a.setTangentialAccel(this.getTangentialAccel()), a.setTangentialAccelVar(this.getTangentialAccelVar())
            } else this.getEmitterMode() == cc.ParticleSystem.MODE_RADIUS && (a.setStartRadius(this.getStartRadius()), a.setStartRadiusVar(this.getStartRadiusVar()), a.setEndRadius(this.getEndRadius()), a.setEndRadiusVar(this.getEndRadiusVar()), a.setRotatePerSecond(this.getRotatePerSecond()), a.setRotatePerSecondVar(this.getRotatePerSecondVar())); if (a.setLife(this.getLife()), a.setLifeVar(this.getLifeVar()), a.setEmissionRate(this.getEmissionRate()), !this.getBatchNode()) {
                a.setOpacityModifyRGB(this.isOpacityModifyRGB());
                var d = this.getTexture();
                if (d) {
                    var e = d.getContentSize();
                    a.setTextureWithRect(d, cc.rect(0, 0, e.width, e.height))
                }
            }
        }
        return a
    },
    setDisplayFrame: function(a) {
        if (a) {
            var b = a.getOffsetInPixels();
            (0 != b.x || 0 != b.y) && cc.log("cc.ParticleSystem.setDisplayFrame(): QuadParticle only supports SpriteFrames with no offsets");
            var c = a.getTexture(),
                d = this._texture;
            d != c && this.setTexture(c)
        }
    },
    setTextureWithRect: function(a, b) {
        var c = this._texture;
        c != a && (this._texture = a, this._updateBlendFunc()), this.initTexCoordsWithRect(b)
    },
    listenBackToForeground: function() {}
});
var _p = cc.ParticleSystem.prototype;
_p.opacityModifyRGB, cc.defineGetterSetter(_p, "opacityModifyRGB", _p.isOpacityModifyRGB, _p.setOpacityModifyRGB), _p.batchNode, cc.defineGetterSetter(_p, "batchNode", _p.getBatchNode, _p.setBatchNode), _p.drawMode, cc.defineGetterSetter(_p, "drawMode", _p.getDrawMode, _p.setDrawMode), _p.shapeType, cc.defineGetterSetter(_p, "shapeType", _p.getShapeType, _p.setShapeType), _p.active, cc.defineGetterSetter(_p, "active", _p.isActive), _p.sourcePos, cc.defineGetterSetter(_p, "sourcePos", _p.getSourcePosition, _p.setSourcePosition), _p.posVar, cc.defineGetterSetter(_p, "posVar", _p.getPosVar, _p.setPosVar), _p.gravity, cc.defineGetterSetter(_p, "gravity", _p.getGravity, _p.setGravity), _p.speed, cc.defineGetterSetter(_p, "speed", _p.getSpeed, _p.setSpeed), _p.speedVar, cc.defineGetterSetter(_p, "speedVar", _p.getSpeedVar, _p.setSpeedVar), _p.tangentialAccel, cc.defineGetterSetter(_p, "tangentialAccel", _p.getTangentialAccel, _p.setTangentialAccel), _p.tangentialAccelVar, cc.defineGetterSetter(_p, "tangentialAccelVar", _p.getTangentialAccelVar, _p.setTangentialAccelVar), _p.radialAccel, cc.defineGetterSetter(_p, "radialAccel", _p.getRadialAccel, _p.setRadialAccel), _p.radialAccelVar, cc.defineGetterSetter(_p, "radialAccelVar", _p.getRadialAccelVar, _p.setRadialAccelVar), _p.rotationIsDir, cc.defineGetterSetter(_p, "rotationIsDir", _p.getRotationIsDir, _p.setRotationIsDir), _p.startRadius, cc.defineGetterSetter(_p, "startRadius", _p.getStartRadius, _p.setStartRadius), _p.startRadiusVar, cc.defineGetterSetter(_p, "startRadiusVar", _p.getStartRadiusVar, _p.setStartRadiusVar), _p.endRadius, cc.defineGetterSetter(_p, "endRadius", _p.getEndRadius, _p.setEndRadius), _p.endRadiusVar, cc.defineGetterSetter(_p, "endRadiusVar", _p.getEndRadiusVar, _p.setEndRadiusVar), _p.rotatePerS, cc.defineGetterSetter(_p, "rotatePerS", _p.getRotatePerSecond, _p.setRotatePerSecond), _p.rotatePerSVar, cc.defineGetterSetter(_p, "rotatePerSVar", _p.getRotatePerSecondVar, _p.setRotatePerSecondVar), _p.startColor, cc.defineGetterSetter(_p, "startColor", _p.getStartColor, _p.setStartColor), _p.startColorVar, cc.defineGetterSetter(_p, "startColorVar", _p.getStartColorVar, _p.setStartColorVar), _p.endColor, cc.defineGetterSetter(_p, "endColor", _p.getEndColor, _p.setEndColor), _p.endColorVar, cc.defineGetterSetter(_p, "endColorVar", _p.getEndColorVar, _p.setEndColorVar), _p.totalParticles, cc.defineGetterSetter(_p, "totalParticles", _p.getTotalParticles, _p.setTotalParticles), _p.texture, cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture), cc.ParticleSystem.create = function(a) {
        return new cc.ParticleSystem(a)
    }, cc.ParticleSystem.createWithTotalParticles = cc.ParticleSystem.create, cc.ParticleSystem.ModeA = function(a, b, c, d, e, f, g, h) {
        this.gravity = a ? a : cc.p(0, 0), this.speed = b || 0, this.speedVar = c || 0, this.tangentialAccel = d || 0, this.tangentialAccelVar = e || 0, this.radialAccel = f || 0, this.radialAccelVar = g || 0, this.rotationIsDir = h || !1
    }, cc.ParticleSystem.ModeB = function(a, b, c, d, e, f) {
        this.startRadius = a || 0, this.startRadiusVar = b || 0, this.endRadius = c || 0, this.endRadiusVar = d || 0, this.rotatePerSecond = e || 0, this.rotatePerSecondVar = f || 0
    }, cc.ParticleSystem.SHAPE_MODE = 0, cc.ParticleSystem.TEXTURE_MODE = 1, cc.ParticleSystem.STAR_SHAPE = 0, cc.ParticleSystem.BALL_SHAPE = 1, cc.ParticleSystem.DURATION_INFINITY = -1, cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE = -1, cc.ParticleSystem.START_RADIUS_EQUAL_TO_END_RADIUS = -1, cc.ParticleSystem.MODE_GRAVITY = 0, cc.ParticleSystem.MODE_RADIUS = 1, cc.ParticleSystem.TYPE_FREE = 0, cc.ParticleSystem.TYPE_RELATIVE = 1, cc.ParticleSystem.TYPE_GROUPED = 2,
    function() {
        cc.ParticleSystem.CanvasRenderCmd = function(a) {
            cc.Node.CanvasRenderCmd.call(this, a), this._needDraw = !0, this._drawMode = cc.ParticleSystem.SHAPE_MODE, this._shapeType = cc.ParticleSystem.BALL_SHAPE, this._pointRect = cc.rect(0, 0, 0, 0)
        };
        var a = cc.ParticleSystem.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
        a.constructor = cc.ParticleSystem.CanvasRenderCmd, a.getDrawMode = function() {
            return this._drawMode
        }, a.setDrawMode = function(a) {
            this._drawMode = a
        }, a.getShapeType = function() {
            return this._shapeType
        }, a.setShapeType = function(a) {
            this._shapeType = a
        }, a.setBatchNode = function(a) {
            this._batchNode != a && (this._node._batchNode = a)
        }, a.updateQuadWithParticle = function() {}, a.updateParticlePosition = function(a, b) {
            cc.pIn(a.drawPos, b)
        }, a.rendering = function(a, b, c) {
            var d = a || cc._renderContext,
                e = d.getContext(),
                f = this._node,
                g = this._pointRect;
            d.setTransform(this._worldTransform, b, c), d.save(), e.globalCompositeOperation = f.isBlendAdditive() ? "lighter" : "source-over";
            var h, i, j, k, l = this._node.particleCount,
                m = this._node._particles;
            if (f.drawMode == cc.ParticleSystem.TEXTURE_MODE) {
                if (!f._texture || !f._texture._isLoaded) return void d.restore();
                var n = f._texture.getHtmlElementObj();
                if (!n.width || !n.height) return void d.restore();
                var o = n;
                for (h = 0; l > h; h++)
                    if (i = m[h], j = 0 | .5 * i.size, k = i.color.a / 255, 0 !== k) {
                        e.globalAlpha = k, e.save(), e.translate(0 | i.drawPos.x, -(0 | i.drawPos.y));
                        var p = 4 * Math.floor(i.size / 4),
                            q = g.width,
                            r = g.height;
                        e.scale(Math.max(1 / q * p, 1e-6), Math.max(1 / r * p, 1e-6)), i.rotation && e.rotate(cc.degreesToRadians(i.rotation)), o = i.isChangeColor ? this._changeTextureColor(n, i.color, this._pointRect) : n, e.drawImage(o, -(0 | q / 2), -(0 | r / 2)), e.restore()
                    }
            } else {
                var s = cc._drawingUtil;
                for (h = 0; l > h; h++) i = m[h], j = 0 | .5 * i.size, k = i.color.a / 255, 0 !== k && (e.globalAlpha = k, e.save(), e.translate(0 | i.drawPos.x, -(0 | i.drawPos.y)), f.shapeType == cc.ParticleSystem.STAR_SHAPE ? (i.rotation && e.rotate(cc.degreesToRadians(i.rotation)), s.drawStar(d, j, i.color)) : s.drawColorBall(d, j, i.color), e.restore())
            }
            d.restore(), cc.g_NumberOfDraws++
        }, a._changeTextureColor = cc.sys._supportCanvasNewBlendModes ? function(a, b, c) {
            return a.tintCache || (a.tintCache = document.createElement("canvas"), a.tintCache.width = a.width, a.tintCache.height = a.height), cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply(a, b, c, a.tintCache)
        } : function(a, b, c) {
            var d = cc.textureCache.getTextureColors(a);
            return d ? (d.tintCache || (d.tintCache = document.createElement("canvas"), d.tintCache.width = a.width, d.tintCache.height = a.height), cc.Sprite.CanvasRenderCmd._generateTintImage(a, d, b, c, d.tintCache), d.tintCache) : null
        }, a.initTexCoordsWithRect = function(a) {
            this._pointRect = a
        }, a.setTotalParticles = function(a) {
            this._node._totalParticles = 200 > a ? a : 200
        }, a.addParticle = function() {
            var a, b = this._node,
                c = b._particles;
            return b.particleCount < c.length ? a = c[b.particleCount] : (a = new cc.Particle, c.push(a)), a
        }, a._setupVBO = function() {}, a._allocMemory = function() {
            return !0
        }, a.postStep = function() {}, a._setBlendAdditive = function() {
            var a = this._node._blendFunc;
            a.src = cc.BLEND_SRC, a.dst = cc.BLEND_DST
        }, a._initWithTotalParticles = function() {}, a._updateDeltaColor = function(a, b) {
            this._dontTint || (a.color.r += a.deltaColor.r * b, a.color.g += a.deltaColor.g * b, a.color.b += a.deltaColor.b * b, a.color.a += a.deltaColor.a * b, a.isChangeColor = !0)
        }
    }(), cc.ParticleFire = cc.ParticleSystem.extend({
        ctor: function() {
            cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 300 : 150)
        },
        initWithTotalParticles: function(a) {
            if (cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a)) {
                this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(60), this.setSpeedVar(20), this.setAngle(90), this.setAngleVar(10);
                var b = cc.director.getWinSize();
                return this.setPosition(b.width / 2, 60), this.setPosVar(cc.p(40, 20)), this.setLife(3), this.setLifeVar(.25), this.setStartSize(54), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(194, 64, 31, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!0), !0
            }
            return !1
        }
    }), cc.ParticleFire.create = function() {
        return new cc.ParticleFire
    }, cc.ParticleFireworks = cc.ParticleSystem.extend({
        ctor: function() {
            cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 1500 : 150)
        },
        initWithTotalParticles: function(a) {
            if (cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a)) {
                this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, -90)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(180), this.setSpeedVar(50);
                var b = cc.director.getWinSize();
                return this.setPosition(b.width / 2, b.height / 2), this.setAngle(90), this.setAngleVar(20), this.setLife(3.5), this.setLifeVar(1), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(128, 128, 128, 255)), this.setStartColorVar(cc.color(128, 128, 128, 255)), this.setEndColor(cc.color(26, 26, 26, 51)), this.setEndColorVar(cc.color(26, 26, 26, 51)), this.setStartSize(8), this.setStartSizeVar(2), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setBlendAdditive(!1), !0
            }
            return !1
        }
    }), cc.ParticleFireworks.create = function() {
        return new cc.ParticleFireworks
    }, cc.ParticleSun = cc.ParticleSystem.extend({
        ctor: function() {
            cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 350 : 150)
        },
        initWithTotalParticles: function(a) {
            if (cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a)) {
                this.setBlendAdditive(!0), this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(20), this.setSpeedVar(5), this.setAngle(90), this.setAngleVar(360);
                var b = cc.director.getWinSize();
                return this.setPosition(b.width / 2, b.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(1), this.setLifeVar(.5), this.setStartSize(30), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(194, 64, 31, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), !0
            }
            return !1
        }
    }), cc.ParticleSun.create = function() {
        return new cc.ParticleSun
    }, cc.ParticleGalaxy = cc.ParticleSystem.extend({
        ctor: function() {
            cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 200 : 100)
        },
        initWithTotalParticles: function(a) {
            if (cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a)) {
                this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(60), this.setSpeedVar(10), this.setRadialAccel(-80), this.setRadialAccelVar(0), this.setTangentialAccel(80), this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(360);
                var b = cc.director.getWinSize();
                return this.setPosition(b.width / 2, b.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(4), this.setLifeVar(1), this.setStartSize(37), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(31, 64, 194, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!0), !0
            }
            return !1
        }
    }), cc.ParticleGalaxy.create = function() {
        return new cc.ParticleGalaxy
    }, cc.ParticleFlower = cc.ParticleSystem.extend({
        ctor: function() {
            cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 250 : 100)
        },
        initWithTotalParticles: function(a) {
            if (cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a)) {
                this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(80), this.setSpeedVar(10), this.setRadialAccel(-60), this.setRadialAccelVar(0), this.setTangentialAccel(15), this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(360);
                var b = cc.director.getWinSize();
                return this.setPosition(b.width / 2, b.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(4), this.setLifeVar(1), this.setStartSize(30), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(128, 128, 128, 255)), this.setStartColorVar(cc.color(128, 128, 128, 128)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!0), !0
            }
            return !1
        }
    }), cc.ParticleFlower.create = function() {
        return new cc.ParticleFlower
    }, cc.ParticleMeteor = cc.ParticleSystem.extend({
        ctor: function() {
            cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 150 : 100)
        },
        initWithTotalParticles: function(a) {
            if (cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a)) {
                this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(-200, 200)), this.setSpeed(15), this.setSpeedVar(5), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setTangentialAccel(0), this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(360);
                var b = cc.director.getWinSize();
                return this.setPosition(b.width / 2, b.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(2), this.setLifeVar(1), this.setStartSize(60), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(51, 102, 179)), this.setStartColorVar(cc.color(0, 0, 51, 26)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!0), !0
            }
            return !1
        }
    }), cc.ParticleMeteor.create = function() {
        return new cc.ParticleMeteor
    }, cc.ParticleSpiral = cc.ParticleSystem.extend({
        ctor: function() {
            cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 500 : 100)
        },
        initWithTotalParticles: function(a) {
            if (cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a)) {
                this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(150), this.setSpeedVar(0), this.setRadialAccel(-380), this.setRadialAccelVar(0), this.setTangentialAccel(45), this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(0);
                var b = cc.director.getWinSize();
                return this.setPosition(b.width / 2, b.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(12), this.setLifeVar(0), this.setStartSize(20), this.setStartSizeVar(0), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(128, 128, 128, 255)), this.setStartColorVar(cc.color(128, 128, 128, 0)), this.setEndColor(cc.color(128, 128, 128, 255)), this.setEndColorVar(cc.color(128, 128, 128, 0)), this.setBlendAdditive(!1), !0
            }
            return !1
        }
    }), cc.ParticleSpiral.create = function() {
        return new cc.ParticleSpiral
    }, cc.ParticleExplosion = cc.ParticleSystem.extend({
        ctor: function() {
            cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 700 : 300)
        },
        initWithTotalParticles: function(a) {
            if (cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a)) {
                this.setDuration(.1), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(70), this.setSpeedVar(40), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setTangentialAccel(0), this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(360);
                var b = cc.director.getWinSize();
                return this.setPosition(b.width / 2, b.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(5), this.setLifeVar(2), this.setStartSize(15), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getDuration()), this.setStartColor(cc.color(179, 26, 51, 255)), this.setStartColorVar(cc.color(128, 128, 128, 0)), this.setEndColor(cc.color(128, 128, 128, 0)), this.setEndColorVar(cc.color(128, 128, 128, 0)), this.setBlendAdditive(!1), !0
            }
            return !1
        }
    }), cc.ParticleExplosion.create = function() {
        return new cc.ParticleExplosion
    }, cc.ParticleSmoke = cc.ParticleSystem.extend({
        ctor: function() {
            cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 200 : 100)
        },
        initWithTotalParticles: function(a) {
            if (cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a)) {
                this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(25), this.setSpeedVar(10), this.setAngle(90), this.setAngleVar(5);
                var b = cc.director.getWinSize();
                return this.setPosition(b.width / 2, 0), this.setPosVar(cc.p(20, 0)), this.setLife(4), this.setLifeVar(1), this.setStartSize(60), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(204, 204, 204, 255)), this.setStartColorVar(cc.color(5, 5, 5, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!1), !0
            }
            return !1
        }
    }), cc.ParticleSmoke.create = function() {
        return new cc.ParticleSmoke
    }, cc.ParticleSnow = cc.ParticleSystem.extend({
        ctor: function() {
            cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 700 : 250)
        },
        initWithTotalParticles: function(a) {
            if (cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a)) {
                this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, -1)), this.setSpeed(5), this.setSpeedVar(1), this.setRadialAccel(0), this.setRadialAccelVar(1), this.setTangentialAccel(0), this.setTangentialAccelVar(1);
                var b = cc.director.getWinSize();
                return this.setPosition(b.width / 2, b.height + 10), this.setPosVar(cc.p(b.width / 2, 0)), this.setAngle(-90), this.setAngleVar(5), this.setLife(45), this.setLifeVar(15), this.setStartSize(10), this.setStartSizeVar(5), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(10), this.setStartColor(cc.color(255, 255, 255, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(255, 255, 255, 0)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!1), !0
            }
            return !1
        }
    }), cc.ParticleSnow.create = function() {
        return new cc.ParticleSnow
    }, cc.ParticleRain = cc.ParticleSystem.extend({
        ctor: function() {
            cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 1e3 : 300)
        },
        initWithTotalParticles: function(a) {
            if (cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a)) {
                this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(10, -10)), this.setRadialAccel(0), this.setRadialAccelVar(1), this.setTangentialAccel(0), this.setTangentialAccelVar(1), this.setSpeed(130), this.setSpeedVar(30), this.setAngle(-90), this.setAngleVar(5);
                var b = cc.director.getWinSize();
                return this.setPosition(b.width / 2, b.height), this.setPosVar(cc.p(b.width / 2, 0)), this.setLife(4.5), this.setLifeVar(0), this.setStartSize(4), this.setStartSizeVar(2), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(20), this.setStartColor(cc.color(179, 204, 255, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(179, 204, 255, 128)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!1), !0
            }
            return !1
        }
    }), cc.ParticleRain.create = function() {
        return new cc.ParticleRain
    }, cc.PARTICLE_DEFAULT_CAPACITY = 500, cc.ParticleBatchNode = cc.Node.extend({
        textureAtlas: null,
        _blendFunc: null,
        _className: "ParticleBatchNode",
        ctor: function(a, b) {
            cc.Node.prototype.ctor.call(this), this._blendFunc = {
                src: cc.BLEND_SRC,
                dst: cc.BLEND_DST
            }, cc.isString(a) ? this.init(a, b) : a instanceof cc.Texture2D && this.initWithTexture(a, b)
        },
        _createRenderCmd: function() {
            return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.ParticleBatchNode.CanvasRenderCmd(this) : new cc.ParticleBatchNode.WebGLRenderCmd(this)
        },
        initWithTexture: function(a, b) {
            return this.textureAtlas = new cc.TextureAtlas, this.textureAtlas.initWithTexture(a, b), this._children.length = 0, this._renderCmd._initWithTexture(), !0
        },
        initWithFile: function(a, b) {
            var c = cc.textureCache.addImage(a);
            return this.initWithTexture(c, b)
        },
        init: function(a, b) {
            var c = cc.textureCache.addImage(a);
            return this.initWithTexture(c, b)
        },
        addChild: function(a, b, c) {
            if (!a) throw "cc.ParticleBatchNode.addChild() : child should be non-null";
            if (!(a instanceof cc.ParticleSystem)) throw "cc.ParticleBatchNode.addChild() : only supports cc.ParticleSystem as children";
            if (b = null == b ? a.zIndex : b, c = null == c ? a.tag : c, a.getTexture() != this.textureAtlas.texture) throw "cc.ParticleSystem.addChild() : the child is not using the same texture id";
            var d = a.getBlendFunc();
            if (0 === this._children.length) this.setBlendFunc(d);
            else if (d.src != this._blendFunc.src || d.dst != this._blendFunc.dst) return void cc.log("cc.ParticleSystem.addChild() : Can't add a ParticleSystem that uses a different blending function");
            var e = this._addChildHelper(a, b, c),
                f = 0;
            if (0 != e) {
                var g = this._children[e - 1];
                f = g.getAtlasIndex() + g.getTotalParticles()
            } else f = 0;
            this.insertChild(a, f), a.setBatchNode(this)
        },
        insertChild: function(a, b) {
            var c = a.getTotalParticles(),
                d = this.textureAtlas,
                e = d.totalQuads;
            a.setAtlasIndex(b), e + c > d.getCapacity() && (this._increaseAtlasCapacityTo(e + c), d.fillWithEmptyQuadsFromIndex(d.getCapacity() - c, c)), a.getAtlasIndex() + c != e && d.moveQuadsFromIndex(b, b + c), d.increaseTotalQuadsWith(c), this._updateAllAtlasIndexes()
        },
        removeChild: function(a, b) {
            if (null != a) {
                if (!(a instanceof cc.ParticleSystem)) throw "cc.ParticleBatchNode.removeChild(): only supports cc.ParticleSystem as children";
                if (-1 == this._children.indexOf(a)) return void cc.log("cc.ParticleBatchNode.removeChild(): doesn't contain the sprite. Can't remove it");
                cc.Node.prototype.removeChild.call(this, a, b);
                var c = this.textureAtlas;
                c.removeQuadsAtIndex(a.getAtlasIndex(), a.getTotalParticles()), c.fillWithEmptyQuadsFromIndex(c.totalQuads, a.getTotalParticles()), a.setBatchNode(null), this._updateAllAtlasIndexes()
            }
        },
        reorderChild: function(a, b) {
            if (!a) throw "cc.ParticleBatchNode.reorderChild(): child should be non-null";
            if (!(a instanceof cc.ParticleSystem)) throw "cc.ParticleBatchNode.reorderChild(): only supports cc.QuadParticleSystems as children";
            if (-1 === this._children.indexOf(a)) return void cc.log("cc.ParticleBatchNode.reorderChild(): Child doesn't belong to batch");
            if (b != a.zIndex) {
                if (this._children.length > 1) {
                    var c = this._getCurrentIndex(a, b);
                    if (c.oldIndex != c.newIndex) {
                        this._children.splice(c.oldIndex, 1), this._children.splice(c.newIndex, 0, a);
                        var d = a.getAtlasIndex();
                        this._updateAllAtlasIndexes();
                        for (var e = 0, f = this._children, g = 0; g < f.length; g++) {
                            var h = f[g];
                            if (h == a) {
                                e = a.getAtlasIndex();
                                break
                            }
                        }
                        this.textureAtlas.moveQuadsFromIndex(d, a.getTotalParticles(), e), a.updateWithNoTime()
                    }
                }
                a._setLocalZOrder(b)
            }
        },
        removeChildAtIndex: function(a, b) {
            this.removeChild(this._children[i], b)
        },
        removeAllChildren: function(a) {
            for (var b = this._children, c = 0; c < b.length; c++) b[c].setBatchNode(null);
            cc.Node.prototype.removeAllChildren.call(this, a), this.textureAtlas.removeAllQuads()
        },
        disableParticle: function(a) {
            var b = this.textureAtlas.quads[a];
            b.br.vertices.x = b.br.vertices.y = b.tr.vertices.x = b.tr.vertices.y = b.tl.vertices.x = b.tl.vertices.y = b.bl.vertices.x = b.bl.vertices.y = 0, this.textureAtlas._setDirty(!0)
        },
        getTexture: function() {
            return this.textureAtlas.texture
        },
        setTexture: function(a) {
            this.textureAtlas.texture = a;
            var b = this._blendFunc;
            a && !a.hasPremultipliedAlpha() && b.src == cc.BLEND_SRC && b.dst == cc.BLEND_DST && (b.src = cc.SRC_ALPHA, b.dst = cc.ONE_MINUS_SRC_ALPHA)
        },
        setBlendFunc: function(a, b) {
            void 0 === b ? (this._blendFunc.src = a.src, this._blendFunc.dst = a.dst) : (this._blendFunc.src = a, this._blendFunc.src = b)
        },
        getBlendFunc: function() {
            return new cc.BlendFunc(this._blendFunc.src, this._blendFunc.dst)
        },
        _updateAllAtlasIndexes: function() {
            for (var a = 0, b = this._children, c = 0; c < b.length; c++) {
                var d = b[c];
                d.setAtlasIndex(a), a += d.getTotalParticles()
            }
        },
        _increaseAtlasCapacityTo: function(a) {
            cc.log("cocos2d: cc.ParticleBatchNode: resizing TextureAtlas capacity from [" + this.textureAtlas.getCapacity() + "] to [" + a + "]."), this.textureAtlas.resizeCapacity(a) || cc.log("cc.ParticleBatchNode._increaseAtlasCapacityTo() : WARNING: Not enough memory to resize the atlas")
        },
        _searchNewPositionInChildrenForZ: function(a) {
            for (var b = this._children, c = b.length, d = 0; c > d; d++)
                if (b[d].zIndex > a) return d;
            return c
        },
        _getCurrentIndex: function(a, b) {
            for (var c = !1, d = !1, e = 0, f = 0, g = 0, h = this._children, i = h.length, j = 0; i > j; j++) {
                var k = h[j];
                if (k.zIndex > b && !d && (e = j, d = !0, c && d)) break;
                if (a == k && (f = j, c = !0, d || (g = -1), c && d)) break
            }
            return d || (e = i), e += g, {
                newIndex: e,
                oldIndex: f
            }
        },
        _addChildHelper: function(a, b, c) {
            if (!a) throw "cc.ParticleBatchNode._addChildHelper(): child should be non-null";
            if (a.parent) return cc.log("cc.ParticleBatchNode._addChildHelper(): child already added. It can't be added again"), null;
            this._children || (this._children = []);
            var d = this._searchNewPositionInChildrenForZ(b);
            return this._children.splice(d, 0, a), a.tag = c, a._setLocalZOrder(b), a.parent = this, this._running && (a.onEnter(), a.onEnterTransitionDidFinish()), d
        },
        _updateBlendFunc: function() {
            this.textureAtlas.texture.hasPremultipliedAlpha() || (this._blendFunc.src = cc.SRC_ALPHA, this._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA)
        },
        getTextureAtlas: function() {
            return this.textureAtlas
        },
        setTextureAtlas: function(a) {
            this.textureAtlas = a
        }
    });
var _p = cc.ParticleBatchNode.prototype;
_p.texture, cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture), cc.ParticleBatchNode.create = function(a, b) {
        return new cc.ParticleBatchNode(a, b)
    },
    function() {
        cc.ParticleBatchNode.CanvasRenderCmd = function(a) {
            cc.Node.CanvasRenderCmd.call(this, a), this._needDraw = !1
        };
        var a = cc.ParticleBatchNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
        a.constructor = cc.ParticleBatchNode.CanvasRenderCmd, a._initWithTexture = function() {}
    }();
! function() {
    cc.ParticleBatchNode.WebGLRenderCmd = function(a) {
        cc.Node.WebGLRenderCmd.call(this, a), this._needDraw = !0
    };
    var a = cc.ParticleBatchNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    a.constructor = cc.ParticleBatchNode.WebGLRenderCmd, a.rendering = function() {
        var a = this._node;
        0 != a.textureAtlas.totalQuads && (this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix), cc.glBlendFuncForParticle(a._blendFunc.src, a._blendFunc.dst), a.textureAtlas.drawQuads())
    }, a._initWithTexture = function() {
        this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)
    }, a.visit = function(a) {
        var b = this._node;
        if (b._visible) {
            var c = cc.current_stack;
            c.stack.push(c.top), this._syncStatus(a), c.top = this._stackMatrix, cc.renderer.pushRenderCommand(this), this._dirtyFlag = 0, cc.kmGLPopMatrix()
        }
    }
}(),
function() {
    cc.ParticleSystem.WebGLRenderCmd = function(a) {
        cc.Node.WebGLRenderCmd.call(this, a), this._needDraw = !0, this._buffersVBO = [0, 0], this._quads = [], this._indices = [], this._quadsArrayBuffer = null
    };
    var a = cc.ParticleSystem.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    a.constructor = cc.ParticleSystem.CanvasRenderCmd, a.getDrawMode = function() {}, a.setDrawMode = function() {}, a.getShapeType = function() {}, a.setShapeType = function() {}, a.setBatchNode = function(a) {
        var b = this._node;
        if (b._batchNode != a) {
            var c = b._batchNode;
            if (b._batchNode = a, a)
                for (var d = b._particles, e = 0; e < b._totalParticles; e++) d[e].atlasIndex = e;
            a ? c || (b._batchNode.textureAtlas._copyQuadsToTextureAtlas(this._quads, b.atlasIndex), cc._renderContext.deleteBuffer(this._buffersVBO[1])) : (this._allocMemory(), this.initIndices(b._totalParticles), b.setTexture(c.getTexture()), this._setupVBO())
        }
    }, a.initIndices = function(a) {
        for (var b = this._indices, c = 0, d = a; d > c; ++c) {
            var e = 6 * c,
                f = 4 * c;
            b[e + 0] = f + 0, b[e + 1] = f + 1, b[e + 2] = f + 2, b[e + 5] = f + 1, b[e + 4] = f + 2, b[e + 3] = f + 3
        }
    }, a.isDifferentTexture = function(a, b) {
        return a == b ? !0 : void 0
    }, a.updateParticlePosition = function(a, b) {
        this.updateQuadWithParticle(a, b)
    }, a.updateQuadWithParticle = function(a, b) {
        var c = null,
            d = this._node;
        if (d._batchNode) {
            var e = d._batchNode.textureAtlas.quads;
            c = e[d.atlasIndex + a.atlasIndex], d._batchNode.textureAtlas.dirty = !0
        } else c = this._quads[d._particleIdx];
        var f, g, h, i;
        d._opacityModifyRGB ? (f = 0 | a.color.r * a.color.a / 255, g = 0 | a.color.g * a.color.a / 255, h = 0 | a.color.b * a.color.a / 255) : (f = 0 | a.color.r, g = 0 | a.color.g, h = 0 | a.color.b), i = 0 | a.color.a;
        var j = c.bl.colors,
            k = c.br.colors,
            l = c.tl.colors,
            m = c.tr.colors;
        j.r = k.r = l.r = m.r = f, j.g = k.g = l.g = m.g = g, j.b = k.b = l.b = m.b = h, j.a = k.a = l.a = m.a = i;
        var n = a.size / 2;
        if (a.rotation) {
            var o = -n,
                p = -n,
                q = n,
                r = n,
                s = b.x,
                t = b.y,
                u = -cc.degreesToRadians(a.rotation),
                v = Math.cos(u),
                w = Math.sin(u),
                x = o * v - p * w + s,
                y = o * w + p * v + t,
                z = q * v - p * w + s,
                A = q * w + p * v + t,
                B = q * v - r * w + s,
                C = q * w + r * v + t,
                D = o * v - r * w + s,
                E = o * w + r * v + t;
            c.bl.vertices.x = x, c.bl.vertices.y = y, c.br.vertices.x = z, c.br.vertices.y = A, c.tl.vertices.x = D, c.tl.vertices.y = E, c.tr.vertices.x = B, c.tr.vertices.y = C
        } else c.bl.vertices.x = b.x - n, c.bl.vertices.y = b.y - n, c.br.vertices.x = b.x + n, c.br.vertices.y = b.y - n, c.tl.vertices.x = b.x - n, c.tl.vertices.y = b.y + n, c.tr.vertices.x = b.x + n, c.tr.vertices.y = b.y + n
    }, a.rendering = function(a) {
        var b = this._node;
        if (b._texture) {
            var c = a || cc._renderContext;
            this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix), cc.glBindTexture2D(b._texture), cc.glBlendFuncForParticle(b._blendFunc.src, b._blendFunc.dst), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), c.bindBuffer(c.ARRAY_BUFFER, this._buffersVBO[0]), c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, c.FLOAT, !1, 24, 0), c.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, c.UNSIGNED_BYTE, !0, 24, 12), c.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, c.FLOAT, !1, 24, 16), c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]), c.drawElements(c.TRIANGLES, 6 * b._particleIdx, c.UNSIGNED_SHORT, 0)
        }
    }, a.initTexCoordsWithRect = function(a) {
        var b = this._node,
            c = b.texture,
            d = cc.contentScaleFactor(),
            e = cc.rect(a.x * d, a.y * d, a.width * d, a.height * d),
            f = a.width,
            g = a.height;
        c && (f = c.pixelsWidth, g = c.pixelsHeight);
        var h, i, j, k;
        cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (h = (2 * e.x + 1) / (2 * f), i = (2 * e.y + 1) / (2 * g), j = h + (2 * e.width - 2) / (2 * f), k = i + (2 * e.height - 2) / (2 * g)) : (h = e.x / f, i = e.y / g, j = h + e.width / f, k = i + e.height / g);
        var l = k;
        k = i, i = l;
        var m, n = 0,
            o = 0;
        b._batchNode ? (m = b._batchNode.textureAtlas.quads, n = b.atlasIndex, o = b.atlasIndex + b._totalParticles) : (m = this._quads, n = 0, o = b._totalParticles);
        for (var p = n; o > p; p++) {
            m[p] || (m[p] = cc.V3F_C4B_T2F_QuadZero());
            var q = m[p];
            q.bl.texCoords.u = h, q.bl.texCoords.v = i, q.br.texCoords.u = j, q.br.texCoords.v = i, q.tl.texCoords.u = h, q.tl.texCoords.v = k, q.tr.texCoords.u = j, q.tr.texCoords.v = k
        }
    }, a.setTotalParticles = function(a) {
        var b = this._node;
        if (a > b._allocatedParticles) {
            var c = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
            this._indices = new Uint16Array(6 * a);
            var d = new ArrayBuffer(a * c),
                e = b._particles;
            e.length = 0;
            var f = this._quads;
            f.length = 0;
            for (var g = 0; a > g; g++) e[g] = new cc.Particle, f[g] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, d, g * c);
            if (b._allocatedParticles = a, b._totalParticles = a, b._batchNode)
                for (var h = 0; a > h; h++) e[h].atlasIndex = h;
            this._quadsArrayBuffer = d, this.initIndices(a), this._setupVBO(), b._texture && this.initTexCoordsWithRect(cc.rect(0, 0, b._texture.width, b._texture.height))
        } else b._totalParticles = a;
        b.resetSystem()
    }, a.addParticle = function() {
        var a = this._node,
            b = a._particles;
        return b[a.particleCount]
    }, a._setupVBO = function() {
        var a = cc._renderContext;
        this._buffersVBO[0] = a.createBuffer(), a.bindBuffer(a.ARRAY_BUFFER, this._buffersVBO[0]), a.bufferData(a.ARRAY_BUFFER, this._quadsArrayBuffer, a.DYNAMIC_DRAW), this._buffersVBO[1] = a.createBuffer(), a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]), a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indices, a.STATIC_DRAW)
    }, a._allocMemory = function() {
        var a = this._node;
        if (a._batchNode) return cc.log("cc.ParticleSystem._allocMemory(): Memory should not be allocated when not using batchNode"), !1;
        var b = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
            c = a._totalParticles,
            d = this._quads;
        d.length = 0, this._indices = new Uint16Array(6 * c);
        for (var e = new ArrayBuffer(b * c), f = 0; c > f; f++) d[f] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, e, f * b);
        return d && this._indices ? (this._quadsArrayBuffer = e, !0) : (cc.log("cocos2d: Particle system: not enough memory"), !1)
    }, a.postStep = function() {
        var a = cc._renderContext;
        a.bindBuffer(a.ARRAY_BUFFER, this._buffersVBO[0]), a.bufferData(a.ARRAY_BUFFER, this._quadsArrayBuffer, a.DYNAMIC_DRAW)
    }, a._setBlendAdditive = function() {
        var a = this._node._blendFunc;
        this._texture && !this._texture.hasPremultipliedAlpha() ? (a.src = cc.SRC_ALPHA, a.dst = cc.ONE_MINUS_SRC_ALPHA) : (a.src = cc.BLEND_SRC, a.dst = cc.BLEND_DST)
    }, a._initWithTotalParticles = function(a) {
        return this._allocMemory() ? (this.initIndices(a), this._setupVBO(), void(this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR))) : !1
    }, a._updateDeltaColor = function(a, b) {
        a.color.r += a.deltaColor.r * b, a.color.g += a.deltaColor.g * b, a.color.b += a.deltaColor.b * b, a.color.a += a.deltaColor.a * b, a.isChangeColor = !0
    }
}();
cc.IMEKeyboardNotificationInfo = function(a, b, c) {
    this.begin = a || cc.rect(0, 0, 0, 0), this.end = b || cc.rect(0, 0, 0, 0), this.duration = c || 0
}, cc.IMEDelegate = cc.Class.extend({
    ctor: function() {
        cc.imeDispatcher.addDelegate(this)
    },
    removeDelegate: function() {
        cc.imeDispatcher.removeDelegate(this)
    },
    attachWithIME: function() {
        return cc.imeDispatcher.attachDelegateWithIME(this)
    },
    detachWithIME: function() {
        return cc.imeDispatcher.detachDelegateWithIME(this)
    },
    canAttachWithIME: function() {
        return !1
    },
    didAttachWithIME: function() {},
    canDetachWithIME: function() {
        return !1
    },
    didDetachWithIME: function() {},
    insertText: function() {},
    deleteBackward: function() {},
    getContentText: function() {
        return ""
    },
    keyboardWillShow: function() {},
    keyboardDidShow: function() {},
    keyboardWillHide: function() {},
    keyboardDidHide: function() {}
}), cc.IMEDispatcher = cc.Class.extend({
    _domInputControl: null,
    impl: null,
    _currentInputString: "",
    _lastClickPosition: null,
    ctor: function() {
        this.impl = new cc.IMEDispatcher.Impl, this._lastClickPosition = cc.p(0, 0)
    },
    init: function() {
        if (!cc.sys.isMobile) {
            this._domInputControl = cc.$("#imeDispatcherInput"), this._domInputControl || (this._domInputControl = cc.$new("input"), this._domInputControl.setAttribute("type", "text"), this._domInputControl.setAttribute("id", "imeDispatcherInput"), this._domInputControl.resize(0, 0), this._domInputControl.translates(0, 0), this._domInputControl.style.opacity = "0", this._domInputControl.style.fontSize = "1px", this._domInputControl.setAttribute("tabindex", 2), this._domInputControl.style.position = "absolute", this._domInputControl.style.top = 0, this._domInputControl.style.left = 0, document.body.appendChild(this._domInputControl));
            var a = this;
            cc._addEventListener(this._domInputControl, "input", function() {
                a._processDomInputString(a._domInputControl.value)
            }, !1), cc._addEventListener(this._domInputControl, "keydown", function(b) {
                b.keyCode === cc.KEY.tab ? (b.stopPropagation(), b.preventDefault()) : b.keyCode == cc.KEY.enter && (a.dispatchInsertText("\n", 1), b.stopPropagation(), b.preventDefault())
            }, !1), /msie/i.test(navigator.userAgent) && cc._addEventListener(this._domInputControl, "keyup", function(b) {
                b.keyCode == cc.KEY.backspace && a._processDomInputString(a._domInputControl.value)
            }, !1), cc._addEventListener(window, "mousedown", function(b) {
                var c = b.pageX || 0,
                    d = b.pageY || 0;
                a._lastClickPosition.x = c, a._lastClickPosition.y = d
            }, !1)
        }
    },
    _processDomInputString: function(a) {
        var b, c, d = this._currentInputString.length < a.length ? this._currentInputString.length : a.length;
        for (c = 0; d > c && a[c] === this._currentInputString[c]; c++);
        var e = this._currentInputString.length - c,
            f = a.length - c;
        for (b = 0; e > b; b++) this.dispatchDeleteBackward();
        for (b = 0; f > b; b++) this.dispatchInsertText(a[c + b], 1);
        this._currentInputString = a
    },
    dispatchInsertText: function(a, b) {
        !this.impl || !a || 0 >= b || this.impl._delegateWithIme && this.impl._delegateWithIme.insertText(a, b)
    },
    dispatchDeleteBackward: function() {
        this.impl && this.impl._delegateWithIme && this.impl._delegateWithIme.deleteBackward()
    },
    getContentText: function() {
        if (this.impl && this.impl._delegateWithIme) {
            var a = this.impl._delegateWithIme.getContentText();
            return a ? a : ""
        }
        return ""
    },
    dispatchKeyboardWillShow: function(a) {
        if (this.impl)
            for (var b = 0; b < this.impl._delegateList.length; b++) {
                var c = this.impl._delegateList[b];
                c && c.keyboardWillShow(a)
            }
    },
    dispatchKeyboardDidShow: function(a) {
        if (this.impl)
            for (var b = 0; b < this.impl._delegateList.length; b++) {
                var c = this.impl._delegateList[b];
                c && c.keyboardDidShow(a)
            }
    },
    dispatchKeyboardWillHide: function(a) {
        if (this.impl)
            for (var b = 0; b < this.impl._delegateList.length; b++) {
                var c = this.impl._delegateList[b];
                c && c.keyboardWillHide(a)
            }
    },
    dispatchKeyboardDidHide: function(a) {
        if (this.impl)
            for (var b = 0; b < this.impl._delegateList.length; b++) {
                var c = this.impl._delegateList[b];
                c && c.keyboardDidHide(a)
            }
    },
    addDelegate: function(a) {
        a && this.impl && (this.impl._delegateList.indexOf(a) > -1 || this.impl._delegateList.splice(0, 0, a))
    },
    attachDelegateWithIME: function(a) {
        if (!this.impl || !a) return !1;
        if (-1 == this.impl._delegateList.indexOf(a)) return !1;
        if (this.impl._delegateWithIme) {
            if (!this.impl._delegateWithIme.canDetachWithIME() || !a.canAttachWithIME()) return !1;
            var b = this.impl._delegateWithIme;
            return this.impl._delegateWithIme = null, b.didDetachWithIME(), this._focusDomInput(a), !0
        }
        return a.canAttachWithIME() ? (this._focusDomInput(a), !0) : !1
    },
    _focusDomInput: function(a) {
        if (cc.sys.isMobile) {
            this.impl._delegateWithIme = a, a.didAttachWithIME(), this._currentInputString = a.string || "";
            var b = prompt("please enter your word:", this._currentInputString);
            null != b && this._processDomInputString(b), this.dispatchInsertText("\n", 1)
        } else this.impl._delegateWithIme = a, this._currentInputString = a.string || "", a.didAttachWithIME(), this._domInputControl.focus(), this._domInputControl.value = this._currentInputString, this._domInputControlTranslate()
    },
    _domInputControlTranslate: function() {
        /msie/i.test(navigator.userAgent) ? (this._domInputControl.style.left = this._lastClickPosition.x + "px", this._domInputControl.style.top = this._lastClickPosition.y + "px") : this._domInputControl.translates(this._lastClickPosition.x, this._lastClickPosition.y)
    },
    detachDelegateWithIME: function(a) {
        return this.impl && a ? this.impl._delegateWithIme != a ? !1 : a.canDetachWithIME() ? (this.impl._delegateWithIme = null, a.didDetachWithIME(), cc._canvas.focus(), !0) : !1 : !1
    },
    removeDelegate: function(a) {
        this.impl && a && -1 != this.impl._delegateList.indexOf(a) && (this.impl._delegateWithIme && a == this.impl._delegateWithIme && (this.impl._delegateWithIme = null), cc.arrayRemoveObject(this.impl._delegateList, a))
    },
    processKeycode: function(a) {
        32 > a ? a == cc.KEY.backspace ? this.dispatchDeleteBackward() : a == cc.KEY.enter ? this.dispatchInsertText("\n", 1) : a == cc.KEY.tab || a == cc.KEY.escape : 255 > a && this.dispatchInsertText(String.fromCharCode(a), 1)
    }
}), cc.IMEDispatcher.Impl = cc.Class.extend({
    _delegateWithIme: null,
    _delegateList: null,
    ctor: function() {
        this._delegateList = []
    },
    findDelegate: function(a) {
        for (var b = 0; b < this._delegateList.length; b++)
            if (this._delegateList[b] == a) return b;
        return null
    }
}), cc.imeDispatcher = new cc.IMEDispatcher, document.body ? cc.imeDispatcher.init() : cc._addEventListener(window, "load", function() {
    cc.imeDispatcher.init()
}, !1), cc.TextFieldDelegate = cc.Class.extend({
    onTextFieldAttachWithIME: function() {
        return !1
    },
    onTextFieldDetachWithIME: function() {
        return !1
    },
    onTextFieldInsertText: function() {
        return !1
    },
    onTextFieldDeleteBackward: function() {
        return !1
    },
    onDraw: function() {
        return !1
    }
}), cc.TextFieldTTF = cc.LabelTTF.extend({
    delegate: null,
    colorSpaceHolder: null,
    _colorText: null,
    _lens: null,
    _inputText: "",
    _placeHolder: "",
    _charCount: 0,
    _className: "TextFieldTTF",
    ctor: function(a, b, c, d, e) {
        this.colorSpaceHolder = cc.color(127, 127, 127), this._colorText = cc.color(255, 255, 255, 255), cc.imeDispatcher.addDelegate(this), cc.LabelTTF.prototype.ctor.call(this), void 0 !== e ? (this.initWithPlaceHolder("", b, c, d, e), a && this.setPlaceHolder(a)) : void 0 === d && void 0 !== c && (this.initWithString("", arguments[1], arguments[2]), a && this.setPlaceHolder(a))
    },
    getDelegate: function() {
        return this.delegate
    },
    setDelegate: function(a) {
        this.delegate = a
    },
    getCharCount: function() {
        return this._charCount
    },
    getColorSpaceHolder: function() {
        return cc.color(this.colorSpaceHolder)
    },
    setColorSpaceHolder: function(a) {
        this.colorSpaceHolder.r = a.r, this.colorSpaceHolder.g = a.g, this.colorSpaceHolder.b = a.b, this.colorSpaceHolder.a = cc.isUndefined(a.a) ? 255 : a.a
    },
    setTextColor: function(a) {
        this._colorText.r = a.r, this._colorText.g = a.g, this._colorText.b = a.b, this._colorText.a = cc.isUndefined(a.a) ? 255 : a.a
    },
    initWithPlaceHolder: function(a, b, c, d, e) {
        switch (arguments.length) {
            case 5:
                return a && this.setPlaceHolder(a), this.initWithString(this._placeHolder, d, e, b, c);
            case 3:
                return a && this.setPlaceHolder(a), this.initWithString(this._placeHolder, arguments[1], arguments[2]);
            default:
                throw "Argument must be non-nil "
        }
    },
    setString: function(a) {
        a = String(a), this._inputText = a || "", this._inputText.length ? (cc.LabelTTF.prototype.setString.call(this, this._inputText), this.setColor(this._colorText)) : (cc.LabelTTF.prototype.setString.call(this, this._placeHolder), this.setColor(this.colorSpaceHolder)), cc._renderType === cc._RENDER_TYPE_CANVAS && this._renderCmd._updateTexture(), this._charCount = this._inputText.length
    },
    getString: function() {
        return this._inputText
    },
    setPlaceHolder: function(a) {
        this._placeHolder = a || "", this._inputText.length || (cc.LabelTTF.prototype.setString.call(this, this._placeHolder), this.setColor(this.colorSpaceHolder))
    },
    getPlaceHolder: function() {
        return this._placeHolder
    },
    draw: function(a) {
        var b = a || cc._renderContext;
        this.delegate && this.delegate.onDraw(this) || cc.LabelTTF.prototype.draw.call(this, b)
    },
    visit: function(a) {
        this._super(a)
    },
    attachWithIME: function() {
        return cc.imeDispatcher.attachDelegateWithIME(this)
    },
    detachWithIME: function() {
        return cc.imeDispatcher.detachDelegateWithIME(this)
    },
    canAttachWithIME: function() {
        return this.delegate ? !this.delegate.onTextFieldAttachWithIME(this) : !0
    },
    didAttachWithIME: function() {},
    canDetachWithIME: function() {
        return this.delegate ? !this.delegate.onTextFieldDetachWithIME(this) : !0
    },
    didDetachWithIME: function() {},
    deleteBackward: function() {
        var a = this._inputText.length;
        if (0 != a) {
            var b = 1;
            if (!this.delegate || !this.delegate.onTextFieldDeleteBackward(this, this._inputText[a - b], b)) return b >= a ? (this._inputText = "", this._charCount = 0, cc.LabelTTF.prototype.setString.call(this, this._placeHolder), void this.setColor(this.colorSpaceHolder)) : void(this.string = this._inputText.substring(0, a - b))
        }
    },
    removeDelegate: function() {
        cc.imeDispatcher.removeDelegate(this)
    },
    insertText: function(a) {
        var b = a,
            c = b.indexOf("\n");
        if (c > -1 && (b = b.substring(0, c)), b.length > 0) {
            if (this.delegate && this.delegate.onTextFieldInsertText(this, b, b.length)) return;
            var d = this._inputText + b;
            this._charCount = d.length, this.string = d
        } - 1 != c && (this.delegate && this.delegate.onTextFieldInsertText(this, "\n", 1) || this.detachWithIME())
    },
    getContentText: function() {
        return this._inputText
    },
    keyboardWillShow: function() {},
    keyboardDidShow: function() {},
    keyboardWillHide: function() {},
    keyboardDidHide: function() {}
});
var _p = cc.TextFieldTTF.prototype;
_p.charCount, cc.defineGetterSetter(_p, "charCount", _p.getCharCount), _p.placeHolder, cc.defineGetterSetter(_p, "placeHolder", _p.getPlaceHolder, _p.setPlaceHolder), cc.TextFieldTTF.create = function(a, b, c, d, e) {
    return new cc.TextFieldTTF(a, b, c, d, e)
};
cc.TGA_OK = 0, cc.TGA_ERROR_FILE_OPEN = 1, cc.TGA_ERROR_READING_FILE = 2, cc.TGA_ERROR_INDEXED_COLOR = 3, cc.TGA_ERROR_MEMORY = 4, cc.TGA_ERROR_COMPRESSED_FILE = 5, cc.ImageTGA = function(a, b, c, d, e, f, g) {
    this.status = a || 0, this.type = b || 0, this.pixelDepth = c || 0, this.width = d || 0, this.height = e || 0, this.imageData = f || [], this.flipped = g || 0
}, cc.tgaLoadHeader = function(a, b, c) {
    var d = 2;
    if (d + 1 > b) return !1;
    var e = new cc.BinaryStreamReader(a);
    if (e.setOffset(d), c.type = e.readByte(), d += 10, d + 4 + 1 > b) return !1;
    if (e.setOffset(d), c.width = e.readUnsignedShort(), c.height = e.readUnsignedInteger(), c.pixelDepth = e.readByte(), d += 5, d + 1 > b) return !1;
    var f = e.readByte();
    return c.flipped = 0, 32 & f && (c.flipped = 1), !0
}, cc.tgaLoadImageData = function(a, b, c) {
    var d, e, f, g, h = 18;
    if (d = 0 | c.pixelDepth / 2, e = c.height * c.width * d, h + e > b) return !1;
    if (c.imageData = cc.__getSubArray(a, h, h + e), d >= 3)
        for (f = 0; e > f; f += d) g = c.imageData[f], c.imageData[f] = c.imageData[f + 2], c.imageData[f + 2] = g;
    return !0
}, cc.tgaRGBtogreyscale = function(a) {
    var b, c;
    if (8 !== a.pixelDepth) {
        var d = a.pixelDepth / 8,
            e = new Uint8Array(a.height * a.width);
        if (null !== e) {
            for (b = 0, c = 0; c < a.width * a.height; b += d, c++) e[c] = .3 * a.imageData[b] + .59 * a.imageData[b + 1] + .11 * a.imageData[b + 2];
            a.pixelDepth = 8, a.type = 3, a.imageData = e
        }
    }
}, cc.tgaDestroy = function(a) {
    a && (a.imageData = null, a = null)
}, cc.tgaLoadRLEImageData = function(a, b, c) {
    var d, e, f, g = 0,
        h = 0,
        i = 0,
        j = [],
        k = 0,
        l = 18;
    for (d = c.pixelDepth / 8, e = c.height * c.width, f = 0; e > f; f++) {
        if (0 != k) k--, h = 0 != i;
        else {
            if (l + 1 > b) break;
            k = a[l], l += 1, i = 128 & k, i && (k -= 128), h = 0
        } if (!h) {
            if (l + d > b) break;
            if (j = cc.__getSubArray(a, l, l + d), l += d, d >= 3) {
                var m = j[0];
                j[0] = j[2], j[2] = m
            }
        }
        for (var n = 0; d > n; n++) c.imageData[g + n] = j[n];
        g += d
    }
    return !0
}, cc.tgaFlipImage = function(a) {
    for (var b = a.pixelDepth / 8, c = a.width * b, d = 0; d < a.height / 2; d++) {
        var e = cc.__getSubArray(a.imageData, d * c, d * c + c);
        cc.__setDataToArray(cc.__getSubArray(a.imageData, (a.height - (d + 1)) * c, c), a.imageData, d * c), cc.__setDataToArray(e, a.imageData, (a.height - (d + 1)) * c)
    }
    a.flipped = 0
}, cc.__getSubArray = function(a, b, c) {
    return a instanceof Array ? a.slice(b, c) : a.subarray(b, c)
}, cc.__setDataToArray = function(a, b, c) {
    for (var d = 0; d < a.length; d++) b[c + d] = a[d]
}, cc.BinaryStreamReader = cc.Class.extend({
    _binaryData: null,
    _offset: 0,
    ctor: function(a) {
        this._binaryData = a
    },
    setBinaryData: function(a) {
        this._binaryData = a, this._offset = 0
    },
    getBinaryData: function() {
        return this._binaryData
    },
    _checkSize: function(a) {
        if (!(this._offset + Math.ceil(a / 8) < this._data.length)) throw new Error("Index out of bound")
    },
    _decodeFloat: function(a, b) {
        var c = a + b + 1,
            d = c >> 3;
        this._checkSize(c);
        var e = Math.pow(2, b - 1) - 1,
            f = this._readBits(a + b, 1, d),
            g = this._readBits(a, b, d),
            h = 0,
            i = 2,
            j = 0;
        do
            for (var k = this._readByte(++j, d), l = a % 8 || 8, m = 1 << l; m >>= 1;) k & m && (h += 1 / i), i *= 2; while (a -= l);
        return this._offset += d, g == (e << 1) + 1 ? h ? 0 / 0 : f ? -1 / 0 : +1 / 0 : (1 + -2 * f) * (g || h ? g ? Math.pow(2, g - e) * (1 + h) : Math.pow(2, -e + 1) * h : 0)
    },
    _readByte: function(a, b) {
        return this._data[this._offset + b - a - 1]
    },
    _decodeInt: function(a, b) {
        var c = this._readBits(0, a, a / 8),
            d = Math.pow(2, a),
            e = b && c >= d / 2 ? c - d : c;
        return this._offset += a / 8, e
    },
    _shl: function(a, b) {
        for (++b; --b; a = 1073741824 == (1073741824 & (a %= 2147483648)) ? 2 * a : 2 * (a - 1073741824) + 2147483647 + 1);
        return a
    },
    _readBits: function(a, b, c) {
        var d = (a + b) % 8,
            e = a % 8,
            f = c - (a >> 3) - 1,
            g = c + (-(a + b) >> 3),
            h = f - g,
            i = this._readByte(f, c) >> e & (1 << (h ? 8 - e : b)) - 1;
        for (h && d && (i += (this._readByte(g++, c) & (1 << d) - 1) << (h-- << 3) - e); h;) i += this._shl(this._readByte(g++, c), (h-- << 3) - e);
        return i
    },
    readInteger: function() {
        return this._decodeInt(32, !0)
    },
    readUnsignedInteger: function() {
        return this._decodeInt(32, !1)
    },
    readSingle: function() {
        return this._decodeFloat(23, 8)
    },
    readShort: function() {
        return this._decodeInt(16, !0)
    },
    readUnsignedShort: function() {
        return this._decodeInt(16, !1)
    },
    readByte: function() {
        var a = this._data[this._offset];
        return this._offset += 1, a
    },
    readData: function(a, b) {
        return this._binaryData instanceof Array ? this._binaryData.slice(a, b) : this._binaryData.subarray(a, b)
    },
    setOffset: function(a) {
        this._offset = a
    },
    getOffset: function() {
        return this._offset
    }
}), cc.TMX_ORIENTATION_ORTHO = 0, cc.TMX_ORIENTATION_HEX = 1, cc.TMX_ORIENTATION_ISO = 2, cc.TMXTiledMap = cc.Node.extend({
    properties: null,
    mapOrientation: null,
    objectGroups: null,
    _mapSize: null,
    _tileSize: null,
    _tileProperties: null,
    _className: "TMXTiledMap",
    ctor: function(a, b) {
        cc.Node.prototype.ctor.call(this), this._mapSize = cc.size(0, 0), this._tileSize = cc.size(0, 0), void 0 !== b ? this.initWithXML(a, b) : void 0 !== a && this.initWithTMXFile(a)
    },
    getMapSize: function() {
        return cc.size(this._mapSize.width, this._mapSize.height)
    },
    setMapSize: function(a) {
        this._mapSize.width = a.width, this._mapSize.height = a.height
    },
    _getMapWidth: function() {
        return this._mapSize.width
    },
    _setMapWidth: function(a) {
        this._mapSize.width = a
    },
    _getMapHeight: function() {
        return this._mapSize.height
    },
    _setMapHeight: function(a) {
        this._mapSize.height = a
    },
    getTileSize: function() {
        return cc.size(this._tileSize.width, this._tileSize.height)
    },
    setTileSize: function(a) {
        this._tileSize.width = a.width, this._tileSize.height = a.height
    },
    _getTileWidth: function() {
        return this._tileSize.width
    },
    _setTileWidth: function(a) {
        this._tileSize.width = a
    },
    _getTileHeight: function() {
        return this._tileSize.height
    },
    _setTileHeight: function(a) {
        this._tileSize.height = a
    },
    getMapOrientation: function() {
        return this.mapOrientation
    },
    setMapOrientation: function(a) {
        this.mapOrientation = a
    },
    getObjectGroups: function() {
        return this.objectGroups
    },
    setObjectGroups: function(a) {
        this.objectGroups = a
    },
    getProperties: function() {
        return this.properties
    },
    setProperties: function(a) {
        this.properties = a
    },
    initWithTMXFile: function(a) {
        if (!a || 0 == a.length) throw "cc.TMXTiledMap.initWithTMXFile(): tmxFile should be non-null or non-empty string.";
        this.width = 0, this.height = 0;
        var b = new cc.TMXMapInfo(a);
        if (!b) return !1;
        var c = b.getTilesets();
        return c && 0 !== c.length || cc.log("cc.TMXTiledMap.initWithTMXFile(): Map not found. Please check the filename."), this._buildWithMapInfo(b), !0
    },
    initWithXML: function(a, b) {
        this.width = 0, this.height = 0;
        var c = new cc.TMXMapInfo(a, b),
            d = c.getTilesets();
        return d && 0 !== d.length || cc.log("cc.TMXTiledMap.initWithXML(): Map not found. Please check the filename."), this._buildWithMapInfo(c), !0
    },
    _buildWithMapInfo: function(a) {
        this._mapSize = a.getMapSize(), this._tileSize = a.getTileSize(), this.mapOrientation = a.orientation, this.objectGroups = a.getObjectGroups(), this.properties = a.properties, this._tileProperties = a.getTileProperties();
        var b = 0,
            c = a.getLayers();
        if (c)
            for (var d = null, e = 0, f = c.length; f > e; e++)
                if (d = c[e], d && d.visible) {
                    var g = this._parseLayer(d, a);
                    this.addChild(g, b, b), this.width = Math.max(this.width, g.width), this.height = Math.max(this.height, g.height), b++
                }
    },
    allLayers: function() {
        for (var a = [], b = this._children, c = 0, d = b.length; d > c; c++) {
            var e = b[c];
            e && e instanceof cc.TMXLayer && a.push(e)
        }
        return a
    },
    getLayer: function(a) {
        if (!a || 0 === a.length) throw "cc.TMXTiledMap.getLayer(): layerName should be non-null or non-empty string.";
        for (var b = this._children, c = 0; c < b.length; c++) {
            var d = b[c];
            if (d && d.layerName == a) return d
        }
        return null
    },
    getObjectGroup: function(a) {
        if (!a || 0 === a.length) throw "cc.TMXTiledMap.getObjectGroup(): groupName should be non-null or non-empty string.";
        if (this.objectGroups)
            for (var b = 0; b < this.objectGroups.length; b++) {
                var c = this.objectGroups[b];
                if (c && c.groupName == a) return c
            }
        return null
    },
    getProperty: function(a) {
        return this.properties[a.toString()]
    },
    propertiesForGID: function(a) {
        return cc.log("propertiesForGID is deprecated. Please use getPropertiesForGID instead."), this.getPropertiesForGID[a]
    },
    getPropertiesForGID: function(a) {
        return this._tileProperties[a]
    },
    _parseLayer: function(a, b) {
        var c = this._tilesetForLayer(a, b),
            d = new cc.TMXLayer(c, a, b);
        return a.ownTiles = !1, d.setupTiles(), d
    },
    _tilesetForLayer: function(a, b) {
        var c = a._layerSize,
            d = b.getTilesets();
        if (d)
            for (var e = d.length - 1; e >= 0; e--) {
                var f = d[e];
                if (f)
                    for (var g = 0; g < c.height; g++)
                        for (var h = 0; h < c.width; h++) {
                            var i = h + c.width * g,
                                j = a._tiles[i];
                            if (0 != j && (j & cc.TMX_TILE_FLIPPED_MASK) >>> 0 >= f.firstGid) return f
                        }
            }
        return cc.log("cocos2d: Warning: TMX Layer " + a.name + " has no tiles"), null
    }
});
var _p = cc.TMXTiledMap.prototype;
_p.mapWidth, cc.defineGetterSetter(_p, "mapWidth", _p._getMapWidth, _p._setMapWidth), _p.mapHeight, cc.defineGetterSetter(_p, "mapHeight", _p._getMapHeight, _p._setMapHeight), _p.tileWidth, cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth), _p.tileHeight, cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight), cc.TMXTiledMap.create = function(a, b) {
    return new cc.TMXTiledMap(a, b)
}, cc.TMX_PROPERTY_NONE = 0, cc.TMX_PROPERTY_MAP = 1, cc.TMX_PROPERTY_LAYER = 2, cc.TMX_PROPERTY_OBJECTGROUP = 3, cc.TMX_PROPERTY_OBJECT = 4, cc.TMX_PROPERTY_TILE = 5, cc.TMX_TILE_HORIZONTAL_FLAG = 2147483648, cc.TMX_TILE_VERTICAL_FLAG = 1073741824, cc.TMX_TILE_DIAGONAL_FLAG = 536870912, cc.TMX_TILE_FLIPPED_ALL = (cc.TMX_TILE_HORIZONTAL_FLAG | cc.TMX_TILE_VERTICAL_FLAG | cc.TMX_TILE_DIAGONAL_FLAG) >>> 0, cc.TMX_TILE_FLIPPED_MASK = ~cc.TMX_TILE_FLIPPED_ALL >>> 0, cc.TMXLayerInfo = cc.Class.extend({
    properties: null,
    name: "",
    _layerSize: null,
    _tiles: null,
    visible: null,
    _opacity: null,
    ownTiles: !0,
    _minGID: 1e5,
    _maxGID: 0,
    offset: null,
    ctor: function() {
        this.properties = [], this.name = "", this._layerSize = null, this._tiles = [], this.visible = !0, this._opacity = 0, this.ownTiles = !0, this._minGID = 1e5, this._maxGID = 0, this.offset = cc.p(0, 0)
    },
    getProperties: function() {
        return this.properties
    },
    setProperties: function(a) {
        this.properties = a
    }
}), cc.TMXTilesetInfo = cc.Class.extend({
    name: "",
    firstGid: 0,
    _tileSize: null,
    spacing: 0,
    margin: 0,
    sourceImage: "",
    imageSize: null,
    ctor: function() {
        this._tileSize = cc.size(0, 0), this.imageSize = cc.size(0, 0)
    },
    rectForGID: function(a) {
        var b = cc.rect(0, 0, 0, 0);
        b.width = this._tileSize.width, b.height = this._tileSize.height, a &= cc.TMX_TILE_FLIPPED_MASK, a -= parseInt(this.firstGid, 10);
        var c = parseInt((this.imageSize.width - 2 * this.margin + this.spacing) / (this._tileSize.width + this.spacing), 10);
        return b.x = parseInt(a % c * (this._tileSize.width + this.spacing) + this.margin, 10), b.y = parseInt(parseInt(a / c, 10) * (this._tileSize.height + this.spacing) + this.margin, 10), b
    }
}), cc.TMXMapInfo = cc.SAXParser.extend({
    properties: null,
    orientation: null,
    parentElement: null,
    parentGID: null,
    layerAttrs: 0,
    storingCharacters: !1,
    tmxFileName: null,
    currentString: null,
    _objectGroups: null,
    _mapSize: null,
    _tileSize: null,
    _layers: null,
    _tilesets: null,
    _tileProperties: null,
    _resources: "",
    _currentFirstGID: 0,
    ctor: function(a, b) {
        cc.SAXParser.prototype.ctor.apply(this), this._mapSize = cc.size(0, 0), this._tileSize = cc.size(0, 0), this._layers = [], this._tilesets = [], this._objectGroups = [], this.properties = [], this._tileProperties = {}, this._currentFirstGID = 0, void 0 !== b ? this.initWithXML(a, b) : void 0 !== a && this.initWithTMXFile(a)
    },
    getOrientation: function() {
        return this.orientation
    },
    setOrientation: function(a) {
        this.orientation = a
    },
    getMapSize: function() {
        return cc.size(this._mapSize.width, this._mapSize.height)
    },
    setMapSize: function(a) {
        this._mapSize.width = a.width, this._mapSize.height = a.height
    },
    _getMapWidth: function() {
        return this._mapSize.width
    },
    _setMapWidth: function(a) {
        this._mapSize.width = a
    },
    _getMapHeight: function() {
        return this._mapSize.height
    },
    _setMapHeight: function(a) {
        this._mapSize.height = a
    },
    getTileSize: function() {
        return cc.size(this._tileSize.width, this._tileSize.height)
    },
    setTileSize: function(a) {
        this._tileSize.width = a.width, this._tileSize.height = a.height
    },
    _getTileWidth: function() {
        return this._tileSize.width
    },
    _setTileWidth: function(a) {
        this._tileSize.width = a
    },
    _getTileHeight: function() {
        return this._tileSize.height
    },
    _setTileHeight: function(a) {
        this._tileSize.height = a
    },
    getLayers: function() {
        return this._layers
    },
    setLayers: function(a) {
        this._layers.push(a)
    },
    getTilesets: function() {
        return this._tilesets
    },
    setTilesets: function(a) {
        this._tilesets.push(a)
    },
    getObjectGroups: function() {
        return this._objectGroups
    },
    setObjectGroups: function(a) {
        this._objectGroups.push(a)
    },
    getParentElement: function() {
        return this.parentElement
    },
    setParentElement: function(a) {
        this.parentElement = a
    },
    getParentGID: function() {
        return this.parentGID
    },
    setParentGID: function(a) {
        this.parentGID = a
    },
    getLayerAttribs: function() {
        return this.layerAttrs
    },
    setLayerAttribs: function(a) {
        this.layerAttrs = a
    },
    getStoringCharacters: function() {
        return this.storingCharacters
    },
    setStoringCharacters: function(a) {
        this.storingCharacters = a
    },
    getProperties: function() {
        return this.properties
    },
    setProperties: function(a) {
        this.properties = a
    },
    initWithTMXFile: function(a) {
        return this._internalInit(a, null), this.parseXMLFile(a)
    },
    initWithXML: function(a, b) {
        return this._internalInit(null, b), this.parseXMLString(a)
    },
    parseXMLFile: function(a, b) {
        b = b || !1;
        var c = b ? a : cc.loader.getRes(a);
        if (!c) throw "Please load the resource first : " + a;
        var d, e, f = this._parseXML(c),
            g = f.documentElement,
            h = g.getAttribute("version"),
            i = g.getAttribute("orientation");
        if ("map" == g.nodeName) {
            "1.0" != h && null !== h && cc.log("cocos2d: TMXFormat: Unsupported TMX version:" + h), "orthogonal" == i ? this.orientation = cc.TMX_ORIENTATION_ORTHO : "isometric" == i ? this.orientation = cc.TMX_ORIENTATION_ISO : "hexagonal" == i ? this.orientation = cc.TMX_ORIENTATION_HEX : null !== i && cc.log("cocos2d: TMXFomat: Unsupported orientation:" + i);
            var j = cc.size(0, 0);
            j.width = parseFloat(g.getAttribute("width")), j.height = parseFloat(g.getAttribute("height")), this.setMapSize(j), j = cc.size(0, 0), j.width = parseFloat(g.getAttribute("tilewidth")), j.height = parseFloat(g.getAttribute("tileheight")), this.setTileSize(j);
            var k = g.querySelectorAll("map > properties >  property");
            if (k) {
                var l = {};
                for (d = 0; d < k.length; d++) l[k[d].getAttribute("name")] = k[d].getAttribute("value");
                this.properties = l
            }
        }
        var m = g.getElementsByTagName("tileset");
        for ("map" !== g.nodeName && (m = [], m.push(g)), d = 0; d < m.length; d++) {
            var n = m[d],
                o = n.getAttribute("source");
            if (o) {
                var p = b ? cc.path.join(this._resources, o) : cc.path.changeBasename(a, o);
                this.parseXMLFile(p)
            } else {
                var q = new cc.TMXTilesetInfo;
                q.name = n.getAttribute("name") || "", q.firstGid = parseInt(n.getAttribute("firstgid")) || 0, q.spacing = parseInt(n.getAttribute("spacing")) || 0, q.margin = parseInt(n.getAttribute("margin")) || 0;
                var r = cc.size(0, 0);
                r.width = parseFloat(n.getAttribute("tilewidth")), r.height = parseFloat(n.getAttribute("tileheight")), q._tileSize = r;
                var s = n.getElementsByTagName("image")[0],
                    t = s.getAttribute("source"),
                    u = -1;
                if (this.tmxFileName && (u = this.tmxFileName.lastIndexOf("/")), -1 !== u) {
                    var v = this.tmxFileName.substr(0, u + 1);
                    q.sourceImage = v + t
                } else q.sourceImage = this._resources + (this._resources ? "/" : "") + t;
                this.setTilesets(q);
                var w = n.getElementsByTagName("tile");
                if (w)
                    for (var x = 0; x < w.length; x++) {
                        var y = w[x];
                        this.parentGID = parseInt(q.firstGid) + parseInt(y.getAttribute("id") || 0);
                        var z = y.querySelectorAll("properties > property");
                        if (z) {
                            var A = {};
                            for (e = 0; e < z.length; e++) {
                                var B = z[e].getAttribute("name");
                                A[B] = z[e].getAttribute("value")
                            }
                            this._tileProperties[this.parentGID] = A
                        }
                    }
            }
        }
        var C = g.getElementsByTagName("layer");
        if (C)
            for (d = 0; d < C.length; d++) {
                var D = C[d],
                    E = D.getElementsByTagName("data")[0],
                    F = new cc.TMXLayerInfo;
                F.name = D.getAttribute("name");
                var G = cc.size(0, 0);
                G.width = parseFloat(D.getAttribute("width")), G.height = parseFloat(D.getAttribute("height")), F._layerSize = G;
                var H = D.getAttribute("visible");
                F.visible = !("0" == H);
                var I = D.getAttribute("opacity") || 1;
                F._opacity = I ? parseInt(255 * parseFloat(I)) : 255, F.offset = cc.p(parseFloat(D.getAttribute("x")) || 0, parseFloat(D.getAttribute("y")) || 0);
                var J = "";
                for (e = 0; e < E.childNodes.length; e++) J += E.childNodes[e].nodeValue;
                J = J.trim();
                var K = E.getAttribute("compression"),
                    L = E.getAttribute("encoding");
                if (K && "gzip" !== K && "zlib" !== K) return cc.log("cc.TMXMapInfo.parseXMLFile(): unsupported compression method"), null;
                switch (K) {
                    case "gzip":
                        F._tiles = cc.unzipBase64AsArray(J, 4);
                        break;
                    case "zlib":
                        var M = new Zlib.Inflate(cc.Codec.Base64.decodeAsArray(J, 1));
                        F._tiles = cc.uint8ArrayToUint32Array(M.decompress());
                        break;
                    case null:
                    case "":
                        if ("base64" == L) F._tiles = cc.Codec.Base64.decodeAsArray(J, 4);
                        else if ("csv" === L) {
                            F._tiles = [];
                            for (var N = J.split(","), O = 0; O < N.length; O++) F._tiles.push(parseInt(N[O]))
                        } else {
                            var P = E.getElementsByTagName("tile");
                            F._tiles = [];
                            for (var Q = 0; Q < P.length; Q++) F._tiles.push(parseInt(P[Q].getAttribute("gid")))
                        }
                        break;
                    default:
                        this.layerAttrs == cc.TMXLayerInfo.ATTRIB_NONE && cc.log("cc.TMXMapInfo.parseXMLFile(): Only base64 and/or gzip/zlib maps are supported")
                }
                var R = D.querySelectorAll("properties > property");
                if (R) {
                    var S = {};
                    for (e = 0; e < R.length; e++) S[R[e].getAttribute("name")] = R[e].getAttribute("value");
                    F.properties = S
                }
                this.setLayers(F)
            }
        var T = g.getElementsByTagName("objectgroup");
        if (T)
            for (d = 0; d < T.length; d++) {
                var U = T[d],
                    V = new cc.TMXObjectGroup;
                V.groupName = U.getAttribute("name"), V.setPositionOffset(cc.p(parseFloat(U.getAttribute("x")) * this.getTileSize().width || 0, parseFloat(U.getAttribute("y")) * this.getTileSize().height || 0));
                var W = U.querySelectorAll("objectgroup > properties > property");
                if (W)
                    for (e = 0; e < W.length; e++) {
                        var X = {};
                        X[W[e].getAttribute("name")] = W[e].getAttribute("value"), V.properties = X
                    }
                var Y = U.querySelectorAll("object");
                if (Y)
                    for (e = 0; e < Y.length; e++) {
                        var Z = Y[e],
                            $ = {};
                        $.name = Z.getAttribute("name") || "", $.type = Z.getAttribute("type") || "", $.x = parseInt(Z.getAttribute("x") || 0) + V.getPositionOffset().x;
                        var _ = parseInt(Z.getAttribute("y") || 0) + V.getPositionOffset().y;
                        $.width = parseInt(Z.getAttribute("width")) || 0, $.height = parseInt(Z.getAttribute("height")) || 0, $.y = parseInt(this.getMapSize().height * this.getTileSize().height) - _ - $.height, $.rotation = parseInt(Z.getAttribute("rotation")) || 0;
                        var ab = Z.querySelectorAll("properties > property");
                        if (ab)
                            for (var bb = 0; bb < ab.length; bb++) $[ab[bb].getAttribute("name")] = ab[bb].getAttribute("value");
                        var cb = Z.querySelectorAll("polygon");
                        if (cb && cb.length > 0) {
                            var db = cb[0].getAttribute("points");
                            db && ($.polygonPoints = this._parsePointsString(db))
                        }
                        var eb = Z.querySelectorAll("polyline");
                        if (eb && eb.length > 0) {
                            var fb = eb[0].getAttribute("points");
                            fb && ($.polylinePoints = this._parsePointsString(fb))
                        }
                        V.setObjects($)
                    }
                this.setObjectGroups(V)
            }
        return g
    },
    _parsePointsString: function(a) {
        if (!a) return null;
        for (var b = [], c = a.split(" "), d = 0; d < c.length; d++) {
            var e = c[d].split(",");
            b.push({
                x: e[0],
                y: e[1]
            })
        }
        return b
    },
    parseXMLString: function(a) {
        return this.parseXMLFile(a, !0)
    },
    getTileProperties: function() {
        return this._tileProperties
    },
    setTileProperties: function(a) {
        this._tileProperties.push(a)
    },
    getCurrentString: function() {
        return this.currentString
    },
    setCurrentString: function(a) {
        this.currentString = a
    },
    getTMXFileName: function() {
        return this.tmxFileName
    },
    setTMXFileName: function(a) {
        this.tmxFileName = a
    },
    _internalInit: function(a, b) {
        this._tilesets.length = 0, this._layers.length = 0, this.tmxFileName = a, b && (this._resources = b), this._objectGroups.length = 0, this.properties.length = 0, this._tileProperties.length = 0, this.currentString = "", this.storingCharacters = !1, this.layerAttrs = cc.TMXLayerInfo.ATTRIB_NONE, this.parentElement = cc.TMX_PROPERTY_NONE, this._currentFirstGID = 0
    }
});
var _p = cc.TMXMapInfo.prototype;
_p.mapWidth, cc.defineGetterSetter(_p, "mapWidth", _p._getMapWidth, _p._setMapWidth), _p.mapHeight, cc.defineGetterSetter(_p, "mapHeight", _p._getMapHeight, _p._setMapHeight), _p.tileWidth, cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth), _p.tileHeight, cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight), cc.TMXMapInfo.create = function(a, b) {
    return new cc.TMXMapInfo(a, b)
}, cc.loader.register(["tmx", "tsx"], cc._txtLoader), cc.TMXLayerInfo.ATTRIB_NONE = 1, cc.TMXLayerInfo.ATTRIB_BASE64 = 2, cc.TMXLayerInfo.ATTRIB_GZIP = 4, cc.TMXLayerInfo.ATTRIB_ZLIB = 8, cc.TMXObjectGroup = cc.Class.extend({
    properties: null,
    groupName: "",
    _positionOffset: null,
    _objects: null,
    ctor: function() {
        this.groupName = "", this._positionOffset = cc.p(0, 0), this.properties = [], this._objects = []
    },
    getPositionOffset: function() {
        return cc.p(this._positionOffset)
    },
    setPositionOffset: function(a) {
        this._positionOffset.x = a.x, this._positionOffset.y = a.y
    },
    getProperties: function() {
        return this.properties
    },
    setProperties: function(a) {
        this.properties.push(a)
    },
    getGroupName: function() {
        return this.groupName.toString()
    },
    setGroupName: function(a) {
        this.groupName = a
    },
    propertyNamed: function(a) {
        return this.properties[a]
    },
    objectNamed: function(a) {
        if (this._objects && this._objects.length > 0)
            for (var b = this._objects, c = 0, d = b.length; d > c; c++) {
                var e = b[c].name;
                if (e && e == a) return b[c]
            }
        return null
    },
    getObjects: function() {
        return this._objects
    },
    setObjects: function(a) {
        this._objects.push(a)
    }
}), cc.TMXLayer = cc.SpriteBatchNode.extend({
    tiles: null,
    tileset: null,
    layerOrientation: null,
    properties: null,
    layerName: "",
    _layerSize: null,
    _mapTileSize: null,
    _opacity: 255,
    _minGID: null,
    _maxGID: null,
    _vertexZvalue: null,
    _useAutomaticVertexZ: null,
    _reusedTile: null,
    _atlasIndexArray: null,
    _contentScaleFactor: null,
    _className: "TMXLayer",
    ctor: function(a, b, c) {
        cc.SpriteBatchNode.prototype.ctor.call(this), this._descendants = [], this._layerSize = cc.size(0, 0), this._mapTileSize = cc.size(0, 0), void 0 !== c && this.initWithTilesetInfo(a, b, c)
    },
    _createRenderCmd: function() {
        return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.TMXLayer.CanvasRenderCmd(this) : new cc.TMXLayer.WebGLRenderCmd(this)
    },
    setContentSize: function(a, b) {
        cc.Node.prototype.setContentSize.call(this, a, b), this._renderCmd._updateCacheContext(a, b)
    },
    getTexture: function() {
        return this._renderCmd.getTexture()
    },
    getLayerSize: function() {
        return cc.size(this._layerSize.width, this._layerSize.height)
    },
    setLayerSize: function(a) {
        this._layerSize.width = a.width, this._layerSize.height = a.height
    },
    _getLayerWidth: function() {
        return this._layerSize.width
    },
    _setLayerWidth: function(a) {
        this._layerSize.width = a
    },
    _getLayerHeight: function() {
        return this._layerSize.height
    },
    _setLayerHeight: function(a) {
        this._layerSize.height = a
    },
    getMapTileSize: function() {
        return cc.size(this._mapTileSize.width, this._mapTileSize.height)
    },
    setMapTileSize: function(a) {
        this._mapTileSize.width = a.width, this._mapTileSize.height = a.height
    },
    _getTileWidth: function() {
        return this._mapTileSize.width
    },
    _setTileWidth: function(a) {
        this._mapTileSize.width = a
    },
    _getTileHeight: function() {
        return this._mapTileSize.height
    },
    _setTileHeight: function(a) {
        this._mapTileSize.height = a
    },
    getTiles: function() {
        return this.tiles
    },
    setTiles: function(a) {
        this.tiles = a
    },
    getTileset: function() {
        return this.tileset
    },
    setTileset: function(a) {
        this.tileset = a
    },
    getLayerOrientation: function() {
        return this.layerOrientation
    },
    setLayerOrientation: function(a) {
        this.layerOrientation = a
    },
    getProperties: function() {
        return this.properties
    },
    setProperties: function(a) {
        this.properties = a
    },
    initWithTilesetInfo: function(a, b, c) {
        var d, e = b._layerSize,
            f = parseInt(e.width * e.height),
            g = .35 * f + 1;
        if (a && (d = cc.textureCache.addImage(a.sourceImage)), this.initWithTexture(d, g)) {
            this.layerName = b.name, this._layerSize = e, this.tiles = b._tiles, this._minGID = b._minGID, this._maxGID = b._maxGID, this._opacity = b._opacity, this.properties = b.properties, this._contentScaleFactor = cc.director.getContentScaleFactor(), this.tileset = a, this._mapTileSize = c.getTileSize(), this.layerOrientation = c.orientation;
            var h = this._calculateLayerOffset(b.offset);
            return this.setPosition(cc.pointPixelsToPoints(h)), this._atlasIndexArray = [], this.setContentSize(cc.sizePixelsToPoints(cc.size(this._layerSize.width * this._mapTileSize.width, this._layerSize.height * this._mapTileSize.height))), this._useAutomaticVertexZ = !1, this._vertexZvalue = 0, !0
        }
        return !1
    },
    releaseMap: function() {
        this.tiles && (this.tiles = null), this._atlasIndexArray && (this._atlasIndexArray = null)
    },
    getTileAt: function(a, b) {
        if (!a) throw "cc.TMXLayer.getTileAt(): pos should be non-null";
        if (void 0 !== b && (a = cc.p(a, b)), a.x >= this._layerSize.width || a.y >= this._layerSize.height || a.x < 0 || a.y < 0) throw "cc.TMXLayer.getTileAt(): invalid position";
        if (!this.tiles || !this._atlasIndexArray) return cc.log("cc.TMXLayer.getTileAt(): TMXLayer: the tiles map has been released"), null;
        var c = null,
            d = this.getTileGIDAt(a);
        if (0 === d) return c;
        var e = 0 | a.x + a.y * this._layerSize.width;
        if (c = this.getChildByTag(e), !c) {
            var f = this.tileset.rectForGID(d);
            f = cc.rectPixelsToPoints(f), c = new cc.Sprite, c.initWithTexture(this.texture, f), c.batchNode = this, c.setPosition(this.getPositionAt(a)), c.vertexZ = this._vertexZForPos(a), c.anchorX = 0, c.anchorY = 0, c.opacity = this._opacity;
            var g = this._atlasIndexForExistantZ(e);
            this.addSpriteWithoutQuad(c, g, e)
        }
        return c
    },
    getTileGIDAt: function(a, b) {
        if (!a) throw "cc.TMXLayer.getTileGIDAt(): pos should be non-null";
        if (void 0 !== b && (a = cc.p(a, b)), a.x >= this._layerSize.width || a.y >= this._layerSize.height || a.x < 0 || a.y < 0) throw "cc.TMXLayer.getTileGIDAt(): invalid position";
        if (!this.tiles || !this._atlasIndexArray) return cc.log("cc.TMXLayer.getTileGIDAt(): TMXLayer: the tiles map has been released"), null;
        var c = 0 | a.x + a.y * this._layerSize.width,
            d = this.tiles[c];
        return (d & cc.TMX_TILE_FLIPPED_MASK) >>> 0
    },
    getTileFlagsAt: function(a, b) {
        if (!a) throw "cc.TMXLayer.getTileFlagsAt(): pos should be non-null";
        if (void 0 !== b && (a = cc.p(a, b)), a.x >= this._layerSize.width || a.y >= this._layerSize.height || a.x < 0 || a.y < 0) throw "cc.TMXLayer.getTileFlagsAt(): invalid position";
        if (!this.tiles || !this._atlasIndexArray) return cc.log("cc.TMXLayer.getTileFlagsAt(): TMXLayer: the tiles map has been released"), null;
        var c = 0 | a.x + a.y * this._layerSize.width,
            d = this.tiles[c];
        return (d & cc.TMX_TILE_FLIPPED_ALL) >>> 0
    },
    setTileGID: function(a, b, c, d) {
        if (!b) throw "cc.TMXLayer.setTileGID(): pos should be non-null";
        var e;
        if (void 0 !== d ? e = cc.p(b, c) : (e = b, d = c), e.x >= this._layerSize.width || e.y >= this._layerSize.height || e.x < 0 || e.y < 0) throw "cc.TMXLayer.setTileGID(): invalid position";
        if (!this.tiles || !this._atlasIndexArray) return void cc.log("cc.TMXLayer.setTileGID(): TMXLayer: the tiles map has been released");
        if (0 !== a && a < this.tileset.firstGid) return void cc.log("cc.TMXLayer.setTileGID(): invalid gid:" + a);
        d = d || 0, this._setNodeDirtyForCache();
        var f = this.getTileFlagsAt(e),
            g = this.getTileGIDAt(e);
        if (g != a || f != d) {
            var h = (a | d) >>> 0;
            if (0 === a) this.removeTileAt(e);
            else if (0 === g) this._insertTileForGID(h, e);
            else {
                var i = e.x + e.y * this._layerSize.width,
                    j = this.getChildByTag(i);
                if (j) {
                    var k = this.tileset.rectForGID(a);
                    k = cc.rectPixelsToPoints(k), j.setTextureRect(k, !1), null != d && this._setupTileSprite(j, e, h), this.tiles[i] = h
                } else this._updateTileForGID(h, e)
            }
        }
    },
    removeTileAt: function(a, b) {
        if (!a) throw "cc.TMXLayer.removeTileAt(): pos should be non-null";
        if (void 0 !== b && (a = cc.p(a, b)), a.x >= this._layerSize.width || a.y >= this._layerSize.height || a.x < 0 || a.y < 0) throw "cc.TMXLayer.removeTileAt(): invalid position";
        if (!this.tiles || !this._atlasIndexArray) return void cc.log("cc.TMXLayer.removeTileAt(): TMXLayer: the tiles map has been released");
        var c = this.getTileGIDAt(a);
        if (0 !== c) {
            cc._renderType === cc._RENDER_TYPE_CANVAS && this._setNodeDirtyForCache();
            var d = 0 | a.x + a.y * this._layerSize.width,
                e = this._atlasIndexForExistantZ(d);
            this.tiles[d] = 0, this._atlasIndexArray.splice(e, 1);
            var f = this.getChildByTag(d);
            if (f) cc.SpriteBatchNode.prototype.removeChild.call(this, f, !0);
            else if (cc._renderType === cc._RENDER_TYPE_WEBGL && this.textureAtlas.removeQuadAtIndex(e), this._children)
                for (var g = this._children, h = 0, i = g.length; i > h; h++) {
                    var j = g[h];
                    if (j) {
                        var k = j.atlasIndex;
                        k >= e && (j.atlasIndex = k - 1)
                    }
                }
        }
    },
    getPositionAt: function(a, b) {
        void 0 !== b && (a = cc.p(a, b));
        var c = cc.p(0, 0);
        switch (this.layerOrientation) {
            case cc.TMX_ORIENTATION_ORTHO:
                c = this._positionForOrthoAt(a);
                break;
            case cc.TMX_ORIENTATION_ISO:
                c = this._positionForIsoAt(a);
                break;
            case cc.TMX_ORIENTATION_HEX:
                c = this._positionForHexAt(a)
        }
        return cc.pointPixelsToPoints(c)
    },
    getProperty: function(a) {
        return this.properties[a]
    },
    setupTiles: function() {
        this._renderCmd.initImageSize(), this._parseInternalProperties(), cc._renderType === cc._RENDER_TYPE_CANVAS && this._setNodeDirtyForCache();
        for (var a = this._layerSize.height, b = this._layerSize.width, c = 0; a > c; c++)
            for (var d = 0; b > d; d++) {
                var e = d + b * c,
                    f = this.tiles[e];
                0 !== f && (this._appendTileForGID(f, cc.p(d, c)), this._minGID = Math.min(f, this._minGID), this._maxGID = Math.max(f, this._maxGID))
            }
        this._maxGID >= this.tileset.firstGid && this._minGID >= this.tileset.firstGid || cc.log("cocos2d:TMX: Only 1 tileset per layer is supported")
    },
    addChild: function() {
        cc.log("addChild: is not supported on cc.TMXLayer. Instead use setTileGID or tileAt.")
    },
    removeChild: function(a, b) {
        if (a) {
            if (-1 === this._children.indexOf(a)) return void cc.log("cc.TMXLayer.removeChild(): Tile does not belong to TMXLayer");
            cc._renderType === cc._RENDER_TYPE_CANVAS && this._setNodeDirtyForCache();
            var c = a.atlasIndex,
                d = this._atlasIndexArray[c];
            this.tiles[d] = 0, this._atlasIndexArray.splice(c, 1), cc.SpriteBatchNode.prototype.removeChild.call(this, a, b), cc.renderer.childrenOrderDirty = !0
        }
    },
    getLayerName: function() {
        return this.layerName
    },
    setLayerName: function(a) {
        this.layerName = a
    },
    _positionForIsoAt: function(a) {
        return cc.p(this._mapTileSize.width / 2 * (this._layerSize.width + a.x - a.y - 1), this._mapTileSize.height / 2 * (2 * this._layerSize.height - a.x - a.y - 2))
    },
    _positionForOrthoAt: function(a) {
        return cc.p(a.x * this._mapTileSize.width, (this._layerSize.height - a.y - 1) * this._mapTileSize.height)
    },
    _positionForHexAt: function(a) {
        var b = a.x % 2 == 1 ? -this._mapTileSize.height / 2 : 0;
        return cc.p(a.x * this._mapTileSize.width * 3 / 4, (this._layerSize.height - a.y - 1) * this._mapTileSize.height + b)
    },
    _calculateLayerOffset: function(a) {
        var b = cc.p(0, 0);
        switch (this.layerOrientation) {
            case cc.TMX_ORIENTATION_ORTHO:
                b = cc.p(a.x * this._mapTileSize.width, -a.y * this._mapTileSize.height);
                break;
            case cc.TMX_ORIENTATION_ISO:
                b = cc.p(this._mapTileSize.width / 2 * (a.x - a.y), this._mapTileSize.height / 2 * (-a.x - a.y));
                break;
            case cc.TMX_ORIENTATION_HEX:
                (0 !== a.x || 0 !== a.y) && cc.log("offset for hexagonal map not implemented yet")
        }
        return b
    },
    _appendTileForGID: function(a, b) {
        var c = this.tileset.rectForGID(a);
        c = cc.rectPixelsToPoints(c);
        var d = 0 | b.x + b.y * this._layerSize.width,
            e = this._renderCmd._reusedTileWithRect(c);
        this._setupTileSprite(e, b, a);
        var f = this._atlasIndexArray.length;
        return this.insertQuadFromSprite(e, f), this._atlasIndexArray.splice(f, 0, d), e
    },
    _insertTileForGID: function(a, b) {
        var c = this.tileset.rectForGID(a);
        c = cc.rectPixelsToPoints(c);
        var d = 0 | b.x + b.y * this._layerSize.width,
            e = this._renderCmd._reusedTileWithRect(c);
        this._setupTileSprite(e, b, a);
        var f = this._atlasIndexForNewZ(d);
        if (this.insertQuadFromSprite(e, f), this._atlasIndexArray.splice(f, 0, d), this._children)
            for (var g = this._children, h = 0, i = g.length; i > h; h++) {
                var j = g[h];
                if (j) {
                    var k = j.atlasIndex;
                    k >= f && (j.atlasIndex = k + 1)
                }
            }
        return this.tiles[d] = a, e
    },
    _updateTileForGID: function(a, b) {
        var c = this.tileset.rectForGID(a),
            d = this._contentScaleFactor;
        c = cc.rect(c.x / d, c.y / d, c.width / d, c.height / d);
        var e = b.x + b.y * this._layerSize.width,
            f = this._renderCmd._reusedTileWithRect(c);
        return this._setupTileSprite(f, b, a), f.atlasIndex = this._atlasIndexForExistantZ(e), f.dirty = !0, f.updateTransform(), this.tiles[e] = a, f
    },
    _parseInternalProperties: function() {
        var a = this.getProperty("cc_vertexz");
        if (a)
            if ("automatic" == a) {
                this._useAutomaticVertexZ = !0;
                var b = this.getProperty("cc_alpha_func"),
                    c = 0;
                if (b && (c = parseFloat(b)), cc._renderType === cc._RENDER_TYPE_WEBGL) {
                    this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST);
                    var d = cc._renderContext.getUniformLocation(this.shaderProgram.getProgram(), cc.UNIFORM_ALPHA_TEST_VALUE_S);
                    this.shaderProgram.use(), this.shaderProgram.setUniformLocationWith1f(d, c)
                }
            } else this._vertexZvalue = parseInt(a, 10)
    },
    _setupTileSprite: function(a, b, c) {
        var d = b.x + b.y * this._layerSize.width;
        if (a.setPosition(this.getPositionAt(b)), cc._renderType === cc._RENDER_TYPE_WEBGL ? a.vertexZ = this._vertexZForPos(b) : a.tag = d, a.anchorX = 0, a.anchorY = 0, a.opacity = this._opacity, cc._renderType === cc._RENDER_TYPE_WEBGL && (a.rotation = 0), a.setFlippedX(!1), a.setFlippedY(!1), (c & cc.TMX_TILE_DIAGONAL_FLAG) >>> 0) {
            a.anchorX = .5, a.anchorY = .5, a.x = this.getPositionAt(b).x + a.width / 2, a.y = this.getPositionAt(b).y + a.height / 2;
            var e = (c & (cc.TMX_TILE_HORIZONTAL_FLAG | cc.TMX_TILE_VERTICAL_FLAG) >>> 0) >>> 0;
            e == cc.TMX_TILE_HORIZONTAL_FLAG ? a.rotation = 90 : e == cc.TMX_TILE_VERTICAL_FLAG ? a.rotation = 270 : e == (cc.TMX_TILE_VERTICAL_FLAG | cc.TMX_TILE_HORIZONTAL_FLAG) >>> 0 ? (a.rotation = 90, a.setFlippedX(!0)) : (a.rotation = 270, a.setFlippedX(!0))
        } else(c & cc.TMX_TILE_HORIZONTAL_FLAG) >>> 0 && a.setFlippedX(!0), (c & cc.TMX_TILE_VERTICAL_FLAG) >>> 0 && a.setFlippedY(!0)
    },
    _vertexZForPos: function(a) {
        var b = 0,
            c = 0;
        if (this._useAutomaticVertexZ) switch (this.layerOrientation) {
            case cc.TMX_ORIENTATION_ISO:
                c = this._layerSize.width + this._layerSize.height, b = -(c - (a.x + a.y));
                break;
            case cc.TMX_ORIENTATION_ORTHO:
                b = -(this._layerSize.height - a.y);
                break;
            case cc.TMX_ORIENTATION_HEX:
                cc.log("TMX Hexa zOrder not supported");
                break;
            default:
                cc.log("TMX invalid value")
        } else b = this._vertexZvalue;
        return b
    },
    _atlasIndexForExistantZ: function(a) {
        var b;
        if (this._atlasIndexArray)
            for (var c = this._atlasIndexArray, d = 0, e = c.length; e > d && (b = c[d], b != a); d++);
        return cc.isNumber(b) || cc.log("cc.TMXLayer._atlasIndexForExistantZ(): TMX atlas index not found. Shall not happen"), d
    },
    _atlasIndexForNewZ: function(a) {
        for (var b = this._atlasIndexArray, c = 0, d = b.length; d > c; c++) {
            var e = b[c];
            if (e > a) break
        }
        return c
    }
});
var _p = cc.TMXLayer.prototype;
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture), _p.layerWidth, cc.defineGetterSetter(_p, "layerWidth", _p._getLayerWidth, _p._setLayerWidth), _p.layerHeight, cc.defineGetterSetter(_p, "layerHeight", _p._getLayerHeight, _p._setLayerHeight), _p.tileWidth, cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth), _p.tileHeight, cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight), cc.TMXLayer.create = function(a, b, c) {
        return new cc.TMXLayer(a, b, c)
    },
    function() {
        cc.TMXLayer.CanvasRenderCmd = function(a) {
            cc.SpriteBatchNode.CanvasRenderCmd.call(this, a), this._needDraw = !0, this._realWorldTransform = {
                a: 1,
                b: 0,
                c: 0,
                d: 1,
                tx: 0,
                ty: 0
            }, this._childrenRenderCmds = [];
            var b = cc._canvas,
                c = cc.newElement("canvas");
            c.width = b.width, c.height = b.height, this._cacheCanvas = c, this._cacheContext = new cc.CanvasContextWrapper(this._cacheCanvas.getContext("2d"));
            var d = new cc.Texture2D;
            d.initWithElement(c), d.handleLoadedTexture(), this._cacheTexture = d, this._cacheDirty = !1
        };
        var a = cc.TMXLayer.CanvasRenderCmd.prototype = Object.create(cc.SpriteBatchNode.CanvasRenderCmd.prototype);
        a.constructor = cc.TMXLayer.CanvasRenderCmd, a._copyRendererCmds = function(a) {
            if (a) {
                var b = this._childrenRenderCmds;
                b.length = 0;
                for (var c = 0, d = a.length; d > c; c++) b[c] = a[c]
            }
        }, a._setNodeDirtyForCache = function() {
            this._cacheDirty = !0
        }, a._renderingChildToCache = function(a, b) {
            if (this._cacheDirty) {
                var c = this._childrenRenderCmds,
                    d = this._cacheContext,
                    e = d.getContext(),
                    f = this._cacheCanvas;
                e.setTransform(1, 0, 0, 1, 0, 0), e.clearRect(0, 0, f.width, f.height);
                for (var g = 0, h = c.length; h > g; g++) c[g].rendering(d, a, b), c[g]._cacheDirty = !1;
                this._cacheDirty = !1
            }
        }, a.rendering = function(a, b, c) {
            var d = this._displayedOpacity / 255;
            if (!(0 >= d)) {
                var e = this._node;
                this._renderingChildToCache(b, c);
                var f = a || cc._renderContext,
                    g = f.getContext();
                f.setGlobalAlpha(d);
                var h = 0 | -this._anchorPointInPoints.x,
                    i = 0 | -this._anchorPointInPoints.y,
                    j = this._cacheCanvas;
                if (j && 0 !== j.width && 0 !== j.height) {
                    f.setTransform(this._realWorldTransform, b, c);
                    var k = j.height * c;
                    if (e.layerOrientation === cc.TMX_ORIENTATION_HEX) {
                        var l = .5 * e._mapTileSize.height * c;
                        g.drawImage(j, 0, 0, j.width, j.height, h, -(i + k) + l, j.width * b, k)
                    } else g.drawImage(j, 0, 0, j.width, j.height, h, -(i + k), j.width * b, k)
                }
                cc.g_NumberOfDraws++
            }
        }, a._updateCacheContext = function() {
            var a = this._node,
                b = a._contentSize,
                c = this._cacheCanvas,
                d = cc.contentScaleFactor();
            c.width = 0 | 1.5 * b.width * d, c.height = 0 | 1.5 * b.height * d, a.layerOrientation === cc.TMX_ORIENTATION_HEX ? this._cacheContext.setOffset(0, .5 * -a._mapTileSize.height) : this._cacheContext.setOffset(0, 0);
            var e = this._cacheTexture._contentSize;
            e.width = c.width, e.height = c.height
        }, a.getTexture = function() {
            return this._cacheTexture
        }, a.visit = function(a) {
            var b, c, d = this._node,
                e = d._children;
            if (d._visible && e && 0 !== e.length) {
                if (a = a || this.getParentRenderCmd(), a && (this._curLevel = a._curLevel + 1), this._syncStatus(a), this._cacheDirty) {
                    var f = this._cacheContext,
                        g = this._cacheCanvas,
                        h = f.getContext(),
                        i = d.__instanceId,
                        j = cc.renderer;
                    for (j._turnToCacheMode(i), d.sortAllChildren(), b = 0, c = e.length; c > b; b++)
                        if (e[b]) {
                            var k = e[b]._renderCmd;
                            k && (k.visit(this), k._cacheDirty = !1)
                        }
                    this._copyRendererCmds(j._cacheToCanvasCmds[i]), h.setTransform(1, 0, 0, 1, 0, 0), h.clearRect(0, 0, g.width, g.height), j._renderingToCacheCanvas(f, i), this._cacheDirty = !1
                }
                cc.renderer.pushRenderCommand(this), this._dirtyFlag = 0
            }
        }, a.transform = function(a, b) {
            var c = this.getNodeToParentTransform(),
                d = this._realWorldTransform;
            if (a) {
                var e = a._worldTransform;
                d.a = c.a * e.a + c.b * e.c, d.b = c.a * e.b + c.b * e.d, d.c = c.c * e.a + c.d * e.c, d.d = c.c * e.b + c.d * e.d;
                var f = a._transform,
                    g = -(f.b + f.c) * c.ty,
                    h = -(f.b + f.c) * c.tx;
                d.tx = c.tx * e.a + c.ty * e.c + e.tx + g, d.ty = c.tx * e.b + c.ty * e.d + e.ty + h
            } else d.a = c.a, d.b = c.b, d.c = c.c, d.d = c.d, d.tx = c.tx, d.ty = c.ty; if (b) {
                var i = this._node._children;
                if (!i || 0 === i.length) return;
                var j, k;
                for (j = 0, k = i.length; k > j; j++) i[j]._renderCmd.transform(this, b)
            }
        }, a.initImageSize = function() {
            var a = this._node;
            a.tileset.imageSize = this._originalTexture.getContentSizeInPixels()
        }, a._reusedTileWithRect = function(a) {
            var b = this._node;
            return b._reusedTile = new cc.Sprite, b._reusedTile.initWithTexture(b._renderCmd._texture, a, !1), b._reusedTile.batchNode = b, b._reusedTile.parent = b, b._reusedTile._renderCmd._cachedParent = b._renderCmd, b._reusedTile
        }
    }();
! function() {
    cc.TMXLayer.WebGLRenderCmd = function(a) {
        cc.SpriteBatchNode.WebGLRenderCmd.call(this, a), this._needDraw = !0
    };
    var a = cc.TMXLayer.WebGLRenderCmd.prototype = Object.create(cc.SpriteBatchNode.WebGLRenderCmd.prototype);
    a.constructor = cc.TMXLayer.WebGLRenderCmd, a._updateCacheContext = function() {}, a.initImageSize = function() {
        var a = this._node;
        a.tileset.imageSize = this._textureAtlas.texture.getContentSizeInPixels(), this._textureAtlas.texture.setAliasTexParameters()
    }, a._reusedTileWithRect = function(a) {
        var b = this._node;
        return b._reusedTile ? (b._reusedTile.batchNode = null, b._reusedTile.setTextureRect(a, !1), b._reusedTile.batchNode = b) : (b._reusedTile = new cc.Sprite, b._reusedTile.initWithTexture(b.texture, a, !1), b._reusedTile.batchNode = b), b._reusedTile
    }
}();
cc.PointObject = cc.Class.extend({
        _ratio: null,
        _offset: null,
        _child: null,
        ctor: function(a, b) {
            this.initWithCCPoint(a, b)
        },
        getRatio: function() {
            return this._ratio
        },
        setRatio: function(a) {
            this._ratio = a
        },
        getOffset: function() {
            return this._offset
        },
        setOffset: function(a) {
            this._offset = a
        },
        getChild: function() {
            return this._child
        },
        setChild: function(a) {
            this._child = a
        },
        initWithCCPoint: function(a, b) {
            return this._ratio = a, this._offset = b, this._child = null, !0
        }
    }), cc.PointObject.create = function(a, b) {
        return new cc.PointObject(a, b)
    }, cc.ParallaxNode = cc.Node.extend({
        parallaxArray: null,
        _lastPosition: null,
        _className: "ParallaxNode",
        getParallaxArray: function() {
            return this.parallaxArray
        },
        setParallaxArray: function(a) {
            this.parallaxArray = a
        },
        ctor: function() {
            cc.Node.prototype.ctor.call(this), this.parallaxArray = [], this._lastPosition = cc.p(-100, -100)
        },
        addChild: function(a, b, c, d) {
            if (3 === arguments.length) return void cc.log("ParallaxNode: use addChild(child, z, ratio, offset) instead");
            if (!a) throw "cc.ParallaxNode.addChild(): child should be non-null";
            var e = new cc.PointObject(c, d);
            e.setChild(a), this.parallaxArray.push(e), a.setPosition(this._position.x * c.x + d.x, this._position.y * c.y + d.y), cc.Node.prototype.addChild.call(this, a, b, a.tag)
        },
        removeChild: function(a, b) {
            for (var c = this.parallaxArray, d = 0; d < c.length; d++) {
                var e = c[d];
                if (e.getChild() == a) {
                    c.splice(d, 1);
                    break
                }
            }
            cc.Node.prototype.removeChild.call(this, a, b)
        },
        removeAllChildren: function(a) {
            this.parallaxArray.length = 0, cc.Node.prototype.removeAllChildren.call(this, a)
        },
        _updateParallaxPosition: function() {
            var a = this._absolutePosition();
            if (!cc.pointEqualToPoint(a, this._lastPosition)) {
                for (var b = this.parallaxArray, c = 0, d = b.length; d > c; c++) {
                    var e = b[c],
                        f = e.getChild();
                    f.setPosition(-a.x + a.x * e.getRatio().x + e.getOffset().x, -a.y + a.y * e.getRatio().y + e.getOffset().y)
                }
                this._lastPosition = a
            }
        },
        _absolutePosition: function() {
            for (var a = this._position, b = this; null != b.parent;) b = b.parent, a = cc.pAdd(a, b.getPosition());
            return a
        },
        _createRenderCmd: function() {
            return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.ParallaxNode.CanvasRenderCmd(this) : new cc.ParallaxNode.WebGLRenderCmd(this)
        }
    }), cc.ParallaxNode.create = function() {
        return new cc.ParallaxNode
    },
    function() {
        cc.ParallaxNode.CanvasRenderCmd = function(a) {
            cc.Node.CanvasRenderCmd.call(this, a), this._needDraw = !1
        };
        var a = cc.ParallaxNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
        a.constructor = cc.ParallaxNode.CanvasRenderCmd, a.updateStatus = function() {
            this._node._updateParallaxPosition(), cc.Node.CanvasRenderCmd.prototype.updateStatus.call(this)
        }, a._syncStatus = function(a) {
            this._node._updateParallaxPosition(), cc.Node.CanvasRenderCmd.prototype._syncStatus.call(this, a)
        }
    }(),
    function() {
        if (cc._renderType === cc._RENDER_TYPE_WEBGL) {
            cc.ParallaxNode.WebGLRenderCmd = function(a) {
                cc.Node.WebGLRenderCmd.call(this, a), this._needDraw = !1
            };
            var a = cc.ParallaxNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
            a.constructor = cc.ParallaxNode.WebGLRenderCmd, a.updateStatus = function() {
                this._node._updateParallaxPosition(), cc.Node.WebGLRenderCmd.prototype.updateStatus.call(this)
            }, a._syncStatus = function(a) {
                this._node._updateParallaxPosition(), cc.Node.WebGLRenderCmd.prototype._syncStatus.call(this, a)
            }
        }
    }();
cc.CONTROL_EVENT_TOTAL_NUMBER = 9, cc.CONTROL_EVENT_TOUCH_DOWN = 1, cc.CONTROL_EVENT_TOUCH_DRAG_INSIDE = 2, cc.CONTROL_EVENT_TOUCH_DRAG_OUTSIDE = 4, cc.CONTROL_EVENT_TOUCH_DRAG_ENTER = 8, cc.CONTROL_EVENT_TOUCH_DRAG_EXIT = 16, cc.CONTROL_EVENT_TOUCH_UP_INSIDE = 32, cc.CONTROL_EVENT_TOUCH_UP_OUTSIDE = 64, cc.CONTROL_EVENT_TOUCH_CANCEL = 128, cc.CONTROL_EVENT_VALUECHANGED = 256, cc.CONTROL_STATE_NORMAL = 1, cc.CONTROL_STATE_HIGHLIGHTED = 2, cc.CONTROL_STATE_DISABLED = 4, cc.CONTROL_STATE_SELECTED = 8, cc.CONTROL_STATE_INITIAL = 8, cc.Control = cc.Layer.extend({
    _isOpacityModifyRGB: !1,
    _hasVisibleParents: !1,
    _touchListener: null,
    _className: "Control",
    isOpacityModifyRGB: function() {
        return this._isOpacityModifyRGB
    },
    setOpacityModifyRGB: function(a) {
        this._isOpacityModifyRGB = a;
        for (var b = this.getChildren(), c = 0, d = b.length; d > c; c++) {
            var e = b[c];
            e && e.setOpacityModifyRGB(a)
        }
    },
    _state: cc.CONTROL_STATE_NORMAL,
    getState: function() {
        return this._state
    },
    _enabled: !1,
    _selected: !1,
    _highlighted: !1,
    _dispatchTable: null,
    setEnabled: function(a) {
        this._enabled = a, this._state = a ? cc.CONTROL_STATE_NORMAL : cc.CONTROL_STATE_DISABLED, this.needsLayout()
    },
    isEnabled: function() {
        return this._enabled
    },
    setSelected: function(a) {
        this._selected = a, this.needsLayout()
    },
    isSelected: function() {
        return this._selected
    },
    setHighlighted: function(a) {
        this._highlighted = a, this.needsLayout()
    },
    isHighlighted: function() {
        return this._highlighted
    },
    hasVisibleParents: function() {
        for (var a = this.getParent(), b = a; null != b; b = b.getParent())
            if (!b.isVisible()) return !1;
        return !0
    },
    ctor: function() {
        cc.Layer.prototype.ctor.call(this), this._dispatchTable = {}, this._color = cc.color.WHITE
    },
    init: function() {
        if (cc.Layer.prototype.init.call(this)) {
            this._state = cc.CONTROL_STATE_NORMAL, this._enabled = !0, this._selected = !1, this._highlighted = !1;
            var a = cc.EventListener.create({
                event: cc.EventListener.TOUCH_ONE_BY_ONE,
                swallowTouches: !0
            });
            return this.onTouchBegan && (a.onTouchBegan = this.onTouchBegan.bind(this)), this.onTouchMoved && (a.onTouchMoved = this.onTouchMoved.bind(this)), this.onTouchEnded && (a.onTouchEnded = this.onTouchEnded.bind(this)), this.onTouchCancelled && (a.onTouchCancelled = this.onTouchCancelled.bind(this)), this._touchListener = a, !0
        }
        return !1
    },
    onEnter: function() {
        var a = this._touchListener;
        a._isRegistered() || cc.eventManager.addListener(a, this), cc.Node.prototype.onEnter.call(this)
    },
    sendActionsForControlEvents: function(a) {
        for (var b = 0, c = cc.CONTROL_EVENT_TOTAL_NUMBER; c > b; b++)
            if (a & 1 << b)
                for (var d = this._dispatchListforControlEvent(1 << b), e = 0, f = d.length; f > e; e++) d[e].invoke(this)
    },
    addTargetWithActionForControlEvents: function(a, b, c) {
        for (var d = 0, e = cc.CONTROL_EVENT_TOTAL_NUMBER; e > d; d++) c & 1 << d && this._addTargetWithActionForControlEvent(a, b, 1 << d)
    },
    removeTargetWithActionForControlEvents: function(a, b, c) {
        for (var d = 0, e = cc.CONTROL_EVENT_TOTAL_NUMBER; e > d; d++) c & 1 << d && this._removeTargetWithActionForControlEvent(a, b, 1 << d)
    },
    getTouchLocation: function(a) {
        var b = a.getLocation();
        return this.convertToNodeSpace(b)
    },
    isTouchInside: function(a) {
        var b = a.getLocation();
        return b = this.getParent().convertToNodeSpace(b), cc.rectContainsPoint(this.getBoundingBox(), b)
    },
    _invocationWithTargetAndActionForControlEvent: function() {
        return null
    },
    _dispatchListforControlEvent: function(a) {
        return a = a.toString(), this._dispatchTable[a] || (this._dispatchTable[a] = []), this._dispatchTable[a]
    },
    _addTargetWithActionForControlEvent: function(a, b, c) {
        var d = new cc.Invocation(a, b, c),
            e = this._dispatchListforControlEvent(c);
        e.push(d)
    },
    _removeTargetWithActionForControlEvent: function(a, b, c) {
        var d = this._dispatchListforControlEvent(c);
        if (a || b)
            for (var e = 0; e < d.length;) {
                var f = d[e],
                    g = !0;
                a && (g = a == f.getTarget()), b && (g = g && b == f.getAction()), g ? cc.arrayRemoveObject(d, f) : e++
            } else d.length = 0
    },
    needsLayout: function() {}
});
var _p = cc.Control.prototype;
_p.state, cc.defineGetterSetter(_p, "state", _p.getState), _p.enabled, cc.defineGetterSetter(_p, "enabled", _p.isEnabled, _p.setEnabled), _p.selected, cc.defineGetterSetter(_p, "selected", _p.isSelected, _p.setSelected), _p.highlighted, cc.defineGetterSetter(_p, "highlighted", _p.isHighlighted, _p.setHighlighted), _p = null, cc.Control.create = function() {
    var a = new cc.Control;
    return a && a.init() ? a : null
}, cc.CONTROL_ZOOM_ACTION_TAG = 3435855873, cc.ControlButton = cc.Control.extend({
    _doesAdjustBackgroundImage: !1,
    zoomOnTouchDown: !1,
    _preferredSize: null,
    _labelAnchorPoint: null,
    _currentTitle: null,
    _currentTitleColor: null,
    _titleLabel: null,
    _backgroundSprite: null,
    _opacity: 0,
    _isPushed: !1,
    _titleDispatchTable: null,
    _titleColorDispatchTable: null,
    _titleLabelDispatchTable: null,
    _backgroundSpriteDispatchTable: null,
    _parentInited: !1,
    _marginV: 0,
    _marginH: 0,
    _className: "ControlButton",
    ctor: function(a, b, c) {
        cc.Control.prototype.ctor.call(this), this._preferredSize = cc.size(0, 0), this._labelAnchorPoint = cc.p(0, 0), this._currentTitle = "", this._currentTitleColor = cc.color.WHITE, this._titleDispatchTable = {}, this._titleColorDispatchTable = {}, this._titleLabelDispatchTable = {}, this._backgroundSpriteDispatchTable = {}, void 0 != c ? this.initWithTitleAndFontNameAndFontSize(a, b, c) : void 0 != b ? this.initWithLabelAndBackgroundSprite(a, b) : void 0 != a ? this.initWithBackgroundSprite(a) : this.init()
    },
    init: function() {
        return this.initWithLabelAndBackgroundSprite(new cc.LabelTTF("", "Arial", 12), new cc.Scale9Sprite)
    },
    needsLayout: function() {
        if (this._parentInited) {
            this._titleLabel && this._titleLabel.setVisible(!1), this._backgroundSprite && this._backgroundSprite.setVisible(!1), this.setLabelAnchorPoint(this._labelAnchorPoint);
            var a = this._state;
            this._currentTitle = this.getTitleForState(a), this._currentTitleColor = this.getTitleColorForState(a), this._titleLabel = this.getTitleLabelForState(a);
            var b = this._titleLabel;
            b && b.setString && b.setString(this._currentTitle), b && b.setColor(this._currentTitleColor);
            var c = this.getContentSize();
            b && b.setPosition(c.width / 2, c.height / 2), this._backgroundSprite = this.getBackgroundSpriteForState(a);
            var d = this._backgroundSprite;
            d && d.setPosition(c.width / 2, c.height / 2);
            var e = cc.size(0, 0);
            if (b) {
                var f = b.getBoundingBox();
                e.width = f.width, e.height = f.height
            }
            if (this._doesAdjustBackgroundImage) d && d.setContentSize(e.width + 2 * this._marginH, e.height + 2 * this._marginV);
            else if (d) {
                var g = d.getPreferredSize();
                g = cc.size(g.width, g.height), g.width <= 0 && (g.width = e.width), g.height <= 0 && (g.height = e.height), d.setContentSize(g)
            }
            var h = b ? b.getBoundingBox() : cc.rect(0, 0, 0, 0),
                i = d ? d.getBoundingBox() : cc.rect(0, 0, 0, 0),
                j = cc.rectUnion(h, i);
            this.setContentSize(j.width, j.height), c = this.getContentSize(), b && (b.setPosition(c.width / 2, c.height / 2), b.setVisible(!0)), d && (d.setPosition(c.width / 2, c.height / 2), d.setVisible(!0))
        }
    },
    initWithLabelAndBackgroundSprite: function(a, b) {
        if (!a) throw "cc.ControlButton.initWithLabelAndBackgroundSprite(): label should be non-null";
        if (!b) throw "cc.ControlButton.initWithLabelAndBackgroundSprite(): backgroundSprite should be non-null";
        if (cc.Control.prototype.init.call(this, !0)) {
            this._parentInited = !0, this._titleDispatchTable = {}, this._titleColorDispatchTable = {}, this._titleLabelDispatchTable = {}, this._backgroundSpriteDispatchTable = {}, this._isPushed = !1, this.zoomOnTouchDown = !0, this._currentTitle = null, this.setAdjustBackgroundImage(!0), this.setPreferredSize(cc.size(0, 0)), this.zoomOnTouchDown = !0, this.ignoreAnchorPointForPosition(!1), this.setAnchorPoint(.5, .5), this._titleLabel = a, this._backgroundSprite = b, this.setOpacity(255), this.setOpacityModifyRGB(!0);
            var c = a.getString();
            return this.setTitleForState(c, cc.CONTROL_STATE_NORMAL), this.setTitleColorForState(a.getColor(), cc.CONTROL_STATE_NORMAL), this.setTitleLabelForState(a, cc.CONTROL_STATE_NORMAL), this.setBackgroundSpriteForState(b, cc.CONTROL_STATE_NORMAL), this._state = cc.CONTROL_STATE_NORMAL, this._marginH = 24, this._marginV = 12, this._labelAnchorPoint = cc.p(.5, .5), this.setPreferredSize(cc.size(0, 0)), this.needsLayout(), !0
        }
        return !1
    },
    initWithTitleAndFontNameAndFontSize: function(a, b, c) {
        var d = new cc.LabelTTF(a, b, c);
        return this.initWithLabelAndBackgroundSprite(d, new cc.Scale9Sprite)
    },
    initWithBackgroundSprite: function(a) {
        var b = new cc.LabelTTF("", "Arial", 30);
        return this.initWithLabelAndBackgroundSprite(b, a)
    },
    doesAdjustBackgroundImage: function() {
        return this._doesAdjustBackgroundImage
    },
    setAdjustBackgroundImage: function(a) {
        this._doesAdjustBackgroundImage = a, this.needsLayout()
    },
    getZoomOnTouchDown: function() {
        return this.zoomOnTouchDown
    },
    setZoomOnTouchDown: function(a) {
        return this.zoomOnTouchDown = a
    },
    getPreferredSize: function() {
        return this._preferredSize
    },
    setPreferredSize: function(a) {
        if (0 === a.width && 0 === a.height) this._doesAdjustBackgroundImage = !0;
        else {
            this._doesAdjustBackgroundImage = !1;
            var b = this._backgroundSpriteDispatchTable;
            for (var c in b) b[c].setPreferredSize(a)
        }
        this._preferredSize = a, this.needsLayout()
    },
    getLabelAnchorPoint: function() {
        return this._labelAnchorPoint
    },
    setLabelAnchorPoint: function(a) {
        this._labelAnchorPoint = a, this._titleLabel && this._titleLabel.setAnchorPoint(a)
    },
    _getCurrentTitle: function() {
        return this._currentTitle
    },
    _getCurrentTitleColor: function() {
        return this._currentTitleColor
    },
    getOpacity: function() {
        return this._opacity
    },
    setOpacity: function(a) {
        cc.Control.prototype.setOpacity.call(this, a);
        var b = this._backgroundSpriteDispatchTable;
        for (var c in b) b[c].setOpacity(a)
    },
    setColor: function(a) {
        cc.Control.prototype.setColor.call(this, a);
        var b = this._backgroundSpriteDispatchTable;
        for (var c in b) b[c].setColor(a)
    },
    getColor: function() {
        var a = this._realColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    isPushed: function() {
        return this._isPushed
    },
    _getVerticalMargin: function() {
        return this._marginV
    },
    _getHorizontalOrigin: function() {
        return this._marginH
    },
    setMargins: function(a, b) {
        this._marginV = b, this._marginH = a, this.needsLayout()
    },
    setEnabled: function(a) {
        cc.Control.prototype.setEnabled.call(this, a), this.needsLayout()
    },
    setSelected: function(a) {
        cc.Control.prototype.setSelected.call(this, a), this.needsLayout()
    },
    setHighlighted: function(a) {
        this._state = a ? cc.CONTROL_STATE_HIGHLIGHTED : cc.CONTROL_STATE_NORMAL, cc.Control.prototype.setHighlighted.call(this, a);
        var b = this.getActionByTag(cc.CONTROL_ZOOM_ACTION_TAG);
        if (b && this.stopAction(b), this.zoomOnTouchDown) {
            var c = this.isHighlighted() && this.isEnabled() && !this.isSelected() ? 1.1 : 1,
                d = cc.scaleTo(.05, c);
            d.setTag(cc.CONTROL_ZOOM_ACTION_TAG), this.runAction(d)
        }
    },
    onTouchBegan: function(a) {
        return this.isTouchInside(a) && this.isEnabled() && this.isVisible() && this.hasVisibleParents() ? (this._isPushed = !0, this.setHighlighted(!0), this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_DOWN), !0) : !1
    },
    onTouchMoved: function(a) {
        if (!this._enabled || !this._isPushed || this._selected) return void(this._highlighted && this.setHighlighted(!1));
        var b = this.isTouchInside(a);
        b && !this._highlighted ? (this.setHighlighted(!0), this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_DRAG_ENTER)) : b && this._highlighted ? this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_DRAG_INSIDE) : !b && this._highlighted ? (this.setHighlighted(!1), this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_DRAG_EXIT)) : b || this._highlighted || this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_DRAG_OUTSIDE)
    },
    onTouchEnded: function(a) {
        this._isPushed = !1, this.setHighlighted(!1), this.sendActionsForControlEvents(this.isTouchInside(a) ? cc.CONTROL_EVENT_TOUCH_UP_INSIDE : cc.CONTROL_EVENT_TOUCH_UP_OUTSIDE)
    },
    onTouchCancelled: function() {
        this._isPushed = !1, this.setHighlighted(!1), this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_CANCEL)
    },
    getTitleForState: function(a) {
        var b = this._titleDispatchTable;
        return b ? b[a] ? b[a] : b[cc.CONTROL_STATE_NORMAL] : ""
    },
    setTitleForState: function(a, b) {
        this._titleDispatchTable[b] = a || "", this.getState() == b && this.needsLayout()
    },
    getTitleColorForState: function(a) {
        var b = this._titleColorDispatchTable[a];
        return b ? b : (b = this._titleColorDispatchTable[cc.CONTROL_STATE_NORMAL], b ? b : cc.color.WHITE)
    },
    setTitleColorForState: function(a, b) {
        this._titleColorDispatchTable[b] = a, this.getState() == b && this.needsLayout()
    },
    getTitleLabelForState: function(a) {
        var b = this._titleLabelDispatchTable;
        return b[a] ? b[a] : b[cc.CONTROL_STATE_NORMAL]
    },
    setTitleLabelForState: function(a, b) {
        var c = this._titleLabelDispatchTable;
        if (c[b]) {
            var d = c[b];
            d && this.removeChild(d, !0)
        }
        c[b] = a, a.setVisible(!1), a.setAnchorPoint(.5, .5), this.addChild(a, 1), this.getState() == b && this.needsLayout()
    },
    setTitleTTFForState: function(a, b) {
        var c = this.getTitleForState(b);
        c || (c = ""), this.setTitleLabelForState(new cc.LabelTTF(c, a, 12), b)
    },
    getTitleTTFForState: function(a) {
        var b = this.getTitleLabelForState(a);
        return null != b && b instanceof cc.LabelTTF ? b.getFontName() : ""
    },
    setTitleTTFSizeForState: function(a, b) {
        var c = this.getTitleLabelForState(b);
        null != c && c instanceof cc.LabelTTF && c.setFontSize(a)
    },
    getTitleTTFSizeForState: function(a) {
        var b = this.getTitleLabelForState(a);
        return null != b && b instanceof cc.LabelTTF ? b.getFontSize() : 0
    },
    setTitleBMFontForState: function(a, b) {
        var c = this.getTitleForState(b);
        c || (c = ""), this.setTitleLabelForState(new cc.LabelBMFont(c, a), b)
    },
    getTitleBMFontForState: function(a) {
        var b = this.getTitleLabelForState(a);
        return null != b && b instanceof cc.LabelBMFont ? b.getFntFile() : ""
    },
    getBackgroundSpriteForState: function(a) {
        var b = this._backgroundSpriteDispatchTable;
        return b[a] ? b[a] : b[cc.CONTROL_STATE_NORMAL]
    },
    setBackgroundSpriteForState: function(a, b) {
        var c = this._backgroundSpriteDispatchTable;
        if (c[b]) {
            var d = c[b];
            d && this.removeChild(d, !0)
        }
        c[b] = a, a.setVisible(!1), a.setAnchorPoint(.5, .5), this.addChild(a);
        var e = this._preferredSize;
        (0 !== e.width || 0 !== e.height) && a.setPreferredSize(e), this._state === b && this.needsLayout()
    },
    setBackgroundSpriteFrameForState: function(a, b) {
        var c = cc.Scale9Sprite.createWithSpriteFrame(a);
        this.setBackgroundSpriteForState(c, b)
    }
});
var _p = cc.ControlButton.prototype;
_p.adjustBackground, cc.defineGetterSetter(_p, "adjustBackground", _p.getAdjustBackgroundImage, _p.setAdjustBackgroundImage), _p.preferredSize, cc.defineGetterSetter(_p, "preferredSize", _p.getPreferredSize, _p.setPreferredSize), _p.labelAnchor, cc.defineGetterSetter(_p, "labelAnchor", _p.getLabelAnchorPoint, _p.setLabelAnchorPoint), _p = null, cc.ControlButton.create = function(a, b, c) {
    return new cc.ControlButton(a, b, c)
}, cc.RGBA = function(a, b, c, d) {
    this.r = a, this.g = b, this.b = c, this.a = d
}, cc.HSV = function(a, b, c) {
    this.h = a, this.s = b, this.v = c
}, cc.ControlUtils = {}, cc.ControlUtils.addSpriteToTargetWithPosAndAnchor = function(a, b, c, d) {
    var e = new cc.Sprite("#" + a);
    return e ? (e.setPosition(c), e.setAnchorPoint(d), b.addChild(e), e) : null
}, cc.ControlUtils.HSVfromRGB = function(a) {
    var b, c, d, e = new cc.HSV;
    return b = a.r < a.g ? a.r : a.g, b = b < a.b ? b : a.b, c = a.r > a.g ? a.r : a.g, c = c > a.b ? c : a.b, e.v = c, d = c - b, c > 0 ? (e.s = d / c, e.h = a.r >= c ? (a.g - a.b) / d : a.g >= c ? 2 + (a.b - a.r) / d : 4 + (a.r - a.g) / d, e.h *= 60, e.h < 0 && (e.h += 360), e) : (e.s = 0, e.h = -1, e)
}, cc.ControlUtils.RGBfromHSV = function(a) {
    var b, c, d, e, f, g, h = new cc.RGBA;
    if (h.a = 1, a.s <= 0) return a.h ? (h.r = 0, h.g = 0, h.b = 0, h) : (h.r = a.v, h.g = a.v, h.b = a.v, h);
    switch (b = a.h, b >= 360 && (b = 0), b /= 60, g = 0 | b, f = b - g, c = a.v * (1 - a.s), d = a.v * (1 - a.s * f), e = a.v * (1 - a.s * (1 - f)), g) {
        case 0:
            h.r = a.v, h.g = e, h.b = c;
            break;
        case 1:
            h.r = d, h.g = a.v, h.b = c;
            break;
        case 2:
            h.r = c, h.g = a.v, h.b = e;
            break;
        case 3:
            h.r = c, h.g = d, h.b = a.v;
            break;
        case 4:
            h.r = e, h.g = c, h.b = a.v;
            break;
        default:
            h.r = a.v, h.g = c, h.b = d
    }
    return h
}, cc.ControlUtils.CCRectUnion = function(a, b) {
    return cc.rectUnion(a, b)
}, cc.Invocation = cc.Class.extend({
    _action: null,
    _target: null,
    _controlEvent: null,
    ctor: function(a, b, c) {
        this._target = a, this._action = b, this._controlEvent = c
    },
    getAction: function() {
        return this._action
    },
    getTarget: function() {
        return this._target
    },
    getControlEvent: function() {
        return this._controlEvent
    },
    invoke: function(a) {
        this._target && this._action && (cc.isString(this._action) ? this._target[this._action](a, this._controlEvent) : this._action.call(this._target, a, this._controlEvent))
    }
}), cc.Scale9Sprite = cc.Node.extend({
    _spriteRect: null,
    _capInsetsInternal: null,
    _positionsAreDirty: !1,
    _scale9Image: null,
    _topLeft: null,
    _top: null,
    _topRight: null,
    _left: null,
    _centre: null,
    _right: null,
    _bottomLeft: null,
    _bottom: null,
    _bottomRight: null,
    _scale9Dirty: !0,
    _opacityModifyRGB: !1,
    _originalSize: null,
    _preferredSize: null,
    _capInsets: null,
    _insetLeft: 0,
    _insetTop: 0,
    _insetRight: 0,
    _insetBottom: 0,
    _spritesGenerated: !1,
    _spriteFrameRotated: !1,
    _textureLoaded: !1,
    _className: "Scale9Sprite",
    textureLoaded: function() {
        return this._textureLoaded
    },
    addLoadedEventListener: function(a, b) {
        this.addEventListener("load", a, b)
    },
    _updateCapInset: function() {
        var a, b = this._insetLeft,
            c = this._insetTop,
            d = this._insetRight,
            e = this._spriteRect,
            f = this._insetBottom;
        a = 0 === b && 0 === c && 0 === d && 0 === f ? cc.rect(0, 0, 0, 0) : this._spriteFrameRotated ? cc.rect(f, b, e.width - d - b, e.height - c - f) : cc.rect(b, c, e.width - b - d, e.height - c - f), this.setCapInsets(a)
    },
    _updatePositions: function() {
        if (this._topLeft && this._topRight && this._bottomRight && this._bottomLeft && this._centre) {
            var a = this._contentSize,
                b = this._topLeft,
                c = this._topRight,
                d = this._bottomRight,
                e = this._bottomLeft,
                f = this._centre,
                g = this._centre.getContentSize(),
                h = b.getContentSize(),
                i = e.getContentSize(),
                j = a.width - h.width - c.getContentSize().width,
                k = a.height - h.height - d.getContentSize().height,
                l = this._renderCmd._computeSpriteScale(j, k, g.width, g.height);
            f.setScaleX(l.horizontalScale), f.setScaleY(l.verticalScale);
            var m = i.width,
                n = i.height,
                o = this._left,
                p = this._right,
                q = this._top,
                r = this._bottom,
                s = cc.p(0, 0);
            e.setAnchorPoint(s), d.setAnchorPoint(s), b.setAnchorPoint(s), c.setAnchorPoint(s), o.setAnchorPoint(s), p.setAnchorPoint(s), q.setAnchorPoint(s), r.setAnchorPoint(s), f.setAnchorPoint(s), e.setPosition(0, 0), d.setPosition(m + l.rescaledWidth, 0), b.setPosition(0, n + l.rescaledHeight), c.setPosition(m + l.rescaledWidth, n + l.rescaledHeight), o.setPosition(0, n), o.setScaleY(l.verticalScale), p.setPosition(m + l.rescaledWidth, n), p.setScaleY(l.verticalScale), r.setPosition(m, 0), r.setScaleX(l.horizontalScale), q.setPosition(m, n + l.rescaledHeight), q.setScaleX(l.horizontalScale), f.setPosition(m, n)
        }
    },
    ctor: function(a, b, c) {
        if (cc.Node.prototype.ctor.call(this), this._spriteRect = cc.rect(0, 0, 0, 0), this._capInsetsInternal = cc.rect(0, 0, 0, 0), this._originalSize = cc.size(0, 0), this._preferredSize = cc.size(0, 0), this._capInsets = cc.rect(0, 0, 0, 0), void 0 != a)
            if (a instanceof cc.SpriteFrame) this.initWithSpriteFrame(a, b);
            else {
                var d = cc.spriteFrameCache.getSpriteFrame(a);
                null != d ? this.initWithSpriteFrame(d, b) : this.initWithFile(a, b, c)
            } else this.init()
    },
    getOriginalSize: function() {
        return cc.size(this._originalSize)
    },
    getSprite: function() {
        return this._scale9Image
    },
    getPreferredSize: function() {
        return cc.size(this._preferredSize)
    },
    _getPreferredWidth: function() {
        return this._preferredSize.width
    },
    _getPreferredHeight: function() {
        return this._preferredSize.height
    },
    setPreferredSize: function(a) {
        this.setContentSize(a), this._preferredSize = a, this._positionsAreDirty && (this._updatePositions(), this._positionsAreDirty = !1, this._scale9Dirty = !0)
    },
    _setPreferredWidth: function(a) {
        this._setWidth(a), this._preferredSize.width = a
    },
    _setPreferredHeight: function(a) {
        this._setHeight(a), this._preferredSize.height = a
    },
    setOpacity: function(a) {
        if (this._scale9Image) {
            cc.Node.prototype.setOpacity.call(this, a);
            for (var b = this._scale9Image.getChildren(), c = 0; c < b.length; c++) {
                var d = b[c];
                d && d.setOpacity(a)
            }
            this._scale9Dirty = !0
        }
    },
    setColor: function(a) {
        if (this._scale9Image) {
            cc.Node.prototype.setColor.call(this, a);
            for (var b = this._scale9Image.getChildren(), c = 0; c < b.length; c++) {
                var d = b[c];
                d && d.setColor(a)
            }
            this._scale9Dirty = !0
        }
    },
    getCapInsets: function() {
        return cc.rect(this._capInsets)
    },
    setCapInsets: function(a) {
        if (this._scale9Image) {
            var b = this._contentSize,
                c = b.width,
                d = b.height;
            this.updateWithBatchNode(this._scale9Image, this._spriteRect, this._spriteFrameRotated, a), this.setContentSize(c, d)
        }
    },
    getInsetLeft: function() {
        return this._insetLeft
    },
    setInsetLeft: function(a) {
        this._insetLeft = a, this._updateCapInset()
    },
    getInsetTop: function() {
        return this._insetTop
    },
    setInsetTop: function(a) {
        this._insetTop = a, this._updateCapInset()
    },
    getInsetRight: function() {
        return this._insetRight
    },
    setInsetRight: function(a) {
        this._insetRight = a, this._updateCapInset()
    },
    getInsetBottom: function() {
        return this._insetBottom
    },
    setInsetBottom: function(a) {
        this._insetBottom = a, this._updateCapInset()
    },
    setContentSize: function(a, b) {
        cc.Node.prototype.setContentSize.call(this, a, b), this._positionsAreDirty = !0
    },
    _setWidth: function(a) {
        cc.Node.prototype._setWidth.call(this, a), this._positionsAreDirty = !0
    },
    _setHeight: function(a) {
        cc.Node.prototype._setHeight.call(this, a), this._positionsAreDirty = !0
    },
    init: function() {
        return this.initWithBatchNode(null, cc.rect(0, 0, 0, 0), !1, cc.rect(0, 0, 0, 0))
    },
    initWithBatchNode: function(a, b, c, d) {
        return void 0 === d && (d = c, c = !1), a && this.updateWithBatchNode(a, b, c, d), this.setCascadeColorEnabled(!0), this.setCascadeOpacityEnabled(!0), this.setAnchorPoint(.5, .5), this._positionsAreDirty = !0, !0
    },
    initWithFile: function(a, b, c) {
        if (a instanceof cc.Rect ? (a = arguments[1], c = arguments[0], b = cc.rect(0, 0, 0, 0)) : (b = b || cc.rect(0, 0, 0, 0), c = c || cc.rect(0, 0, 0, 0)), !a) throw "cc.Scale9Sprite.initWithFile(): file should be non-null";
        var d = cc.textureCache.getTextureForKey(a);
        d || (d = cc.textureCache.addImage(a));
        var e = d.isLoaded();
        return this._textureLoaded = e, e || d.addEventListener("load", function(a) {
            var b = this._preferredSize;
            b = cc.size(b.width, b.height);
            var c = a.getContentSize();
            this.updateWithBatchNode(this._scale9Image, cc.rect(0, 0, c.width, c.height), !1, this._capInsets), this.setPreferredSize(b), this._positionsAreDirty = !0, this.dispatchEvent("load")
        }, this), this.initWithBatchNode(new cc.SpriteBatchNode(a, 9), b, !1, c)
    },
    initWithSpriteFrame: function(a, b) {
        if (!a || !a.getTexture()) throw "cc.Scale9Sprite.initWithSpriteFrame(): spriteFrame should be non-null and its texture should be non-null";
        b = b || cc.rect(0, 0, 0, 0);
        var c = a.textureLoaded();
        this._textureLoaded = c, c || a.addEventListener("load", function(a) {
            var b = this._preferredSize;
            b = cc.size(b.width, b.height), this.updateWithBatchNode(this._scale9Image, a.getRect(), cc._renderType == cc._RENDER_TYPE_WEBGL && a.isRotated(), this._capInsets), this.setPreferredSize(b), this._positionsAreDirty = !0, this.dispatchEvent("load")
        }, this);
        var d = new cc.SpriteBatchNode(a.getTexture(), 9);
        return this.initWithBatchNode(d, a.getRect(), cc._renderType == cc._RENDER_TYPE_WEBGL && a.isRotated(), b)
    },
    initWithSpriteFrameName: function(a, b) {
        if (!a) throw "cc.Scale9Sprite.initWithSpriteFrameName(): spriteFrameName should be non-null";
        b = b || cc.rect(0, 0, 0, 0);
        var c = cc.spriteFrameCache.getSpriteFrame(a);
        return null == c ? (cc.log("cc.Scale9Sprite.initWithSpriteFrameName(): can't find the sprite frame by spriteFrameName"), !1) : this.initWithSpriteFrame(c, b)
    },
    resizableSpriteWithCapInsets: function(a) {
        var b = new cc.Scale9Sprite;
        return b && b.initWithBatchNode(this._scale9Image, this._spriteRect, !1, a) ? b : null
    },
    setOpacityModifyRGB: function(a) {
        if (this._scale9Image) {
            this._opacityModifyRGB = a;
            var b = this._scale9Image.getChildren();
            if (b)
                for (var c = 0, d = b.length; d > c; c++) b[c].setOpacityModifyRGB(a)
        }
    },
    isOpacityModifyRGB: function() {
        return this._opacityModifyRGB
    },
    updateWithBatchNode: function(a, b, c, d) {
        var e = this.getOpacity(),
            f = this.getColor(),
            g = cc.rect(b.x, b.y, b.width, b.height);
        if (this.removeAllChildren(!0), this._scale9Image != a && (this._scale9Image = a), !this._scale9Image) return !1;
        var h = a.getTexture(),
            i = h.isLoaded();
        if (this._textureLoaded = i, !i) return h.addEventListener("load", function() {
            this._positionsAreDirty = !0, this.dispatchEvent("load")
        }, this), !0;
        var j = this._scale9Image;
        j.removeAllChildren(!0);
        var k = this._capInsets;
        k.x = d.x, k.y = d.y, k.width = d.width, k.height = d.height, this._spriteFrameRotated = c;
        var l = j.getTexture();
        if (cc._rectEqualToZero(g)) {
            var m = l.getContentSize();
            g = cc.rect(0, 0, m.width, m.height)
        }
        var n = this._spriteRect;
        n.x = g.x, n.y = g.y, n.width = g.width, n.height = g.height, this._originalSize.width = g.width, this._originalSize.height = g.height;
        var o = this._preferredSize;
        0 === o.width && 0 === o.height && (o.width = g.width, o.height = g.height);
        var p = this._capInsetsInternal;
        d && (p.x = d.x, p.y = d.y, p.width = d.width, p.height = d.height);
        var q = g.width,
            r = g.height;
        cc._rectEqualToZero(p) && (p.x = q / 3, p.y = r / 3, p.width = q / 3, p.height = r / 3);
        var s = p.x,
            t = p.width,
            u = q - (s + t),
            v = p.y,
            w = p.height,
            x = r - (v + w),
            y = 0,
            z = 0,
            A = cc.rect(y + .5 | 0, z + .5 | 0, s + .5 | 0, v + .5 | 0);
        y += s;
        var B = cc.rect(y + .5 | 0, z + .5 | 0, t + .5 | 0, v + .5 | 0);
        y += t;
        var C = cc.rect(y + .5 | 0, z + .5 | 0, u + .5 | 0, v + .5 | 0);
        y = 0, z = 0, z += v;
        var D = cc.rect(y + .5 | 0, z + .5 | 0, s + .5 | 0, w + .5 | 0);
        y += s;
        var E = cc.rect(y + .5 | 0, z + .5 | 0, t + .5 | 0, w + .5 | 0);
        y += t;
        var F = cc.rect(y + .5 | 0, z + .5 | 0, u + .5 | 0, w + .5 | 0);
        y = 0, z = 0, z += v, z += w;
        var G = cc.rect(y + .5 | 0, z + .5 | 0, s + .5 | 0, x + .5 | 0);
        y += s;
        var H = cc.rect(y + .5 | 0, z + .5 | 0, t + .5 | 0, x + .5 | 0);
        y += t;
        var I = cc.rect(y + .5 | 0, z + .5 | 0, u + .5 | 0, x + .5 | 0),
            J = cc.affineTransformMakeIdentity();
        if (c) {
            var K = E,
                L = I,
                M = G,
                N = C,
                O = A,
                P = F,
                Q = D,
                R = H,
                S = B;
            J = cc.affineTransformTranslate(J, g.height + g.x, g.y), J = cc.affineTransformRotate(J, 1.57079633), E = cc.rectApplyAffineTransform(E, J), I = cc.rectApplyAffineTransform(I, J), G = cc.rectApplyAffineTransform(G, J), C = cc.rectApplyAffineTransform(C, J), A = cc.rectApplyAffineTransform(A, J), F = cc.rectApplyAffineTransform(F, J), D = cc.rectApplyAffineTransform(D, J), H = cc.rectApplyAffineTransform(H, J), B = cc.rectApplyAffineTransform(B, J), K.x = E.x, K.y = E.y, L.x = I.x, L.y = I.y, M.x = G.x, M.y = G.y, N.x = C.x, N.y = C.y, O.x = A.x, O.y = A.y, P.x = F.x, P.y = F.y, Q.x = D.x, Q.y = D.y, R.x = H.x, R.y = H.y, S.x = B.x, S.y = B.y, this._centre = new cc.Sprite, this._centre.initWithTexture(l, K, !0), j.addChild(this._centre, 0, cc.Scale9Sprite.POSITIONS_CENTRE), this._top = new cc.Sprite, this._top.initWithTexture(l, S, !0), j.addChild(this._top, 1, cc.Scale9Sprite.POSITIONS_TOP), this._bottom = new cc.Sprite, this._bottom.initWithTexture(l, R, !0), j.addChild(this._bottom, 1, cc.Scale9Sprite.POSITIONS_BOTTOM), this._left = new cc.Sprite, this._left.initWithTexture(l, Q, !0), j.addChild(this._left, 1, cc.Scale9Sprite.POSITIONS_LEFT), this._right = new cc.Sprite, this._right.initWithTexture(l, P, !0), j.addChild(this._right, 1, cc.Scale9Sprite.POSITIONS_RIGHT), this._topLeft = new cc.Sprite, this._topLeft.initWithTexture(l, O, !0), j.addChild(this._topLeft, 2, cc.Scale9Sprite.POSITIONS_TOPLEFT), this._topRight = new cc.Sprite, this._topRight.initWithTexture(l, N, !0), j.addChild(this._topRight, 2, cc.Scale9Sprite.POSITIONS_TOPRIGHT), this._bottomLeft = new cc.Sprite, this._bottomLeft.initWithTexture(l, M, !0), j.addChild(this._bottomLeft, 2, cc.Scale9Sprite.POSITIONS_BOTTOMLEFT), this._bottomRight = new cc.Sprite, this._bottomRight.initWithTexture(l, L, !0), j.addChild(this._bottomRight, 2, cc.Scale9Sprite.POSITIONS_BOTTOMRIGHT)
        } else J = cc.affineTransformTranslate(J, g.x, g.y), cc._rectApplyAffineTransformIn(E, J), cc._rectApplyAffineTransformIn(I, J), cc._rectApplyAffineTransformIn(G, J), cc._rectApplyAffineTransformIn(C, J), cc._rectApplyAffineTransformIn(A, J), cc._rectApplyAffineTransformIn(F, J), cc._rectApplyAffineTransformIn(D, J), cc._rectApplyAffineTransformIn(H, J), cc._rectApplyAffineTransformIn(B, J), this._centre = new cc.Sprite, this._centre.initWithTexture(l, E), j.addChild(this._centre, 0, cc.Scale9Sprite.POSITIONS_CENTRE), this._top = new cc.Sprite, this._top.initWithTexture(l, B), j.addChild(this._top, 1, cc.Scale9Sprite.POSITIONS_TOP), this._bottom = new cc.Sprite, this._bottom.initWithTexture(l, H), j.addChild(this._bottom, 1, cc.Scale9Sprite.POSITIONS_BOTTOM), this._left = new cc.Sprite, this._left.initWithTexture(l, D), j.addChild(this._left, 1, cc.Scale9Sprite.POSITIONS_LEFT), this._right = new cc.Sprite, this._right.initWithTexture(l, F), j.addChild(this._right, 1, cc.Scale9Sprite.POSITIONS_RIGHT), this._topLeft = new cc.Sprite, this._topLeft.initWithTexture(l, A), j.addChild(this._topLeft, 2, cc.Scale9Sprite.POSITIONS_TOPLEFT), this._topRight = new cc.Sprite, this._topRight.initWithTexture(l, C), j.addChild(this._topRight, 2, cc.Scale9Sprite.POSITIONS_TOPRIGHT), this._bottomLeft = new cc.Sprite, this._bottomLeft.initWithTexture(l, G), j.addChild(this._bottomLeft, 2, cc.Scale9Sprite.POSITIONS_BOTTOMLEFT), this._bottomRight = new cc.Sprite, this._bottomRight.initWithTexture(l, I), j.addChild(this._bottomRight, 2, cc.Scale9Sprite.POSITIONS_BOTTOMRIGHT);
        return this.setContentSize(g.width, g.height), this._renderCmd.addBatchNodeToChildren(j), this._spritesGenerated && (this.setOpacity(e), this.setColor(f)), this._spritesGenerated = !0, !0
    },
    setSpriteFrame: function(a) {
        var b = new cc.SpriteBatchNode(a.getTexture(), 9),
            c = a.textureLoaded();
        this._textureLoaded = c, c || a.addEventListener("load", function(a) {
            var b = this._preferredSize;
            b = cc.size(b.width, b.height), this.updateWithBatchNode(this._scale9Image, a.getRect(), cc._renderType == cc._RENDER_TYPE_WEBGL && a.isRotated(), this._capInsets), this.setPreferredSize(b), this._positionsAreDirty = !0, this.dispatchEvent("load")
        }, this), this.updateWithBatchNode(b, a.getRect(), cc._renderType == cc._RENDER_TYPE_WEBGL && a.isRotated(), cc.rect(0, 0, 0, 0)), this._insetLeft = 0, this._insetTop = 0, this._insetRight = 0, this._insetBottom = 0
    },
    _createRenderCmd: function() {
        return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.Scale9Sprite.CanvasRenderCmd(this) : new cc.Scale9Sprite.WebGLRenderCmd(this)
    }
});
var _p = cc.Scale9Sprite.prototype;
cc.EventHelper.prototype.apply(_p), _p.preferredSize, cc.defineGetterSetter(_p, "preferredSize", _p.getPreferredSize, _p.setPreferredSize), _p.capInsets, cc.defineGetterSetter(_p, "capInsets", _p.getCapInsets, _p.setCapInsets), _p.insetLeft, cc.defineGetterSetter(_p, "insetLeft", _p.getInsetLeft, _p.setInsetLeft), _p.insetTop, cc.defineGetterSetter(_p, "insetTop", _p.getInsetTop, _p.setInsetTop), _p.insetRight, cc.defineGetterSetter(_p, "insetRight", _p.getInsetRight, _p.setInsetRight), _p.insetBottom, cc.defineGetterSetter(_p, "insetBottom", _p.getInsetBottom, _p.setInsetBottom), _p = null, cc.Scale9Sprite.create = function(a, b, c) {
        return new cc.Scale9Sprite(a, b, c)
    }, cc.Scale9Sprite.createWithSpriteFrame = function(a, b) {
        return new cc.Scale9Sprite(a, b)
    }, cc.Scale9Sprite.createWithSpriteFrameName = function(a, b) {
        return new cc.Scale9Sprite(a, b)
    }, cc.Scale9Sprite.POSITIONS_CENTRE = 0, cc.Scale9Sprite.POSITIONS_TOP = 1, cc.Scale9Sprite.POSITIONS_LEFT = 2, cc.Scale9Sprite.POSITIONS_RIGHT = 3, cc.Scale9Sprite.POSITIONS_BOTTOM = 4, cc.Scale9Sprite.POSITIONS_TOPRIGHT = 5, cc.Scale9Sprite.POSITIONS_TOPLEFT = 6, cc.Scale9Sprite.POSITIONS_BOTTOMRIGHT = 7,
    function() {
        cc.Scale9Sprite.CanvasRenderCmd = function(a) {
            cc.Node.CanvasRenderCmd.call(this, a), this._cachedParent = null, this._cacheDirty = !1;
            var b = this._node,
                c = this._cacheCanvas = cc.newElement("canvas");
            c.width = 1, c.height = 1, this._cacheContext = new cc.CanvasContextWrapper(c.getContext("2d"));
            var d = this._cacheTexture = new cc.Texture2D;
            d.initWithElement(c), d.handleLoadedTexture(), this._cacheSprite = new cc.Sprite(d), this._cacheSprite.setAnchorPoint(0, 0), b.addChild(this._cacheSprite)
        };
        var a = cc.Scale9Sprite.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
        a.constructor = cc.Scale9Sprite.CanvasRenderCmd, a.addBatchNodeToChildren = function() {}, a._computeSpriteScale = function(a, b, c, d) {
            var e = a / c,
                f = b / d;
            return {
                horizontalScale: e,
                verticalScale: f,
                rescaledWidth: c * e,
                rescaledHeight: d * f
            }
        }, a.visit = function(a) {
            var b = this._node;
            b._visible && (b._positionsAreDirty && (b._updatePositions(), b._positionsAreDirty = !1, b._scale9Dirty = !0), b._scale9Dirty = !1, this._cacheScale9Sprite(), cc.Node.CanvasRenderCmd.prototype.visit.call(this, a))
        }, a._updateDisplayColor = function(a) {
            cc.Node.CanvasRenderCmd.prototype._updateDisplayColor.call(this, a);
            var b = this._node._scale9Image;
            if (b) {
                for (var c = b.getChildren(), d = 0; d < c.length; d++) {
                    var e = c[d];
                    e && e._renderCmd._updateDisplayColor(a)
                }
                this._cacheScale9Sprite()
            }
        }, a.transform = function(a) {
            var b = this._node;
            this._cacheScale9Sprite(), cc.Node.CanvasRenderCmd.prototype.transform.call(this, a);
            for (var c = b._children, d = 0; d < c.length; d++) c[d]._renderCmd.transform(this)
        }, a._cacheScale9Sprite = function() {
            var a = this._node;
            if (a._scale9Image) {
                var b = cc.contentScaleFactor(),
                    c = a._contentSize,
                    d = cc.size(c.width * b, c.height * b),
                    e = this._cacheCanvas,
                    f = this._cacheContext,
                    g = f.getContext(),
                    h = !1;
                (e.width != d.width || e.height != d.height) && (e.width = d.width, e.height = d.height, h = !0), cc.renderer._turnToCacheMode(a.__instanceId), a._scale9Image.visit(), g.setTransform(1, 0, 0, 1, 0, 0), g.clearRect(0, 0, d.width, d.height), cc.renderer._renderingToCacheCanvas(f, a.__instanceId, b, b), h && this._cacheSprite.setTextureRect(cc.rect(0, 0, c.width, c.height)), this._cacheSprite.getParent() || a.addChild(this._cacheSprite, -1)
            }
        }
    }(), cc.Spacer = cc.Layer.extend({}), cc.Spacer.verticalSpacer = function(a) {
        var b = new cc.Spacer;
        return b.init(), b.setContentSize(0, a), b
    }, cc.Spacer.horizontalSpacer = function(a) {
        var b = new cc.Spacer;
        return b.init(), b.setContentSize(a, 0), b
    }, cc.MenuPassive = cc.Layer.extend({
        _color: null,
        _opacity: 0,
        _className: "MenuPassive",
        ctor: function() {},
        getColor: function() {
            var a = this._color;
            return cc.color(a.r, a.g, a.b, a.a)
        },
        setColor: function(a) {
            var b = this._color;
            if (b.r = a.r, b.g = a.g, b.b = a.b, this._children && this._children.length > 0)
                for (var c = 0; c < this._children.length; c++) this._children[c] && this._children[c].setColor(a);
            void 0 === a.a || a.a_undefined || this.setOpacity(a.a)
        },
        getOpacity: function() {
            return this._opacity
        },
        setOpacity: function(a) {
            if (this._opacity = a, this._children && this._children.length > 0)
                for (var b = 0; b < this._children.length; b++) this._children[b] && this._children[b].setOpacity(a);
            this._color.a = a
        },
        initWithItems: function(a, b) {
            if (this.init()) {
                var c = cc.director.getWinSize();
                this.ignoreAnchorPointForPosition(!0), this.setAnchorPoint(.5, .5), this.setContentSize(c), this.setPosition(c.width / 2, c.height / 2);
                var d = 0;
                if (a) {
                    this.addChild(a, d);
                    for (var e = 0; e < b.length; e++) b[e] && (d++, this.addChild(b[e], d))
                }
                return !0
            }
            return !1
        },
        alignItemsVertically: function() {
            this.alignItemsVerticallyWithPadding(cc.DEFAULT_PADDING)
        },
        alignItemsVerticallyWithPadding: function(a) {
            var b, c = -a;
            if (this._children && this._children.length > 0)
                for (b = 0; b < this._children.length; b++) this._children[b] && (c += this._children[b].getContentSize().height * this._children[b].getScaleY() + a);
            var d = 0,
                e = c / 2;
            if (this._children && this._children.length > 0)
                for (b = 0; b < this._children.length; b++) this._children[b] && (d = Math.max(d, this._children[b].getContentSize().width), this._children[b].setPosition(0, e - this._children[b].getContentSize().height * this._children[b].getScaleY() / 2), e -= this._children[b].getContentSize().height * this._children[b].getScaleY() + a);
            this.setContentSize(d, c)
        },
        alignItemsHorizontally: function() {
            this.alignItemsHorizontallyWithPadding(cc.DEFAULT_PADDING)
        },
        alignItemsHorizontallyWithPadding: function(a) {
            var b, c = -a;
            if (this._children && this._children.length > 0)
                for (b = 0; b < this._children.length; b++) this._children[b] && (c += this._children[b].getContentSize().width * this._children[b].getScaleX() + a);
            var d = 0,
                e = -c / 2;
            if (this._children && this._children.length > 0)
                for (b = 0; b < this._children.length; b++) this._children[b] && (d = Math.max(d, this._children[b].getContentSize().height), this._children[b].setPosition(e + this._children[b].getContentSize().width * this._children[b].getScaleX() / 2, 0), e += this._children[b].getContentSize().width * this._children[b].getScaleX() + a);
            this.setContentSize(c, d)
        },
        alignItemsInColumns: function() {
            var a, b = [];
            for (a = 1; a < arguments.length; a++) b.push(arguments[a]);
            var c, d, e = -5,
                f = 0,
                g = 0,
                h = 0;
            if (this._children && this._children.length > 0)
                for (a = 0; a < this._children.length; a++)
                    if (this._children[a]) {
                        if (f >= b.length) {
                            cc.log("cc.MenuPassive.alignItemsInColumns(): invalid row index");
                            continue
                        }
                        if (c = b[f], !c) {
                            cc.log("cc.MenuPassive.alignItemsInColumns(): can not have zero columns on a row");
                            continue
                        }
                        d = this._children[a].getContentSize().height, g = 0 | (g >= d || null == d ? g : d), ++h, h >= c && (e += g + 5, h = 0, g = 0, ++f)
                    }
            var i = cc.director.getWinSize();
            f = 0, g = 0, c = 0;
            var j = 0,
                k = 0,
                l = e / 2;
            if (this._children && this._children.length > 0)
                for (a = 0; a < this._children.length; a++) this._children[a] && (0 == c && (c = b[f], j = i.width / (1 + c), k = j), d = this._children[a].getContentSize().height, g = 0 | (g >= d || null == d ? g : d), this._children[a].setPosition(k - i.width / 2, l - this._children[a].getContentSize().height / 2), k += j, ++h, h >= c && (l -= g + 5, h = 0, c = 0, g = 0, ++f))
        },
        alignItemsInRows: function() {
            var a, b = [];
            for (a = 1; a < arguments.length; a++) b.push(arguments[a]);
            var c, d, e = [],
                f = [],
                g = -10,
                h = -5,
                i = 0,
                j = 0,
                k = 0;
            if (this._children && this._children.length > 0)
                for (a = 0; a < this._children.length; a++)
                    if (this._children[a]) {
                        if (i >= b.length) {
                            cc.log("cc.MenuPassive.alignItemsInRows(): invalid row index");
                            continue
                        }
                        if (c = b[i], !c) {
                            cc.log("cc.MenuPassive.alignItemsInColumns(): can't have zero rows on a column");
                            continue
                        }
                        d = this._children[a].getContentSize().width, j = 0 | (j >= d || null == d ? j : d), h += 0 | this._children[a].getContentSize().height + 5, ++k, k >= c && (e.push(j), f.push(h), g += j + 10, k = 0, j = 0, h = -5, ++i)
                    }
            var l = cc.director.getWinSize();
            i = 0, j = 0, c = null;
            var m = -g / 2,
                n = 0;
            if (this._children && this._children.length > 0)
                for (a = 0; a < this._children.length; a++) this._children[a] && (null == c && (c = b[i], n = f[i]), d = this._children[a].getContentSize().width, j = 0 | (j >= d || null == d ? j : d), this._children[a].setPosition(m + e[i] / 2, n - l.height / 2), n -= this._children[a].getContentSize().height + 10, ++k, k >= c && (m += j + 5, k = 0, c = 0, j = 0, ++i))
        },
        setOpacityModifyRGB: function() {},
        isOpacityModifyRGB: function() {
            return !1
        }
    }), cc.MenuPassive.create = function(a) {
        a || (a = null);
        for (var b = [], c = 1; c < arguments.length; c++) b.push(arguments[c]);
        var d = new cc.MenuPassive;
        return d && d.initWithItems(a, b) ? d : null
    }, cc.MenuPassive.createWithItem = function(a) {
        return cc.MenuPassive.create(a, null)
    }, cc.ControlSaturationBrightnessPicker = cc.Control.extend({
        _saturation: 0,
        _brightness: 0,
        _background: null,
        _overlay: null,
        _shadow: null,
        _slider: null,
        _startPos: null,
        _boxPos: 0,
        _boxSize: 0,
        _className: "ControlSaturationBrightnessPicker",
        ctor: function(a, b) {
            cc.Control.prototype.ctor.call(this), b && this.initWithTargetAndPos(a, b)
        },
        getSaturation: function() {
            return this._saturation
        },
        getBrightness: function() {
            return this._brightness
        },
        getBackground: function() {
            return this._background
        },
        getOverlay: function() {
            return this._brightness
        },
        getShadow: function() {
            return this._shadow
        },
        getSlider: function() {
            return this._slider
        },
        getStartPos: function() {
            return this._startPos
        },
        initWithTargetAndPos: function(a, b) {
            return cc.Control.prototype.init.call(this) ? (this._background = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("colourPickerBackground.png", a, b, cc.p(0, 0)), this._overlay = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("colourPickerOverlay.png", a, b, cc.p(0, 0)), this._shadow = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("colourPickerShadow.png", a, b, cc.p(0, 0)), this._slider = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("colourPicker.png", a, b, cc.p(.5, .5)), this._startPos = b, this._boxPos = 35, this._boxSize = this._background.getContentSize().width / 2, !0) : !1
        },
        setEnabled: function(a) {
            cc.Control.prototype.setEnabled.call(this, a), this._slider && this._slider.setOpacity(a ? 255 : 128)
        },
        updateWithHSV: function(a) {
            var b = new cc.HSV;
            b.s = 1, b.h = a.h, b.v = 1;
            var c = cc.ControlUtils.RGBfromHSV(b);
            this._background.setColor(cc.color(0 | 255 * c.r, 0 | 255 * c.g, 0 | 255 * c.b))
        },
        updateDraggerWithHSV: function(a) {
            var b = cc.p(this._startPos.x + this._boxPos + this._boxSize * (1 - a.s), this._startPos.y + this._boxPos + this._boxSize * a.v);
            this._updateSliderPosition(b)
        },
        _updateSliderPosition: function(a) {
            var b = this._startPos.x + .5 * this._background.getBoundingBox().width,
                c = this._startPos.y + .5 * this._background.getBoundingBox().height,
                d = a.x - b,
                e = a.y - c,
                f = Math.sqrt(d * d + e * e),
                g = Math.atan2(e, d),
                h = .5 * this._background.getBoundingBox().width;
            f > h && (a.x = b + h * Math.cos(g), a.y = c + h * Math.sin(g)), this._slider.setPosition(a), a.x < this._startPos.x + this._boxPos ? a.x = this._startPos.x + this._boxPos : a.x > this._startPos.x + this._boxPos + this._boxSize - 1 && (a.x = this._startPos.x + this._boxPos + this._boxSize - 1), a.y < this._startPos.y + this._boxPos ? a.y = this._startPos.y + this._boxPos : a.y > this._startPos.y + this._boxPos + this._boxSize && (a.y = this._startPos.y + this._boxPos + this._boxSize), this._saturation = 1 - Math.abs((this._startPos.x + this._boxPos - a.x) / this._boxSize), this._brightness = Math.abs((this._startPos.y + this._boxPos - a.y) / this._boxSize)
        },
        _checkSliderPosition: function(a) {
            var b = this._startPos.x + .5 * this._background.getBoundingBox().width,
                c = this._startPos.y + .5 * this._background.getBoundingBox().height,
                d = a.x - b,
                e = a.y - c,
                f = Math.sqrt(d * d + e * e);
            return f <= .5 * this._background.getBoundingBox().width ? (this._updateSliderPosition(a), this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED), !0) : !1
        },
        onTouchBegan: function(a) {
            if (!this.isEnabled() || !this.isVisible()) return !1;
            var b = this.getTouchLocation(a);
            return this._checkSliderPosition(b)
        },
        onTouchMoved: function(a) {
            var b = this.getTouchLocation(a);
            this._checkSliderPosition(b)
        }
    });
var _p = cc.ControlSaturationBrightnessPicker.prototype;
_p.saturation, cc.defineGetterSetter(_p, "saturation", _p.getSaturation), _p.brightness, cc.defineGetterSetter(_p, "brightness", _p.getBrightness), _p.background, cc.defineGetterSetter(_p, "background", _p.getBackground), _p.overlay, cc.defineGetterSetter(_p, "overlay", _p.getOverlay), _p.shadow, cc.defineGetterSetter(_p, "shadow", _p.getShadow), _p.slider, cc.defineGetterSetter(_p, "slider", _p.getSlider), _p.startPos, cc.defineGetterSetter(_p, "startPos", _p.getStartPos), _p = null, cc.ControlSaturationBrightnessPicker.create = function(a, b) {
    return new cc.ControlSaturationBrightnessPicker(a, b)
}, cc.ControlHuePicker = cc.Control.extend({
    _hue: 0,
    _huePercentage: 0,
    _background: null,
    _slider: null,
    _startPos: null,
    _className: "ControlHuePicker",
    ctor: function(a, b) {
        cc.Control.prototype.ctor.call(this), b && this.initWithTargetAndPos(a, b)
    },
    getHue: function() {
        return this._hue
    },
    setHue: function(a) {
        this._hue = a, this.setHuePercentage(this._hue / 360)
    },
    getHuePercentage: function() {
        return this._huePercentage
    },
    setHuePercentage: function(a) {
        this._huePercentage = a, this._hue = 360 * this._huePercentage;
        var b = this._background.getBoundingBox(),
            c = this._startPos.x + .5 * b.width,
            d = this._startPos.y + .5 * b.height,
            e = .5 * b.width - 15,
            f = 360 * this._huePercentage - 180,
            g = cc.degreesToRadians(f),
            h = c + e * Math.cos(g),
            i = d + e * Math.sin(g);
        this._slider.setPosition(h, i)
    },
    setEnabled: function(a) {
        cc.Control.prototype.setEnabled.call(this, a), this._slider && this._slider.setOpacity(a ? 255 : 128)
    },
    getBackground: function() {
        return this._background
    },
    getSlider: function() {
        return this._slider
    },
    getStartPos: function() {
        return this._startPos
    },
    initWithTargetAndPos: function(a, b) {
        return cc.Control.prototype.init.call(this) ? (this._background = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("huePickerBackground.png", a, b, cc.p(0, 0)), this._slider = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("colourPicker.png", a, b, cc.p(.5, .5)), this._slider.setPosition(b.x, b.y + .5 * this._background.getBoundingBox().height), this._startPos = b, this._hue = 0, this._huePercentage = 0, !0) : !1
    },
    _updateSliderPosition: function(a) {
        var b = this._background.getBoundingBox(),
            c = this._startPos.x + .5 * b.width,
            d = this._startPos.y + .5 * b.height,
            e = a.x - c,
            f = a.y - d,
            g = Math.atan2(f, e),
            h = cc.radiansToDegrees(g) + 180;
        this.setHue(h), this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED)
    },
    _checkSliderPosition: function(a) {
        var b = Math.sqrt(Math.pow(a.x + 10, 2) + Math.pow(a.y, 2));
        return 80 > b && b > 59 ? (this._updateSliderPosition(a), !0) : !1
    },
    onTouchBegan: function(a) {
        if (!this.isEnabled() || !this.isVisible()) return !1;
        var b = this.getTouchLocation(a);
        return this._checkSliderPosition(b)
    },
    onTouchMoved: function(a) {
        var b = this.getTouchLocation(a);
        this._checkSliderPosition(b)
    }
});
var _p = cc.ControlHuePicker.prototype;
_p.hue, cc.defineGetterSetter(_p, "hue", _p.getHue, _p.setHue), _p.huePercent, cc.defineGetterSetter(_p, "huePercent", _p.getHuePercentage, _p.setHuePercentage), _p.background, cc.defineGetterSetter(_p, "background", _p.getBackground), _p.slider, cc.defineGetterSetter(_p, "slider", _p.getSlider), _p.startPos, cc.defineGetterSetter(_p, "startPos", _p.getStartPos), _p = null, cc.ControlHuePicker.create = function(a, b) {
    return new cc.ControlHuePicker(a, b)
}, cc.ControlColourPicker = cc.Control.extend({
    _hsv: null,
    _colourPicker: null,
    _huePicker: null,
    _background: null,
    _className: "ControlColourPicker",
    ctor: function() {
        cc.Control.prototype.ctor.call(this), this.init()
    },
    hueSliderValueChanged: function(a) {
        this._hsv.h = a.getHue();
        var b = cc.ControlUtils.RGBfromHSV(this._hsv);
        cc.Control.prototype.setColor.call(this, cc.color(0 | 255 * b.r, 0 | 255 * b.g, 0 | 255 * b.b)), this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED), this._updateControlPicker()
    },
    colourSliderValueChanged: function(a) {
        this._hsv.s = a.getSaturation(), this._hsv.v = a.getBrightness();
        var b = cc.ControlUtils.RGBfromHSV(this._hsv);
        cc.Control.prototype.setColor.call(this, cc.color(0 | 255 * b.r, 0 | 255 * b.g, 0 | 255 * b.b)), this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED)
    },
    setColor: function(a) {
        cc.Control.prototype.setColor.call(this, a);
        var b = new cc.RGBA;
        b.r = a.r / 255, b.g = a.g / 255, b.b = a.b / 255, b.a = 1, this._hsv = cc.ControlUtils.HSVfromRGB(b), this._updateHueAndControlPicker()
    },
    getBackground: function() {
        return this._background
    },
    init: function() {
        if (cc.Control.prototype.init.call(this)) {
            cc.spriteFrameCache.addSpriteFrames(res.CCControlColourPickerSpriteSheet_plist);
            var a = new cc.SpriteBatchNode(res.CCControlColourPickerSpriteSheet_png);
            this.addChild(a), this._hsv = new cc.HSV(0, 0, 0), this._background = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("menuColourPanelBackground.png", a, cc.p(0, 0), cc.p(.5, .5));
            var b = cc.pSub(this._background.getPosition(), cc.p(this._background.getContentSize().width / 2, this._background.getContentSize().height / 2)),
                c = 8,
                d = 28;
            return this._huePicker = new cc.ControlHuePicker(a, cc.p(b.x + c, b.y + c)), this._colourPicker = new cc.ControlSaturationBrightnessPicker(a, cc.p(b.x + d, b.y + d)), this._huePicker.addTargetWithActionForControlEvents(this, this.hueSliderValueChanged, cc.CONTROL_EVENT_VALUECHANGED), this._colourPicker.addTargetWithActionForControlEvents(this, this.colourSliderValueChanged, cc.CONTROL_EVENT_VALUECHANGED), this._updateHueAndControlPicker(), this.addChild(this._huePicker), this.addChild(this._colourPicker), this.setContentSize(this._background.getContentSize()), !0
        }
        return !1
    },
    _updateControlPicker: function() {
        this._huePicker.setHue(this._hsv.h), this._colourPicker.updateWithHSV(this._hsv)
    },
    _updateHueAndControlPicker: function() {
        this._huePicker.setHue(this._hsv.h), this._colourPicker.updateWithHSV(this._hsv), this._colourPicker.updateDraggerWithHSV(this._hsv)
    },
    setEnabled: function(a) {
        cc.Control.prototype.setEnabled.call(this, a), null != this._huePicker && this._huePicker.setEnabled(a), this._colourPicker && this._colourPicker.setEnabled(a)
    },
    onTouchBegan: function() {
        return !1
    }
});
var _p = cc.ControlColourPicker.prototype;
_p.background, cc.defineGetterSetter(_p, "background", _p.getBackground), _p = null, cc.ControlColourPicker.create = function() {
    return new cc.ControlColourPicker
};
var res = res || {};
res.CCControlColourPickerSpriteSheet_plist = res.CCControlColourPickerSpriteSheet_plist || "res/extensions/CCControlColourPickerSpriteSheet.plist", res.CCControlColourPickerSpriteSheet_png = res.CCControlColourPickerSpriteSheet_png || "res/extensions/CCControlColourPickerSpriteSheet.png", cc.SLIDER_MARGIN_H = 24, cc.SLIDER_MARGIN_V = 8, cc.ControlSlider = cc.Control.extend({
    _value: 0,
    _minimumValue: 0,
    _maximumValue: 0,
    _minimumAllowedValue: 0,
    _maximumAllowedValue: 0,
    _thumbSprite: null,
    _progressSprite: null,
    _backgroundSprite: null,
    _className: "ControlSlider",
    ctor: function(a, b, c) {
        if (cc.Control.prototype.ctor.call(this), void 0 != c) {
            var d = new cc.Sprite(a),
                e = new cc.Sprite(b),
                f = new cc.Sprite(c);
            this.initWithSprites(d, e, f)
        }
    },
    getValue: function() {
        return this._value
    },
    setValue: function(a) {
        a = Math.max(a, this._minimumValue), a = Math.min(a, this._maximumValue), this._value = a, this.needsLayout(), this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED)
    },
    getMinimumValue: function() {
        return this._minimumValue
    },
    setMinimumValue: function(a) {
        this._minimumValue = a, this._minimumAllowedValue = a, this._minimumValue >= this._maximumValue && (this._maximumValue = this._minimumValue + 1), this.setValue(this._value)
    },
    getMaximumValue: function() {
        return this._maximumValue
    },
    setMaximumValue: function(a) {
        this._maximumValue = a, this._maximumAllowedValue = a, this._maximumValue <= this._minimumValue && (this._minimumValue = this._maximumValue - 1), this.setValue(this._value)
    },
    isTouchInside: function(a) {
        var b = a.getLocation();
        b = this.getParent().convertToNodeSpace(b);
        var c = this.getBoundingBox();
        return c.width += this._thumbSprite.getContentSize().width, c.x -= this._thumbSprite.getContentSize().width / 2, cc.rectContainsPoint(c, b)
    },
    locationFromTouch: function(a) {
        var b = a.getLocation();
        return b = this.convertToNodeSpace(b), b.x < 0 ? b.x = 0 : b.x > this._backgroundSprite.getContentSize().width && (b.x = this._backgroundSprite.getContentSize().width), b
    },
    getMinimumAllowedValue: function() {
        return this._minimumAllowedValue
    },
    setMinimumAllowedValue: function(a) {
        this._minimumAllowedValue = a
    },
    getMaximumAllowedValue: function() {
        return this._maximumAllowedValue
    },
    setMaximumAllowedValue: function(a) {
        this._maximumAllowedValue = a
    },
    getThumbSprite: function() {
        return this._thumbSprite
    },
    getProgressSprite: function() {
        return this._progressSprite
    },
    getBackgroundSprite: function() {
        return this._backgroundSprite
    },
    initWithSprites: function(a, b, c) {
        if (cc.Control.prototype.init.call(this)) {
            this.ignoreAnchorPointForPosition(!1), this._backgroundSprite = a, this._progressSprite = b, this._thumbSprite = c;
            var d = cc.ControlUtils.CCRectUnion(a.getBoundingBox(), c.getBoundingBox());
            return this.setContentSize(d.width, d.height), this._backgroundSprite.setAnchorPoint(.5, .5), this._backgroundSprite.setPosition(d.width / 2, d.height / 2), this.addChild(this._backgroundSprite), this._progressSprite.setAnchorPoint(0, .5), this._progressSprite.setPosition(0, d.height / 2), this.addChild(this._progressSprite), this._thumbSprite.setPosition(0, d.height / 2), this.addChild(this._thumbSprite), this._minimumValue = 0, this._maximumValue = 1, this.setValue(this._minimumValue), !0
        }
        return !1
    },
    setEnabled: function(a) {
        cc.Control.prototype.setEnabled.call(this, a), this._thumbSprite && this._thumbSprite.setOpacity(a ? 255 : 128)
    },
    sliderBegan: function(a) {
        this.setSelected(!0), this._thumbSprite.setColor(cc.color.GRAY), this.setValue(this.valueForLocation(a))
    },
    sliderMoved: function(a) {
        this.setValue(this.valueForLocation(a))
    },
    sliderEnded: function() {
        this.isSelected() && this.setValue(this.valueForLocation(this._thumbSprite.getPosition())), this._thumbSprite.setColor(cc.color.WHITE), this.setSelected(!1)
    },
    getTouchLocationInControl: function(a) {
        var b = a.getLocation();
        return b = this.convertToNodeSpace(b), b.x < 0 ? b.x = 0 : b.x > this._backgroundSprite.getContentSize().width + cc.SLIDER_MARGIN_H && (b.x = this._backgroundSprite.getContentSize().width + cc.SLIDER_MARGIN_H), b
    },
    onTouchBegan: function(a) {
        if (!this.isTouchInside(a) || !this.isEnabled() || !this.isVisible()) return !1;
        var b = this.locationFromTouch(a);
        return this.sliderBegan(b), !0
    },
    onTouchMoved: function(a) {
        var b = this.locationFromTouch(a);
        this.sliderMoved(b)
    },
    onTouchEnded: function() {
        this.sliderEnded(cc.p(0, 0))
    },
    needsLayout: function() {
        var a = (this._value - this._minimumValue) / (this._maximumValue - this._minimumValue);
        this._thumbSprite.setPositionX(a * this._backgroundSprite.getContentSize().width);
        var b = this._progressSprite.getTextureRect();
        b = cc.rect(b.x, b.y, this._thumbSprite.getPositionX(), b.height), this._progressSprite.setTextureRect(b, this._progressSprite.isTextureRectRotated()), this._thumbSprite._renderCmd.transform(this._renderCmd)
    },
    valueForLocation: function(a) {
        var b = a.x / this._backgroundSprite.getContentSize().width;
        return Math.max(Math.min(this._minimumValue + b * (this._maximumValue - this._minimumValue), this._maximumAllowedValue), this._minimumAllowedValue)
    }
});
var _p = cc.ControlSlider.prototype;
_p.value, cc.defineGetterSetter(_p, "value", _p.getValue, _p.setValue), _p.minValue, cc.defineGetterSetter(_p, "minValue", _p.getMinimumValue, _p.setMinimumValue), _p.maxValue, cc.defineGetterSetter(_p, "maxValue", _p.getMaximumValue, _p.setMaximumValue), _p.minAllowedValue, cc.defineGetterSetter(_p, "minAllowedValue", _p.getMinimumAllowedValue, _p.setMinimumAllowedValue), _p.maxAllowedValue, cc.defineGetterSetter(_p, "maxAllowedValue", _p.getMaximumAllowedValue, _p.setMaximumAllowedValue), _p.thumbSprite, cc.defineGetterSetter(_p, "thumbSprite", _p.getThumbSprite), _p.progressSprite, cc.defineGetterSetter(_p, "progressSprite", _p.getProgressSprite), _p.backgroundSprite, cc.defineGetterSetter(_p, "backgroundSprite", _p.getBackgroundSprite), _p = null, cc.ControlSlider.create = function(a, b, c) {
    return new cc.ControlSlider(a, b, c)
}, cc.ControlSwitch = cc.Control.extend({
    _switchSprite: null,
    _initialTouchXPosition: 0,
    _moved: !1,
    _on: !1,
    _className: "ControlSwitch",
    ctor: function(a, b, c, d, e, f) {
        cc.Control.prototype.ctor.call(this), f && this.initWithMaskSprite(a, b, c, d, e, f)
    },
    initWithMaskSprite: function(a, b, c, d, e, f) {
        if (!a) throw "cc.ControlSwitch.initWithMaskSprite(): maskSprite should be non-null.";
        if (!b) throw "cc.ControlSwitch.initWithMaskSprite(): onSprite should be non-null.";
        if (!c) throw "cc.ControlSwitch.initWithMaskSprite(): offSprite should be non-null.";
        if (!d) throw "cc.ControlSwitch.initWithMaskSprite(): thumbSprite should be non-null.";
        return this.init() ? (this._on = !0, this._switchSprite = new cc.ControlSwitchSprite, this._switchSprite.initWithMaskSprite(a, b, c, d, e, f), this._switchSprite.setPosition(this._switchSprite.getContentSize().width / 2, this._switchSprite.getContentSize().height / 2), this.addChild(this._switchSprite), this.ignoreAnchorPointForPosition(!1), this.setAnchorPoint(.5, .5), this.setContentSize(this._switchSprite.getContentSize()), !0) : !1
    },
    setOn: function(a, b) {
        b = b || !1, this._on = a;
        var c = this._on ? this._switchSprite.getOnPosition() : this._switchSprite.getOffPosition();
        b ? this._switchSprite.runAction(new cc.ActionTween(.2, "sliderXPosition", this._switchSprite.getSliderXPosition(), c)) : this._switchSprite.setSliderXPosition(c), this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED)
    },
    isOn: function() {
        return this._on
    },
    hasMoved: function() {
        return this._moved
    },
    setEnabled: function(a) {
        this._enabled = a, this._switchSprite.setOpacity(a ? 255 : 128)
    },
    locationFromTouch: function(a) {
        var b = a.getLocation();
        return b = this.convertToNodeSpace(b)
    },
    onTouchBegan: function(a) {
        if (!this.isTouchInside(a) || !this.isEnabled() || !this.isVisible()) return !1;
        this._moved = !1;
        var b = this.locationFromTouch(a);
        return this._initialTouchXPosition = b.x - this._switchSprite.getSliderXPosition(), this._switchSprite.getThumbSprite().setColor(cc.color.GRAY), this._switchSprite.needsLayout(), !0
    },
    onTouchMoved: function(a) {
        var b = this.locationFromTouch(a);
        b = cc.p(b.x - this._initialTouchXPosition, 0), this._moved = !0, this._switchSprite.setSliderXPosition(b.x)
    },
    onTouchEnded: function(a) {
        var b = this.locationFromTouch(a);
        this._switchSprite.getThumbSprite().setColor(cc.color.WHITE), this.hasMoved() ? this.setOn(!(b.x < this._switchSprite.getContentSize().width / 2), !0) : this.setOn(!this._on, !0)
    },
    onTouchCancelled: function(a) {
        var b = this.locationFromTouch(a);
        this._switchSprite.getThumbSprite().setColor(cc.color.WHITE), this.hasMoved() ? this.setOn(!(b.x < this._switchSprite.getContentSize().width / 2), !0) : this.setOn(!this._on, !0)
    }
}), cc.ControlSwitch.create = function(a, b, c, d, e, f) {
    return new cc.ControlSwitch(a, b, c, d, e, f)
}, cc.ControlSwitchSprite = cc.Sprite.extend({
    _sliderXPosition: 0,
    _onPosition: 0,
    _offPosition: 0,
    _textureLocation: 0,
    _maskLocation: 0,
    _maskSize: null,
    _onSprite: null,
    _offSprite: null,
    _thumbSprite: null,
    _onLabel: null,
    _offLabel: null,
    _clipper: null,
    _stencil: null,
    _backRT: null,
    ctor: function() {
        cc.Sprite.prototype.ctor.call(this), this._sliderXPosition = 0, this._onPosition = 0, this._offPosition = 0, this._maskLocation = 0, this._maskSize = cc.size(0, 0), this._onSprite = null, this._offSprite = null, this._thumbSprite = null, this._onLabel = null, this._offLabel = null
    },
    initWithMaskSprite: function(a, b, c, d, e, f) {
        if (cc.Sprite.prototype.init.call(this)) {
            this.setSpriteFrame(a.displayFrame()), this._onPosition = 0, this._offPosition = -b.getContentSize().width + d.getContentSize().width / 2, this._sliderXPosition = this._onPosition, this.setOnSprite(b), this.setOffSprite(c), this.setThumbSprite(d), this.setOnLabel(e), this.setOffLabel(f), this._stencil = a;
            var g = this._maskSize = this._stencil.getContentSize();
            return this._stencil.setPosition(0, 0), this._clipper = new cc.ClippingNode, this._clipper.setAnchorPoint(.5, .5), this._clipper.setPosition(g.width / 2, g.height / 2), this._clipper.setStencil(this._stencil), this.addChild(this._clipper), this._clipper.addChild(b), this._clipper.addChild(c), this._clipper.addChild(e), this._clipper.addChild(f), this.addChild(this._thumbSprite), this.needsLayout(), !0
        }
        return !1
    },
    needsLayout: function() {
        var a = this._maskSize;
        this._onSprite.setPosition(this._onSprite.getContentSize().width / 2 + this._sliderXPosition - a.width / 2, this._onSprite.getContentSize().height / 2 - a.height / 2), this._offSprite.setPosition(this._onSprite.getContentSize().width + this._offSprite.getContentSize().width / 2 + this._sliderXPosition - a.width / 2, this._offSprite.getContentSize().height / 2 - a.height / 2), this._onLabel && this._onLabel.setPosition(this._onSprite.getPositionX() - this._thumbSprite.getContentSize().width / 6, this._onSprite.getContentSize().height / 2 - a.height / 2), this._offLabel && this._offLabel.setPosition(this._offSprite.getPositionX() + this._thumbSprite.getContentSize().width / 6, this._offSprite.getContentSize().height / 2 - a.height / 2), this._thumbSprite.setPosition(this._onSprite.getContentSize().width + this._sliderXPosition, this._maskSize.height / 2)
    },
    setSliderXPosition: function(a) {
        a <= this._offPosition ? a = this._offPosition : a >= this._onPosition && (a = this._onPosition), this._sliderXPosition = a, this.needsLayout()
    },
    getSliderXPosition: function() {
        return this._sliderXPosition
    },
    _getOnSideWidth: function() {
        return this._onSprite.getContentSize().width
    },
    _getOffSideWidth: function() {
        return this._offSprite.getContentSize().height
    },
    updateTweenAction: function(a, b) {
        "sliderXPosition" === b && this.setSliderXPosition(a)
    },
    setOnPosition: function(a) {
        this._onPosition = a
    },
    getOnPosition: function() {
        return this._onPosition
    },
    setOffPosition: function(a) {
        this._offPosition = a
    },
    getOffPosition: function() {
        return this._offPosition
    },
    setMaskTexture: function(a) {
        this._stencil.setTexture(a)
    },
    getMaskTexture: function() {
        return this._stencil.getTexture()
    },
    setTextureLocation: function(a) {
        this._textureLocation = a
    },
    getTextureLocation: function() {
        return this._textureLocation
    },
    setMaskLocation: function(a) {
        this._maskLocation = a
    },
    getMaskLocation: function() {
        return this._maskLocation
    },
    setOnSprite: function(a) {
        this._onSprite = a
    },
    getOnSprite: function() {
        return this._onSprite
    },
    setOffSprite: function(a) {
        this._offSprite = a
    },
    getOffSprite: function() {
        return this._offSprite
    },
    setThumbSprite: function(a) {
        this._thumbSprite = a
    },
    getThumbSprite: function() {
        return this._thumbSprite
    },
    setOnLabel: function(a) {
        this._onLabel = a
    },
    getOnLabel: function() {
        return this._onLabel
    },
    setOffLabel: function(a) {
        this._offLabel = a
    },
    getOffLabel: function() {
        return this._offLabel
    }
});
var _p = cc.ControlSwitchSprite.prototype;
_p.sliderX, cc.defineGetterSetter(_p, "sliderX", _p.getSliderXPosition, _p.setSliderXPosition), _p.onPos, cc.defineGetterSetter(_p, "onPos", _p.getOnPosition, _p.setOnPosition), _p.offPos, cc.defineGetterSetter(_p, "offPos", _p.getOffPosition, _p.setOffPosition), _p.maskTexture, cc.defineGetterSetter(_p, "maskTexture", _p.getMaskTexture, _p.setMaskTexture), _p.maskPos, cc.defineGetterSetter(_p, "maskPos", _p.getMaskLocation, _p.setMaskLocation), _p.onSprite, cc.defineGetterSetter(_p, "onSprite", _p.getOnSprite, _p.setOnSprite), _p.offSprite, cc.defineGetterSetter(_p, "offSprite", _p.getOffSprite, _p.setOffSprite), _p.thumbSprite, cc.defineGetterSetter(_p, "thumbSprite", _p.getThumbSprite, _p.setThumbSprite), _p.onLabel, cc.defineGetterSetter(_p, "onLabel", _p.getOnLabel, _p.setOnLabel), _p.offLabel, cc.defineGetterSetter(_p, "offLabel", _p.getOffLabel, _p.setOffLabel), _p.onSideWidth, cc.defineGetterSetter(_p, "onSideWidth", _p._getOnSideWidth), _p.offSideWidth, cc.defineGetterSetter(_p, "offSideWidth", _p._getOffSideWidth), _p = null, cc.CONTROL_STEPPER_PARTMINUS = 0, cc.CONTROL_STEPPER_PARTPLUS = 1, cc.CONTROL_STEPPER_PARTNONE = 2, cc.CONTROL_STEPPER_LABELCOLOR_ENABLED = cc.color(55, 55, 55), cc.CONTROL_STEPPER_LABELCOLOR_DISABLED = cc.color(147, 147, 147), cc.CONTROL_STEPPER_LABELFONT = "CourierNewPSMT", cc.AUTOREPEAT_DELTATIME = .15, cc.AUTOREPEAT_INCREASETIME_INCREMENT = 12, cc.ControlStepper = cc.Control.extend({
    _minusSprite: null,
    _plusSprite: null,
    _minusLabel: null,
    _plusLabel: null,
    _value: 0,
    _continuous: !1,
    _autorepeat: !1,
    _wraps: !1,
    _minimumValue: 0,
    _maximumValue: 0,
    _stepValue: 0,
    _touchInsideFlag: !1,
    _touchedPart: cc.CONTROL_STEPPER_PARTNONE,
    _autorepeatCount: 0,
    _className: "ControlStepper",
    ctor: function(a, b) {
        cc.Control.prototype.ctor.call(this), this._minusSprite = null, this._plusSprite = null, this._minusLabel = null, this._plusLabel = null, this._value = 0, this._continuous = !1, this._autorepeat = !1, this._wraps = !1, this._minimumValue = 0, this._maximumValue = 0, this._stepValue = 0, this._touchInsideFlag = !1, this._touchedPart = cc.CONTROL_STEPPER_PARTNONE, this._autorepeatCount = 0, b && this.initWithMinusSpriteAndPlusSprite(a, b)
    },
    initWithMinusSpriteAndPlusSprite: function(a, b) {
        if (!a) throw "cc.ControlStepper.initWithMinusSpriteAndPlusSprite(): Minus sprite should be non-null.";
        if (!b) throw "cc.ControlStepper.initWithMinusSpriteAndPlusSprite(): Plus sprite should be non-null.";
        if (this.init()) {
            this._autorepeat = !0, this._continuous = !0, this._minimumValue = 0, this._maximumValue = 100, this._value = 0, this._stepValue = 1, this._wraps = !1, this.ignoreAnchorPointForPosition(!1), this.setMinusSprite(a), this._minusSprite.setPosition(a.getContentSize().width / 2, a.getContentSize().height / 2), this.addChild(this._minusSprite), this.setMinusLabel(new cc.LabelTTF("-", cc.CONTROL_STEPPER_LABELFONT, 40, cc.size(40, 40), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER)), this._minusLabel.setColor(cc.CONTROL_STEPPER_LABELCOLOR_DISABLED), this._minusLabel.setPosition(this._minusSprite.getContentSize().width / 2, this._minusSprite.getContentSize().height / 2), this._minusSprite.addChild(this._minusLabel), this.setPlusSprite(b), this._plusSprite.setPosition(a.getContentSize().width + b.getContentSize().width / 2, a.getContentSize().height / 2), this.addChild(this._plusSprite), this.setPlusLabel(new cc.LabelTTF("+", cc.CONTROL_STEPPER_LABELFONT, 40, cc.size(40, 40), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER)), this._plusLabel.setColor(cc.CONTROL_STEPPER_LABELCOLOR_ENABLED), this._plusLabel.setPosition(this._plusSprite.getContentSize().width / 2, this._plusSprite.getContentSize().height / 2), this._plusSprite.addChild(this._plusLabel);
            var c = cc.ControlUtils.CCRectUnion(this._minusSprite.getBoundingBox(), this._plusSprite.getBoundingBox());
            return this.setContentSize(this._minusSprite.getContentSize().width + this._plusSprite.getContentSize().height, c.height), !0
        }
        return !1
    },
    setWraps: function(a) {
        this._wraps = a, this._wraps && (this._minusLabel.setColor(cc.CONTROL_STEPPER_LABELCOLOR_ENABLED), this._plusLabel.setColor(cc.CONTROL_STEPPER_LABELCOLOR_ENABLED)), this.setValue(this._value)
    },
    getWraps: function() {
        return this._wraps
    },
    setMinimumValue: function(a) {
        if (a >= this._maximumValue) throw "cc.ControlStepper.setMinimumValue(): minimumValue should be numerically less than maximumValue.";
        this._minimumValue = a, this.setValue(this._value)
    },
    getMinimumValue: function() {
        return this._minimumValue
    },
    setMaximumValue: function(a) {
        if (a <= this._minimumValue) throw "cc.ControlStepper.setMaximumValue(): maximumValue should be numerically less than maximumValue.";
        this._maximumValue = a, this.setValue(this._value)
    },
    getMaximumValue: function() {
        return this._maximumValue
    },
    setValue: function(a) {
        this.setValueWithSendingEvent(a, !0)
    },
    getValue: function() {
        return this._value
    },
    setStepValue: function(a) {
        if (0 >= a) throw "cc.ControlStepper.setMaximumValue(): stepValue should be numerically greater than 0.";
        this._stepValue = a
    },
    getStepValue: function() {
        return this._stepValue
    },
    isContinuous: function() {
        return this._continuous
    },
    setValueWithSendingEvent: function(a, b) {
        a < this._minimumValue ? a = this._wraps ? this._maximumValue : this._minimumValue : a > this._maximumValue && (a = this._wraps ? this._minimumValue : this._maximumValue), this._value = a, this._wraps || (this._minusLabel.setColor(a == this._minimumValue ? cc.CONTROL_STEPPER_LABELCOLOR_DISABLED : cc.CONTROL_STEPPER_LABELCOLOR_ENABLED), this._plusLabel.setColor(a == this._maximumValue ? cc.CONTROL_STEPPER_LABELCOLOR_DISABLED : cc.CONTROL_STEPPER_LABELCOLOR_ENABLED)), b && this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED)
    },
    startAutorepeat: function() {
        this._autorepeatCount = -1, this.schedule(this.update, cc.AUTOREPEAT_DELTATIME, cc.REPEAT_FOREVER, 3 * cc.AUTOREPEAT_DELTATIME)
    },
    stopAutorepeat: function() {
        this.unschedule(this.update)
    },
    update: function() {
        this._autorepeatCount++, this._autorepeatCount < cc.AUTOREPEAT_INCREASETIME_INCREMENT && this._autorepeatCount % 3 != 0 || (this._touchedPart == cc.CONTROL_STEPPER_PARTMINUS ? this.setValueWithSendingEvent(this._value - this._stepValue, this._continuous) : this._touchedPart == cc.CONTROL_STEPPER_PARTPLUS && this.setValueWithSendingEvent(this._value + this._stepValue, this._continuous))
    },
    updateLayoutUsingTouchLocation: function(a) {
        a.x < this._minusSprite.getContentSize().width && this._value > this._minimumValue ? (this._touchedPart = cc.CONTROL_STEPPER_PARTMINUS, this._minusSprite.setColor(cc.color.GRAY), this._plusSprite.setColor(cc.color.WHITE)) : a.x >= this._minusSprite.getContentSize().width && this._value < this._maximumValue ? (this._touchedPart = cc.CONTROL_STEPPER_PARTPLUS, this._minusSprite.setColor(cc.color.WHITE), this._plusSprite.setColor(cc.color.GRAY)) : (this._touchedPart = cc.CONTROL_STEPPER_PARTNONE, this._minusSprite.setColor(cc.color.WHITE), this._plusSprite.setColor(cc.color.WHITE))
    },
    onTouchBegan: function(a) {
        if (!this.isTouchInside(a) || !this.isEnabled() || !this.isVisible()) return !1;
        var b = this.getTouchLocation(a);
        return this.updateLayoutUsingTouchLocation(b), this._touchInsideFlag = !0, this._autorepeat && this.startAutorepeat(), !0
    },
    onTouchMoved: function(a) {
        if (this.isTouchInside(a)) {
            var b = this.getTouchLocation(a);
            this.updateLayoutUsingTouchLocation(b), this._touchInsideFlag || (this._touchInsideFlag = !0, this._autorepeat && this.startAutorepeat())
        } else this._touchInsideFlag = !1, this._touchedPart = cc.CONTROL_STEPPER_PARTNONE, this._minusSprite.setColor(cc.color.WHITE), this._plusSprite.setColor(cc.color.WHITE), this._autorepeat && this.stopAutorepeat()
    },
    onTouchEnded: function(a) {
        if (this._minusSprite.setColor(cc.color.WHITE), this._plusSprite.setColor(cc.color.WHITE), this._autorepeat && this.stopAutorepeat(), this.isTouchInside(a)) {
            var b = this.getTouchLocation(a);
            this.setValue(this._value + (b.x < this._minusSprite.getContentSize().width ? 0 - this._stepValue : this._stepValue))
        }
    },
    setMinusSprite: function(a) {
        this._minusSprite = a
    },
    getMinusSprite: function() {
        return this._minusSprite
    },
    setPlusSprite: function(a) {
        this._plusSprite = a
    },
    getPlusSprite: function() {
        return this._plusSprite
    },
    setMinusLabel: function(a) {
        this._minusLabel = a
    },
    getMinusLabel: function() {
        return this._minusLabel
    },
    setPlusLabel: function(a) {
        this._plusLabel = a
    },
    getPlusLabel: function() {
        return this._plusLabel
    }
});
var _p = cc.ControlStepper.prototype;
_p.wraps, cc.defineGetterSetter(_p, "wraps", _p.getWraps, _p.setWraps), _p.value, cc.defineGetterSetter(_p, "value", _p.getValue, _p.setValue), _p.minValue, cc.defineGetterSetter(_p, "minValue", _p.getMinimumValue, _p.setMinimumValue), _p.maxValue, cc.defineGetterSetter(_p, "maxValue", _p.getMaximumValue, _p.setMaximumValue), _p.stepValue, cc.defineGetterSetter(_p, "stepValue", _p.getStepValue, _p.setStepValue), _p.continuous, cc.defineGetterSetter(_p, "continuous", _p.isContinuous), _p.minusSprite, cc.defineGetterSetter(_p, "minusSprite", _p.getMinusSprite, _p.setMinusSprite), _p.plusSprite, cc.defineGetterSetter(_p, "plusSprite", _p.getPlusSprite, _p.setPlusSprite), _p.minusLabel, cc.defineGetterSetter(_p, "minusLabel", _p.getMinusLabel, _p.setMinusLabel), _p.plusLabel, cc.defineGetterSetter(_p, "plusLabel", _p.getPlusLabel, _p.setPlusLabel), _p = null, cc.ControlStepper.create = function(a, b) {
    return new cc.ControlStepper(a, b)
}, cc.ControlPotentiometer = cc.Control.extend({
    _thumbSprite: null,
    _progressTimer: null,
    _previousLocation: null,
    _value: 0,
    _minimumValue: 0,
    _maximumValue: 1,
    _className: "ControlPotentiometer",
    ctor: function(a, b, c) {
        if (cc.Control.prototype.ctor.call(this), void 0 != c) {
            var d = new cc.Sprite(a),
                e = new cc.Sprite(c),
                f = new cc.ProgressTimer(new cc.Sprite(b));
            this.initWithTrackSprite_ProgressTimer_ThumbSprite(d, f, e)
        }
    },
    initWithTrackSprite_ProgressTimer_ThumbSprite: function(a, b, c) {
        return this.init() ? (this.setProgressTimer(b), this.setThumbSprite(c), this._thumbSprite.setPosition(b.getPosition()), this.addChild(c, 2), this.addChild(b, 1), this.addChild(a), this.setContentSize(a.getContentSize()), this._minimumValue = 0, this._maximumValue = 1, this.setValue(this._minimumValue), !0) : !1
    },
    setEnabled: function(a) {
        this.setEnabled(a), this._thumbSprite != NULL && this._thumbSprite.setOpacity(a ? 255 : 128)
    },
    setValue: function(a) {
        a < this._minimumValue && (a = this._minimumValue), a > this._maximumValue && (a = this._maximumValue), this._value = a;
        var b = (a - this._minimumValue) / (this._maximumValue - this._minimumValue);
        this._progressTimer.setPercentage(100 * b), this._thumbSprite.setRotation(360 * b), this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED)
    },
    getValue: function() {
        return this._value
    },
    setMinimumValue: function(a) {
        this._minimumValue = a, this._minimumValue >= this._maximumValue && (this._maximumValue = this._minimumValue + 1), this.setValue(this._maximumValue)
    },
    getMinimumValue: function() {
        return this._minimumValue
    },
    setMaximumValue: function(a) {
        this._maximumValue = a, this._maximumValue <= this._minimumValue && (this._minimumValue = this._maximumValue - 1), this.setValue(this._minimumValue)
    },
    getMaximumValue: function() {
        return this._maximumValue
    },
    isTouchInside: function(a) {
        var b = this.getTouchLocation(a),
            c = this.distanceBetweenPointAndPoint(this._progressTimer.getPosition(), b);
        return c < Math.min(this.getContentSize().width / 2, this.getContentSize().height / 2)
    },
    onTouchBegan: function(a) {
        return this.isTouchInside(a) && this.isEnabled() && this.isVisible() ? (this._previousLocation = this.getTouchLocation(a), this.potentiometerBegan(this._previousLocation), !0) : !1
    },
    onTouchMoved: function(a) {
        var b = this.getTouchLocation(a);
        this.potentiometerMoved(b)
    },
    onTouchEnded: function() {
        this.potentiometerEnded(cc.p(0, 0))
    },
    distanceBetweenPointAndPoint: function(a, b) {
        var c = a.x - b.x,
            d = a.y - b.y;
        return Math.sqrt(c * c + d * d)
    },
    angleInDegreesBetweenLineFromPoint_toPoint_toLineFromPoint_toPoint: function(a, b, c, d) {
        var e = b.x - a.x,
            f = b.y - a.y,
            g = d.x - c.x,
            h = d.y - c.y,
            i = Math.atan2(e, f),
            j = Math.atan2(g, h);
        return 180 * (i - j) / Math.PI
    },
    potentiometerBegan: function() {
        this.setSelected(!0), this.getThumbSprite().setColor(cc.color.GRAY)
    },
    potentiometerMoved: function(a) {
        var b = this.angleInDegreesBetweenLineFromPoint_toPoint_toLineFromPoint_toPoint(this._progressTimer.getPosition(), a, this._progressTimer.getPosition(), this._previousLocation);
        b > 180 ? b -= 360 : -180 > b && (b += 360), this.setValue(this._value + b / 360 * (this._maximumValue - this._minimumValue)), this._previousLocation = a
    },
    potentiometerEnded: function() {
        this.getThumbSprite().setColor(cc.color.WHITE), this.setSelected(!1)
    },
    setThumbSprite: function(a) {
        this._thumbSprite = a
    },
    getThumbSprite: function() {
        return this._thumbSprite
    },
    setProgressTimer: function(a) {
        this._progressTimer = a
    },
    getProgressTimer: function() {
        return this._progressTimer
    },
    setPreviousLocation: function(a) {
        this._previousLocation = a
    },
    getPreviousLocation: function() {
        return this._previousLocation
    }
});
var _p = cc.ControlPotentiometer.prototype;
_p.value, cc.defineGetterSetter(_p, "value", _p.getValue, _p.setValue), _p.minValue, cc.defineGetterSetter(_p, "minValue", _p.getMinimumValue, _p.setMinimumValue), _p.maxValue, cc.defineGetterSetter(_p, "maxValue", _p.getMaximumValue, _p.setMaximumValue), _p.progressTimer, cc.defineGetterSetter(_p, "progressTimer", _p.getProgressTimer, _p.setProgressTimer), _p.thumbSprite, cc.defineGetterSetter(_p, "thumbSprite", _p.getThumbSprite, _p.setThumbSprite), _p.prevLocation, cc.defineGetterSetter(_p, "prevLocation", _p.getPreviousLocation, _p.setPreviousLocation), _p = null, cc.ControlPotentiometer.create = function(a, b, c) {
    return new cc.ControlPotentiometer(a, b, c)
}, cc.SCROLLVIEW_DIRECTION_NONE = -1, cc.SCROLLVIEW_DIRECTION_HORIZONTAL = 0, cc.SCROLLVIEW_DIRECTION_VERTICAL = 1, cc.SCROLLVIEW_DIRECTION_BOTH = 2;
var SCROLL_DEACCEL_RATE = .95,
    SCROLL_DEACCEL_DIST = 1,
    BOUNCE_DURATION = .15,
    INSET_RATIO = .2,
    MOVE_INCH = 7 / 160,
    BOUNCE_BACK_FACTOR = .35;
cc.convertDistanceFromPointToInch = function(a) {
    var b = cc.view,
        c = (b.getScaleX() + b.getScaleY()) / 2;
    return a * c / 160
}, cc.ScrollViewDelegate = cc.Class.extend({
    scrollViewDidScroll: function() {},
    scrollViewDidZoom: function() {}
}), cc.ScrollView = cc.Layer.extend({
    _zoomScale: 0,
    _minZoomScale: 0,
    _maxZoomScale: 0,
    _delegate: null,
    _direction: cc.SCROLLVIEW_DIRECTION_BOTH,
    _dragging: !1,
    _contentOffset: null,
    _container: null,
    _touchMoved: !1,
    _maxInset: null,
    _minInset: null,
    _bounceable: !1,
    _clippingToBounds: !1,
    _scrollDistance: null,
    _touchPoint: null,
    _touchLength: 0,
    _touches: null,
    _viewSize: null,
    _minScale: 0,
    _maxScale: 0,
    _parentScissorRect: null,
    _scissorRestored: !1,
    _tmpViewRect: null,
    _touchListener: null,
    _className: "ScrollView",
    ctor: function(a, b) {
        cc.Layer.prototype.ctor.call(this), this._contentOffset = cc.p(0, 0), this._maxInset = cc.p(0, 0), this._minInset = cc.p(0, 0), this._scrollDistance = cc.p(0, 0), this._touchPoint = cc.p(0, 0), this._touches = [], this._viewSize = cc.size(0, 0), this._parentScissorRect = new cc.Rect(0, 0, 0, 0), this._tmpViewRect = new cc.Rect(0, 0, 0, 0), void 0 != b ? this.initWithViewSize(a, b) : this.initWithViewSize(cc.size(200, 200), null)
    },
    init: function() {
        return this.initWithViewSize(cc.size(200, 200), null)
    },
    initWithViewSize: function(a, b) {
        var c = cc.p(0, 0);
        return cc.Layer.prototype.init.call(this) ? (this._container = b, this._container || (this._container = new cc.Layer, this._container.ignoreAnchorPointForPosition(!1), this._container.setAnchorPoint(c)), this.setViewSize(a), this.setTouchEnabled(!0), this._touches.length = 0, this._delegate = null, this._bounceable = !0, this._clippingToBounds = !0, this._direction = cc.SCROLLVIEW_DIRECTION_BOTH, this._container.setPosition(c), this._touchLength = 0, this.addChild(this._container), this._minScale = this._maxScale = 1, !0) : !1
    },
    setContentOffset: function(a, b) {
        if (b) return void this.setContentOffsetInDuration(a, BOUNCE_DURATION);
        if (!this._bounceable) {
            var c = this.minContainerOffset(),
                d = this.maxContainerOffset();
            a.x = Math.max(c.x, Math.min(d.x, a.x)), a.y = Math.max(c.y, Math.min(d.y, a.y))
        }
        this._container.setPosition(a);
        var e = this._delegate;
        null != e && e.scrollViewDidScroll && e.scrollViewDidScroll(this)
    },
    getContentOffset: function() {
        var a = this._container.getPosition();
        return cc.p(a.x, a.y)
    },
    setContentOffsetInDuration: function(a, b) {
        var c = cc.moveTo(b, a),
            d = cc.callFunc(this._stoppedAnimatedScroll, this);
        this._container.runAction(cc.sequence(c, d)), this.schedule(this._performedAnimatedScroll)
    },
    setZoomScale: function(a, b) {
        if (b) return void this.setZoomScaleInDuration(a, BOUNCE_DURATION);
        var c = this._container;
        if (c.getScale() != a) {
            var d, e, f;
            if (0 == this._touchLength) {
                var g = this._viewSize;
                f = cc.p(.5 * g.width, .5 * g.height), f = this.convertToWorldSpace(f)
            } else f = this._touchPoint;
            d = c.convertToNodeSpace(f), c.setScale(Math.max(this._minScale, Math.min(this._maxScale, a))), e = c.convertToWorldSpace(d);
            var h = cc.pSub(f, e);
            this._delegate && this._delegate.scrollViewDidZoom && this._delegate.scrollViewDidZoom(this), this.setContentOffset(cc.pAdd(c.getPosition(), h))
        }
    },
    getZoomScale: function() {
        return this._container.getScale()
    },
    setZoomScaleInDuration: function(a, b) {
        if (b > 0) {
            var c = this._container.getScale();
            if (c != a) {
                var d = cc.actionTween(b, "zoomScale", c, a);
                this.runAction(d)
            }
        } else this.setZoomScale(a)
    },
    minContainerOffset: function() {
        var a = this._container,
            b = a.getContentSize(),
            c = this._viewSize;
        return cc.p(c.width - b.width * a.getScaleX(), c.height - b.height * a.getScaleY())
    },
    maxContainerOffset: function() {
        return cc.p(0, 0)
    },
    isNodeVisible: function(a) {
        var b = this.getContentOffset(),
            c = this.getViewSize(),
            d = this.getZoomScale(),
            e = cc.rect(-b.x / d, -b.y / d, c.width / d, c.height / d);
        return cc.rectIntersectsRect(e, a.getBoundingBox())
    },
    pause: function() {
        this._container.pause();
        for (var a = this._container.getChildren(), b = 0; b < a.length; b++) a[b].pause();
        this._super()
    },
    resume: function() {
        for (var a = this._container.getChildren(), b = 0, c = a.length; c > b; b++) a[b].resume();
        this._container.resume(), this._super()
    },
    isDragging: function() {
        return this._dragging
    },
    isTouchMoved: function() {
        return this._touchMoved
    },
    isBounceable: function() {
        return this._bounceable
    },
    setBounceable: function(a) {
        this._bounceable = a
    },
    getViewSize: function() {
        return this._viewSize
    },
    setViewSize: function(a) {
        this._viewSize = a, cc.Node.prototype.setContentSize.call(this, a)
    },
    getContainer: function() {
        return this._container
    },
    setContainer: function(a) {
        a && (this.removeAllChildren(!0), this._container = a, a.ignoreAnchorPointForPosition(!1), a.setAnchorPoint(0, 0), this.addChild(a), this.setViewSize(this._viewSize))
    },
    getDirection: function() {
        return this._direction
    },
    setDirection: function(a) {
        this._direction = a
    },
    getDelegate: function() {
        return this._delegate
    },
    setDelegate: function(a) {
        this._delegate = a
    },
    onTouchBegan: function(a) {
        if (!this.isVisible()) return !1;
        var b = this._getViewRect(),
            c = this._container,
            d = c.convertToWorldSpace(c.convertTouchToNodeSpace(a)),
            e = this._touches;
        return e.length > 2 || this._touchMoved || !cc.rectContainsPoint(b, d) ? !1 : (e.push(a), 1 === e.length ? (this._touchPoint = this.convertTouchToNodeSpace(a), this._touchMoved = !1, this._dragging = !0, this._scrollDistance.x = 0, this._scrollDistance.y = 0, this._touchLength = 0) : 2 == e.length && (this._touchPoint = cc.pMidpoint(this.convertTouchToNodeSpace(e[0]), this.convertTouchToNodeSpace(e[1])), this._touchLength = cc.pDistance(c.convertTouchToNodeSpace(e[0]), c.convertTouchToNodeSpace(e[1])), this._dragging = !1), !0)
    },
    onTouchMoved: function(a) {
        if (this.isVisible())
            if (this.setNodeDirty(), 1 === this._touches.length && this._dragging) {
                this._touchMoved = !0;
                var b, c = (this._getViewRect(), this.convertTouchToNodeSpace(a)),
                    d = cc.pSub(c, this._touchPoint),
                    e = 0,
                    f = this._direction;
                if (f === cc.SCROLLVIEW_DIRECTION_VERTICAL) e = d.y, b = this._container.getPositionY(), this.minContainerOffset().y <= b && b <= this.maxContainerOffset().y || (d.y *= BOUNCE_BACK_FACTOR);
                else if (f === cc.SCROLLVIEW_DIRECTION_HORIZONTAL) e = d.x, b = this._container.getPositionX(), this.minContainerOffset().x <= b && b <= this.maxContainerOffset().x || (d.x *= BOUNCE_BACK_FACTOR);
                else {
                    e = Math.sqrt(d.x * d.x + d.y * d.y), b = this._container.getPositionY();
                    var g = this.minContainerOffset(),
                        h = this.maxContainerOffset();
                    g.y <= b && b <= h.y || (d.y *= BOUNCE_BACK_FACTOR), b = this._container.getPositionX(), g.x <= b && b <= h.x || (d.x *= BOUNCE_BACK_FACTOR)
                } if (!this._touchMoved && Math.abs(cc.convertDistanceFromPointToInch(e)) < MOVE_INCH) return;
                if (this._touchMoved || (d.x = 0, d.y = 0), this._touchPoint = c, this._touchMoved = !0, this._dragging) {
                    switch (f) {
                        case cc.SCROLLVIEW_DIRECTION_VERTICAL:
                            d.x = 0;
                            break;
                        case cc.SCROLLVIEW_DIRECTION_HORIZONTAL:
                            d.y = 0
                    }
                    var i = this._container.getPosition(),
                        j = i.x + d.x,
                        k = i.y + d.y;
                    this._scrollDistance = d, this.setContentOffset(cc.p(j, k))
                }
            } else if (2 === this._touches.length && !this._dragging) {
            var l = cc.pDistance(this._container.convertTouchToNodeSpace(this._touches[0]), this._container.convertTouchToNodeSpace(this._touches[1]));
            this.setZoomScale(this.getZoomScale() * l / this._touchLength)
        }
    },
    onTouchEnded: function() {
        this.isVisible() && (1 == this._touches.length && this._touchMoved && this.schedule(this._deaccelerateScrolling), this._touches.length = 0, this._dragging = !1, this._touchMoved = !1)
    },
    onTouchCancelled: function() {
        this.isVisible() && (this._touches.length = 0, this._dragging = !1, this._touchMoved = !1)
    },
    setContentSize: function(a, b) {
        null != this.getContainer() && (void 0 === b ? this.getContainer().setContentSize(a) : this.getContainer().setContentSize(a, b), this.updateInset())
    },
    _setWidth: function(a) {
        var b = this.getContainer();
        null != b && (b._setWidth(a), this.updateInset())
    },
    _setHeight: function(a) {
        var b = this.getContainer();
        null != b && (b._setHeight(a), this.updateInset())
    },
    getContentSize: function() {
        return this._container.getContentSize()
    },
    updateInset: function() {
        if (null != this.getContainer()) {
            var a = this._viewSize,
                b = this.maxContainerOffset();
            this._maxInset.x = b.x + a.width * INSET_RATIO, this._maxInset.y = b.y + a.height * INSET_RATIO, b = this.minContainerOffset(), this._minInset.x = b.x - a.width * INSET_RATIO, this._minInset.y = b.y - a.height * INSET_RATIO
        }
    },
    isClippingToBounds: function() {
        return this._clippingToBounds
    },
    setClippingToBounds: function(a) {
        this._clippingToBounds = a
    },
    visit: function(a) {
        this.isVisible() && this._renderCmd.visit(a)
    },
    addChild: function(a, b, c) {
        if (!a) throw new Error("child must not nil!");
        b = b || a.getLocalZOrder(), c = c || a.getTag(), this._container != a ? this._container.addChild(a, b, c) : cc.Layer.prototype.addChild.call(this, a, b, c)
    },
    isTouchEnabled: function() {
        return null != this._touchListener
    },
    setTouchEnabled: function(a) {
        if (this._touchListener && cc.eventManager.removeListener(this._touchListener), this._touchListener = null, a) {
            var b = cc.EventListener.create({
                event: cc.EventListener.TOUCH_ONE_BY_ONE
            });
            this.onTouchBegan && (b.onTouchBegan = this.onTouchBegan.bind(this)), this.onTouchMoved && (b.onTouchMoved = this.onTouchMoved.bind(this)), this.onTouchEnded && (b.onTouchEnded = this.onTouchEnded.bind(this)), this.onTouchCancelled && (b.onTouchCancelled = this.onTouchCancelled.bind(this)), this._touchListener = b, cc.eventManager.addListener(b, this)
        } else this._dragging = !1, this._touchMoved = !1, this._touches.length = 0
    },
    _initWithViewSize: function() {
        return null
    },
    _relocateContainer: function(a) {
        var b = this.minContainerOffset(),
            c = this.maxContainerOffset(),
            d = this._direction,
            e = this._container.getPosition(),
            f = e.x,
            g = e.y;
        (d === cc.SCROLLVIEW_DIRECTION_BOTH || d === cc.SCROLLVIEW_DIRECTION_HORIZONTAL) && (f = Math.max(f, b.x), f = Math.min(f, c.x)), (d == cc.SCROLLVIEW_DIRECTION_BOTH || d == cc.SCROLLVIEW_DIRECTION_VERTICAL) && (g = Math.min(g, c.y), g = Math.max(g, b.y)), (g != e.y || f != e.x) && this.setContentOffset(cc.p(f, g), a)
    },
    _deaccelerateScrolling: function() {
        if (this._dragging) return void this.unschedule(this._deaccelerateScrolling);
        var a, b, c = this._container.getPosition(),
            d = this._scrollDistance;
        this._container.setPosition(c.x + d.x, c.y + d.y), this._bounceable ? (a = this._maxInset, b = this._minInset) : (a = this.maxContainerOffset(), b = this.minContainerOffset());
        var e = this._container.getPositionX(),
            f = this._container.getPositionY();
        d.x = d.x * SCROLL_DEACCEL_RATE, d.y = d.y * SCROLL_DEACCEL_RATE, this.setContentOffset(cc.p(e, f)), (Math.abs(d.x) <= SCROLL_DEACCEL_DIST && Math.abs(d.y) <= SCROLL_DEACCEL_DIST || f > a.y || f < b.y || e > a.x || e < b.x || e == a.x || e == b.x || f == a.y || f == b.y) && (this.unschedule(this._deaccelerateScrolling), this._relocateContainer(!0))
    },
    _performedAnimatedScroll: function() {
        return this._dragging ? void this.unschedule(this._performedAnimatedScroll) : void(this._delegate && this._delegate.scrollViewDidScroll && this._delegate.scrollViewDidScroll(this))
    },
    _stoppedAnimatedScroll: function() {
        this.unschedule(this._performedAnimatedScroll), this._delegate && this._delegate.scrollViewDidScroll && this._delegate.scrollViewDidScroll(this)
    },
    _handleZoom: function() {},
    _getViewRect: function() {
        for (var a = this.convertToWorldSpace(cc.p(0, 0)), b = this._viewSize, c = this.getScaleX(), d = this.getScaleY(), e = this._parent; null != e; e = e.getParent()) c *= e.getScaleX(), d *= e.getScaleY();
        0 > c && (a.x += b.width * c, c = -c), 0 > d && (a.y += b.height * d, d = -d);
        var f = this._tmpViewRect;
        return f.x = a.x, f.y = a.y, f.width = b.width * c, f.height = b.height * d, f
    },
    _createRenderCmd: function() {
        return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.ScrollView.CanvasRenderCmd(this) : new cc.ScrollView.WebGLRenderCmd(this)
    }
});
var _p = cc.ScrollView.prototype;
_p.minOffset, cc.defineGetterSetter(_p, "minOffset", _p.minContainerOffset), _p.maxOffset, cc.defineGetterSetter(_p, "maxOffset", _p.maxContainerOffset), _p.bounceable, cc.defineGetterSetter(_p, "bounceable", _p.isBounceable, _p.setBounceable), _p.viewSize, cc.defineGetterSetter(_p, "viewSize", _p.getViewSize, _p.setViewSize), _p.container, cc.defineGetterSetter(_p, "container", _p.getContainer, _p.setContainer), _p.direction, cc.defineGetterSetter(_p, "direction", _p.getDirection, _p.setDirection), _p.delegate, cc.defineGetterSetter(_p, "delegate", _p.getDelegate, _p.setDelegate), _p.clippingToBounds, cc.defineGetterSetter(_p, "clippingToBounds", _p.isClippingToBounds, _p.setClippingToBounds), _p = null, cc.ScrollView.create = function(a, b) {
        return new cc.ScrollView(a, b)
    },
    function() {
        cc.ScrollView.CanvasRenderCmd = function(a) {
            cc.Layer.CanvasRenderCmd.call(this, a), this._needDraw = !1, this.startCmd = new cc.CustomRenderCmd(this, this._startCmd), this.endCmd = new cc.CustomRenderCmd(this, this._endCmd)
        };
        var a = cc.ScrollView.CanvasRenderCmd.prototype = Object.create(cc.Layer.CanvasRenderCmd.prototype);
        a.constructor = cc.ScrollView.CanvasRenderCmd, a._startCmd = function(a, b, c) {
            var d = this._node,
                e = a || cc._renderContext,
                f = e.getContext();
            if (e.save(), d._clippingToBounds) {
                this._scissorRestored = !1, e.setTransform(this._worldTransform, b, c);
                var g = d.getScaleX(),
                    h = d.getScaleY(),
                    i = d._viewSize.width * g * b,
                    j = d._viewSize.height * h * c;
                f.beginPath(), f.rect(0, 0, i, -j), f.closePath(), f.clip()
            }
        }, a._endCmd = function(a) {
            a = a || cc._renderContext, a.restore()
        }, a.visit = function(a) {
            var b, c, d = this._node,
                e = d._children;
            if (this.transform(a), cc.renderer.pushRenderCommand(this.startCmd), e && e.length > 0)
                for (c = e.length, d.sortAllChildren(), b = 0; c > b; b++) e[b]._renderCmd.visit(this);
            cc.renderer.pushRenderCommand(this.endCmd)
        }
    }(), cc.SortableObject = cc.Class.extend({
        setObjectID: function() {},
        getObjectID: function() {
            return 0
        }
    }), cc.SortedObject = cc.SortableObject.extend({
        _objectID: 0,
        ctor: function() {
            this._objectID = 0
        },
        setObjectID: function(a) {
            this._objectID = a
        },
        getObjectID: function() {
            return this._objectID
        }
    });
var _compareObject = function(a, b) {
    return a.getObjectID() - b.getObjectID()
};
cc.ArrayForObjectSorting = cc.Class.extend({
    _saveObjectArr: null,
    ctor: function() {
        this._saveObjectArr = []
    },
    insertSortedObject: function(a) {
        if (!a) throw "cc.ArrayForObjectSorting.insertSortedObject(): addObject should be non-null.";
        var b = this.indexOfSortedObject(a);
        this.insertObject(a, b)
    },
    removeSortedObject: function(a) {
        if (0 != this.count()) {
            var b = this.indexOfSortedObject(a);
            if (b < this.count() && b != cc.INVALID_INDEX) {
                var c = this.objectAtIndex(b);
                c.getObjectID() == a.getObjectID() && this.removeObjectAtIndex(b)
            }
        }
    },
    setObjectID_ofSortedObject: function(a, b) {
        var c = this.indexOfSortedObject(b);
        if (c < this.count() && c != cc.INVALID_INDEX) {
            var d = this.objectAtIndex(c);
            d.getObjectID() == b.getObjectID() && (this.removeObjectAtIndex(c), d.setObjectID(a), this.insertSortedObject(d))
        }
    },
    objectWithObjectID: function(a) {
        if (0 == this.count()) return null;
        var b = new cc.SortedObject;
        b.setObjectID(a);
        var c = this.indexOfSortedObject(b);
        return c < this.count() && c != cc.INVALID_INDEX && (b = this.objectAtIndex(c), b.getObjectID() != a && (b = null)), b
    },
    getObjectWithObjectID: function() {
        return null
    },
    indexOfSortedObject: function(a) {
        var b = 0;
        if (a)
            for (var c = 0, d = a.getObjectID(), e = this._saveObjectArr, f = 0; f < e.length; f++) {
                var g = e[f],
                    h = g.getObjectID();
                if (d == h || d >= c && h > d) break;
                c = h, b++
            } else b = cc.INVALID_INDEX;
        return b
    },
    count: function() {
        return this._saveObjectArr.length
    },
    lastObject: function() {
        var a = this._saveObjectArr;
        return 0 == a.length ? null : a[a.length - 1]
    },
    objectAtIndex: function(a) {
        return this._saveObjectArr[a]
    },
    addObject: function(a) {
        this._saveObjectArr.push(a), this._saveObjectArr.sort(_compareObject)
    },
    removeObjectAtIndex: function(a) {
        this._saveObjectArr.splice(a, 1), this._saveObjectArr.sort(_compareObject)
    },
    insertObject: function(a, b) {
        this._saveObjectArr.splice(b, 0, a), this._saveObjectArr.sort(_compareObject)
    }
}), cc.TABLEVIEW_FILL_TOPDOWN = 0, cc.TABLEVIEW_FILL_BOTTOMUP = 1, cc.TableViewCell = cc.Node.extend({
    _idx: 0,
    _className: "TableViewCell",
    getIdx: function() {
        return this._idx
    },
    setIdx: function(a) {
        this._idx = a
    },
    reset: function() {
        this._idx = cc.INVALID_INDEX
    },
    setObjectID: function(a) {
        this._idx = a
    },
    getObjectID: function() {
        return this._idx
    }
});
var _p = cc.TableViewCell.prototype;
_p.objectId, cc.defineGetterSetter(_p, "objectId", _p.getObjectID, _p.setObjectID), _p = null, cc.TableViewDelegate = cc.ScrollViewDelegate.extend({
    tableCellTouched: function() {},
    tableCellHighlight: function() {},
    tableCellUnhighlight: function() {},
    tableCellWillRecycle: function() {}
}), cc.TableViewDataSource = cc.Class.extend({
    tableCellSizeForIndex: function(a) {
        return this.cellSizeForTable(a)
    },
    cellSizeForTable: function() {
        return cc.size(0, 0)
    },
    tableCellAtIndex: function() {
        return null
    },
    numberOfCellsInTableView: function() {
        return 0
    }
}), cc.TableView = cc.ScrollView.extend({
    _vOrdering: null,
    _indices: null,
    _cellsFreed: null,
    _dataSource: null,
    _tableViewDelegate: null,
    _oldDirection: null,
    _cellsPositions: null,
    _touchedCell: null,
    ctor: function(a, b, c) {
        cc.ScrollView.prototype.ctor.call(this), this._oldDirection = cc.SCROLLVIEW_DIRECTION_NONE, this._cellsPositions = [], this.initWithViewSize(b, c), this.setDataSource(a), this._updateCellPositions(), this._updateContentSize()
    },
    __indexFromOffset: function(a) {
        var b, c = 0,
            d = this._dataSource.numberOfCellsInTableView(this) - 1;
        switch (this.getDirection()) {
            case cc.SCROLLVIEW_DIRECTION_HORIZONTAL:
                b = a.x;
                break;
            default:
                b = a.y
        }
        for (var e = this._cellsPositions; d >= c;) {
            var f = 0 | c + (d - c) / 2,
                g = e[f],
                h = e[f + 1];
            if (b >= g && h >= b) return f;
            g > b ? d = f - 1 : c = f + 1
        }
        return 0 >= c ? 0 : -1
    },
    _indexFromOffset: function(a) {
        var b = {
                x: a.x,
                y: a.y
            },
            c = this._dataSource,
            d = c.numberOfCellsInTableView(this) - 1;
        this._vOrdering === cc.TABLEVIEW_FILL_TOPDOWN && (b.y = this.getContainer().getContentSize().height - b.y);
        var e = this.__indexFromOffset(b);
        return -1 != e && (e = Math.max(0, e), e > d && (e = cc.INVALID_INDEX)), e
    },
    __offsetFromIndex: function(a) {
        var b;
        switch (this.getDirection()) {
            case cc.SCROLLVIEW_DIRECTION_HORIZONTAL:
                b = cc.p(this._cellsPositions[a], 0);
                break;
            default:
                b = cc.p(0, this._cellsPositions[a])
        }
        return b
    },
    _offsetFromIndex: function(a) {
        var b = this.__offsetFromIndex(a),
            c = this._dataSource.tableCellSizeForIndex(this, a);
        return this._vOrdering === cc.TABLEVIEW_FILL_TOPDOWN && (b.y = this.getContainer().getContentSize().height - b.y - c.height), b
    },
    _updateCellPositions: function() {
        var a = this._dataSource.numberOfCellsInTableView(this),
            b = this._cellsPositions;
        if (a > 0) {
            for (var c, d = 0, e = this._dataSource, f = 0; a > f; f++) switch (b[f] = d, c = e.tableCellSizeForIndex(this, f), this.getDirection()) {
                case cc.SCROLLVIEW_DIRECTION_HORIZONTAL:
                    d += c.width;
                    break;
                default:
                    d += c.height
            }
            this._cellsPositions[a] = d
        }
    },
    _updateContentSize: function() {
        var a = cc.size(0, 0),
            b = this._dataSource.numberOfCellsInTableView(this);
        if (b > 0) {
            var c = this._cellsPositions[b];
            switch (this.getDirection()) {
                case cc.SCROLLVIEW_DIRECTION_HORIZONTAL:
                    a = cc.size(c, this._viewSize.height);
                    break;
                default:
                    a = cc.size(this._viewSize.width, c)
            }
        }
        this.setContentSize(a), this._oldDirection != this._direction && (this.setContentOffset(this._direction == cc.SCROLLVIEW_DIRECTION_HORIZONTAL ? cc.p(0, 0) : cc.p(0, this.minContainerOffset().y)), this._oldDirection = this._direction)
    },
    _moveCellOutOfSight: function(a) {
        this._tableViewDelegate && this._tableViewDelegate.tableCellWillRecycle && this._tableViewDelegate.tableCellWillRecycle(this, a), this._cellsFreed.addObject(a), this._cellsUsed.removeSortedObject(a), cc.arrayRemoveObject(this._indices, a.getIdx()), a.reset(), a.getParent() == this.getContainer() && this.getContainer().removeChild(a, !0)
    },
    _setIndexForCell: function(a, b) {
        b.setAnchorPoint(0, 0), b.setPosition(this._offsetFromIndex(a)), b.setIdx(a)
    },
    _addCellIfNecessary: function(a) {
        a.getParent() != this.getContainer() && this.getContainer().addChild(a), this._cellsUsed.insertSortedObject(a);
        var b = this._indices,
            c = a.getIdx(); - 1 == b.indexOf(c) && (b.push(c), b.sort(function(a, b) {
            return a - b
        }))
    },
    getDataSource: function() {
        return this._dataSource
    },
    setDataSource: function(a) {
        this._dataSource = a
    },
    getDelegate: function() {
        return this._tableViewDelegate
    },
    setDelegate: function(a) {
        this._tableViewDelegate = a
    },
    setVerticalFillOrder: function(a) {
        this._vOrdering != a && (this._vOrdering = a, this._cellsUsed.count() > 0 && this.reloadData())
    },
    getVerticalFillOrder: function() {
        return this._vOrdering
    },
    initWithViewSize: function(a, b) {
        return cc.ScrollView.prototype.initWithViewSize.call(this, a, b) ? (this._cellsUsed = new cc.ArrayForObjectSorting, this._cellsFreed = new cc.ArrayForObjectSorting, this._indices = [], this._tableViewDelegate = null, this._vOrdering = cc.TABLEVIEW_FILL_BOTTOMUP, this.setDirection(cc.SCROLLVIEW_DIRECTION_VERTICAL), cc.ScrollView.prototype.setDelegate.call(this, this), !0) : !1
    },
    updateCellAtIndex: function(a) {
        if (!(a == cc.INVALID_INDEX || a > this._dataSource.numberOfCellsInTableView(this) - 1)) {
            var b = this.cellAtIndex(a);
            b && this._moveCellOutOfSight(b), b = this._dataSource.tableCellAtIndex(this, a), this._setIndexForCell(a, b), this._addCellIfNecessary(b)
        }
    },
    insertCellAtIndex: function(a) {
        if (!(a == cc.INVALID_INDEX || a > this._dataSource.numberOfCellsInTableView(this) - 1)) {
            var b, c = this._cellsUsed,
                d = c.objectWithObjectID(a);
            if (d) {
                b = c.indexOfSortedObject(d);
                for (var e = b; e < c.count(); e++) d = c.objectAtIndex(e), this._setIndexForCell(d.getIdx() + 1, d)
            }
            d = this._dataSource.tableCellAtIndex(this, a), this._setIndexForCell(a, d), this._addCellIfNecessary(d), this._updateCellPositions(), this._updateContentSize()
        }
    },
    removeCellAtIndex: function(a) {
        if (!(a == cc.INVALID_INDEX || a > this._dataSource.numberOfCellsInTableView(this) - 1)) {
            var b = this.cellAtIndex(a);
            if (b) {
                var c = this._cellsUsed,
                    d = c.indexOfSortedObject(b);
                this._moveCellOutOfSight(b), cc.arrayRemoveObject(this._indices, a), this._updateCellPositions();
                for (var e = c.count() - 1; e > d; e--) b = c.objectAtIndex(e), this._setIndexForCell(b.getIdx() - 1, b)
            }
        }
    },
    reloadData: function() {
        this._oldDirection = cc.SCROLLVIEW_DIRECTION_NONE;
        for (var a = this._cellsUsed, b = this._cellsFreed, c = this.getContainer(), d = 0, e = a.count(); e > d; d++) {
            var f = a.objectAtIndex(d);
            this._tableViewDelegate && this._tableViewDelegate.tableCellWillRecycle && this._tableViewDelegate.tableCellWillRecycle(this, f), b.addObject(f), f.reset(), f.getParent() == c && c.removeChild(f, !0)
        }
        this._indices = [], this._cellsUsed = new cc.ArrayForObjectSorting, this._updateCellPositions(), this._updateContentSize(), this._dataSource.numberOfCellsInTableView(this) > 0 && this.scrollViewDidScroll(this)
    },
    dequeueCell: function() {
        if (0 === this._cellsFreed.count()) return null;
        var a = this._cellsFreed.objectAtIndex(0);
        return this._cellsFreed.removeObjectAtIndex(0), a
    },
    cellAtIndex: function(a) {
        var b = this._indices.indexOf(a);
        return -1 == b ? null : this._cellsUsed.objectWithObjectID(a)
    },
    scrollViewDidScroll: function() {
        var a = this._dataSource,
            b = a.numberOfCellsInTableView(this);
        if (0 !== b) {
            null != this._tableViewDelegate && this._tableViewDelegate.scrollViewDidScroll && this._tableViewDelegate.scrollViewDidScroll(this);
            var c = 0,
                d = this._viewSize,
                e = this.getContainer(),
                f = this.getContentOffset();
            f.x *= -1, f.y *= -1;
            var g = Math.max(b - 1, 0);
            this._vOrdering === cc.TABLEVIEW_FILL_TOPDOWN && (f.y = f.y + d.height / e.getScaleY());
            var h = this._indexFromOffset(f);
            h === cc.INVALID_INDEX && (h = b - 1), this._vOrdering === cc.TABLEVIEW_FILL_TOPDOWN ? f.y -= d.height / e.getScaleY() : f.y += d.height / e.getScaleY(), f.x += d.width / e.getScaleX();
            var i = this._indexFromOffset(f);
            i === cc.INVALID_INDEX && (i = b - 1);
            var j, k = this._cellsUsed;
            if (k.count() > 0)
                for (j = k.objectAtIndex(0), c = j.getIdx(); h > c && (this._moveCellOutOfSight(j), k.count() > 0);) j = k.objectAtIndex(0), c = j.getIdx();
            if (k.count() > 0)
                for (j = k.lastObject(), c = j.getIdx(); g >= c && c > i && (this._moveCellOutOfSight(j), k.count() > 0);) j = k.lastObject(), c = j.getIdx();
            for (var l = this._indices, m = h; i >= m; m++) - 1 == l.indexOf(m) && this.updateCellAtIndex(m)
        }
    },
    scrollViewDidZoom: function() {},
    onTouchEnded: function(a, b) {
        if (this.isVisible()) {
            if (this._touchedCell) {
                var c = this.getBoundingBox(),
                    d = cc.p(c.x, c.y);
                d = this._parent.convertToWorldSpace(d), c.x = d.x, c.y = d.y;
                var e = this._tableViewDelegate;
                cc.rectContainsPoint(c, a.getLocation()) && null != e && (e.tableCellUnhighlight && e.tableCellUnhighlight(this, this._touchedCell), e.tableCellTouched && e.tableCellTouched(this, this._touchedCell)), this._touchedCell = null
            }
            cc.ScrollView.prototype.onTouchEnded.call(this, a, b)
        }
    },
    onTouchBegan: function(a, b) {
        if (!this.isVisible()) return !1;
        var c = cc.ScrollView.prototype.onTouchBegan.call(this, a, b);
        if (1 === this._touches.length) {
            var d, e;
            e = this.getContainer().convertTouchToNodeSpace(a), d = this._indexFromOffset(e), this._touchedCell = d === cc.INVALID_INDEX ? null : this.cellAtIndex(d), this._touchedCell && null != this._tableViewDelegate && this._tableViewDelegate.tableCellHighlight && this._tableViewDelegate.tableCellHighlight(this, this._touchedCell)
        } else this._touchedCell && (null != this._tableViewDelegate && this._tableViewDelegate.tableCellUnhighlight && this._tableViewDelegate.tableCellUnhighlight(this, this._touchedCell), this._touchedCell = null);
        return c
    },
    onTouchMoved: function(a, b) {
        cc.ScrollView.prototype.onTouchMoved.call(this, a, b), this._touchedCell && this.isTouchMoved() && (null != this._tableViewDelegate && this._tableViewDelegate.tableCellUnhighlight && this._tableViewDelegate.tableCellUnhighlight(this, this._touchedCell), this._touchedCell = null)
    },
    onTouchCancelled: function(a, b) {
        cc.ScrollView.prototype.onTouchCancelled.call(this, a, b), this._touchedCell && (null != this._tableViewDelegate && this._tableViewDelegate.tableCellUnhighlight && this._tableViewDelegate.tableCellUnhighlight(this, this._touchedCell), this._touchedCell = null)
    }
});
var _p = cc.TableView.prototype;
_p.dataSource, cc.defineGetterSetter(_p, "dataSource", _p.getDataSource, _p.setDataSource), _p.delegate, cc.defineGetterSetter(_p, "delegate", _p.getDelegate, _p.setDelegate), _p.verticalFillOrder, cc.defineGetterSetter(_p, "verticalFillOrder", _p.getVerticalFillOrder, _p.setVerticalFillOrder), _p = null, cc.TableView.create = function(a, b, c) {
    return new cc.TableView(a, b, c)
};
! function() {
    cc.Scale9Sprite.WebGLRenderCmd = function(a) {
        cc.Node.WebGLRenderCmd.call(this, a), this._cachedParent = null, this._cacheDirty = !1
    };
    var a = cc.Scale9Sprite.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    a.constructor = cc.Scale9Sprite.WebGLRenderCmd, a.addBatchNodeToChildren = function(a) {
        this._node.addChild(a)
    }, a._computeSpriteScale = function(a, b, c, d) {
        var e = a / c,
            f = b / d,
            g = c * e,
            h = d * f,
            i = Math.round(g);
        g !== i && (g = i, e = g / c);
        var j = Math.round(h);
        return h !== j && (h = j, f = h / d), {
            horizontalScale: e,
            verticalScale: f,
            rescaledWidth: g,
            rescaledHeight: h
        }
    }, a.visit = function(a) {
        var b = this._node;
        b._visible && (b._positionsAreDirty && (b._updatePositions(), b._positionsAreDirty = !1, b._scale9Dirty = !0), cc.Node.WebGLRenderCmd.prototype.visit.call(this, a))
    }
}(),
function() {
    cc.ScrollView.WebGLRenderCmd = function(a) {
        cc.Layer.WebGLRenderCmd.call(this, a), this._needDraw = !1, this.startCmd = new cc.CustomRenderCmd(this, this._startCmd), this.endCmd = new cc.CustomRenderCmd(this, this._endCmd)
    };
    var a = cc.ScrollView.WebGLRenderCmd.prototype = Object.create(cc.Layer.WebGLRenderCmd.prototype);
    a.constructor = cc.ScrollView.WebGLRenderCmd, a._startCmd = function() {
        var a = this._node,
            b = cc.view,
            c = a._getViewRect();
        if (b.isScissorEnabled()) {
            if (a._scissorRestored = !0, a._parentScissorRect = b.getScissorRect(), cc.rectIntersection(c, a._parentScissorRect)) {
                var d = a._parentScissorRect,
                    e = Math.max(c.x, d.x),
                    f = Math.max(c.y, d.y),
                    g = Math.min(c.x + c.width, d.x + d.width),
                    h = Math.min(c.y + c.height, d.y + d.height);
                b.setScissorInPoints(e, f, g - e, h - f)
            }
        } else {
            var i = cc._renderContext;
            i.enable(i.SCISSOR_TEST), b.setScissorInPoints(c.x, c.y, c.width, c.height)
        }
    }, a._endCmd = function() {
        var a = this._node;
        if (a._scissorRestored) {
            var b = a._parentScissorRect;
            cc.view.setScissorInPoints(b.x, b.y, b.width, b.height)
        } else {
            var c = cc._renderContext;
            c.disable(c.SCISSOR_TEST)
        }
    }, a.visit = function(a) {
        var b, c, d, e = this._node,
            f = e._children;
        if (cc.kmGLPushMatrix(), this.transform(a), e._clippingToBounds && cc.renderer.pushRenderCommand(this.startCmd), f && f.length > 0) {
            for (d = f.length, b = 0; d > b && (c = f[b], c && c._localZOrder < 0); b++) c._renderCmd.visit();
            for (; d > b; b++) f[b]._renderCmd.visit()
        }
        e._clippingToBounds && cc.renderer.pushRenderCommand(this.endCmd), this._dirtyFlag = 0, cc.kmGLPopMatrix()
    }
}();

function BlockData(a, b) {
    this.selMenuHander = a, this.target = b
}

function BlockCCControlData(a, b, c) {
    this.selCCControlHandler = a, this.target = b, this.controlEvents = c
}
var PROPERTY_POSITION = "position",
    PROPERTY_CONTENTSIZE = "contentSize",
    PROPERTY_SKEW = "skew",
    PROPERTY_ANCHORPOINT = "anchorPoint",
    PROPERTY_SCALE = "scale",
    PROPERTY_ROTATION = "rotation",
    PROPERTY_TAG = "tag",
    PROPERTY_IGNOREANCHORPOINTFORPOSITION = "ignoreAnchorPointForPosition",
    PROPERTY_VISIBLE = "visible",
    ASSERT_FAIL_UNEXPECTED_PROPERTY = function(a) {
        cc.log("Unexpected property: '" + a + "'!")
    },
    ASSERT_FAIL_UNEXPECTED_PROPERTYTYPE = function(a) {
        cc.log("Unexpected property type: '" + a + "'!")
    };
cc.NodeLoader = cc.Class.extend({
    _customProperties: null,
    ctor: function() {
        this._customProperties = new cc._Dictionary
    },
    loadCCNode: function(a, b) {
        return this._createCCNode(a, b)
    },
    parseProperties: function(a, b, c) {
        for (var d = c.readInt(!1), e = c.readInt(!1), f = d + e, g = 0; f > g; g++) {
            var h = g >= d,
                i = c.readInt(!1),
                j = c.readCachedString(),
                k = !1,
                l = c.readByte();
            if ((l === CCB_PLATFORM_ALL || l === CCB_PLATFORM_IOS || l === CCB_PLATFORM_MAC) && (k = !0), a instanceof cc.BuilderFile) {
                if (a.getCCBFileNode() && h) {
                    a = a.getCCBFileNode();
                    var m = a.userObject;
                    k = -1 != m.indexOf(j)
                }
            } else if (h && a == c.getAnimationManager().getRootNode()) {
                var n = a.userObject;
                n || (n = [], a.userObject = n), n.push(j)
            }
            switch (i) {
                case CCB_PROPTYPE_POSITION:
                    var o = this.parsePropTypePosition(a, b, c, j);
                    k && this.onHandlePropTypePosition(a, b, j, o, c);
                    break;
                case CCB_PROPTYPE_POINT:
                    var p = this.parsePropTypePoint(a, b, c);
                    k && this.onHandlePropTypePoint(a, b, j, p, c);
                    break;
                case CCB_PROPTYPE_POINTLOCK:
                    var q = this.parsePropTypePointLock(a, b, c);
                    k && this.onHandlePropTypePointLock(a, b, j, q, c);
                    break;
                case CCB_PROPTYPE_SIZE:
                    var r = this.parsePropTypeSize(a, b, c);
                    k && this.onHandlePropTypeSize(a, b, j, r, c);
                    break;
                case CCB_PROPTYPE_SCALELOCK:
                    var s = this.parsePropTypeScaleLock(a, b, c, j);
                    k && this.onHandlePropTypeScaleLock(a, b, j, s, c);
                    break;
                case CCB_PROPTYPE_FLOATXY:
                    var t = this.parsePropTypeFloatXY(a, b, c);
                    k && this.onHandlePropTypeFloatXY(a, b, j, t, c);
                    break;
                case CCB_PROPTYPE_FLOAT:
                    var u = this.parsePropTypeFloat(a, b, c);
                    k && this.onHandlePropTypeFloat(a, b, j, u, c);
                    break;
                case CCB_PROPTYPE_DEGREES:
                    var v = this.parsePropTypeDegrees(a, b, c, j);
                    k && this.onHandlePropTypeDegrees(a, b, j, v, c);
                    break;
                case CCB_PROPTYPE_FLOATSCALE:
                    var w = this.parsePropTypeFloatScale(a, b, c);
                    k && this.onHandlePropTypeFloatScale(a, b, j, w, c);
                    break;
                case CCB_PROPTYPE_INTEGER:
                    var x = this.parsePropTypeInteger(a, b, c);
                    k && this.onHandlePropTypeInteger(a, b, j, x, c);
                    break;
                case CCB_PROPTYPE_INTEGERLABELED:
                    var y = this.parsePropTypeIntegerLabeled(a, b, c);
                    k && this.onHandlePropTypeIntegerLabeled(a, b, j, y, c);
                    break;
                case CCB_PROPTYPE_FLOATVAR:
                    var z = this.parsePropTypeFloatVar(a, b, c);
                    k && this.onHandlePropTypeFloatVar(a, b, j, z, c);
                    break;
                case CCB_PROPTYPE_CHECK:
                    var A = this.parsePropTypeCheck(a, b, c, j);
                    k && this.onHandlePropTypeCheck(a, b, j, A, c);
                    break;
                case CCB_PROPTYPE_SPRITEFRAME:
                    var B = this.parsePropTypeSpriteFrame(a, b, c, j);
                    k && this.onHandlePropTypeSpriteFrame(a, b, j, B, c);
                    break;
                case CCB_PROPTYPE_ANIMATION:
                    var C = this.parsePropTypeAnimation(a, b, c);
                    k && this.onHandlePropTypeAnimation(a, b, j, C, c);
                    break;
                case CCB_PROPTYPE_TEXTURE:
                    var D = this.parsePropTypeTexture(a, b, c);
                    k && this.onHandlePropTypeTexture(a, b, j, D, c);
                    break;
                case CCB_PROPTYPE_BYTE:
                    var E = this.parsePropTypeByte(a, b, c, j);
                    k && this.onHandlePropTypeByte(a, b, j, E, c);
                    break;
                case CCB_PROPTYPE_COLOR3:
                    var F = this.parsePropTypeColor3(a, b, c, j);
                    k && this.onHandlePropTypeColor3(a, b, j, F, c);
                    break;
                case CCB_PROPTYPE_COLOR4VAR:
                    var G = this.parsePropTypeColor4FVar(a, b, c);
                    k && this.onHandlePropTypeColor4FVar(a, b, j, G, c);
                    break;
                case CCB_PROPTYPE_FLIP:
                    var H = this.parsePropTypeFlip(a, b, c);
                    k && this.onHandlePropTypeFlip(a, b, j, H, c);
                    break;
                case CCB_PROPTYPE_BLENDMODE:
                    var I = this.parsePropTypeBlendFunc(a, b, c);
                    k && this.onHandlePropTypeBlendFunc(a, b, j, I, c);
                    break;
                case CCB_PROPTYPE_FNTFILE:
                    var J = c.getCCBRootPath() + this.parsePropTypeFntFile(a, b, c);
                    k && this.onHandlePropTypeFntFile(a, b, j, J, c);
                    break;
                case CCB_PROPTYPE_FONTTTF:
                    var K = this.parsePropTypeFontTTF(a, b, c);
                    k && this.onHandlePropTypeFontTTF(a, b, j, K, c);
                    break;
                case CCB_PROPTYPE_STRING:
                    var L = this.parsePropTypeString(a, b, c);
                    k && this.onHandlePropTypeString(a, b, j, L, c);
                    break;
                case CCB_PROPTYPE_TEXT:
                    var M = this.parsePropTypeText(a, b, c);
                    k && this.onHandlePropTypeText(a, b, j, M, c);
                    break;
                case CCB_PROPTYPE_BLOCK:
                    var N = this.parsePropTypeBlock(a, b, c);
                    k && this.onHandlePropTypeBlock(a, b, j, N, c);
                    break;
                case CCB_PROPTYPE_BLOCKCCCONTROL:
                    var O = this.parsePropTypeBlockCCControl(a, b, c);
                    k && null != O && this.onHandlePropTypeBlockCCControl(a, b, j, O, c);
                    break;
                case CCB_PROPTYPE_CCBFILE:
                    var P = this.parsePropTypeCCBFile(a, b, c);
                    k && this.onHandlePropTypeCCBFile(a, b, j, P, c);
                    break;
                default:
                    ASSERT_FAIL_UNEXPECTED_PROPERTYTYPE(i)
            }
        }
    },
    getCustomProperties: function() {
        return this._customProperties
    },
    _createCCNode: function() {
        return new cc.Node
    },
    parsePropTypePosition: function(a, b, c, d) {
        var e = c.readFloat(),
            f = c.readFloat(),
            g = c.readInt(!1),
            h = c.getAnimationManager().getContainerSize(b),
            i = cc._getAbsolutePosition(e, f, g, h, d);
        if (a.setPosition(cc.getAbsolutePosition(i, g, h, d)), c.getAnimatedProperties().indexOf(d) > -1) {
            var j = [e, f, g];
            c.getAnimationManager().setBaseValue(j, a, d)
        }
        return i
    },
    parsePropTypePoint: function(a, b, c) {
        var d = c.readFloat(),
            e = c.readFloat();
        return cc.p(d, e)
    },
    parsePropTypePointLock: function(a, b, c) {
        var d = c.readFloat(),
            e = c.readFloat();
        return cc.p(d, e)
    },
    parsePropTypeSize: function(a, b, c) {
        var d = c.readFloat(),
            e = c.readFloat(),
            f = c.readInt(!1),
            g = c.getAnimationManager().getContainerSize(b);
        switch (f) {
            case CCB_SIZETYPE_ABSOLUTE:
                break;
            case CCB_SIZETYPE_RELATIVE_CONTAINER:
                d = g.width - d, e = g.height - e;
                break;
            case CCB_SIZETYPE_PERCENT:
                d = g.width * d / 100, e = g.height * e / 100;
                break;
            case CCB_SIZETYPE_HORIZONTAL_PERCENT:
                d = g.width * d / 100;
                break;
            case CCB_SIZETYPE_VERTICAL_PERCENT:
                e = g.height * e / 100;
                break;
            case CCB_SIZETYPE_MULTIPLY_RESOLUTION:
                var h = cc.BuilderReader.getResolutionScale();
                d *= h, e *= h;
                break;
            default:
                cc.log("Unknown CCB type.")
        }
        return cc.size(d, e)
    },
    parsePropTypeScaleLock: function(a, b, c, d) {
        var e = c.readFloat(),
            f = c.readFloat(),
            g = c.readInt(!1);
        return cc.setRelativeScale(a, e, f, g, d), c.getAnimatedProperties().indexOf(d) > -1 && c.getAnimationManager().setBaseValue([e, f, g], a, d), g == CCB_SCALETYPE_MULTIPLY_RESOLUTION && (e *= cc.BuilderReader.getResolutionScale(), f *= cc.BuilderReader.getResolutionScale()), [e, f]
    },
    parsePropTypeFloat: function(a, b, c) {
        return c.readFloat()
    },
    parsePropTypeDegrees: function(a, b, c, d) {
        var e = c.readFloat();
        return c.getAnimatedProperties().indexOf(d) > -1 && c.getAnimationManager().setBaseValue(e, a, d), e
    },
    parsePropTypeFloatScale: function(a, b, c) {
        var d = c.readFloat(),
            e = c.readInt(!1);
        return e == CCB_SCALETYPE_MULTIPLY_RESOLUTION && (d *= cc.BuilderReader.getResolutionScale()), d
    },
    parsePropTypeInteger: function(a, b, c) {
        return c.readInt(!0)
    },
    parsePropTypeIntegerLabeled: function(a, b, c) {
        return c.readInt(!0)
    },
    parsePropTypeFloatVar: function(a, b, c) {
        var d = c.readFloat(),
            e = c.readFloat();
        return [d, e]
    },
    parsePropTypeCheck: function(a, b, c, d) {
        var e = c.readBool();
        return c.getAnimatedProperties().indexOf(d) > -1 && c.getAnimationManager().setBaseValue(e, a, d), e
    },
    parsePropTypeSpriteFrame: function(a, b, c, d) {
        var e, f = c.readCachedString(),
            g = c.readCachedString();
        if (null != g && 0 != g.length) {
            if (0 == f.length) {
                g = c.getCCBRootPath() + g;
                var h = cc.textureCache.addImage(g),
                    i = h.getContentSize(),
                    j = cc.rect(0, 0, i.width, i.height);
                e = new cc.SpriteFrame(h, j)
            } else {
                var k = cc.spriteFrameCache;
                f = c.getCCBRootPath() + f, -1 == c.getLoadedSpriteSheet().indexOf(f) && (k.addSpriteFrames(f), c.getLoadedSpriteSheet().push(f)), e = k.getSpriteFrame(g)
            }
            c.getAnimatedProperties().indexOf(d) > -1 && c.getAnimationManager().setBaseValue(e, a, d)
        }
        return e
    },
    parsePropTypeAnimation: function(a, b, c) {
        var d = c.getCCBRootPath() + c.readCachedString(),
            e = c.readCachedString(),
            f = null;
        if (e = cc.BuilderReader.lastPathComponent(e), d = cc.BuilderReader.lastPathComponent(d), null != e && "" != e) {
            var g = cc.animationCache;
            g.addAnimations(d), f = g.getAnimation(e)
        }
        return f
    },
    parsePropTypeTexture: function(a, b, c) {
        var d = c.getCCBRootPath() + c.readCachedString();
        return "" != d ? cc.textureCache.addImage(d) : null
    },
    parsePropTypeByte: function(a, b, c, d) {
        var e = c.readByte();
        return c.getAnimatedProperties().indexOf(d) > -1 && c.getAnimationManager().setBaseValue(e, a, d), e
    },
    parsePropTypeColor3: function(a, b, c, d) {
        var e = c.readByte(),
            f = c.readByte(),
            g = c.readByte(),
            h = {
                r: e,
                g: f,
                b: g
            };
        return c.getAnimatedProperties().indexOf(d) > -1 && c.getAnimationManager().setBaseValue(cc.Color3BWapper.create(h), a, d), h
    },
    parsePropTypeColor4FVar: function(a, b, c) {
        var d = 0 | 255 * c.readFloat(),
            e = 0 | 255 * c.readFloat(),
            f = 0 | 255 * c.readFloat(),
            g = c.readFloat();
        g = 1 >= g ? 0 | 255 * g : g;
        var h = 0 | 255 * c.readFloat(),
            i = 0 | 255 * c.readFloat(),
            j = 0 | 255 * c.readFloat(),
            k = c.readFloat();
        k = 1 >= k ? 0 | 255 * k : k;
        var l = [];
        return l[0] = {
            r: d,
            g: e,
            b: f,
            a: g
        }, l[1] = {
            r: h,
            g: i,
            b: j,
            a: k
        }, l
    },
    parsePropTypeFlip: function(a, b, c) {
        var d = c.readBool(),
            e = c.readBool();
        return [d, e]
    },
    parsePropTypeBlendFunc: function(a, b, c) {
        var d = c.readInt(!1),
            e = c.readInt(!1);
        return new cc.BlendFunc(d, e)
    },
    parsePropTypeFntFile: function(a, b, c) {
        return c.readCachedString()
    },
    parsePropTypeString: function(a, b, c) {
        return c.readCachedString()
    },
    parsePropTypeText: function(a, b, c) {
        return c.readCachedString()
    },
    parsePropTypeFontTTF: function(a, b, c) {
        return c.readCachedString()
    },
    parsePropTypeBlock: function(a, b, c) {
        var d = c.readCachedString(),
            e = c.readInt(!1);
        if (e !== CCB_TARGETTYPE_NONE) {
            var f = null;
            if (c.isJSControlled()) e === CCB_TARGETTYPE_DOCUMENTROOT ? (c.addDocumentCallbackNode(a), c.addDocumentCallbackName(d), c.addDocumentCallbackControlEvents(0)) : (c.addOwnerCallbackNode(a), c.addOwnerCallbackName(d), c.addOwnerCallbackControlEvents(0));
            else if (e === CCB_TARGETTYPE_DOCUMENTROOT ? f = c.getAnimationManager().getRootNode() : e === CCB_TARGETTYPE_OWNER && (f = c.getOwner()), null != f)
                if (d.length > 0) {
                    var g = 0;
                    if (null != f && f.onResolveCCBCCMenuItemSelector && (g = f.onResolveCCBCCMenuItemSelector(f, d)), 0 == g) {
                        var h = c.getCCBSelectorResolver();
                        null != h && (g = h.onResolveCCBCCMenuItemSelector(f, d))
                    }
                    if (0 != g) return new BlockData(g, f);
                    cc.log("Skipping selector '" + d + "' since no CCBSelectorResolver is present.")
                } else cc.log("Unexpected empty selector.");
            else cc.log("Unexpected NULL target for selector.")
        }
        return null
    },
    parsePropTypeBlockCCControl: function(a, b, c) {
        var d = c.readCachedString(),
            e = c.readInt(!1),
            f = c.readInt(!1);
        if (e !== CCB_TARGETTYPE_NONE)
            if (c.isJSControlled()) e == CCB_TARGETTYPE_DOCUMENTROOT ? (c.addDocumentCallbackNode(a), c.addDocumentCallbackName(d), c.addDocumentCallbackControlEvents(f)) : (c.addOwnerCallbackNode(a), c.addOwnerCallbackName(d), c.addOwnerCallbackControlEvents(f));
            else {
                var g = null;
                if (e == CCB_TARGETTYPE_DOCUMENTROOT ? g = c.getAnimationManager().getRootNode() : e == CCB_TARGETTYPE_OWNER && (g = c.getOwner()), null != g)
                    if (d.length > 0) {
                        var h = 0;
                        if (null != g && g.onResolveCCBCCControlSelector && (h = g.onResolveCCBCCControlSelector(g, d)), 0 == h) {
                            var i = c.getCCBSelectorResolver();
                            null != i && (h = i.onResolveCCBCCControlSelector(g, d))
                        }
                        if (0 != h) return new BlockCCControlData(h, g, f);
                        cc.log("Skipping selector '" + d + "' since no CCBSelectorResolver is present.")
                    } else cc.log("Unexpected empty selector.");
                else cc.log("Unexpected NULL target for selector.")
            }
        return null
    },
    parsePropTypeCCBFile: function(a, b, c) {
        var d = c.getCCBRootPath() + c.readCachedString(),
            e = cc.BuilderReader.deletePathExtension(d);
        d = e + ".ccbi";
        var f = new cc.BuilderReader(c),
            g = cc.loader.getRes(d);
        if (!g) {
            var h = cc.loader.getUrl(d);
            g = cc.loader.loadBinarySync(h), cc.loader.cache[d] = g
        }
        f.initWithData(g, c.getOwner()), f.getAnimationManager().setRootContainerSize(b.getContentSize()), f.setAnimationManagers(c.getAnimationManagers()), f.getAnimationManager().setOwner(c.getOwner());
        var i = f.readFileWithCleanUp(!1);
        return c.setAnimationManagers(f.getAnimationManagers()), i && -1 != f.getAnimationManager().getAutoPlaySequenceId() && f.getAnimationManager().runAnimations(f.getAnimationManager().getAutoPlaySequenceId(), 0), i
    },
    parsePropTypeFloatXY: function(a, b, c) {
        var d = c.readFloat(),
            e = c.readFloat();
        return [d, e]
    },
    onHandlePropTypePosition: function(a, b, c, d) {
        c === PROPERTY_POSITION ? a.setPosition(d) : ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypePoint: function(a, b, c, d) {
        c === PROPERTY_ANCHORPOINT ? a.setAnchorPoint(d) : ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypePointLock: function(a, b, c) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeSize: function(a, b, c, d) {
        c === PROPERTY_CONTENTSIZE ? a.setContentSize(d) : ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeScaleLock: function(a, b, c, d) {
        c === PROPERTY_SCALE ? (a.setScaleX(d[0]), a.setScaleY(d[1])) : ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeFloatXY: function(a, b, c, d) {
        if (c === PROPERTY_SKEW) a.setSkewX(d[0]), a.setSkewY(d[1]);
        else {
            var e = c + "X",
                f = c + "Y";
            a[e] && a[f] || ASSERT_FAIL_UNEXPECTED_PROPERTY(c), a[e](d[0]), a[f](d[1])
        }
    },
    onHandlePropTypeFloat: function(a, b, c, d) {
        this._customProperties.setObject(d, c)
    },
    onHandlePropTypeDegrees: function(a, b, c, d) {
        c === PROPERTY_ROTATION ? a.setRotation(d) : ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeFloatScale: function(a, b, c) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeInteger: function(a, b, c, d) {
        c === PROPERTY_TAG ? a.setTag(d) : ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeIntegerLabeled: function(a, b, c) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeFloatVar: function(a, b, c) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeCheck: function(a, b, c, d) {
        c === PROPERTY_VISIBLE ? a.setVisible(d) : c === PROPERTY_IGNOREANCHORPOINTFORPOSITION ? a.ignoreAnchorPointForPosition(d) : ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeSpriteFrame: function(a, b, c) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeAnimation: function(a, b, c) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeTexture: function(a, b, c) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeByte: function(a, b, c) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeColor3: function(a, b, c) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeColor4FVar: function(a, b, c) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeFlip: function(a, b, c) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeBlendFunc: function(a, b, c) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeFntFile: function(a, b, c) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeString: function(a, b, c, d) {
        this._customProperties.setObject(d, c)
    },
    onHandlePropTypeText: function(a, b, c) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeFontTTF: function(a, b, c) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeBlock: function(a, b, c) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeBlockCCControl: function(a, b, c) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    },
    onHandlePropTypeCCBFile: function(a, b, c) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(c)
    }
}), cc.NodeLoader.loader = function() {
    return new cc.NodeLoader
}, cc.NodeLoaderListener = cc.Class.extend({
    onNodeLoaded: function() {}
}), cc.BuilderSelectorResolver = cc.Class.extend({
    onResolveCCBCCMenuItemSelector: function() {},
    onResolveCCBCCCallFuncSelector: function() {},
    onResolveCCBCCControlSelector: function() {}
}), cc.BuilderScriptOwnerProtocol = cc.Class.extend({
    createNew: function() {}
}), cc.BuilderMemberVariableAssigner = cc.Class.extend({
    onAssignCCBMemberVariable: function() {
        return !1
    },
    onAssignCCBCustomProperty: function() {
        return !1
    }
});
var PROPERTY_CCBFILE = "ccbFile";
cc.BuilderFileLoader = cc.NodeLoader.extend({
    _createCCNode: function() {
        return cc.BuilderFile.create()
    },
    onHandlePropTypeCCBFile: function(a, b, c, d, e) {
        c == PROPERTY_CCBFILE ? a.setCCBFileNode(d) : cc.NodeLoader.prototype.onHandlePropTypeCCBFile.call(this, a, b, c, d, e)
    }
}), cc.BuilderFileLoader.loader = function() {
    return new cc.BuilderFileLoader
};
var PROPERTY_ENABLED = "enabled",
    PROPERTY_SELECTED = "selected",
    PROPERTY_CCCONTROL = "ccControl";
cc.ControlLoader = cc.NodeLoader.extend({
    _createCCNode: function() {},
    onHandlePropTypeBlockCCControl: function(a, b, c, d, e) {
        c == PROPERTY_CCCONTROL ? a.addTargetWithActionForControlEvents(d.target, d.selCCControlHandler, d.controlEvents) : cc.NodeLoader.prototype.onHandlePropTypeBlockCCControl.call(this, a, b, c, d, e)
    },
    onHandlePropTypeCheck: function(a, b, c, d, e) {
        c == PROPERTY_ENABLED ? a.setEnabled(d) : c == PROPERTY_SELECTED ? a.setSelected(d) : cc.NodeLoader.prototype.onHandlePropTypeCheck.call(this, a, b, c, d, e)
    }
});
var PROPERTY_ZOOMONTOUCHDOWN = "zoomOnTouchDown",
    PROPERTY_TITLE_NORMAL = "title|1",
    PROPERTY_TITLE_HIGHLIGHTED = "title|2",
    PROPERTY_TITLE_DISABLED = "title|3",
    PROPERTY_TITLECOLOR_NORMAL = "titleColor|1",
    PROPERTY_TITLECOLOR_HIGHLIGHTED = "titleColor|2",
    PROPERTY_TITLECOLOR_DISABLED = "titleColor|3",
    PROPERTY_TITLETTF_NORMAL = "titleTTF|1",
    PROPERTY_TITLETTF_HIGHLIGHTED = "titleTTF|2",
    PROPERTY_TITLETTF_DISABLED = "titleTTF|3",
    PROPERTY_TITLETTFSIZE_NORMAL = "titleTTFSize|1",
    PROPERTY_TITLETTFSIZE_HIGHLIGHTED = "titleTTFSize|2",
    PROPERTY_TITLETTFSIZE_DISABLED = "titleTTFSize|4",
    PROPERTY_LABELANCHORPOINT = "labelAnchorPoint",
    PROPERTY_PREFEREDSIZE = "preferedSize",
    PROPERTY_BACKGROUNDSPRITEFRAME_NORMAL = "backgroundSpriteFrame|1",
    PROPERTY_BACKGROUNDSPRITEFRAME_HIGHLIGHTED = "backgroundSpriteFrame|2",
    PROPERTY_BACKGROUNDSPRITEFRAME_DISABLED = "backgroundSpriteFrame|3";
cc.ControlButtonLoader = cc.ControlLoader.extend({
    _createCCNode: function() {
        return new cc.ControlButton
    },
    onHandlePropTypeCheck: function(a, b, c, d, e) {
        c == PROPERTY_ZOOMONTOUCHDOWN ? a.setZoomOnTouchDown(d) : cc.ControlLoader.prototype.onHandlePropTypeCheck.call(this, a, b, c, d, e)
    },
    onHandlePropTypeString: function(a, b, c, d, e) {
        c == PROPERTY_TITLE_NORMAL ? a.setTitleForState(d, cc.CONTROL_STATE_NORMAL) : c == PROPERTY_TITLE_HIGHLIGHTED ? a.setTitleForState(d, cc.CONTROL_STATE_HIGHLIGHTED) : c == PROPERTY_TITLE_DISABLED ? a.setTitleForState(d, cc.CONTROL_STATE_DISABLED) : cc.ControlLoader.prototype.onHandlePropTypeString.call(this, a, b, c, d, e)
    },
    onHandlePropTypeFontTTF: function(a, b, c, d, e) {
        c == PROPERTY_TITLETTF_NORMAL ? a.setTitleTTFForState(d, cc.CONTROL_STATE_NORMAL) : c == PROPERTY_TITLETTF_HIGHLIGHTED ? a.setTitleTTFForState(d, cc.CONTROL_STATE_HIGHLIGHTED) : c == PROPERTY_TITLETTF_DISABLED ? a.setTitleTTFForState(d, cc.CONTROL_STATE_DISABLED) : cc.ControlLoader.prototype.onHandlePropTypeFontTTF.call(this, a, b, c, d, e)
    },
    onHandlePropTypeFloatScale: function(a, b, c, d, e) {
        c == PROPERTY_TITLETTFSIZE_NORMAL ? a.setTitleTTFSizeForState(d, cc.CONTROL_STATE_NORMAL) : c == PROPERTY_TITLETTFSIZE_HIGHLIGHTED ? a.setTitleTTFSizeForState(d, cc.CONTROL_STATE_HIGHLIGHTED) : c == PROPERTY_TITLETTFSIZE_DISABLED ? a.setTitleTTFSizeForState(d, cc.CONTROL_STATE_DISABLED) : cc.ControlLoader.prototype.onHandlePropTypeFloatScale.call(this, a, b, c, d, e)
    },
    onHandlePropTypePoint: function(a, b, c, d, e) {
        c == PROPERTY_LABELANCHORPOINT ? a.setLabelAnchorPoint(d) : cc.ControlLoader.prototype.onHandlePropTypePoint.call(this, a, b, c, d, e)
    },
    onHandlePropTypeSize: function(a, b, c, d, e) {
        c == PROPERTY_PREFEREDSIZE ? a.setPreferredSize(d) : cc.ControlLoader.prototype.onHandlePropTypeSize.call(this, a, b, c, d, e)
    },
    onHandlePropTypeSpriteFrame: function(a, b, c, d, e) {
        c == PROPERTY_BACKGROUNDSPRITEFRAME_NORMAL ? null != d && a.setBackgroundSpriteFrameForState(d, cc.CONTROL_STATE_NORMAL) : c == PROPERTY_BACKGROUNDSPRITEFRAME_HIGHLIGHTED ? null != d && a.setBackgroundSpriteFrameForState(d, cc.CONTROL_STATE_HIGHLIGHTED) : c == PROPERTY_BACKGROUNDSPRITEFRAME_DISABLED ? null != d && a.setBackgroundSpriteFrameForState(d, cc.CONTROL_STATE_DISABLED) : cc.ControlLoader.prototype.onHandlePropTypeSpriteFrame.call(this, a, b, c, d, e)
    },
    onHandlePropTypeColor3: function(a, b, c, d, e) {
        c == PROPERTY_TITLECOLOR_NORMAL ? a.setTitleColorForState(d, cc.CONTROL_STATE_NORMAL) : c == PROPERTY_TITLECOLOR_HIGHLIGHTED ? a.setTitleColorForState(d, cc.CONTROL_STATE_HIGHLIGHTED) : c == PROPERTY_TITLECOLOR_DISABLED ? a.setTitleColorForState(d, cc.CONTROL_STATE_DISABLED) : cc.ControlLoader.prototype.onHandlePropTypeColor3.call(this, a, b, c, d, e)
    }
}), cc.ControlButtonLoader.loader = function() {
    return new cc.ControlButtonLoader
};
var PROPERTY_CONTAINER = "container",
    PROPERTY_DIRECTION = "direction",
    PROPERTY_CLIPSTOBOUNDS = "clipsToBounds",
    PROPERTY_BOUNCES = "bounces",
    PROPERTY_SCALE = "scale";
cc.ScrollViewLoader = cc.NodeLoader.extend({
    _createCCNode: function() {
        return new cc.ScrollView
    },
    onHandlePropTypeSize: function(a, b, c, d, e) {
        c == PROPERTY_CONTENTSIZE ? a.setViewSize(d) : cc.NodeLoader.prototype.onHandlePropTypeSize.call(this, a, b, c, d, e)
    },
    onHandlePropTypeCCBFile: function(a, b, c, d, e) {
        c == PROPERTY_CONTAINER ? (a.setContainer(d), a.updateInset()) : cc.NodeLoader.prototype.onHandlePropTypeCCBFile.call(this, a, b, c, d, e)
    },
    onHandlePropTypeCheck: function(a, b, c, d, e) {
        c == PROPERTY_CLIPSTOBOUNDS ? a.setClippingToBounds(d) : c == PROPERTY_BOUNCES ? a.setBounceable(d) : cc.NodeLoader.prototype.onHandlePropTypeCheck.call(this, a, b, c, d, e)
    },
    onHandlePropTypeFloat: function(a, b, c, d, e) {
        c == PROPERTY_SCALE ? a.setScale(d) : cc.NodeLoader.prototype.onHandlePropTypeFloat.call(this, a, b, c, d, e)
    },
    onHandlePropTypeIntegerLabeled: function(a, b, c, d, e) {
        c == PROPERTY_DIRECTION ? a.setDirection(d) : cc.NodeLoader.prototype.onHandlePropTypeIntegerLabeled.call(this, a, b, c, d, e)
    }
}), cc.ScrollViewLoader.loader = function() {
    return new cc.ScrollViewLoader
};
var PROPERTY_CONTENTSIZE = "contentSize",
    PROPERTY_SPRITEFRAME = "spriteFrame",
    PROPERTY_COLOR = "color",
    PROPERTY_OPACITY = "opacity",
    PROPERTY_BLENDFUNC = "blendFunc",
    PROPERTY_INSETLEFT = "insetLeft",
    PROPERTY_INSETTOP = "insetTop",
    PROPERTY_INSETRIGHT = "insetRight",
    PROPERTY_INSETBOTTOM = "insetBottom";
cc.Scale9SpriteLoader = cc.NodeLoader.extend({
    _createCCNode: function() {
        var a = new cc.Scale9Sprite;
        return a.setAnchorPoint(0, 0), a
    },
    onHandlePropTypeColor3: function(a, b, c, d, e) {
        c == PROPERTY_COLOR ? (255 !== d.r || 255 !== d.g || 255 !== d.b) && a.setColor(d) : cc.NodeLoader.prototype.onHandlePropTypeColor3.call(this, a, b, c, d, e)
    },
    onHandlePropTypeByte: function(a, b, c, d, e) {
        c == PROPERTY_OPACITY ? a.setOpacity(d) : cc.NodeLoader.prototype.onHandlePropTypeByte.call(this, a, b, c, d, e)
    },
    onHandlePropTypeBlendFunc: function(a, b, c, d, e) {
        c == PROPERTY_BLENDFUNC || cc.NodeLoader.prototype.onHandlePropTypeBlendFunc.call(this, a, b, c, d, e)
    },
    onHandlePropTypeSpriteFrame: function(a, b, c, d, e) {
        c == PROPERTY_SPRITEFRAME ? a.setSpriteFrame(d) : cc.NodeLoader.prototype.onHandlePropTypeSpriteFrame.call(this, a, b, c, d, e)
    },
    onHandlePropTypeSize: function(a, b, c, d, e) {
        c == PROPERTY_CONTENTSIZE || (c == PROPERTY_PREFEREDSIZE ? a.setPreferredSize(d) : cc.NodeLoader.prototype.onHandlePropTypeSize.call(this, a, b, c, d, e))
    },
    onHandlePropTypeFloat: function(a, b, c, d, e) {
        c == PROPERTY_INSETLEFT ? a.setInsetLeft(d) : c == PROPERTY_INSETTOP ? a.setInsetTop(d) : c == PROPERTY_INSETRIGHT ? a.setInsetRight(d) : c == PROPERTY_INSETBOTTOM ? a.setInsetBottom(d) : cc.NodeLoader.prototype.onHandlePropTypeFloat.call(this, a, b, c, d, e)
    }
}), cc.Scale9SpriteLoader.loader = function() {
    return new cc.Scale9SpriteLoader
};
var PROPERTY_FLIP = "flip",
    PROPERTY_DISPLAYFRAME = "displayFrame",
    PROPERTY_COLOR = "color",
    PROPERTY_OPACITY = "opacity",
    PROPERTY_BLENDFUNC = "blendFunc";
cc.SpriteLoader = cc.NodeLoader.extend({
    _createCCNode: function() {
        return new cc.Sprite
    },
    onHandlePropTypeColor3: function(a, b, c, d, e) {
        c === PROPERTY_COLOR ? (255 !== d.r || 255 !== d.g || 255 !== d.b) && a.setColor(d) : cc.NodeLoader.prototype.onHandlePropTypeColor3.call(this, a, b, c, d, e)
    },
    onHandlePropTypeByte: function(a, b, c, d, e) {
        c === PROPERTY_OPACITY ? a.setOpacity(d) : cc.NodeLoader.prototype.onHandlePropTypeByte.call(this, a, b, c, d, e)
    },
    onHandlePropTypeBlendFunc: function(a, b, c, d, e) {
        c === PROPERTY_BLENDFUNC ? a.setBlendFunc(d) : cc.NodeLoader.prototype.onHandlePropTypeBlendFunc.call(this, a, b, c, d, e)
    },
    onHandlePropTypeSpriteFrame: function(a, b, c, d, e) {
        c === PROPERTY_DISPLAYFRAME ? d ? a.setSpriteFrame(d) : cc.log("ERROR: SpriteFrame is null") : cc.NodeLoader.prototype.onHandlePropTypeSpriteFrame.call(this, a, b, c, d, e)
    },
    onHandlePropTypeFlip: function(a, b, c, d, e) {
        c === PROPERTY_FLIP ? (a.setFlippedX(d[0]), a.setFlippedY(d[1])) : cc.NodeLoader.prototype.onHandlePropTypeFlip.call(this, a, b, c, d, e)
    }
}), cc.SpriteLoader.loader = function() {
    return new cc.SpriteLoader
};
var PROPERTY_TOUCH_ENABLED = "touchEnabled",
    PROPERTY_IS_TOUCH_ENABLED = "isTouchEnabled",
    PROPERTY_ACCELEROMETER_ENABLED = "accelerometerEnabled",
    PROPERTY_IS_ACCELEROMETER_ENABLED = "isAccelerometerEnabled",
    PROPERTY_IS_MOUSE_ENABLED = "isMouseEnabled",
    PROPERTY_MOUSE_ENABLED = "mouseEnabled",
    PROPERTY_KEYBOARD_ENABLED = "keyboardEnabled",
    PROPERTY_IS_KEYBOARD_ENABLED = "isKeyboardEnabled";
cc.LayerLoader = cc.NodeLoader.extend({
    _createCCNode: function() {
        var a = new cc.Layer;
        return a.setContentSize(0, 0), a
    },
    onHandlePropTypeCheck: function(a, b, c, d, e) {
        c === PROPERTY_TOUCH_ENABLED || c === PROPERTY_IS_TOUCH_ENABLED || c === PROPERTY_ACCELEROMETER_ENABLED || c === PROPERTY_IS_ACCELEROMETER_ENABLED || c === PROPERTY_MOUSE_ENABLED || c === PROPERTY_IS_MOUSE_ENABLED || (c === PROPERTY_KEYBOARD_ENABLED || c === PROPERTY_IS_KEYBOARD_ENABLED ? a.setKeyboardEnabled && !cc.sys.isNative ? a.setKeyboardEnabled(d) : cc.log("The property '" + PROPERTY_IS_KEYBOARD_ENABLED + "' is not supported!") : cc.NodeLoader.prototype.onHandlePropTypeCheck.call(this, a, b, c, d, e))
    }
}), cc.LayerLoader.loader = function() {
    return new cc.LayerLoader
}, cc.LayerColorLoader = cc.LayerLoader.extend({
    _createCCNode: function() {
        return new cc.LayerColor
    },
    onHandlePropTypeColor3: function(a, b, c, d, e) {
        c === PROPERTY_COLOR ? a.setColor(d) : cc.LayerLoader.prototype.onHandlePropTypeColor3.call(this, a, b, c, d, e)
    },
    onHandlePropTypeByte: function(a, b, c, d, e) {
        c === PROPERTY_OPACITY ? a.setOpacity(d) : cc.LayerLoader.prototype.onHandlePropTypeByte.call(this, a, b, c, d, e)
    },
    onHandlePropTypeBlendFunc: function(a, b, c, d, e) {
        c === PROPERTY_BLENDFUNC ? a.setBlendFunc(d) : cc.LayerLoader.prototype.onHandlePropTypeBlendFunc.call(this, a, b, c, d, e)
    }
}), cc.LayerColorLoader.loader = function() {
    return new cc.LayerColorLoader
};
var PROPERTY_STARTCOLOR = "startColor",
    PROPERTY_ENDCOLOR = "endColor",
    PROPERTY_STARTOPACITY = "startOpacity",
    PROPERTY_ENDOPACITY = "endOpacity",
    PROPERTY_VECTOR = "vector";
cc.LayerGradientLoader = cc.LayerLoader.extend({
    _createCCNode: function() {
        return new cc.LayerGradient
    },
    onHandlePropTypeColor3: function(a, b, c, d, e) {
        c === PROPERTY_STARTCOLOR ? a.setStartColor(d) : c == PROPERTY_ENDCOLOR ? a.setEndColor(d) : cc.LayerLoader.prototype.onHandlePropTypeColor3.call(this, a, b, c, d, e)
    },
    onHandlePropTypeByte: function(a, b, c, d, e) {
        c === PROPERTY_STARTOPACITY ? a.setStartOpacity(d) : c === PROPERTY_ENDOPACITY ? a.setEndOpacity(d) : cc.LayerLoader.prototype.onHandlePropTypeByte.call(this, a, b, c, d, e)
    },
    onHandlePropTypePoint: function(a, b, c, d, e) {
        c === PROPERTY_VECTOR ? a.setVector(d) : cc.LayerLoader.prototype.onHandlePropTypePoint.call(this, a, b, c, d, e)
    },
    onHandlePropTypeBlendFunc: function(a, b, c, d, e) {
        c === PROPERTY_BLENDFUNC ? a.setBlendFunc(d) : cc.LayerLoader.prototype.onHandlePropTypeBlendFunc.call(this, a, b, c, d, e)
    }
}), cc.LayerGradientLoader.loader = function() {
    return new cc.LayerGradientLoader
}, cc.MenuLoader = cc.LayerLoader.extend({
    _createCCNode: function() {
        var a = new cc.Menu;
        return a.setContentSize(0, 0), a
    }
}), cc.MenuLoader.loader = function() {
    return new cc.MenuLoader
};
var PROPERTY_BLOCK = "block",
    PROPERTY_ISENABLED = "isEnabled";
cc.MenuItemLoader = cc.NodeLoader.extend({
    _createCCNode: function() {
        return null
    },
    onHandlePropTypeBlock: function(a, b, c, d, e) {
        c === PROPERTY_BLOCK ? null != d && a.setTarget(d.selMenuHander, d.target) : cc.NodeLoader.prototype.onHandlePropTypeBlock.call(this, a, b, c, d, e)
    },
    onHandlePropTypeCheck: function(a, b, c, d, e) {
        c === PROPERTY_ISENABLED ? a.setEnabled(d) : cc.NodeLoader.prototype.onHandlePropTypeCheck.call(this, a, b, c, d, e)
    }
});
var PROPERTY_NORMALDISPLAYFRAME = "normalSpriteFrame",
    PROPERTY_SELECTEDDISPLAYFRAME = "selectedSpriteFrame",
    PROPERTY_DISABLEDDISPLAYFRAME = "disabledSpriteFrame";
cc.MenuItemImageLoader = cc.MenuItemLoader.extend({
    _createCCNode: function() {
        return new cc.MenuItemImage
    },
    onHandlePropTypeSpriteFrame: function(a, b, c, d, e) {
        c === PROPERTY_NORMALDISPLAYFRAME ? null != d && a.setNormalSpriteFrame(d) : c === PROPERTY_SELECTEDDISPLAYFRAME ? null != d && a.setSelectedSpriteFrame(d) : c === PROPERTY_DISABLEDDISPLAYFRAME ? null != d && a.setDisabledSpriteFrame(d) : cc.MenuItemLoader.prototype.onHandlePropTypeSpriteFrame.call(this, a, b, c, d, e)
    }
}), cc.MenuItemImageLoader.loader = function() {
    return new cc.MenuItemImageLoader
};
var PROPERTY_FONTNAME = "fontName",
    PROPERTY_FONTSIZE = "fontSize",
    PROPERTY_HORIZONTALALIGNMENT = "horizontalAlignment",
    PROPERTY_VERTICALALIGNMENT = "verticalAlignment",
    PROPERTY_STRING = "string",
    PROPERTY_DIMENSIONS = "dimensions";
cc.LabelTTFLoader = cc.NodeLoader.extend({
    _createCCNode: function() {
        return new cc.LabelTTF
    },
    onHandlePropTypeColor3: function(a, b, c, d, e) {
        c === PROPERTY_COLOR ? (255 !== d.r || 255 !== d.g || 255 !== d.b) && a.setColor(d) : cc.NodeLoader.prototype.onHandlePropTypeColor3.call(this, a, b, c, d, e)
    },
    onHandlePropTypeByte: function(a, b, c, d, e) {
        c === PROPERTY_OPACITY ? a.setOpacity(d) : cc.NodeLoader.prototype.onHandlePropTypeByte.call(this, a, b, c, d, e)
    },
    onHandlePropTypeBlendFunc: function(a, b, c, d, e) {
        c === PROPERTY_BLENDFUNC ? a.setBlendFunc(d) : cc.NodeLoader.prototype.onHandlePropTypeBlendFunc.call(this, a, b, c, d, e)
    },
    onHandlePropTypeFontTTF: function(a, b, c, d, e) {
        c === PROPERTY_FONTNAME ? a.setFontName(d) : cc.NodeLoader.prototype.onHandlePropTypeFontTTF.call(this, a, b, c, d, e)
    },
    onHandlePropTypeText: function(a, b, c, d, e) {
        c === PROPERTY_STRING ? a.setString(d) : cc.NodeLoader.prototype.onHandlePropTypeText.call(this, a, b, c, d, e)
    },
    onHandlePropTypeFloatScale: function(a, b, c, d, e) {
        c === PROPERTY_FONTSIZE ? a.setFontSize(d) : cc.NodeLoader.prototype.onHandlePropTypeFloatScale.call(this, a, b, c, d, e)
    },
    onHandlePropTypeIntegerLabeled: function(a, b, c, d, e) {
        c === PROPERTY_HORIZONTALALIGNMENT ? a.setHorizontalAlignment(d) : c === PROPERTY_VERTICALALIGNMENT ? a.setVerticalAlignment(d) : cc.NodeLoader.prototype.onHandlePropTypeIntegerLabeled.call(this, a, b, c, d, e)
    },
    onHandlePropTypeSize: function(a, b, c, d, e) {
        c === PROPERTY_DIMENSIONS ? a.setDimensions(d) : cc.NodeLoader.prototype.onHandlePropTypeSize.call(this, a, b, c, d, e)
    }
}), cc.LabelTTFLoader.loader = function() {
    return new cc.LabelTTFLoader
};
var PROPERTY_FNTFILE = "fntFile";
cc.LabelBMFontLoader = cc.NodeLoader.extend({
    _createCCNode: function() {
        return new cc.LabelBMFont
    },
    onHandlePropTypeColor3: function(a, b, c, d, e) {
        c === PROPERTY_COLOR ? (255 !== d.r || 255 !== d.g || 255 !== d.b) && a.setColor(d) : cc.NodeLoader.prototype.onHandlePropTypeColor3.call(this, a, b, c, d, e)
    },
    onHandlePropTypeByte: function(a, b, c, d, e) {
        c === PROPERTY_OPACITY ? a.setOpacity(d) : cc.NodeLoader.prototype.onHandlePropTypeByte.call(this, a, b, c, d, e)
    },
    onHandlePropTypeBlendFunc: function(a, b, c, d, e) {
        c === PROPERTY_BLENDFUNC ? a.setBlendFunc(d) : cc.NodeLoader.prototype.onHandlePropTypeBlendFunc.call(this, a, b, c, d, e)
    },
    onHandlePropTypeFntFile: function(a, b, c, d, e) {
        c === PROPERTY_FNTFILE ? a.setFntFile(d) : cc.NodeLoader.prototype.onHandlePropTypeFntFile.call(this, a, b, c, d, e)
    },
    onHandlePropTypeText: function(a, b, c, d, e) {
        c === PROPERTY_STRING ? a.setString(d) : cc.NodeLoader.prototype.onHandlePropTypeText.call(this, a, b, c, d, e)
    }
}), cc.LabelBMFontLoader.loader = function() {
    return new cc.LabelBMFontLoader
};
var PROPERTY_EMITERMODE = "emitterMode",
    PROPERTY_POSVAR = "posVar",
    PROPERTY_EMISSIONRATE = "emissionRate",
    PROPERTY_DURATION = "duration",
    PROPERTY_TOTALPARTICLES = "totalParticles",
    PROPERTY_LIFE = "life",
    PROPERTY_STARTSIZE = "startSize",
    PROPERTY_ENDSIZE = "endSize",
    PROPERTY_STARTSPIN = "startSpin",
    PROPERTY_ENDSPIN = "endSpin",
    PROPERTY_ANGLE = "angle",
    PROPERTY_GRAVITY = "gravity",
    PROPERTY_SPEED = "speed",
    PROPERTY_TANGENTIALACCEL = "tangentialAccel",
    PROPERTY_RADIALACCEL = "radialAccel",
    PROPERTY_TEXTURE = "texture",
    PROPERTY_STARTRADIUS = "startRadius",
    PROPERTY_ENDRADIUS = "endRadius",
    PROPERTY_ROTATEPERSECOND = "rotatePerSecond";
cc.ParticleSystemLoader = cc.NodeLoader.extend({
    _createCCNode: function() {
        return new cc.ParticleSystem
    },
    onHandlePropTypeIntegerLabeled: function(a, b, c, d, e) {
        c === PROPERTY_EMITERMODE ? a.setEmitterMode(d) : cc.NodeLoader.prototype.onHandlePropTypeIntegerLabeled.call(this, a, b, c, d, e)
    },
    onHandlePropTypePoint: function(a, b, c, d, e) {
        c === PROPERTY_POSVAR ? a.setPosVar(d) : c === PROPERTY_GRAVITY ? a.setGravity(d) : cc.NodeLoader.prototype.onHandlePropTypePoint.call(this, a, b, c, d, e)
    },
    onHandlePropTypeFloat: function(a, b, c, d, e) {
        c === PROPERTY_EMISSIONRATE ? a.setEmissionRate(d) : c === PROPERTY_DURATION ? a.setDuration(d) : cc.NodeLoader.prototype.onHandlePropTypeFloat.call(this, a, b, c, d, e)
    },
    onHandlePropTypeInteger: function(a, b, c, d, e) {
        c === PROPERTY_TOTALPARTICLES ? a.setTotalParticles(d) : cc.NodeLoader.prototype.onHandlePropTypeInteger.call(this, a, b, c, d, e)
    },
    onHandlePropTypeFloatVar: function(a, b, c, d, e) {
        c === PROPERTY_LIFE ? (a.setLife(d[0]), a.setLifeVar(d[1])) : c === PROPERTY_STARTSIZE ? (a.setStartSize(d[0]), a.setStartSizeVar(d[1])) : c === PROPERTY_ENDSIZE ? (a.setEndSize(d[0]), a.setEndSizeVar(d[1])) : c === PROPERTY_STARTSPIN ? (a.setStartSpin(d[0]), a.setStartSpinVar(d[1])) : c === PROPERTY_ENDSPIN ? (a.setEndSpin(d[0]), a.setEndSpinVar(d[1])) : c === PROPERTY_ANGLE ? (a.setAngle(d[0]), a.setAngleVar(d[1])) : c === PROPERTY_SPEED ? (a.setSpeed(d[0]), a.setSpeedVar(d[1])) : c === PROPERTY_TANGENTIALACCEL ? (a.setTangentialAccel(d[0]), a.setTangentialAccelVar(d[1])) : c === PROPERTY_RADIALACCEL ? (a.setRadialAccel(d[0]), a.setRadialAccelVar(d[1])) : c === PROPERTY_STARTRADIUS ? (a.setStartRadius(d[0]), a.setStartRadiusVar(d[1])) : c === PROPERTY_ENDRADIUS ? (a.setEndRadius(d[0]), a.setEndRadiusVar(d[1])) : c === PROPERTY_ROTATEPERSECOND ? (a.setRotatePerSecond(d[0]), a.setRotatePerSecondVar(d[1])) : cc.NodeLoader.prototype.onHandlePropTypeFloatVar.call(this, a, b, c, d, e)
    },
    onHandlePropTypeColor4FVar: function(a, b, c, d, e) {
        c === PROPERTY_STARTCOLOR ? (a.setStartColor(d[0]), a.setStartColorVar(d[1])) : c === PROPERTY_ENDCOLOR ? (a.setEndColor(d[0]), a.setEndColorVar(d[1])) : cc.NodeLoader.prototype.onHandlePropTypeColor4FVar.call(this, a, b, c, d, e)
    },
    onHandlePropTypeBlendFunc: function(a, b, c, d, e) {
        c === PROPERTY_BLENDFUNC ? a.setBlendFunc(d) : cc.NodeLoader.prototype.onHandlePropTypeBlendFunc.call(this, a, b, c, d, e)
    },
    onHandlePropTypeTexture: function(a, b, c, d, e) {
        c === PROPERTY_TEXTURE ? a.setTexture(d) : cc.NodeLoader.prototype.onHandlePropTypeTexture.call(this, a, b, c, d, e)
    }
}), cc.ParticleSystemLoader.loader = function() {
    return new cc.ParticleSystemLoader
}, cc.NodeLoaderLibrary = cc.Class.extend({
    _ccNodeLoaders: null,
    ctor: function() {
        this._ccNodeLoaders = {}
    },
    registerDefaultCCNodeLoaders: function() {
        this.registerCCNodeLoader("CCNode", cc.NodeLoader.loader()), this.registerCCNodeLoader("CCLayer", cc.LayerLoader.loader()), this.registerCCNodeLoader("CCLayerColor", cc.LayerColorLoader.loader()), this.registerCCNodeLoader("CCLayerGradient", cc.LayerGradientLoader.loader()), this.registerCCNodeLoader("CCSprite", cc.SpriteLoader.loader()), this.registerCCNodeLoader("CCLabelBMFont", cc.LabelBMFontLoader.loader()), this.registerCCNodeLoader("CCLabelTTF", cc.LabelTTFLoader.loader()), this.registerCCNodeLoader("CCScale9Sprite", cc.Scale9SpriteLoader.loader()), this.registerCCNodeLoader("CCScrollView", cc.ScrollViewLoader.loader()), this.registerCCNodeLoader("CCBFile", cc.BuilderFileLoader.loader()), this.registerCCNodeLoader("CCMenu", cc.MenuLoader.loader()), this.registerCCNodeLoader("CCMenuItemImage", cc.MenuItemImageLoader.loader()), this.registerCCNodeLoader("CCControlButton", cc.ControlButtonLoader.loader()), this.registerCCNodeLoader("CCParticleSystemQuad", cc.ParticleSystemLoader.loader())
    },
    registerCCNodeLoader: function(a, b) {
        this._ccNodeLoaders[a] = b
    },
    unregisterCCNodeLoader: function(a) {
        this._ccNodeLoaders[a] && delete this._ccNodeLoaders[a]
    },
    getCCNodeLoader: function(a) {
        return this._ccNodeLoaders[a] ? this._ccNodeLoaders[a] : null
    },
    purge: function(a) {
        if (a)
            for (var b in this._ccNodeLoaders) delete this._ccNodeLoaders[b];
        this._ccNodeLoaders = {}
    }
}), cc.NodeLoaderLibrary.sSharedCCNodeLoaderLibrary = null, cc.NodeLoaderLibrary.library = function() {
    return new cc.NodeLoaderLibrary
}, cc.NodeLoaderLibrary.sharedCCNodeLoaderLibrary = function() {
    return null == cc.NodeLoaderLibrary.sSharedCCNodeLoaderLibrary && (cc.NodeLoaderLibrary.sSharedCCNodeLoaderLibrary = new cc.NodeLoaderLibrary, cc.NodeLoaderLibrary.sSharedCCNodeLoaderLibrary.registerDefaultCCNodeLoaders()), cc.NodeLoaderLibrary.sSharedCCNodeLoaderLibrary
}, cc.NodeLoaderLibrary.purgeSharedCCNodeLoaderLibrary = function() {
    cc.NodeLoaderLibrary.sSharedCCNodeLoaderLibrary = null
}, cc.NodeLoaderLibrary.newDefaultCCNodeLoaderLibrary = function() {
    var a = cc.NodeLoaderLibrary.library();
    return a.registerDefaultCCNodeLoaders(), a
};
var CCB_VERSION = 5,
    CCB_PROPTYPE_POSITION = 0,
    CCB_PROPTYPE_SIZE = 1,
    CCB_PROPTYPE_POINT = 2,
    CCB_PROPTYPE_POINTLOCK = 3,
    CCB_PROPTYPE_SCALELOCK = 4,
    CCB_PROPTYPE_DEGREES = 5,
    CCB_PROPTYPE_INTEGER = 6,
    CCB_PROPTYPE_FLOAT = 7,
    CCB_PROPTYPE_FLOATVAR = 8,
    CCB_PROPTYPE_CHECK = 9,
    CCB_PROPTYPE_SPRITEFRAME = 10,
    CCB_PROPTYPE_TEXTURE = 11,
    CCB_PROPTYPE_BYTE = 12,
    CCB_PROPTYPE_COLOR3 = 13,
    CCB_PROPTYPE_COLOR4VAR = 14,
    CCB_PROPTYPE_FLIP = 15,
    CCB_PROPTYPE_BLENDMODE = 16,
    CCB_PROPTYPE_FNTFILE = 17,
    CCB_PROPTYPE_TEXT = 18,
    CCB_PROPTYPE_FONTTTF = 19,
    CCB_PROPTYPE_INTEGERLABELED = 20,
    CCB_PROPTYPE_BLOCK = 21,
    CCB_PROPTYPE_ANIMATION = 22,
    CCB_PROPTYPE_CCBFILE = 23,
    CCB_PROPTYPE_STRING = 24,
    CCB_PROPTYPE_BLOCKCCCONTROL = 25,
    CCB_PROPTYPE_FLOATSCALE = 26,
    CCB_PROPTYPE_FLOATXY = 27,
    CCB_FLOAT0 = 0,
    CCB_FLOAT1 = 1,
    CCB_FLOAT_MINUS1 = 2,
    CCB_FLOAT05 = 3,
    CCB_FLOAT_INTEGER = 4,
    CCB_FLOAT_FULL = 5,
    CCB_PLATFORM_ALL = 0,
    CCB_PLATFORM_IOS = 1,
    CCB_PLATFORM_MAC = 2,
    CCB_TARGETTYPE_NONE = 0,
    CCB_TARGETTYPE_DOCUMENTROOT = 1,
    CCB_TARGETTYPE_OWNER = 2,
    CCB_KEYFRAME_EASING_INSTANT = 0,
    CCB_KEYFRAME_EASING_LINEAR = 1,
    CCB_KEYFRAME_EASING_CUBIC_IN = 2,
    CCB_KEYFRAME_EASING_CUBIC_OUT = 3,
    CCB_KEYFRAME_EASING_CUBIC_INOUT = 4,
    CCB_KEYFRAME_EASING_ELASTIC_IN = 5,
    CCB_KEYFRAME_EASING_ELASTIC_OUT = 6,
    CCB_KEYFRAME_EASING_ELASTIC_INOUT = 7,
    CCB_KEYFRAME_EASING_BOUNCE_IN = 8,
    CCB_KEYFRAME_EASING_BOUNCE_OUT = 9,
    CCB_KEYFRAME_EASING_BOUNCE_INOUT = 10,
    CCB_KEYFRAME_EASING_BACK_IN = 11,
    CCB_KEYFRAME_EASING_BACK_OUT = 12,
    CCB_KEYFRAME_EASING_BACK_INOUT = 13,
    CCB_POSITIONTYPE_RELATIVE_BOTTOM_LEFT = 0,
    CCB_POSITIONTYPE_RELATIVE_TOP_LEFT = 1,
    CCB_POSITIONTYPE_RELATIVE_TOP_RIGHT = 2,
    CCB_POSITIONTYPE_RELATIVE_BOTTOM_RIGHT = 3,
    CCB_POSITIONTYPE_PERCENT = 4,
    CCB_POSITIONTYPE_MULTIPLY_RESOLUTION = 5,
    CCB_SIZETYPE_ABSOLUTE = 0,
    CCB_SIZETYPE_PERCENT = 1,
    CCB_SIZETYPE_RELATIVE_CONTAINER = 2,
    CCB_SIZETYPE_HORIZONTAL_PERCENT = 3,
    CCB_SIZETYPE_VERTICAL_PERCENT = 4,
    CCB_SIZETYPE_MULTIPLY_RESOLUTION = 5,
    CCB_SCALETYPE_ABSOLUTE = 0,
    CCB_SCALETYPE_MULTIPLY_RESOLUTION = 1;
cc.BuilderFile = cc.Node.extend({
    _ccbFileNode: null,
    getCCBFileNode: function() {
        return this._ccbFileNode
    },
    setCCBFileNode: function(a) {
        this._ccbFileNode = a
    }
}), cc.BuilderFile.create = function() {
    return new cc.BuilderFile
}, cc.BuilderReader = cc.Class.extend({
    _jsControlled: !1,
    _data: null,
    _ccbRootPath: "",
    _bytes: 0,
    _currentByte: 0,
    _currentBit: 0,
    _stringCache: null,
    _loadedSpriteSheets: null,
    _owner: null,
    _animationManager: null,
    _animationManagers: null,
    _animatedProps: null,
    _ccNodeLoaderLibrary: null,
    _ccNodeLoaderListener: null,
    _ccbMemberVariableAssigner: null,
    _ccbSelectorResolver: null,
    _ownerOutletNames: null,
    _ownerOutletNodes: null,
    _nodesWithAnimationManagers: null,
    _animationManagerForNodes: null,
    _ownerCallbackNames: null,
    _ownerCallbackNodes: null,
    _ownerCallbackEvents: null,
    _readNodeGraphFromData: !1,
    ctor: function(a, b, c, d) {
        if (this._stringCache = [], this._loadedSpriteSheets = [], this._currentBit = -1, this._currentByte = -1, 0 != arguments.length)
            if (a instanceof cc.BuilderReader) {
                var e = a;
                this._loadedSpriteSheets = e._loadedSpriteSheets, this._ccNodeLoaderLibrary = e._ccNodeLoaderLibrary, this._ccbMemberVariableAssigner = e._ccbMemberVariableAssigner, this._ccbSelectorResolver = e._ccbSelectorResolver, this._ccNodeLoaderListener = e._ccNodeLoaderListener, this._ownerCallbackNames = e._ownerCallbackNames, this._ownerCallbackNodes = e._ownerCallbackNodes, this._ownerCallbackEvents = e._ownerCallbackEvents, this._ownerOutletNames = e._ownerOutletNames, this._ownerOutletNodes = e._ownerOutletNodes, this._ccbRootPath = e._ccbRootPath
            } else this._ccNodeLoaderLibrary = a, this._ccbMemberVariableAssigner = b, this._ccbSelectorResolver = c, this._ccNodeLoaderListener = d
    },
    getCCBRootPath: function() {
        return this._ccbRootPath
    },
    setCCBRootPath: function(a) {
        this._ccbRootPath = a
    },
    initWithData: function(a, b) {
        return this._animationManager = new cc.BuilderAnimationManager, this._data = a, this._bytes = a.length, this._currentBit = 0, this._currentByte = 0, this._owner = b, this._animationManager.setRootContainerSize(cc.director.getWinSize()), !0
    },
    _loadBinarySync: function(a) {
        var b = this.getXMLHttpRequest(),
            c = "load " + a + " failed!";
        b.open("GET", a, !1);
        var d = null;
        if (/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
            if (b.setRequestHeader("Accept-Charset", "x-user-defined"), b.send(null), 200 != b.status) return cc.log(c), null;
            var e = cc._convertResponseBodyToText(b.responseBody);
            e && (d = this._stringConvertToArray(e), this._fileDataCache[a] = d)
        } else {
            if (b.overrideMimeType && b.overrideMimeType("text/plain; charset=x-user-defined"), b.send(null), 200 != b.status) return cc.log(c), null;
            d = this._stringConvertToArray(b.responseText), this._fileDataCache[a] = d
        }
        return d
    },
    readNodeGraphFromFile: function(a, b, c, d) {
        null == c ? c = cc.director.getWinSize() : c instanceof cc.BuilderAnimationManager && (d = c, c = cc.director.getWinSize());
        var e = cc.loader.getRes(a);
        if (!e) {
            var f = cc.loader.getUrl(a);
            e = cc.loader.loadBinarySync(f), cc.loader.cache[a] = e
        }
        return this.readNodeGraphFromData(e, b, c, d)
    },
    readNodeGraphFromData: function(a, b, c) {
        this.initWithData(a, b);
        var d = this._animationManager;
        d.setRootContainerSize(c), d.setOwner(b), this._ownerOutletNames = [], this._ownerOutletNodes = [], this._ownerCallbackNames = [], this._ownerCallbackNodes = [], this._ownerCallbackEvents = [], this._animationManagers = new cc._Dictionary;
        var e = this.readFileWithCleanUp(!0);
        if (e && -1 != d.getAutoPlaySequenceId() && d.runAnimations(d.getAutoPlaySequenceId(), 0), this._jsControlled) {
            for (var f = [], g = [], h = this._animationManagers, i = h.allKeys(), j = 0; j < i.length; j++) f.push(i[j]), g.push(h.objectForKey(i[j]));
            this._nodesWithAnimationManagers = f, this._animationManagerForNodes = g
        }
        return e
    },
    createSceneWithNodeGraphFromFile: function(a, b, c, d) {
        var e = this.readNodeGraphFromFile(a, b, c, d),
            f = new cc.Scene;
        return f.addChild(e), f
    },
    getCCBMemberVariableAssigner: function() {
        return this._ccbMemberVariableAssigner
    },
    getCCBSelectorResolver: function() {
        return this._ccbSelectorResolver
    },
    getAnimationManager: function() {
        return this._animationManager
    },
    setAnimationManager: function(a) {
        this._animationManager = a
    },
    getAnimatedProperties: function() {
        return this._animatedProps
    },
    getLoadedSpriteSheet: function() {
        return this._loadedSpriteSheets
    },
    getOwner: function() {
        return this._owner
    },
    readInt: function(a) {
        for (var b = 0; !this._getBit();) b++;
        for (var c = 0, d = b - 1; d >= 0; d--) this._getBit() && (c |= 1 << d);
        c |= 1 << b;
        var e;
        if (a) {
            var f = c % 2;
            e = f ? 0 | c / 2 : 0 | -c / 2
        } else e = c - 1;
        return this._alignBits(), e
    },
    readByte: function() {
        var a = this._data[this._currentByte];
        return this._currentByte++, a
    },
    readBool: function() {
        return 0 != this.readByte()
    },
    readFloat: function() {
        var a = this.readByte();
        switch (a) {
            case CCB_FLOAT0:
                return 0;
            case CCB_FLOAT1:
                return 1;
            case CCB_FLOAT_MINUS1:
                return -1;
            case CCB_FLOAT05:
                return .5;
            case CCB_FLOAT_INTEGER:
                return this.readInt(!0);
            default:
                var b = this._decodeFloat(23, 8);
                return b
        }
    },
    _decodeFloat: function(a, b) {
        var c = a + b + 1,
            d = c >> 3;
        this._checkSize(c);
        var e = Math.pow(2, b - 1) - 1,
            f = this._readBitsOnly(a + b, 1, d),
            g = this._readBitsOnly(a, b, d),
            h = 0,
            i = 2,
            j = 0;
        do
            for (var k = this._readByteOnly(++j, d), l = a % 8 || 8, m = 1 << l; m >>= 1;) k & m && (h += 1 / i), i *= 2; while (a -= l);
        return this._currentByte += d, g == (e << 1) + 1 ? h ? 0 / 0 : f ? -1 / 0 : +1 / 0 : (1 + -2 * f) * (g || h ? g ? Math.pow(2, g - e) * (1 + h) : Math.pow(2, -e + 1) * h : 0)
    },
    _readBitsOnly: function(a, b, c) {
        var d = (a + b) % 8,
            e = a % 8,
            f = c - (a >> 3) - 1,
            g = c + (-(a + b) >> 3),
            h = f - g,
            i = this._readByteOnly(f, c) >> e & (1 << (h ? 8 - e : b)) - 1;
        for (h && d && (i += (this._readByteOnly(g++, c) & (1 << d) - 1) << (h-- << 3) - e); h;) i += this._shl(this._readByteOnly(g++, c), (h-- << 3) - e);
        return i
    },
    _readByteOnly: function(a, b) {
        return this._data[this._currentByte + b - a - 1]
    },
    _shl: function(a, b) {
        for (++b; --b; a = 1073741824 == (1073741824 & (a %= 2147483648)) ? 2 * a : 2 * (a - 1073741824) + 2147483647 + 1);
        return a
    },
    _checkSize: function(a) {
        if (!(this._currentByte + Math.ceil(a / 8) < this._data.length)) throw new Error("Index out of bound")
    },
    readCachedString: function() {
        return this._stringCache[this.readInt(!1)]
    },
    isJSControlled: function() {
        return this._jsControlled
    },
    getOwnerCallbackNames: function() {
        return this._ownerCallbackNames
    },
    getOwnerCallbackNodes: function() {
        return this._ownerCallbackNodes
    },
    getOwnerCallbackControlEvents: function() {
        return this._ownerCallbackEvents
    },
    getOwnerOutletNames: function() {
        return this._ownerOutletNames
    },
    getOwnerOutletNodes: function() {
        return this._ownerOutletNodes
    },
    getNodesWithAnimationManagers: function() {
        return this._nodesWithAnimationManagers
    },
    getAnimationManagersForNodes: function() {
        return this._animationManagerForNodes
    },
    getAnimationManagers: function() {
        return this._animationManagers
    },
    setAnimationManagers: function(a) {
        this._animationManagers = a
    },
    addOwnerCallbackName: function(a) {
        this._ownerCallbackNames.push(a)
    },
    addOwnerCallbackNode: function(a) {
        this._ownerCallbackNodes.push(a)
    },
    addOwnerCallbackControlEvents: function(a) {
        this._ownerCallbackEvents.push(a)
    },
    addDocumentCallbackName: function(a) {
        this._animationManager.addDocumentCallbackName(a)
    },
    addDocumentCallbackNode: function(a) {
        this._animationManager.addDocumentCallbackNode(a)
    },
    addDocumentCallbackControlEvents: function(a) {
        this._animationManager.addDocumentCallbackControlEvents(a)
    },
    readFileWithCleanUp: function(a) {
        if (!this._readHeader()) return null;
        if (!this._readStringCache()) return null;
        if (!this._readSequences()) return null;
        var b = this._readNodeGraph();
        return this._animationManagers.setObject(this._animationManager, b), a && this._cleanUpNodeGraph(b), b
    },
    addOwnerOutletName: function(a) {
        this._ownerOutletNames.push(a)
    },
    addOwnerOutletNode: function(a) {
        null != a && this._ownerOutletNodes.push(a)
    },
    _cleanUpNodeGraph: function(a) {
        a.userObject = null;
        for (var b = a.getChildren(), c = 0, d = b.length; d > c; c++) this._cleanUpNodeGraph(b[c])
    },
    _readCallbackKeyframesForSeq: function(a) {
        var b = this.readInt(!1);
        if (!b) return !0;
        for (var c = new cc.BuilderSequenceProperty, d = this._jsControlled, e = this._animationManager, f = c.getKeyframes(), g = 0; b > g; g++) {
            var h = this.readFloat(),
                i = this.readCachedString(),
                j = this.readInt(!1),
                k = [i, j],
                l = new cc.BuilderKeyframe;
            l.setTime(h), l.setValue(k), d && e.getKeyframeCallbacks().push(j + ":" + i), f.push(l)
        }
        return a.setCallbackChannel(c), !0
    },
    _readSoundKeyframesForSeq: function(a) {
        var b = this.readInt(!1);
        if (!b) return !0;
        for (var c = new cc.BuilderSequenceProperty, d = c.getKeyframes(), e = 0; b > e; e++) {
            var f = this.readFloat(),
                g = this.readCachedString(),
                h = this.readFloat(),
                i = this.readFloat(),
                j = this.readFloat(),
                k = [g, h, i, j],
                l = new cc.BuilderKeyframe;
            l.setTime(f), l.setValue(k), d.push(l)
        }
        return a.setSoundChannel(c), !0
    },
    _readSequences: function() {
        for (var a = this._animationManager.getSequences(), b = this.readInt(!1), c = 0; b > c; c++) {
            var d = new cc.BuilderSequence;
            if (d.setDuration(this.readFloat()), d.setName(this.readCachedString()), d.setSequenceId(this.readInt(!1)), d.setChainedSequenceId(this.readInt(!0)), !this._readCallbackKeyframesForSeq(d)) return !1;
            if (!this._readSoundKeyframesForSeq(d)) return !1;
            a.push(d)
        }
        return this._animationManager.setAutoPlaySequenceId(this.readInt(!0)), !0
    },
    readKeyframe: function(a) {
        var b = new cc.BuilderKeyframe;
        b.setTime(this.readFloat());
        var c = this.readInt(!1),
            d = 0,
            e = null;
        if ((c === CCB_KEYFRAME_EASING_CUBIC_IN || c === CCB_KEYFRAME_EASING_CUBIC_OUT || c === CCB_KEYFRAME_EASING_CUBIC_INOUT || c === CCB_KEYFRAME_EASING_ELASTIC_IN || c === CCB_KEYFRAME_EASING_ELASTIC_OUT || c === CCB_KEYFRAME_EASING_ELASTIC_INOUT) && (d = this.readFloat()), b.setEasingType(c), b.setEasingOpt(d), a == CCB_PROPTYPE_CHECK) e = this.readBool();
        else if (a == CCB_PROPTYPE_BYTE) e = this.readByte();
        else if (a == CCB_PROPTYPE_COLOR3) {
            var f = cc.color(this.readByte(), this.readByte(), this.readByte());
            e = cc.Color3BWapper.create(f)
        } else if (a == CCB_PROPTYPE_FLOATXY) e = [this.readFloat(), this.readFloat()];
        else if (a == CCB_PROPTYPE_DEGREES) e = this.readFloat();
        else if (a == CCB_PROPTYPE_SCALELOCK || a == CCB_PROPTYPE_POSITION || a == CCB_PROPTYPE_FLOATXY) e = [this.readFloat(), this.readFloat()];
        else if (a == CCB_PROPTYPE_SPRITEFRAME) {
            var g = this.readCachedString(),
                h = this.readCachedString();
            if ("" == g) {
                h = this._ccbRootPath + h;
                var i = cc.textureCache.addImage(h),
                    j = i.getContentSize(),
                    k = cc.rect(0, 0, j.width, j.height);
                e = new cc.SpriteFrame(i, k)
            } else {
                g = this._ccbRootPath + g;
                var l = cc.spriteFrameCache; - 1 == this._loadedSpriteSheets.indexOf(g) && (l.addSpriteFrames(g), this._loadedSpriteSheets.push(g)), e = l.getSpriteFrame(h)
            }
        }
        return b.setValue(e), b
    },
    _readHeader: function() {
        if (null == this._data) return !1;
        var a = this._readStringFromBytes(this._currentByte, 4, !0);
        if (this._currentByte += 4, "ccbi" != a) return !1;
        var b = this.readInt(!1);
        return b != CCB_VERSION ? (cc.log("WARNING! Incompatible ccbi file version (file: " + b + " reader: " + CCB_VERSION + ")"), !1) : (this._jsControlled = this.readBool(), this._animationManager._jsControlled = this._jsControlled, !0)
    },
    _readStringFromBytes: function(a, b, c) {
        c = c || !1;
        var d, e = "",
            f = this._data,
            g = this._currentByte;
        if (c)
            for (d = b - 1; d >= 0; d--) e += String.fromCharCode(f[g + d]);
        else
            for (d = 0; b > d; d++) e += String.fromCharCode(f[g + d]);
        return e
    },
    _readStringCache: function() {
        for (var a = this.readInt(!1), b = 0; a > b; b++) this._readStringCacheEntry();
        return !0
    },
    _readStringCacheEntry: function() {
        for (var a = this.readByte(), b = this.readByte(), c = a << 8 | b, d = "", e = this._data, f = this._currentByte, g = 0; c > g; g++) {
            var h = e[f + g].toString("16").toUpperCase();
            h = h.length > 1 ? h : "0" + h, d += "%" + h
        }
        d = decodeURIComponent(d), this._currentByte += c, this._stringCache.push(d)
    },
    _readNodeGraph: function(a) {
        var b, c = this.readCachedString(),
            d = this._jsControlled,
            e = this._animationManager;
        d && (b = this.readCachedString());
        var f, g = this.readInt(!1);
        g != CCB_TARGETTYPE_NONE && (f = this.readCachedString());
        var h = this._ccNodeLoaderLibrary.getCCNodeLoader(c);
        h || (h = this._ccNodeLoaderLibrary.getCCNodeLoader("CCNode"));
        var i = h.loadCCNode(a, this);
        e.getRootNode() || e.setRootNode(i), d && i == e.getRootNode() && e.setDocumentControllerName(b);
        var j = new cc._Dictionary;
        this._animatedProps = [];
        var k, l = this._animatedProps,
            m = this.readInt(!1);
        for (k = 0; m > k; ++k) {
            for (var n = this.readInt(!1), o = new cc._Dictionary, p = this.readInt(!1), q = 0; p > q; ++q) {
                var r = new cc.BuilderSequenceProperty;
                r.setName(this.readCachedString()), r.setType(this.readInt(!1)), l.push(r.getName());
                for (var s = this.readInt(!1), t = r.getKeyframes(), u = 0; s > u; ++u) {
                    var v = this.readKeyframe(r.getType());
                    t.push(v)
                }
                o.setObject(r, r.getName())
            }
            j.setObject(o, n)
        }
        j.count() > 0 && e.addNode(i, j), h.parseProperties(i, a, this);
        var w = i instanceof cc.BuilderFile;
        if (w) {
            var x = i.getCCBFileNode();
            x.setPosition(i.getPosition()), x.setRotation(i.getRotation()), x.setScaleX(i.getScaleX()), x.setScaleY(i.getScaleY()), x.setTag(i.getTag()), x.setVisible(!0), e.moveAnimationsFromNode(i, x), i.setCCBFileNode(null), i = x
        }
        var y = null,
            z = null;
        if (g != CCB_TARGETTYPE_NONE)
            if (d) g == CCB_TARGETTYPE_DOCUMENTROOT ? (e.addDocumentOutletName(f), e.addDocumentOutletNode(i)) : (this._ownerOutletNames.push(f), this._ownerOutletNodes.push(i));
            else if (g === CCB_TARGETTYPE_DOCUMENTROOT ? y = e.getRootNode() : g === CCB_TARGETTYPE_OWNER && (y = this._owner), null != y) {
            var A = !1;
            null != y && y.onAssignCCBMemberVariable && (A = y.onAssignCCBMemberVariable(y, f, i)), z = this._ccbMemberVariableAssigner, !A && null != z && z.onAssignCCBMemberVariable && z.onAssignCCBMemberVariable(y, f, i)
        }
        if (h.getCustomProperties().length > 0) {
            var B = !1;
            if (!d && (y = i, null != y && null != y.onAssignCCBCustomProperty)) {
                var C = h.getCustomProperties(),
                    D = C.allKeys();
                for (k = 0; k < D.length; k++) {
                    var E = C.objectForKey(D[k]);
                    B = y.onAssignCCBCustomProperty(y, D[k], E), z = this._ccbMemberVariableAssigner, B || null == z || null == z.onAssignCCBCustomProperty || (B = z.onAssignCCBCustomProperty(y, D[k], E))
                }
            }
        }
        this._animatedProps = null;
        var F = this.readInt(!1);
        for (k = 0; F > k; k++) {
            var G = this._readNodeGraph(i);
            i.addChild(G)
        }
        return w || (null != i && i.onNodeLoaded ? i.onNodeLoaded(i, h) : null != this._ccNodeLoaderListener && this._ccNodeLoaderListener.onNodeLoaded(i, h)), i
    },
    _getBit: function() {
        var a = 0 != (this._data[this._currentByte] & 1 << this._currentBit);
        if (this._currentBit++, this._currentBit >= 8 && (this._currentBit = 0, this._currentByte++, this._currentByte > this._data.length)) throw "out of the data bound";
        return a
    },
    _alignBits: function() {
        this._currentBit && (this._currentBit = 0, this._currentByte++)
    },
    _readUTF8: function() {}
}), cc.BuilderReader._ccbResolutionScale = 1, cc.BuilderReader.setResolutionScale = function(a) {
    cc.BuilderReader._ccbResolutionScale = a
}, cc.BuilderReader.getResolutionScale = function() {
    return cc.BuilderReader._ccbResolutionScale
}, cc.BuilderReader.loadAsScene = function(a, b, c, d) {
    d = d || cc.BuilderReader.getResourcePath();
    var e = cc.BuilderReader.load(a, b, c, d),
        f = new cc.Scene;
    return f.addChild(e), f
}, cc.BuilderReader._controllerClassCache = {}, cc.BuilderReader.registerController = function(a, b) {
    cc.BuilderReader._controllerClassCache[a] = cc.Class.extend(b)
}, cc.BuilderReader.load = function(a, b, c, d) {
    d = d || cc.BuilderReader.getResourcePath();
    var e = new cc.BuilderReader(cc.NodeLoaderLibrary.newDefaultCCNodeLoaderLibrary());
    e.setCCBRootPath(d), (a.length < 5 || a.toLowerCase().lastIndexOf(".ccbi") != a.length - 5) && (a += ".ccbi");
    var f, g, h, i, j, k, l = e.readNodeGraphFromFile(a, b, c);
    if (b) {
        var m = e.getOwnerCallbackNames(),
            n = e.getOwnerCallbackNodes(),
            o = e.getOwnerCallbackControlEvents();
        for (f = 0; f < m.length; f++) g = m[f], h = n[f], i = o[f], h instanceof cc.ControlButton ? h.addTargetWithActionForControlEvents(b, b[g], i) : h.setCallback(b[g], b);
        var p = e.getOwnerOutletNames(),
            q = e.getOwnerOutletNodes();
        for (f = 0; f < p.length; f++) j = p[f], k = q[f], b[j] = k
    }
    var r = e.getNodesWithAnimationManagers(),
        s = e.getAnimationManagersForNodes();
    if (!r || !s) return l;
    var t = cc.BuilderReader._controllerClassCache;
    for (f = 0; f < r.length; f++) {
        var u, v = r[f],
            w = s[f];
        v.animationManager = w;
        var x = w.getDocumentControllerName();
        if (x) {
            var y = t[x];
            if (!y) throw "Can not find controller : " + x;
            var z = new y;
            z.controllerName = x, v.controller = z, z.rootNode = v;
            var A = w.getDocumentCallbackNames(),
                B = w.getDocumentCallbackNodes(),
                C = w.getDocumentCallbackControlEvents();
            for (u = 0; u < A.length; u++) g = A[u], h = B[u], i = C[u], h instanceof cc.ControlButton ? h.addTargetWithActionForControlEvents(z, z[g], i) : h.setCallback(z[g], z);
            var D = w.getDocumentOutletNames(),
                E = w.getDocumentOutletNodes();
            for (u = 0; u < D.length; u++) j = D[u], k = E[u], z[j] = k;
            z.onDidLoadFromCCB && cc.isFunction(z.onDidLoadFromCCB) && z.onDidLoadFromCCB();
            var F = w.getKeyframeCallbacks();
            for (u = 0; u < F.length; u++) {
                var G = F[u].split(":"),
                    H = G[0],
                    I = G[1];
                1 == H ? w.setCallFunc(cc.callFunc(z[I], z), F[u]) : 2 == H && b && w.setCallFunc(cc.callFunc(b[I], b), F[u])
            }
        }
    }
    return l
}, cc.BuilderReader._resourcePath = "", cc.BuilderReader.setResourcePath = function(a) {
    cc.BuilderReader._resourcePath = a
}, cc.BuilderReader.getResourcePath = function() {
    return cc.BuilderReader._resourcePath
}, cc.BuilderReader.lastPathComponent = function(a) {
    var b = a.lastIndexOf("/");
    return -1 != b ? a.substring(b + 1, a.length - b) : a
}, cc.BuilderReader.deletePathExtension = function(a) {
    var b = a.lastIndexOf(".");
    return -1 != b ? a.substring(0, b) : a
}, cc.BuilderReader.toLowerCase = function(a) {
    return a.toLowerCase()
}, cc.BuilderReader.endsWith = function(a, b) {
    return a.length >= b.length ? 0 == a.lastIndexOf(b) : !1
}, cc.BuilderReader.concat = function(a, b) {
    return a + b
}, cc.loader.register(["ccbi"], cc._binaryLoader), cc.INT_VALUE = 0, cc.FLOAT_VALUE = 1, cc.POINTER_VALUE = 2, cc.BOOL_VALUE = 3, cc.UNSIGNEDCHAR_VALUE = 4, cc.Color3BWapper = cc.Class.extend({
    _color: null,
    ctor: function() {
        this._color = cc.color(0, 0, 0)
    },
    getColor: function() {
        return this._color
    }
}), cc.Color3BWapper.create = function(a) {
    var b = new cc.Color3BWapper;
    return b && (b._color.r = a.r, b._color.g = a.g, b._color.b = a.b), b
}, cc.BuilderValue = cc.Class.extend({
    _value: null,
    _type: 0,
    getIntValue: function() {},
    getFloatValue: function() {},
    getBoolValue: function() {},
    getByteValue: function() {},
    getPointer: function() {},
    getValue: function() {
        return this._value
    }
}), cc.BuilderValue.create = function() {
    return new cc.BuilderValue
}, cc.BuilderKeyframe = cc.Class.extend({
    _value: null,
    _time: 0,
    _easingType: 0,
    _easingOpt: 0,
    getValue: function() {
        return this._value
    },
    setValue: function(a) {
        this._value = a
    },
    getTime: function() {
        return this._time
    },
    setTime: function(a) {
        this._time = a
    },
    getEasingType: function() {
        return this._easingType
    },
    setEasingType: function(a) {
        this._easingType = a
    },
    getEasingOpt: function() {
        return this._easingOpt
    },
    setEasingOpt: function(a) {
        this._easingOpt = a
    }
}), cc.BuilderSequence = cc.Class.extend({
    _duration: 0,
    _name: "",
    _sequenceId: 0,
    _chainedSequenceId: 0,
    _callbackChannel: null,
    _soundChannel: null,
    ctor: function() {
        this._name = ""
    },
    getDuration: function() {
        return this._duration
    },
    setDuration: function(a) {
        this._duration = a
    },
    getName: function() {
        return this._name
    },
    setName: function(a) {
        this._name = a
    },
    getSequenceId: function() {
        return this._sequenceId
    },
    setSequenceId: function(a) {
        this._sequenceId = a
    },
    getChainedSequenceId: function() {
        return this._chainedSequenceId
    },
    setChainedSequenceId: function(a) {
        this._chainedSequenceId = a
    },
    getCallbackChannel: function() {
        return this._callbackChannel
    },
    setCallbackChannel: function(a) {
        this._callbackChannel = a
    },
    getSoundChannel: function() {
        return this._soundChannel
    },
    setSoundChannel: function(a) {
        this._soundChannel = a
    }
}), cc.BuilderSequenceProperty = cc.Class.extend({
    _name: null,
    _type: 0,
    _keyFrames: null,
    ctor: function() {
        this.init()
    },
    init: function() {
        this._keyFrames = [], this._name = ""
    },
    getName: function() {
        return this._name
    },
    setName: function(a) {
        this._name = a
    },
    getType: function() {
        return this._type
    },
    setType: function(a) {
        this._type = a
    },
    getKeyframes: function() {
        return this._keyFrames
    }
}), cc.getAbsolutePosition = function(a, b, c) {
    var d = cc.p(0, 0);
    if (b === CCB_POSITIONTYPE_RELATIVE_BOTTOM_LEFT) d = a;
    else if (b === CCB_POSITIONTYPE_RELATIVE_TOP_LEFT) d.x = a.x, d.y = c.height - a.y;
    else if (b === CCB_POSITIONTYPE_RELATIVE_TOP_RIGHT) d.x = c.width - a.x, d.y = c.height - a.y;
    else if (b === CCB_POSITIONTYPE_RELATIVE_BOTTOM_RIGHT) d.x = c.width - a.x, d.y = a.y;
    else if (b === CCB_POSITIONTYPE_PERCENT) d.x = c.width * a.x / 100, d.y = c.height * a.y / 100;
    else if (b === CCB_POSITIONTYPE_MULTIPLY_RESOLUTION) {
        var e = cc.BuilderReader.getResolutionScale();
        d.x = a.x * e, d.y = a.y * e
    }
    return d
}, cc._getAbsolutePosition = function(a, b, c, d) {
    var e = cc.p(0, 0);
    if (c === CCB_POSITIONTYPE_RELATIVE_BOTTOM_LEFT) e.x = a, e.y = b;
    else if (c === CCB_POSITIONTYPE_RELATIVE_TOP_LEFT) e.x = a, e.y = d.height - b;
    else if (c === CCB_POSITIONTYPE_RELATIVE_TOP_RIGHT) e.x = d.width - a, e.y = d.height - b;
    else if (c === CCB_POSITIONTYPE_RELATIVE_BOTTOM_RIGHT) e.x = d.width - a, e.y = b;
    else if (c === CCB_POSITIONTYPE_PERCENT) e.x = d.width * a / 100, e.y = d.height * b / 100;
    else if (c === CCB_POSITIONTYPE_MULTIPLY_RESOLUTION) {
        var f = cc.BuilderReader.getResolutionScale();
        e.x = a * f, e.y = b * f
    }
    return e
}, cc.setRelativeScale = function(a, b, c, d) {
    if (!a) throw "cc.setRelativeScale(): node should be non-null";
    if (d === CCB_POSITIONTYPE_MULTIPLY_RESOLUTION) {
        var e = cc.BuilderReader.getResolutionScale();
        b *= e, c *= e
    }
    a.setScaleX(b), a.setScaleY(c)
}, cc.BuilderAnimationManagerDelegate = cc.Class.extend({
    completedAnimationSequenceNamed: function() {}
}), cc.BuilderAnimationManager = cc.Class.extend({
    _sequences: null,
    _nodeSequences: null,
    _baseValues: null,
    _autoPlaySequenceId: 0,
    _rootNode: null,
    _owner: null,
    _rootContainerSize: null,
    _delegate: null,
    _runningSequence: null,
    _documentOutletNames: null,
    _documentOutletNodes: null,
    _documentCallbackNames: null,
    _documentCallbackNodes: null,
    _documentCallbackControlEvents: null,
    _documentControllerName: "",
    _lastCompletedSequenceName: "",
    _keyframeCallbacks: null,
    _keyframeCallFuncs: null,
    _animationCompleteCallbackFunc: null,
    _target: null,
    _jsControlled: !1,
    ctor: function() {
        this._rootContainerSize = cc.size(0, 0), this.init()
    },
    init: function() {
        return this._sequences = [], this._nodeSequences = new cc._Dictionary, this._baseValues = new cc._Dictionary, this._documentOutletNames = [], this._documentOutletNodes = [], this._documentCallbackNames = [], this._documentCallbackNodes = [], this._documentCallbackControlEvents = [], this._keyframeCallbacks = [], this._keyframeCallFuncs = {}, !0
    },
    getSequences: function() {
        return this._sequences
    },
    setSequences: function(a) {
        this._sequences = a
    },
    getAutoPlaySequenceId: function() {
        return this._autoPlaySequenceId
    },
    setAutoPlaySequenceId: function(a) {
        this._autoPlaySequenceId = a
    },
    getRootNode: function() {
        return this._rootNode
    },
    setRootNode: function(a) {
        this._rootNode = a
    },
    getOwner: function() {
        return this._owner
    },
    setOwner: function(a) {
        this._owner = a
    },
    addDocumentCallbackNode: function(a) {
        this._documentCallbackNodes.push(a)
    },
    addDocumentCallbackName: function(a) {
        this._documentCallbackNames.push(a)
    },
    addDocumentCallbackControlEvents: function(a) {
        this._documentCallbackControlEvents.push(a)
    },
    addDocumentOutletNode: function(a) {
        this._documentOutletNodes.push(a)
    },
    addDocumentOutletName: function(a) {
        this._documentOutletNames.push(a)
    },
    setDocumentControllerName: function(a) {
        this._documentControllerName = a
    },
    getDocumentControllerName: function() {
        return this._documentControllerName
    },
    getDocumentCallbackNames: function() {
        return this._documentCallbackNames
    },
    getDocumentCallbackNodes: function() {
        return this._documentCallbackNodes
    },
    getDocumentCallbackControlEvents: function() {
        return this._documentCallbackControlEvents
    },
    getDocumentOutletNames: function() {
        return this._documentOutletNames
    },
    getDocumentOutletNodes: function() {
        return this._documentOutletNodes
    },
    getLastCompletedSequenceName: function() {
        return this._lastCompletedSequenceName
    },
    getKeyframeCallbacks: function() {
        return this._keyframeCallbacks
    },
    getRootContainerSize: function() {
        return this._rootContainerSize
    },
    setRootContainerSize: function(a) {
        this._rootContainerSize = cc.size(a.width, a.height)
    },
    getDelegate: function() {
        return this._delegate
    },
    setDelegate: function(a) {
        this._delegate = a
    },
    getRunningSequenceName: function() {
        return this._runningSequence ? this._runningSequence.getName() : null
    },
    getContainerSize: function(a) {
        return a ? a.getContentSize() : this._rootContainerSize
    },
    addNode: function(a, b) {
        this._nodeSequences.setObject(b, a)
    },
    setBaseValue: function(a, b, c) {
        var d = this._baseValues.objectForKey(b);
        d || (d = new cc._Dictionary, this._baseValues.setObject(d, b)), d.setObject(a, c)
    },
    moveAnimationsFromNode: function(a, b) {
        var c = this._baseValues,
            d = c.objectForKey(a);
        null != d && (c.setObject(d, b), c.removeObjectForKey(a));
        var e = this._nodeSequences,
            f = e.objectForKey(a);
        null != f && (e.setObject(f, b), e.removeObjectForKey(a))
    },
    getActionForCallbackChannel: function(a) {
        for (var b = 0, c = [], d = a.getKeyframes(), e = d.length, f = 0; e > f; ++f) {
            var g = d[f],
                h = g.getTime() - b;
            b = g.getTime(), h > 0 && c.push(cc.delayTime(h));
            var i = g.getValue(),
                j = i[0],
                k = i[1];
            if (this._jsControlled) {
                var l = k + ":" + j,
                    m = this._keyframeCallFuncs[l];
                null != m && c.push(m)
            } else {
                var n;
                if (k == CCB_TARGETTYPE_DOCUMENTROOT ? n = this._rootNode : k == CCB_TARGETTYPE_OWNER && (n = this._owner), null != n)
                    if (j.length > 0) {
                        var o = 0,
                            p = n;
                        null != n.onResolveCCBCCCallFuncSelector && (o = p.onResolveCCBCCCallFuncSelector(n, j)), 0 == o ? cc.log("Skipping selector '" + j + "' since no CCBSelectorResolver is present.") : c.push(cc.callFunc(o, n))
                    } else cc.log("Unexpected empty selector.")
            }
        }
        return c.length < 1 ? null : cc.sequence(c)
    },
    getActionForSoundChannel: function(a) {
        for (var b = 0, c = [], d = a.getKeyframes(), e = d.length, f = 0; e > f; ++f) {
            var g = d[f],
                h = g.getTime() - b;
            b = g.getTime(), h > 0 && c.push(cc.delayTime(h));
            var i = g.getValue(),
                j = cc.BuilderReader.getResourcePath() + i[0],
                k = parseFloat(i[1]),
                l = parseFloat(i[2]),
                m = parseFloat(i[3]);
            c.push(cc.BuilderSoundEffect.create(j, k, l, m))
        }
        return c.length < 1 ? null : cc.sequence(c)
    },
    runAnimationsForSequenceNamed: function(a) {
        this.runAnimationsForSequenceIdTweenDuration(this._getSequenceId(a), 0)
    },
    runAnimationsForSequenceNamedTweenDuration: function(a, b) {
        this.runAnimationsForSequenceIdTweenDuration(this._getSequenceId(a), b)
    },
    runAnimationsForSequenceIdTweenDuration: function(a, b) {
        if (-1 === a) throw "cc.BuilderAnimationManager.runAnimationsForSequenceIdTweenDuration(): Sequence id should not be -1";
        b = b || 0, this._rootNode.stopAllActions();
        for (var c = this._nodeSequences.allKeys(), d = 0, e = c.length; e > d; d++) {
            var f = c[d];
            f.stopAllActions();
            var g, h = this._nodeSequences.objectForKey(f),
                i = h.objectForKey(a),
                j = [];
            if (i) {
                var k = i.allKeys();
                for (g = 0; g < k.length; g++) {
                    var l = k[g],
                        m = i.objectForKey(l);
                    j.push(l), this._setFirstFrame(f, m, b), this._runAction(f, m, b)
                }
            }
            var n = this._baseValues.objectForKey(f);
            if (n) {
                var o = n.allKeys();
                for (g = 0; g < o.length; g++) {
                    var p = o[g];
                    if (-1 == j.indexOf(p)) {
                        var q = n.objectForKey(p);
                        null != q && this._setAnimatedProperty(p, f, q, b)
                    }
                }
            }
        }
        var r = this._getSequence(a),
            s = cc.sequence(cc.delayTime(r.getDuration() + b), cc.callFunc(this._sequenceCompleted, this));
        this._rootNode.runAction(s);
        var t;
        r.getCallbackChannel() && (t = this.getActionForCallbackChannel(r.getCallbackChannel()), t && this._rootNode.runAction(t)), r.getSoundChannel() && (t = this.getActionForSoundChannel(r.getSoundChannel()), t && this._rootNode.runAction(t)), this._runningSequence = this._getSequence(a)
    },
    runAnimations: function(a, b) {
        b = b || 0;
        var c;
        c = cc.isString(a) ? this._getSequenceId(a) : a, this.runAnimationsForSequenceIdTweenDuration(c, b)
    },
    setAnimationCompletedCallback: function(a, b) {
        this._target = a, this._animationCompleteCallbackFunc = b
    },
    setCompletedAnimationCallback: function(a, b) {
        this.setAnimationCompletedCallback(a, b)
    },
    setCallFunc: function(a, b) {
        this._keyframeCallFuncs[b] = a
    },
    debug: function() {},
    _getBaseValue: function(a, b) {
        var c = this._baseValues.objectForKey(a);
        return c ? c.objectForKey(b) : null
    },
    _getSequenceId: function(a) {
        for (var b = null, c = this._sequences, d = 0, e = c.length; e > d; d++)
            if (b = c[d], b && b.getName() === a) return b.getSequenceId();
        return -1
    },
    _getSequence: function(a) {
        for (var b = null, c = this._sequences, d = 0, e = c.length; e > d; d++)
            if (b = c[d], b && b.getSequenceId() === a) return b;
        return null
    },
    _getAction: function(a, b, c, d) {
        var e, f, g, h, i, j = b.getTime() - (a ? a.getTime() : 0);
        if ("rotation" === c) return cc.BuilderRotateTo.create(j, b.getValue());
        if ("rotationX" === c) return cc.BuilderRotateXTo.create(j, b.getValue());
        if ("rotationY" === c) return cc.BuilderRotateYTo.create(j, b.getValue());
        if ("opacity" === c) return cc.fadeTo(j, b.getValue());
        if ("color" === c) {
            var k = b.getValue().getColor();
            return cc.tintTo(j, k.r, k.g, k.b)
        }
        if ("visible" === c) {
            var l = b.getValue();
            return l ? cc.sequence(cc.delayTime(j), cc.show()) : cc.sequence(cc.delayTime(j), cc.hide())
        }
        if ("displayFrame" === c) return cc.sequence(cc.delayTime(j), cc.BuilderSetSpriteFrame.create(b.getValue()));
        if ("position" === c) {
            e = this._getBaseValue(d, c), f = e[2], g = b.getValue(), h = g[0], i = g[1];
            var m = this.getContainerSize(d.getParent()),
                n = cc._getAbsolutePosition(h, i, f, m, c);
            return cc.moveTo(j, n)
        }
        if ("scale" === c) {
            if (e = this._getBaseValue(d, c), f = e[2], g = b.getValue(), h = g[0], i = g[1], f === CCB_SCALETYPE_MULTIPLY_RESOLUTION) {
                var o = cc.BuilderReader.getResolutionScale();
                h *= o, i *= o
            }
            return cc.scaleTo(j, h, i)
        }
        return "skew" === c ? (g = b.getValue(), h = g[0], i = g[1], cc.skewTo(j, h, i)) : (cc.log("BuilderReader: Failed to create animation for property: " + c), null)
    },
    _setAnimatedProperty: function(a, b, c, d) {
        if (d > 0) {
            var e = new cc.BuilderKeyframe;
            e.setValue(c), e.setTime(d), e.setEasingType(CCB_KEYFRAME_EASING_LINEAR);
            var f = this._getAction(null, e, a, b);
            b.runAction(f)
        } else {
            var g, h, i, j;
            if ("position" === a) g = this._getBaseValue(b, a), h = g[2], i = c[0], j = c[1], b.setPosition(cc._getAbsolutePosition(i, j, h, this.getContainerSize(b.getParent()), a));
            else if ("scale" === a) g = this._getBaseValue(b, a), h = g[2], i = c[0], j = c[1], cc.setRelativeScale(b, i, j, h, a);
            else if ("skew" === a) i = c[0], j = c[1], b.setSkewX(i), b.setSkewY(j);
            else if ("rotation" === a) b.setRotation(c);
            else if ("rotationX" == a) b.setRotationSkewX(c);
            else if ("rotationY" == a) b.setRotationSkewY(c);
            else if ("opacity" === a) b.setOpacity(c);
            else if ("displayFrame" === a) b.setSpriteFrame(c);
            else if ("color" === a) {
                var k = c.getColor();
                (255 !== k.r || 255 !== k.g || 255 !== k.b) && b.setColor(k)
            } else "visible" === a ? (c = c || !1, b.setVisible(c)) : cc.log("unsupported property name is " + a)
        }
    },
    _setFirstFrame: function(a, b, c) {
        var d = b.getKeyframes();
        if (0 === d.length) {
            var e = this._getBaseValue(a, b.getName());
            e || cc.log("cc.BuilderAnimationManager._setFirstFrame(): No baseValue found for property"), this._setAnimatedProperty(b.getName(), a, e, c)
        } else {
            var f = d[0];
            this._setAnimatedProperty(b.getName(), a, f.getValue(), c)
        }
    },
    _getEaseAction: function(a, b, c) {
        return b === CCB_KEYFRAME_EASING_LINEAR || b === CCB_KEYFRAME_EASING_INSTANT ? a : b === CCB_KEYFRAME_EASING_CUBIC_IN ? a.easing(cc.easeIn(c)) : b === CCB_KEYFRAME_EASING_CUBIC_OUT ? a.easing(cc.easeOut(c)) : b === CCB_KEYFRAME_EASING_CUBIC_INOUT ? a.easing(cc.easeInOut(c)) : b === CCB_KEYFRAME_EASING_BACK_IN ? a.easing(cc.easeBackIn()) : b === CCB_KEYFRAME_EASING_BACK_OUT ? a.easing(cc.easeBackOut()) : b === CCB_KEYFRAME_EASING_BACK_INOUT ? a.easing(cc.easeBackInOut()) : b === CCB_KEYFRAME_EASING_BOUNCE_IN ? a.easing(cc.easeBounceIn()) : b === CCB_KEYFRAME_EASING_BOUNCE_OUT ? a.easing(cc.easeBounceOut()) : b === CCB_KEYFRAME_EASING_BOUNCE_INOUT ? a.easing(cc.easeBounceInOut()) : b === CCB_KEYFRAME_EASING_ELASTIC_IN ? a.easing(cc.easeElasticIn(c)) : b === CCB_KEYFRAME_EASING_ELASTIC_OUT ? a.easing(cc.easeElasticOut(c)) : b === CCB_KEYFRAME_EASING_ELASTIC_INOUT ? a.easing(cc.easeElasticInOut(c)) : (cc.log("BuilderReader: Unkown easing type " + b), a)
    },
    _runAction: function(a, b, c) {
        var d = b.getKeyframes(),
            e = d.length;
        if (e > 1) {
            var f = [],
                g = d[0],
                h = g.getTime() + c;
            h > 0 && f.push(cc.delayTime(h));
            for (var i = 0; e - 1 > i; ++i) {
                var j = d[i],
                    k = d[i + 1],
                    l = this._getAction(j, k, b.getName(), a);
                l && (l = this._getEaseAction(l, j.getEasingType(), j.getEasingOpt()), f.push(l))
            }
            a.runAction(cc.sequence(f))
        }
    },
    _sequenceCompleted: function() {
        var a = this._runningSequence,
            b = a.getName();
        this._lastCompletedSequenceName != a.getName() && (this._lastCompletedSequenceName = a.getName());
        var c = a.getChainedSequenceId();
        this._runningSequence = null, -1 != c && this.runAnimations(c, 0), this._delegate && this._delegate.completedAnimationSequenceNamed(b), this._target && this._animationCompleteCallbackFunc && this._animationCompleteCallbackFunc.call(this._target)
    }
}), cc.BuilderSetSpriteFrame = cc.ActionInstant.extend({
    _spriteFrame: null,
    initWithSpriteFrame: function(a) {
        return this._spriteFrame = a, !0
    },
    update: function() {
        this.target.setSpriteFrame(this._spriteFrame)
    }
}), cc.BuilderSetSpriteFrame.create = function(a) {
    var b = new cc.BuilderSetSpriteFrame;
    return b && b.initWithSpriteFrame(a) ? b : null
}, cc.BuilderRotateTo = cc.ActionInterval.extend({
    _startAngle: 0,
    _dstAngle: 0,
    _diffAngle: 0,
    initWithDuration: function(a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._dstAngle = b, !0) : !1
    },
    update: function(a) {
        this.target.setRotation(this._startAngle + this._diffAngle * a)
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a), this._startAngle = this.target.getRotation(), this._diffAngle = this._dstAngle - this._startAngle
    }
}), cc.BuilderRotateTo.create = function(a, b) {
    var c = new cc.BuilderRotateTo;
    return c && c.initWithDuration(a, b) ? c : null
}, cc.BuilderRotateXTo = cc.ActionInterval.extend({}), cc.BuilderRotateXTo.create = function() {
    throw "rotationX has not been implemented in cocos2d-html5"
}, cc.BuilderRotateYTo = cc.ActionInterval.extend({}), cc.BuilderRotateYTo.create = function() {
    throw "rotationY has not been implemented in cocos2d-html5"
}, cc.BuilderSoundEffect = cc.ActionInstant.extend({
    init: function(a) {
        return this._file = a, !0
    },
    update: function() {
        cc.audioEngine.playEffect(this._file)
    }
}), cc.BuilderSoundEffect.create = function(a) {
    var b = new cc.BuilderSoundEffect;
    return b && b.init(a) ? b : null
};
cc.DOM = {}, cc.DOM._addMethods = function(a) {
    for (var b in cc.DOM.methods) a[b] = cc.DOM.methods[b];
    cc.defineGetterSetter(a, "x", a.getPositionX, a.setPositionX), cc.defineGetterSetter(a, "y", a.getPositionY, a.setPositionY), cc.defineGetterSetter(a, "width", a._getWidth, a._setWidth), cc.defineGetterSetter(a, "height", a._getHeight, a._setHeight), cc.defineGetterSetter(a, "anchorX", a._getAnchorX, a._setAnchorX), cc.defineGetterSetter(a, "anchorY", a._getAnchorY, a._setAnchorY), cc.defineGetterSetter(a, "scale", a.getScale, a.setScale), cc.defineGetterSetter(a, "scaleX", a.getScaleX, a.setScaleX), cc.defineGetterSetter(a, "scaleY", a.getScaleY, a.getScaleY), cc.defineGetterSetter(a, "rotation", a.getRotation, a.setRotation), cc.defineGetterSetter(a, "skewX", a.getSkewX, a.setSkewX), cc.defineGetterSetter(a, "skewY", a.getSkewY, a.setSkewY), cc.defineGetterSetter(a, "visible", a.isVisible, a.setVisible), cc.defineGetterSetter(a, "parent", a.getParent, a.setParent), cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity)
}, cc.DOM.methods = {
    setPosition: function(a, b) {
        void 0 === b ? (this._position.x = a.x, this._position.y = a.y) : (this._position.x = a, this._position.y = b), this.setNodeDirty(), this.dom.translates(this._position.x, -this._position.y)
    },
    setPositionY: function(a) {
        this._position.y = a, this.setNodeDirty(), this.dom.translates(this._position.x, -this._position.y)
    },
    setPositionX: function(a) {
        this._position.x = a, this.setNodeDirty(), this.dom.translates(this._position.x, -this._position.y)
    },
    setScale: function(a, b) {
        this._scaleX = a, this._scaleY = b || a, this.setNodeDirty(), this.dom.resize(this._scaleX, this._scaleY)
    },
    setScaleX: function(a) {
        this._scaleX = a, this.setNodeDirty(), this.dom.resize(this._scaleX, this._scaleY)
    },
    setScaleY: function(a) {
        this._scaleY = a, this.setNodeDirty(), this.dom.resize(this._scaleX, this._scaleY)
    },
    setAnchorPoint: function(a, b) {
        var c = this._renderCmd,
            d = this._anchorPoint;
        void 0 === b ? (d.x = a.x, d.y = a.y) : (d.x = a, d.y = b);
        var e = c._anchorPointInPoints,
            f = this._contentSize;
        e.x = f.width * d.x, e.y = f.height * d.y, this.dom.style[cc.$.pfx + "TransformOrigin"] = "" + e.x + "px " + -e.y + "px", this.ignoreAnchor ? (this.dom.style.marginLeft = 0, this.dom.style.marginBottom = 0) : (this.dom.style.marginLeft = this.isToggler ? 0 : -e.x + "px", this.dom.style.marginBottom = -e.y + "px"), this.setNodeDirty()
    },
    _setAnchorX: function(a) {
        var b = this._anchorPoint;
        if (a !== b.x) {
            b.x = a;
            var c = this._anchorPointInPoints,
                d = this._contentSize;
            c.x = d.width * b.x, this.dom.style[cc.$.pfx + "TransformOrigin"] = "" + c.x + "px " + -c.y + "px", this.ignoreAnchor ? (this.dom.style.marginLeft = 0, this.dom.style.marginBottom = 0) : this.dom.style.marginLeft = this.isToggler ? 0 : -c.x + "px", this.setNodeDirty()
        }
    },
    _setAnchorY: function(a) {
        var b = this._anchorPoint;
        if (a !== b.y) {
            b.y = a;
            var c = this._anchorPointInPoints,
                d = this._contentSize;
            c.y = d.height * b.y, this.dom.style[cc.$.pfx + "TransformOrigin"] = "" + c.x + "px " + -c.y + "px", this.ignoreAnchor ? (this.dom.style.marginLeft = 0, this.dom.style.marginBottom = 0) : this.dom.style.marginBottom = -c.y + "px", this.setNodeDirty()
        }
    },
    setContentSize: function(a, b) {
        var c = this._renderCmd,
            d = this._contentSize;
        void 0 === b ? (d.width = a.width, d.height = a.height) : (d.width = a, d.height = b);
        var e = c._anchorPointInPoints,
            f = this._anchorPoint;
        e.x = d.width * f.x, e.y = d.height * f.y, this.dom.width = d.width, this.dom.height = d.height, this.setAnchorPoint(this.getAnchorPoint()), this.canvas && (this.canvas.width = d.width, this.canvas.height = d.height), this.setNodeDirty(), this.redraw()
    },
    _setWidth: function(a) {
        var b = this._contentSize;
        if (a !== b.width) {
            b.width = a;
            var c = this._anchorPointInPoints,
                d = this._anchorPoint;
            c.x = b.width * d.x, this.dom.width = b.width, this.anchorX = d.x, this.canvas && (this.canvas.width = b.width), this.setNodeDirty(), this.redraw()
        }
    },
    _setHeight: function(a) {
        var b = this._contentSize;
        if (a !== b.height) {
            b.height = a;
            var c = this._anchorPointInPoints,
                d = this._anchorPoint;
            c.y = b.height * d.y, this.dom.height = b.height, this.anchorY = d.y, this.canvas && (this.canvas.height = b.height), this.setNodeDirty(), this.redraw()
        }
    },
    setRotation: function(a) {
        this._rotation != a && (this._rotationX = this._rotationY = a, this.setNodeDirty(), this.dom.rotate(a))
    },
    setSkewX: function(a) {
        this._skewX = a, this.setNodeDirty(), this.dom.setSkew(this._skewX, this._skewY)
    },
    setSkewY: function(a) {
        this._skewY = a, this.setNodeDirty(), this.dom.setSkew(this._skewX, this._skewY)
    },
    setVisible: function(a) {
        this._visible = a, this.setNodeDirty(), this.dom && (this.dom.style.display = a ? "block" : "none")
    },
    _setLocalZOrder: function(a) {
        this._localZOrder = a, this.setNodeDirty(), this.dom && (this.dom.zIndex = a)
    },
    setParent: function(a) {
        this._parent = a, null !== a && (a.setAnchorPoint(a.getAnchorPoint()), this.setNodeDirty(), cc.DOM.parentDOM(this))
    },
    resume: function() {
        this.getScheduler().resumeTarget(this), this.getActionManager().resumeTarget(this), cc.eventManager.resumeTarget(this), this.dom && !this.dom.parentNode && (this.getParent() ? cc.DOM.parentDOM(this) : "" == this.dom.id ? cc.DOM._createEGLViewDiv(this) : this.dom.appendTo(cc.container)), this.dom && (this.dom.style.visibility = "visible")
    },
    pause: function() {
        this.getScheduler().pauseTarget(this), this.getActionManager().pauseTarget(this), cc.eventManager.pauseTarget(this), this.dom && (this.dom.style.visibility = "hidden")
    },
    cleanup: function() {
        this.stopAllActions(), this.unscheduleAllCallbacks(), this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.cleanup), this.dom && this.dom.remove()
    },
    removeFromParentAndCleanup: function() {
        this.dom.remove()
    },
    setOpacity: function(a) {
        this._opacity = a, this.dom.style.opacity = a / 255
    },
    redraw: function() {
        if (this.isSprite) {
            var a = this._children;
            this._children = [], cc.Sprite.prototype.visit.call(this, this.ctx), this._children = a
        } else cc.Sprite.prototype.visit.call(this, this.ctx)
    }
}, cc.DOM._resetEGLViewDiv = function() {
    var a = cc.$("#EGLViewDiv");
    if (a) {
        var b = cc.view,
            c = b.getDesignResolutionSize(),
            d = b.getViewPortRect(),
            e = b.getFrameSize(),
            f = b.getDevicePixelRatio(),
            g = c.width,
            h = c.height;
        0 === c.width && 0 === c.height && (g = e.width, h = e.height);
        var i = d.width / f;
        0 === d.width && 0 === d.height && (i = e.width), a.style.position = "absolute", a.style.width = g + "px", a.style.maxHeight = h + "px", a.style.margin = 0, a.resize(b.getScaleX() / f, b.getScaleY() / f), a.style.left = (i - g) / 2 + "px", a.style.bottom = "0px"
    }
}, cc.DOM.parentDOM = function(a) {
    var b = a.getParent();
    if (!b || !a.dom) return !1;
    if (b.dom || (cc.DOM.placeHolder(b), b.setParent = cc.DOM.methods.setParent), a.dom.appendTo(b.dom), b.setAnchorPoint(b.getAnchorPoint()), b.getParent()) cc.DOM.parentDOM(b);
    else if (b.isRunning()) {
        var c = cc.$("#EGLViewDiv");
        c ? b.dom.appendTo(c) : cc.DOM._createEGLViewDiv(b)
    }
    return !0
}, cc.DOM._createEGLViewDiv = function(a) {
    var b = cc.$("#EGLViewDiv");
    b || (b = cc.$new("div"), b.id = "EGLViewDiv");
    var c = cc.view,
        d = c.getDesignResolutionSize(),
        e = c.getViewPortRect(),
        f = c.getFrameSize(),
        g = c.getDevicePixelRatio(),
        h = d.width,
        i = d.height;
    0 === d.width && 0 === d.height && (h = f.width, i = f.height);
    var j = e.width / g;
    0 === e.width && 0 === e.height && (j = f.width), b.style.position = "absolute", b.style.width = h + "px", b.style.maxHeight = i + "px", b.style.margin = 0, b.resize(c.getScaleX() / g, c.getScaleY() / g), b.style.left = (j - h) / 2 + "px", b.style.bottom = "0px", a.dom.appendTo(b), b.appendTo(cc.container)
}, cc.DOM.setTransform = function(a) {
    if (a.ctx)
        if (a.ctx.translate(a.getAnchorPointInPoints().x, a.getAnchorPointInPoints().y), a.isSprite) {
            var b = a._children;
            a._children = [], cc.Sprite.prototype.visit.call(a), a._children = b
        } else cc.Sprite.prototype.visit.call(a);
    a.dom && (a.dom.position.x = a.getPositionX(), a.dom.position.y = -a.getPositionY(), a.dom.rotation = a.getRotation(), a.dom.scale = {
        x: a.getScaleX(),
        y: a.getScaleY()
    }, a.dom.skew = {
        x: a.getSkewX(),
        y: a.getSkewY()
    }, a.setAnchorPoint && a.setAnchorPoint(a.getAnchorPoint()), a.dom.transforms())
}, cc.DOM.forSprite = function(a) {
    a.dom = cc.$new("div"), a.canvas = cc.$new("canvas");
    var b = a.getContentSize();
    a.canvas.width = b.width, a.canvas.height = b.height, a.dom.style.position = "absolute", a.dom.style.bottom = 0, a.ctx = a.canvas.getContext("2d"), a.dom.appendChild(a.canvas), a.getParent() && cc.DOM.parentDOM(a), a.isSprite = !0
}, cc.DOM.placeHolder = function(a) {
    a.dom = cc.$new("div"), a.placeholder = !0, a.dom.style.position = "absolute", a.dom.style.bottom = 0, a.dom.style.width = (a.getContentSize().width || cc.director.getWinSize().width) + "px", a.dom.style.maxHeight = (a.getContentSize().height || cc.director.getWinSize().height) + "px", a.dom.style.margin = 0, cc.DOM.setTransform(a), a.dom.transforms(), cc.DOM._addMethods(a)
}, cc.DOM.convert = function() {
    if (arguments.length > 1) return void cc.DOM.convert(arguments);
    if (1 == arguments.length && !arguments[0].length) return void cc.DOM.convert([arguments[0]]);
    for (var a = arguments[0], b = 0; b < a.length; b++) a[b] instanceof cc.Sprite ? a[b].dom || cc.DOM.forSprite(a[b]) : cc.log("DOM converter only supports sprite and menuitems yet"), cc.DOM._addMethods(a[b]), a[b].visit = function() {}, a[b].transform = function() {}, cc.DOM.setTransform(a[b]), a[b].setVisible(a[b].isVisible())
}, cc.KEYBOARD_RETURNTYPE_DEFAULT = 0, cc.KEYBOARD_RETURNTYPE_DONE = 1, cc.KEYBOARD_RETURNTYPE_SEND = 2, cc.KEYBOARD_RETURNTYPE_SEARCH = 3, cc.KEYBOARD_RETURNTYPE_GO = 4, cc.EDITBOX_INPUT_MODE_ANY = 0, cc.EDITBOX_INPUT_MODE_EMAILADDR = 1, cc.EDITBOX_INPUT_MODE_NUMERIC = 2, cc.EDITBOX_INPUT_MODE_PHONENUMBER = 3, cc.EDITBOX_INPUT_MODE_URL = 4, cc.EDITBOX_INPUT_MODE_DECIMAL = 5, cc.EDITBOX_INPUT_MODE_SINGLELINE = 6, cc.EDITBOX_INPUT_FLAG_PASSWORD = 0, cc.EDITBOX_INPUT_FLAG_SENSITIVE = 1, cc.EDITBOX_INPUT_FLAG_INITIAL_CAPS_WORD = 2, cc.EDITBOX_INPUT_FLAG_INITIAL_CAPS_SENTENCE = 3, cc.EDITBOX_INPUT_FLAG_INITIAL_CAPS_ALL_CHARACTERS = 4, cc.EditBoxDelegate = cc.Class.extend({
    editBoxEditingDidBegin: function() {},
    editBoxEditingDidEnd: function() {},
    editBoxTextChanged: function() {},
    editBoxReturn: function() {}
}), cc.EditBox = cc.ControlButton.extend({
    _domInputSprite: null,
    _delegate: null,
    _editBoxInputMode: cc.EDITBOX_INPUT_MODE_ANY,
    _editBoxInputFlag: cc.EDITBOX_INPUT_FLAG_SENSITIVE,
    _keyboardReturnType: cc.KEYBOARD_RETURNTYPE_DEFAULT,
    _text: "",
    _placeholderText: "",
    _textColor: null,
    _placeholderColor: null,
    _maxLength: 50,
    _adjustHeight: 18,
    _edTxt: null,
    _edFontSize: 14,
    _edFontName: "Arial",
    _placeholderFontName: "",
    _placeholderFontSize: 14,
    _tooltip: !1,
    _className: "EditBox",
    ctor: function(a, b, c, d) {
        cc.ControlButton.prototype.ctor.call(this), this._textColor = cc.color.WHITE, this._placeholderColor = cc.color.GRAY, this.setContentSize(a);
        var e = this._domInputSprite = new cc.Sprite;
        e.draw = function() {}, this.addChild(e);
        var f = this,
            g = this._edTxt = cc.newElement("input");
        g.type = "text", g.style.fontSize = this._edFontSize + "px", g.style.color = "#000000", g.style.border = 0, g.style.background = "transparent", g.style.width = "100%", g.style.height = "100%", g.style.active = 0, g.style.outline = "medium", g.style.padding = "0";
        var h = function() {
            g.blur()
        };
        cc._addEventListener(g, "input", function() {
            f._delegate && f._delegate.editBoxTextChanged && f._delegate.editBoxTextChanged(f, this.value)
        }), cc._addEventListener(g, "keypress", function(a) {
            a.keyCode === cc.KEY.enter && (a.stopPropagation(), a.preventDefault(), cc._canvas.focus())
        }), cc._addEventListener(g, "focus", function() {
            this.value == f._placeholderText && (this.value = "", this.style.fontSize = f._edFontSize + "px", this.style.color = cc.colorToHex(f._textColor)), f._delegate && f._delegate.editBoxEditingDidBegin && f._delegate.editBoxEditingDidBegin(f), cc._addEventListener(cc._canvas, "click", h)
        }), cc._addEventListener(g, "blur", function() {
            "" == this.value && (this.value = f._placeholderText, this.style.fontSize = f._placeholderFontSize + "px", this.style.color = cc.colorToHex(f._placeholderColor)), f._delegate && f._delegate.editBoxEditingDidEnd && f._delegate.editBoxEditingDidEnd(f), f._delegate && f._delegate.editBoxReturn && f._delegate.editBoxReturn(f), cc._canvas.removeEventListener("click", h)
        }), cc.DOM.convert(e), e.dom.appendChild(g), e.dom.showTooltipDiv = !1, e.dom.style.width = a.width - 6 + "px", e.dom.style.height = a.height - 6 + "px", e.canvas.remove(), this.initWithSizeAndBackgroundSprite(a, b) && (c && this.setBackgroundSpriteForState(c, cc.CONTROL_STATE_HIGHLIGHTED), d && this.setBackgroundSpriteForState(d, cc.CONTROL_STATE_DISABLED))
    },
    setFont: function(a, b) {
        this._edFontSize = b, this._edFontName = a, this._setFontToEditBox()
    },
    _setFont: function(a) {
        var b = cc.LabelTTF._fontStyleRE.exec(a);
        b && (this._edFontSize = parseInt(b[1]), this._edFontName = b[2], this._setFontToEditBox())
    },
    setFontName: function(a) {
        this._edFontName = a, this._setFontToEditBox()
    },
    setFontSize: function(a) {
        this._edFontSize = a, this._setFontToEditBox()
    },
    _setFontToEditBox: function() {
        this._edTxt.value != this._placeholderText && (this._edTxt.style.fontFamily = this._edFontName, this._edTxt.style.fontSize = this._edFontSize + "px")
    },
    setText: function(a) {
        cc.log("Please use the setString"), null != a && ("" == a ? (this._edTxt.value = this._placeholderText, this._edTxt.style.color = cc.colorToHex(this._placeholderColor)) : (this._edTxt.value = a, this._edTxt.style.color = cc.colorToHex(this._textColor)))
    },
    setString: function(a) {
        null != a && ("" == a ? (this._edTxt.value = this._placeholderText, this._edTxt.style.color = cc.colorToHex(this._placeholderColor)) : (this._edTxt.value = a, this._edTxt.style.color = cc.colorToHex(this._textColor)))
    },
    setFontColor: function(a) {
        this._textColor = a, this._edTxt.value != this._placeholderText && (this._edTxt.style.color = cc.colorToHex(a))
    },
    setMaxLength: function(a) {
        !isNaN(a) && a > 0 && (this._maxLength = a, this._edTxt.maxLength = a)
    },
    getMaxLength: function() {
        return this._maxLength
    },
    setPlaceHolder: function(a) {
        if (null != a) {
            var b = this._placeholderText;
            this._placeholderText = a, this._edTxt.value == b && (this._edTxt.value = a, this._edTxt.style.color = cc.colorToHex(this._placeholderColor), this._setPlaceholderFontToEditText())
        }
    },
    setPlaceholderFont: function(a, b) {
        this._placeholderFontName = a, this._placeholderFontSize = b, this._setPlaceholderFontToEditText()
    },
    _setPlaceholderFont: function(a) {
        var b = cc.LabelTTF._fontStyleRE.exec(a);
        b && (this._placeholderFontName = b[2], this._placeholderFontSize = parseInt(b[1]), this._setPlaceholderFontToEditText())
    },
    setPlaceholderFontName: function(a) {
        this._placeholderFontName = a, this._setPlaceholderFontToEditText()
    },
    setPlaceholderFontSize: function(a) {
        this._placeholderFontSize = a, this._setPlaceholderFontToEditText()
    },
    _setPlaceholderFontToEditText: function() {
        this._edTxt.value == this._placeholderText && (this._edTxt.style.fontFamily = this._placeholderFontName, this._edTxt.style.fontSize = this._placeholderFontSize + "px")
    },
    setPlaceholderFontColor: function(a) {
        this._placeholderColor = a, this._edTxt.value == this._placeholderText && (this._edTxt.style.color = cc.colorToHex(a))
    },
    setInputFlag: function(a) {
        this._editBoxInputFlag = a, this._edTxt.type = a == cc.EDITBOX_INPUT_FLAG_PASSWORD ? "password" : "text"
    },
    getText: function() {
        return cc.log("Please use the getString"), this._edTxt.value
    },
    getString: function() {
        return this._edTxt.value
    },
    initWithSizeAndBackgroundSprite: function(a, b) {
        return this.initWithBackgroundSprite(b) ? (this._domInputSprite.x = 3, this._domInputSprite.y = 3, this.setZoomOnTouchDown(!1), this.setPreferredSize(a), this.x = 0, this.y = 0, this._addTargetWithActionForControlEvent(this, this.touchDownAction, cc.CONTROL_EVENT_TOUCH_UP_INSIDE), !0) : !1
    },
    setDelegate: function(a) {
        this._delegate = a
    },
    getPlaceHolder: function() {
        return this._placeholderText
    },
    setInputMode: function(a) {
        this._editBoxInputMode = a
    },
    setReturnType: function(a) {
        this._keyboardReturnType = a
    },
    keyboardWillShow: function(a) {
        var b = cc.EditBox.getRect(this);
        return b.y -= 4, b.intersectsRect(a.end) ? void(this._adjustHeight = a.end.getMaxY() - b.getMinY()) : void cc.log("needn't to adjust view layout.")
    },
    keyboardDidShow: function() {},
    keyboardWillHide: function() {},
    keyboardDidHide: function() {},
    touchDownAction: function() {},
    initWithBackgroundColor: function(a, b) {
        this._edWidth = a.width, this.dom.style.width = this._edWidth.toString() + "px", this._edHeight = a.height, this.dom.style.height = this._edHeight.toString() + "px", this.dom.style.backgroundColor = cc.colorToHex(b)
    }
});
var _p = cc.EditBox.prototype;
_p.font, cc.defineGetterSetter(_p, "font", null, _p._setFont), _p.fontName, cc.defineGetterSetter(_p, "fontName", null, _p.setFontName), _p.fontSize, cc.defineGetterSetter(_p, "fontSize", null, _p.setFontSize), _p.fontColor, cc.defineGetterSetter(_p, "fontColor", null, _p.setFontColor), _p.string, cc.defineGetterSetter(_p, "string", _p.getString, _p.setString), _p.maxLength, cc.defineGetterSetter(_p, "maxLength", _p.getMaxLength, _p.setMaxLength), _p.placeHolder, cc.defineGetterSetter(_p, "placeHolder", _p.getPlaceHolder, _p.setPlaceHolder), _p.placeHolderFont, cc.defineGetterSetter(_p, "placeHolderFont", null, _p._setPlaceholderFont), _p.placeHolderFontName, cc.defineGetterSetter(_p, "placeHolderFontName", null, _p.setPlaceholderFontName), _p.placeHolderFontSize, cc.defineGetterSetter(_p, "placeHolderFontSize", null, _p.setPlaceholderFontSize), _p.placeHolderFontColor, cc.defineGetterSetter(_p, "placeHolderFontColor", null, _p.setPlaceholderFontColor), _p.inputFlag, cc.defineGetterSetter(_p, "inputFlag", null, _p.setInputFlag), _p.delegate, cc.defineGetterSetter(_p, "delegate", null, _p.setDelegate), _p.inputMode, cc.defineGetterSetter(_p, "inputMode", null, _p.setInputMode), _p.returnType, cc.defineGetterSetter(_p, "returnType", null, _p.setReturnType), _p = null, cc.EditBox.getRect = function(a) {
    var b = a.getContentSize(),
        c = cc.rect(0, 0, b.width, b.height);
    return cc.rectApplyAffineTransform(c, a.getNodeToWorldTransform())
}, cc.EditBox.create = function(a, b, c, d) {
    return new cc.EditBox(a, b, c, d)
};
cc.ProtectedNode = cc.Node.extend({
        _protectedChildren: null,
        _reorderProtectedChildDirty: !1,
        _insertProtectedChild: function(a, b) {
            this._reorderProtectedChildDirty = !0, this._protectedChildren.push(a), a._setLocalZOrder(b)
        },
        ctor: function() {
            cc.Node.prototype.ctor.call(this), this._protectedChildren = []
        },
        addProtectedChild: function(a, b, c) {
            cc.assert(null != a, "child must be non-nil"), cc.assert(!a.parent, "child already added. It can't be added again"), b = b || a.getLocalZOrder(), c && a.setTag(c), this._insertProtectedChild(a, b), a.setParent(this), a.setOrderOfArrival(cc.s_globalOrderOfArrival), this._running && (a.onEnter(), this._isTransitionFinished && a.onEnterTransitionDidFinish()), this._cascadeColorEnabled && this._renderCmd.setCascadeColorEnabledDirty(), this._cascadeOpacityEnabled && this._renderCmd.setCascadeOpacityEnabledDirty()
        },
        getProtectedChildByTag: function(a) {
            cc.assert(a != cc.NODE_TAG_INVALID, "Invalid tag");
            for (var b = this._protectedChildren, c = 0, d = b.length; d > c; c++)
                if (b.getTag() == a) return b[c];
            return null
        },
        removeProtectedChild: function(a, b) {
            null == b && (b = !0);
            var c = this._protectedChildren;
            if (0 !== c.length) {
                var d = c.indexOf(a);
                d > -1 && (this._running && (a.onExitTransitionDidStart(), a.onExit()), b && a.cleanup(), a.setParent(null), c.splice(d, 1))
            }
        },
        removeProtectedChildByTag: function(a, b) {
            cc.assert(a != cc.NODE_TAG_INVALID, "Invalid tag"), null == b && (b = !0);
            var c = this.getProtectedChildByTag(a);
            null == c ? cc.log("cocos2d: removeChildByTag(tag = %d): child not found!", a) : this.removeProtectedChild(c, b)
        },
        removeAllProtectedChildren: function() {
            this.removeAllProtectedChildrenWithCleanup(!0)
        },
        removeAllProtectedChildrenWithCleanup: function(a) {
            null == a && (a = !0);
            for (var b = this._protectedChildren, c = 0, d = b.length; d > c; c++) {
                var e = b[c];
                this._running && (e.onExitTransitionDidStart(), e.onExit()), a && e.cleanup(), e.setParent(null)
            }
            b.length = 0
        },
        reorderProtectedChild: function(a, b) {
            cc.assert(null != a, "Child must be non-nil"), this._reorderProtectedChildDirty = !0, a.setOrderOfArrival(cc.s_globalOrderOfArrival++), a._setLocalZOrder(b)
        },
        sortAllProtectedChildren: function() {
            if (this._reorderProtectedChildDirty) {
                var a, b, c, d = this._protectedChildren,
                    e = d.length;
                for (a = 1; e > a; a++) {
                    for (c = d[a], b = a - 1; b >= 0;) {
                        if (c._localZOrder < d[b]._localZOrder) d[b + 1] = d[b];
                        else {
                            if (!(c._localZOrder === d[b]._localZOrder && c.arrivalOrder < d[b].arrivalOrder)) break;
                            d[b + 1] = d[b]
                        }
                        b--
                    }
                    d[b + 1] = c
                }
                this._reorderProtectedChildDirty = !1
            }
        },
        visit: function(a) {
            this._renderCmd._visit(a)
        },
        _changePosition: function() {},
        cleanup: function() {
            cc.Node.prototype.cleanup.call(this);
            for (var a = this._protectedChildren, b = 0, c = a.length; c > b; b++) a[b].cleanup()
        },
        onEnter: function() {
            cc.Node.prototype.onEnter.call(this);
            for (var a = this._protectedChildren, b = 0, c = a.length; c > b; b++) a[b].onEnter()
        },
        onEnterTransitionDidFinish: function() {
            cc.Node.prototype.onEnterTransitionDidFinish.call(this);
            for (var a = this._protectedChildren, b = 0, c = a.length; c > b; b++) a[b].onEnterTransitionDidFinish()
        },
        onExit: function() {
            cc.Node.prototype.onExit.call(this);
            for (var a = this._protectedChildren, b = 0, c = a.length; c > b; b++) a[b].onExit()
        },
        onExitTransitionDidStart: function() {
            cc.Node.prototype.onExitTransitionDidStart.call(this);
            for (var a = this._protectedChildren, b = 0, c = a.length; c > b; b++) a[b].onExitTransitionDidStart()
        },
        _createRenderCmd: function() {
            return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.ProtectedNode.CanvasRenderCmd(this) : new cc.ProtectedNode.WebGLRenderCmd(this)
        }
    }), cc.ProtectedNode.create = function() {
        return new cc.ProtectedNode
    },
    function() {
        cc.ProtectedNode.RenderCmd = {
            _updateDisplayColor: function(a) {
                var b, c, d, e, f = this._node,
                    g = this._displayedColor,
                    h = f._realColor;
                if (this._cascadeColorEnabledDirty && !f._cascadeColorEnabled) {
                    g.r = h.r, g.g = h.g, g.b = h.b;
                    var i = new cc.Color(255, 255, 255, 255);
                    for (d = f._children, b = 0, c = d.length; c > b; b++) e = d[b], e && e._renderCmd && e._renderCmd._updateDisplayColor(i);
                    this._cascadeColorEnabledDirty = !1
                } else {
                    if (void 0 === a) {
                        var j = f._parent;
                        a = j && j._cascadeColorEnabled ? j.getDisplayedColor() : cc.color.WHITE
                    }
                    if (g.r = 0 | h.r * a.r / 255, g.g = 0 | h.g * a.g / 255, g.b = 0 | h.b * a.b / 255, f._cascadeColorEnabled)
                        for (d = f._children, b = 0, c = d.length; c > b; b++) e = d[b], e && e._renderCmd && (e._renderCmd._updateDisplayColor(g), e._renderCmd._updateColor());
                    for (d = f._protectedChildren, b = 0, c = d.length; c > b; b++) e = d[b], e && e._renderCmd && (e._renderCmd._updateDisplayColor(g), e._renderCmd._updateColor())
                }
                this._dirtyFlag = this._dirtyFlag & cc.Node._dirtyFlags.colorDirty ^ this._dirtyFlag
            },
            _updateDisplayOpacity: function(a) {
                var b, c, d, e, f = this._node;
                if (this._cascadeOpacityEnabledDirty && !f._cascadeOpacityEnabled) {
                    for (this._displayedOpacity = f._realOpacity, d = this._children, b = 0, c = d.length; c > b; b++) e = d[b], e && e._renderCmd && e._renderCmd._updateDisplayOpacity(255);
                    this._cascadeOpacityEnabledDirty = !1
                } else {
                    if (void 0 === a) {
                        var g = f._parent;
                        a = 255, g && g._cascadeOpacityEnabled && (a = g.getDisplayedOpacity())
                    }
                    if (this._displayedOpacity = f._realOpacity * a / 255, f._cascadeOpacityEnabled)
                        for (d = f._children, b = 0, c = d.length; c > b; b++) e = d[b], e && e._renderCmd && (e._renderCmd._updateDisplayOpacity(this._displayedOpacity), e._renderCmd._updateColor());
                    for (d = f._protectedChildren, b = 0, c = d.length; c > b; b++) e = d[b], e && e._renderCmd && (e._renderCmd._updateDisplayOpacity(this._displayedOpacity), e._renderCmd._updateColor())
                }
                this._dirtyFlag = this._dirtyFlag & cc.Node._dirtyFlags.opacityDirty ^ this._dirtyFlag
            }
        }, cc.ProtectedNode.CanvasRenderCmd = function(a) {
            cc.Node.CanvasRenderCmd.call(this, a), this._cachedParent = null, this._cacheDirty = !1
        };
        var a = cc.ProtectedNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
        cc.inject(cc.ProtectedNode.RenderCmd, a), a.constructor = cc.ProtectedNode.CanvasRenderCmd, a.visit = function(a) {
            this._node.visit(a)
        }, a._visit = function(a) {
            var b = this._node;
            if (b._visible) {
                var c, d, e, f = b._children,
                    g = b._children,
                    h = b._protectedChildren,
                    i = g.length,
                    j = h.length;
                this._syncStatus(a), b.sortAllChildren(), b.sortAllProtectedChildren();
                var k;
                for (c = 0; i > c && (e = f[c], e._localZOrder < 0); c++) e.visit(this);
                for (d = 0; j > d && (k = h[d], k && k._localZOrder < 0); d++) this._changeProtectedChild(k), k.visit(this);
                for (cc.renderer.pushRenderCommand(this); i > c; c++) f[c] && f[c].visit(this);
                for (; j > d; d++) k = h[d], k && (this._changeProtectedChild(k), k.visit(this));
                this._dirtyFlag = 0, this._cacheDirty = !1
            }
        }, a._changeProtectedChild = function(a) {
            var b = a._renderCmd,
                c = b._dirtyFlag,
                d = cc.Node._dirtyFlags;
            this._dirtyFlag & d.colorDirty && (c |= d.colorDirty), this._dirtyFlag & d.opacityDirty && (c |= d.opacityDirty);
            var e = c & d.colorDirty,
                f = c & d.opacityDirty;
            e && b._updateDisplayColor(this._displayedColor), f && b._updateDisplayOpacity(this._displayedOpacity), (e || f) && b._updateColor()
        }, a.transform = function(a, b) {
            var c = this._node;
            c._changePosition && c._changePosition();
            var d = c.getNodeToParentTransform(),
                e = this._worldTransform;
            if (a) {
                var f = a._worldTransform;
                if (e.a = d.a * f.a + d.b * f.c, e.b = d.a * f.b + d.b * f.d, e.c = d.c * f.a + d.d * f.c, e.d = d.c * f.b + d.d * f.d, c._skewX || c._skewY) {
                    var g = a._transform,
                        h = -(g.b + g.c) * d.ty,
                        i = -(g.b + g.c) * d.tx;
                    e.tx = d.tx * f.a + d.ty * f.c + f.tx + h, e.ty = d.tx * f.b + d.ty * f.d + f.ty + i
                } else e.tx = d.tx * f.a + d.ty * f.c + f.tx, e.ty = d.tx * f.b + d.ty * f.d + f.ty
            } else e.a = d.a, e.b = d.b, e.c = d.c, e.d = d.d, e.tx = d.tx, e.ty = d.ty;
            var j, k, l = c._children;
            if (b && l && 0 !== l.length)
                for (j = 0, k = l.length; k > j; j++) l[j]._renderCmd.transform(this, b);
            if (l = c._protectedChildren, b && l && 0 !== l.length)
                for (j = 0, k = l.length; k > j; j++) l[j]._renderCmd.transform(this, b)
        }
    }();
var ccui = ccui || {};
ccui.Class = ccui.Class || cc.Class, ccui.Class.extend = ccui.Class.extend || cc.Class.extend, ccui.Node = ccui.Node || cc.Node, ccui.Node.extend = ccui.Node.extend || cc.Node.extend, ccui.ProtectedNode = ccui.ProtectedNode || cc.ProtectedNode, ccui.ProtectedNode.extend = ccui.ProtectedNode.extend || cc.ProtectedNode.extend, ccui.cocosGUIVersion = "CocosGUI v1.0.0.0", ccui.__LAYOUT_COMPONENT_NAME = "__ui_layout", ccui.Widget = ccui.ProtectedNode.extend({
    _enabled: !0,
    _bright: !0,
    _touchEnabled: !1,
    _brightStyle: null,
    _touchBeganPosition: null,
    _touchMovePosition: null,
    _touchEndPosition: null,
    _touchEventListener: null,
    _touchEventSelector: null,
    _name: "default",
    _widgetType: null,
    _actionTag: 0,
    _customSize: null,
    _layoutParameterDictionary: null,
    _layoutParameterType: 0,
    _focused: !1,
    _focusEnabled: !0,
    _ignoreSize: !1,
    _affectByClipping: !1,
    _sizeType: null,
    _sizePercent: null,
    _positionType: null,
    _positionPercent: null,
    _hit: !1,
    _nodes: null,
    _touchListener: null,
    _className: "Widget",
    _flippedX: !1,
    _flippedY: !1,
    _opacity: 255,
    _highlight: !1,
    _touchEventCallback: null,
    _propagateTouchEvents: !0,
    _unifySize: !1,
    ctor: function() {
        cc.ProtectedNode.prototype.ctor.call(this), this._brightStyle = ccui.Widget.BRIGHT_STYLE_NONE, this._touchBeganPosition = cc.p(0, 0), this._touchMovePosition = cc.p(0, 0), this._touchEndPosition = cc.p(0, 0), this._widgetType = ccui.Widget.TYPE_WIDGET, this._customSize = cc.size(0, 0), this._layoutParameterDictionary = {}, this._sizeType = ccui.Widget.SIZE_ABSOLUTE, this._sizePercent = cc.p(0, 0), this._positionType = ccui.Widget.POSITION_ABSOLUTE, this._positionPercent = cc.p(0, 0), this._nodes = [], this._layoutParameterType = ccui.LayoutParameter.NONE, this.init()
    },
    init: function() {
        return cc.ProtectedNode.prototype.init.call(this) ? (this._layoutParameterDictionary = {}, this._initRenderer(), this.setBright(!0), this.onFocusChanged = this.onFocusChange.bind(this), this.onNextFocusedWidget = null, this.setAnchorPoint(cc.p(.5, .5)), this.ignoreContentAdaptWithSize(!0), !0) : !1
    },
    onEnter: function() {
        this.updateSizeAndPosition(), cc.ProtectedNode.prototype.onEnter.call(this)
    },
    onExit: function() {
        this.unscheduleUpdate(), cc.ProtectedNode.prototype.onExit.call(this)
    },
    getOrCreateLayoutComponent: function() {
        var a = this.getComponent(ccui.__LAYOUT_COMPONENT_NAME);
        if (null == a) {
            var b = new ccui.LayoutComponent;
            this.addComponent(b), a = b
        }
        return a
    },
    visit: function(a) {
        this._visible && (this._adaptRenderers(), cc.ProtectedNode.prototype.visit.call(this, a))
    },
    getWidgetParent: function() {
        var a = this.getParent();
        return a instanceof ccui.Widget ? a : null
    },
    _updateContentSizeWithTextureSize: function(a) {
        this.setContentSize(this._ignoreSize ? a : this._customSize)
    },
    _isAncestorsEnabled: function() {
        var a = this._getAncensterWidget(this);
        return null == a ? !0 : a && !a.isEnabled() ? !1 : a._isAncestorsEnabled()
    },
    setPropagateTouchEvents: function(a) {
        this._propagateTouchEvents = a
    },
    isPropagateTouchEvents: function() {
        return this._propagateTouchEvents
    },
    setSwallowTouches: function(a) {
        this._touchListener && this._touchListener.setSwallowTouches(a)
    },
    isSwallowTouches: function() {
        return this._touchListener ? !0 : !1
    },
    _getAncensterWidget: function(a) {
        if (null == a) return null;
        var b = a.getParent();
        return null == b ? null : b instanceof ccui.Widget ? b : this._getAncensterWidget(b.getParent())
    },
    _isAncestorsVisible: function(a) {
        if (null == a) return !0;
        var b = a.getParent();
        return b && !b.isVisible() ? !1 : this._isAncestorsVisible(b)
    },
    _cleanupWidget: function() {
        this._eventDispatcher.removeEventListener(this._touchListener), ccui.Widget._focusedWidget == this && (ccui.Widget._focusedWidget = null)
    },
    setEnabled: function(a) {
        this._enabled = a
    },
    _initRenderer: function() {},
    setContentSize: function(a, b) {
        var c = void 0 === b ? a.width : a,
            d = void 0 === b ? a.height : b;
        if (cc.Node.prototype.setContentSize.call(this, c, d), this._customSize.width = c, this._customSize.height = d, this._ignoreSize && (this._contentSize = this.getVirtualRendererSize()), this._running) {
            var e = this.getWidgetParent(),
                f = e ? e.getContentSize() : this._parent.getContentSize();
            this._sizePercent.x = f.width > 0 ? c / f.width : 0, this._sizePercent.y = f.height > 0 ? d / f.height : 0
        }
        this._onSizeChanged()
    },
    _setWidth: function(a) {
        if (cc.Node.prototype._setWidth.call(this, a), this._customSize.width = a, this._ignoreSize && (this._contentSize = this.getVirtualRendererSize()), this._running) {
            var b = this.getWidgetParent(),
                c = b ? b.width : this._parent.width;
            this._sizePercent.x = c > 0 ? this._customSize.width / c : 0
        }
        this._onSizeChanged()
    },
    _setHeight: function(a) {
        if (cc.Node.prototype._setHeight.call(this, a), this._customSize.height = a, this._ignoreSize && (this._contentSize = this.getVirtualRendererSize()), this._running) {
            var b = this.getWidgetParent(),
                c = b ? b.height : this._parent.height;
            this._sizePercent.y = c > 0 ? this._customSize.height / c : 0
        }
        this._onSizeChanged()
    },
    setSizePercent: function(a) {
        this._sizePercent.x = a.x, this._sizePercent.y = a.y;
        var b = this._customSize.width,
            c = this._customSize.height;
        if (this._running) {
            var d = this.getWidgetParent();
            d ? (b = d.width * a.x, c = d.height * a.y) : (b = this._parent.width * a.x, c = this._parent.height * a.y)
        }
        this._ignoreSize ? this.setContentSize(this.getVirtualRendererSize()) : this.setContentSize(b, c), this._customSize.width = b, this._customSize.height = c
    },
    _setWidthPercent: function(a) {
        this._sizePercent.x = a;
        var b = this._customSize.width;
        if (this._running) {
            var c = this.getWidgetParent();
            b = (c ? c.width : this._parent.width) * a
        }
        this._setWidth(this._ignoreSize ? this.getVirtualRendererSize().width : b), this._customSize.width = b
    },
    _setHeightPercent: function(a) {
        this._sizePercent.y = a;
        var b = this._customSize.height;
        if (this._running) {
            var c = this.getWidgetParent();
            b = (c ? c.height : this._parent.height) * a
        }
        this._setHeight(this._ignoreSize ? this.getVirtualRendererSize().height : b), this._customSize.height = b
    },
    updateSizeAndPosition: function(a) {
        if (!a) {
            var b = this.getWidgetParent();
            a = b ? b.getLayoutSize() : this._parent.getContentSize()
        }
        switch (this._sizeType) {
            case ccui.Widget.SIZE_ABSOLUTE:
                this.setContentSize(this._ignoreSize ? this.getVirtualRendererSize() : this._customSize), this._sizePercent.x = a.width > 0 ? this._customSize.width / a.width : 0, this._sizePercent.y = a.height > 0 ? this._customSize.height / a.height : 0;
                break;
            case ccui.Widget.SIZE_PERCENT:
                var c = cc.size(a.width * this._sizePercent.x, a.height * this._sizePercent.y);
                this.setContentSize(this._ignoreSize ? this.getVirtualRendererSize() : c), this._customSize.width = c.width, this._customSize.height = c.height
        }
        this._onSizeChanged();
        var d = this.getPosition();
        switch (this._positionType) {
            case ccui.Widget.POSITION_ABSOLUTE:
                a.width <= 0 || a.height <= 0 ? this._positionPercent.x = this._positionPercent.y = 0 : (this._positionPercent.x = d.x / a.width, this._positionPercent.y = d.y / a.height);
                break;
            case ccui.Widget.POSITION_PERCENT:
                d = cc.p(a.width * this._positionPercent.x, a.height * this._positionPercent.y)
        }
        if (this._parent instanceof ccui.ImageView) {
            var e = this._parent._imageRenderer;
            if (e && !e._textureLoaded) return
        }
        this.setPosition(d)
    },
    setSizeType: function(a) {
        this._sizeType = a
    },
    getSizeType: function() {
        return this._sizeType
    },
    ignoreContentAdaptWithSize: function(a) {
        this._ignoreSize != a && (this._ignoreSize = a, this.setContentSize(a ? this.getVirtualRendererSize() : this._customSize), this._onSizeChanged())
    },
    isIgnoreContentAdaptWithSize: function() {
        return this._ignoreSize
    },
    getCustomSize: function() {
        return cc.size(this._customSize)
    },
    getLayoutSize: function() {
        return cc.size(this._contentSize)
    },
    getSizePercent: function() {
        var a = this.getOrCreateLayoutComponent();
        return a.getPercentContentSize()
    },
    _getWidthPercent: function() {
        return this._sizePercent.x
    },
    _getHeightPercent: function() {
        return this._sizePercent.y
    },
    getWorldPosition: function() {
        return this.convertToWorldSpace(cc.p(this._anchorPoint.x * this._contentSize.width, this._anchorPoint.y * this._contentSize.height))
    },
    getVirtualRenderer: function() {
        return this
    },
    getVirtualRendererSize: function() {
        return cc.size(this._contentSize)
    },
    _onSizeChanged: function() {
        for (var a = this.getChildren(), b = 0, c = a.length; c > b; b++) {
            var d = a[b];
            d instanceof ccui.Widget && d.updateSizeAndPosition()
        }
    },
    setTouchEnabled: function(a) {
        this._touchEnabled !== a && (this._touchEnabled = a, this._touchEnabled ? (this._touchListener || (this._touchListener = cc.EventListener.create({
            event: cc.EventListener.TOUCH_ONE_BY_ONE,
            swallowTouches: !0,
            onTouchBegan: this.onTouchBegan.bind(this),
            onTouchMoved: this.onTouchMoved.bind(this),
            onTouchEnded: this.onTouchEnded.bind(this)
        })), cc.eventManager.addListener(this._touchListener, this)) : cc.eventManager.removeListener(this._touchListener))
    },
    isTouchEnabled: function() {
        return this._touchEnabled
    },
    isHighlighted: function() {
        return this._highlight
    },
    setHighlighted: function(a) {
        a != this._highlight && (this._highlight = a, this._bright ? this.setBrightStyle(this._highlight ? ccui.Widget.BRIGHT_STYLE_HIGH_LIGHT : ccui.Widget.BRIGHT_STYLE_NORMAL) : this._onPressStateChangedToDisabled())
    },
    isFocused: function() {
        return this._focused
    },
    setFocused: function(a) {
        this._focused = a, a && (ccui.Widget._focusedWidget = this)
    },
    isFocusEnabled: function() {
        return this._focusEnabled
    },
    setFocusEnabled: function(a) {
        this._focused = a
    },
    findNextFocusedWidget: function(a, b) {
        if (null == this.onNextFocusedWidget || null == this.onNextFocusedWidget(a)) {
            var c = b instanceof ccui.Layout;
            if (this.isFocused() || c) {
                var d = this.getParent();
                return null == d ? c ? b.findNextFocusedWidget(a, b) : b : d.findNextFocusedWidget(a, b)
            }
            return b
        }
        var e = this.onNextFocusedWidget(a);
        return this.dispatchFocusEvent(this, e), e
    },
    requestFocus: function() {
        this != ccui.Widget._focusedWidget && this.dispatchFocusEvent(ccui.Widget._focusedWidget, this)
    },
    getCurrentFocusedWidget: function() {
        return ccui.Widget._focusedWidget
    },
    enableDpadNavigation: function() {},
    onFocusChanged: null,
    onNextFocusedWidget: null,
    interceptTouchEvent: function(a, b, c) {
        var d = this.getWidgetParent();
        d && d.interceptTouchEvent(a, b, c)
    },
    onFocusChange: function(a, b) {
        a && a.setFocused(!1), b && b.setFocused(!0)
    },
    dispatchFocusEvent: function(a, b) {
        a && !a.isFocused() && (a = ccui.Widget._focusedWidget), b != a && (b && b.onFocusChanged && b.onFocusChanged(a, b), a && b.onFocusChanged && a.onFocusChanged(a, b), cc.eventManager.dispatchEvent(new cc.EventFocus(a, b)))
    },
    setBright: function(a) {
        this._bright = a, this._bright ? (this._brightStyle = ccui.Widget.BRIGHT_STYLE_NONE, this.setBrightStyle(ccui.Widget.BRIGHT_STYLE_NORMAL)) : this._onPressStateChangedToDisabled()
    },
    setBrightStyle: function(a) {
        if (this._brightStyle != a) switch (a = a || ccui.Widget.BRIGHT_STYLE_NORMAL, this._brightStyle = a, this._brightStyle) {
            case ccui.Widget.BRIGHT_STYLE_NORMAL:
                this._onPressStateChangedToNormal();
                break;
            case ccui.Widget.BRIGHT_STYLE_HIGH_LIGHT:
                this._onPressStateChangedToPressed()
        }
    },
    _onPressStateChangedToNormal: function() {},
    _onPressStateChangedToPressed: function() {},
    _onPressStateChangedToDisabled: function() {},
    _updateChildrenDisplayedRGBA: function() {
        this.setColor(this.getColor()), this.setOpacity(this.getOpacity())
    },
    didNotSelectSelf: function() {},
    onTouchBegan: function(a) {
        if (this._hit = !1, this.isVisible() && this.isEnabled() && this._isAncestorsEnabled() && this._isAncestorsVisible(this)) {
            var b = a.getLocation();
            this._touchBeganPosition.x = b.x, this._touchBeganPosition.y = b.y, this.hitTest(this._touchBeganPosition) && this.isClippingParentContainsPoint(this._touchBeganPosition) && (this._hit = !0)
        }
        return this._hit ? (this.setHighlighted(!0), this._propagateTouchEvents && this.propagateTouchEvent(ccui.Widget.TOUCH_BEGAN, this, a), this._pushDownEvent(), !0) : !1
    },
    propagateTouchEvent: function(a, b, c) {
        var d = this.getWidgetParent();
        d && d.interceptTouchEvent(a, b, c)
    },
    onTouchMoved: function(a) {
        var b = a.getLocation();
        this._touchMovePosition.x = b.x, this._touchMovePosition.y = b.y, this.setHighlighted(this.hitTest(b));
        var c = this.getWidgetParent();
        c && c.interceptTouchEvent(ccui.Widget.TOUCH_MOVED, this, a), this._moveEvent()
    },
    onTouchEnded: function(a) {
        var b = a.getLocation();
        this._touchEndPosition.x = b.x, this._touchEndPosition.y = b.y;
        var c = this.getWidgetParent();
        c && c.interceptTouchEvent(ccui.Widget.TOUCH_ENDED, this, a);
        var d = this._highlight;
        this.setHighlighted(!1), d ? this._releaseUpEvent() : this._cancelUpEvent()
    },
    onTouchCancelled: function() {
        this.setHighlighted(!1), this._cancelUpEvent()
    },
    onTouchLongClicked: function() {
        this.longClickEvent()
    },
    _pushDownEvent: function() {
        this._touchEventCallback && this._touchEventCallback(this, ccui.Widget.TOUCH_BEGAN), this._touchEventListener && this._touchEventSelector && this._touchEventSelector.call(this._touchEventListener, this, ccui.Widget.TOUCH_BEGAN)
    },
    _moveEvent: function() {
        this._touchEventCallback && this._touchEventCallback(this, ccui.Widget.TOUCH_MOVED), this._touchEventListener && this._touchEventSelector && this._touchEventSelector.call(this._touchEventListener, this, ccui.Widget.TOUCH_MOVED)
    },
    _releaseUpEvent: function() {
        this._touchEventCallback && this._touchEventCallback(this, ccui.Widget.TOUCH_ENDED), this._touchEventListener && this._touchEventSelector && this._touchEventSelector.call(this._touchEventListener, this, ccui.Widget.TOUCH_ENDED), this._clickEventListener && this._clickEventListener(this)
    },
    _cancelUpEvent: function() {
        this._touchEventCallback && this._touchEventCallback(this, ccui.Widget.TOUCH_CANCELED), this._touchEventListener && this._touchEventSelector && this._touchEventSelector.call(this._touchEventListener, this, ccui.Widget.TOUCH_CANCELED)
    },
    longClickEvent: function() {},
    addTouchEventListener: function(a, b) {
        void 0 === b ? this._touchEventCallback = a : (this._touchEventSelector = a, this._touchEventListener = b)
    },
    addClickEventListener: function(a) {
        this._clickEventListener = a
    },
    hitTest: function(a) {
        var b = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        return cc.rectContainsPoint(b, this.convertToNodeSpace(a))
    },
    isClippingParentContainsPoint: function(a) {
        this._affectByClipping = !1;
        for (var b = this.getParent(), c = null; b;) {
            if (b instanceof ccui.Layout && b.isClippingEnabled()) {
                this._affectByClipping = !0, c = b;
                break
            }
            b = b.getParent()
        }
        return this._affectByClipping && c ? c.hitTest(a) ? c.isClippingParentContainsPoint(a) : !1 : !0
    },
    checkChildInfo: function(a, b, c) {
        var d = this.getWidgetParent();
        d && d.checkChildInfo(a, b, c)
    },
    setPosition: function(a, b) {
        if (this._running) {
            var c = this.getWidgetParent();
            if (c) {
                var d = c.getContentSize();
                d.width <= 0 || d.height <= 0 ? (this._positionPercent.x = 0, this._positionPercent.y = 0) : void 0 == b ? (this._positionPercent.x = a.x / d.width, this._positionPercent.y = a.y / d.height) : (this._positionPercent.x = a / d.width, this._positionPercent.y = b / d.height)
            }
        }
        cc.Node.prototype.setPosition.call(this, a, b), this._positionType = ccui.Widget.POSITION_ABSOLUTE
    },
    setPositionX: function(a) {
        if (this._running) {
            var b = this.getWidgetParent();
            if (b) {
                var c = b.width;
                this._positionPercent.x = 0 >= c ? 0 : a / c
            }
        }
        cc.Node.prototype.setPositionX.call(this, a)
    },
    setPositionY: function(a) {
        if (this._running) {
            var b = this.getWidgetParent();
            if (b) {
                var c = b.height;
                this._positionPercent.y = 0 >= c ? 0 : a / c
            }
        }
        cc.Node.prototype.setPositionY.call(this, a)
    },
    setPositionPercent: function(a) {
        if (this._positionPercent = a, this._running) {
            var b = this.getWidgetParent();
            if (b) {
                var c = b.getSize();
                this.setPosition(c.width * this._positionPercent.x, c.height * this._positionPercent.y)
            }
        }
    },
    _setXPercent: function(a) {
        if (this._positionPercent.x = a, this._running) {
            var b = this.getWidgetParent();
            b && this.setPositionX(b.width * a)
        }
    },
    _setYPercent: function(a) {
        if (this._positionPercent.y = a, this._running) {
            var b = this.getWidgetParent();
            b && this.setPositionY(b.height * a)
        }
    },
    getPositionPercent: function() {
        return cc.p(this.getNormalizedPosition())
    },
    _getXPercent: function() {
        return this._positionPercent.x
    },
    _getYPercent: function() {
        return this._positionPercent.y
    },
    setPositionType: function(a) {
        this._positionType = a, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getPositionType: function() {
        return this._positionType
    },
    setFlippedX: function(a) {
        this._flippedX = a, this._updateFlippedX()
    },
    isFlippedX: function() {
        return this._flippedX
    },
    setFlippedY: function(a) {
        this._flippedY = a, this._updateFlippedY()
    },
    isFlippedY: function() {
        return this._flippedY
    },
    _updateFlippedX: function() {},
    _updateFlippedY: function() {},
    _adaptRenderers: function() {},
    isBright: function() {
        return this._bright
    },
    isEnabled: function() {
        return this._enabled
    },
    getLeftBoundary: function() {
        return this.getPositionX() - this._getAnchorX() * this._contentSize.width
    },
    getBottomBoundary: function() {
        return this.getPositionY() - this._getAnchorY() * this._contentSize.height
    },
    getRightBoundary: function() {
        return this.getLeftBoundary() + this._contentSize.width
    },
    getTopBoundary: function() {
        return this.getBottomBoundary() + this._contentSize.height
    },
    getTouchBeganPosition: function() {
        return cc.p(this._touchBeganPosition)
    },
    getTouchMovePosition: function() {
        return cc.p(this._touchMovePosition)
    },
    getTouchEndPosition: function() {
        return cc.p(this._touchEndPosition)
    },
    getWidgetType: function() {
        return this._widgetType
    },
    setLayoutParameter: function(a) {
        a && (this._layoutParameterDictionary[a.getLayoutType()] = a, this._layoutParameterType = a.getLayoutType())
    },
    getLayoutParameter: function(a) {
        return a = a || this._layoutParameterType, this._layoutParameterDictionary[a]
    },
    getDescription: function() {
        return "Widget"
    },
    clone: function() {
        var a = this._createCloneInstance();
        return a._copyProperties(this), a._copyClonedWidgetChildren(this), a
    },
    _createCloneInstance: function() {
        return new ccui.Widget
    },
    _copyClonedWidgetChildren: function(a) {
        for (var b = a.getChildren(), c = 0; c < b.length; c++) {
            var d = b[c];
            d instanceof ccui.Widget && this.addChild(d.clone())
        }
    },
    _copySpecialProperties: function() {},
    _copyProperties: function(a) {
        this.setEnabled(a.isEnabled()), this.setVisible(a.isVisible()), this.setBright(a.isBright()), this.setTouchEnabled(a.isTouchEnabled()), this.setLocalZOrder(a.getLocalZOrder()), this.setTag(a.getTag()), this.setName(a.getName()), this.setActionTag(a.getActionTag()), this._ignoreSize = a._ignoreSize, this.setContentSize(a._contentSize), this._customSize.width = a._customSize.width, this._customSize.height = a._customSize.height, this._copySpecialProperties(a), this._sizeType = a.getSizeType(), this._sizePercent.x = a._sizePercent.x, this._sizePercent.y = a._sizePercent.y, this._positionType = a._positionType, this._positionPercent.x = a._positionPercent.x, this._positionPercent.y = a._positionPercent.y, this.setPosition(a.getPosition()), this.setAnchorPoint(a.getAnchorPoint()), this.setScaleX(a.getScaleX()), this.setScaleY(a.getScaleY()), this.setRotation(a.getRotation()), this.setRotationX(a.getRotationX()), this.setRotationY(a.getRotationY()), this.setFlippedX(a.isFlippedX()), this.setFlippedY(a.isFlippedY()), this.setColor(a.getColor()), this.setOpacity(a.getOpacity()), this._touchEventCallback = a._touchEventCallback, this._touchEventListener = a._touchEventListener, this._touchEventSelector = a._touchEventSelector, this._clickEventListener = a._clickEventListener, this._focused = a._focused, this._focusEnabled = a._focusEnabled, this._propagateTouchEvents = a._propagateTouchEvents;
        for (var b in a._layoutParameterDictionary) {
            var c = a._layoutParameterDictionary[b];
            c && this.setLayoutParameter(c.clone())
        }
        this._onSizeChanged()
    },
    setActionTag: function(a) {
        this._actionTag = a
    },
    getActionTag: function() {
        return this._actionTag
    },
    getLeftInParent: function() {
        return cc.log("getLeftInParent is deprecated. Please use getLeftBoundary instead."), this.getLeftBoundary()
    },
    getBottomInParent: function() {
        return cc.log("getBottomInParent is deprecated. Please use getBottomBoundary instead."), this.getBottomBoundary()
    },
    getRightInParent: function() {
        return cc.log("getRightInParent is deprecated. Please use getRightBoundary instead."), this.getRightBoundary()
    },
    getTopInParent: function() {
        return cc.log("getTopInParent is deprecated. Please use getTopBoundary instead."), this.getTopBoundary()
    },
    getTouchEndPos: function() {
        return cc.log("getTouchEndPos is deprecated. Please use getTouchEndPosition instead."), this.getTouchEndPosition()
    },
    getTouchMovePos: function() {
        return cc.log("getTouchMovePos is deprecated. Please use getTouchMovePosition instead."), this.getTouchMovePosition()
    },
    clippingParentAreaContainPoint: function(a) {
        cc.log("clippingParentAreaContainPoint is deprecated. Please use isClippingParentContainsPoint instead."), this.isClippingParentContainsPoint(a)
    },
    getTouchStartPos: function() {
        return cc.log("getTouchStartPos is deprecated. Please use getTouchBeganPosition instead."), this.getTouchBeganPosition()
    },
    setSize: function(a) {
        this.setContentSize(a)
    },
    getSize: function() {
        return this.getContentSize()
    },
    addNode: function(a, b, c) {
        return a instanceof ccui.Widget ? void cc.log("Please use addChild to add a Widget.") : (cc.Node.prototype.addChild.call(this, a, b, c), void this._nodes.push(a))
    },
    getNodeByTag: function(a) {
        for (var b = this._nodes, c = 0; c < b.length; c++) {
            var d = b[c];
            if (d && d.getTag() == a) return d
        }
        return null
    },
    getNodes: function() {
        return this._nodes
    },
    removeNode: function(a, b) {
        cc.Node.prototype.removeChild.call(this, a, b), cc.arrayRemoveObject(this._nodes, a)
    },
    removeNodeByTag: function(a) {
        var b = this.getNodeByTag(a);
        b ? this.removeNode(b) : cc.log("cocos2d: removeNodeByTag(tag = %d): child not found!", a)
    },
    removeAllNodes: function() {
        for (var a = 0; a < this._nodes.length; a++) {
            var b = this._nodes[a];
            cc.Node.prototype.removeChild.call(this, b)
        }
        this._nodes.length = 0
    },
    _findLayout: function() {
        cc.renderer.childrenOrderDirty = !0;
        for (var a = this._parent; a;) {
            if (a._doLayout) {
                a._doLayoutDirty = !0;
                break
            }
            a = a._parent
        }
    },
    isUnifySizeEnabled: function() {
        return this._unifySize
    },
    setUnifySizeEnabled: function(a) {
        this._unifySize = a
    }
});
var _p = ccui.Widget.prototype;
_p.xPercent, cc.defineGetterSetter(_p, "xPercent", _p._getXPercent, _p._setXPercent), _p.yPercent, cc.defineGetterSetter(_p, "yPercent", _p._getYPercent, _p._setYPercent), _p.widthPercent, cc.defineGetterSetter(_p, "widthPercent", _p._getWidthPercent, _p._setWidthPercent), _p.heightPercent, cc.defineGetterSetter(_p, "heightPercent", _p._getHeightPercent, _p._setHeightPercent), _p.widgetParent, cc.defineGetterSetter(_p, "widgetParent", _p.getWidgetParent), _p.enabled, cc.defineGetterSetter(_p, "enabled", _p.isEnabled, _p.setEnabled), _p.focused, cc.defineGetterSetter(_p, "focused", _p.isFocused, _p.setFocused), _p.sizeType, cc.defineGetterSetter(_p, "sizeType", _p.getSizeType, _p.setSizeType), _p.widgetType, cc.defineGetterSetter(_p, "widgetType", _p.getWidgetType), _p.touchEnabled, cc.defineGetterSetter(_p, "touchEnabled", _p.isTouchEnabled, _p.setTouchEnabled), _p.updateEnabled, cc.defineGetterSetter(_p, "updateEnabled", _p.isUpdateEnabled, _p.setUpdateEnabled), _p.bright, cc.defineGetterSetter(_p, "bright", _p.isBright, _p.setBright), _p.name, cc.defineGetterSetter(_p, "name", _p.getName, _p.setName), _p.actionTag, cc.defineGetterSetter(_p, "actionTag", _p.getActionTag, _p.setActionTag), _p.opacity, cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity), _p = null, ccui.Widget.create = function() {
    return new ccui.Widget
}, ccui.Widget._focusedWidget = null, ccui.Widget.getCurrentFocusedWidget = function() {
    return ccui.Widget._focusedWidget
}, ccui.Widget.BRIGHT_STYLE_NONE = -1, ccui.Widget.BRIGHT_STYLE_NORMAL = 0, ccui.Widget.BRIGHT_STYLE_HIGH_LIGHT = 1, ccui.Widget.TYPE_WIDGET = 0, ccui.Widget.TYPE_CONTAINER = 1, ccui.Widget.LEFT = 0, ccui.Widget.RIGHT = 1, ccui.Widget.UP = 0, ccui.Widget.DOWN = 1, ccui.Widget.LOCAL_TEXTURE = 0, ccui.Widget.PLIST_TEXTURE = 1, ccui.Widget.TOUCH_BEGAN = 0, ccui.Widget.TOUCH_MOVED = 1, ccui.Widget.TOUCH_ENDED = 2, ccui.Widget.TOUCH_CANCELED = 3, ccui.Widget.SIZE_ABSOLUTE = 0, ccui.Widget.SIZE_PERCENT = 1, ccui.Widget.POSITION_ABSOLUTE = 0, ccui.Widget.POSITION_PERCENT = 1, cc.EventFocus = cc.Event.extend({
    _widgetGetFocus: null,
    _widgetLoseFocus: null,
    ctor: function(a, b) {
        this._widgetGetFocus = b, this._widgetLoseFocus = a
    }
}), ccui.Scale9Sprite = cc.Node.extend({
    _spriteRect: null,
    _capInsetsInternal: null,
    _positionsAreDirty: !1,
    _scale9Image: null,
    _topLeft: null,
    _top: null,
    _topRight: null,
    _left: null,
    _centre: null,
    _right: null,
    _bottomLeft: null,
    _bottom: null,
    _bottomRight: null,
    _cacheSprite: null,
    _cacheCanvas: null,
    _cacheContext: null,
    _cacheTexture: null,
    _scale9Dirty: !0,
    _opacityModifyRGB: !1,
    _originalSize: null,
    _preferredSize: null,
    _opacity: 0,
    _color: null,
    _capInsets: null,
    _insetLeft: 0,
    _insetTop: 0,
    _insetRight: 0,
    _insetBottom: 0,
    _spritesGenerated: !1,
    _spriteFrameRotated: !1,
    _textureLoaded: !1,
    _className: "Scale9Sprite",
    textureLoaded: function() {
        return this._textureLoaded
    },
    addLoadedEventListener: function(a, b) {
        this.addEventListener("load", a, b)
    },
    _updateCapInset: function() {
        var a, b = this._insetLeft,
            c = this._insetTop,
            d = this._insetRight,
            e = this._spriteRect,
            f = this._insetBottom;
        a = 0 === b && 0 === c && 0 === d && 0 === f ? cc.rect(0, 0, 0, 0) : this._spriteFrameRotated ? cc.rect(f, b, e.width - d - b, e.height - c - f) : cc.rect(b, c, e.width - b - d, e.height - c - f), this.setCapInsets(a)
    },
    _updatePositions: function() {
        if (this._topLeft && this._topRight && this._bottomRight && this._bottomLeft && this._centre) {
            var a = this._contentSize,
                b = this._topLeft,
                c = this._topRight,
                d = this._bottomRight,
                e = this._bottomLeft,
                f = this._centre,
                g = this._centre.getContentSize(),
                h = b.getContentSize(),
                i = e.getContentSize(),
                j = a.width - h.width - c.getContentSize().width,
                k = a.height - h.height - d.getContentSize().height,
                l = j / g.width,
                m = k / g.height,
                n = g.width * l,
                o = g.height * m,
                p = i.width,
                q = i.height;
            if (cc._renderType == cc._RENDER_TYPE_WEBGL) {
                var r = Math.round(n);
                n != r && (n = r, l = n / g.width);
                var s = Math.round(o);
                o != s && (o = s, m = o / g.height)
            }
            f.setScaleX(l), f.setScaleY(m);
            var t = this._left,
                u = this._right,
                v = this._top,
                w = this._bottom,
                x = cc.p(0, 0);
            e.setAnchorPoint(x), d.setAnchorPoint(x), b.setAnchorPoint(x), c.setAnchorPoint(x), t.setAnchorPoint(x), u.setAnchorPoint(x), v.setAnchorPoint(x), w.setAnchorPoint(x), f.setAnchorPoint(x), e.setPosition(0, 0), d.setPosition(p + n, 0), b.setPosition(0, q + o), c.setPosition(p + n, q + o), t.setPosition(0, q), t.setScaleY(m), u.setPosition(p + n, q), u.setScaleY(m), w.setPosition(p, 0), w.setScaleX(l), v.setPosition(p, q + o), v.setScaleX(l), f.setPosition(p, q)
        }
    },
    ctor: function(a, b, c) {
        if (cc.Node.prototype.ctor.call(this), this._spriteRect = cc.rect(0, 0, 0, 0), this._capInsetsInternal = cc.rect(0, 0, 0, 0), this._originalSize = cc.size(0, 0), this._preferredSize = cc.size(0, 0), this._capInsets = cc.rect(0, 0, 0, 0), void 0 != a)
            if (a instanceof cc.SpriteFrame) this.initWithSpriteFrame(a, b);
            else {
                var d = cc.spriteFrameCache.getSpriteFrame(a);
                null != d ? this.initWithSpriteFrame(d, b) : this.initWithFile(a, b, c)
            } else this.init()
    },
    getSprite: function() {
        return this._scale9Image
    },
    getOriginalSize: function() {
        return cc.size(this._originalSize)
    },
    getPreferredSize: function() {
        return cc.size(this._preferredSize)
    },
    _getPreferredWidth: function() {
        return this._preferredSize.width
    },
    _getPreferredHeight: function() {
        return this._preferredSize.height
    },
    setPreferredSize: function(a) {
        this.setContentSize(a), this._preferredSize = a, this._positionsAreDirty && (this._updatePositions(), this._positionsAreDirty = !1, this._scale9Dirty = !0)
    },
    _setPreferredWidth: function(a) {
        this._setWidth(a), this._preferredSize.width = a
    },
    _setPreferredHeight: function(a) {
        this._setHeight(a), this._preferredSize.height = a
    },
    setOpacity: function(a) {
        if (this._scale9Image) {
            cc.Node.prototype.setOpacity.call(this, a);
            for (var b = this._scale9Image.getChildren(), c = 0; c < b.length; c++) {
                var d = b[c];
                d && d.setOpacity(a)
            }
            this._scale9Dirty = !0
        }
    },
    setColor: function(a) {
        if (this._scale9Image) {
            cc.Node.prototype.setColor.call(this, a);
            for (var b = this._scale9Image.getChildren(), c = 0; c < b.length; c++) {
                var d = b[c];
                d && d.setColor(a)
            }
            this._scale9Dirty = !0
        }
    },
    getCapInsets: function() {
        return cc.rect(this._capInsets)
    },
    setCapInsets: function(a) {
        if (this._scale9Image) {
            var b = this._contentSize,
                c = b.width,
                d = b.height;
            this.updateWithBatchNode(this._scale9Image, this._spriteRect, this._spriteFrameRotated, a), this.setContentSize(c, d)
        }
    },
    getInsetLeft: function() {
        return this._insetLeft
    },
    setInsetLeft: function(a) {
        this._insetLeft = a, this._updateCapInset()
    },
    getInsetTop: function() {
        return this._insetTop
    },
    setInsetTop: function(a) {
        this._insetTop = a, this._updateCapInset()
    },
    getInsetRight: function() {
        return this._insetRight
    },
    setInsetRight: function(a) {
        this._insetRight = a, this._updateCapInset()
    },
    getInsetBottom: function() {
        return this._insetBottom
    },
    setInsetBottom: function(a) {
        this._insetBottom = a, this._updateCapInset()
    },
    setContentSize: function(a, b) {
        cc.Node.prototype.setContentSize.call(this, a, b), this._positionsAreDirty = !0
    },
    _setWidth: function(a) {
        cc.Node.prototype._setWidth.call(this, a), this._positionsAreDirty = !0
    },
    _setHeight: function(a) {
        cc.Node.prototype._setHeight.call(this, a), this._positionsAreDirty = !0
    },
    init: function() {
        return this.initWithBatchNode(null, cc.rect(0, 0, 0, 0), !1, cc.rect(0, 0, 0, 0))
    },
    initWithBatchNode: function(a, b, c, d) {
        return void 0 === d && (d = c, c = !1), a && this.updateWithBatchNode(a, b, c, d), this.setCascadeColorEnabled(!0), this.setCascadeOpacityEnabled(!0), this.setAnchorPoint(.5, .5), this._positionsAreDirty = !0, !0
    },
    initWithFile: function(a, b, c) {
        if (a instanceof cc.Rect ? (a = arguments[1], c = arguments[0], b = cc.rect(0, 0, 0, 0)) : (b = b || cc.rect(0, 0, 0, 0), c = c || cc.rect(0, 0, 0, 0)), !a) throw "ccui.Scale9Sprite.initWithFile(): file should be non-null";
        var d = cc.textureCache.getTextureForKey(a);
        d || (d = cc.textureCache.addImage(a));
        var e = d.isLoaded();
        return this._textureLoaded = e, e || d.addEventListener("load", function(a) {
            var b = this._preferredSize;
            b = cc.size(b.width, b.height);
            var c = a.getContentSize();
            this.updateWithBatchNode(this._scale9Image, cc.rect(0, 0, c.width, c.height), !1, this._capInsets), this.setPreferredSize(b), this._positionsAreDirty = !0, this.dispatchEvent("load")
        }, this), this.initWithBatchNode(new cc.SpriteBatchNode(a, 9), b, !1, c)
    },
    initWithSpriteFrame: function(a, b) {
        if (!a || !a.getTexture()) throw "ccui.Scale9Sprite.initWithSpriteFrame(): spriteFrame should be non-null and its texture should be non-null";
        b = b || cc.rect(0, 0, 0, 0);
        var c = a.textureLoaded();
        this._textureLoaded = c, c || a.addEventListener("load", function(a) {
            var b = this._preferredSize;
            b = cc.size(b.width, b.height), this.updateWithBatchNode(this._scale9Image, a.getRect(), cc._renderType == cc._RENDER_TYPE_WEBGL && a.isRotated(), this._capInsets), this.setPreferredSize(b), this._positionsAreDirty = !0, this.dispatchEvent("load")
        }, this);
        var d = new cc.SpriteBatchNode(a.getTexture(), 9);
        return this.initWithBatchNode(d, a.getRect(), cc._renderType == cc._RENDER_TYPE_WEBGL && a.isRotated(), b)
    },
    initWithSpriteFrameName: function(a, b) {
        if (!a) throw "ccui.Scale9Sprite.initWithSpriteFrameName(): spriteFrameName should be non-null";
        b = b || cc.rect(0, 0, 0, 0);
        var c = cc.spriteFrameCache.getSpriteFrame(a);
        return null == c ? (cc.log("ccui.Scale9Sprite.initWithSpriteFrameName(): can't find the sprite frame by spriteFrameName"), !1) : this.initWithSpriteFrame(c, b)
    },
    resizableSpriteWithCapInsets: function(a) {
        var b = new ccui.Scale9Sprite;
        return b && b.initWithBatchNode(this._scale9Image, this._spriteRect, !1, a) ? b : null
    },
    setOpacityModifyRGB: function(a) {
        if (this._scale9Image) {
            this._opacityModifyRGB = a;
            var b = this._scale9Image.getChildren();
            if (b)
                for (var c = 0, d = b.length; d > c; c++) b[c].setOpacityModifyRGB(a)
        }
    },
    isOpacityModifyRGB: function() {
        return this._opacityModifyRGB
    },
    updateWithBatchNode: function(a, b, c, d) {
        var e = this.getOpacity(),
            f = this.getColor(),
            g = cc.rect(b.x, b.y, b.width, b.height);
        if (this.removeAllChildren(!0), this._scale9Image != a && (this._scale9Image = a), !this._scale9Image) return !1;
        var h = a.getTexture(),
            i = h.isLoaded();
        if (this._textureLoaded = i, !i) return h.addEventListener("load", function() {
            this._positionsAreDirty = !0, this.dispatchEvent("load")
        }, this), !0;
        var j = this._scale9Image;
        j.removeAllChildren(!0);
        var k = this._capInsets;
        k.x = d.x, k.y = d.y, k.width = d.width, k.height = d.height, this._spriteFrameRotated = c;
        var l = j.getTexture();
        if (cc._rectEqualToZero(g)) {
            var m = l.getContentSize();
            g = cc.rect(0, 0, m.width, m.height)
        }
        this._spriteRect = g;
        var n = this._spriteRect;
        n.x = g.x, n.y = g.y, n.width = g.width, n.height = g.height, this._originalSize.width = g.width, this._originalSize.height = g.height;
        var o = this._preferredSize;
        0 === o.width && 0 === o.height && (o.width = g.width, o.height = g.height);
        var p = this._capInsetsInternal;
        d && (p.x = d.x, p.y = d.y, p.width = d.width, p.height = d.height);
        var q = g.width,
            r = g.height;
        cc._rectEqualToZero(p) && (p.x = q / 3, p.y = r / 3, p.width = q / 3, p.height = r / 3);
        var s = p.x,
            t = p.width,
            u = q - (s + t),
            v = p.y,
            w = p.height,
            x = r - (v + w),
            y = 0,
            z = 0,
            A = cc.rect(y + .5 | 0, z + .5 | 0, s + .5 | 0, v + .5 | 0);
        y += s;
        var B = cc.rect(y + .5 | 0, z + .5 | 0, t + .5 | 0, v + .5 | 0);
        y += t;
        var C = cc.rect(y + .5 | 0, z + .5 | 0, u + .5 | 0, v + .5 | 0);
        y = 0, z = 0, z += v;
        var D = cc.rect(y + .5 | 0, z + .5 | 0, s + .5 | 0, w + .5 | 0);
        y += s;
        var E = cc.rect(y + .5 | 0, z + .5 | 0, t + .5 | 0, w + .5 | 0);
        y += t;
        var F = cc.rect(y + .5 | 0, z + .5 | 0, u + .5 | 0, w + .5 | 0);
        y = 0, z = 0, z += v, z += w;
        var G = cc.rect(y + .5 | 0, z + .5 | 0, s + .5 | 0, x + .5 | 0);
        y += s;
        var H = cc.rect(y + .5 | 0, z + .5 | 0, t + .5 | 0, x + .5 | 0);
        y += t;
        var I = cc.rect(y + .5 | 0, z + .5 | 0, u + .5 | 0, x + .5 | 0),
            J = cc.affineTransformMakeIdentity();
        if (c) {
            var K = E,
                L = I,
                M = G,
                N = C,
                O = A,
                P = F,
                Q = D,
                R = H,
                S = B;
            J = cc.affineTransformTranslate(J, g.height + g.x, g.y), J = cc.affineTransformRotate(J, 1.57079633), E = cc.rectApplyAffineTransform(E, J), I = cc.rectApplyAffineTransform(I, J), G = cc.rectApplyAffineTransform(G, J), C = cc.rectApplyAffineTransform(C, J), A = cc.rectApplyAffineTransform(A, J), F = cc.rectApplyAffineTransform(F, J), D = cc.rectApplyAffineTransform(D, J), H = cc.rectApplyAffineTransform(H, J), B = cc.rectApplyAffineTransform(B, J), K.x = E.x, K.y = E.y, L.x = I.x, L.y = I.y, M.x = G.x, M.y = G.y, N.x = C.x, N.y = C.y, O.x = A.x, O.y = A.y, P.x = F.x, P.y = F.y, Q.x = D.x, Q.y = D.y, R.x = H.x, R.y = H.y, S.x = B.x, S.y = B.y, this._centre = new cc.Sprite, this._centre.initWithTexture(l, K, !0), j.addChild(this._centre, 0, ccui.Scale9Sprite.POSITIONS_CENTRE), this._top = new cc.Sprite, this._top.initWithTexture(l, S, !0), j.addChild(this._top, 1, ccui.Scale9Sprite.POSITIONS_TOP), this._bottom = new cc.Sprite, this._bottom.initWithTexture(l, R, !0), j.addChild(this._bottom, 1, ccui.Scale9Sprite.POSITIONS_BOTTOM), this._left = new cc.Sprite, this._left.initWithTexture(l, Q, !0), j.addChild(this._left, 1, ccui.Scale9Sprite.POSITIONS_LEFT), this._right = new cc.Sprite, this._right.initWithTexture(l, P, !0), j.addChild(this._right, 1, ccui.Scale9Sprite.POSITIONS_RIGHT), this._topLeft = new cc.Sprite, this._topLeft.initWithTexture(l, O, !0), j.addChild(this._topLeft, 2, ccui.Scale9Sprite.POSITIONS_TOPLEFT), this._topRight = new cc.Sprite, this._topRight.initWithTexture(l, N, !0), j.addChild(this._topRight, 2, ccui.Scale9Sprite.POSITIONS_TOPRIGHT), this._bottomLeft = new cc.Sprite, this._bottomLeft.initWithTexture(l, M, !0), j.addChild(this._bottomLeft, 2, ccui.Scale9Sprite.POSITIONS_BOTTOMLEFT), this._bottomRight = new cc.Sprite, this._bottomRight.initWithTexture(l, L, !0), j.addChild(this._bottomRight, 2, ccui.Scale9Sprite.POSITIONS_BOTTOMRIGHT)
        } else J = cc.affineTransformTranslate(J, g.x, g.y), cc._rectApplyAffineTransformIn(E, J), cc._rectApplyAffineTransformIn(I, J), cc._rectApplyAffineTransformIn(G, J), cc._rectApplyAffineTransformIn(C, J), cc._rectApplyAffineTransformIn(A, J), cc._rectApplyAffineTransformIn(F, J), cc._rectApplyAffineTransformIn(D, J), cc._rectApplyAffineTransformIn(H, J), cc._rectApplyAffineTransformIn(B, J), this._centre = new cc.Sprite, this._centre.initWithTexture(l, E), j.addChild(this._centre, 0, ccui.Scale9Sprite.POSITIONS_CENTRE), this._top = new cc.Sprite, this._top.initWithTexture(l, B), j.addChild(this._top, 1, ccui.Scale9Sprite.POSITIONS_TOP), this._bottom = new cc.Sprite, this._bottom.initWithTexture(l, H), j.addChild(this._bottom, 1, ccui.Scale9Sprite.POSITIONS_BOTTOM), this._left = new cc.Sprite, this._left.initWithTexture(l, D), j.addChild(this._left, 1, ccui.Scale9Sprite.POSITIONS_LEFT), this._right = new cc.Sprite, this._right.initWithTexture(l, F), j.addChild(this._right, 1, ccui.Scale9Sprite.POSITIONS_RIGHT), this._topLeft = new cc.Sprite, this._topLeft.initWithTexture(l, A), j.addChild(this._topLeft, 2, ccui.Scale9Sprite.POSITIONS_TOPLEFT), this._topRight = new cc.Sprite, this._topRight.initWithTexture(l, C), j.addChild(this._topRight, 2, ccui.Scale9Sprite.POSITIONS_TOPRIGHT), this._bottomLeft = new cc.Sprite, this._bottomLeft.initWithTexture(l, G), j.addChild(this._bottomLeft, 2, ccui.Scale9Sprite.POSITIONS_BOTTOMLEFT), this._bottomRight = new cc.Sprite, this._bottomRight.initWithTexture(l, I), j.addChild(this._bottomRight, 2, ccui.Scale9Sprite.POSITIONS_BOTTOMRIGHT);
        return this.setContentSize(g.width, g.height), cc._renderType === cc._RENDER_TYPE_WEBGL && this.addChild(j), this._spritesGenerated && (this.setOpacity(e), this.setColor(f)), this._spritesGenerated = !0, !0
    },
    setSpriteFrame: function(a) {
        var b = new cc.SpriteBatchNode(a.getTexture(), 9),
            c = a.textureLoaded();
        this._textureLoaded = c, c || a.addEventListener("load", function(a) {
            var b = this._preferredSize;
            b = cc.size(b.width, b.height), this.updateWithBatchNode(this._scale9Image, a.getRect(), cc._renderType == cc._RENDER_TYPE_WEBGL && a.isRotated(), this._capInsets), this.setPreferredSize(b), this._positionsAreDirty = !0, this.dispatchEvent("load")
        }, this), this.updateWithBatchNode(b, a.getRect(), cc._renderType == cc._RENDER_TYPE_WEBGL && a.isRotated(), cc.rect(0, 0, 0, 0)), this._insetLeft = 0, this._insetTop = 0, this._insetRight = 0, this._insetBottom = 0
    },
    _createRenderCmd: function() {
        return cc._renderType === cc._RENDER_TYPE_CANVAS ? new ccui.Scale9Sprite.CanvasRenderCmd(this) : new ccui.Scale9Sprite.WebGLRenderCmd(this)
    }
});
var _p = ccui.Scale9Sprite.prototype;
cc.EventHelper.prototype.apply(_p), _p.preferredSize, cc.defineGetterSetter(_p, "preferredSize", _p.getPreferredSize, _p.setPreferredSize), _p.capInsets, cc.defineGetterSetter(_p, "capInsets", _p.getCapInsets, _p.setCapInsets), _p.insetLeft, cc.defineGetterSetter(_p, "insetLeft", _p.getInsetLeft, _p.setInsetLeft), _p.insetTop, cc.defineGetterSetter(_p, "insetTop", _p.getInsetTop, _p.setInsetTop), _p.insetRight, cc.defineGetterSetter(_p, "insetRight", _p.getInsetRight, _p.setInsetRight), _p.insetBottom, cc.defineGetterSetter(_p, "insetBottom", _p.getInsetBottom, _p.setInsetBottom), _p = null, ccui.Scale9Sprite.create = function(a, b, c) {
        return new ccui.Scale9Sprite(a, b, c)
    }, ccui.Scale9Sprite.createWithSpriteFrame = function(a, b) {
        return new ccui.Scale9Sprite(a, b)
    }, ccui.Scale9Sprite.createWithSpriteFrameName = function(a, b) {
        return new ccui.Scale9Sprite(a, b)
    }, ccui.Scale9Sprite.POSITIONS_CENTRE = 0, ccui.Scale9Sprite.POSITIONS_TOP = 1, ccui.Scale9Sprite.POSITIONS_LEFT = 2, ccui.Scale9Sprite.POSITIONS_RIGHT = 3, ccui.Scale9Sprite.POSITIONS_BOTTOM = 4, ccui.Scale9Sprite.POSITIONS_TOPRIGHT = 5, ccui.Scale9Sprite.POSITIONS_TOPLEFT = 6, ccui.Scale9Sprite.POSITIONS_BOTTOMRIGHT = 7,
    function() {
        ccui.Scale9Sprite.CanvasRenderCmd = function(a) {
            cc.Node.CanvasRenderCmd.call(this, a), this._cachedParent = null, this._cacheDirty = !1;
            var b = this._node,
                c = this._cacheCanvas = cc.newElement("canvas");
            c.width = 1, c.height = 1, this._cacheContext = new cc.CanvasContextWrapper(c.getContext("2d"));
            var d = this._cacheTexture = new cc.Texture2D;
            d.initWithElement(c), d.handleLoadedTexture(), this._cacheSprite = new cc.Sprite(d), this._cacheSprite.setAnchorPoint(0, 0), b.addChild(this._cacheSprite)
        };
        var a = ccui.Scale9Sprite.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
        a.constructor = ccui.Scale9Sprite.CanvasRenderCmd, a.visit = function(a) {
            var b = this._node;
            b._visible && (b._positionsAreDirty && (b._updatePositions(), b._positionsAreDirty = !1, b._scale9Dirty = !0), b._scale9Dirty = !1, this._cacheScale9Sprite(), cc.Node.CanvasRenderCmd.prototype.visit.call(this, a))
        }, a.transform = function(a) {
            var b = this._node;
            this._cacheScale9Sprite(), cc.Node.CanvasRenderCmd.prototype.transform.call(this, a);
            for (var c = b._children, d = 0; d < c.length; d++) c[d].transform(this)
        }, a._updateDisplayColor = function(a) {
            cc.Node.CanvasRenderCmd.prototype._updateDisplayColor.call(this, a);
            var b = this._node._scale9Image;
            if (b) {
                for (var c = b.getChildren(), d = 0; d < c.length; d++) {
                    var e = c[d];
                    e && e._renderCmd._updateDisplayColor(a)
                }
                this._cacheScale9Sprite()
            }
        }, a._cacheScale9Sprite = function() {
            var a = this._node;
            if (a._scale9Image) {
                var b = cc.contentScaleFactor(),
                    c = a._contentSize,
                    d = cc.size(c.width * b, c.height * b),
                    e = this._cacheCanvas,
                    f = this._cacheContext,
                    g = f.getContext(),
                    h = !1;
                (e.width != d.width || e.height != d.height) && (e.width = d.width, e.height = d.height, h = !0), cc.renderer._turnToCacheMode(a.__instanceId), a._scale9Image.visit(), g.setTransform(1, 0, 0, 1, 0, 0), g.clearRect(0, 0, d.width, d.height), cc.renderer._renderingToCacheCanvas(f, a.__instanceId, b, b), h && this._cacheSprite.setTextureRect(cc.rect(0, 0, c.width, c.height)), this._cacheSprite.getParent() || a.addChild(this._cacheSprite, -1)
            }
        }
    }(), ccui.Layout = ccui.Widget.extend({
        _clippingEnabled: !1,
        _backGroundScale9Enabled: null,
        _backGroundImage: null,
        _backGroundImageFileName: null,
        _backGroundImageCapInsets: null,
        _colorType: null,
        _bgImageTexType: ccui.Widget.LOCAL_TEXTURE,
        _colorRender: null,
        _gradientRender: null,
        _color: null,
        _startColor: null,
        _endColor: null,
        _alongVector: null,
        _opacity: 255,
        _backGroundImageTextureSize: null,
        _layoutType: null,
        _doLayoutDirty: !0,
        _clippingRectDirty: !0,
        _clippingType: null,
        _clippingStencil: null,
        _scissorRectDirty: !1,
        _clippingRect: null,
        _clippingParent: null,
        _className: "Layout",
        _backGroundImageColor: null,
        _finalPositionX: 0,
        _finalPositionY: 0,
        _backGroundImageOpacity: 0,
        _loopFocus: !1,
        __passFocusToChild: !1,
        _isFocusPassing: !1,
        _isInterceptTouch: !1,
        ctor: function() {
            this._layoutType = ccui.Layout.ABSOLUTE, this._widgetType = ccui.Widget.TYPE_CONTAINER, this._clippingType = ccui.Layout.CLIPPING_STENCIL, this._colorType = ccui.Layout.BG_COLOR_NONE, ccui.Widget.prototype.ctor.call(this), this._backGroundImageCapInsets = cc.rect(0, 0, 0, 0), this._color = cc.color(255, 255, 255, 255), this._startColor = cc.color(255, 255, 255, 255), this._endColor = cc.color(255, 255, 255, 255), this._alongVector = cc.p(0, -1), this._backGroundImageTextureSize = cc.size(0, 0), this._clippingRect = cc.rect(0, 0, 0, 0), this._backGroundImageColor = cc.color(255, 255, 255, 255)
        },
        onEnter: function() {
            ccui.Widget.prototype.onEnter.call(this), this._clippingStencil && this._clippingStencil.onEnter(), this._doLayoutDirty = !0, this._clippingRectDirty = !0
        },
        onExit: function() {
            ccui.Widget.prototype.onExit.call(this), this._clippingStencil && this._clippingStencil.onExit()
        },
        setLoopFocus: function(a) {
            this._loopFocus = a
        },
        isLoopFocus: function() {
            return this._loopFocus
        },
        setPassFocusToChild: function(a) {
            this.__passFocusToChild = a
        },
        isPassFocusToChild: function() {
            return this.__passFocusToChild
        },
        findNextFocusedWidget: function(a, b) {
            if (this._isFocusPassing || this.isFocused()) {
                var c = this.getParent();
                if (this._isFocusPassing = !1, this.__passFocusToChild) {
                    var d = this._passFocusToChild(a, b);
                    return d instanceof ccui.Layout && c ? (c._isFocusPassing = !0, c.findNextFocusedWidget(a, this)) : d
                }
                return null == c ? this : (c._isFocusPassing = !0, c.findNextFocusedWidget(a, this))
            }
            if (!(b.isFocused() || b instanceof ccui.Layout)) return b;
            if (this._layoutType == ccui.Layout.LINEAR_HORIZONTAL) switch (a) {
                case ccui.Widget.LEFT:
                    return this._getPreviousFocusedWidget(a, b);
                case ccui.Widget.RIGHT:
                    return this._getNextFocusedWidget(a, b);
                case ccui.Widget.DOWN:
                case ccui.Widget.UP:
                    return this._isLastWidgetInContainer(this, a) ? this._isWidgetAncestorSupportLoopFocus(b, a) ? this.findNextFocusedWidget(a, this) : b : this.findNextFocusedWidget(a, this);
                default:
                    return cc.assert(0, "Invalid Focus Direction"), b
            } else {
                if (this._layoutType != ccui.Layout.LINEAR_VERTICAL) return cc.assert(0, "Un Supported Layout type, please use VBox and HBox instead!!!"), b;
                switch (a) {
                    case ccui.Widget.LEFT:
                    case ccui.Widget.RIGHT:
                        return this._isLastWidgetInContainer(this, a) ? this._isWidgetAncestorSupportLoopFocus(b, a) ? this.findNextFocusedWidget(a, this) : b : this.findNextFocusedWidget(a, this);
                    case ccui.Widget.DOWN:
                        return this._getNextFocusedWidget(a, b);
                    case ccui.Widget.UP:
                        return this._getPreviousFocusedWidget(a, b);
                    default:
                        return cc.assert(0, "Invalid Focus Direction"), b
                }
            }
        },
        onPassFocusToChild: null,
        init: function() {
            return ccui.Widget.prototype.init.call(this) ? (this.ignoreContentAdaptWithSize(!1), this.setContentSize(cc.size(0, 0)), this.setAnchorPoint(0, 0), this.onPassFocusToChild = this._findNearestChildWidgetIndex.bind(this), !0) : !1
        },
        addChild: function(a, b, c) {
            a instanceof ccui.Widget && this._supplyTheLayoutParameterLackToChild(a), ccui.Widget.prototype.addChild.call(this, a, b, c), this._doLayoutDirty = !0
        },
        removeChild: function(a, b) {
            ccui.Widget.prototype.removeChild.call(this, a, b), this._doLayoutDirty = !0
        },
        removeAllChildren: function(a) {
            ccui.Widget.prototype.removeAllChildren.call(this, a), this._doLayoutDirty = !0
        },
        removeAllChildrenWithCleanup: function(a) {
            ccui.Widget.prototype.removeAllChildrenWithCleanup.call(this, a), this._doLayoutDirty = !0
        },
        isClippingEnabled: function() {
            return this._clippingEnabled
        },
        visit: function(a) {
            if (this._visible)
                if (this._adaptRenderers(), this._doLayout(), this._clippingEnabled) switch (this._clippingType) {
                    case ccui.Layout.CLIPPING_STENCIL:
                        this._renderCmd.stencilClippingVisit(a);
                        break;
                    case ccui.Layout.CLIPPING_SCISSOR:
                        this._renderCmd.scissorClippingVisit(a)
                } else ccui.Widget.prototype.visit.call(this, a)
        },
        setClippingEnabled: function(a) {
            if (a != this._clippingEnabled) switch (this._clippingEnabled = a, this._clippingType) {
                case ccui.Layout.CLIPPING_STENCIL:
                    a ? (this._clippingStencil = new cc.DrawNode, this._renderCmd.rebindStencilRendering(this._clippingStencil), this._running && this._clippingStencil.onEnter(), this._setStencilClippingSize(this._contentSize)) : (this._running && this._clippingStencil && this._clippingStencil.onExit(), this._clippingStencil = null)
            }
        },
        setClippingType: function(a) {
            if (a != this._clippingType) {
                if (cc._renderType === cc._RENDER_TYPE_CANVAS && a == ccui.Layout.CLIPPING_SCISSOR) return void cc.log("Only supports STENCIL on canvas mode.");
                var b = this.isClippingEnabled();
                this.setClippingEnabled(!1), this._clippingType = a, this.setClippingEnabled(b)
            }
        },
        getClippingType: function() {
            return this._clippingType
        },
        _setStencilClippingSize: function(a) {
            if (this._clippingEnabled && this._clippingType == ccui.Layout.CLIPPING_STENCIL) {
                var b = [];
                b[0] = cc.p(0, 0), b[1] = cc.p(a.width, 0), b[2] = cc.p(a.width, a.height), b[3] = cc.p(0, a.height);
                var c = cc.color.GREEN;
                this._clippingStencil.clear(), this._clippingStencil.drawPoly(b, 4, c, 0, c)
            }
        },
        _getClippingRect: function() {
            if (this._clippingRectDirty) {
                for (var a, b = this.convertToWorldSpace(cc.p(0, 0)), c = this.getNodeToWorldTransform(), d = this._contentSize.width * c.a, e = this._contentSize.height * c.d, f = this; f;)
                    if (f = f.getParent(), f && f instanceof ccui.Layout && f.isClippingEnabled()) {
                        this._clippingParent = f;
                        break
                    }
                if (this._clippingParent) {
                    a = this._clippingParent._getClippingRect();
                    var g = b.x - d * this._anchorPoint.x,
                        h = b.y - e * this._anchorPoint.y,
                        i = d,
                        j = e,
                        k = b.x - a.x;
                    0 > k && (g = a.x, i += k);
                    var l = b.x + d - (a.x + a.width);
                    l > 0 && (i -= l);
                    var m = b.y + e - (a.y + a.height);
                    m > 0 && (j -= m);
                    var n = b.y - a.y;
                    0 > n && (h = a.x, j += n), 0 > i && (i = 0), 0 > j && (j = 0), this._clippingRect.x = g, this._clippingRect.y = h, this._clippingRect.width = i, this._clippingRect.height = j
                } else this._clippingRect.x = b.x - d * this._anchorPoint.x, this._clippingRect.y = b.y - e * this._anchorPoint.y, this._clippingRect.width = d, this._clippingRect.height = e;
                this._clippingRectDirty = !1
            }
            return this._clippingRect
        },
        _onSizeChanged: function() {
            ccui.Widget.prototype._onSizeChanged.call(this);
            var a = this._contentSize;
            this._setStencilClippingSize(a), this._doLayoutDirty = !0, this._clippingRectDirty = !0, this._backGroundImage && (this._backGroundImage.setPosition(.5 * a.width, .5 * a.height), this._backGroundScale9Enabled && this._backGroundImage instanceof ccui.Scale9Sprite && this._backGroundImage.setPreferredSize(a)), this._colorRender && this._colorRender.setContentSize(a), this._gradientRender && this._gradientRender.setContentSize(a)
        },
        setBackGroundImageScale9Enabled: function(a) {
            this._backGroundScale9Enabled != a && (this.removeProtectedChild(this._backGroundImage), this._backGroundImage = null, this._backGroundScale9Enabled = a, this._addBackGroundImage(), this.setBackGroundImage(this._backGroundImageFileName, this._bgImageTexType), this.setBackGroundImageCapInsets(this._backGroundImageCapInsets))
        },
        isBackGroundImageScale9Enabled: function() {
            return this._backGroundScale9Enabled
        },
        setBackGroundImage: function(a, b) {
            if (a) {
                b = b || ccui.Widget.LOCAL_TEXTURE, null == this._backGroundImage && (this._addBackGroundImage(), this.setBackGroundImageScale9Enabled(this._backGroundScale9Enabled)), this._backGroundImageFileName = a, this._bgImageTexType = b;
                var c = this._backGroundImage;
                if (this._backGroundScale9Enabled) {
                    var d = c;
                    switch (this._bgImageTexType) {
                        case ccui.Widget.LOCAL_TEXTURE:
                            d.initWithFile(a);
                            break;
                        case ccui.Widget.PLIST_TEXTURE:
                            d.initWithSpriteFrameName(a)
                    }
                    d.setPreferredSize(this._contentSize)
                } else {
                    var e = c;
                    switch (this._bgImageTexType) {
                        case ccui.Widget.LOCAL_TEXTURE:
                            e.initWithFile(a);
                            break;
                        case ccui.Widget.PLIST_TEXTURE:
                            e.initWithSpriteFrameName(a)
                    }
                }
                this._backGroundImageTextureSize = c.getContentSize(), c.setPosition(.5 * this._contentSize.width, .5 * this._contentSize.height), this._updateBackGroundImageColor()
            }
        },
        setBackGroundImageCapInsets: function(a) {
            if (a) {
                var b = this._backGroundImageCapInsets;
                b.x = a.x, b.y = a.y, b.width = a.width, b.height = a.height, this._backGroundScale9Enabled && this._backGroundImage.setCapInsets(a)
            }
        },
        getBackGroundImageCapInsets: function() {
            return cc.rect(this._backGroundImageCapInsets)
        },
        _supplyTheLayoutParameterLackToChild: function(a) {
            if (a) switch (this._layoutType) {
                case ccui.Layout.ABSOLUTE:
                    break;
                case ccui.Layout.LINEAR_HORIZONTAL:
                case ccui.Layout.LINEAR_VERTICAL:
                    var b = a.getLayoutParameter(ccui.LayoutParameter.LINEAR);
                    b || a.setLayoutParameter(new ccui.LinearLayoutParameter);
                    break;
                case ccui.Layout.RELATIVE:
                    var b = a.getLayoutParameter(ccui.LayoutParameter.RELATIVE);
                    b || a.setLayoutParameter(new ccui.RelativeLayoutParameter)
            }
        },
        _addBackGroundImage: function() {
            this._backGroundScale9Enabled ? (this._backGroundImage = new ccui.Scale9Sprite, this._backGroundImage.setPreferredSize(this._contentSize)) : this._backGroundImage = new cc.Sprite, this.addProtectedChild(this._backGroundImage, ccui.Layout.BACKGROUND_IMAGE_ZORDER, -1), this._backGroundImage.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
        },
        removeBackGroundImage: function() {
            this._backGroundImage && (this.removeProtectedChild(this._backGroundImage), this._backGroundImage = null, this._backGroundImageFileName = "", this._backGroundImageTextureSize.width = 0, this._backGroundImageTextureSize.height = 0)
        },
        setBackGroundColorType: function(a) {
            if (this._colorType != a) {
                switch (this._colorType) {
                    case ccui.Layout.BG_COLOR_NONE:
                        this._colorRender && (this.removeProtectedChild(this._colorRender), this._colorRender = null), this._gradientRender && (this.removeProtectedChild(this._gradientRender), this._gradientRender = null);
                        break;
                    case ccui.Layout.BG_COLOR_SOLID:
                        this._colorRender && (this.removeProtectedChild(this._colorRender), this._colorRender = null);
                        break;
                    case ccui.Layout.BG_COLOR_GRADIENT:
                        this._gradientRender && (this.removeProtectedChild(this._gradientRender), this._gradientRender = null)
                }
                switch (this._colorType = a, this._colorType) {
                    case ccui.Layout.BG_COLOR_NONE:
                        break;
                    case ccui.Layout.BG_COLOR_SOLID:
                        this._colorRender = new cc.LayerColor, this._colorRender.setContentSize(this._contentSize), this._colorRender.setOpacity(this._opacity), this._colorRender.setColor(this._color), this.addProtectedChild(this._colorRender, ccui.Layout.BACKGROUND_RENDERER_ZORDER, -1);
                        break;
                    case ccui.Layout.BG_COLOR_GRADIENT:
                        this._gradientRender = new cc.LayerGradient(cc.color(255, 0, 0, 255), cc.color(0, 255, 0, 255)), this._gradientRender.setContentSize(this._contentSize), this._gradientRender.setOpacity(this._opacity), this._gradientRender.setStartColor(this._startColor), this._gradientRender.setEndColor(this._endColor), this._gradientRender.setVector(this._alongVector), this.addProtectedChild(this._gradientRender, ccui.Layout.BACKGROUND_RENDERER_ZORDER, -1)
                }
            }
        },
        getBackGroundColorType: function() {
            return this._colorType
        },
        setBackGroundColor: function(a, b) {
            b ? (this._startColor.r = a.r, this._startColor.g = a.g, this._startColor.b = a.b, this._gradientRender && this._gradientRender.setStartColor(a), this._endColor.r = b.r, this._endColor.g = b.g, this._endColor.b = b.b, this._gradientRender && this._gradientRender.setEndColor(b)) : (this._color.r = a.r, this._color.g = a.g, this._color.b = a.b, this._colorRender && this._colorRender.setColor(a))
        },
        getBackGroundColor: function() {
            var a = this._color;
            return cc.color(a.r, a.g, a.b, a.a)
        },
        getBackGroundStartColor: function() {
            var a = this._startColor;
            return cc.color(a.r, a.g, a.b, a.a)
        },
        getBackGroundEndColor: function() {
            var a = this._endColor;
            return cc.color(a.r, a.g, a.b, a.a)
        },
        setBackGroundColorOpacity: function(a) {
            switch (this._opacity = a, this._colorType) {
                case ccui.Layout.BG_COLOR_NONE:
                    break;
                case ccui.Layout.BG_COLOR_SOLID:
                    this._colorRender.setOpacity(a);
                    break;
                case ccui.Layout.BG_COLOR_GRADIENT:
                    this._gradientRender.setOpacity(a)
            }
        },
        getBackGroundColorOpacity: function() {
            return this._opacity
        },
        setBackGroundColorVector: function(a) {
            this._alongVector.x = a.x, this._alongVector.y = a.y, this._gradientRender && this._gradientRender.setVector(a)
        },
        getBackGroundColorVector: function() {
            return this._alongVector
        },
        setBackGroundImageColor: function(a) {
            this._backGroundImageColor.r = a.r, this._backGroundImageColor.g = a.g, this._backGroundImageColor.b = a.b, this._updateBackGroundImageColor()
        },
        setBackGroundImageOpacity: function(a) {
            this._backGroundImageColor.a = a, this.getBackGroundImageColor()
        },
        getBackGroundImageColor: function() {
            var a = this._backGroundImageColor;
            return cc.color(a.r, a.g, a.b, a.a)
        },
        getBackGroundImageOpacity: function() {
            return this._backGroundImageColor.a
        },
        _updateBackGroundImageColor: function() {
            this._backGroundImage && this._backGroundImage.setColor(this._backGroundImageColor)
        },
        getBackGroundImageTextureSize: function() {
            return this._backGroundImageTextureSize
        },
        setLayoutType: function(a) {
            this._layoutType = a;
            for (var b = this._children, c = null, d = 0; d < b.length; d++) c = b[d], c instanceof ccui.Widget && this._supplyTheLayoutParameterLackToChild(c);
            this._doLayoutDirty = !0
        },
        getLayoutType: function() {
            return this._layoutType
        },
        requestDoLayout: function() {
            this._doLayoutDirty = !0
        },
        _doLayout: function() {
            if (this._doLayoutDirty) {
                this.sortAllChildren();
                var a = ccui.getLayoutManager(this._layoutType);
                a && a._doLayout(this), this._doLayoutDirty = !1
            }
        },
        _getLayoutContentSize: function() {
            return this.getContentSize()
        },
        _getLayoutElements: function() {
            return this.getChildren()
        },
        _updateBackGroundImageOpacity: function() {
            this._backGroundImage && this._backGroundImage.setOpacity(this._backGroundImageOpacity)
        },
        _updateBackGroundImageRGBA: function() {
            this._backGroundImage && (this._backGroundImage.setColor(this._backGroundImageColor), this._backGroundImage.setOpacity(this._backGroundImageOpacity))
        },
        _getLayoutAccumulatedSize: function() {
            for (var a, b = this.getChildren(), c = cc.size(0, 0), d = 0, e = 0, f = b.length; f > e; e++) {
                var g = b[e];
                if (null != g && g instanceof ccui.Layout) a = g._getLayoutAccumulatedSize(), c.width += a.width, c.height += a.height;
                else if (g instanceof ccui.Widget) {
                    d++;
                    var h = g.getLayoutParameter().getMargin();
                    a = g.getContentSize(), c.width += a.width + .5 * (h.right + h.left), c.height += a.height + .5 * (h.top + h.bottom)
                }
            }
            var i = this.getLayoutType();
            return i == ccui.Layout.LINEAR_HORIZONTAL && (c.height = c.height - c.height / d * (d - 1)), i == ccui.Layout.LINEAR_VERTICAL && (c.width = c.width - c.width / d * (d - 1)), c
        },
        _findNearestChildWidgetIndex: function(a, b) {
            if (null == b || b == this) return this._findFirstFocusEnabledWidgetIndex();
            var c, d = 0,
                e = this.getChildren(),
                f = e.length,
                g = cc.FLT_MAX,
                h = 0;
            if (a == ccui.Widget.LEFT || a == ccui.Widget.RIGHT || a == ccui.Widget.DOWN || a == ccui.Widget.UP) {
                for (c = this._getWorldCenterPoint(b); f > d;) {
                    var i = e[d];
                    if (i && i instanceof ccui.Widget && i.isFocusEnabled()) {
                        var j = i instanceof ccui.Layout ? i._calculateNearestDistance(b) : cc.pLength(cc.pSub(this._getWorldCenterPoint(i), c));
                        g > j && (h = d, g = j)
                    }
                    d++
                }
                return h
            }
            return cc.log("invalid focus direction!"), 0
        },
        _findFarthestChildWidgetIndex: function(a, b) {
            if (null == b || b == this) return this._findFirstFocusEnabledWidgetIndex();
            var c = 0,
                d = this.getChildren(),
                e = d.length,
                f = -cc.FLT_MAX,
                g = 0;
            if (a == ccui.Widget.LEFT || a == ccui.Widget.RIGHT || a == ccui.Widget.DOWN || a == ccui.Widget.UP) {
                for (var h = this._getWorldCenterPoint(b); e > c;) {
                    var i = d[c];
                    if (i && i instanceof ccui.Widget && i.isFocusEnabled()) {
                        var j = i instanceof ccui.Layout ? i._calculateFarthestDistance(b) : cc.pLength(cc.pSub(this._getWorldCenterPoint(i), h));
                        j > f && (g = c, f = j)
                    }
                    c++
                }
                return g
            }
            return cc.log("invalid focus direction!!!"), 0
        },
        _calculateNearestDistance: function(a) {
            for (var b = cc.FLT_MAX, c = this._getWorldCenterPoint(a), d = this._children, e = 0, f = d.length; f > e; e++) {
                var g, h = d[e];
                if (h instanceof ccui.Layout) g = h._calculateNearestDistance(a);
                else {
                    if (!(h instanceof ccui.Widget && h.isFocusEnabled())) continue;
                    g = cc.pLength(cc.pSub(this._getWorldCenterPoint(h), c))
                }
                b > g && (b = g)
            }
            return b
        },
        _calculateFarthestDistance: function(a) {
            for (var b = -cc.FLT_MAX, c = this._getWorldCenterPoint(a), d = this._children, e = 0, f = d.length; f > e; e++) {
                var g, h = d[e];
                if (h instanceof ccui.Layout) g = h._calculateFarthestDistance(a);
                else {
                    if (!(h instanceof ccui.Widget && h.isFocusEnabled())) continue;
                    var i = this._getWorldCenterPoint(h);
                    g = cc.pLength(cc.pSub(i, c))
                }
                g > b && (b = g)
            }
            return b
        },
        _findProperSearchingFunctor: function(a, b) {
            if (null != b) {
                var c = this._getWorldCenterPoint(b),
                    d = this._getWorldCenterPoint(this._findFirstNonLayoutWidget());
                a == ccui.Widget.LEFT ? this.onPassFocusToChild = c.x > d.x ? this._findNearestChildWidgetIndex.bind(this) : this._findFarthestChildWidgetIndex.bind(this) : a == ccui.Widget.RIGHT ? this.onPassFocusToChild = c.x > d.x ? this._findFarthestChildWidgetIndex.bind(this) : this._findNearestChildWidgetIndex.bind(this) : a == ccui.Widget.DOWN ? this.onPassFocusToChild = c.y > d.y ? this._findNearestChildWidgetIndex.bind(this) : this._findFarthestChildWidgetIndex.bind(this) : a == ccui.Widget.UP ? this.onPassFocusToChild = c.y < d.y ? this._findNearestChildWidgetIndex.bind(this) : this._findFarthestChildWidgetIndex.bind(this) : cc.log("invalid direction!")
            }
        },
        _findFirstNonLayoutWidget: function() {
            for (var a = this._children, b = 0, c = a.length; c > b; b++) {
                var d = a[b];
                if (d instanceof ccui.Layout) {
                    var e = d._findFirstNonLayoutWidget();
                    if (e) return e
                } else if (d instanceof cc.Widget) return d
            }
            return null
        },
        _findFirstFocusEnabledWidgetIndex: function() {
            for (var a = 0, b = this.getChildren(), c = b.length; c > a;) {
                var d = b[a];
                if (d && d instanceof ccui.Widget && d.isFocusEnabled()) return a;
                a++
            }
            return 0
        },
        _findFocusEnabledChildWidgetByIndex: function(a) {
            var b = this._getChildWidgetByIndex(a);
            return b ? b.isFocusEnabled() ? b : (a += 1, this._findFocusEnabledChildWidgetByIndex(a)) : null
        },
        _getWorldCenterPoint: function(a) {
            var b = a instanceof ccui.Layout ? a._getLayoutAccumulatedSize() : a.getContentSize();
            return a.convertToWorldSpace(cc.p(b.width / 2, b.height / 2))
        },
        _getNextFocusedWidget: function(a, b) {
            var c = null,
                d = this._children,
                e = d.indexOf(b);
            return e += 1, e < d.length ? (c = this._getChildWidgetByIndex(e), c ? c.isFocusEnabled() ? c instanceof ccui.Layout ? (c._isFocusPassing = !0, c.findNextFocusedWidget(a, c)) : (this.dispatchFocusEvent(b, c), c) : this._getNextFocusedWidget(a, c) : b) : this._loopFocus ? this._checkFocusEnabledChild() ? (e = 0, c = this._getChildWidgetByIndex(e), c.isFocusEnabled() ? c instanceof ccui.Layout ? (c._isFocusPassing = !0, c.findNextFocusedWidget(a, c)) : (this.dispatchFocusEvent(b, c), c) : this._getNextFocusedWidget(a, c)) : b instanceof ccui.Layout ? b : this._focusedWidget : this._isLastWidgetInContainer(b, a) ? this._isWidgetAncestorSupportLoopFocus(this, a) ? this.findNextFocusedWidget(a, this) : b instanceof ccui.Layout ? b : this._focusedWidget : this.findNextFocusedWidget(a, this)
        },
        _getPreviousFocusedWidget: function(a, b) {
            var c = null,
                d = this._children,
                e = d.indexOf(b);
            return e -= 1, e >= 0 ? (c = this._getChildWidgetByIndex(e), c.isFocusEnabled() ? c instanceof ccui.Layout ? (c._isFocusPassing = !0, c.findNextFocusedWidget(a, c)) : (this.dispatchFocusEvent(b, c), c) : this._getPreviousFocusedWidget(a, c)) : this._loopFocus ? this._checkFocusEnabledChild() ? (e = d.length - 1, c = this._getChildWidgetByIndex(e), c.isFocusEnabled() ? c instanceof ccui.Layout ? (c._isFocusPassing = !0, c.findNextFocusedWidget(a, c)) : (this.dispatchFocusEvent(b, c), c) : this._getPreviousFocusedWidget(a, c)) : b instanceof ccui.Layout ? b : this._focusedWidget : this._isLastWidgetInContainer(b, a) ? this._isWidgetAncestorSupportLoopFocus(this, a) ? this.findNextFocusedWidget(a, this) : b instanceof ccui.Layout ? b : this._focusedWidget : this.findNextFocusedWidget(a, this)
        },
        _getChildWidgetByIndex: function(a) {
            for (var b = this._children, c = b.length, d = 0, e = a; c > a;) {
                var f = b[a];
                if (f && f instanceof ccui.Widget) return f;
                d++, a++
            }
            for (var g = 0; e > g;) {
                var h = b[g];
                if (h && h instanceof ccui.Widget) return h;
                d++, g++
            }
            return null
        },
        _isLastWidgetInContainer: function(a, b) {
            var c = a.getParent();
            if (c instanceof ccui.Layout) return !0;
            var d = c.getChildren(),
                e = d.indexOf(a);
            if (c.getLayoutType() == ccui.Layout.LINEAR_HORIZONTAL) {
                if (b == ccui.Widget.LEFT) return 0 == e ? this._isLastWidgetInContainer(c, b) : !1;
                if (b == ccui.Widget.RIGHT) return e == d.length - 1 ? this._isLastWidgetInContainer(c, b) : !1;
                if (b == ccui.Widget.DOWN) return this._isLastWidgetInContainer(c, b);
                if (b == ccui.Widget.UP) return this._isLastWidgetInContainer(c, b)
            } else {
                if (c.getLayoutType() != ccui.Layout.LINEAR_VERTICAL) return cc.log("invalid layout Type"), !1;
                if (b == ccui.Widget.UP) return 0 == e ? this._isLastWidgetInContainer(c, b) : !1;
                if (b == ccui.Widget.DOWN) return e == d.length - 1 ? this._isLastWidgetInContainer(c, b) : !1;
                if (b == ccui.Widget.LEFT) return this._isLastWidgetInContainer(c, b);
                if (b == ccui.Widget.RIGHT) return this._isLastWidgetInContainer(c, b)
            }
        },
        _isWidgetAncestorSupportLoopFocus: function(a, b) {
            var c = a.getParent();
            if (null == c) return !1;
            if (c.isLoopFocus()) {
                var d = c.getLayoutType();
                return d == ccui.Layout.LINEAR_HORIZONTAL ? b == ccui.Widget.LEFT || b == ccui.Widget.RIGHT ? !0 : this._isWidgetAncestorSupportLoopFocus(c, b) : d == ccui.Layout.LINEAR_VERTICAL ? b == ccui.Widget.DOWN || b == ccui.Widget.UP ? !0 : this._isWidgetAncestorSupportLoopFocus(c, b) : (cc.assert(0, "invalid layout type"), !1)
            }
            return this._isWidgetAncestorSupportLoopFocus(c, b)
        },
        _passFocusToChild: function(a, b) {
            if (this._checkFocusEnabledChild()) {
                var c = ccui.Widget.getCurrentFocusedWidget();
                this._findProperSearchingFunctor(a, c);
                var d = this.onPassFocusToChild(a, c),
                    e = this._getChildWidgetByIndex(d);
                return e instanceof ccui.Layout ? (e._isFocusPassing = !0, e.findNextFocusedWidget(a, e)) : (this.dispatchFocusEvent(b, e), e)
            }
            return this
        },
        _checkFocusEnabledChild: function() {
            for (var a = this._children, b = 0, c = a.length; c > b; b++) {
                var d = a[b];
                if (d && d instanceof ccui.Widget && d.isFocusEnabled()) return !0
            }
            return !1
        },
        getDescription: function() {
            return "Layout"
        },
        _createCloneInstance: function() {
            return new ccui.Layout
        },
        _copyClonedWidgetChildren: function(a) {
            ccui.Widget.prototype._copyClonedWidgetChildren.call(this, a)
        },
        _copySpecialProperties: function(a) {
            a instanceof ccui.Layout && (this.setBackGroundImageScale9Enabled(a._backGroundScale9Enabled), this.setBackGroundImage(a._backGroundImageFileName, a._bgImageTexType), this.setBackGroundImageCapInsets(a._backGroundImageCapInsets), this.setBackGroundColorType(a._colorType), this.setBackGroundColor(a._color), this.setBackGroundColor(a._startColor, a._endColor), this.setBackGroundColorOpacity(a._opacity), this.setBackGroundColorVector(a._alongVector), this.setLayoutType(a._layoutType), this.setClippingEnabled(a._clippingEnabled), this.setClippingType(a._clippingType), this._loopFocus = a._loopFocus, this.__passFocusToChild = a.__passFocusToChild, this._isInterceptTouch = a._isInterceptTouch)
        },
        _createRenderCmd: function() {
            return cc._renderType === cc._RENDER_TYPE_WEBGL ? new ccui.Layout.WebGLRenderCmd(this) : new ccui.Layout.CanvasRenderCmd(this)
        }
    });
var _p = ccui.Layout.prototype;
_p.clippingEnabled, cc.defineGetterSetter(_p, "clippingEnabled", _p.isClippingEnabled, _p.setClippingEnabled), _p.clippingType, cc.defineGetterSetter(_p, "clippingType", null, _p.setClippingType), _p.layoutType, cc.defineGetterSetter(_p, "layoutType", _p.getLayoutType, _p.setLayoutType), _p = null, ccui.Layout.create = function() {
        return new ccui.Layout
    }, ccui.Layout.BG_COLOR_NONE = 0, ccui.Layout.BG_COLOR_SOLID = 1, ccui.Layout.BG_COLOR_GRADIENT = 2, ccui.Layout.ABSOLUTE = 0, ccui.Layout.LINEAR_VERTICAL = 1, ccui.Layout.LINEAR_HORIZONTAL = 2, ccui.Layout.RELATIVE = 3, ccui.Layout.CLIPPING_STENCIL = 0, ccui.Layout.CLIPPING_SCISSOR = 1, ccui.Layout.BACKGROUND_IMAGE_ZORDER = -2, ccui.Layout.BACKGROUND_RENDERER_ZORDER = -2,
    function() {
        ccui.Layout.CanvasRenderCmd = function(a) {
            ccui.ProtectedNode.CanvasRenderCmd.call(this, a), this._needDraw = !1, this._clipElemType = !1, this._locCache = null, this._rendererSaveCmd = new cc.CustomRenderCmd(this, this._onRenderSaveCmd), this._rendererSaveCmdSprite = new cc.CustomRenderCmd(this, this._onRenderSaveSpriteCmd), this._rendererClipCmd = new cc.CustomRenderCmd(this, this._onRenderClipCmd), this._rendererRestoreCmd = new cc.CustomRenderCmd(this, this._onRenderRestoreCmd)
        };
        var a = ccui.Layout.CanvasRenderCmd.prototype = Object.create(ccui.ProtectedNode.CanvasRenderCmd.prototype);
        a.constructor = ccui.Layout.CanvasRenderCmd, a._onRenderSaveCmd = function(a, b, c) {
            var d = a || cc._renderContext,
                e = d.getContext();
            if (this._clipElemType) {
                var f = e.canvas;
                this._locCache = ccui.Layout.CanvasRenderCmd._getSharedCache(), this._locCache.width = f.width, this._locCache.height = f.height;
                var g = this._locCache.getContext("2d");
                g.drawImage(f, 0, 0)
            } else d.save(), d.save(), d.setTransform(this._worldTransform, b, c)
        }, a._onRenderSaveSpriteCmd = function(a) {
            var b = a || cc._renderContext;
            this._clipElemType && b.setCompositeOperation("destination-in")
        }, a._onRenderClipCmd = function(a) {
            var b = a || cc._renderContext,
                c = b.getContext();
            this._clipElemType || (b.restore(), c.clip())
        }, a._onRenderRestoreCmd = function(a) {
            var b = a || cc._renderContext,
                c = b.getContext();
            this._clipElemType ? (c.save(), c.setTransform(1, 0, 0, 1, 0, 0), c.globalCompositeOperation = "destination-over", c.drawImage(this._locCache, 0, 0), c.restore()) : b.restore()
        }, a.rebindStencilRendering = function(a) {
            a._renderCmd.rendering = this.__stencilDraw
        }, a.__stencilDraw = function(a, b, c) {
            for (var d = a || cc._renderContext, e = d.getContext(), f = this._buffer, g = 0, h = f.length; h > g; g++) {
                var i = f[g],
                    j = i.verts,
                    k = j[0];
                e.beginPath(), e.moveTo(k.x * b, -k.y * c);
                for (var l = 1, m = j.length; m > l; l++) e.lineTo(j[l].x * b, -j[l].y * c);
                e.closePath()
            }
        }, a.stencilClippingVisit = a.scissorClippingVisit = function(a) {
            var b = this._node;
            if (b._clippingStencil && b._clippingStencil.isVisible() && (this._clipElemType = b._stencil instanceof cc.Sprite, this._syncStatus(a), this._dirtyFlag = 0, cc.renderer.pushRenderCommand(this._rendererSaveCmd), this._clipElemType && (cc.ProtectedNode.prototype.visit.call(b, a), cc.renderer.pushRenderCommand(this._rendererSaveCmdSprite)), b._clippingStencil.visit(this), cc.renderer.pushRenderCommand(this._rendererClipCmd), !this._clipElemType)) {
                b.sortAllChildren(), b.sortAllProtectedChildren();
                for (var c, d = b._children, e = 0, f = b._protectedChildren, g = 0, h = d.length, i = f.length; h > g && (c = d[g], c && c.getLocalZOrder() < 0); g++) c.visit(this);
                for (; i > e && (c = f[e], c && c.getLocalZOrder() < 0); e++) c.visit(this);
                for (; h > g; g++) d[g].visit(this);
                for (; i > e; e++) f[e].visit(this);
                cc.renderer.pushRenderCommand(this._rendererRestoreCmd)
            }
        }, ccui.Layout.CanvasRenderCmd._getSharedCache = function() {
            return cc.ClippingNode._sharedCache || (cc.ClippingNode._sharedCache = cc.newElement("canvas"))
        }
    }(), ccui.Margin = ccui.Class.extend({
        left: 0,
        top: 0,
        right: 0,
        bottom: 0,
        ctor: function(a, b, c, d) {
            void 0 !== a && void 0 === b && (this.left = a.left, this.top = a.top, this.right = a.right, this.bottom = a.bottom), void 0 !== d && (this.left = a, this.top = b, this.right = c, this.bottom = d)
        },
        setMargin: function(a, b, c, d) {
            this.left = a, this.top = b, this.right = c, this.bottom = d
        },
        equals: function(a) {
            return this.left == a.left && this.top == a.top && this.right == a.right && this.bottom == a.bottom
        }
    }), ccui.MarginZero = function() {
        return new ccui.Margin(0, 0, 0, 0)
    }, ccui.LayoutParameter = ccui.Class.extend({
        _margin: null,
        _layoutParameterType: null,
        ctor: function() {
            this._margin = new ccui.Margin, this._layoutParameterType = ccui.LayoutParameter.NONE
        },
        setMargin: function(a) {
            cc.isObject(a) ? (this._margin.left = a.left, this._margin.top = a.top, this._margin.right = a.right, this._margin.bottom = a.bottom) : (this._margin.left = arguments[0], this._margin.top = arguments[1], this._margin.right = arguments[2], this._margin.bottom = arguments[3])
        },
        getMargin: function() {
            return this._margin
        },
        getLayoutType: function() {
            return this._layoutParameterType
        },
        clone: function() {
            var a = this._createCloneInstance();
            return a._copyProperties(this), a
        },
        _createCloneInstance: function() {
            return new ccui.LayoutParameter
        },
        _copyProperties: function(a) {
            this._margin.bottom = a._margin.bottom, this._margin.left = a._margin.left, this._margin.right = a._margin.right, this._margin.top = a._margin.top
        }
    }), ccui.LayoutParameter.create = function() {
        return new ccui.LayoutParameter
    }, ccui.LayoutParameter.NONE = 0, ccui.LayoutParameter.LINEAR = 1, ccui.LayoutParameter.RELATIVE = 2, ccui.LinearLayoutParameter = ccui.LayoutParameter.extend({
        _linearGravity: null,
        ctor: function() {
            ccui.LayoutParameter.prototype.ctor.call(this), this._linearGravity = ccui.LinearLayoutParameter.NONE, this._layoutParameterType = ccui.LayoutParameter.LINEAR
        },
        setGravity: function(a) {
            this._linearGravity = a
        },
        getGravity: function() {
            return this._linearGravity
        },
        _createCloneInstance: function() {
            return new ccui.LinearLayoutParameter
        },
        _copyProperties: function(a) {
            ccui.LayoutParameter.prototype._copyProperties.call(this, a), a instanceof ccui.LinearLayoutParameter && this.setGravity(a._linearGravity)
        }
    }), ccui.LinearLayoutParameter.create = function() {
        return new ccui.LinearLayoutParameter
    }, ccui.LinearLayoutParameter.NONE = 0, ccui.LinearLayoutParameter.LEFT = 1, ccui.LinearLayoutParameter.TOP = 2, ccui.LinearLayoutParameter.RIGHT = 3, ccui.LinearLayoutParameter.BOTTOM = 4, ccui.LinearLayoutParameter.CENTER_VERTICAL = 5, ccui.LinearLayoutParameter.CENTER_HORIZONTAL = 6, ccui.RelativeLayoutParameter = ccui.LayoutParameter.extend({
        _relativeAlign: null,
        _relativeWidgetName: "",
        _relativeLayoutName: "",
        _put: !1,
        ctor: function() {
            ccui.LayoutParameter.prototype.ctor.call(this), this._relativeAlign = ccui.RelativeLayoutParameter.NONE, this._relativeWidgetName = "", this._relativeLayoutName = "", this._put = !1, this._layoutParameterType = ccui.LayoutParameter.RELATIVE
        },
        setAlign: function(a) {
            this._relativeAlign = a
        },
        getAlign: function() {
            return this._relativeAlign
        },
        setRelativeToWidgetName: function(a) {
            this._relativeWidgetName = a
        },
        getRelativeToWidgetName: function() {
            return this._relativeWidgetName
        },
        setRelativeName: function(a) {
            this._relativeLayoutName = a
        },
        getRelativeName: function() {
            return this._relativeLayoutName
        },
        _createCloneInstance: function() {
            return new ccui.RelativeLayoutParameter
        },
        _copyProperties: function(a) {
            ccui.LayoutParameter.prototype._copyProperties.call(this, a), a instanceof ccui.RelativeLayoutParameter && (this.setAlign(a._relativeAlign), this.setRelativeToWidgetName(a._relativeWidgetName), this.setRelativeName(a._relativeLayoutName))
        }
    }), ccui.RelativeLayoutParameter.create = function() {
        return new ccui.RelativeLayoutParameter
    }, ccui.RelativeLayoutParameter.NONE = 0, ccui.RelativeLayoutParameter.PARENT_TOP_LEFT = 1, ccui.RelativeLayoutParameter.PARENT_TOP_CENTER_HORIZONTAL = 2, ccui.RelativeLayoutParameter.PARENT_TOP_RIGHT = 3, ccui.RelativeLayoutParameter.PARENT_LEFT_CENTER_VERTICAL = 4, ccui.RelativeLayoutParameter.CENTER_IN_PARENT = 5, ccui.RelativeLayoutParameter.PARENT_RIGHT_CENTER_VERTICAL = 6, ccui.RelativeLayoutParameter.PARENT_LEFT_BOTTOM = 7, ccui.RelativeLayoutParameter.PARENT_BOTTOM_CENTER_HORIZONTAL = 8, ccui.RelativeLayoutParameter.PARENT_RIGHT_BOTTOM = 9, ccui.RelativeLayoutParameter.LOCATION_ABOVE_LEFTALIGN = 10, ccui.RelativeLayoutParameter.LOCATION_ABOVE_CENTER = 11, ccui.RelativeLayoutParameter.LOCATION_ABOVE_RIGHTALIGN = 12, ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_TOPALIGN = 13, ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_CENTER = 14, ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_BOTTOMALIGN = 15, ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_TOPALIGN = 16, ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_CENTER = 17, ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_BOTTOMALIGN = 18, ccui.RelativeLayoutParameter.LOCATION_BELOW_LEFTALIGN = 19, ccui.RelativeLayoutParameter.LOCATION_BELOW_CENTER = 20, ccui.RelativeLayoutParameter.LOCATION_BELOW_RIGHTALIGN = 21, ccui.LINEAR_GRAVITY_NONE = 0, ccui.LINEAR_GRAVITY_LEFT = 1, ccui.LINEAR_GRAVITY_TOP = 2, ccui.LINEAR_GRAVITY_RIGHT = 3, ccui.LINEAR_GRAVITY_BOTTOM = 4, ccui.LINEAR_GRAVITY_CENTER_VERTICAL = 5, ccui.LINEAR_GRAVITY_CENTER_HORIZONTAL = 6, ccui.RELATIVE_ALIGN_NONE = 0, ccui.RELATIVE_ALIGN_PARENT_TOP_LEFT = 1, ccui.RELATIVE_ALIGN_PARENT_TOP_CENTER_HORIZONTAL = 2, ccui.RELATIVE_ALIGN_PARENT_TOP_RIGHT = 3, ccui.RELATIVE_ALIGN_PARENT_LEFT_CENTER_VERTICAL = 4, ccui.RELATIVE_ALIGN_PARENT_CENTER = 5, ccui.RELATIVE_ALIGN_PARENT_RIGHT_CENTER_VERTICAL = 6, ccui.RELATIVE_ALIGN_PARENT_LEFT_BOTTOM = 7, ccui.RELATIVE_ALIGN_PARENT_BOTTOM_CENTER_HORIZONTAL = 8, ccui.RELATIVE_ALIGN_PARENT_RIGHT_BOTTOM = 9, ccui.RELATIVE_ALIGN_LOCATION_ABOVE_LEFT = 10, ccui.RELATIVE_ALIGN_LOCATION_ABOVE_CENTER = 11, ccui.RELATIVE_ALIGN_LOCATION_ABOVE_RIGHT = 12, ccui.RELATIVE_ALIGN_LOCATION_LEFT_TOP = 13, ccui.RELATIVE_ALIGN_LOCATION_LEFT_CENTER = 14, ccui.RELATIVE_ALIGN_LOCATION_LEFT_BOTTOM = 15, ccui.RELATIVE_ALIGN_LOCATION_RIGHT_TOP = 16, ccui.RELATIVE_ALIGN_LOCATION_RIGHT_CENTER = 17, ccui.RELATIVE_ALIGN_LOCATION_RIGHT_BOTTOM = 18, ccui.RELATIVE_ALIGN_LOCATION_BELOW_TOP = 19, ccui.RELATIVE_ALIGN_LOCATION_BELOW_CENTER = 20, ccui.RELATIVE_ALIGN_LOCATION_BELOW_BOTTOM = 21, ccui.getLayoutManager = function(a) {
        switch (a) {
            case ccui.Layout.LINEAR_VERTICAL:
                return ccui.linearVerticalLayoutManager;
            case ccui.Layout.LINEAR_HORIZONTAL:
                return ccui.linearHorizontalLayoutManager;
            case ccui.Layout.RELATIVE:
                return ccui.relativeLayoutManager
        }
        return null
    }, ccui.linearVerticalLayoutManager = {
        _doLayout: function(a) {
            for (var b = a._getLayoutContentSize(), c = a._getLayoutElements(), d = b.height, e = 0, f = c.length; f > e; e++) {
                var g = c[e];
                if (g) {
                    var h = g.getLayoutParameter();
                    if (h) {
                        var i = h.getGravity(),
                            j = g.getAnchorPoint(),
                            k = g.getContentSize(),
                            l = j.x * k.width,
                            m = d - (1 - j.y) * k.height;
                        switch (i) {
                            case ccui.LinearLayoutParameter.NONE:
                            case ccui.LinearLayoutParameter.LEFT:
                                break;
                            case ccui.LinearLayoutParameter.RIGHT:
                                l = b.width - (1 - j.x) * k.width;
                                break;
                            case ccui.LinearLayoutParameter.CENTER_HORIZONTAL:
                                l = b.width / 2 - k.width * (.5 - j.x)
                        }
                        var n = h.getMargin();
                        l += n.left, m -= n.top, g.setPosition(l, m), d = g.getPositionY() - g.getAnchorPoint().y * g.getContentSize().height - n.bottom
                    }
                }
            }
        }
    }, ccui.linearHorizontalLayoutManager = {
        _doLayout: function(a) {
            for (var b = a._getLayoutContentSize(), c = a._getLayoutElements(), d = 0, e = 0, f = c.length; f > e; e++) {
                var g = c[e];
                if (g) {
                    var h = g.getLayoutParameter();
                    if (h) {
                        var i = h.getGravity(),
                            j = g.getAnchorPoint(),
                            k = g.getSize(),
                            l = d + j.x * k.width,
                            m = b.height - (1 - j.y) * k.height;
                        switch (i) {
                            case ccui.LinearLayoutParameter.NONE:
                            case ccui.LinearLayoutParameter.TOP:
                                break;
                            case ccui.LinearLayoutParameter.BOTTOM:
                                m = j.y * k.height;
                                break;
                            case ccui.LinearLayoutParameter.CENTER_VERTICAL:
                                m = b.height / 2 - k.height * (.5 - j.y)
                        }
                        var n = h.getMargin();
                        l += n.left, m -= n.top, g.setPosition(l, m), d = g.getRightBoundary() + n.right
                    }
                }
            }
        }
    }, ccui.relativeLayoutManager = {
        _unlayoutChildCount: 0,
        _widgetChildren: [],
        _widget: null,
        _finalPositionX: 0,
        _finalPositionY: 0,
        _relativeWidgetLP: null,
        _doLayout: function(a) {
            this._widgetChildren = this._getAllWidgets(a);
            for (var b = this._widgetChildren; this._unlayoutChildCount > 0;) {
                for (var c = 0, d = b.length; d > c; c++) {
                    this._widget = b[c];
                    var e = this._widget.getLayoutParameter();
                    if (e) {
                        if (e._put) continue;
                        var f = this._calculateFinalPositionWithRelativeWidget(a);
                        if (!f) continue;
                        this._calculateFinalPositionWithRelativeAlign(), this._widget.setPosition(this._finalPositionX, this._finalPositionY), e._put = !0
                    }
                }
                this._unlayoutChildCount--
            }
            this._widgetChildren.length = 0
        },
        _getAllWidgets: function(a) {
            var b = a._getLayoutElements(),
                c = this._widgetChildren;
            c.length = 0;
            for (var d = 0, e = b.length; e > d; d++) {
                var f = b[d];
                if (f) {
                    var g = f.getLayoutParameter();
                    g._put = !1, this._unlayoutChildCount++, c.push(f)
                }
            }
            return c
        },
        _getRelativeWidget: function(a) {
            var b = null,
                c = a.getLayoutParameter(),
                d = c.getRelativeToWidgetName();
            if (d && 0 != d.length)
                for (var e = this._widgetChildren, f = 0, g = e.length; g > f; f++) {
                    var h = e[f];
                    if (h) {
                        var i = h.getLayoutParameter();
                        if (i && i.getRelativeName() == d) {
                            b = h, this._relativeWidgetLP = i;
                            break
                        }
                    }
                }
            return b
        },
        _calculateFinalPositionWithRelativeWidget: function(a) {
            var b = this._widget,
                c = b.getAnchorPoint(),
                d = b.getContentSize();
            this._finalPositionX = 0, this._finalPositionY = 0;
            var e = this._getRelativeWidget(b),
                f = b.getLayoutParameter(),
                g = f.getAlign(),
                h = a._getLayoutContentSize();
            switch (g) {
                case ccui.RelativeLayoutParameter.NONE:
                case ccui.RelativeLayoutParameter.PARENT_TOP_LEFT:
                    this._finalPositionX = c.x * d.width, this._finalPositionY = h.height - (1 - c.y) * d.height;
                    break;
                case ccui.RelativeLayoutParameter.PARENT_TOP_CENTER_HORIZONTAL:
                    this._finalPositionX = .5 * h.width - d.width * (.5 - c.x), this._finalPositionY = h.height - (1 - c.y) * d.height;
                    break;
                case ccui.RelativeLayoutParameter.PARENT_TOP_RIGHT:
                    this._finalPositionX = h.width - (1 - c.x) * d.width, this._finalPositionY = h.height - (1 - c.y) * d.height;
                    break;
                case ccui.RelativeLayoutParameter.PARENT_LEFT_CENTER_VERTICAL:
                    this._finalPositionX = c.x * d.width, this._finalPositionY = .5 * h.height - d.height * (.5 - c.y);
                    break;
                case ccui.RelativeLayoutParameter.CENTER_IN_PARENT:
                    this._finalPositionX = .5 * h.width - d.width * (.5 - c.x), this._finalPositionY = .5 * h.height - d.height * (.5 - c.y);
                    break;
                case ccui.RelativeLayoutParameter.PARENT_RIGHT_CENTER_VERTICAL:
                    this._finalPositionX = h.width - (1 - c.x) * d.width, this._finalPositionY = .5 * h.height - d.height * (.5 - c.y);
                    break;
                case ccui.RelativeLayoutParameter.PARENT_LEFT_BOTTOM:
                    this._finalPositionX = c.x * d.width, this._finalPositionY = c.y * d.height;
                    break;
                case ccui.RelativeLayoutParameter.PARENT_BOTTOM_CENTER_HORIZONTAL:
                    this._finalPositionX = .5 * h.width - d.width * (.5 - c.x), this._finalPositionY = c.y * d.height;
                    break;
                case ccui.RelativeLayoutParameter.PARENT_RIGHT_BOTTOM:
                    this._finalPositionX = h.width - (1 - c.x) * d.width, this._finalPositionY = c.y * d.height;
                    break;
                case ccui.RelativeLayoutParameter.LOCATION_ABOVE_LEFTALIGN:
                    if (e) {
                        if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                        this._finalPositionY = e.getTopBoundary() + c.y * d.height, this._finalPositionX = e.getLeftBoundary() + c.x * d.width
                    }
                    break;
                case ccui.RelativeLayoutParameter.LOCATION_ABOVE_CENTER:
                    if (e) {
                        if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                        var i = e.getContentSize();
                        this._finalPositionY = e.getTopBoundary() + c.y * d.height, this._finalPositionX = e.getLeftBoundary() + .5 * i.width + c.x * d.width - .5 * d.width
                    }
                    break;
                case ccui.RelativeLayoutParameter.LOCATION_ABOVE_RIGHTALIGN:
                    if (e) {
                        if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                        this._finalPositionY = e.getTopBoundary() + c.y * d.height, this._finalPositionX = e.getRightBoundary() - (1 - c.x) * d.width
                    }
                    break;
                case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_TOPALIGN:
                    if (e) {
                        if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                        this._finalPositionY = e.getTopBoundary() - (1 - c.y) * d.height, this._finalPositionX = e.getLeftBoundary() - (1 - c.x) * d.width
                    }
                    break;
                case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_CENTER:
                    if (e) {
                        if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                        var i = e.getContentSize();
                        this._finalPositionX = e.getLeftBoundary() - (1 - c.x) * d.width, this._finalPositionY = e.getBottomBoundary() + .5 * i.height + c.y * d.height - .5 * d.height
                    }
                    break;
                case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_BOTTOMALIGN:
                    if (e) {
                        if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                        this._finalPositionY = e.getBottomBoundary() + c.y * d.height, this._finalPositionX = e.getLeftBoundary() - (1 - c.x) * d.width
                    }
                    break;
                case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_TOPALIGN:
                    if (e) {
                        if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                        this._finalPositionY = e.getTopBoundary() - (1 - c.y) * d.height, this._finalPositionX = e.getRightBoundary() + c.x * d.width
                    }
                    break;
                case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_CENTER:
                    if (e) {
                        if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                        var i = e.getContentSize(),
                            j = e.getRightBoundary();
                        this._finalPositionX = j + c.x * d.width, this._finalPositionY = e.getBottomBoundary() + .5 * i.height + c.y * d.height - .5 * d.height
                    }
                    break;
                case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_BOTTOMALIGN:
                    if (e) {
                        if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                        this._finalPositionY = e.getBottomBoundary() + c.y * d.height, this._finalPositionX = e.getRightBoundary() + c.x * d.width
                    }
                    break;
                case ccui.RelativeLayoutParameter.LOCATION_BELOW_LEFTALIGN:
                    if (e) {
                        if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                        this._finalPositionY = e.getBottomBoundary() - (1 - c.y) * d.height, this._finalPositionX = e.getLeftBoundary() + c.x * d.width
                    }
                    break;
                case ccui.RelativeLayoutParameter.LOCATION_BELOW_CENTER:
                    if (e) {
                        if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                        var i = e.getContentSize();
                        this._finalPositionY = e.getBottomBoundary() - (1 - c.y) * d.height, this._finalPositionX = e.getLeftBoundary() + .5 * i.width + c.x * d.width - .5 * d.width
                    }
                    break;
                case ccui.RelativeLayoutParameter.LOCATION_BELOW_RIGHTALIGN:
                    if (e) {
                        if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                        this._finalPositionY = e.getBottomBoundary() - (1 - c.y) * d.height, this._finalPositionX = e.getRightBoundary() - (1 - c.x) * d.width
                    }
            }
            return !0
        },
        _calculateFinalPositionWithRelativeAlign: function() {
            var a = this._widget.getLayoutParameter(),
                b = a.getMargin(),
                c = a.getAlign();
            switch (c) {
                case ccui.RelativeLayoutParameter.NONE:
                case ccui.RelativeLayoutParameter.PARENT_TOP_LEFT:
                    this._finalPositionX += b.left, this._finalPositionY -= b.top;
                    break;
                case ccui.RelativeLayoutParameter.PARENT_TOP_CENTER_HORIZONTAL:
                    this._finalPositionY -= b.top;
                    break;
                case ccui.RelativeLayoutParameter.PARENT_TOP_RIGHT:
                    this._finalPositionX -= b.right, this._finalPositionY -= b.top;
                    break;
                case ccui.RelativeLayoutParameter.PARENT_LEFT_CENTER_VERTICAL:
                    this._finalPositionX += b.left;
                    break;
                case ccui.RelativeLayoutParameter.CENTER_IN_PARENT:
                    break;
                case ccui.RelativeLayoutParameter.PARENT_RIGHT_CENTER_VERTICAL:
                    this._finalPositionX -= b.right;
                    break;
                case ccui.RelativeLayoutParameter.PARENT_LEFT_BOTTOM:
                    this._finalPositionX += b.left, this._finalPositionY += b.bottom;
                    break;
                case ccui.RelativeLayoutParameter.PARENT_BOTTOM_CENTER_HORIZONTAL:
                    this._finalPositionY += b.bottom;
                    break;
                case ccui.RelativeLayoutParameter.PARENT_RIGHT_BOTTOM:
                    this._finalPositionX -= b.right, this._finalPositionY += b.bottom;
                    break;
                case ccui.RelativeLayoutParameter.LOCATION_ABOVE_LEFTALIGN:
                    this._finalPositionY += b.bottom, this._finalPositionX += b.left;
                    break;
                case ccui.RelativeLayoutParameter.LOCATION_ABOVE_RIGHTALIGN:
                    this._finalPositionY += b.bottom, this._finalPositionX -= b.right;
                    break;
                case ccui.RelativeLayoutParameter.LOCATION_ABOVE_CENTER:
                    this._finalPositionY += b.bottom;
                    break;
                case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_TOPALIGN:
                    this._finalPositionX -= b.right, this._finalPositionY -= b.top;
                    break;
                case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_BOTTOMALIGN:
                    this._finalPositionX -= b.right, this._finalPositionY += b.bottom;
                    break;
                case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_CENTER:
                    this._finalPositionX -= b.right;
                    break;
                case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_TOPALIGN:
                    this._finalPositionX += b.left, this._finalPositionY -= b.top;
                    break;
                case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_BOTTOMALIGN:
                    this._finalPositionX += b.left, this._finalPositionY += b.bottom;
                    break;
                case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_CENTER:
                    this._finalPositionX += b.left;
                    break;
                case ccui.RelativeLayoutParameter.LOCATION_BELOW_LEFTALIGN:
                    this._finalPositionY -= b.top, this._finalPositionX += b.left;
                    break;
                case ccui.RelativeLayoutParameter.LOCATION_BELOW_RIGHTALIGN:
                    this._finalPositionY -= b.top, this._finalPositionX -= b.right;
                    break;
                case ccui.RelativeLayoutParameter.LOCATION_BELOW_CENTER:
                    this._finalPositionY -= b.top
            }
        }
    }, ccui.HBox = ccui.Layout.extend({
        ctor: function(a) {
            void 0 !== a ? this.initWithSize(a) : this.init()
        },
        init: function() {
            return ccui.Layout.prototype.init.call(this) ? (this.setLayoutType(ccui.Layout.LINEAR_HORIZONTAL), !0) : !1
        },
        initWithSize: function(a) {
            return this.init() ? (this.setContentSize(a), !0) : !1
        }
    }), ccui.HBox.create = function(a) {
        return new ccui.HBox(a)
    }, ccui.RelativeBox = ccui.Layout.extend({
        ctor: function(a) {
            a ? this.initWithSize(a) : this.init()
        },
        init: function() {
            return ccui.Layout.prototype.init.call(this) ? (this.setLayoutType(ccui.Layout.RELATIVE), !0) : !1
        },
        initWithSize: function(a) {
            return this.init() ? (this.setContentSize(a), !0) : !1
        }
    }), ccui.RelativeBox.create = function(a) {
        return new ccui.RelativeBox(a)
    }, ccui.VBox = ccui.Layout.extend({
        ctor: function(a) {
            void 0 !== a ? this.initWithSize(a) : this.init()
        },
        init: function() {
            return ccui.Layout.prototype.init.call(this) ? (this.setLayoutType(ccui.Layout.LINEAR_VERTICAL), !0) : !1
        },
        initWithSize: function(a) {
            return this.init() ? (this.setContentSize(a), !0) : !1
        }
    }), ccui.VBox.create = function(a) {
        return new ccui.VBox(a)
    }, ccui.helper = {
        seekWidgetByTag: function(a, b) {
            if (!a) return null;
            if (a.getTag() == b) return a;
            for (var c = a.getChildren(), d = c.length, e = 0; d > e; e++) {
                var f = c[e],
                    g = ccui.helper.seekWidgetByTag(f, b);
                if (null != g) return g
            }
            return null
        },
        seekWidgetByName: function(a, b) {
            if (!a) return null;
            if (a.getName() == b) return a;
            for (var c = a.getChildren(), d = c.length, e = 0; d > e; e++) {
                var f = c[e],
                    g = ccui.helper.seekWidgetByName(f, b);
                if (null != g) return g
            }
            return null
        },
        seekWidgetByRelativeName: function(a, b) {
            if (!a) return null;
            for (var c = a.getChildren(), d = c.length, e = 0; d > e; e++) {
                var f = c[e],
                    g = f.getLayoutParameter(ccui.LayoutParameter.RELATIVE);
                if (g && g.getRelativeName() == b) return f
            }
            return null
        },
        seekActionWidgetByActionTag: function(a, b) {
            if (!a) return null;
            if (a.getActionTag() == b) return a;
            for (var c = a.getChildren(), d = 0; d < c.length; d++) {
                var e = c[d],
                    f = ccui.helper.seekActionWidgetByActionTag(e, b);
                if (null != f) return f
            }
            return null
        }
    }, ccui.Button = ccui.Widget.extend({
        _buttonNormalRenderer: null,
        _buttonClickedRenderer: null,
        _buttonDisableRenderer: null,
        _titleRenderer: null,
        _normalFileName: "",
        _clickedFileName: "",
        _disabledFileName: "",
        _prevIgnoreSize: !0,
        _scale9Enabled: !1,
        _capInsetsNormal: null,
        _capInsetsPressed: null,
        _capInsetsDisabled: null,
        _normalTexType: ccui.Widget.LOCAL_TEXTURE,
        _pressedTexType: ccui.Widget.LOCAL_TEXTURE,
        _disabledTexType: ccui.Widget.LOCAL_TEXTURE,
        _normalTextureSize: null,
        _pressedTextureSize: null,
        _disabledTextureSize: null,
        pressedActionEnabled: !1,
        _titleColor: null,
        _normalTextureScaleXInSize: 1,
        _normalTextureScaleYInSize: 1,
        _pressedTextureScaleXInSize: 1,
        _pressedTextureScaleYInSize: 1,
        _zoomScale: .1,
        _normalTextureLoaded: !1,
        _pressedTextureLoaded: !1,
        _disabledTextureLoaded: !1,
        _className: "Button",
        _normalTextureAdaptDirty: !0,
        _pressedTextureAdaptDirty: !0,
        _disabledTextureAdaptDirty: !0,
        _fontName: "Thonburi",
        _fontSize: 12,
        _type: 0,
        ctor: function(a, b, c, d) {
            this._capInsetsNormal = cc.rect(0, 0, 0, 0), this._capInsetsPressed = cc.rect(0, 0, 0, 0), this._capInsetsDisabled = cc.rect(0, 0, 0, 0), this._normalTextureSize = cc.size(0, 0), this._pressedTextureSize = cc.size(0, 0), this._disabledTextureSize = cc.size(0, 0), this._titleColor = cc.color.WHITE, ccui.Widget.prototype.ctor.call(this), this.setTouchEnabled(!0), void 0 !== d && this.init(a, b, c, d)
        },
        init: function(a, b, c, d) {
            if (ccui.Widget.prototype.init.call(this)) {
                if (void 0 === a) return !0;
                this.loadTextures(a, b, c, d)
            }
            return !1
        },
        _initRenderer: function() {
            this._buttonNormalRenderer = new cc.Sprite, this._buttonClickedRenderer = new cc.Sprite, this._buttonDisableRenderer = new cc.Sprite, this._titleRenderer = new cc.LabelTTF(""), this._titleRenderer.setAnchorPoint(.5, .5), this.addProtectedChild(this._buttonNormalRenderer, ccui.Button.NORMAL_RENDERER_ZORDER, -1), this.addProtectedChild(this._buttonClickedRenderer, ccui.Button.PRESSED_RENDERER_ZORDER, -1), this.addProtectedChild(this._buttonDisableRenderer, ccui.Button.DISABLED_RENDERER_ZORDER, -1), this.addProtectedChild(this._titleRenderer, ccui.Button.TITLE_RENDERER_ZORDER, -1)
        },
        setScale9Enabled: function(a) {
            if (this._scale9Enabled != a) {
                if (this._brightStyle = ccui.Widget.BRIGHT_STYLE_NONE, this._scale9Enabled = a, this.removeProtectedChild(this._buttonNormalRenderer), this.removeProtectedChild(this._buttonClickedRenderer), this.removeProtectedChild(this._buttonDisableRenderer), this._scale9Enabled ? (this._buttonNormalRenderer = new ccui.Scale9Sprite, this._buttonClickedRenderer = new ccui.Scale9Sprite, this._buttonDisableRenderer = new ccui.Scale9Sprite) : (this._buttonNormalRenderer = new cc.Sprite, this._buttonClickedRenderer = new cc.Sprite, this._buttonDisableRenderer = new cc.Sprite), this._buttonClickedRenderer.setVisible(!1), this._buttonDisableRenderer.setVisible(!1), this.loadTextureNormal(this._normalFileName, this._normalTexType), this.loadTexturePressed(this._clickedFileName, this._pressedTexType), this.loadTextureDisabled(this._disabledFileName, this._disabledTexType), this.addProtectedChild(this._buttonNormalRenderer, ccui.Button.NORMAL_RENDERER_ZORDER, -1), this.addProtectedChild(this._buttonClickedRenderer, ccui.Button.PRESSED_RENDERER_ZORDER, -1), this.addProtectedChild(this._buttonDisableRenderer, ccui.Button.DISABLED_RENDERER_ZORDER, -1), this._scale9Enabled) {
                    var b = this._ignoreSize;
                    this.ignoreContentAdaptWithSize(!1), this._prevIgnoreSize = b
                } else this.ignoreContentAdaptWithSize(this._prevIgnoreSize);
                this.setCapInsetsNormalRenderer(this._capInsetsNormal), this.setCapInsetsPressedRenderer(this._capInsetsPressed), this.setCapInsetsDisabledRenderer(this._capInsetsDisabled), this.setBright(this._bright)
            }
        },
        isScale9Enabled: function() {
            return this._scale9Enabled
        },
        ignoreContentAdaptWithSize: function(a) {
            if (this._unifySize) {
                if (this._scale9Enabled) ccui.ProtectedNode.prototype.setContentSize.call(this, this._customSize);
                else {
                    var b = this.getVirtualRendererSize();
                    ccui.ProtectedNode.prototype.setContentSize.call(this, b)
                }
                return void this._onSizeChanged()
            }(!this._scale9Enabled || this._scale9Enabled && !a) && (ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this, a), this._prevIgnoreSize = a)
        },
        getVirtualRendererSize: function() {
            var a = this._titleRenderer.getContentSize();
            return !this._normalTextureLoaded && this._titleRenderer.getString().length > 0 ? a : cc.size(this._normalTextureSize)
        },
        loadTextures: function(a, b, c, d) {
            this.loadTextureNormal(a, d), this.loadTexturePressed(b, d), this.loadTextureDisabled(c, d)
        },
        loadTextureNormal: function(a, b) {
            if (a) {
                b = b || ccui.Widget.LOCAL_TEXTURE, this._normalFileName = a, this._normalTexType = b;
                var c = this;
                if (this._buttonNormalRenderer.texture && this._buttonNormalRenderer.texture.isLoaded() || this._buttonNormalRenderer.addEventListener("load", function() {
                    c._findLayout(), c._normalTextureSize = c._buttonNormalRenderer.getContentSize(), c._updateFlippedX(), c._updateFlippedY(), c._updateChildrenDisplayedRGBA(), c._buttonNormalRenderer.setColor(c.getColor()), c._buttonNormalRenderer.setOpacity(c.getOpacity()), c._updateContentSizeWithTextureSize(c._normalTextureSize), c._normalTextureLoaded = !0, c._normalTextureAdaptDirty = !0
                }), this._scale9Enabled) {
                    var d = this._buttonNormalRenderer;
                    switch (this._normalTexType) {
                        case ccui.Widget.LOCAL_TEXTURE:
                            d.initWithFile(a);
                            break;
                        case ccui.Widget.PLIST_TEXTURE:
                            d.initWithSpriteFrameName(a)
                    }
                    d.setCapInsets(this._capInsetsNormal)
                } else {
                    var e = this._buttonNormalRenderer;
                    switch (this._normalTexType) {
                        case ccui.Widget.LOCAL_TEXTURE:
                            e.initWithFile(a);
                            break;
                        case ccui.Widget.PLIST_TEXTURE:
                            e.initWithSpriteFrameName(a)
                    }
                }
                this._normalTextureSize = this._buttonNormalRenderer.getContentSize(), this._updateFlippedX(), this._updateFlippedY(), this._updateChildrenDisplayedRGBA(), this._updateContentSizeWithTextureSize(this._normalTextureSize), this._normalTextureLoaded = !0, this._normalTextureAdaptDirty = !0
            }
        },
        loadTexturePressed: function(a, b) {
            if (a) {
                b = b || ccui.Widget.LOCAL_TEXTURE, this._clickedFileName = a, this._pressedTexType = b;
                var c = this;
                if (this._buttonClickedRenderer.texture && this._buttonClickedRenderer.texture.isLoaded() || this._buttonClickedRenderer.addEventListener("load", function() {
                    c._findLayout(), c._pressedTextureSize = c._buttonClickedRenderer.getContentSize(), c._updateFlippedX(), c._updateFlippedY(), c._updateChildrenDisplayedRGBA(), c._pressedTextureLoaded = !0, c._pressedTextureAdaptDirty = !0
                }), this._scale9Enabled) {
                    var d = this._buttonClickedRenderer;
                    switch (this._pressedTexType) {
                        case ccui.Widget.LOCAL_TEXTURE:
                            d.initWithFile(a);
                            break;
                        case ccui.Widget.PLIST_TEXTURE:
                            d.initWithSpriteFrameName(a)
                    }
                    d.setCapInsets(this._capInsetsPressed)
                } else {
                    var e = this._buttonClickedRenderer;
                    switch (this._pressedTexType) {
                        case ccui.Widget.LOCAL_TEXTURE:
                            e.initWithFile(a);
                            break;
                        case ccui.Widget.PLIST_TEXTURE:
                            e.initWithSpriteFrameName(a)
                    }
                }
                this._pressedTextureSize = this._buttonClickedRenderer.getContentSize(), this._updateFlippedX(), this._updateFlippedY(), this._updateChildrenDisplayedRGBA(), this._pressedTextureLoaded = !0, this._pressedTextureAdaptDirty = !0
            }
        },
        loadTextureDisabled: function(a, b) {
            if (a) {
                b = b || ccui.Widget.LOCAL_TEXTURE, this._disabledFileName = a, this._disabledTexType = b;
                var c = this;
                if (this._buttonDisableRenderer.texture && this._buttonDisableRenderer.texture.isLoaded() || this._buttonDisableRenderer.addEventListener("load", function() {
                    c._findLayout(), c._disabledTextureSize = c._buttonDisableRenderer.getContentSize(), c._updateFlippedX(), c._updateFlippedY(), c._updateChildrenDisplayedRGBA(), c._disabledTextureLoaded = !0, c._disabledTextureAdaptDirty = !0
                }), this._scale9Enabled) {
                    var d = this._buttonDisableRenderer;
                    switch (this._disabledTexType) {
                        case ccui.Widget.LOCAL_TEXTURE:
                            d.initWithFile(a);
                            break;
                        case ccui.Widget.PLIST_TEXTURE:
                            d.initWithSpriteFrameName(a)
                    }
                    d.setCapInsets(this._capInsetsDisabled)
                } else {
                    var e = this._buttonDisableRenderer;
                    switch (this._disabledTexType) {
                        case ccui.Widget.LOCAL_TEXTURE:
                            e.initWithFile(a);
                            break;
                        case ccui.Widget.PLIST_TEXTURE:
                            e.initWithSpriteFrameName(a)
                    }
                }
                this._disabledTextureSize = this._buttonDisableRenderer.getContentSize(), this._updateFlippedX(), this._updateFlippedY(), this._updateChildrenDisplayedRGBA(), this._disabledTextureLoaded = !0, this._disabledTextureAdaptDirty = !0
            }
        },
        setCapInsets: function(a) {
            this.setCapInsetsNormalRenderer(a), this.setCapInsetsPressedRenderer(a), this.setCapInsetsDisabledRenderer(a)
        },
        setCapInsetsNormalRenderer: function(a) {
            if (a) {
                var b = a.x,
                    c = a.y,
                    d = a.width,
                    e = a.height;
                this._normalTextureSize.width < d && (b = 0, d = 0), this._normalTextureSize.height < e && (c = 0, e = 0);
                var f = cc.rect(b, c, d, e),
                    g = this._capInsetsNormal;
                g.x = b, g.y = c, g.width = d, g.height = e, this._scale9Enabled && this._buttonNormalRenderer.setCapInsets(f)
            }
        },
        getCapInsetsNormalRenderer: function() {
            return cc.rect(this._capInsetsNormal)
        },
        setCapInsetsPressedRenderer: function(a) {
            if (a) {
                var b = a.x,
                    c = a.y,
                    d = a.width,
                    e = a.height;
                this._normalTextureSize.width < d && (b = 0, d = 0), this._normalTextureSize.height < e && (c = 0, e = 0);
                var f = cc.rect(b, c, d, e),
                    g = this._capInsetsPressed;
                g.x = b, g.y = c, g.width = d, g.height = e, this._scale9Enabled && this._buttonClickedRenderer.setCapInsets(f)
            }
        },
        getCapInsetsPressedRenderer: function() {
            return cc.rect(this._capInsetsPressed)
        },
        setCapInsetsDisabledRenderer: function(a) {
            if (a) {
                var b = a.x,
                    c = a.y,
                    d = a.width,
                    e = a.height;
                this._normalTextureSize.width < d && (b = 0, d = 0), this._normalTextureSize.height < e && (c = 0, e = 0);
                var f = cc.rect(b, c, d, e),
                    g = this._capInsetsDisabled;
                g.x = b, g.y = c, g.width = d, g.height = e, this._scale9Enabled && this._buttonDisableRenderer.setCapInsets(f)
            }
        },
        getCapInsetsDisabledRenderer: function() {
            return cc.rect(this._capInsetsDisabled)
        },
        _onPressStateChangedToNormal: function() {
            if (this._buttonNormalRenderer.setVisible(!0), this._buttonClickedRenderer.setVisible(!1), this._buttonDisableRenderer.setVisible(!1), this._pressedTextureLoaded) {
                if (this.pressedActionEnabled) {
                    this._buttonNormalRenderer.stopAllActions(), this._buttonClickedRenderer.stopAllActions();
                    var a = cc.scaleTo(.05, this._normalTextureScaleXInSize, this._normalTextureScaleYInSize);
                    this._buttonNormalRenderer.runAction(a), this._buttonClickedRenderer.setScale(this._pressedTextureScaleXInSize, this._pressedTextureScaleYInSize), this._titleRenderer.stopAllActions(), this._titleRenderer.runAction(a.clone())
                }
            } else this._scale9Enabled ? this._buttonNormalRenderer.setColor(cc.color.WHITE) : (this._buttonNormalRenderer.stopAllActions(), this._buttonNormalRenderer.setScale(this._normalTextureScaleXInSize, this._normalTextureScaleYInSize), this._titleRenderer.stopAllActions(), this._titleRenderer.setScaleX(this._normalTextureScaleXInSize), this._titleRenderer.setScaleY(this._normalTextureScaleYInSize))
        },
        _onPressStateChangedToPressed: function() {
            var a = this._buttonNormalRenderer;
            if (this._pressedTextureLoaded) {
                if (a.setVisible(!1), this._buttonClickedRenderer.setVisible(!0), this._buttonDisableRenderer.setVisible(!1), this.pressedActionEnabled) {
                    a.stopAllActions(), this._buttonClickedRenderer.stopAllActions();
                    var b = cc.scaleTo(.05, this._pressedTextureScaleXInSize + .1, this._pressedTextureScaleYInSize + .1);
                    this._buttonClickedRenderer.runAction(b), a.setScale(this._pressedTextureScaleXInSize + .1, this._pressedTextureScaleYInSize + .1), this._titleRenderer.stopAllActions(), this._titleRenderer.runAction(b.clone())
                }
            } else a.setVisible(!0), this._buttonClickedRenderer.setVisible(!0), this._buttonDisableRenderer.setVisible(!1), this._scale9Enabled ? a.setColor(cc.color.GRAY) : (a.stopAllActions(), a.setScale(this._normalTextureScaleXInSize + .1, this._normalTextureScaleYInSize + .1), this._titleRenderer.stopAllActions(), this._titleRenderer.setScaleX(this._normalTextureScaleXInSize + this._zoomScale), this._titleRenderer.setScaleY(this._normalTextureScaleYInSize + this._zoomScale))
        },
        _onPressStateChangedToDisabled: function() {
            this._buttonNormalRenderer.setVisible(!1), this._buttonClickedRenderer.setVisible(!1), this._buttonDisableRenderer.setVisible(!0), this._buttonNormalRenderer.setScale(this._normalTextureScaleXInSize, this._normalTextureScaleYInSize), this._buttonClickedRenderer.setScale(this._pressedTextureScaleXInSize, this._pressedTextureScaleYInSize)
        },
        _updateFlippedX: function() {
            var a = this._flippedX ? -1 : 1;
            this._titleRenderer.setScaleX(a), this._scale9Enabled ? (this._buttonNormalRenderer.setScaleX(a), this._buttonClickedRenderer.setScaleX(a), this._buttonDisableRenderer.setScaleX(a)) : (this._buttonNormalRenderer.setFlippedX(this._flippedX), this._buttonClickedRenderer.setFlippedX(this._flippedX), this._buttonDisableRenderer.setFlippedX(this._flippedX))
        },
        _updateFlippedY: function() {
            var a = this._flippedY ? -1 : 1;
            this._titleRenderer.setScaleY(a), this._scale9Enabled ? (this._buttonNormalRenderer.setScaleY(a), this._buttonClickedRenderer.setScaleY(a), this._buttonDisableRenderer.setScaleY(a)) : (this._buttonNormalRenderer.setFlippedY(this._flippedY), this._buttonClickedRenderer.setFlippedY(this._flippedY), this._buttonDisableRenderer.setFlippedY(this._flippedY))
        },
        _updateTexturesRGBA: function() {
            this._buttonNormalRenderer.setColor(this.getColor()), this._buttonClickedRenderer.setColor(this.getColor()), this._buttonDisableRenderer.setColor(this.getColor()), this._buttonNormalRenderer.setOpacity(this.getOpacity()), this._buttonClickedRenderer.setOpacity(this.getOpacity()), this._buttonDisableRenderer.setOpacity(this.getOpacity())
        },
        _onSizeChanged: function() {
            ccui.Widget.prototype._onSizeChanged.call(this), this._updateTitleLocation(), this._normalTextureAdaptDirty = !0, this._pressedTextureAdaptDirty = !0, this._disabledTextureAdaptDirty = !0
        },
        getVirtualRenderer: function() {
            if (!this._bright) return this._buttonDisableRenderer;
            switch (this._brightStyle) {
                case ccui.Widget.BRIGHT_STYLE_NORMAL:
                    return this._buttonNormalRenderer;
                case ccui.Widget.BRIGHT_STYLE_HIGH_LIGHT:
                    return this._buttonClickedRenderer;
                default:
                    return null
            }
        },
        _normalTextureScaleChangedWithSize: function() {
            if (this._unifySize) this._scale9Enabled && this._buttonNormalRenderer.setPreferredSize(this._contentSize);
            else if (this._ignoreSize) this._scale9Enabled || (this._buttonNormalRenderer.setScale(1), this._normalTextureScaleXInSize = this._normalTextureScaleYInSize = 1);
            else if (this._scale9Enabled) this._buttonNormalRenderer.setPreferredSize(this._contentSize), this._normalTextureScaleXInSize = this._normalTextureScaleYInSize = 1;
            else {
                var a = this._normalTextureSize;
                if (a.width <= 0 || a.height <= 0) return void this._buttonNormalRenderer.setScale(1);
                var b = this._contentSize.width / a.width,
                    c = this._contentSize.height / a.height;
                this._buttonNormalRenderer.setScaleX(b), this._buttonNormalRenderer.setScaleY(c), this._normalTextureScaleXInSize = b, this._normalTextureScaleYInSize = c
            }
            this._buttonNormalRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
        },
        _pressedTextureScaleChangedWithSize: function() {
            if (this._ignoreSize) this._scale9Enabled || (this._buttonClickedRenderer.setScale(1), this._pressedTextureScaleXInSize = this._pressedTextureScaleYInSize = 1);
            else if (this._scale9Enabled) this._buttonClickedRenderer.setPreferredSize(this._contentSize), this._pressedTextureScaleXInSize = this._pressedTextureScaleYInSize = 1;
            else {
                var a = this._pressedTextureSize;
                if (a.width <= 0 || a.height <= 0) return void this._buttonClickedRenderer.setScale(1);
                var b = this._contentSize.width / a.width,
                    c = this._contentSize.height / a.height;
                this._buttonClickedRenderer.setScaleX(b), this._buttonClickedRenderer.setScaleY(c), this._pressedTextureScaleXInSize = b, this._pressedTextureScaleYInSize = c
            }
            this._buttonClickedRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
        },
        _disabledTextureScaleChangedWithSize: function() {
            if (this._unifySize) this._scale9Enabled && this._buttonNormalRenderer.setPreferredSize(this._contentSize);
            else if (this._ignoreSize) this._scale9Enabled || this._buttonDisableRenderer.setScale(1);
            else if (this._scale9Enabled) this._buttonDisableRenderer.setPreferredSize(this._contentSize);
            else {
                var a = this._disabledTextureSize;
                if (a.width <= 0 || a.height <= 0) return void this._buttonDisableRenderer.setScale(1);
                var b = this._contentSize.width / a.width,
                    c = this._contentSize.height / a.height;
                this._buttonDisableRenderer.setScaleX(b), this._buttonDisableRenderer.setScaleY(c)
            }
            this._buttonDisableRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
        },
        _adaptRenderers: function() {
            this._normalTextureAdaptDirty && (this._normalTextureScaleChangedWithSize(), this._normalTextureAdaptDirty = !1), this._pressedTextureAdaptDirty && (this._pressedTextureScaleChangedWithSize(), this._pressedTextureAdaptDirty = !1), this._disabledTextureAdaptDirty && (this._disabledTextureScaleChangedWithSize(), this._disabledTextureAdaptDirty = !1)
        },
        _updateTitleLocation: function() {
            this._titleRenderer.setPosition(.5 * this._contentSize.width, .5 * this._contentSize.height)
        },
        setPressedActionEnabled: function(a) {
            this.pressedActionEnabled = a
        },
        setTitleText: function(a) {
            if (this._titleRenderer.setString(a), this._ignoreSize) {
                var b = this.getVirtualRendererSize();
                this.setContentSize(b)
            } else this._titleRenderer._renderCmd._updateTTF()
        },
        getTitleText: function() {
            return this._titleRenderer.getString()
        },
        setTitleColor: function(a) {
            this._titleRenderer.setColor(a)
        },
        getTitleColor: function() {
            return this._titleRenderer.getColor()
        },
        setTitleFontSize: function(a) {
            this._titleRenderer.setFontSize(a)
        },
        getTitleFontSize: function() {
            return this._titleRenderer.getFontSize()
        },
        setZoomScale: function(a) {
            this._zoomScale = a
        },
        getZoomScale: function() {
            return this._zoomScale
        },
        setTitleFontName: function(a) {
            this._titleRenderer.setFontName(a), this._fontName = a
        },
        getTitleRenderer: function() {
            return this._titleRenderer
        },
        getTitleFontName: function() {
            return this._titleRenderer.getFontName()
        },
        _setTitleFont: function(a) {
            this._titleRenderer.font = a
        },
        _getTitleFont: function() {
            return this._titleRenderer.font
        },
        getDescription: function() {
            return "Button"
        },
        _createCloneInstance: function() {
            return new ccui.Button
        },
        _copySpecialProperties: function(a) {
            this._prevIgnoreSize = a._prevIgnoreSize, this.setScale9Enabled(a._scale9Enabled), this.loadTextureNormal(a._normalFileName, a._normalTexType), this.loadTexturePressed(a._clickedFileName, a._pressedTexType), this.loadTextureDisabled(a._disabledFileName, a._disabledTexType), this.setCapInsetsNormalRenderer(a._capInsetsNormal), this.setCapInsetsPressedRenderer(a._capInsetsPressed), this.setCapInsetsDisabledRenderer(a._capInsetsDisabled), this.setTitleText(a.getTitleText()), this.setTitleFontName(a.getTitleFontName()), this.setTitleFontSize(a.getTitleFontSize()), this.setTitleColor(a.getTitleColor()), this.setPressedActionEnabled(a.pressedActionEnabled), this.setZoomScale(a._zoomScale)
        },
        setColor: function(a) {
            cc.ProtectedNode.prototype.setColor.call(this, a), this._updateTexturesRGBA()
        }
    });
var _p = ccui.Button.prototype;
_p.titleText, cc.defineGetterSetter(_p, "titleText", _p.getTitleText, _p.setTitleText), _p.titleFont, cc.defineGetterSetter(_p, "titleFont", _p._getTitleFont, _p._setTitleFont), _p.titleFontSize, cc.defineGetterSetter(_p, "titleFontSize", _p.getTitleFontSize, _p.setTitleFontSize), _p.titleFontName, cc.defineGetterSetter(_p, "titleFontName", _p.getTitleFontName, _p.setTitleFontName), _p.titleColor, cc.defineGetterSetter(_p, "titleColor", _p.getTitleColor, _p.setTitleColor), _p = null, ccui.Button.create = function(a, b, c, d) {
    return new ccui.Button(a, b, c, d)
}, ccui.Button.NORMAL_RENDERER_ZORDER = -2, ccui.Button.PRESSED_RENDERER_ZORDER = -2, ccui.Button.DISABLED_RENDERER_ZORDER = -2, ccui.Button.TITLE_RENDERER_ZORDER = -1, ccui.Button.SYSTEM = 0, ccui.Button.TTF = 1, ccui.CheckBox = ccui.Widget.extend({
    _backGroundBoxRenderer: null,
    _backGroundSelectedBoxRenderer: null,
    _frontCrossRenderer: null,
    _backGroundBoxDisabledRenderer: null,
    _frontCrossDisabledRenderer: null,
    _isSelected: !0,
    _checkBoxEventListener: null,
    _checkBoxEventSelector: null,
    _backGroundTexType: ccui.Widget.LOCAL_TEXTURE,
    _backGroundSelectedTexType: ccui.Widget.LOCAL_TEXTURE,
    _frontCrossTexType: ccui.Widget.LOCAL_TEXTURE,
    _backGroundDisabledTexType: ccui.Widget.LOCAL_TEXTURE,
    _frontCrossDisabledTexType: ccui.Widget.LOCAL_TEXTURE,
    _backGroundFileName: "",
    _backGroundSelectedFileName: "",
    _frontCrossFileName: "",
    _backGroundDisabledFileName: "",
    _frontCrossDisabledFileName: "",
    _className: "CheckBox",
    _backGroundBoxRendererAdaptDirty: !0,
    _backGroundSelectedBoxRendererAdaptDirty: !0,
    _frontCrossRendererAdaptDirty: !0,
    _backGroundBoxDisabledRendererAdaptDirty: !0,
    _frontCrossDisabledRendererAdaptDirty: !0,
    ctor: function(a, b, c, d, e, f) {
        ccui.Widget.prototype.ctor.call(this), this.setTouchEnabled(!0), void 0 !== f && this.init(a, b, c, d, e, f)
    },
    init: function(a, b, c, d, e, f) {
        return ccui.Widget.prototype.init.call(this) ? (this._isSelected = !0, this.setSelected(!1), this.loadTextures(a, b, c, d, e, f), !0) : !1
    },
    _initRenderer: function() {
        this._backGroundBoxRenderer = new cc.Sprite, this._backGroundSelectedBoxRenderer = new cc.Sprite, this._frontCrossRenderer = new cc.Sprite, this._backGroundBoxDisabledRenderer = new cc.Sprite, this._frontCrossDisabledRenderer = new cc.Sprite, this.addProtectedChild(this._backGroundBoxRenderer, ccui.CheckBox.BOX_RENDERER_ZORDER, -1), this.addProtectedChild(this._backGroundSelectedBoxRenderer, ccui.CheckBox.BOX_SELECTED_RENDERER_ZORDER, -1), this.addProtectedChild(this._frontCrossRenderer, ccui.CheckBox.FRONT_CROSS_RENDERER_ZORDER, -1), this.addProtectedChild(this._backGroundBoxDisabledRenderer, ccui.CheckBox.BOX_DISABLED_RENDERER_ZORDER, -1), this.addProtectedChild(this._frontCrossDisabledRenderer, ccui.CheckBox.FRONT_CROSS_DISABLED_RENDERER_ZORDER, -1)
    },
    loadTextures: function(a, b, c, d, e, f) {
        this.loadTextureBackGround(a, f), this.loadTextureBackGroundSelected(b, f), this.loadTextureFrontCross(c, f), this.loadTextureBackGroundDisabled(d, f), this.loadTextureFrontCrossDisabled(e, f)
    },
    loadTextureBackGround: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE, this._backGroundFileName = a, this._backGroundTexType = b;
            var c = this._backGroundBoxRenderer,
                d = this;
            switch (c.texture && c.texture.isLoaded() || c.addEventListener("load", function() {
                d._findLayout(), d._updateFlippedX(), d._updateFlippedY(), d._updateChildrenDisplayedRGBA(), d._updateContentSizeWithTextureSize(d._backGroundBoxRenderer.getContentSize()), d._backGroundBoxRendererAdaptDirty = !0
            }), this._backGroundTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    c.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    c.initWithSpriteFrameName(a)
            }
            c.textureLoaded() || (this._backGroundBoxRenderer.setContentSize(this._customSize), c.addEventListener("load", function() {
                this._updateContentSizeWithTextureSize(this._backGroundBoxRenderer.getContentSize())
            }, this)), this._updateFlippedX(), this._updateFlippedY(), this._updateChildrenDisplayedRGBA(), this._updateContentSizeWithTextureSize(this._backGroundBoxRenderer.getContentSize()), this._backGroundBoxRendererAdaptDirty = !0
        }
    },
    loadTextureBackGroundSelected: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE, this._backGroundSelectedFileName = a, this._backGroundSelectedTexType = b;
            var c = this;
            switch (this._backGroundSelectedBoxRenderer.texture && this._backGroundSelectedBoxRenderer.texture.isLoaded() || this._backGroundSelectedBoxRenderer.addEventListener("load", function() {
                c._findLayout(), c._updateFlippedX(), c._updateFlippedY(), c._updateChildrenDisplayedRGBA(), c._backGroundSelectedBoxRendererAdaptDirty = !0
            }), this._backGroundSelectedTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._backGroundSelectedBoxRenderer.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._backGroundSelectedBoxRenderer.initWithSpriteFrameName(a)
            }
            this._updateFlippedX(), this._updateFlippedY(), this._updateChildrenDisplayedRGBA(), this._backGroundSelectedBoxRendererAdaptDirty = !0
        }
    },
    loadTextureFrontCross: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE, this._frontCrossFileName = a, this._frontCrossTexType = b;
            var c = this;
            switch (this._frontCrossRenderer.texture && this._frontCrossRenderer.texture.isLoaded() || this._frontCrossRenderer.addEventListener("load", function() {
                c._findLayout(), c._updateFlippedX(), c._updateFlippedY(), c._updateChildrenDisplayedRGBA(), c._frontCrossRendererAdaptDirty = !0
            }), this._frontCrossTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._frontCrossRenderer.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._frontCrossRenderer.initWithSpriteFrameName(a)
            }
            this._updateFlippedX(), this._updateFlippedY(), this._updateChildrenDisplayedRGBA(), this._frontCrossRendererAdaptDirty = !0
        }
    },
    loadTextureBackGroundDisabled: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE, this._backGroundDisabledFileName = a, this._backGroundDisabledTexType = b;
            var c = this;
            switch (this._backGroundBoxDisabledRenderer.texture && this._backGroundBoxDisabledRenderer.texture.isLoaded() || this._backGroundBoxDisabledRenderer.addEventListener("load", function() {
                c._findLayout(), c._updateFlippedX(), c._updateFlippedY(), c._updateChildrenDisplayedRGBA(), c._backGroundBoxDisabledRendererAdaptDirty = !0
            }), this._backGroundDisabledTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._backGroundBoxDisabledRenderer.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._backGroundBoxDisabledRenderer.initWithSpriteFrameName(a)
            }
            this._updateFlippedX(), this._updateFlippedY(), this._updateChildrenDisplayedRGBA(), this._backGroundBoxDisabledRendererAdaptDirty = !0
        }
    },
    loadTextureFrontCrossDisabled: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE, this._frontCrossDisabledFileName = a, this._frontCrossDisabledTexType = b;
            var c = this;
            switch (this._frontCrossDisabledRenderer.texture && this._frontCrossDisabledRenderer.texture.isLoaded() || this._frontCrossDisabledRenderer.addEventListener("load", function() {
                c._findLayout(), c._updateFlippedX(), c._updateFlippedY(), c._updateChildrenDisplayedRGBA(), c._frontCrossDisabledRendererAdaptDirty = !0
            }), this._frontCrossDisabledTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._frontCrossDisabledRenderer.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._frontCrossDisabledRenderer.initWithSpriteFrameName(a)
            }
            this._updateFlippedX(), this._updateFlippedY(), this._updateChildrenDisplayedRGBA(), this._frontCrossDisabledRendererAdaptDirty = !0
        }
    },
    _onPressStateChangedToNormal: function() {
        this._backGroundBoxRenderer.setVisible(!0), this._backGroundSelectedBoxRenderer.setVisible(!1), this._backGroundBoxDisabledRenderer.setVisible(!1), this._frontCrossDisabledRenderer.setVisible(!1), this._isSelected && this._frontCrossRenderer.setVisible(!0)
    },
    _onPressStateChangedToPressed: function() {
        this._backGroundBoxRenderer.setVisible(!1), this._backGroundSelectedBoxRenderer.setVisible(!0), this._backGroundBoxDisabledRenderer.setVisible(!1), this._frontCrossDisabledRenderer.setVisible(!1)
    },
    _onPressStateChangedToDisabled: function() {
        this._backGroundBoxRenderer.setVisible(!1), this._backGroundSelectedBoxRenderer.setVisible(!1), this._backGroundBoxDisabledRenderer.setVisible(!0), this._frontCrossRenderer.setVisible(!1), this._isSelected && this._frontCrossDisabledRenderer.setVisible(!0)
    },
    setSelectedState: function(a) {
        this.setSelected(a)
    },
    setSelected: function(a) {
        a != this._isSelected && (this._isSelected = a, this._frontCrossRenderer.setVisible(this._isSelected))
    },
    getSelectedState: function() {
        return this.isSelected()
    },
    isSelected: function() {
        return this._isSelected
    },
    _selectedEvent: function() {
        this._checkBoxEventSelector && (this._checkBoxEventListener ? this._checkBoxEventSelector.call(this._checkBoxEventListener, this, ccui.CheckBox.EVENT_SELECTED) : this._checkBoxEventSelector(this, ccui.CheckBox.EVENT_SELECTED))
    },
    _unSelectedEvent: function() {
        this._checkBoxEventSelector && (this._checkBoxEventListener ? this._checkBoxEventSelector.call(this._checkBoxEventListener, this, ccui.CheckBox.EVENT_UNSELECTED) : this._checkBoxEventSelector(this, ccui.CheckBox.EVENT_UNSELECTED))
    },
    _releaseUpEvent: function() {
        ccui.Widget.prototype._releaseUpEvent.call(this), this._isSelected ? (this.setSelected(!1), this._unSelectedEvent()) : (this.setSelected(!0), this._selectedEvent())
    },
    addEventListenerCheckBox: function(a, b) {
        this.addEventListener(a, b)
    },
    addEventListener: function(a, b) {
        this._checkBoxEventSelector = a, this._checkBoxEventListener = b
    },
    getVirtualRendererSize: function() {
        return this._backGroundBoxRenderer.getContentSize()
    },
    _updateFlippedX: function() {
        this._backGroundBoxRenderer.setFlippedX(this._flippedX), this._backGroundSelectedBoxRenderer.setFlippedX(this._flippedX), this._frontCrossRenderer.setFlippedX(this._flippedX), this._backGroundBoxDisabledRenderer.setFlippedX(this._flippedX), this._frontCrossDisabledRenderer.setFlippedX(this._flippedX)
    },
    _updateFlippedY: function() {
        this._backGroundBoxRenderer.setFlippedY(this._flippedY), this._backGroundSelectedBoxRenderer.setFlippedY(this._flippedY), this._frontCrossRenderer.setFlippedY(this._flippedY), this._backGroundBoxDisabledRenderer.setFlippedY(this._flippedY), this._frontCrossDisabledRenderer.setFlippedY(this._flippedY)
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this), this._backGroundBoxRendererAdaptDirty = !0, this._backGroundSelectedBoxRendererAdaptDirty = !0, this._frontCrossRendererAdaptDirty = !0, this._backGroundBoxDisabledRendererAdaptDirty = !0, this._frontCrossDisabledRendererAdaptDirty = !0
    },
    getVirtualRenderer: function() {
        return this._backGroundBoxRenderer
    },
    _backGroundTextureScaleChangedWithSize: function() {
        var a = this._backGroundBoxRenderer,
            b = this._contentSize;
        if (this._ignoreSize) a.setScale(1);
        else {
            var c = a.getContentSize();
            if (c.width <= 0 || c.height <= 0) return void a.setScale(1);
            var d = b.width / c.width,
                e = b.height / c.height;
            a.setScaleX(d), a.setScaleY(e)
        }
        a.setPosition(.5 * b.width, .5 * b.height)
    },
    _backGroundSelectedTextureScaleChangedWithSize: function() {
        var a = this._backGroundSelectedBoxRenderer,
            b = this._contentSize;
        if (this._ignoreSize) a.setScale(1);
        else {
            var c = a.getContentSize();
            if (c.width <= 0 || c.height <= 0) return void a.setScale(1);
            var d = b.width / c.width,
                e = b.height / c.height;
            a.setScaleX(d), a.setScaleY(e)
        }
        a.setPosition(.5 * b.width, .5 * b.height)
    },
    _frontCrossTextureScaleChangedWithSize: function() {
        var a = this._frontCrossRenderer,
            b = this._contentSize;
        if (this._ignoreSize) a.setScale(1);
        else {
            var c = a.getContentSize();
            if (c.width <= 0 || c.height <= 0) return void a.setScale(1);
            var d = b.width / c.width,
                e = b.height / c.height;
            a.setScaleX(d), a.setScaleY(e)
        }
        a.setPosition(.5 * b.width, .5 * b.height)
    },
    _backGroundDisabledTextureScaleChangedWithSize: function() {
        var a = this._backGroundBoxDisabledRenderer,
            b = this._contentSize;
        if (this._ignoreSize) a.setScale(1);
        else {
            var c = a.getContentSize();
            if (c.width <= 0 || c.height <= 0) return void a.setScale(1);
            var d = b.width / c.width,
                e = b.height / c.height;
            a.setScaleX(d), a.setScaleY(e)
        }
        a.setPosition(.5 * b.width, .5 * b.height)
    },
    _frontCrossDisabledTextureScaleChangedWithSize: function() {
        var a = this._frontCrossDisabledRenderer,
            b = this._contentSize;
        if (this._ignoreSize) a.setScale(1);
        else {
            var c = a.getContentSize();
            if (c.width <= 0 || c.height <= 0) return void a.setScale(1);
            var d = b.width / c.width,
                e = b.height / c.height;
            a.setScaleX(d), a.setScaleY(e)
        }
        a.setPosition(.5 * b.width, .5 * b.height)
    },
    getDescription: function() {
        return "CheckBox"
    },
    _createCloneInstance: function() {
        return new ccui.CheckBox
    },
    _copySpecialProperties: function(a) {
        a instanceof ccui.CheckBox && (this.loadTextureBackGround(a._backGroundFileName, a._backGroundTexType), this.loadTextureBackGroundSelected(a._backGroundSelectedFileName, a._backGroundSelectedTexType), this.loadTextureFrontCross(a._frontCrossFileName, a._frontCrossTexType), this.loadTextureBackGroundDisabled(a._backGroundDisabledFileName, a._backGroundDisabledTexType), this.loadTextureFrontCrossDisabled(a._frontCrossDisabledFileName, a._frontCrossDisabledTexType), this.setSelected(a._isSelected), this._checkBoxEventListener = a._checkBoxEventListener, this._checkBoxEventSelector = a._checkBoxEventSelector)
    },
    _adaptRenderers: function() {
        this._backGroundBoxRendererAdaptDirty && (this._backGroundTextureScaleChangedWithSize(), this._backGroundBoxRendererAdaptDirty = !1), this._backGroundSelectedBoxRendererAdaptDirty && (this._backGroundSelectedTextureScaleChangedWithSize(), this._backGroundSelectedBoxRendererAdaptDirty = !1), this._frontCrossRendererAdaptDirty && (this._frontCrossTextureScaleChangedWithSize(), this._frontCrossRendererAdaptDirty = !1), this._backGroundBoxDisabledRendererAdaptDirty && (this._backGroundDisabledTextureScaleChangedWithSize(), this._backGroundBoxDisabledRendererAdaptDirty = !1), this._frontCrossDisabledRendererAdaptDirty && (this._frontCrossDisabledTextureScaleChangedWithSize(), this._frontCrossDisabledRendererAdaptDirty = !1)
    }
});
var _p = ccui.CheckBox.prototype;
_p.selected, cc.defineGetterSetter(_p, "selected", _p.isSelected, _p.setSelected), _p = null, ccui.CheckBox.create = function(a, b, c, d, e, f) {
    return new ccui.CheckBox(a, b, c, d, e, f)
}, ccui.CheckBox.EVENT_SELECTED = 0, ccui.CheckBox.EVENT_UNSELECTED = 1, ccui.CheckBox.BOX_RENDERER_ZORDER = -1, ccui.CheckBox.BOX_SELECTED_RENDERER_ZORDER = -1, ccui.CheckBox.BOX_DISABLED_RENDERER_ZORDER = -1, ccui.CheckBox.FRONT_CROSS_RENDERER_ZORDER = -1, ccui.CheckBox.FRONT_CROSS_DISABLED_RENDERER_ZORDER = -1, ccui.ImageView = ccui.Widget.extend({
    _scale9Enabled: !1,
    _prevIgnoreSize: !0,
    _capInsets: null,
    _imageRenderer: null,
    _textureFile: "",
    _imageTexType: ccui.Widget.LOCAL_TEXTURE,
    _imageTextureSize: null,
    _className: "ImageView",
    _imageRendererAdaptDirty: !0,
    ctor: function(a, b) {
        this._capInsets = cc.rect(0, 0, 0, 0), this._imageTextureSize = cc.size(this._capInsets.width, this._capInsets.height), ccui.Widget.prototype.ctor.call(this), void 0 !== b && this.init(a, b)
    },
    init: function(a, b) {
        return ccui.Widget.prototype.init.call(this) ? (void 0 === a ? this._imageTexType = ccui.Widget.LOCAL_TEXTURE : this.loadTexture(a, b), !0) : !1
    },
    _initRenderer: function() {
        this._imageRenderer = new cc.Sprite, this.addProtectedChild(this._imageRenderer, ccui.ImageView.RENDERER_ZORDER, -1)
    },
    setRotation: function(a) {
        this._imageRenderer.setRotation(a)
    },
    loadTexture: function(a, b) {
        if (a) {
            var c = this;
            b = b || ccui.Widget.LOCAL_TEXTURE, this._textureFile = a, this._imageTexType = b;
            var d = c._imageRenderer;
            switch (c._imageTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    c._scale9Enabled ? (d.initWithFile(a), d.setCapInsets(c._capInsets)) : d.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    c._scale9Enabled ? (d.initWithSpriteFrameName(a), d.setCapInsets(c._capInsets)) : d.initWithSpriteFrameName(a)
            }
            d.texture && d.texture.isLoaded() || d.addEventListener("load", function() {
                c._findLayout(), c._imageTextureSize = d.getContentSize(), c._updateFlippedX(), c._updateFlippedY(), c._updateChildrenDisplayedRGBA(), c._updateContentSizeWithTextureSize(c._imageTextureSize), c._scale9Enabled && c.setCapInsets(c._capInsets), c._imageRendererAdaptDirty = !0
            }), c._imageTextureSize = d.getContentSize(), c._updateFlippedX(), c._updateFlippedY(), this._updateChildrenDisplayedRGBA(), c._updateContentSizeWithTextureSize(c._imageTextureSize), c._imageRendererAdaptDirty = !0
        }
    },
    setTextureRect: function(a) {
        this._scale9Enabled || this._imageRenderer.setTextureRect(a)
    },
    _updateFlippedX: function() {
        this._scale9Enabled ? this._imageRenderer.setScaleX(this._flippedX ? -1 : 1) : this._imageRenderer.setFlippedX(this._flippedX)
    },
    _updateFlippedY: function() {
        this._scale9Enabled ? this._imageRenderer.setScaleY(this._flippedY ? -1 : 1) : this._imageRenderer.setFlippedY(this._flippedY)
    },
    setScale9Enabled: function(a) {
        if (this._scale9Enabled != a) {
            if (this._scale9Enabled = a, this.removeProtectedChild(this._imageRenderer), this._imageRenderer = null, this._imageRenderer = this._scale9Enabled ? new ccui.Scale9Sprite : new cc.Sprite, this.loadTexture(this._textureFile, this._imageTexType), this.addProtectedChild(this._imageRenderer, ccui.ImageView.RENDERER_ZORDER, -1), this._scale9Enabled) {
                var b = this._ignoreSize;
                this.ignoreContentAdaptWithSize(!1), this._prevIgnoreSize = b
            } else this.ignoreContentAdaptWithSize(this._prevIgnoreSize);
            this.setCapInsets(this._capInsets)
        }
    },
    isScale9Enabled: function() {
        return this._scale9Enabled
    },
    ignoreContentAdaptWithSize: function(a) {
        (!this._scale9Enabled || this._scale9Enabled && !a) && (ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this, a), this._prevIgnoreSize = a)
    },
    setCapInsets: function(a) {
        if (a) {
            var b = this._capInsets;
            b.x = a.x, b.y = a.y, b.width = a.width, b.height = a.height, this._scale9Enabled && this._imageRenderer.setCapInsets(a)
        }
    },
    getCapInsets: function() {
        return cc.rect(this._capInsets)
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this), this._imageRendererAdaptDirty = !0
    },
    _adaptRenderers: function() {
        this._imageRendererAdaptDirty && (this._imageTextureScaleChangedWithSize(), this._imageRendererAdaptDirty = !1)
    },
    getVirtualRendererSize: function() {
        return cc.size(this._imageTextureSize)
    },
    getVirtualRenderer: function() {
        return this._imageRenderer
    },
    _imageTextureScaleChangedWithSize: function() {
        if (this._ignoreSize) this._scale9Enabled || this._imageRenderer.setScale(1);
        else if (this._scale9Enabled) this._imageRenderer.setPreferredSize(this._contentSize);
        else {
            var a = this._imageRenderer.getContentSize();
            if (a.width <= 0 || a.height <= 0) return void this._imageRenderer.setScale(1);
            this._imageRenderer.setScaleX(this._contentSize.width / a.width), this._imageRenderer.setScaleY(this._contentSize.height / a.height)
        }
        this._imageRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    },
    getDescription: function() {
        return "ImageView"
    },
    _createCloneInstance: function() {
        return new ccui.ImageView
    },
    _copySpecialProperties: function(a) {
        a instanceof ccui.ImageView && (this._prevIgnoreSize = a._prevIgnoreSize, this.setScale9Enabled(a._scale9Enabled), this.loadTexture(a._textureFile, a._imageTexType), this.setCapInsets(a._capInsets))
    }
}), ccui.ImageView.create = function(a, b) {
    return new ccui.ImageView(a, b)
}, ccui.ImageView.RENDERER_ZORDER = -1, ccui.LoadingBar = ccui.Widget.extend({
    _direction: null,
    _percent: 100,
    _totalLength: 0,
    _barRenderer: null,
    _renderBarTexType: ccui.Widget.LOCAL_TEXTURE,
    _barRendererTextureSize: null,
    _scale9Enabled: !1,
    _prevIgnoreSize: !0,
    _capInsets: null,
    _textureFile: "",
    _isTextureLoaded: !1,
    _className: "LoadingBar",
    _barRendererAdaptDirty: !0,
    ctor: function(a, b) {
        this._direction = ccui.LoadingBar.TYPE_LEFT, this._barRendererTextureSize = cc.size(0, 0), this._capInsets = cc.rect(0, 0, 0, 0), ccui.Widget.prototype.ctor.call(this), void 0 !== a && this.loadTexture(a), void 0 !== b && this.setPercent(b)
    },
    _initRenderer: function() {
        this._barRenderer = new cc.Sprite, this.addProtectedChild(this._barRenderer, ccui.LoadingBar.RENDERER_ZORDER, -1), this._barRenderer.setAnchorPoint(0, .5)
    },
    setDirection: function(a) {
        if (this._direction != a) switch (this._direction = a, this._direction) {
            case ccui.LoadingBar.TYPE_LEFT:
                this._barRenderer.setAnchorPoint(0, .5), this._barRenderer.setPosition(0, .5 * this._contentSize.height), this._scale9Enabled || this._barRenderer.setFlippedX(!1);
                break;
            case ccui.LoadingBar.TYPE_RIGHT:
                this._barRenderer.setAnchorPoint(1, .5), this._barRenderer.setPosition(this._totalLength, .5 * this._contentSize.height), this._scale9Enabled || this._barRenderer.setFlippedX(!0)
        }
    },
    getDirection: function() {
        return this._direction
    },
    loadTexture: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE, this._renderBarTexType = b, this._textureFile = a;
            var c = this._barRenderer,
                d = this;
            switch (c.texture && c.texture.isLoaded() || c.addEventListener("load", function() {
                d._findLayout();
                var a = c.getContentSize();
                switch (d._barRendererTextureSize.width = a.width, d._barRendererTextureSize.height = a.height, d._direction) {
                    case ccui.LoadingBar.TYPE_LEFT:
                        c.setAnchorPoint(0, .5), d._scale9Enabled || c.setFlippedX(!1);
                        break;
                    case ccui.LoadingBar.TYPE_RIGHT:
                        c.setAnchorPoint(1, .5), d._scale9Enabled || c.setFlippedX(!0)
                }
                d._updateChildrenDisplayedRGBA(), d._barRendererScaleChangedWithSize(), d._updateContentSizeWithTextureSize(d._barRendererTextureSize), d._barRendererAdaptDirty = !0
            }), this._renderBarTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._scale9Enabled ? (c.initWithFile(a), c.setCapInsets(this._capInsets)) : c.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._scale9Enabled ? (c.initWithSpriteFrameName(a), c.setCapInsets(this._capInsets)) : c.initWithSpriteFrameName(a)
            }
            var e = c.getContentSize();
            switch (this._barRendererTextureSize.width = e.width, this._barRendererTextureSize.height = e.height, this._direction) {
                case ccui.LoadingBar.TYPE_LEFT:
                    c.setAnchorPoint(0, .5), this._scale9Enabled || c.setFlippedX(!1);
                    break;
                case ccui.LoadingBar.TYPE_RIGHT:
                    c.setAnchorPoint(1, .5), this._scale9Enabled || c.setFlippedX(!0)
            }
            this._updateChildrenDisplayedRGBA(), this._barRendererScaleChangedWithSize(), this._updateContentSizeWithTextureSize(this._barRendererTextureSize), this._barRendererAdaptDirty = !0
        }
    },
    setScale9Enabled: function(a) {
        if (this._scale9Enabled != a) {
            if (this._scale9Enabled = a, this.removeProtectedChild(this._barRenderer), this._barRenderer = this._scale9Enabled ? new ccui.Scale9Sprite : new cc.Sprite, this.loadTexture(this._textureFile, this._renderBarTexType), this.addProtectedChild(this._barRenderer, ccui.LoadingBar.RENDERER_ZORDER, -1), this._scale9Enabled) {
                var b = this._ignoreSize;
                this.ignoreContentAdaptWithSize(!1), this._prevIgnoreSize = b
            } else this.ignoreContentAdaptWithSize(this._prevIgnoreSize);
            this.setCapInsets(this._capInsets), this.setPercent(this._percent)
        }
    },
    isScale9Enabled: function() {
        return this._scale9Enabled
    },
    setCapInsets: function(a) {
        if (a) {
            var b = this._capInsets;
            b.x = a.x, b.y = a.y, b.width = a.width, b.height = a.height, this._scale9Enabled && this._barRenderer.setCapInsets(a)
        }
    },
    getCapInsets: function() {
        return cc.rect(this._capInsets)
    },
    setPercent: function(a) {
        if (!(0 > a || a > 100 || (this._percent = a, this._totalLength <= 0))) {
            var b = this._percent / 100;
            if (this._scale9Enabled) this._setScale9Scale();
            else {
                var c = this._barRenderer,
                    d = c.getTextureRect();
                d.width = this._barRendererTextureSize.width * b, this._barRenderer.setTextureRect(cc.rect(d.x, d.y, this._barRendererTextureSize.width * b, this._barRendererTextureSize.height))
            }
        }
    },
    setContentSize: function(a, b) {
        ccui.Widget.prototype.setContentSize.call(this, a, b), this._totalLength = void 0 === b ? a.width : a
    },
    getPercent: function() {
        return this._percent
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this), this._barRendererAdaptDirty = !0
    },
    _adaptRenderers: function() {
        this._barRendererAdaptDirty && (this._barRendererScaleChangedWithSize(), this._barRendererAdaptDirty = !1)
    },
    ignoreContentAdaptWithSize: function(a) {
        (!this._scale9Enabled || this._scale9Enabled && !a) && (ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this, a), this._prevIgnoreSize = a)
    },
    getVirtualRendererSize: function() {
        return cc.size(this._barRendererTextureSize)
    },
    getVirtualRenderer: function() {
        return this._barRenderer
    },
    _barRendererScaleChangedWithSize: function() {
        var a = this._barRenderer,
            b = this._contentSize;
        if (this._unifySize) this._totalLength = this._contentSize.width, this.setPercent(this._percent);
        else if (this._ignoreSize) this._scale9Enabled || (this._totalLength = this._barRendererTextureSize.width, a.setScale(1));
        else if (this._totalLength = b.width, this._scale9Enabled) this._setScale9Scale();
        else {
            var c = this._barRendererTextureSize;
            if (c.width <= 0 || c.height <= 0) return void a.setScale(1);
            var d = b.width / c.width,
                e = b.height / c.height;
            a.setScaleX(d), a.setScaleY(e)
        }
        switch (this._direction) {
            case ccui.LoadingBar.TYPE_LEFT:
                a.setPosition(0, .5 * b.height);
                break;
            case ccui.LoadingBar.TYPE_RIGHT:
                a.setPosition(this._totalLength, .5 * b.height)
        }
    },
    _setScale9Scale: function() {
        var a = this._percent / 100 * this._totalLength;
        this._barRenderer.setPreferredSize(cc.size(a, this._contentSize.height))
    },
    getDescription: function() {
        return "LoadingBar"
    },
    _createCloneInstance: function() {
        return new ccui.LoadingBar
    },
    _copySpecialProperties: function(a) {
        a instanceof ccui.LoadingBar && (this._prevIgnoreSize = a._prevIgnoreSize, this.setScale9Enabled(a._scale9Enabled), this.loadTexture(a._textureFile, a._renderBarTexType), this.setCapInsets(a._capInsets), this.setPercent(a._percent), this.setDirection(a._direction))
    }
});
var _p = ccui.LoadingBar.prototype;
_p.direction, cc.defineGetterSetter(_p, "direction", _p.getDirection, _p.setDirection), _p.percent, cc.defineGetterSetter(_p, "percent", _p.getPercent, _p.setPercent), _p = null, ccui.LoadingBar.create = function(a, b) {
    return new ccui.LoadingBar(a, b)
}, ccui.LoadingBar.TYPE_LEFT = 0, ccui.LoadingBar.TYPE_RIGHT = 1, ccui.LoadingBar.RENDERER_ZORDER = -1, ccui.Slider = ccui.Widget.extend({
    _barRenderer: null,
    _progressBarRenderer: null,
    _progressBarTextureSize: null,
    _slidBallNormalRenderer: null,
    _slidBallPressedRenderer: null,
    _slidBallDisabledRenderer: null,
    _slidBallRenderer: null,
    _barLength: 0,
    _percent: 0,
    _scale9Enabled: !1,
    _prevIgnoreSize: !0,
    _textureFile: "",
    _progressBarTextureFile: "",
    _slidBallNormalTextureFile: "",
    _slidBallPressedTextureFile: "",
    _slidBallDisabledTextureFile: "",
    _capInsetsBarRenderer: null,
    _capInsetsProgressBarRenderer: null,
    _sliderEventListener: null,
    _sliderEventSelector: null,
    _barTexType: ccui.Widget.LOCAL_TEXTURE,
    _progressBarTexType: ccui.Widget.LOCAL_TEXTURE,
    _ballNTexType: ccui.Widget.LOCAL_TEXTURE,
    _ballPTexType: ccui.Widget.LOCAL_TEXTURE,
    _ballDTexType: ccui.Widget.LOCAL_TEXTURE,
    _isTextureLoaded: !1,
    _className: "Slider",
    _barRendererAdaptDirty: !0,
    _progressBarRendererDirty: !0,
    ctor: function() {
        this._progressBarTextureSize = cc.size(0, 0), this._capInsetsBarRenderer = cc.rect(0, 0, 0, 0), this._capInsetsProgressBarRenderer = cc.rect(0, 0, 0, 0), ccui.Widget.prototype.ctor.call(this)
    },
    init: function() {
        return ccui.Widget.prototype.init.call(this)
    },
    _initRenderer: function() {
        this._barRenderer = new cc.Sprite, this._progressBarRenderer = new cc.Sprite, this._progressBarRenderer.setAnchorPoint(0, .5), this.addProtectedChild(this._barRenderer, ccui.Slider.BASEBAR_RENDERER_ZORDER, -1), this.addProtectedChild(this._progressBarRenderer, ccui.Slider.PROGRESSBAR_RENDERER_ZORDER, -1), this._slidBallNormalRenderer = new cc.Sprite, this._slidBallPressedRenderer = new cc.Sprite, this._slidBallPressedRenderer.setVisible(!1), this._slidBallDisabledRenderer = new cc.Sprite, this._slidBallDisabledRenderer.setVisible(!1), this._slidBallRenderer = new cc.Node, this._slidBallRenderer.addChild(this._slidBallNormalRenderer), this._slidBallRenderer.addChild(this._slidBallPressedRenderer), this._slidBallRenderer.addChild(this._slidBallDisabledRenderer), this._slidBallRenderer.setCascadeColorEnabled(!0), this._slidBallRenderer.setCascadeOpacityEnabled(!0), this.addProtectedChild(this._slidBallRenderer, ccui.Slider.BALL_RENDERER_ZORDER, -1)
    },
    loadBarTexture: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE, this._textureFile = a, this._barTexType = b;
            var c = this._barRenderer,
                d = this;
            switch (c.texture && c.texture.isLoaded() || c.addEventListener("load", function() {
                d._findLayout(), d._updateChildrenDisplayedRGBA(), d._barRendererAdaptDirty = !0, d._progressBarRendererDirty = !0, d._updateContentSizeWithTextureSize(d._barRenderer.getContentSize())
            }), this._barTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    c.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    c.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA(), this._barRendererAdaptDirty = !0, this._progressBarRendererDirty = !0, this._updateContentSizeWithTextureSize(this._barRenderer.getContentSize())
        }
    },
    loadProgressBarTexture: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE, this._progressBarTextureFile = a, this._progressBarTexType = b;
            var c = this._progressBarRenderer,
                d = this;
            switch (c.texture && c.texture.isLoaded() || c.addEventListener("load", function() {
                d._findLayout(), d._updateChildrenDisplayedRGBA(), d._progressBarRenderer.setAnchorPoint(cc.p(0, .5));
                var a = d._progressBarRenderer.getContentSize();
                d._progressBarTextureSize = {
                    width: a.width,
                    height: a.height
                }, d._progressBarRendererDirty = !0
            }), this._progressBarTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    c.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    c.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA(), this._progressBarRenderer.setAnchorPoint(cc.p(0, .5));
            var e = this._progressBarRenderer.getContentSize();
            this._progressBarTextureSize = {
                width: e.width,
                height: e.height
            }, this._progressBarRendererDirty = !0
        }
    },
    setScale9Enabled: function(a) {
        if (this._scale9Enabled != a) {
            if (this._scale9Enabled = a, this.removeProtectedChild(this._barRenderer, !0), this.removeProtectedChild(this._progressBarRenderer, !0), this._barRenderer = null, this._progressBarRenderer = null, this._scale9Enabled ? (this._barRenderer = new ccui.Scale9Sprite, this._progressBarRenderer = new ccui.Scale9Sprite) : (this._barRenderer = new cc.Sprite, this._progressBarRenderer = new cc.Sprite), this.loadBarTexture(this._textureFile, this._barTexType), this.loadProgressBarTexture(this._progressBarTextureFile, this._progressBarTexType), this.addProtectedChild(this._barRenderer, ccui.Slider.BASEBAR_RENDERER_ZORDER, -1), this.addProtectedChild(this._progressBarRenderer, ccui.Slider.PROGRESSBAR_RENDERER_ZORDER, -1), this._scale9Enabled) {
                var b = this._ignoreSize;
                this.ignoreContentAdaptWithSize(!1), this._prevIgnoreSize = b
            } else this.ignoreContentAdaptWithSize(this._prevIgnoreSize);
            this.setCapInsetsBarRenderer(this._capInsetsBarRenderer), this.setCapInsetProgressBarRenderer(this._capInsetsProgressBarRenderer)
        }
    },
    isScale9Enabled: function() {
        return this._scale9Enabled
    },
    ignoreContentAdaptWithSize: function(a) {
        (!this._scale9Enabled || this._scale9Enabled && !a) && (ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this, a), this._prevIgnoreSize = a)
    },
    setCapInsets: function(a) {
        this.setCapInsetsBarRenderer(a), this.setCapInsetProgressBarRenderer(a)
    },
    setCapInsetsBarRenderer: function(a) {
        if (a) {
            var b = this._capInsetsBarRenderer;
            b.x = a.x, b.y = a.y, b.width = a.width, b.height = a.height, this._scale9Enabled && this._barRenderer.setCapInsets(a)
        }
    },
    getCapInsetsBarRenderer: function() {
        return cc.rect(this._capInsetsBarRenderer)
    },
    setCapInsetProgressBarRenderer: function(a) {
        if (a) {
            var b = this._capInsetsProgressBarRenderer;
            b.x = a.x, b.y = a.y, b.width = a.width, b.height = a.height, this._scale9Enabled && this._progressBarRenderer.setCapInsets(a)
        }
    },
    getCapInsetsProgressBarRenderer: function() {
        return cc.rect(this._capInsetsProgressBarRenderer)
    },
    loadSlidBallTextures: function(a, b, c, d) {
        this.loadSlidBallTextureNormal(a, d), this.loadSlidBallTexturePressed(b, d), this.loadSlidBallTextureDisabled(c, d)
    },
    loadSlidBallTextureNormal: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE, this._slidBallNormalTextureFile = a, this._ballNTexType = b;
            var c = this;
            switch (this._slidBallNormalRenderer.texture && this._slidBallNormalRenderer.texture.isLoaded() || this._slidBallNormalRenderer.addEventListener("load", function() {
                c._updateChildrenDisplayedRGBA()
            }), this._ballNTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._slidBallNormalRenderer.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._slidBallNormalRenderer.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA()
        }
    },
    loadSlidBallTexturePressed: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE, this._slidBallPressedTextureFile = a, this._ballPTexType = b;
            var c = this;
            switch (this._slidBallPressedRenderer.texture && this._slidBallPressedRenderer.texture.isLoaded() || this._slidBallPressedRenderer.addEventListener("load", function() {
                c._updateChildrenDisplayedRGBA()
            }), this._ballPTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._slidBallPressedRenderer.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._slidBallPressedRenderer.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA()
        }
    },
    loadSlidBallTextureDisabled: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE, this._slidBallDisabledTextureFile = a, this._ballDTexType = b;
            var c = this;
            switch (this._slidBallDisabledRenderer.texture && this._slidBallDisabledRenderer.texture.isLoaded() || this._slidBallDisabledRenderer.addEventListener("load", function() {
                c._updateChildrenDisplayedRGBA()
            }), this._ballDTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._slidBallDisabledRenderer.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._slidBallDisabledRenderer.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA()
        }
    },
    setPercent: function(a) {
        a > 100 && (a = 100), 0 > a && (a = 0), this._percent = a;
        var b = a / 100,
            c = this._barLength * b;
        if (this._slidBallRenderer.setPosition(c, this._contentSize.height / 2), this._scale9Enabled) this._progressBarRenderer.setPreferredSize(cc.size(c, this._progressBarTextureSize.height));
        else {
            var d = this._progressBarRenderer,
                e = d.getTextureRect();
            d.setTextureRect(cc.rect(e.x, e.y, c, e.height), d.isTextureRectRotated())
        }
    },
    hitTest: function(a) {
        var b = this._slidBallNormalRenderer.convertToNodeSpace(a),
            c = this._slidBallNormalRenderer.getContentSize(),
            d = cc.rect(0, 0, c.width, c.height);
        return b.x >= d.x && b.x <= d.x + d.width && b.y >= d.y && b.y <= d.y + d.height
    },
    onTouchBegan: function(a, b) {
        var c = ccui.Widget.prototype.onTouchBegan.call(this, a, b);
        if (this._hit) {
            var d = this.convertToNodeSpace(this._touchBeganPosition);
            this.setPercent(this._getPercentWithBallPos(d.x)), this._percentChangedEvent()
        }
        return c
    },
    onTouchMoved: function(a) {
        var b = a.getLocation(),
            c = this.convertToNodeSpace(b);
        this.setPercent(this._getPercentWithBallPos(c.x)), this._percentChangedEvent()
    },
    onTouchEnded: function(a, b) {
        ccui.Widget.prototype.onTouchEnded.call(this, a, b)
    },
    onTouchCancelled: function(a, b) {
        ccui.Widget.prototype.onTouchCancelled.call(this, a, b)
    },
    _getPercentWithBallPos: function(a) {
        return a / this._barLength * 100
    },
    addEventListenerSlider: function(a, b) {
        this.addEventListener(a, b)
    },
    addEventListener: function(a, b) {
        this._sliderEventSelector = a, this._sliderEventListener = b
    },
    _percentChangedEvent: function() {
        this._sliderEventSelector && (this._sliderEventListener ? this._sliderEventSelector.call(this._sliderEventListener, this, ccui.Slider.EVENT_PERCENT_CHANGED) : this._sliderEventSelector(this, ccui.Slider.EVENT_PERCENT_CHANGED))
    },
    getPercent: function() {
        return this._percent
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this), this._barRendererAdaptDirty = !0, this._progressBarRendererDirty = !0
    },
    _adaptRenderers: function() {
        this._barRendererAdaptDirty && (this._barRendererScaleChangedWithSize(), this._barRendererAdaptDirty = !1), this._progressBarRendererDirty && (this._progressBarRendererScaleChangedWithSize(), this._progressBarRendererDirty = !1)
    },
    getVirtualRendererSize: function() {
        return this._barRenderer.getContentSize()
    },
    getVirtualRenderer: function() {
        return this._barRenderer
    },
    _barRendererScaleChangedWithSize: function() {
        if (this._ignoreSize) this._barRenderer.setScale(1), this._barLength = this._contentSize.width;
        else if (this._barLength = this._contentSize.width, this._scale9Enabled) this._barRenderer.setPreferredSize(this._contentSize);
        else {
            var a = this._barRenderer.getContentSize();
            if (a.width <= 0 || a.height <= 0) return void this._barRenderer.setScale(1);
            var b = this._contentSize.width / a.width,
                c = this._contentSize.height / a.height;
            this._barRenderer.setScaleX(b), this._barRenderer.setScaleY(c)
        }
        this._barRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2), this.setPercent(this._percent)
    },
    _progressBarRendererScaleChangedWithSize: function() {
        if (this._ignoreSize) {
            if (!this._scale9Enabled) {
                var a = this._progressBarTextureSize,
                    b = this._contentSize.width / a.width,
                    c = this._contentSize.height / a.height;
                this._progressBarRenderer.setScaleX(b), this._progressBarRenderer.setScaleY(c)
            }
        } else if (this._scale9Enabled) this._progressBarRenderer.setPreferredSize(this._contentSize), this._progressBarTextureSize = this._progressBarRenderer.getContentSize();
        else {
            var a = this._progressBarTextureSize;
            if (a.width <= 0 || a.height <= 0) return void this._progressBarRenderer.setScale(1);
            var b = this._contentSize.width / a.width,
                c = this._contentSize.height / a.height;
            this._progressBarRenderer.setScaleX(b), this._progressBarRenderer.setScaleY(c)
        }
        this._progressBarRenderer.setPosition(0, this._contentSize.height / 2), this.setPercent(this._percent)
    },
    _onPressStateChangedToNormal: function() {
        this._slidBallNormalRenderer.setVisible(!0), this._slidBallPressedRenderer.setVisible(!1), this._slidBallDisabledRenderer.setVisible(!1)
    },
    _onPressStateChangedToPressed: function() {
        this._slidBallNormalRenderer.setVisible(!1), this._slidBallPressedRenderer.setVisible(!0), this._slidBallDisabledRenderer.setVisible(!1)
    },
    _onPressStateChangedToDisabled: function() {
        this._slidBallNormalRenderer.setVisible(!1), this._slidBallPressedRenderer.setVisible(!1), this._slidBallDisabledRenderer.setVisible(!0)
    },
    getDescription: function() {
        return "Slider"
    },
    _createCloneInstance: function() {
        return new ccui.Slider
    },
    _copySpecialProperties: function(a) {
        this._prevIgnoreSize = a._prevIgnoreSize, this.setScale9Enabled(a._scale9Enabled), this.loadBarTexture(a._textureFile, a._barTexType), this.loadProgressBarTexture(a._progressBarTextureFile, a._progressBarTexType), this.loadSlidBallTextureNormal(a._slidBallNormalTextureFile, a._ballNTexType), this.loadSlidBallTexturePressed(a._slidBallPressedTextureFile, a._ballPTexType), this.loadSlidBallTextureDisabled(a._slidBallDisabledTextureFile, a._ballDTexType), this.setPercent(a.getPercent()), this._sliderEventListener = a._sliderEventListener, this._sliderEventSelector = a._sliderEventSelector
    }
});
var _p = ccui.Slider.prototype;
_p.percent, cc.defineGetterSetter(_p, "percent", _p.getPercent, _p.setPercent), _p = null, ccui.Slider.create = function() {
    return new ccui.Slider
}, ccui.Slider.EVENT_PERCENT_CHANGED = 0, ccui.Slider.BASEBAR_RENDERER_ZORDER = -3, ccui.Slider.PROGRESSBAR_RENDERER_ZORDER = -2, ccui.Slider.BALL_RENDERER_ZORDER = -1, ccui.Text = ccui.Widget.extend({
    _touchScaleChangeEnabled: !1,
    _normalScaleValueX: 1,
    _normalScaleValueY: 1,
    _fontName: "Thonburi",
    _fontSize: 10,
    _onSelectedScaleOffset: .5,
    _labelRenderer: "",
    _textAreaSize: null,
    _textVerticalAlignment: 0,
    _textHorizontalAlignment: 0,
    _className: "Text",
    _type: null,
    _labelRendererAdaptDirty: !0,
    ctor: function(a, b, c) {
        this._type = ccui.Text.Type.SYSTEM, this._textAreaSize = cc.size(0, 0), ccui.Widget.prototype.ctor.call(this), void 0 !== c && this.init(a, b, c)
    },
    init: function(a, b, c) {
        return ccui.Widget.prototype.init.call(this) ? (arguments.length > 0 && (this.setString(a), this.setFontName(b), this.setFontSize(c)), !0) : !1
    },
    _initRenderer: function() {
        this._labelRenderer = new cc.LabelTTF, this.addProtectedChild(this._labelRenderer, ccui.Text.RENDERER_ZORDER, -1)
    },
    setText: function(a) {
        cc.log("Please use the setString"), this.setString(a)
    },
    setString: function(a) {
        this._labelRenderer.setString(a), this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize()), this._labelRendererAdaptDirty = !0
    },
    getStringValue: function() {
        return cc.log("Please use the getString"), this._labelRenderer.getString()
    },
    getString: function() {
        return this._labelRenderer.getString()
    },
    getStringLength: function() {
        return this._labelRenderer.getStringLength()
    },
    setFontSize: function(a) {
        this._labelRenderer.setFontSize(a), this._fontSize = a, this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize()), this._labelRendererAdaptDirty = !0
    },
    getFontSize: function() {
        return this._fontSize
    },
    setFontName: function(a) {
        this._fontName = a, this._labelRenderer.setFontName(a), this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize()), this._labelRendererAdaptDirty = !0
    },
    getFontName: function() {
        return this._fontName
    },
    _setFont: function(a) {
        var b = cc.LabelTTF._fontStyleRE.exec(a);
        b && (this._fontSize = parseInt(b[1]), this._fontName = b[2], this._labelRenderer._setFont(a), this._labelScaleChangedWithSize())
    },
    _getFont: function() {
        return this._labelRenderer._getFont()
    },
    getType: function() {
        return this._type
    },
    setTextAreaSize: function(a) {
        this._labelRenderer.setDimensions(a), this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize()), this._labelRendererAdaptDirty = !0
    },
    getTextAreaSize: function() {
        return this._labelRenderer.getDimensions()
    },
    setTextHorizontalAlignment: function(a) {
        this._labelRenderer.setHorizontalAlignment(a), this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize()), this._labelRendererAdaptDirty = !0
    },
    getTextHorizontalAlignment: function() {
        return this._labelRenderer.getHorizontalAlignment()
    },
    setTextVerticalAlignment: function(a) {
        this._labelRenderer.setVerticalAlignment(a), this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize()), this._labelRendererAdaptDirty = !0
    },
    getTextVerticalAlignment: function() {
        return this._labelRenderer.getVerticalAlignment()
    },
    setTouchScaleChangeEnabled: function(a) {
        this._touchScaleChangeEnabled = a
    },
    isTouchScaleChangeEnabled: function() {
        return this._touchScaleChangeEnabled
    },
    _onPressStateChangedToNormal: function() {
        this._touchScaleChangeEnabled && (this._labelRenderer.setScaleX(this._normalScaleValueX), this._labelRenderer.setScaleY(this._normalScaleValueY))
    },
    _onPressStateChangedToPressed: function() {
        this._touchScaleChangeEnabled && (this._labelRenderer.setScaleX(this._normalScaleValueX + this._onSelectedScaleOffset), this._labelRenderer.setScaleY(this._normalScaleValueY + this._onSelectedScaleOffset))
    },
    _onPressStateChangedToDisabled: function() {},
    _updateFlippedX: function() {
        this._labelRenderer.setScaleX(this._flippedX ? -1 : 1)
    },
    _updateFlippedY: function() {
        this._labelRenderer.setScaleY(this._flippedY ? -1 : 1)
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this), this._labelRendererAdaptDirty = !0
    },
    _adaptRenderers: function() {
        this._labelRendererAdaptDirty && (this._labelScaleChangedWithSize(), this._labelRendererAdaptDirty = !1)
    },
    getVirtualRendererSize: function() {
        return this._labelRenderer.getContentSize()
    },
    getVirtualRenderer: function() {
        return this._labelRenderer
    },
    _labelScaleChangedWithSize: function() {
        var a = this._contentSize;
        if (this._ignoreSize) this._labelRenderer.setDimensions(0, 0), this._labelRenderer.setScale(1), this._normalScaleValueX = this._normalScaleValueY = 1;
        else {
            this._labelRenderer.setDimensions(cc.size(a.width, a.height));
            var b = this._labelRenderer.getContentSize();
            if (b.width <= 0 || b.height <= 0) return void this._labelRenderer.setScale(1);
            var c = a.width / b.width,
                d = a.height / b.height;
            this._labelRenderer.setScaleX(c), this._labelRenderer.setScaleY(d), this._normalScaleValueX = c, this._normalScaleValueY = d
        }
        this._labelRenderer.setPosition(a.width / 2, a.height / 2)
    },
    getDescription: function() {
        return "Label"
    },
    enableShadow: function(a, b, c) {
        this._labelRenderer.enableShadow(a, b, c)
    },
    enableOutline: function(a, b) {
        this._labelRenderer.enableStroke(a, b)
    },
    enableGlow: function(a) {
        this._type == ccui.Text.Type.TTF && this._labelRenderer.enableGlow(a)
    },
    disableEffect: function() {
        this._labelRenderer.disableEffect && this._labelRenderer.disableEffect()
    },
    _createCloneInstance: function() {
        return new ccui.Text
    },
    _copySpecialProperties: function(a) {
        a instanceof ccui.Text && (this.setFontName(a._fontName), this.setFontSize(a.getFontSize()), this.setString(a.getString()), this.setTouchScaleChangeEnabled(a.touchScaleEnabled), this.setTextAreaSize(a._textAreaSize), this.setTextHorizontalAlignment(a._labelRenderer.getHorizontalAlignment()), this.setTextVerticalAlignment(a._labelRenderer.getVerticalAlignment()))
    },
    _setBoundingWidth: function(a) {
        this._textAreaSize.width = a, this._labelRenderer._setBoundingWidth(a), this._labelScaleChangedWithSize()
    },
    _setBoundingHeight: function(a) {
        this._textAreaSize.height = a, this._labelRenderer._setBoundingHeight(a), this._labelScaleChangedWithSize()
    },
    _getBoundingWidth: function() {
        return this._textAreaSize.width
    },
    _getBoundingHeight: function() {
        return this._textAreaSize.height
    },
    _changePosition: function() {
        this._adaptRenderers()
    },
    setColor: function(a) {
        cc.ProtectedNode.prototype.setColor.call(this, a), this._labelRenderer.setColor(a)
    }
});
var _p = ccui.Text.prototype;
_p.boundingWidth, cc.defineGetterSetter(_p, "boundingWidth", _p._getBoundingWidth, _p._setBoundingWidth), _p.boundingHeight, cc.defineGetterSetter(_p, "boundingHeight", _p._getBoundingHeight, _p._setBoundingHeight), _p.string, cc.defineGetterSetter(_p, "string", _p.getString, _p.setString), _p.stringLength, cc.defineGetterSetter(_p, "stringLength", _p.getStringLength), _p.font, cc.defineGetterSetter(_p, "font", _p._getFont, _p._setFont), _p.fontSize, cc.defineGetterSetter(_p, "fontSize", _p.getFontSize, _p.setFontSize), _p.fontName, cc.defineGetterSetter(_p, "fontName", _p.getFontName, _p.setFontName), _p.textAlign, cc.defineGetterSetter(_p, "textAlign", _p.getTextHorizontalAlignment, _p.setTextHorizontalAlignment), _p.verticalAlign, cc.defineGetterSetter(_p, "verticalAlign", _p.getTextVerticalAlignment, _p.setTextVerticalAlignment), _p = null, ccui.Label = ccui.Text.create = function(a, b, c) {
    return new ccui.Text(a, b, c)
}, ccui.Text.RENDERER_ZORDER = -1, ccui.Text.Type = {
    SYSTEM: 0,
    TTF: 1
}, ccui.TextAtlas = ccui.Widget.extend({
    _labelAtlasRenderer: null,
    _stringValue: "",
    _charMapFileName: "",
    _itemWidth: 0,
    _itemHeight: 0,
    _startCharMap: "",
    _className: "TextAtlas",
    _labelAtlasRendererAdaptDirty: null,
    ctor: function(a, b, c, d, e) {
        ccui.Widget.prototype.ctor.call(this), void 0 !== e && this.setProperty(a, b, c, d, e)
    },
    _initRenderer: function() {
        this._labelAtlasRenderer = new cc.LabelAtlas, this._labelAtlasRenderer.setAnchorPoint(cc.p(.5, .5)), this.addProtectedChild(this._labelAtlasRenderer, ccui.TextAtlas.RENDERER_ZORDER, -1)
    },
    setProperty: function(a, b, c, d, e) {
        this._stringValue = a, this._charMapFileName = b, this._itemWidth = c, this._itemHeight = d, this._startCharMap = e, this._labelAtlasRenderer.initWithString(a, this._charMapFileName, this._itemWidth, this._itemHeight, this._startCharMap[0]), this._updateContentSizeWithTextureSize(this._labelAtlasRenderer.getContentSize()), this._labelAtlasRendererAdaptDirty = !0
    },
    setString: function(a) {
        this._stringValue = a, this._labelAtlasRenderer.setString(a), this._updateContentSizeWithTextureSize(this._labelAtlasRenderer.getContentSize()), this._labelAtlasRendererAdaptDirty = !0
    },
    setStringValue: function(a) {
        cc.log("Please use the setString"), this.setString(a)
    },
    getStringValue: function() {
        return cc.log("Please use the getString"), this.getString()
    },
    getString: function() {
        return this._labelAtlasRenderer.getString()
    },
    getStringLength: function() {
        return this._labelAtlasRenderer.getStringLength()
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this), this._labelAtlasRendererAdaptDirty = !0
    },
    _adaptRenderers: function() {
        this._labelAtlasRendererAdaptDirty && (this._labelAtlasScaleChangedWithSize(), this._labelAtlasRendererAdaptDirty = !1)
    },
    getVirtualRendererSize: function() {
        return this._labelAtlasRenderer.getContentSize()
    },
    getVirtualRenderer: function() {
        return this._labelAtlasRenderer
    },
    _labelAtlasScaleChangedWithSize: function() {
        var a = this._labelAtlasRenderer;
        if (this._ignoreSize) a.setScale(1);
        else {
            var b = a.getContentSize();
            if (b.width <= 0 || b.height <= 0) return void a.setScale(1);
            a.setScaleX(this._contentSize.width / b.width), a.setScaleY(this._contentSize.height / b.height)
        }
        a.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    },
    getDescription: function() {
        return "LabelAtlas"
    },
    _copySpecialProperties: function(a) {
        a && this.setProperty(a._stringValue, a._charMapFileName, a._itemWidth, a._itemHeight, a._startCharMap)
    },
    _createCloneInstance: function() {
        return new ccui.TextAtlas
    }
});
var _p = ccui.TextAtlas.prototype;
_p.string, cc.defineGetterSetter(_p, "string", _p.getString, _p.setString), _p = null, ccui.TextAtlas.create = function(a, b, c, d, e) {
    return new ccui.TextAtlas(a, b, c, d, e)
}, ccui.TextAtlas.RENDERER_ZORDER = -1, ccui.LabelBMFont = ccui.TextBMFont = ccui.Widget.extend({
    _labelBMFontRenderer: null,
    _fntFileHasInit: !1,
    _fntFileName: "",
    _stringValue: "",
    _className: "TextBMFont",
    _labelBMFontRendererAdaptDirty: !0,
    ctor: function(a, b) {
        ccui.Widget.prototype.ctor.call(this), void 0 != b && (this.setFntFile(b), this.setString(a))
    },
    _initRenderer: function() {
        this._labelBMFontRenderer = new cc.LabelBMFont, this.addProtectedChild(this._labelBMFontRenderer, ccui.TextBMFont.RENDERER_ZORDER, -1)
    },
    setFntFile: function(a) {
        if (a) {
            var b = this;
            b._fntFileName = a, b._fntFileHasInit = !0, b._labelBMFontRenderer.initWithString(this._stringValue, a);
            var c = b._labelBMFontRenderer;
            c._textureLoaded || c.addEventListener("load", function() {
                b.updateSizeAndPosition()
            })
        }
    },
    setText: function(a) {
        cc.log("Please use the setString"), this.setString(a)
    },
    setString: function(a) {
        this._stringValue = a, this._fntFileHasInit && (this._labelBMFontRenderer.setString(a), this._updateContentSizeWithTextureSize(this._labelBMFontRenderer.getContentSize()), this._labelBMFontRendererAdaptDirty = !0)
    },
    getString: function() {
        return this._stringValue
    },
    getStringLength: function() {
        return this._labelBMFontRenderer.getStringLength()
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this), this._labelBMFontRendererAdaptDirty = !0
    },
    _adaptRenderers: function() {
        this._labelBMFontRendererAdaptDirty && (this._labelBMFontScaleChangedWithSize(), this._labelBMFontRendererAdaptDirty = !1)
    },
    getVirtualRendererSize: function() {
        return this._labelBMFontRenderer.getContentSize()
    },
    getVirtualRenderer: function() {
        return this._labelBMFontRenderer
    },
    _labelBMFontScaleChangedWithSize: function() {
        var a = this._labelBMFontRenderer;
        if (this._ignoreSize) a.setScale(1);
        else {
            var b = a.getContentSize();
            if (b.width <= 0 || b.height <= 0) return void a.setScale(1);
            a.setScaleX(this._contentSize.width / b.width), a.setScaleY(this._contentSize.height / b.height)
        }
        a.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    },
    getDescription: function() {
        return "TextBMFont"
    },
    _createCloneInstance: function() {
        return new ccui.TextBMFont
    },
    _copySpecialProperties: function(a) {
        this.setFntFile(a._fntFileName), this.setString(a._stringValue)
    }
});
var _p = ccui.TextBMFont.prototype;
_p.string, cc.defineGetterSetter(_p, "string", _p.getString, _p.setString), _p = null, ccui.TextBMFont.create = function(a, b) {
    return new ccui.TextBMFont(a, b)
}, ccui.TextBMFont.RENDERER_ZORDER = -1, ccui._TextFieldRenderer = cc.TextFieldTTF.extend({
    _maxLengthEnabled: !1,
    _maxLength: 0,
    _passwordEnabled: !1,
    _passwordStyleText: "",
    _attachWithIME: !1,
    _detachWithIME: !1,
    _insertText: !1,
    _deleteBackward: !1,
    _className: "_TextFieldRenderer",
    _textFieldRendererAdaptDirty: !0,
    ctor: function() {
        cc.TextFieldTTF.prototype.ctor.call(this), this._maxLengthEnabled = !1, this._maxLength = 0, this._passwordEnabled = !1, this._passwordStyleText = "*", this._attachWithIME = !1, this._detachWithIME = !1, this._insertText = !1, this._deleteBackward = !1
    },
    onEnter: function() {
        cc.TextFieldTTF.prototype.onEnter.call(this), cc.TextFieldTTF.prototype.setDelegate.call(this, this)
    },
    onTextFieldAttachWithIME: function() {
        return this.setAttachWithIME(!0), !1
    },
    onTextFieldInsertText: function(a, b, c) {
        return 1 == c && "\n" == b ? !1 : (this.setInsertText(!0), this._maxLengthEnabled && cc.TextFieldTTF.prototype.getCharCount.call(this) >= this._maxLength)
    },
    onTextFieldDeleteBackward: function() {
        return this.setDeleteBackward(!0), !1
    },
    onTextFieldDetachWithIME: function() {
        return this.setDetachWithIME(!0), !1
    },
    insertText: function(a, b) {
        var c = a;
        if ("\n" != a && this._maxLengthEnabled) {
            var d = this.getString().length;
            if (d >= this._maxLength) return void(this._passwordEnabled && this.setPasswordText(this.getString()))
        }
        cc.TextFieldTTF.prototype.insertText.call(this, c, b), this._passwordEnabled && cc.TextFieldTTF.prototype.getCharCount.call(this) > 0 && this.setPasswordText(this.getString())
    },
    deleteBackward: function() {
        cc.TextFieldTTF.prototype.deleteBackward.call(this), cc.TextFieldTTF.prototype.getCharCount.call(this) > 0 && this._passwordEnabled && this.setPasswordText(this._inputText)
    },
    openIME: function() {
        cc.TextFieldTTF.prototype.attachWithIME.call(this)
    },
    closeIME: function() {
        cc.TextFieldTTF.prototype.detachWithIME.call(this)
    },
    setMaxLengthEnabled: function(a) {
        this._maxLengthEnabled = a
    },
    isMaxLengthEnabled: function() {
        return this._maxLengthEnabled
    },
    setMaxLength: function(a) {
        this._maxLength = a
    },
    getMaxLength: function() {
        return this._maxLength
    },
    getCharCount: function() {
        return cc.TextFieldTTF.prototype.getCharCount.call(this)
    },
    setPasswordEnabled: function(a) {
        this._passwordEnabled = a
    },
    isPasswordEnabled: function() {
        return this._passwordEnabled
    },
    setPasswordStyleText: function(a) {
        if (!(a.length > 1)) {
            var b = a.charCodeAt(0);
            33 > b || b > 126 || (this._passwordStyleText = a)
        }
    },
    setPasswordText: function(a) {
        var b = "",
            c = a.length,
            d = c;
        this._maxLengthEnabled && c > this._maxLength && (d = this._maxLength);
        for (var e = 0; d > e; ++e) b += this._passwordStyleText;
        cc.LabelTTF.prototype.setString.call(this, b)
    },
    setAttachWithIME: function(a) {
        this._attachWithIME = a
    },
    getAttachWithIME: function() {
        return this._attachWithIME
    },
    setDetachWithIME: function(a) {
        this._detachWithIME = a
    },
    getDetachWithIME: function() {
        return this._detachWithIME
    },
    setInsertText: function(a) {
        this._insertText = a
    },
    getInsertText: function() {
        return this._insertText
    },
    setDeleteBackward: function(a) {
        this._deleteBackward = a
    },
    getDeleteBackward: function() {
        return this._deleteBackward
    },
    onDraw: function() {
        return !1
    }
}), ccui._TextFieldRenderer.create = function(a, b, c) {
    var d = new ccui._TextFieldRenderer;
    return d && d.initWithString("", b, c) ? (a && d.setPlaceHolder(a), d) : null
}, ccui.TextField = ccui.Widget.extend({
    _textFieldRenderer: null,
    _touchWidth: 0,
    _touchHeight: 0,
    _useTouchArea: !1,
    _textFieldEventListener: null,
    _textFieldEventSelector: null,
    _passwordStyleText: "",
    _textFieldRendererAdaptDirty: !0,
    _fontName: "",
    _fontSize: 12,
    ctor: function(a, b, c) {
        ccui.Widget.prototype.ctor.call(this), a && this.setPlaceHolder(a), b && this.setFontName(b), c && this.setFontSize(c)
    },
    init: function() {
        return ccui.Widget.prototype.init.call(this) ? (this.setTouchEnabled(!0), !0) : !1
    },
    onEnter: function() {
        ccui.Widget.prototype.onEnter.call(this), this.scheduleUpdate()
    },
    _initRenderer: function() {
        this._textFieldRenderer = ccui._TextFieldRenderer.create("input words here", "Thonburi", 20), this.addProtectedChild(this._textFieldRenderer, ccui.TextField.RENDERER_ZORDER, -1)
    },
    setTouchSize: function(a) {
        this._touchWidth = a.width, this._touchHeight = a.height
    },
    setTouchAreaEnabled: function(a) {
        this._useTouchArea = a
    },
    hitTest: function(a) {
        if (this._useTouchArea) {
            var b = this.convertToNodeSpace(a),
                c = cc.rect(-this._touchWidth * this._anchorPoint.x, -this._touchHeight * this._anchorPoint.y, this._touchWidth, this._touchHeight);
            return b.x >= c.x && b.x <= c.x + c.width && b.y >= c.y && b.y <= c.y + c.height
        }
        return ccui.Widget.prototype.hitTest.call(this, a)
    },
    getTouchSize: function() {
        return cc.size(this._touchWidth, this._touchHeight)
    },
    setText: function(a) {
        cc.log("Please use the setString"), this.setString(a)
    },
    setString: function(a) {
        null != a && (a = String(a), this.isMaxLengthEnabled() && (a = a.substr(0, this.getMaxLength())), this.isPasswordEnabled() ? (this._textFieldRenderer.setPasswordText(a), this._textFieldRenderer.setString(""), this._textFieldRenderer.insertText(a, a.length)) : this._textFieldRenderer.setString(a), this._textFieldRendererAdaptDirty = !0, this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize()))
    },
    setPlaceHolder: function(a) {
        this._textFieldRenderer.setPlaceHolder(a), this._textFieldRendererAdaptDirty = !0, this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize())
    },
    getPlaceHolder: function() {
        return this._textFieldRenderer.getPlaceHolder()
    },
    getPlaceHolderColor: function() {
        return this._textFieldRenderer.getPlaceHolderColor()
    },
    setPlaceHolderColor: function(a) {
        this._textFieldRenderer.setColorSpaceHolder(a)
    },
    setTextColor: function(a) {
        this._textFieldRenderer.setTextColor(a)
    },
    setFontSize: function(a) {
        this._textFieldRenderer.setFontSize(a), this._fontSize = a, this._textFieldRendererAdaptDirty = !0, this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize())
    },
    getFontSize: function() {
        return this._fontSize
    },
    setFontName: function(a) {
        this._textFieldRenderer.setFontName(a), this._fontName = a, this._textFieldRendererAdaptDirty = !0, this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize())
    },
    getFontName: function() {
        return this._fontName
    },
    didNotSelectSelf: function() {
        this._textFieldRenderer.detachWithIME()
    },
    getStringValue: function() {
        return cc.log("Please use the getString"), this.getString()
    },
    getString: function() {
        return this._textFieldRenderer.getString()
    },
    getStringLength: function() {
        return this._textFieldRenderer.getStringLength()
    },
    onTouchBegan: function(a, b) {
        var c = this,
            d = ccui.Widget.prototype.onTouchBegan.call(c, a, b);
        return c._hit && setTimeout(function() {
            c._textFieldRenderer.attachWithIME()
        }, 0), d
    },
    setMaxLengthEnabled: function(a) {
        this._textFieldRenderer.setMaxLengthEnabled(a)
    },
    isMaxLengthEnabled: function() {
        return this._textFieldRenderer.isMaxLengthEnabled()
    },
    setMaxLength: function(a) {
        this._textFieldRenderer.setMaxLength(a), this.setString(this.getString())
    },
    getMaxLength: function() {
        return this._textFieldRenderer.getMaxLength()
    },
    setPasswordEnabled: function(a) {
        this._textFieldRenderer.setPasswordEnabled(a)
    },
    isPasswordEnabled: function() {
        return this._textFieldRenderer.isPasswordEnabled()
    },
    setPasswordStyleText: function(a) {
        this._textFieldRenderer.setPasswordStyleText(a), this._passwordStyleText = a, this.setString(this.getString())
    },
    getPasswordStyleText: function() {
        return this._passwordStyleText
    },
    update: function() {
        this.getAttachWithIME() && (this._attachWithIMEEvent(), this.setAttachWithIME(!1)), this.getDetachWithIME() && (this._detachWithIMEEvent(), this.setDetachWithIME(!1)), this.getInsertText() && (this._insertTextEvent(), this.setInsertText(!1), this._textFieldRendererAdaptDirty = !0, this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize())), this.getDeleteBackward() && (this._deleteBackwardEvent(), this.setDeleteBackward(!1), this._textFieldRendererAdaptDirty = !0, this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize()))
    },
    getAttachWithIME: function() {
        return this._textFieldRenderer.getAttachWithIME()
    },
    setAttachWithIME: function(a) {
        this._textFieldRenderer.setAttachWithIME(a)
    },
    getDetachWithIME: function() {
        return this._textFieldRenderer.getDetachWithIME()
    },
    setDetachWithIME: function(a) {
        this._textFieldRenderer.setDetachWithIME(a)
    },
    getInsertText: function() {
        return this._textFieldRenderer.getInsertText()
    },
    setInsertText: function(a) {
        this._textFieldRenderer.setInsertText(a)
    },
    getDeleteBackward: function() {
        return this._textFieldRenderer.getDeleteBackward()
    },
    setDeleteBackward: function(a) {
        this._textFieldRenderer.setDeleteBackward(a)
    },
    _attachWithIMEEvent: function() {
        this._textFieldEventSelector && (this._textFieldEventListener ? this._textFieldEventSelector.call(this._textFieldEventListener, this, ccui.TextField.EVENT_ATTACH_WITH_IME) : this._textFieldEventSelector(this, ccui.TextField.EVENT_ATTACH_WITH_IME))
    },
    _detachWithIMEEvent: function() {
        this._textFieldEventSelector && (this._textFieldEventListener ? this._textFieldEventSelector.call(this._textFieldEventListener, this, ccui.TextField.EVENT_DETACH_WITH_IME) : this._textFieldEventSelector(this, ccui.TextField.EVENT_DETACH_WITH_IME))
    },
    _insertTextEvent: function() {
        this._textFieldEventSelector && (this._textFieldEventListener ? this._textFieldEventSelector.call(this._textFieldEventListener, this, ccui.TextField.EVENT_INSERT_TEXT) : this._textFieldEventSelector(this, ccui.TextField.EVENT_INSERT_TEXT))
    },
    _deleteBackwardEvent: function() {
        this._textFieldEventSelector && (this._textFieldEventListener ? this._textFieldEventSelector.call(this._textFieldEventListener, this, ccui.TextField.EVENT_DELETE_BACKWARD) : this._textFieldEventSelector(this, ccui.TextField.EVENT_DELETE_BACKWARD))
    },
    addEventListenerTextField: function(a, b) {
        this.addEventListener(a, b)
    },
    addEventListener: function(a, b) {
        this._textFieldEventSelector = a, this._textFieldEventListener = b
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this), this._textFieldRendererAdaptDirty = !0
    },
    _adaptRenderers: function() {
        this._textFieldRendererAdaptDirty && (this._textfieldRendererScaleChangedWithSize(), this._textFieldRendererAdaptDirty = !1)
    },
    _textfieldRendererScaleChangedWithSize: function() {
        this._ignoreSize || this._textFieldRenderer.setDimensions(this._contentSize), this._textFieldRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    },
    getVirtualRendererSize: function() {
        return this._textFieldRenderer.getContentSize()
    },
    getVirtualRenderer: function() {
        return this._textFieldRenderer
    },
    getDescription: function() {
        return "TextField"
    },
    attachWithIME: function() {
        this._textFieldRenderer.attachWithIME()
    },
    _createCloneInstance: function() {
        return new ccui.TextField
    },
    _copySpecialProperties: function(a) {
        this.setString(a._textFieldRenderer.getString()), this.setPlaceHolder(a.getString()), this.setFontSize(a._textFieldRenderer.getFontSize()), this.setFontName(a._textFieldRenderer.getFontName()), this.setMaxLengthEnabled(a.isMaxLengthEnabled()), this.setMaxLength(a.getMaxLength()), this.setPasswordEnabled(a.isPasswordEnabled()), this.setPasswordStyleText(a._passwordStyleText), this.setAttachWithIME(a.getAttachWithIME()), this.setDetachWithIME(a.getDetachWithIME()), this.setInsertText(a.getInsertText()), this.setDeleteBackward(a.getDeleteBackward())
    },
    setTextAreaSize: function(a) {
        this.setContentSize(a)
    },
    setTextHorizontalAlignment: function(a) {
        this._textFieldRenderer.setHorizontalAlignment(a)
    },
    setTextVerticalAlignment: function(a) {
        this._textFieldRenderer.setVerticalAlignment(a)
    },
    _setFont: function(a) {
        this._textFieldRenderer._setFont(a), this._textFieldRendererAdaptDirty = !0
    },
    _getFont: function() {
        return this._textFieldRenderer._getFont()
    },
    _changePosition: function() {
        this._adaptRenderers()
    }
}), ccui.TextField.create = function(a, b, c) {
    return new ccui.TextField(a, b, c)
};
var _p = ccui.TextField.prototype;
_p.string, cc.defineGetterSetter(_p, "string", _p.getString, _p.setString), _p.placeHolder, cc.defineGetterSetter(_p, "placeHolder", _p.getPlaceHolder, _p.setPlaceHolder), _p.font, cc.defineGetterSetter(_p, "font", _p._getFont, _p._setFont), _p.fontSize, cc.defineGetterSetter(_p, "fontSize", _p.getFontSize, _p.setFontSize), _p.fontName, cc.defineGetterSetter(_p, "fontName", _p.getFontName, _p.setFontName), _p.maxLengthEnabled, cc.defineGetterSetter(_p, "maxLengthEnabled", _p.isMaxLengthEnabled, _p.setMaxLengthEnabled), _p.maxLength, cc.defineGetterSetter(_p, "maxLength", _p.getMaxLength, _p.setMaxLength), _p.passwordEnabled, cc.defineGetterSetter(_p, "passwordEnabled", _p.isPasswordEnabled, _p.setPasswordEnabled), _p = null, ccui.TextField.EVENT_ATTACH_WITH_IME = 0, ccui.TextField.EVENT_DETACH_WITH_IME = 1, ccui.TextField.EVENT_INSERT_TEXT = 2, ccui.TextField.EVENT_DELETE_BACKWARD = 3, ccui.TextField.RENDERER_ZORDER = -1, ccui.RichElement = ccui.Class.extend({
    _type: 0,
    _tag: 0,
    _color: null,
    _opacity: 0,
    ctor: function() {
        this._type = 0, this._tag = 0, this._color = cc.color(255, 255, 255, 255)
    },
    init: function(a, b, c) {
        this._tag = a, this._color.r = b.r, this._color.g = b.g, this._color.b = b.b, this._opacity = c, this._color.a = void 0 === c ? b.a : c
    }
}), ccui.RichElementText = ccui.RichElement.extend({
    _text: "",
    _fontName: "",
    _fontSize: 0,
    ctor: function(a, b, c, d, e, f) {
        ccui.RichElement.prototype.ctor.call(this), this._type = ccui.RichElement.TEXT, this._text = "", this._fontName = "", this._fontSize = 0, f && this.init(a, b, c, d, e, f)
    },
    init: function(a, b, c, d, e, f) {
        ccui.RichElement.prototype.init.call(this, a, b, c), this._text = d, this._fontName = e, this._fontSize = f
    }
}), ccui.RichElementText.create = function(a, b, c, d, e, f) {
    return new ccui.RichElementText(a, b, c, d, e, f)
}, ccui.RichElementImage = ccui.RichElement.extend({
    _filePath: "",
    _textureRect: null,
    _textureType: 0,
    ctor: function(a, b, c, d) {
        ccui.RichElement.prototype.ctor.call(this), this._type = ccui.RichElement.IMAGE, this._filePath = "", this._textureRect = cc.rect(0, 0, 0, 0), this._textureType = 0, void 0 !== d && this.init(a, b, c, d)
    },
    init: function(a, b, c, d) {
        ccui.RichElement.prototype.init.call(this, a, b, c), this._filePath = d
    }
}), ccui.RichElementImage.create = function(a, b, c, d) {
    return new ccui.RichElementImage(a, b, c, d)
}, ccui.RichElementCustomNode = ccui.RichElement.extend({
    _customNode: null,
    ctor: function(a, b, c, d) {
        ccui.RichElement.prototype.ctor.call(this), this._type = ccui.RichElement.CUSTOM, this._customNode = null, void 0 !== d && this.init(a, b, c, d)
    },
    init: function(a, b, c, d) {
        ccui.RichElement.prototype.init.call(this, a, b, c), this._customNode = d
    }
}), ccui.RichElementCustomNode.create = function(a, b, c, d) {
    return new ccui.RichElementCustomNode(a, b, c, d)
}, ccui.RichText = ccui.Widget.extend({
    _formatTextDirty: !1,
    _richElements: null,
    _elementRenders: null,
    _leftSpaceWidth: 0,
    _verticalSpace: 0,
    _elementRenderersContainer: null,
    ctor: function() {
        ccui.Widget.prototype.ctor.call(this), this._formatTextDirty = !1, this._richElements = [], this._elementRenders = [], this._leftSpaceWidth = 0, this._verticalSpace = 0
    },
    _initRenderer: function() {
        this._elementRenderersContainer = new cc.Node, this._elementRenderersContainer.setAnchorPoint(.5, .5), this.addProtectedChild(this._elementRenderersContainer, 0, -1)
    },
    insertElement: function(a, b) {
        this._richElements.splice(b, 0, a), this._formatTextDirty = !0
    },
    pushBackElement: function(a) {
        this._richElements.push(a), this._formatTextDirty = !0
    },
    removeElement: function(a) {
        cc.isNumber(a) ? this._richElements.splice(a, 1) : cc.arrayRemoveObject(this._richElements, a), this._formatTextDirty = !0
    },
    formatText: function() {
        if (this._formatTextDirty) {
            this._elementRenderersContainer.removeAllChildren(), this._elementRenders.length = 0;
            var a, b, c = this._richElements;
            if (this._ignoreSize)
                for (this._addNewLine(), a = 0; a < c.length; a++) {
                    b = c[a];
                    var d = null;
                    switch (b._type) {
                        case ccui.RichElement.TEXT:
                            d = new cc.LabelTTF(b._text, b._fontName, b._fontSize);
                            break;
                        case ccui.RichElement.IMAGE:
                            d = new cc.Sprite(b._filePath);
                            break;
                        case ccui.RichElement.CUSTOM:
                            d = b._customNode
                    }
                    d.setColor(b._color), d.setOpacity(b._color.a), this._pushToContainer(d)
                } else
                    for (this._addNewLine(), a = 0; a < c.length; a++) switch (b = c[a], b._type) {
                        case ccui.RichElement.TEXT:
                            this._handleTextRenderer(b._text, b._fontName, b._fontSize, b._color);
                            break;
                        case ccui.RichElement.IMAGE:
                            this._handleImageRenderer(b._filePath, b._color, b._color.a);
                            break;
                        case ccui.RichElement.CUSTOM:
                            this._handleCustomRenderer(b._customNode)
                    }
            this.formatRenderers(), this._formatTextDirty = !1
        }
    },
    _handleTextRenderer: function(a, b, c, d) {
        var e = new cc.LabelTTF(a, b, c),
            f = e.getContentSize().width;
        if (this._leftSpaceWidth -= f, this._leftSpaceWidth < 0) {
            var g = -this._leftSpaceWidth / f,
                h = a,
                i = h.length,
                j = i * (1 - g),
                k = h.substr(0, j),
                l = h.substr(j, h.length - 1);
            if (j > 0) {
                var m = new cc.LabelTTF(k.substr(0, j), b, c);
                m.setColor(d), m.setOpacity(d.a), this._pushToContainer(m)
            }
            this._addNewLine(), this._handleTextRenderer(l, b, c, d)
        } else e.setColor(d), e.setOpacity(d.a), this._pushToContainer(e)
    },
    _handleImageRenderer: function(a) {
        var b = new cc.Sprite(a);
        this._handleCustomRenderer(b)
    },
    _handleCustomRenderer: function(a) {
        var b = a.getContentSize();
        this._leftSpaceWidth -= b.width, this._leftSpaceWidth < 0 ? (this._addNewLine(), this._pushToContainer(a), this._leftSpaceWidth -= b.width) : this._pushToContainer(a)
    },
    _addNewLine: function() {
        this._leftSpaceWidth = this._customSize.width, this._elementRenders.push([])
    },
    formatRenderers: function() {
        var a, b, c, d, e, f = 0,
            g = this._elementRenderersContainer,
            h = this._elementRenders;
        if (this._ignoreSize) {
            var i = 0;
            for (c = h[0], d = 0, b = 0; b < c.length; b++) {
                e = c[b], e.setAnchorPoint(cc.p(0, 0)), e.setPosition(d, 0), g.addChild(e, 1, b);
                var j = e.getContentSize();
                i += j.width, f = Math.max(f, j.height), d += j.width
            }
            g.setContentSize(i, f)
        } else {
            var k = [];
            for (a = 0; a < h.length; a++) {
                c = h[a];
                var l = 0;
                for (b = 0; b < c.length; b++) e = c[b], l = Math.max(e.getContentSize().height, l);
                k[a] = l, f += k[a]
            }
            var m = this._customSize.height;
            for (a = 0; a < h.length; a++)
                for (c = h[a], d = 0, m -= k[a] + this._verticalSpace, b = 0; b < c.length; b++) e = c[b], e.setAnchorPoint(cc.p(0, 0)), e.setPosition(cc.p(d, m)), g.addChild(e, 1), d += e.getContentSize().width;
            g.setContentSize(this._contentSize)
        }
        var n = h.length;
        for (a = 0; n > a; a++) h[a].length = 0;
        this._elementRenders.length = 0, this.setContentSize(this._ignoreSize ? this.getVirtualRendererSize() : this._customSize), this._updateContentSizeWithTextureSize(this._contentSize), g.setPosition(.5 * this._contentSize.width, .5 * this._contentSize.height)
    },
    _pushToContainer: function(a) {
        this._elementRenders.length <= 0 || this._elementRenders[this._elementRenders.length - 1].push(a)
    },
    visit: function(a) {
        this._enabled && (this.formatText(), ccui.Widget.prototype.visit.call(this, a))
    },
    setVerticalSpace: function(a) {
        this._verticalSpace = a
    },
    setAnchorPoint: function(a) {
        ccui.Widget.prototype.setAnchorPoint.call(this, a), this._elementRenderersContainer.setAnchorPoint(a)
    },
    _setAnchorX: function(a) {
        ccui.Widget.prototype._setAnchorX.call(this, a), this._elementRenderersContainer._setAnchorX(a)
    },
    _setAnchorY: function(a) {
        ccui.Widget.prototype._setAnchorY.call(this, a), this._elementRenderersContainer._setAnchorY(a)
    },
    getVirtualRendererSize: function() {
        return this._elementRenderersContainer.getContentSize()
    },
    ignoreContentAdaptWithSize: function(a) {
        this._ignoreSize != a && (this._formatTextDirty = !0, ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this, a))
    },
    getContentSize: function() {
        return this.formatText(), cc.Node.prototype.getContentSize.call(this)
    },
    _getWidth: function() {
        return this.formatText(), cc.Node.prototype._getWidth.call(this)
    },
    _getHeight: function() {
        return this.formatText(), cc.Node.prototype._getHeight.call(this)
    },
    setContentSize: function(a, b) {
        var c = void 0 === b ? a.width : a,
            d = void 0 === b ? a.height : b;
        ccui.Widget.prototype.setContentSize.call(this, c, d), this._formatTextDirty = !0
    },
    getDescription: function() {
        return "RichText"
    }
}), ccui.RichText.create = function() {
    return new ccui.RichText
}, ccui.RichElement.TEXT = 0, ccui.RichElement.IMAGE = 1, ccui.RichElement.CUSTOM = 2, ccui.ScrollView = ccui.Layout.extend({
    _innerContainer: null,
    direction: null,
    _autoScrollDir: null,
    _topBoundary: 0,
    _bottomBoundary: 0,
    _leftBoundary: 0,
    _rightBoundary: 0,
    _bounceTopBoundary: 0,
    _bounceBottomBoundary: 0,
    _bounceLeftBoundary: 0,
    _bounceRightBoundary: 0,
    _autoScroll: !1,
    _autoScrollAddUpTime: 0,
    _autoScrollOriginalSpeed: 0,
    _autoScrollAcceleration: 0,
    _isAutoScrollSpeedAttenuated: !1,
    _needCheckAutoScrollDestination: !1,
    _autoScrollDestination: null,
    _bePressed: !1,
    _slidTime: 0,
    _moveChildPoint: null,
    _childFocusCancelOffset: 0,
    _leftBounceNeeded: !1,
    _topBounceNeeded: !1,
    _rightBounceNeeded: !1,
    _bottomBounceNeeded: !1,
    bounceEnabled: !1,
    _bouncing: !1,
    _bounceDir: null,
    _bounceOriginalSpeed: 0,
    inertiaScrollEnabled: !1,
    _scrollViewEventListener: null,
    _scrollViewEventSelector: null,
    _className: "ScrollView",
    ctor: function() {
        ccui.Layout.prototype.ctor.call(this), this.direction = ccui.ScrollView.DIR_NONE, this._autoScrollDir = cc.p(0, 0), this._autoScrollAcceleration = -1e3, this._autoScrollDestination = cc.p(0, 0), this._slidTime = 0, this._moveChildPoint = cc.p(0, 0), this._childFocusCancelOffset = 5, this._bounceDir = cc.p(0, 0), this._bounceOriginalSpeed = 0, this.inertiaScrollEnabled = !0, this.setTouchEnabled(!0)
    },
    init: function() {
        return ccui.Layout.prototype.init.call(this) ? (this.setClippingEnabled(!0), this._innerContainer.setTouchEnabled(!1), !0) : !1
    },
    onEnter: function() {
        ccui.Layout.prototype.onEnter.call(this), this.scheduleUpdate(!0)
    },
    findNextFocusedWidget: function(a, b) {
        return this.getLayoutType() == ccui.Layout.LINEAR_VERTICAL || this.getLayoutType() == ccui.Layout.LINEAR_HORIZONTAL ? this._innerContainer.findNextFocusedWidget(a, b) : ccui.Widget.prototype.findNextFocusedWidget.call(this, a, b)
    },
    _initRenderer: function() {
        ccui.Layout.prototype._initRenderer.call(this), this._innerContainer = new ccui.Layout, this._innerContainer.setColor(cc.color(255, 255, 255)), this._innerContainer.setOpacity(255), this._innerContainer.setCascadeColorEnabled(!0), this._innerContainer.setCascadeOpacityEnabled(!0), this.addProtectedChild(this._innerContainer, 1, 1)
    },
    _onSizeChanged: function() {
        ccui.Layout.prototype._onSizeChanged.call(this);
        var a = this._contentSize;
        this._topBoundary = a.height, this._rightBoundary = a.width;
        var b = a.width / 3,
            c = a.height / 3;
        this._bounceTopBoundary = a.height - c, this._bounceBottomBoundary = c, this._bounceLeftBoundary = b, this._bounceRightBoundary = a.width - b;
        var d = this._innerContainer.getContentSize();
        this._innerContainer.setContentSize(cc.size(Math.max(d.width, a.width), Math.max(d.height, a.height))), this._innerContainer.setPosition(0, a.height - this._innerContainer.getContentSize().height)
    },
    setInnerContainerSize: function(a) {
        var b = this._innerContainer,
            c = this._contentSize,
            d = c.width,
            e = c.height,
            f = b.getContentSize();
        a.width < c.width ? cc.log("Inner width <= ScrollView width, it will be force sized!") : d = a.width, a.height < c.height ? cc.log("Inner height <= ScrollView height, it will be force sized!") : e = a.height, b.setContentSize(cc.size(d, e));
        var g, h;
        switch (this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
                g = b.getContentSize(), h = f.height - g.height, this._scrollChildren(0, h);
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                b.getRightBoundary() <= c.width && (g = b.getContentSize(), h = f.width - g.width, this._scrollChildren(h, 0));
                break;
            case ccui.ScrollView.DIR_BOTH:
                g = b.getContentSize();
                var i = f.height - g.height,
                    j = b.getRightBoundary() <= c.width ? f.width - g.width : 0;
                this._scrollChildren(j, i)
        }
        var k = b.getContentSize(),
            l = b.getPosition(),
            m = b.getAnchorPoint();
        b.getLeftBoundary() > 0 && b.setPosition(m.x * k.width, l.y), b.getRightBoundary() < c.width && b.setPosition(c.width - (1 - m.x) * k.width, l.y), l.y > 0 && b.setPosition(l.x, m.y * k.height), b.getTopBoundary() < c.height && b.setPosition(l.x, c.height - (1 - m.y) * k.height)
    },
    _setInnerWidth: function(a) {
        var b = this._contentSize.width,
            c = b,
            d = this._innerContainer,
            e = d.width;
        switch (b > a ? cc.log("Inner width <= scrollview width, it will be force sized!") : c = a, d.width = c, this.direction) {
            case ccui.ScrollView.DIR_HORIZONTAL:
            case ccui.ScrollView.DIR_BOTH:
                if (d.getRightBoundary() <= b) {
                    var f = d.width,
                        g = e - f;
                    this._scrollChildren(g, 0)
                }
        }
        var h = d.anchorX;
        d.getLeftBoundary() > 0 && (d.x = h * c), d.getRightBoundary() < b && (d.x = b - (1 - h) * c)
    },
    _setInnerHeight: function(a) {
        var b = this._contentSize.height,
            c = b,
            d = this._innerContainer,
            e = d.height;
        switch (b > a ? cc.log("Inner height <= scrollview height, it will be force sized!") : c = a, d.height = c, this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
            case ccui.ScrollView.DIR_BOTH:
                var f = c,
                    g = e - f;
                this._scrollChildren(0, g)
        }
        var h = d.anchorY;
        d.getLeftBoundary() > 0 && (d.y = h * c), d.getRightBoundary() < b && (d.y = b - (1 - h) * c)
    },
    getInnerContainerSize: function() {
        return this._innerContainer.getContentSize()
    },
    _getInnerWidth: function() {
        return this._innerContainer.width
    },
    _getInnerHeight: function() {
        return this._innerContainer.height
    },
    addChild: function(a, b, c) {
        return a ? (b = b || a.getLocalZOrder(), c = c || a.getTag(), this._innerContainer.addChild(a, b, c)) : !1
    },
    removeAllChildren: function() {
        this.removeAllChildrenWithCleanup(!0)
    },
    removeAllChildrenWithCleanup: function(a) {
        this._innerContainer.removeAllChildrenWithCleanup(a)
    },
    removeChild: function(a, b) {
        return this._innerContainer.removeChild(a, b)
    },
    getChildren: function() {
        return this._innerContainer.getChildren()
    },
    getChildrenCount: function() {
        return this._innerContainer.getChildrenCount()
    },
    getChildByTag: function(a) {
        return this._innerContainer.getChildByTag(a)
    },
    getChildByName: function(a) {
        return this._innerContainer.getChildByName(a)
    },
    _moveChildren: function(a, b) {
        var c = this._innerContainer;
        this._moveChildPoint.x = c.x + a, this._moveChildPoint.y = c.y + b, this._innerContainer.setPosition(this._moveChildPoint)
    },
    _autoScrollChildren: function(a) {
        var b = this._autoScrollAddUpTime;
        if (this._autoScrollAddUpTime += a, this._isAutoScrollSpeedAttenuated) {
            var c = this._autoScrollOriginalSpeed + this._autoScrollAcceleration * this._autoScrollAddUpTime;
            if (0 >= c) this._stopAutoScrollChildren(), this._checkNeedBounce();
            else {
                var d = 2 * b + a,
                    e = (this._autoScrollOriginalSpeed + this._autoScrollAcceleration * d * .5) * a,
                    f = e * this._autoScrollDir.x,
                    g = e * this._autoScrollDir.y;
                this._scrollChildren(f, g) || (this._stopAutoScrollChildren(), this._checkNeedBounce())
            }
        } else if (this._needCheckAutoScrollDestination) {
            var h = this._autoScrollDir.x * a * this._autoScrollOriginalSpeed,
                i = this._autoScrollDir.y * a * this._autoScrollOriginalSpeed,
                j = this._checkCustomScrollDestination(h, i),
                k = this._scrollChildren(h, i);
            j && k || (this._stopAutoScrollChildren(), this._checkNeedBounce())
        } else this._scrollChildren(this._autoScrollDir.x * a * this._autoScrollOriginalSpeed, this._autoScrollDir.y * a * this._autoScrollOriginalSpeed) || (this._stopAutoScrollChildren(), this._checkNeedBounce())
    },
    _bounceChildren: function(a) {
        var b = this._bounceOriginalSpeed,
            c = this._bounceDir;
        0 >= b && this._stopBounceChildren(), this._bounceScrollChildren(c.x * a * b, c.y * a * b) || this._stopBounceChildren()
    },
    _checkNeedBounce: function() {
        if (!this.bounceEnabled) return !1;
        this._checkBounceBoundary();
        var a = this._topBounceNeeded,
            b = this._bottomBounceNeeded,
            c = this._leftBounceNeeded,
            d = this._rightBounceNeeded;
        if (a || b || c || d) {
            var e, f, g = this._contentSize,
                h = this._innerContainer;
            return a && c ? (e = cc.pSub(cc.p(0, g.height), cc.p(h.getLeftBoundary(), h.getTopBoundary())), f = cc.pLength(e) / .2, this._bounceDir = cc.pNormalize(e), this._startBounceChildren(f)) : a && d ? (e = cc.pSub(cc.p(g.width, g.height), cc.p(h.getRightBoundary(), h.getTopBoundary())), f = cc.pLength(e) / .2, this._bounceDir = cc.pNormalize(e), this._startBounceChildren(f)) : b && c ? (e = cc.pSub(cc.p(0, 0), cc.p(h.getLeftBoundary(), h.getBottomBoundary())), f = cc.pLength(e) / .2, this._bounceDir = cc.pNormalize(e), this._startBounceChildren(f)) : b && d ? (e = cc.pSub(cc.p(g.width, 0), cc.p(h.getRightBoundary(), h.getBottomBoundary())), f = cc.pLength(e) / .2, this._bounceDir = cc.pNormalize(e), this._startBounceChildren(f)) : a ? (e = cc.pSub(cc.p(0, g.height), cc.p(0, h.getTopBoundary())), f = cc.pLength(e) / .2, this._bounceDir = cc.pNormalize(e), this._startBounceChildren(f)) : b ? (e = cc.pSub(cc.p(0, 0), cc.p(0, h.getBottomBoundary())), f = cc.pLength(e) / .2, this._bounceDir = cc.pNormalize(e), this._startBounceChildren(f)) : c ? (e = cc.pSub(cc.p(0, 0), cc.p(h.getLeftBoundary(), 0)), f = cc.pLength(e) / .2, this._bounceDir = cc.pNormalize(e), this._startBounceChildren(f)) : d && (e = cc.pSub(cc.p(g.width, 0), cc.p(h.getRightBoundary(), 0)), f = cc.pLength(e) / .2, this._bounceDir = cc.pNormalize(e), this._startBounceChildren(f)), !0
        }
        return !1
    },
    _checkBounceBoundary: function() {
        var a = this._innerContainer,
            b = a.getBottomBoundary();
        b > this._bottomBoundary ? (this._scrollToBottomEvent(), this._bottomBounceNeeded = !0) : this._bottomBounceNeeded = !1;
        var c = a.getTopBoundary();
        c < this._topBoundary ? (this._scrollToTopEvent(), this._topBounceNeeded = !0) : this._topBounceNeeded = !1;
        var d = a.getRightBoundary();
        d < this._rightBoundary ? (this._scrollToRightEvent(), this._rightBounceNeeded = !0) : this._rightBounceNeeded = !1;
        var e = a.getLeftBoundary();
        e > this._leftBoundary ? (this._scrollToLeftEvent(), this._leftBounceNeeded = !0) : this._leftBounceNeeded = !1
    },
    _startBounceChildren: function(a) {
        this._bounceOriginalSpeed = a, this._bouncing = !0
    },
    _stopBounceChildren: function() {
        this._bouncing = !1, this._bounceOriginalSpeed = 0, this._leftBounceNeeded = !1, this._rightBounceNeeded = !1, this._topBounceNeeded = !1, this._bottomBounceNeeded = !1
    },
    _startAutoScrollChildrenWithOriginalSpeed: function(a, b, c, d) {
        this._stopAutoScrollChildren(), this._autoScrollDir.x = a.x, this._autoScrollDir.y = a.y, this._isAutoScrollSpeedAttenuated = c, this._autoScrollOriginalSpeed = b, this._autoScroll = !0, this._autoScrollAcceleration = d
    },
    _startAutoScrollChildrenWithDestination: function(a, b, c) {
        this._needCheckAutoScrollDestination = !1, this._autoScrollDestination = a;
        var d = cc.pSub(a, this._innerContainer.getPosition()),
            e = cc.pNormalize(d),
            f = 0,
            g = -1e3,
            h = cc.pLength(d);
        c ? (g = -(2 * h) / (b * b), f = 2 * h / b) : (this._needCheckAutoScrollDestination = !0, f = h / b), this._startAutoScrollChildrenWithOriginalSpeed(e, f, c, g)
    },
    _jumpToDestination: function(a, b) {
        void 0 !== a.x && (b = a.y, a = a.x);
        var c = a,
            d = b;
        switch (this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
                0 >= b && (d = Math.max(b, this._contentSize.height - this._innerContainer.getContentSize().height));
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                0 >= a && (c = Math.max(a, this._contentSize.width - this._innerContainer.getContentSize().width));
                break;
            case ccui.ScrollView.DIR_BOTH:
                0 >= b && (d = Math.max(b, this._contentSize.height - this._innerContainer.getContentSize().height)), 0 >= a && (c = Math.max(a, this._contentSize.width - this._innerContainer.getContentSize().width))
        }
        this._innerContainer.setPosition(c, d)
    },
    _stopAutoScrollChildren: function() {
        this._autoScroll = !1, this._autoScrollOriginalSpeed = 0, this._autoScrollAddUpTime = 0
    },
    _bounceScrollChildren: function(a, b) {
        var c, d, e, f, g, h = !0,
            i = this._innerContainer;
        if (a > 0 && b > 0) c = a, d = b, e = i.getRightBoundary(), e + c >= this._rightBoundary && (c = this._rightBoundary - e, this._bounceRightEvent(), h = !1), f = i.getTopBoundary(), f + b >= this._topBoundary && (d = this._topBoundary - f, this._bounceTopEvent(), h = !1), this._moveChildren(c, d);
        else if (0 > a && b > 0) c = a, d = b, j = i.getLeftBoundary(), j + c <= this._leftBoundary && (c = this._leftBoundary - j, this._bounceLeftEvent(), h = !1), f = i.getTopBoundary(), f + b >= this._topBoundary && (d = this._topBoundary - f, this._bounceTopEvent(), h = !1), this._moveChildren(c, d);
        else if (0 > a && 0 > b) {
            c = a, d = b;
            var j = i.getLeftBoundary();
            j + c <= this._leftBoundary && (c = this._leftBoundary - j, this._bounceLeftEvent(), h = !1), g = i.getBottomBoundary(), g + b <= this._bottomBoundary && (d = this._bottomBoundary - g, this._bounceBottomEvent(), h = !1), this._moveChildren(c, d)
        } else if (a > 0 && 0 > b) c = a, d = b, e = i.getRightBoundary(), e + c >= this._rightBoundary && (c = this._rightBoundary - e, this._bounceRightEvent(), h = !1), g = i.getBottomBoundary(), g + b <= this._bottomBoundary && (d = this._bottomBoundary - g, this._bounceBottomEvent(), h = !1), this._moveChildren(c, d);
        else if (0 == a && b > 0) d = b, f = i.getTopBoundary(), f + b >= this._topBoundary && (d = this._topBoundary - f, this._bounceTopEvent(), h = !1), this._moveChildren(0, d);
        else if (0 == a && 0 > b) d = b, g = i.getBottomBoundary(), g + b <= this._bottomBoundary && (d = this._bottomBoundary - g, this._bounceBottomEvent(), h = !1), this._moveChildren(0, d);
        else if (a > 0 && 0 == b) c = a, e = i.getRightBoundary(), e + c >= this._rightBoundary && (c = this._rightBoundary - e, this._bounceRightEvent(), h = !1), this._moveChildren(c, 0);
        else if (0 > a && 0 == b) {
            c = a;
            var k = i.getLeftBoundary();
            k + c <= this._leftBoundary && (c = this._leftBoundary - k, this._bounceLeftEvent(), h = !1), this._moveChildren(c, 0)
        }
        return h
    },
    _checkCustomScrollDestination: function(a, b) {
        var c, d, e, f, g = !0,
            h = this._innerContainer,
            i = this._autoScrollDestination;
        switch (this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
                this._autoScrollDir.y > 0 ? (c = h.getBottomBoundary(), c + b >= i.y && (b = i.y - c, g = !1)) : (c = h.getBottomBoundary(), c + b <= i.y && (b = i.y - c, g = !1));
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                this._autoScrollDir.x > 0 ? (d = h.getLeftBoundary(), d + a >= i.x && (a = i.x - d, g = !1)) : (d = h.getLeftBoundary(), d + a <= i.x && (a = i.x - d, g = !1));
                break;
            case ccui.ScrollView.DIR_BOTH:
                a > 0 && b > 0 ? (d = h.getLeftBoundary(), d + a >= i.x && (a = i.x - d, g = !1), c = h.getBottomBoundary(), c + b >= i.y && (b = i.y - c, g = !1)) : 0 > a && b > 0 ? (e = h.getRightBoundary(), e + a <= i.x && (a = i.x - e, g = !1), c = h.getBottomBoundary(), c + b >= i.y && (b = i.y - c, g = !1)) : 0 > a && 0 > b ? (e = h.getRightBoundary(), e + a <= i.x && (a = i.x - e, g = !1), f = h.getTopBoundary(), f + b <= i.y && (b = i.y - f, g = !1)) : a > 0 && 0 > b ? (d = h.getLeftBoundary(), d + a >= i.x && (a = i.x - d, g = !1), f = h.getTopBoundary(), f + b <= i.y && (b = i.y - f, g = !1)) : 0 == a && b > 0 ? (c = h.getBottomBoundary(), c + b >= i.y && (b = i.y - c, g = !1)) : 0 > a && 0 == b ? (e = h.getRightBoundary(), e + a <= i.x && (a = i.x - e, g = !1)) : 0 == a && 0 > b ? (f = h.getTopBoundary(), f + b <= i.y && (b = i.y - f, g = !1)) : a > 0 && 0 == b && (d = h.getLeftBoundary(), d + a >= i.x && (a = i.x - d, g = !1))
        }
        return g
    },
    _scrollChildren: function(a, b) {
        var c = !0;
        switch (this._scrollingEvent(), this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
                c = this._scrollChildrenVertical(a, b);
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                c = this._scrollChildrenHorizontal(a, b);
                break;
            case ccui.ScrollView.DIR_BOTH:
                c = this._scrollChildrenBoth(a, b)
        }
        return c
    },
    _scrollChildrenVertical: function(a, b) {
        var c, d, e = b,
            f = !0,
            g = this._innerContainer;
        return this.bounceEnabled ? (c = g.getBottomBoundary(), c + b >= this._bounceBottomBoundary && (e = this._bounceBottomBoundary - c, this._scrollToBottomEvent(), f = !1), d = g.getTopBoundary(), d + b <= this._bounceTopBoundary && (e = this._bounceTopBoundary - d, this._scrollToTopEvent(), f = !1)) : (c = g.getBottomBoundary(), c + b >= this._bottomBoundary && (e = this._bottomBoundary - c, this._scrollToBottomEvent(), f = !1), d = g.getTopBoundary(), d + b <= this._topBoundary && (e = this._topBoundary - d, this._scrollToTopEvent(), f = !1)), this._moveChildren(0, e), f
    },
    _scrollChildrenHorizontal: function(a) {
        var b, c, d = !0,
            e = a,
            f = this._innerContainer;
        return this.bounceEnabled ? (b = f.getRightBoundary(), b + a <= this._bounceRightBoundary && (e = this._bounceRightBoundary - b, this._scrollToRightEvent(), d = !1), c = f.getLeftBoundary(), c + a >= this._bounceLeftBoundary && (e = this._bounceLeftBoundary - c, this._scrollToLeftEvent(), d = !1)) : (b = f.getRightBoundary(), b + a <= this._rightBoundary && (e = this._rightBoundary - b, this._scrollToRightEvent(), d = !1), c = f.getLeftBoundary(), c + a >= this._leftBoundary && (e = this._leftBoundary - c, this._scrollToLeftEvent(), d = !1)), this._moveChildren(e, 0), d
    },
    _scrollChildrenBoth: function(a, b) {
        var c, d, e, f, g = !0,
            h = a,
            i = b,
            j = this._innerContainer;
        return this.bounceEnabled ? a > 0 && b > 0 ? (c = j.getLeftBoundary(), c + a >= this._bounceLeftBoundary && (h = this._bounceLeftBoundary - c, this._scrollToLeftEvent(), g = !1), d = j.getBottomBoundary(), d + b >= this._bounceBottomBoundary && (i = this._bounceBottomBoundary - d, this._scrollToBottomEvent(), g = !1)) : 0 > a && b > 0 ? (e = j.getRightBoundary(), e + a <= this._bounceRightBoundary && (h = this._bounceRightBoundary - e, this._scrollToRightEvent(), g = !1), d = j.getBottomBoundary(), d + b >= this._bounceBottomBoundary && (i = this._bounceBottomBoundary - d, this._scrollToBottomEvent(), g = !1)) : 0 > a && 0 > b ? (e = j.getRightBoundary(), e + a <= this._bounceRightBoundary && (h = this._bounceRightBoundary - e, this._scrollToRightEvent(), g = !1), f = j.getTopBoundary(), f + b <= this._bounceTopBoundary && (i = this._bounceTopBoundary - f, this._scrollToTopEvent(), g = !1)) : a > 0 && 0 > b ? (c = j.getLeftBoundary(), c + a >= this._bounceLeftBoundary && (h = this._bounceLeftBoundary - c, this._scrollToLeftEvent(), g = !1), f = j.getTopBoundary(), f + b <= this._bounceTopBoundary && (i = this._bounceTopBoundary - f, this._scrollToTopEvent(), g = !1)) : 0 == a && b > 0 ? (d = j.getBottomBoundary(), d + b >= this._bounceBottomBoundary && (i = this._bounceBottomBoundary - d, this._scrollToBottomEvent(), g = !1)) : 0 > a && 0 == b ? (e = j.getRightBoundary(), e + a <= this._bounceRightBoundary && (h = this._bounceRightBoundary - e, this._scrollToRightEvent(), g = !1)) : 0 == a && 0 > b ? (f = j.getTopBoundary(), f + b <= this._bounceTopBoundary && (i = this._bounceTopBoundary - f, this._scrollToTopEvent(), g = !1)) : a > 0 && 0 == b && (c = j.getLeftBoundary(), c + a >= this._bounceLeftBoundary && (h = this._bounceLeftBoundary - c, this._scrollToLeftEvent(), g = !1)) : a > 0 && b > 0 ? (c = j.getLeftBoundary(), c + a >= this._leftBoundary && (h = this._leftBoundary - c, this._scrollToLeftEvent(), g = !1), d = j.getBottomBoundary(), d + b >= this._bottomBoundary && (i = this._bottomBoundary - d, this._scrollToBottomEvent(), g = !1)) : 0 > a && b > 0 ? (e = j.getRightBoundary(), e + a <= this._rightBoundary && (h = this._rightBoundary - e, this._scrollToRightEvent(), g = !1), d = j.getBottomBoundary(), d + b >= this._bottomBoundary && (i = this._bottomBoundary - d, this._scrollToBottomEvent(), g = !1)) : 0 > a && 0 > b ? (e = j.getRightBoundary(), e + a <= this._rightBoundary && (h = this._rightBoundary - e, this._scrollToRightEvent(), g = !1), f = j.getTopBoundary(), f + b <= this._topBoundary && (i = this._topBoundary - f, this._scrollToTopEvent(), g = !1)) : a > 0 && 0 > b ? (c = j.getLeftBoundary(), c + a >= this._leftBoundary && (h = this._leftBoundary - c, this._scrollToLeftEvent(), g = !1), f = this._innerContainer.getTopBoundary(), f + b <= this._topBoundary && (i = this._topBoundary - f, this._scrollToTopEvent(), g = !1)) : 0 == a && b > 0 ? (d = this._innerContainer.getBottomBoundary(), d + b >= this._bottomBoundary && (i = this._bottomBoundary - d, this._scrollToBottomEvent(), g = !1)) : 0 > a && 0 == b ? (e = this._innerContainer.getRightBoundary(), e + a <= this._rightBoundary && (h = this._rightBoundary - e, this._scrollToRightEvent(), g = !1)) : 0 == a && 0 > b ? (f = this._innerContainer.getTopBoundary(), f + b <= this._topBoundary && (i = this._topBoundary - f, this._scrollToTopEvent(), g = !1)) : a > 0 && 0 == b && (c = this._innerContainer.getLeftBoundary(), c + a >= this._leftBoundary && (h = this._leftBoundary - c, this._scrollToLeftEvent(), g = !1)), this._moveChildren(h, i), g
    },
    scrollToBottom: function(a, b) {
        this._startAutoScrollChildrenWithDestination(cc.p(this._innerContainer.getPositionX(), 0), a, b)
    },
    scrollToTop: function(a, b) {
        this._startAutoScrollChildrenWithDestination(cc.p(this._innerContainer.getPositionX(), this._contentSize.height - this._innerContainer.getContentSize().height), a, b)
    },
    scrollToLeft: function(a, b) {
        this._startAutoScrollChildrenWithDestination(cc.p(0, this._innerContainer.getPositionY()), a, b)
    },
    scrollToRight: function(a, b) {
        this._startAutoScrollChildrenWithDestination(cc.p(this._contentSize.width - this._innerContainer.getContentSize().width, this._innerContainer.getPositionY()), a, b)
    },
    scrollToTopLeft: function(a, b) {
        return this.direction != ccui.ScrollView.DIR_BOTH ? void cc.log("Scroll direction is not both!") : void this._startAutoScrollChildrenWithDestination(cc.p(0, this._contentSize.height - this._innerContainer.getContentSize().height), a, b)
    },
    scrollToTopRight: function(a, b) {
        if (this.direction != ccui.ScrollView.DIR_BOTH) return void cc.log("Scroll direction is not both!");
        var c = this._innerContainer.getContentSize();
        this._startAutoScrollChildrenWithDestination(cc.p(this._contentSize.width - c.width, this._contentSize.height - c.height), a, b)
    },
    scrollToBottomLeft: function(a, b) {
        return this.direction != ccui.ScrollView.DIR_BOTH ? void cc.log("Scroll direction is not both!") : void this._startAutoScrollChildrenWithDestination(cc.p(0, 0), a, b)
    },
    scrollToBottomRight: function(a, b) {
        return this.direction != ccui.ScrollView.DIR_BOTH ? void cc.log("Scroll direction is not both!") : void this._startAutoScrollChildrenWithDestination(cc.p(this._contentSize.width - this._innerContainer.getContentSize().width, 0), a, b)
    },
    scrollToPercentVertical: function(a, b, c) {
        var d = this._contentSize.height - this._innerContainer.getContentSize().height,
            e = -d;
        this._startAutoScrollChildrenWithDestination(cc.p(this._innerContainer.getPositionX(), d + a * e / 100), b, c)
    },
    scrollToPercentHorizontal: function(a, b, c) {
        var d = this._innerContainer.getContentSize().width - this._contentSize.width;
        this._startAutoScrollChildrenWithDestination(cc.p(-(a * d / 100), this._innerContainer.getPositionY()), b, c)
    },
    scrollToPercentBothDirection: function(a, b, c) {
        if (this.direction == ccui.ScrollView.DIR_BOTH) {
            var d = this._contentSize.height - this._innerContainer.getContentSize().height,
                e = -d,
                f = this._innerContainer.getContentSize().width - this._contentSize.width;
            this._startAutoScrollChildrenWithDestination(cc.p(-(a.x * f / 100), d + a.y * e / 100), b, c)
        }
    },
    jumpToBottom: function() {
        this._jumpToDestination(this._innerContainer.getPositionX(), 0)
    },
    jumpToTop: function() {
        this._jumpToDestination(this._innerContainer.getPositionX(), this._contentSize.height - this._innerContainer.getContentSize().height)
    },
    jumpToLeft: function() {
        this._jumpToDestination(0, this._innerContainer.getPositionY())
    },
    jumpToRight: function() {
        this._jumpToDestination(this._contentSize.width - this._innerContainer.getContentSize().width, this._innerContainer.getPositionY())
    },
    jumpToTopLeft: function() {
        return this.direction != ccui.ScrollView.DIR_BOTH ? void cc.log("Scroll direction is not both!") : void this._jumpToDestination(0, this._contentSize.height - this._innerContainer.getContentSize().height)
    },
    jumpToTopRight: function() {
        if (this.direction != ccui.ScrollView.DIR_BOTH) return void cc.log("Scroll direction is not both!");
        var a = this._innerContainer.getContentSize();
        this._jumpToDestination(this._contentSize.width - a.width, this._contentSize.height - a.height)
    },
    jumpToBottomLeft: function() {
        return this.direction != ccui.ScrollView.DIR_BOTH ? void cc.log("Scroll direction is not both!") : void this._jumpToDestination(0, 0)
    },
    jumpToBottomRight: function() {
        return this.direction != ccui.ScrollView.DIR_BOTH ? void cc.log("Scroll direction is not both!") : void this._jumpToDestination(this._contentSize.width - this._innerContainer.getContentSize().width, 0)
    },
    jumpToPercentVertical: function(a) {
        var b = this._contentSize.height - this._innerContainer.getContentSize().height,
            c = -b;
        this._jumpToDestination(this._innerContainer.getPositionX(), b + a * c / 100)
    },
    jumpToPercentHorizontal: function(a) {
        var b = this._innerContainer.getContentSize().width - this._contentSize.width;
        this._jumpToDestination(-(a * b / 100), this._innerContainer.getPositionY())
    },
    jumpToPercentBothDirection: function(a) {
        if (this.direction == ccui.ScrollView.DIR_BOTH) {
            var b = this._innerContainer.getContentSize(),
                c = this._contentSize.height - b.height,
                d = -c,
                e = b.width - this._contentSize.width;
            this._jumpToDestination(-(a.x * e / 100), c + a.y * d / 100)
        }
    },
    _startRecordSlidAction: function() {
        this._autoScroll && this._stopAutoScrollChildren(), this._bouncing && this._stopBounceChildren(), this._slidTime = 0
    },
    _endRecordSlidAction: function() {
        if (!this._checkNeedBounce() && this.inertiaScrollEnabled) {
            if (this._slidTime <= .016) return;
            var a, b = 0;
            switch (this.direction) {
                case ccui.ScrollView.DIR_VERTICAL:
                    b = this._touchEndPosition.y - this._touchBeganPosition.y, a = 0 > b ? ccui.ScrollView.SCROLLDIR_DOWN : ccui.ScrollView.SCROLLDIR_UP;
                    break;
                case ccui.ScrollView.DIR_HORIZONTAL:
                    b = this._touchEndPosition.x - this._touchBeganPosition.x, a = 0 > b ? ccui.ScrollView.SCROLLDIR_LEFT : ccui.ScrollView.SCROLLDIR_RIGHT;
                    break;
                case ccui.ScrollView.DIR_BOTH:
                    var c = cc.pSub(this._touchEndPosition, this._touchBeganPosition);
                    b = cc.pLength(c), a = cc.pNormalize(c)
            }
            var d = Math.min(Math.abs(b) / this._slidTime, ccui.ScrollView.AUTO_SCROLL_MAX_SPEED);
            this._startAutoScrollChildrenWithOriginalSpeed(a, d, !0, -1e3), this._slidTime = 0
        }
    },
    _handlePressLogic: function() {
        this._startRecordSlidAction(), this._bePressed = !0
    },
    _handleMoveLogic: function(a) {
        var b = cc.pSub(a.getLocation(), a.getPreviousLocation());
        switch (this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
                this._scrollChildren(0, b.y);
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                this._scrollChildren(b.x, 0);
                break;
            case ccui.ScrollView.DIR_BOTH:
                this._scrollChildren(b.x, b.y)
        }
    },
    _handleReleaseLogic: function() {
        this._endRecordSlidAction(), this._bePressed = !1
    },
    onTouchBegan: function(a, b) {
        var c = ccui.Layout.prototype.onTouchBegan.call(this, a, b);
        return this._isInterceptTouch || this._hit && this._handlePressLogic(a), c
    },
    onTouchMoved: function(a, b) {
        ccui.Layout.prototype.onTouchMoved.call(this, a, b), this._isInterceptTouch || this._handleMoveLogic(a)
    },
    onTouchEnded: function(a, b) {
        ccui.Layout.prototype.onTouchEnded.call(this, a, b), this._isInterceptTouch || this._handleReleaseLogic(a), this._isInterceptTouch = !1
    },
    onTouchCancelled: function(a, b) {
        ccui.Layout.prototype.onTouchCancelled.call(this, a, b), this._isInterceptTouch || this.handleReleaseLogic(a), this._isInterceptTouch = !1
    },
    update: function(a) {
        this._autoScroll && this._autoScrollChildren(a), this._bouncing && this._bounceChildren(a), this._recordSlidTime(a)
    },
    _recordSlidTime: function(a) {
        this._bePressed && (this._slidTime += a)
    },
    interceptTouchEvent: function(a, b, c) {
        var d = c.getLocation();
        switch (a) {
            case ccui.Widget.TOUCH_BEGAN:
                this._isInterceptTouch = !0, this._touchBeganPosition.x = d.x, this._touchBeganPosition.y = d.y, this._handlePressLogic(c);
                break;
            case ccui.Widget.TOUCH_MOVED:
                var e = cc.pLength(cc.pSub(b.getTouchBeganPosition(), d));
                e > this._childFocusCancelOffset && (b.setHighlighted(!1), this._touchMovePosition.x = d.x, this._touchMovePosition.y = d.y, this._handleMoveLogic(c));
                break;
            case ccui.Widget.TOUCH_CANCELED:
            case ccui.Widget.TOUCH_ENDED:
                this._touchEndPosition.x = d.x, this._touchEndPosition.y = d.y, this._handleReleaseLogic(c), b.isSwallowTouches() && (this._isInterceptTouch = !1)
        }
    },
    _scrollToTopEvent: function() {
        this._scrollViewEventSelector && (this._scrollViewEventListener ? this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_SCROLL_TO_TOP) : this._scrollViewEventSelector(this, ccui.ScrollView.EVENT_SCROLL_TO_TOP))
    },
    _scrollToBottomEvent: function() {
        this._scrollViewEventSelector && (this._scrollViewEventListener ? this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_SCROLL_TO_BOTTOM) : this._scrollViewEventSelector(this, ccui.ScrollView.EVENT_SCROLL_TO_BOTTOM))
    },
    _scrollToLeftEvent: function() {
        this._scrollViewEventSelector && (this._scrollViewEventListener ? this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_SCROLL_TO_LEFT) : this._scrollViewEventSelector(this, ccui.ScrollView.EVENT_SCROLL_TO_LEFT))
    },
    _scrollToRightEvent: function() {
        this._scrollViewEventSelector && (this._scrollViewEventListener ? this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_SCROLL_TO_RIGHT) : this._scrollViewEventSelector(this, ccui.ScrollView.EVENT_SCROLL_TO_RIGHT))
    },
    _scrollingEvent: function() {
        this._scrollViewEventSelector && (this._scrollViewEventListener ? this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_SCROLLING) : this._scrollViewEventSelector(this, ccui.ScrollView.EVENT_SCROLLING))
    },
    _bounceTopEvent: function() {
        this._scrollViewEventSelector && (this._scrollViewEventListener ? this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_BOUNCE_TOP) : this._scrollViewEventSelector(this, ccui.ScrollView.EVENT_BOUNCE_TOP))
    },
    _bounceBottomEvent: function() {
        this._scrollViewEventSelector && (this._scrollViewEventListener ? this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_BOUNCE_BOTTOM) : this._scrollViewEventSelector(this, ccui.ScrollView.EVENT_BOUNCE_BOTTOM))
    },
    _bounceLeftEvent: function() {
        this._scrollViewEventSelector && (this._scrollViewEventListener ? this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_BOUNCE_LEFT) : this._scrollViewEventSelector(this, ccui.ScrollView.EVENT_BOUNCE_LEFT))
    },
    _bounceRightEvent: function() {
        this._scrollViewEventSelector && (this._scrollViewEventListener ? this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_BOUNCE_RIGHT) : this._scrollViewEventSelector(this, ccui.ScrollView.EVENT_BOUNCE_RIGHT))
    },
    addEventListenerScrollView: function(a, b) {
        this.addEventListener(a, b)
    },
    addEventListener: function(a, b) {
        this._scrollViewEventSelector = a, this._scrollViewEventListener = b
    },
    setDirection: function(a) {
        this.direction = a
    },
    getDirection: function() {
        return this.direction
    },
    setBounceEnabled: function(a) {
        this.bounceEnabled = a
    },
    isBounceEnabled: function() {
        return this.bounceEnabled
    },
    setInertiaScrollEnabled: function(a) {
        this.inertiaScrollEnabled = a
    },
    isInertiaScrollEnabled: function() {
        return this.inertiaScrollEnabled
    },
    getInnerContainer: function() {
        return this._innerContainer
    },
    setLayoutType: function(a) {
        this._innerContainer.setLayoutType(a)
    },
    getLayoutType: function() {
        return this._innerContainer.getLayoutType()
    },
    _doLayout: function() {
        this._doLayoutDirty && (this._doLayoutDirty = !1)
    },
    getDescription: function() {
        return "ScrollView"
    },
    _createCloneInstance: function() {
        return new ccui.ScrollView
    },
    _copyClonedWidgetChildren: function(a) {
        ccui.Layout.prototype._copyClonedWidgetChildren.call(this, a)
    },
    _copySpecialProperties: function(a) {
        a instanceof ccui.ScrollView && (ccui.Layout.prototype._copySpecialProperties.call(this, a), this.setInnerContainerSize(a.getInnerContainerSize()), this.setDirection(a.direction), this.setBounceEnabled(a.bounceEnabled), this.setInertiaScrollEnabled(a.inertiaScrollEnabled), this._scrollViewEventListener = a._scrollViewEventListener, this._scrollViewEventSelector = a._scrollViewEventSelector)
    },
    getNodeByTag: function(a) {
        return this._innerContainer.getNodeByTag(a)
    },
    getNodes: function() {
        return this._innerContainer.getNodes()
    },
    removeNode: function(a) {
        this._innerContainer.removeNode(a)
    },
    removeNodeByTag: function(a) {
        this._innerContainer.removeNodeByTag(a)
    },
    removeAllNodes: function() {
        this._innerContainer.removeAllNodes()
    },
    addNode: function(a, b, c) {
        this._innerContainer.addNode(a, b, c)
    }
});
var _p = ccui.ScrollView.prototype;
_p.innerWidth, cc.defineGetterSetter(_p, "innerWidth", _p._getInnerWidth, _p._setInnerWidth), _p.innerHeight, cc.defineGetterSetter(_p, "innerHeight", _p._getInnerHeight, _p._setInnerHeight), _p = null, ccui.ScrollView.create = function() {
    return new ccui.ScrollView
}, ccui.ScrollView.DIR_NONE = 0, ccui.ScrollView.DIR_VERTICAL = 1, ccui.ScrollView.DIR_HORIZONTAL = 2, ccui.ScrollView.DIR_BOTH = 3, ccui.ScrollView.EVENT_SCROLL_TO_TOP = 0, ccui.ScrollView.EVENT_SCROLL_TO_BOTTOM = 1, ccui.ScrollView.EVENT_SCROLL_TO_LEFT = 2, ccui.ScrollView.EVENT_SCROLL_TO_RIGHT = 3, ccui.ScrollView.EVENT_SCROLLING = 4, ccui.ScrollView.EVENT_BOUNCE_TOP = 5, ccui.ScrollView.EVENT_BOUNCE_BOTTOM = 6, ccui.ScrollView.EVENT_BOUNCE_LEFT = 7, ccui.ScrollView.EVENT_BOUNCE_RIGHT = 8, ccui.ScrollView.AUTO_SCROLL_MAX_SPEED = 1e3, ccui.ScrollView.SCROLLDIR_UP = cc.p(0, 1), ccui.ScrollView.SCROLLDIR_DOWN = cc.p(0, -1), ccui.ScrollView.SCROLLDIR_LEFT = cc.p(-1, 0), ccui.ScrollView.SCROLLDIR_RIGHT = cc.p(1, 0), ccui.ListView = ccui.ScrollView.extend({
    _model: null,
    _items: null,
    _gravity: null,
    _itemsMargin: 0,
    _curSelectedIndex: 0,
    _refreshViewDirty: !0,
    _listViewEventListener: null,
    _listViewEventSelector: null,
    ctor: function() {
        ccui.ScrollView.prototype.ctor.call(this), this._items = [], this._gravity = ccui.ListView.GRAVITY_CENTER_HORIZONTAL, this.setTouchEnabled(!0), this.init()
    },
    init: function() {
        return ccui.ScrollView.prototype.init.call(this) ? (this.setLayoutType(ccui.Layout.LINEAR_VERTICAL), !0) : !1
    },
    setItemModel: function(a) {
        a && (this._model = a)
    },
    _updateInnerContainerSize: function() {
        var a, b, c = this._items;
        switch (this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
                a = c.length;
                var d = (a - 1) * this._itemsMargin;
                for (b = 0; a > b; b++) d += c[b].getContentSize().height;
                this.setInnerContainerSize(cc.size(this._contentSize.width, d));
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                a = c.length;
                var e = (a - 1) * this._itemsMargin;
                for (b = 0; a > b; b++) e += c[b].getContentSize().width;
                this.setInnerContainerSize(cc.size(e, this._contentSize.height))
        }
    },
    _remedyLayoutParameter: function(a) {
        if (a) {
            var b;
            switch (this.direction) {
                case ccui.ScrollView.DIR_VERTICAL:
                    if (b = a.getLayoutParameter()) switch (b.setMargin(0 == this.getIndex(a) ? ccui.MarginZero() : new ccui.Margin(0, this._itemsMargin, 0, 0)), this._gravity) {
                        case ccui.ListView.GRAVITY_LEFT:
                            b.setGravity(ccui.LinearLayoutParameter.LEFT);
                            break;
                        case ccui.ListView.GRAVITY_RIGHT:
                            b.setGravity(ccui.LinearLayoutParameter.RIGHT);
                            break;
                        case ccui.ListView.GRAVITY_CENTER_HORIZONTAL:
                            b.setGravity(ccui.LinearLayoutParameter.CENTER_HORIZONTAL)
                    } else {
                        var c = new ccui.LinearLayoutParameter;
                        switch (this._gravity) {
                            case ccui.ListView.GRAVITY_LEFT:
                                c.setGravity(ccui.LinearLayoutParameter.LEFT);
                                break;
                            case ccui.ListView.GRAVITY_RIGHT:
                                c.setGravity(ccui.LinearLayoutParameter.RIGHT);
                                break;
                            case ccui.ListView.GRAVITY_CENTER_HORIZONTAL:
                                c.setGravity(ccui.LinearLayoutParameter.CENTER_HORIZONTAL)
                        }
                        c.setMargin(0 == this.getIndex(a) ? ccui.MarginZero() : new ccui.Margin(0, this._itemsMargin, 0, 0)), a.setLayoutParameter(c)
                    }
                    break;
                case ccui.ScrollView.DIR_HORIZONTAL:
                    if (b = a.getLayoutParameter()) switch (b.setMargin(0 == this.getIndex(a) ? ccui.MarginZero() : new ccui.Margin(this._itemsMargin, 0, 0, 0)), this._gravity) {
                        case ccui.ListView.GRAVITY_TOP:
                            b.setGravity(ccui.LinearLayoutParameter.TOP);
                            break;
                        case ccui.ListView.GRAVITY_BOTTOM:
                            b.setGravity(ccui.LinearLayoutParameter.BOTTOM);
                            break;
                        case ccui.ListView.GRAVITY_CENTER_VERTICAL:
                            b.setGravity(ccui.LinearLayoutParameter.CENTER_VERTICAL)
                    } else {
                        var c = new ccui.LinearLayoutParameter;
                        switch (this._gravity) {
                            case ccui.ListView.GRAVITY_TOP:
                                c.setGravity(ccui.LinearLayoutParameter.TOP);
                                break;
                            case ccui.ListView.GRAVITY_BOTTOM:
                                c.setGravity(ccui.LinearLayoutParameter.BOTTOM);
                                break;
                            case ccui.ListView.GRAVITY_CENTER_VERTICAL:
                                c.setGravity(ccui.LinearLayoutParameter.CENTER_VERTICAL)
                        }
                        c.setMargin(0 == this.getIndex(a) ? ccui.MarginZero() : new ccui.Margin(this._itemsMargin, 0, 0, 0)), a.setLayoutParameter(c)
                    }
            }
        }
    },
    pushBackDefaultItem: function() {
        if (this._model) {
            var a = this._model.clone();
            this._remedyLayoutParameter(a), this.addChild(a), this._refreshViewDirty = !0
        }
    },
    insertDefaultItem: function(a) {
        if (this._model) {
            var b = this._model.clone();
            this._items.splice(a, 0, b), ccui.ScrollView.prototype.addChild.call(this, b), this._remedyLayoutParameter(b), this._refreshViewDirty = !0
        }
    },
    pushBackCustomItem: function(a) {
        this._remedyLayoutParameter(a), this.addChild(a), this._refreshViewDirty = !0
    },
    addChild: function(a, b, c) {
        a && (b = b || a.getLocalZOrder(), c = c || a.getName(), ccui.ScrollView.prototype.addChild.call(this, a, b, c), a instanceof ccui.Widget && this._items.push(a))
    },
    removeChild: function(a, b) {
        if (a) {
            var c = this._items.indexOf(a);
            c > -1 && this._items.splice(c, 1), ccui.ScrollView.prototype.removeChild.call(this, a, b)
        }
    },
    removeAllChildren: function() {
        this.removeAllChildrenWithCleanup(!0)
    },
    removeAllChildrenWithCleanup: function(a) {
        ccui.ScrollView.prototype.removeAllChildrenWithCleanup.call(this, a), this._items = []
    },
    insertCustomItem: function(a, b) {
        this._items.splice(b, 0, a), ccui.ScrollView.prototype.addChild.call(this, a), this._remedyLayoutParameter(a), this._refreshViewDirty = !0
    },
    removeItem: function(a) {
        var b = this.getItem(a);
        b && (this.removeChild(b, !0), this._refreshViewDirty = !0)
    },
    removeLastItem: function() {
        this.removeItem(this._items.length - 1)
    },
    removeAllItems: function() {
        this.removeAllChildren()
    },
    getItem: function(a) {
        return 0 > a || a >= this._items.length ? null : this._items[a]
    },
    getItems: function() {
        return this._items
    },
    getIndex: function(a) {
        return this._items.indexOf(a)
    },
    setGravity: function(a) {
        this._gravity != a && (this._gravity = a, this._refreshViewDirty = !0)
    },
    setItemsMargin: function(a) {
        this._itemsMargin != a && (this._itemsMargin = a, this._refreshViewDirty = !0)
    },
    getItemsMargin: function() {
        return this._itemsMargin
    },
    setDirection: function(a) {
        switch (a) {
            case ccui.ScrollView.DIR_VERTICAL:
                this.setLayoutType(ccui.Layout.LINEAR_VERTICAL);
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                this.setLayoutType(ccui.Layout.LINEAR_HORIZONTAL);
                break;
            case ccui.ScrollView.DIR_BOTH:
                return;
            default:
                return
        }
        ccui.ScrollView.prototype.setDirection.call(this, a)
    },
    requestRefreshView: function() {
        this._refreshViewDirty = !0
    },
    refreshView: function() {
        for (var a = this._items, b = 0; b < a.length; b++) {
            var c = a[b];
            c.setLocalZOrder(b), this._remedyLayoutParameter(c)
        }
        this._updateInnerContainerSize()
    },
    doLayout: function() {
        this._doLayout()
    },
    _doLayout: function() {
        ccui.Layout.prototype._doLayout.call(this), this._refreshViewDirty && (this.refreshView(), this._refreshViewDirty = !1)
    },
    addEventListenerListView: function(a, b) {
        this.addEventListener(a, b)
    },
    addEventListener: function(a, b) {
        this._listViewEventListener = b, this._listViewEventSelector = a
    },
    _selectedItemEvent: function(a) {
        var b = a == ccui.Widget.TOUCH_BEGAN ? ccui.ListView.ON_SELECTED_ITEM_START : ccui.ListView.ON_SELECTED_ITEM_END;
        this._listViewEventSelector && (this._listViewEventListener ? this._listViewEventSelector.call(this._listViewEventListener, this, b) : this._listViewEventSelector(this, b))
    },
    interceptTouchEvent: function(a, b, c) {
        if (ccui.ScrollView.prototype.interceptTouchEvent.call(this, a, b, c), a != ccui.Widget.TOUCH_MOVED) {
            for (var d = b; d;) {
                if (d && d.getParent() == this._innerContainer) {
                    this._curSelectedIndex = this.getIndex(d);
                    break
                }
                d = d.getParent()
            }
            b.isHighlighted() && this._selectedItemEvent(a)
        }
    },
    getCurSelectedIndex: function() {
        return this._curSelectedIndex
    },
    _onSizeChanged: function() {
        ccui.ScrollView.prototype._onSizeChanged.call(this), this._refreshViewDirty = !0
    },
    getDescription: function() {
        return "ListView"
    },
    _createCloneInstance: function() {
        return new ccui.ListView
    },
    _copyClonedWidgetChildren: function(a) {
        for (var b = a.getItems(), c = 0; c < b.length; c++) {
            var d = b[c];
            this.pushBackCustomItem(d.clone())
        }
    },
    _copySpecialProperties: function(a) {
        a instanceof ccui.ListView && (ccui.ScrollView.prototype._copySpecialProperties.call(this, a), this.setItemModel(a._model), this.setItemsMargin(a._itemsMargin), this.setGravity(a._gravity), this._listViewEventListener = a._listViewEventListener, this._listViewEventSelector = a._listViewEventSelector)
    }
}), ccui.ListView.create = function() {
    return new ccui.ListView
}, ccui.ListView.EVENT_SELECTED_ITEM = 0, ccui.ListView.ON_SELECTED_ITEM_START = 0, ccui.ListView.ON_SELECTED_ITEM_END = 1, ccui.ListView.GRAVITY_LEFT = 0, ccui.ListView.GRAVITY_RIGHT = 1, ccui.ListView.GRAVITY_CENTER_HORIZONTAL = 2, ccui.ListView.GRAVITY_TOP = 3, ccui.ListView.GRAVITY_BOTTOM = 4, ccui.ListView.GRAVITY_CENTER_VERTICAL = 5, ccui.PageView = ccui.Layout.extend({
    _curPageIdx: 0,
    _pages: null,
    _touchMoveDirection: null,
    _touchStartLocation: 0,
    _touchMoveStartLocation: 0,
    _movePagePoint: null,
    _leftBoundaryChild: null,
    _rightBoundaryChild: null,
    _leftBoundary: 0,
    _rightBoundary: 0,
    _isAutoScrolling: !1,
    _autoScrollDistance: 0,
    _autoScrollSpeed: 0,
    _autoScrollDirection: 0,
    _childFocusCancelOffset: 0,
    _pageViewEventListener: null,
    _pageViewEventSelector: null,
    _className: "PageView",
    _customScrollThreshold: 0,
    _usingCustomScrollThreshold: !1,
    ctor: function() {
        ccui.Layout.prototype.ctor.call(this), this._pages = [], this._touchMoveDirection = ccui.PageView.TOUCH_DIR_LEFT, this._movePagePoint = null, this._leftBoundaryChild = null, this._rightBoundaryChild = null, this._childFocusCancelOffset = 5, this._pageViewEventListener = null, this._pageViewEventSelector = null, this.setTouchEnabled(!0)
    },
    init: function() {
        return ccui.Layout.prototype.init.call(this) ? (this.setClippingEnabled(!0), !0) : !1
    },
    onEnter: function() {
        ccui.Layout.prototype.onEnter.call(this), this.scheduleUpdate(!0)
    },
    addWidgetToPage: function(a, b, c) {
        if (a && !(0 > b)) {
            var d = this._getPageCount();
            if (0 > b || b >= d) {
                if (c) {
                    b > d && cc.log("pageIdx is %d, it will be added as page id [%d]", b, d);
                    var e = this._createPage();
                    e.addChild(a), this.addPage(e)
                }
            } else {
                var f = this._pages[b];
                f && f.addChild(a)
            }
        }
    },
    _createPage: function() {
        var a = new ccui.Layout;
        return a.setContentSize(this.getContentSize()), a
    },
    addPage: function(a) {
        a && -1 == this._pages.indexOf(a) && (this.addChild(a), this._pages.push(a), this._doLayoutDirty = !0)
    },
    insertPage: function(a, b) {
        if (!(0 > b) && a && -1 == this._pages.indexOf(a)) {
            var c = this._getPageCount();
            b >= c ? this.addPage(a) : (this._pages[b] = a, this.addChild(a)), this._doLayoutDirty = !0
        }
    },
    removePage: function(a) {
        if (a) {
            this.removeChild(a);
            var b = this._pages.indexOf(a);
            b > -1 && this._pages.splice(b, 1), this._doLayoutDirty = !0
        }
    },
    removePageAtIndex: function(a) {
        if (!(0 > a || a >= this._pages.length)) {
            var b = this._pages[a];
            b && this.removePage(b)
        }
    },
    removeAllPages: function() {
        for (var a = this._pages, b = 0, c = a.length; c > b; b++) this.removeChild(a[b]);
        this._pages.length = 0
    },
    _updateBoundaryPages: function() {
        var a = this._pages;
        return a.length <= 0 ? (this._leftBoundaryChild = null, void(this._rightBoundaryChild = null)) : (this._leftBoundaryChild = a[0], void(this._rightBoundaryChild = a[a.length - 1]))
    },
    _getPageCount: function() {
        return this._pages.length
    },
    _getPositionXByIndex: function(a) {
        return this.getContentSize().width * (a - this._curPageIdx)
    },
    _onSizeChanged: function() {
        ccui.Layout.prototype._onSizeChanged.call(this), this._rightBoundary = this.getContentSize().width, this._doLayoutDirty = !0
    },
    _updateAllPagesSize: function() {
        for (var a = this.getContentSize(), b = this._pages, c = 0, d = b.length; d > c; c++) b[c].setContentSize(a)
    },
    _updateAllPagesPosition: function() {
        var a = this._getPageCount();
        if (0 >= a) return void(this._curPageIdx = 0);
        this._curPageIdx >= a && (this._curPageIdx = a - 1);
        for (var b = this.getContentSize().width, c = this._pages, d = 0; a > d; d++) c[d].setPosition(cc.p((d - this._curPageIdx) * b, 0))
    },
    scrollToPage: function(a) {
        if (!(0 > a || a >= this._pages.length)) {
            this._curPageIdx = a;
            var b = this._pages[a];
            this._autoScrollDistance = -b.getPosition().x, this._autoScrollSpeed = Math.abs(this._autoScrollDistance) / .2, this._autoScrollDirection = this._autoScrollDistance > 0 ? ccui.PageView.DIRECTION_RIGHT : ccui.PageView.DIRECTION_LEFT, this._isAutoScrolling = !0
        }
    },
    update: function(a) {
        this._isAutoScrolling && this._autoScroll(a)
    },
    setLayoutType: function() {},
    getLayoutType: function() {
        return ccui.Layout.ABSOLUTE
    },
    _autoScroll: function(a) {
        var b;
        switch (this._autoScrollDirection) {
            case ccui.PageView.DIRECTION_LEFT:
                b = this._autoScrollSpeed * a, this._autoScrollDistance + b >= 0 ? (b = -this._autoScrollDistance, this._autoScrollDistance = 0, this._isAutoScrolling = !1) : this._autoScrollDistance += b, this._scrollPages(-b), this._isAutoScrolling || this._pageTurningEvent();
                break;
            case ccui.PageView.DIRECTION_RIGHT:
                b = this._autoScrollSpeed * a, this._autoScrollDistance - b <= 0 ? (b = this._autoScrollDistance, this._autoScrollDistance = 0, this._isAutoScrolling = !1) : this._autoScrollDistance -= b, this._scrollPages(b), this._isAutoScrolling || this._pageTurningEvent()
        }
    },
    onTouchMoved: function(a, b) {
        ccui.Layout.prototype.onTouchMoved.call(this, a, b), this._isInterceptTouch || this._handleMoveLogic(a)
    },
    onTouchEnded: function(a, b) {
        ccui.Layout.prototype.onTouchEnded.call(this, a, b), this._isInterceptTouch || this._handleReleaseLogic(a), this._isInterceptTouch = !1
    },
    onTouchCancelled: function(a, b) {
        ccui.Layout.prototype.onTouchCancelled.call(this, a, b), this._isInterceptTouch || this._handleReleaseLogic(a), this._isInterceptTouch = !1
    },
    _doLayout: function() {
        this._doLayoutDirty && (this._updateAllPagesPosition(), this._updateAllPagesSize(), this._updateBoundaryPages(), this._doLayoutDirty = !1)
    },
    _movePages: function(a) {
        for (var b = this._pages, c = b.length, d = 0; c > d; d++) {
            var e = b[d];
            e.setPositionX(e.getPositionX() + a)
        }
    },
    _scrollPages: function(a) {
        if (this._pages.length <= 0) return !1;
        if (!this._leftBoundaryChild || !this._rightBoundaryChild) return !1;
        var b = a;
        switch (this._touchMoveDirection) {
            case ccui.PageView.TOUCH_DIR_LEFT:
                var c = this._rightBoundaryChild.getRightBoundary();
                if (c + a <= this._rightBoundary) return b = this._rightBoundary - c, this._movePages(b), !1;
                break;
            case ccui.PageView.TOUCH_DIR_RIGHT:
                var d = this._leftBoundaryChild.getLeftBoundary();
                if (d + a >= this._leftBoundary) return b = this._leftBoundary - d, this._movePages(b), !1
        }
        return this._movePages(b), !0
    },
    _handleMoveLogic: function(a) {
        var b = a.getLocation().x - a.getPreviousLocation().x;
        0 > b ? this._touchMoveDirection = ccui.PageView.TOUCH_DIR_LEFT : b > 0 && (this._touchMoveDirection = ccui.PageView.TOUCH_DIR_RIGHT), this._scrollPages(b)
    },
    setCustomScrollThreshold: function(a) {
        cc.assert(a > 0, "Invalid threshold!"), this._customScrollThreshold = a, this.setUsingCustomScrollThreshold(!0)
    },
    getCustomScrollThreshold: function() {
        return this._customScrollThreshold
    },
    setUsingCustomScrollThreshold: function(a) {
        this._usingCustomScrollThreshold = a
    },
    isUsingCustomScrollThreshold: function() {
        return this._usingCustomScrollThreshold
    },
    _handleReleaseLogic: function() {
        if (!(this._pages.length <= 0)) {
            var a = this._pages[this._curPageIdx];
            if (a) {
                var b = a.getPosition(),
                    c = this._pages.length,
                    d = b.x,
                    e = this.getSize().width;
                this._usingCustomScrollThreshold || (this._customScrollThreshold = e / 2);
                var f = this._customScrollThreshold; - f >= d ? this._curPageIdx >= c - 1 ? this._scrollPages(-d) : this.scrollToPage(this._curPageIdx + 1) : d >= f ? this._curPageIdx <= 0 ? this._scrollPages(-d) : this.scrollToPage(this._curPageIdx - 1) : this.scrollToPage(this._curPageIdx)
            }
        }
    },
    interceptTouchEvent: function(a, b, c) {
        var d = c.getLocation();
        switch (a) {
            case ccui.Widget.TOUCH_BEGAN:
                this._touchBeganPosition.x = d.x, this._touchBeganPosition.y = d.y, this._isInterceptTouch = !0;
                break;
            case ccui.Widget.TOUCH_MOVED:
                this._touchMovePosition.x = d.x, this._touchMovePosition.y = d.y;
                var e = 0;
                e = Math.abs(b.getTouchBeganPosition().x - d.x), e > this._childFocusCancelOffset && (b.setFocused(!1), this._handleMoveLogic(c));
                break;
            case ccui.Widget.TOUCH_ENDED:
            case ccui.Widget.TOUCH_CANCELED:
                this._touchEndPosition.x = d.x, this._touchEndPosition.y = d.y, this._handleReleaseLogic(c), b.isSwallowTouches() && (this._isInterceptTouch = !1)
        }
    },
    _pageTurningEvent: function() {
        this._pageViewEventSelector && (this._pageViewEventListener ? this._pageViewEventSelector.call(this._pageViewEventListener, this, ccui.PageView.EVENT_TURNING) : this._pageViewEventSelector(this, ccui.PageView.EVENT_TURNING))
    },
    addEventListenerPageView: function(a, b) {
        this.addEventListener(a, b)
    },
    addEventListener: function(a, b) {
        this._pageViewEventSelector = a, this._pageViewEventListener = b
    },
    getCurPageIndex: function() {
        return this._curPageIdx
    },
    getPages: function() {
        return this._pages
    },
    getPage: function(a) {
        return 0 > a || a >= this.getPages().size() ? null : this._pages[a]
    },
    getDescription: function() {
        return "PageView"
    },
    _createCloneInstance: function() {
        return new ccui.PageView
    },
    _copyClonedWidgetChildren: function(a) {
        for (var b = a.getPages(), c = 0; c < b.length; c++) {
            var d = b[c];
            this.addPage(d.clone())
        }
    },
    _copySpecialProperties: function(a) {
        ccui.Layout.prototype._copySpecialProperties.call(this, a), this._pageViewEventListener = a._pageViewEventListener, this._pageViewEventSelector = a._pageViewEventSelector, this._usingCustomScrollThreshold = a._usingCustomScrollThreshold, this._customScrollThreshold = a._customScrollThreshold
    }
}), ccui.PageView.create = function() {
    return new ccui.PageView
}, ccui.PageView.EVENT_TURNING = 0, ccui.PageView.TOUCH_DIR_LEFT = 0, ccui.PageView.TOUCH_DIR_RIGHT = 1, ccui.PageView.DIRECTION_LEFT = 0, ccui.PageView.DIRECTION_RIGHT = 1;
! function() {
    cc.ProtectedNode.WebGLRenderCmd = function(a) {
        cc.Node.WebGLRenderCmd.call(this, a), this._cachedParent = null, this._cacheDirty = !1
    };
    var a = cc.ProtectedNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    cc.inject(cc.ProtectedNode.RenderCmd, a), a.constructor = cc.ProtectedNode.WebGLRenderCmd, a.visit = function(a) {
        this._node.visit(a)
    }, a._visit = function(a) {
        var b = this._node;
        if (b._visible) {
            var c, d, e = cc.current_stack;
            e.stack.push(e.top), this._syncStatus(a), e.top = this._stackMatrix;
            var f = b.grid;
            f && f._active && f.beforeDraw();
            var g = b._children,
                h = b._protectedChildren,
                i = g.length,
                j = h.length;
            b.sortAllChildren(), b.sortAllProtectedChildren();
            var k;
            for (c = 0; i > c && (g[c] && g[c]._localZOrder < 0); c++) g[c].visit(this);
            for (d = 0; j > d && (k = h[d], k && k._localZOrder < 0); d++) this._changeProtectedChild(k), k.visit(this);
            for (cc.renderer.pushRenderCommand(this); i > c; c++) g[c] && g[c].visit(this);
            for (; j > d; d++) k = h[d], k && (this._changeProtectedChild(k), k.visit(this));
            f && f._active && f.afterDraw(b), this._dirtyFlag = 0, e.top = e.stack.pop()
        }
    }, a._changeProtectedChild = function(a) {
        var b = a._renderCmd,
            c = b._dirtyFlag,
            d = cc.Node._dirtyFlags;
        this._dirtyFlag & d.colorDirty && (c |= d.colorDirty), this._dirtyFlag & d.opacityDirty && (c |= d.opacityDirty);
        var e = c & d.colorDirty,
            f = c & d.opacityDirty;
        e && b._updateDisplayColor(this._displayedColor), f && b._updateDisplayOpacity(this._displayedOpacity), (e || f) && b._updateColor()
    }, a.transform = function(a, b) {
        var c = this._node,
            d = this._transform4x4,
            e = this._stackMatrix,
            f = a ? a._stackMatrix : cc.current_stack.top,
            g = c.getNodeToParentTransform();
        c._changePosition && c._changePosition(), this._dirtyFlag = this._dirtyFlag & cc.Node._dirtyFlags.transformDirty ^ this._dirtyFlag;
        var h = d.mat;
        if (h[0] = g.a, h[4] = g.c, h[12] = g.tx, h[1] = g.b, h[5] = g.d, h[13] = g.ty, h[14] = c._vertexZ, cc.kmMat4Multiply(e, f, d), null != c._camera && (null == c.grid || !c.grid.isActive())) {
            var i = this._anchorPointInPoints.x,
                j = this._anchorPointInPoints.y,
                k = 0 !== i || 0 !== j;
            if (k) {
                cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (i = 0 | i, j = 0 | j);
                var l = new cc.kmMat4;
                cc.kmMat4Translation(l, i, j, 0), cc.kmMat4Multiply(e, e, l), c._camera._locateForRenderer(e), cc.kmMat4Translation(l, -i, -j, 0), cc.kmMat4Multiply(e, e, l)
            } else c._camera._locateForRenderer(e)
        }
        var m, n, o = c._children;
        if (b && o && 0 !== o.length)
            for (m = 0, n = o.length; n > m; m++) o[m]._renderCmd.transform(this, b);
        if (o = c._protectedChildren, b && o && 0 !== o.length)
            for (m = 0, n = o.length; n > m; m++) o[m]._renderCmd.transform(this, b)
    }
}(),
function() {
    ccui.Scale9Sprite.WebGLRenderCmd = function(a) {
        cc.Node.WebGLRenderCmd.call(this, a), this._cachedParent = null, this._cacheDirty = !1
    };
    var a = ccui.Scale9Sprite.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    a.constructor = ccui.Scale9Sprite.WebGLRenderCmd, a.visit = function(a) {
        var b = this._node;
        b._visible && (b._positionsAreDirty && (b._updatePositions(), b._positionsAreDirty = !1, b._scale9Dirty = !0), cc.Node.WebGLRenderCmd.prototype.visit.call(this, a))
    }, a._updateDisplayColor = function(a) {
        cc.Node.WebGLRenderCmd.prototype._updateDisplayColor.call(this, a);
        var b = this._node._scale9Image;
        if (b)
            for (var c = b.getChildren(), d = 0; d < c.length; d++) {
                var e = c[d];
                e && (e._renderCmd._updateDisplayColor(a), e._renderCmd._updateColor())
            }
    }, a._updateDisplayOpacity = function(a) {
        cc.Node.WebGLRenderCmd.prototype._updateDisplayOpacity.call(this, a);
        var b = this._node._scale9Image;
        if (b)
            for (var c = b.getChildren(), d = 0; d < c.length; d++) {
                var e = c[d];
                e && (e._renderCmd._updateDisplayOpacity(a), e._renderCmd._updateColor())
            }
    }
}(),
function() {
    ccui.Layout.WebGLRenderCmd = function(a) {
        ccui.ProtectedNode.WebGLRenderCmd.call(this, a), this._needDraw = !1, this._currentStencilEnabled = 0, this._currentStencilWriteMask = 0, this._currentStencilFunc = 0, this._currentStencilRef = 0, this._currentStencilValueMask = 0, this._currentStencilFail = 0, this._currentStencilPassDepthFail = 0, this._currentStencilPassDepthPass = 0, this._currentDepthWriteMask = !1, this._mask_layer_le = 0, this._beforeVisitCmdStencil = new cc.CustomRenderCmd(this, this._onBeforeVisitStencil), this._afterDrawStencilCmd = new cc.CustomRenderCmd(this, this._onAfterDrawStencil), this._afterVisitCmdStencil = new cc.CustomRenderCmd(this, this._onAfterVisitStencil), this._beforeVisitCmdScissor = new cc.CustomRenderCmd(this, this._onBeforeVisitScissor), this._afterVisitCmdScissor = new cc.CustomRenderCmd(this, this._onAfterVisitScissor)
    };
    var a = ccui.Layout.WebGLRenderCmd.prototype = Object.create(ccui.ProtectedNode.WebGLRenderCmd.prototype);
    a.constructor = ccui.Layout.WebGLRenderCmd, a._onBeforeVisitStencil = function(a) {
        var b = a || cc._renderContext;
        ccui.Layout.WebGLRenderCmd._layer++;
        var c = 1 << ccui.Layout.WebGLRenderCmd._layer,
            d = c - 1;
        this._mask_layer_le = c | d, this._currentStencilEnabled = b.isEnabled(b.STENCIL_TEST), this._currentStencilWriteMask = b.getParameter(b.STENCIL_WRITEMASK), this._currentStencilFunc = b.getParameter(b.STENCIL_FUNC), this._currentStencilRef = b.getParameter(b.STENCIL_REF), this._currentStencilValueMask = b.getParameter(b.STENCIL_VALUE_MASK), this._currentStencilFail = b.getParameter(b.STENCIL_FAIL), this._currentStencilPassDepthFail = b.getParameter(b.STENCIL_PASS_DEPTH_FAIL), this._currentStencilPassDepthPass = b.getParameter(b.STENCIL_PASS_DEPTH_PASS), b.enable(b.STENCIL_TEST), b.stencilMask(c), this._currentDepthWriteMask = b.getParameter(b.DEPTH_WRITEMASK), b.depthMask(!1), b.stencilFunc(b.NEVER, c, c), b.stencilOp(b.ZERO, b.KEEP, b.KEEP), this._drawFullScreenQuadClearStencil(), b.stencilFunc(b.NEVER, c, c), b.stencilOp(b.REPLACE, b.KEEP, b.KEEP)
    }, a._onAfterDrawStencil = function(a) {
        var b = a || cc._renderContext;
        b.depthMask(this._currentDepthWriteMask), b.stencilFunc(b.EQUAL, this._mask_layer_le, this._mask_layer_le), b.stencilOp(b.KEEP, b.KEEP, b.KEEP)
    }, a._onAfterVisitStencil = function(a) {
        var b = a || cc._renderContext;
        b.stencilFunc(this._currentStencilFunc, this._currentStencilRef, this._currentStencilValueMask), b.stencilOp(this._currentStencilFail, this._currentStencilPassDepthFail, this._currentStencilPassDepthPass), b.stencilMask(this._currentStencilWriteMask), this._currentStencilEnabled || b.disable(b.STENCIL_TEST), ccui.Layout.WebGLRenderCmd._layer--
    }, a._onBeforeVisitScissor = function(a) {
        var b = this._getClippingRect(),
            c = a || cc._renderContext;
        c.enable(c.SCISSOR_TEST), cc.view.setScissorInPoints(b.x, b.y, b.width, b.height)
    }, a._onAfterVisitScissor = function(a) {
        var b = a || cc._renderContext;
        b.disable(b.SCISSOR_TEST)
    }, a._drawFullScreenQuadClearStencil = function() {
        cc.kmGLMatrixMode(cc.KM_GL_PROJECTION), cc.kmGLPushMatrix(), cc.kmGLLoadIdentity(), cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW), cc.kmGLPushMatrix(), cc.kmGLLoadIdentity(), cc._drawingUtil.drawSolidRect(cc.p(-1, -1), cc.p(1, 1), cc.color(255, 255, 255, 255)), cc.kmGLMatrixMode(cc.KM_GL_PROJECTION), cc.kmGLPopMatrix(), cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW), cc.kmGLPopMatrix()
    }, a.rebindStencilRendering = function() {}, a.transform = function(a, b) {
        var c = this._node;
        ccui.ProtectedNode.WebGLRenderCmd.prototype.transform.call(this, a, b), c._clippingStencil && c._clippingStencil._renderCmd.transform(this, b)
    }, a.stencilClippingVisit = function(a) {
        var b = this._node;
        if (b._clippingStencil && b._clippingStencil.isVisible()) {
            if (ccui.Layout.WebGLRenderCmd._layer + 1 == cc.stencilBits) return ccui.Layout.WebGLRenderCmd._visit_once = !0, ccui.Layout.WebGLRenderCmd._visit_once && (cc.log("Nesting more than " + cc.stencilBits + "stencils is not supported. Everything will be drawn without stencil for this node and its childs."), ccui.Layout.WebGLRenderCmd._visit_once = !1), void cc.Node.prototype.visit.call(b, a);
            cc.renderer.pushRenderCommand(this._beforeVisitCmdStencil);
            var c = cc.current_stack;
            c.stack.push(c.top), this._syncStatus(a), this._dirtyFlag = 0, c.top = this._stackMatrix, b._clippingStencil.visit(this), cc.renderer.pushRenderCommand(this._afterDrawStencilCmd);
            var d = 0,
                e = 0;
            b.sortAllChildren(), b.sortAllProtectedChildren();
            for (var f, g = b._children, h = b._protectedChildren, i = g.length, j = h.length; i > d && (f = g[d], f && f.getLocalZOrder() < 0); d++) f.visit(this);
            for (; j > e && (f = h[e], f && f.getLocalZOrder() < 0); e++) f.visit(this);
            for (; i > d; d++) g[d].visit(this);
            for (; j > e; e++) h[e].visit(this);
            cc.renderer.pushRenderCommand(this._afterVisitCmdStencil), c.top = c.stack.pop()
        }
    }, a.scissorClippingVisit = function(a) {
        cc.renderer.pushRenderCommand(this._beforeVisitCmdScissor), cc.ProtectedNode.prototype.visit.call(this._node, a), cc.renderer.pushRenderCommand(this._afterVisitCmdScissor)
    }, ccui.Layout.WebGLRenderCmd._layer = -1, ccui.Layout.WebGLRenderCmd._visit_once = null
}();
cc.Component = cc.Class.extend({
    _owner: null,
    _name: "",
    _enabled: !0,
    ctor: function() {
        this._owner = null, this._name = "", this._enabled = !0
    },
    init: function() {
        return !0
    },
    onEnter: function() {},
    onExit: function() {},
    update: function() {},
    serialize: function() {},
    isEnabled: function() {
        return this._enabled
    },
    setEnabled: function(a) {
        this._enabled = a
    },
    getName: function() {
        return this._name
    },
    setName: function(a) {
        this._name = a
    },
    setOwner: function(a) {
        this._owner = a
    },
    getOwner: function() {
        return this._owner
    }
}), cc.Component.create = function() {
    return new cc.Component
}, ccui.LayoutComponent_ReferencePoint = {
    BOTTOM_LEFT: 0,
    TOP_LEFT: 1,
    BOTTOM_RIGHT: 2,
    TOP_RIGHT: 3
}, ccui.LayoutComponent_PositionType = {
    Position: 0,
    RelativePosition: 1,
    PreRelativePosition: 2,
    PreRelativePositionEnable: 3
}, ccui.LayoutComponent_SizeType = {
    Size: 0,
    PreSize: 1,
    PreSizeEnable: 2
}, ccui.LayoutComponent = cc.Component.extend({
    _percentContentSize: null,
    _usingPercentContentSize: !1,
    _referencePoint: ccui.LayoutComponent_ReferencePoint.BOTTOM_LEFT,
    _relativePosition: null,
    _percentPosition: null,
    _usingPercentPosition: !1,
    _actived: !0,
    init: function() {
        var a = !0;
        do
            if (!cc.Component.prototype.init.call(this)) {
                a = !1;
                break
            }
        while (0);
        return a
    },
    isUsingPercentPosition: function() {
        return this._usingPercentPosition
    },
    setUsingPercentPosition: function(a) {
        this._usingPercentPosition = a, this.RefreshLayoutPosition(ccui.LayoutComponent_PositionType.PreRelativePositionEnable, cc.p(0, 0))
    },
    getPercentPosition: function() {
        return this._percentPosition
    },
    setPercentPosition: function(a) {
        this.RefreshLayoutPosition(ccui.LayoutComponent_PositionType.PreRelativePosition, a)
    },
    getRelativePosition: function() {
        return this._relativePosition
    },
    setRelativePosition: function(a) {
        this.RefreshLayoutPosition(ccui.LayoutComponent_PositionType.RelativePosition, a)
    },
    setReferencePoint: function(a) {
        this._referencePoint = a, this.RefreshLayoutPosition(ccui.LayoutComponent_PositionType.RelativePosition, this._relativePosition)
    },
    getReferencePoint: function() {
        return this._referencePoint
    },
    getOwnerPosition: function() {
        return this.getOwner().getPosition()
    },
    setOwnerPosition: function(a) {
        this.RefreshLayoutPosition(ccui.LayoutComponent_PositionType.Position, a)
    },
    RefreshLayoutPosition: function(a, b) {
        var c = this.getOwner().getParent(),
            d = b;
        if (null != c && this._actived) {
            var e = c.getContentSize();
            a == ccui.LayoutComponent_PositionType.PreRelativePosition ? (this._percentPosition = b, d = cc.p(this._percentPosition.x * e.width, this._percentPosition.y * e.height)) : a == ccui.LayoutComponent_PositionType.PreRelativePositionEnable && (this._usingPercentPosition && (0 != e.width ? this._percentPosition.x = this._relativePosition.x / e.width : (this._percentPosition.x = 0, this._relativePosition.x = 0), 0 != e.height ? this._percentPosition.y = this._relativePosition.y / e.height : (this._percentPosition.y = 0, this._relativePosition.y = 0)), d = this._relativePosition);
            var f = d;
            switch (this._referencePoint) {
                case ccui.LayoutComponent_ReferencePoint.TOP_LEFT:
                    f.y = e.height - f.y;
                    break;
                case ccui.LayoutComponent_ReferencePoint.BOTTOM_RIGHT:
                    f.x = e.width - f.x;
                    break;
                case ccui.LayoutComponent_ReferencePoint.TOP_RIGHT:
                    f.x = e.width - f.x, f.y = e.height - f.y
            }
            switch (a) {
                case ccui.LayoutComponent_PositionType.Position:
                    this.getOwner().setPosition(d), this._relativePosition = f, this._percentPosition = 0 != e.width && 0 != e.height ? cc.p(this._relativePosition.x / e.width, this._relativePosition.y / e.height) : cc.p(0, 0);
                    break;
                case ccui.LayoutComponent_PositionType.RelativePosition:
                    this.getOwner().setPosition(f), this._relativePosition = d, this._percentPosition = 0 != e.width && 0 != e.height ? cc.p(this._relativePosition.x / e.width, this._relativePosition.y / e.height) : cc.p(0, 0);
                    break;
                case ccui.LayoutComponent_PositionType.PreRelativePosition:
                    this.getOwner().setPosition(f), this._relativePosition = d;
                    break;
                case ccui.LayoutComponent_PositionType.PreRelativePositionEnable:
                    this.getOwner().setPosition(f), this._relativePosition = d
            }
        } else switch (a) {
            case ccui.LayoutComponent_PositionType.Position:
                this.getOwner().setPosition(d), this._referencePoint == ccui.LayoutComponent_ReferencePoint.BOTTOM_LEFT && (this._relativePosition = d);
                break;
            case ccui.LayoutComponent_PositionType.RelativePosition:
                this._relativePosition = d;
                break;
            case ccui.LayoutComponent_PositionType.PreRelativePosition:
                this._percentPosition = d
        }
    },
    getOwnerContentSize: function() {
        return this.getOwner().getContentSize()
    },
    setOwnerContentSize: function(a) {
        this.RefreshLayoutSize(ccui.LayoutComponent_SizeType.Size, a)
    },
    getPercentContentSize: function() {
        return this._percentContentSize
    },
    setPercentContentSize: function(a) {
        this.RefreshLayoutSize(ccui.LayoutComponent_SizeType.PreSize, a)
    },
    isUsingPercentContentSize: function() {
        return this._usingPercentContentSize
    },
    setUsingPercentContentSize: function(a) {
        this._usingPercentContentSize = a, this.RefreshLayoutSize(ccui.LayoutComponent_SizeType.PreSizeEnable, cc.p(0, 0))
    },
    RefreshLayoutSize: function(a, b) {
        var c = this.getOwner().getParent();
        if (null != c && this._actived) {
            var d = c.getContentSize();
            switch (a) {
                case ccui.LayoutComponent_SizeType.Size:
                    this._percentContentSize = 0 != d.width && 0 != d.height ? cc.p(b.x / d.width, b.y / d.height) : cc.p(0, 0), this.getOwner().setContentSize(cc.size(b.x, b.y));
                    break;
                case ccui.LayoutComponent_SizeType.PreSize:
                    cc.p_percentContentSize = b, this._usingPercentContentSize && this.getOwner().setContentSize(cc.size(b.x * d.width, b.y * d.height));
                    break;
                case ccui.LayoutComponent_SizeType.PreSizeEnable:
                    if (this._usingPercentContentSize) {
                        var e = this.getOwner().getContentSize();
                        0 != d.width ? this._percentContentSize.x = e.width / d.width : (this._percentContentSize.x = 0, e.width = 0), 0 != d.height ? this._percentContentSize.y = e.height / d.height : (this._percentContentSize.y = 0, e.height = 0), this.getOwner().setContentSize(e)
                    }
            }
        } else switch (a) {
            case ccui.LayoutComponent_SizeType.Size:
                this.getOwner().setContentSize(cc.size(b.x, b.y));
                break;
            case ccui.LayoutComponent_SizeType.PreSize:
                this._percentContentSize = b
        }
    },
    SetActiveEnable: function(a) {
        this._actived = a
    }
}), cc.ComponentContainer = cc.Class.extend({
    _components: null,
    _owner: null,
    ctor: function(a) {
        this._components = null, this._owner = a
    },
    getComponent: function(a) {
        if (!a) throw "cc.ComponentContainer.getComponent(): name should be non-null";
        return a = a.trim(), this._components || (this._components = {}), this._components[a]
    },
    add: function(a) {
        if (!a) throw "cc.ComponentContainer.add(): component should be non-null";
        if (a.getOwner()) return cc.log("cc.ComponentContainer.add(): Component already added. It can't be added again"), !1;
        null == this._components && (this._components = {}, this._owner.scheduleUpdate());
        var b = this._components[a.getName()];
        return b ? (cc.log("cc.ComponentContainer.add(): Component already added. It can't be added again"), !1) : (a.setOwner(this._owner), this._components[a.getName()] = a, a.onEnter(), !0)
    },
    remove: function(a) {
        if (!a) throw "cc.ComponentContainer.remove(): name should be non-null";
        return this._components ? a instanceof cc.Component ? this._removeByComponent(a) : (a = a.trim(), this._removeByComponent(this._components[a])) : !1
    },
    _removeByComponent: function(a) {
        return a ? (a.onExit(), a.setOwner(null), delete this._components[a.getName()], !0) : !1
    },
    removeAll: function() {
        if (this._components) {
            var a = this._components;
            for (var b in a) {
                var c = a[b];
                c.onExit(), c.setOwner(null), delete a[b]
            }
            this._owner.unscheduleUpdate(), this._components = null
        }
    },
    _alloc: function() {
        this._components = {}
    },
    visit: function(a) {
        if (this._components) {
            var b = this._components;
            for (var c in b) b[c].update(a)
        }
    },
    isEmpty: function() {
        return this._components ? 0 == this._components.length : !0
    }
});
var ccs = ccs || {};
ccs.Class = ccs.Class || cc.Class, ccs.Class.extend = ccs.Class.extend || cc.Class.extend, ccs.Node = ccs.Node || cc.Node, ccs.Node.extend = ccs.Node.extend || cc.Node.extend, ccs.Sprite = ccs.Sprite || cc.Sprite, ccs.Sprite.extend = ccs.Sprite.extend || cc.Sprite.extend, ccs.Component = ccs.Component || cc.Component, ccs.Component.extend = ccs.Component.extend || cc.Component.extend, ccs.cocostudioVersion = "v1.3.0.0", ccui.CSLoaderStatic = {
    ClassName_Node: "Node",
    ClassName_SubGraph: "SubGraph",
    ClassName_Sprite: "Sprite",
    ClassName_Particle: "Particle",
    ClassName_TMXTiledMap: "TMXTiledMap",
    ClassName_Panel: "Panel",
    ClassName_Button: "Button",
    ClassName_CheckBox: "CheckBox",
    ClassName_ImageView: "ImageView",
    ClassName_TextAtlas: "TextAtlas",
    ClassName_LabelAtlas: "LabelAtlas",
    ClassName_LabelBMFont: "LabelBMFont",
    ClassName_TextBMFont: "TextBMFont",
    ClassName_Text: "Text",
    ClassName_LoadingBar: "LoadingBar",
    ClassName_TextField: "TextField",
    ClassName_Slider: "Slider",
    ClassName_Layout: "Layout",
    ClassName_ScrollView: "ScrollView",
    ClassName_ListView: "ListView",
    ClassName_PageView: "PageView",
    ClassName_Widget: "Widget",
    ClassName_Label: "Label",
    ClassName_ComAudio: "ComAudio",
    NODE: "nodeTree",
    CHILDREN: "children",
    CLASSNAME: "classname",
    FILE_PATH: "fileName",
    PLIST_FILE: "plistFile",
    TMX_FILE: "tmxFile",
    TMX_STRING: "tmxString",
    RESOURCE_PATH: "resourcePath",
    COMPONENTS: "components",
    COMPONENT_TYPE: "componentType",
    COMPONENT_NAME: "componentName",
    COMPONENT_ENABLED: "componentEnabled",
    COMPONENT_AUDIO_FILE_PATH: "comAudioFilePath",
    COMPONENT_LOOP: "comAudioloop",
    TAG: "tag",
    ACTION_TAG: "actionTag",
    OPTIONS: "options",
    WIDTH: "width",
    HEIGHT: "height",
    X: "x",
    Y: "y",
    SCALE_X: "scaleX",
    SCALE_Y: "scaleY",
    SKEW_X: "skewX",
    SKEW_Y: "skewY",
    ROTATION: "rotation",
    ROTATION_SKEW_X: "rotationSkewX",
    ROTATION_SKEW_Y: "rotationSkewY",
    ANCHOR_X: "anchorPointX",
    ANCHOR_Y: "anchorPointY",
    ALPHA: "opacity",
    RED: "colorR",
    GREEN: "colorG",
    BLUE: "colorB",
    ZORDER: "ZOrder",
    PARTICLE_NUM: "particleNum",
    FLIPX: "flipX",
    FLIPY: "flipY",
    VISIBLE: "visible",
    TEXTURES: "textures",
    TEXTURES_PNG: "texturesPng",
    MONO_COCOS2D_VERSION: "cocos2dVersion"
}, ccs.csLoader = {
    _recordJsonPath: !0,
    _jsonPath: "",
    _monoCocos2dxVersion: "",
    init: function() {
        this._funcs = {}, this._componentFuncs = {}, this._funcs[ccui.CSLoaderStatic.ClassName_Node] = ccs.csLoader.loadSimpleNode.bind(this), this._funcs[ccui.CSLoaderStatic.ClassName_SubGraph] = ccs.csLoader.loadSubGraph.bind(this), this._funcs[ccui.CSLoaderStatic.ClassName_Sprite] = ccs.csLoader.loadSprite.bind(this), this._funcs[ccui.CSLoaderStatic.ClassName_Particle] = ccs.csLoader.loadParticle.bind(this), this._funcs[ccui.CSLoaderStatic.ClassName_TMXTiledMap] = ccs.csLoader.loadTMXTiledMap.bind(this), this._funcs[ccui.CSLoaderStatic.ClassName_LabelAtlas] = ccs.csLoader.loadWidget.bind(this), this._funcs[ccui.CSLoaderStatic.ClassName_LabelBMFont] = ccs.csLoader.loadWidget.bind(this), this._funcs[ccui.CSLoaderStatic.ClassName_Panel] = ccs.csLoader.loadWidget.bind(this), this._funcs[ccui.CSLoaderStatic.ClassName_Button] = ccs.csLoader.loadWidget.bind(this), this._funcs[ccui.CSLoaderStatic.ClassName_CheckBox] = ccs.csLoader.loadWidget.bind(this), this._funcs[ccui.CSLoaderStatic.ClassName_ImageView] = ccs.csLoader.loadWidget.bind(this), this._funcs[ccui.CSLoaderStatic.ClassName_TextAtlas] = ccs.csLoader.loadWidget.bind(this), this._funcs[ccui.CSLoaderStatic.ClassName_TextBMFont] = ccs.csLoader.loadWidget.bind(this), this._funcs[ccui.CSLoaderStatic.ClassName_Text] = ccs.csLoader.loadWidget.bind(this), this._funcs[ccui.CSLoaderStatic.ClassName_LoadingBar] = ccs.csLoader.loadWidget.bind(this), this._funcs[ccui.CSLoaderStatic.ClassName_TextField] = ccs.csLoader.loadWidget.bind(this), this._funcs[ccui.CSLoaderStatic.ClassName_Slider] = ccs.csLoader.loadWidget.bind(this), this._funcs[ccui.CSLoaderStatic.ClassName_Layout] = ccs.csLoader.loadWidget.bind(this), this._funcs[ccui.CSLoaderStatic.ClassName_ScrollView] = ccs.csLoader.loadWidget.bind(this), this._funcs[ccui.CSLoaderStatic.ClassName_ListView] = ccs.csLoader.loadWidget.bind(this), this._funcs[ccui.CSLoaderStatic.ClassName_PageView] = ccs.csLoader.loadWidget.bind(this), this._funcs[ccui.CSLoaderStatic.ClassName_Widget] = ccs.csLoader.loadWidget.bind(this), this._funcs[ccui.CSLoaderStatic.ClassName_Label] = ccs.csLoader.loadWidget.bind(this), this._componentFuncs[ccui.CSLoaderStatic.ClassName_ComAudio] = ccs.csLoader.loadComAudio.bind(this)
    },
    createNode: function(a) {
        var b = a,
            c = b.lastIndexOf("."),
            d = b.substr(c + 1, b.length),
            e = ccs.csLoader;
        if ("csb" == d) throw "Does not support protobuf";
        return "json" == d || "ExportJson" == d ? e.createNodeFromJson(a) : null
    },
    createTimeline: function(a) {
        var b = a,
            c = b.lastIndexOf("."),
            d = b.substr(c + 1, b.length),
            e = ccs.actionTimelineCache;
        if ("csb" == d) throw "Does not support protobuf";
        return "json" == d || "ExportJson" == d ? e.createActionFromJson(a) : null
    },
    createNodeFromJson: function(a) {
        if (this._recordJsonPath) {
            var b = a.substr(0, a.lastIndexOf("/") + 1);
            ccs.uiReader.setFilePath(b), this._jsonPath = b
        } else ccs.uiReader.setFilePath(""), this._jsonPath = "";
        return this.loadNodeWithFile(a)
    },
    loadNodeWithFile: function(a) {
        var b = cc.loader.getRes(a),
            c = this.loadNodeWithContent(b);
        return ccs.actionTimelineCache.loadAnimationActionWithContent(a, b), c
    },
    loadNodeWithContent: function(a) {
        this._monoCocos2dxVersion = a[ccui.CSLoaderStatic.MONO_COCOS2D_VERSION] || a.version;
        for (var b = a[ccui.CSLoaderStatic.TEXTURES], c = a[ccui.CSLoaderStatic.TEXTURES_PNG], d = b.length, e = 0; d > e; e++) {
            var f = b[e],
                g = c[e];
            f = this._jsonPath + f, g = this._jsonPath + g, cc.spriteFrameCache.addSpriteFrames(f, g)
        }
        var h = a[ccui.CSLoaderStatic.NODE];
        return this.loadNode(h)
    },
    setRecordJsonPath: function(a) {
        this._recordJsonPath = a
    },
    isRecordJsonPath: function() {
        return this._recordJsonPath
    },
    setJsonPath: function(a) {
        this._jsonPath = a
    },
    getJsonPath: function() {
        return this._jsonPath
    },
    loadNode: function(a) {
        var b = null,
            c = a[ccui.CSLoaderStatic.CLASSNAME],
            d = this._funcs[c];
        if (null != d) {
            var e = a[ccui.CSLoaderStatic.OPTIONS];
            if (b = d(e))
                for (var f = e[ccui.CSLoaderStatic.COMPONENTS], g = e[ccui.CSLoaderStatic.COMPONENTS] || 0, h = 0; g > h; ++h) {
                    var i = f[ccui.CSLoaderStatic.COMPONENTS][h],
                        j = this.loadComponent(i);
                    j && b.addComponent(j)
                }
        }
        if (b)
            for (var k = a[ccui.CSLoaderStatic.CHILDREN].length || 0, h = 0; k > h; h++) {
                var i = a[ccui.CSLoaderStatic.CHILDREN][h],
                    l = this.loadNode(i);
                if (l) {
                    var m = b,
                        n = b;
                    if (m instanceof ccui.PageView) {
                        var o = l;
                        o instanceof ccui.Layout && m.addPage(o)
                    } else if (n instanceof ccui.ListView) {
                        var p = l;
                        p instanceof ccui.Widget && n.pushBackCustomItem(p)
                    } else {
                        if ("3.x" != this._monoCocos2dxVersion) {
                            var p = l,
                                q = b;
                            if (p instanceof ccui.Widget && q instanceof ccui.Widget && !(q instanceof ccui.Layout))
                                if (p.getPositionType() == ccui.Widget.POSITION_PERCENT) p.setPositionPercent(cc.p(p.getPositionPercent().x + q.getAnchorPoint().x, p.getPositionPercent().y + q.getAnchorPoint().y)), p.setPosition(cc.p(p.getPositionX() + q.getAnchorPointInPoints().x, p.getPositionY() + q.getAnchorPointInPoints().y));
                                else {
                                    var r = q.getContentSize();
                                    p.setPosition(cc.p(p.getPositionX() + r.width * q.getAnchorPoint().x, p.getPositionY() + r.height * q.getAnchorPoint().y))
                                }
                        }
                        b.addChild(l)
                    }
                }
            } else cc.log("Not supported NodeType: %s", c);
        return b
    },
    locateNodeWithMulresPosition: function() {},
    initNode: function(a, b) {
        var c = null != b[ccui.CSLoaderStatic.WIDTH] ? b[ccui.CSLoaderStatic.WIDTH] : 0,
            d = null != b[ccui.CSLoaderStatic.HEIGHT] ? b[ccui.CSLoaderStatic.HEIGHT] : 0,
            e = null != b[ccui.CSLoaderStatic.X] ? b[ccui.CSLoaderStatic.X] : 0,
            f = null != b[ccui.CSLoaderStatic.Y] ? b[ccui.CSLoaderStatic.Y] : 0,
            g = null != b[ccui.CSLoaderStatic.SCALE_X] ? b[ccui.CSLoaderStatic.SCALE_X] : 1,
            h = null != b[ccui.CSLoaderStatic.SCALE_Y] ? b[ccui.CSLoaderStatic.SCALE_Y] : 1,
            i = null != b[ccui.CSLoaderStatic.ROTATION] ? b[ccui.CSLoaderStatic.ROTATION] : 0,
            j = null != b[ccui.CSLoaderStatic.ROTATION_SKEW_X] ? b[ccui.CSLoaderStatic.ROTATION_SKEW_X] : 0,
            k = null != b[ccui.CSLoaderStatic.ROTATION_SKEW_Y] ? b[ccui.CSLoaderStatic.ROTATION_SKEW_Y] : 0,
            l = null != b[ccui.CSLoaderStatic.SKEW_X] ? b[ccui.CSLoaderStatic.SKEW_X] : 0,
            m = null != b[ccui.CSLoaderStatic.SKEW_Y] ? b[ccui.CSLoaderStatic.SKEW_Y] : 0,
            n = null != b[ccui.CSLoaderStatic.ANCHOR_X] ? b[ccui.CSLoaderStatic.ANCHOR_X] : .5,
            o = null != b[ccui.CSLoaderStatic.ANCHOR_Y] ? b[ccui.CSLoaderStatic.ANCHOR_Y] : .5,
            p = null != b[ccui.CSLoaderStatic.ALPHA] ? b[ccui.CSLoaderStatic.ALPHA] : 255,
            q = null != b[ccui.CSLoaderStatic.RED] ? b[ccui.CSLoaderStatic.RED] : 255,
            r = null != b[ccui.CSLoaderStatic.GREEN] ? b[ccui.CSLoaderStatic.GREEN] : 255,
            s = null != b[ccui.CSLoaderStatic.BLUE] ? b[ccui.CSLoaderStatic.BLUE] : 255,
            t = null != b[ccui.CSLoaderStatic.ZORDER] ? b[ccui.CSLoaderStatic.ZORDER] : 0,
            u = null != b[ccui.CSLoaderStatic.TAG] ? b[ccui.CSLoaderStatic.TAG] : 0,
            v = null != b[ccui.CSLoaderStatic.ACTION_TAG] ? b[ccui.CSLoaderStatic.ACTION_TAG] : 0,
            w = null != b[ccui.CSLoaderStatic.VISIBLE] ? b[ccui.CSLoaderStatic.VISIBLE] : !0;
        (0 != e || 0 != f) && a.setPosition(cc.p(e, f)), 1 != g && a.setScaleX(g), 1 != h && a.setScaleY(h), 0 != i && a.setRotation(i), 0 != j && a.setRotationX(j), 0 != k && a.setRotationY(k), 0 != l && a.setSkewX(l), 0 != m && a.setSkewY(m), (.5 != n || .5 != o) && a.setAnchorPoint(cc.p(n, o)), (0 != c || 0 != d) && a.setContentSize(cc.size(c, d)), 0 != t && a.setLocalZOrder(t), 1 != w && a.setVisible(w), 255 != p && a.setOpacity(p), (255 != q || 255 != r || 255 != s) && a.setColor(cc.color(q, r, s)), a.setTag(u), a.setUserObject(new ccs.ActionTimelineData(v))
    },
    loadSimpleNode: function(a) {
        var b = new ccs.Node;
        return this.initNode(b, a), b
    },
    loadSubGraph: function(a) {
        var b = a[ccui.CSLoaderStatic.FILE_PATH],
            c = null;
        return c = b && "" != b ? this.createNode(b) : new ccs.Node, this.initNode(c, a), c
    },
    loadSprite: function(a) {
        var b = a[ccui.CSLoaderStatic.FILE_PATH],
            c = null;
        if (null != b) {
            var d = b,
                e = cc.spriteFrameCache.getSpriteFrame(d);
            e ? c = ccs.Sprite.createWithSpriteFrame(e) : (d = this._jsonPath + d, c = new ccs.Sprite(d)), c || (c = new cc.Sprite, cc.log("filePath is empty. Create a sprite with no texture"))
        } else c = new ccs.Sprite;
        this.initNode(c, a);
        var f = a[ccui.CSLoaderStatic.FLIPX],
            g = a[ccui.CSLoaderStatic.FLIPY];
        return 0 != f && c.setFlippedX(f), 0 != g && c.setFlippedY(g), c
    },
    loadParticle: function(a) {
        var b = a[ccui.CSLoaderStatic.PLIST_FILE],
            c = a[ccui.CSLoaderStatic.PARTICLE_NUM],
            d = new cc.ParticleSystemQuad(b);
        return d.setTotalParticles(c), this.initNode(d, a), d
    },
    loadTMXTiledMap: function(a) {
        var b = a[ccui.CSLoaderStatic.TMX_FILE],
            c = a[ccui.CSLoaderStatic.TMX_STRING],
            d = a[ccui.CSLoaderStatic.RESOURCE_PATH],
            e = null;
        return b && "" != b ? e = new cc.TMXTiledMap(b) : c && "" != c && d && "" != d && (e = new cc.TMXTiledMap(c, d)), e
    },
    loadWidget: function(a) {
        var b = a[ccui.CSLoaderStatic.CLASSNAME];
        if (null == b) return null;
        var c = b,
            d = new ccs.WidgetPropertiesReader0300,
            e = null;
        if (this.isWidget(c)) {
            var f = this.getGUIClassName(c);
            f += "Reader";
            var g = this.getGUIClassName(c);
            e = ccs.objectFactory.createObject(g);
            var h = ccs.objectFactory.createObject(f);
            d.setPropsForAllWidgetFromJsonDictionary(h, e, a)
        } else if (this.isCustomWidget(c)) {
            e = ccs.objectFactory.createObject(c);
            var f = this.getWidgetReaderClassName(e),
                h = ccs.objectFactory.createObject(f);
            if (h && e) {
                d.setPropsForAllWidgetFromJsonDictionary(h, e, a);
                var i = a.customProperty;
                d.setPropsForAllCustomWidgetFromJsonDictionary(c, e, i)
            } else cc.log("Widget or WidgetReader doesn't exists!!!  Please check your file.")
        }
        if (e) {
            var j = a[ccui.CSLoaderStatic.ROTATION_SKEW_X],
                k = a[ccui.CSLoaderStatic.ROTATION_SKEW_Y],
                l = a[ccui.CSLoaderStatic.SKEW_X],
                m = a[ccui.CSLoaderStatic.SKEW_Y];
            0 != j && e.setRotationX(j), 0 != k && e.setRotationY(k), 0 != l && e.setSkewX(l), 0 != m && e.setSkewY(m);
            var n = a[ccui.CSLoaderStatic.ACTION_TAG];
            e.setUserObject(new ccs.ActionTimelineData(n))
        }
        return e
    },
    loadComponent: function(a) {
        var b = null,
            c = a[ccui.CSLoaderStatic.COMPONENT_TYPE],
            d = this._componentFuncs[c];
        return null != d && (b = d(a)), b
    },
    loadComAudio: function(a) {
        var b = new ccs.ComAudio,
            c = a[ccui.CSLoaderStatic.COMPONENT_NAME],
            d = a[ccui.CSLoaderStatic.COMPONENT_ENABLED];
        b.setName(c), b.setEnabled(d);
        var e = a[ccui.CSLoaderStatic.COMPONENT_AUDIO_FILE_PATH],
            f = a[ccui.CSLoaderStatic.COMPONENT_LOOP];
        return b.setFile(e), b.setLoop(f), b
    },
    isWidget: function(a) {
        return a == ccui.CSLoaderStatic.ClassName_Panel || a == ccui.CSLoaderStatic.ClassName_Button || a == ccui.CSLoaderStatic.ClassName_CheckBox || a == ccui.CSLoaderStatic.ClassName_ImageView || a == ccui.CSLoaderStatic.ClassName_TextAtlas || a == ccui.CSLoaderStatic.ClassName_LabelAtlas || a == ccui.CSLoaderStatic.ClassName_LabelBMFont || a == ccui.CSLoaderStatic.ClassName_TextBMFont || a == ccui.CSLoaderStatic.ClassName_Text || a == ccui.CSLoaderStatic.ClassName_LoadingBar || a == ccui.CSLoaderStatic.ClassName_TextField || a == ccui.CSLoaderStatic.ClassName_Slider || a == ccui.CSLoaderStatic.ClassName_Layout || a == ccui.CSLoaderStatic.ClassName_ScrollView || a == ccui.CSLoaderStatic.ClassName_ListView || a == ccui.CSLoaderStatic.ClassName_PageView || a == ccui.CSLoaderStatic.ClassName_Widget || a == ccui.CSLoaderStatic.ClassName_Label
    },
    isCustomWidget: function(a) {
        var b = ccs.objectFactory.createObject(a);
        return b ? !0 : !1
    },
    getGUIClassName: function(a) {
        var b = a;
        return "Panel" == a ? b = "Layout" : "TextArea" == a ? b = "Text" : "TextButton" == a ? b = "Button" : "Label" == a ? b = "Text" : "LabelAtlas" == a ? b = "TextAtlas" : "LabelBMFont" == a && (b = "TextBMFont"), b
    },
    getWidgetReaderClassName: function(a) {
        var b;
        return a instanceof ccui.Button ? b = "ButtonReader" : a instanceof ccui.CheckBox ? b = "CheckBoxReader" : a instanceof ccui.ImageView ? b = "ImageViewReader" : a instanceof ccui.TextAtlas ? b = "TextAtlasReader" : a instanceof ccui.TextBMFont ? b = "TextBMFontReader" : a instanceof ccui.Text ? b = "TextReader" : a instanceof ccui.LoadingBar ? b = "LoadingBarReader" : a instanceof ccui.Slider ? b = "SliderReader" : a instanceof ccui.TextField ? b = "TextFieldReader" : a instanceof ccui.ListView ? b = "ListViewReader" : a instanceof ccui.PageView ? b = "PageViewReader" : a instanceof ccui.ScrollView ? b = "ScrollViewReader" : a instanceof ccui.Layout ? b = "LayoutReader" : a instanceof ccui.Widget && (b = "WidgetReader"), b
    }
}, ccs.csLoader.init(), ccs.VERSION_COMBINED = .3, ccs.VERSION_CHANGE_ROTATION_RANGE = 1, ccs.VERSION_COLOR_READING = 1.1, ccs.MAX_VERTEXZ_VALUE = 5e6, ccs.ARMATURE_MAX_CHILD = 50, ccs.ARMATURE_MAX_ZORDER = 100, ccs.ARMATURE_MAX_COUNT = ccs.MAX_VERTEXZ_VALUE / ccs.ARMATURE_MAX_CHILD / ccs.ARMATURE_MAX_ZORDER, ccs.AUTO_ADD_SPRITE_FRAME_NAME_PREFIX = !1, ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT = !1, ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX = !1, ccs.armatureVersion = function() {
    return "v1.1.0.0"
}, ccs.CONST_VERSION = "version", ccs.CONST_VERSION_2_0 = 2, ccs.CONST_VERSION_COMBINED = .3, ccs.CONST_ARMATURES = "armatures", ccs.CONST_ARMATURE = "armature", ccs.CONST_BONE = "b", ccs.CONST_DISPLAY = "d", ccs.CONST_ANIMATIONS = "animations", ccs.CONST_ANIMATION = "animation", ccs.CONST_MOVEMENT = "mov", ccs.CONST_FRAME = "f", ccs.CONST_TEXTURE_ATLAS = "TextureAtlas", ccs.CONST_SUB_TEXTURE = "SubTexture", ccs.CONST_SKELETON = "skeleton", ccs.CONST_A_NAME = "name", ccs.CONST_A_DURATION = "dr", ccs.CONST_A_FRAME_INDEX = "fi", ccs.CONST_A_DURATION_TO = "to", ccs.CONST_A_DURATION_TWEEN = "drTW", ccs.CONST_A_LOOP = "lp", ccs.CONST_A_MOVEMENT_SCALE = "sc", ccs.CONST_A_MOVEMENT_DELAY = "dl", ccs.CONST_A_DISPLAY_INDEX = "dI", ccs.CONST_A_PLIST = "plist", ccs.CONST_A_PARENT = "parent", ccs.CONST_A_SKEW_X = "kX", ccs.CONST_A_SKEW_Y = "kY", ccs.CONST_A_SCALE_X = "cX", ccs.CONST_A_SCALE_Y = "cY", ccs.CONST_A_Z = "z", ccs.CONST_A_EVENT = "evt", ccs.CONST_A_SOUND = "sd", ccs.CONST_A_SOUND_EFFECT = "sdE", ccs.CONST_A_TWEEN_EASING = "twE", ccs.CONST_A_EASING_PARAM = "twEP", ccs.CONST_A_TWEEN_ROTATE = "twR", ccs.CONST_A_IS_ARMATURE = "isArmature", ccs.CONST_A_DISPLAY_TYPE = "displayType", ccs.CONST_A_MOVEMENT = "mov", ccs.CONST_A_X = "x", ccs.CONST_A_Y = "y", ccs.CONST_A_COCOS2DX_X = "cocos2d_x", ccs.CONST_A_COCOS2DX_Y = "cocos2d_y", ccs.CONST_A_WIDTH = "width", ccs.CONST_A_HEIGHT = "height", ccs.CONST_A_PIVOT_X = "pX", ccs.CONST_A_PIVOT_Y = "pY", ccs.CONST_A_COCOS2D_PIVOT_X = "cocos2d_pX", ccs.CONST_A_COCOS2D_PIVOT_Y = "cocos2d_pY", ccs.CONST_A_BLEND_TYPE = "bd", ccs.CONST_A_BLEND_SRC = "bd_src", ccs.CONST_A_BLEND_DST = "bd_dst", ccs.CONST_A_ALPHA = "a", ccs.CONST_A_RED = "r", ccs.CONST_A_GREEN = "g", ccs.CONST_A_BLUE = "b", ccs.CONST_A_ALPHA_OFFSET = "aM", ccs.CONST_A_RED_OFFSET = "rM", ccs.CONST_A_GREEN_OFFSET = "gM", ccs.CONST_A_BLUE_OFFSET = "bM", ccs.CONST_A_COLOR_TRANSFORM = "colorTransform", ccs.CONST_A_TWEEN_FRAME = "tweenFrame", ccs.CONST_CONTOUR = "con", ccs.CONST_CONTOUR_VERTEX = "con_vt", ccs.CONST_FL_NAN = "NaN", ccs.CONST_FRAME_DATA = "frame_data", ccs.CONST_MOVEMENT_BONE_DATA = "mov_bone_data", ccs.CONST_MOVEMENT_DATA = "mov_data", ccs.CONST_ANIMATION_DATA = "animation_data", ccs.CONST_DISPLAY_DATA = "display_data", ccs.CONST_SKIN_DATA = "skin_data", ccs.CONST_BONE_DATA = "bone_data", ccs.CONST_ARMATURE_DATA = "armature_data", ccs.CONST_CONTOUR_DATA = "contour_data", ccs.CONST_TEXTURE_DATA = "texture_data", ccs.CONST_VERTEX_POINT = "vertex", ccs.CONST_COLOR_INFO = "color", ccs.CONST_CONFIG_FILE_PATH = "config_file_path", ccs.CONST_CONTENT_SCALE = "content_scale", ccs.DataInfo = function() {
    this.asyncStruct = null, this.configFileQueue = [], this.contentScale = 1, this.filename = "", this.baseFilePath = "", this.flashToolVersion = 0, this.cocoStudioVersion = 0
}, ccs.dataReaderHelper = {
    ConfigType: {
        DragonBone_XML: 0,
        CocoStudio_JSON: 1,
        CocoStudio_Binary: 2
    },
    _configFileList: [],
    _flashToolVersion: ccs.CONST_VERSION_2_0,
    _positionReadScale: 1,
    _asyncRefCount: 0,
    _asyncRefTotalCount: 0,
    _dataQueue: null,
    setPositionReadScale: function(a) {
        this._positionReadScale = a
    },
    getPositionReadScale: function() {
        return this._positionReadScale
    },
    addDataFromFile: function(a) {
        if (-1 == this._configFileList.indexOf(a)) {
            this._configFileList.push(a);
            var b = this._initBaseFilePath(a),
                c = cc.path.extname(a).toLowerCase(),
                d = new ccs.DataInfo;
            d.filename = a, d.basefilePath = b, ".xml" == c ? ccs.dataReaderHelper.addDataFromXML(a, d) : ".json" == c || ".exportjson" == c ? ccs.dataReaderHelper.addDataFromJson(a, d) : ".csb" == c && ccs.dataReaderHelper.addDataFromBinaryCache(a, d)
        }
    },
    addDataFromFileAsync: function(a, b, c, d, e) {
        if (-1 != this._configFileList.indexOf(c)) return void(e && d && (0 == this._asyncRefTotalCount && 0 == this._asyncRefCount ? this._asyncCallBack(d, e, 1) : this._asyncCallBack(d, e, (this._asyncRefTotalCount - this._asyncRefCount) / this._asyncRefTotalCount)));
        this._asyncRefTotalCount++, this._asyncRefCount++;
        var f = this,
            g = function() {
                f.addDataFromFile(c), f._asyncRefCount--, f._asyncCallBack(d, e, (f._asyncRefTotalCount - f._asyncRefCount) / f._asyncRefTotalCount)
            };
        cc.director.getScheduler().scheduleCallbackForTarget(this, g, .1, !1)
    },
    removeConfigFile: function(a) {
        for (var b = this._configFileList, c = b.length, d = b[c], e = 0; c > e; e++) b[e] == a && (d = e);
        d != b[c] && cc.arrayRemoveObject(b, a)
    },
    addDataFromCache: function(a, b) {
        if (!a) return void cc.log("XML error  or  XML is empty.");
        b.flashToolVersion = parseFloat(a.getAttribute(ccs.CONST_VERSION));
        var c, d = a.querySelectorAll(ccs.CONST_SKELETON + " > " + ccs.CONST_ARMATURES + " >  " + ccs.CONST_ARMATURE),
            e = ccs.armatureDataManager;
        for (c = 0; c < d.length; c++) {
            var f = this.decodeArmature(d[c], b);
            e.addArmatureData(f.name, f, b.filename)
        }
        var g = a.querySelectorAll(ccs.CONST_SKELETON + " > " + ccs.CONST_ANIMATIONS + " >  " + ccs.CONST_ANIMATION);
        for (c = 0; c < g.length; c++) {
            var h = this.decodeAnimation(g[c], b);
            e.addAnimationData(h.name, h, b.filename)
        }
        var i = a.querySelectorAll(ccs.CONST_SKELETON + " > " + ccs.CONST_TEXTURE_ATLAS + " >  " + ccs.CONST_SUB_TEXTURE);
        for (c = 0; c < i.length; c++) {
            var j = this.decodeTexture(i[c], b);
            e.addTextureData(j.name, j, b.filename)
        }
    },
    decodeArmature: function(a, b) {
        var c = new ccs.ArmatureData;
        c.init(), c.name = a.getAttribute(ccs.CONST_A_NAME);
        for (var d = a.querySelectorAll(ccs.CONST_ARMATURE + " > " + ccs.CONST_BONE), e = 0; e < d.length; e++) {
            var f = d[e],
                g = f.getAttribute(ccs.CONST_A_PARENT),
                h = null;
            if (g)
                for (var i = 0; i < d.length && (h = d[i], g != d[i].getAttribute(ccs.CONST_A_NAME)); i++);
            var j = this.decodeBone(f, h, b);
            c.addBoneData(j)
        }
        return c
    },
    decodeArmatureFromJSON: function(a, b) {
        var c = new ccs.ArmatureData;
        c.init();
        var d = a[ccs.CONST_A_NAME];
        d && (c.name = d), b.cocoStudioVersion = c.dataVersion = a[ccs.CONST_VERSION] || .1;
        for (var e = a[ccs.CONST_BONE_DATA], f = 0; f < e.length; f++) {
            var g = this.decodeBoneFromJson(e[f], b);
            c.addBoneData(g)
        }
        return c
    },
    decodeBone: function(a, b, c) {
        var d = new ccs.BoneData;
        d.init(), d.name = a.getAttribute(ccs.CONST_A_NAME), d.parentName = a.getAttribute(ccs.CONST_A_PARENT) || "", d.zOrder = parseInt(a.getAttribute(ccs.CONST_A_Z)) || 0;
        for (var e = a.querySelectorAll(ccs.CONST_BONE + " > " + ccs.CONST_DISPLAY), f = 0; f < e.length; f++) {
            var g = e[f],
                h = this.decodeBoneDisplay(g, c);
            d.addDisplayData(h)
        }
        return d
    },
    decodeBoneFromJson: function(a, b) {
        var c = new ccs.BoneData;
        c.init(), this.decodeNodeFromJson(c, a, b), c.name = a[ccs.CONST_A_NAME] || "", c.parentName = a[ccs.CONST_A_PARENT] || "";
        for (var d = a[ccs.CONST_DISPLAY_DATA] || [], e = 0; e < d.length; e++) {
            var f = this.decodeBoneDisplayFromJson(d[e], b);
            c.addDisplayData(f)
        }
        return c
    },
    decodeBoneDisplay: function(a) {
        var b = parseFloat(a.getAttribute(ccs.CONST_A_IS_ARMATURE)) || 0,
            c = null;
        1 == b ? (c = new ccs.ArmatureDisplayData, c.displayType = ccs.DISPLAY_TYPE_ARMATURE) : (c = new ccs.SpriteDisplayData, c.displayType = ccs.DISPLAY_TYPE_SPRITE);
        var d = a.getAttribute(ccs.CONST_A_NAME) || "";
        return d && (c.displayName = d), c
    },
    decodeBoneDisplayFromJson: function(a, b) {
        var c = a[ccs.CONST_A_DISPLAY_TYPE] || ccs.DISPLAY_TYPE_SPRITE,
            d = null;
        switch (c) {
            case ccs.DISPLAY_TYPE_SPRITE:
                d = new ccs.SpriteDisplayData;
                var e = a[ccs.CONST_A_NAME];
                null != e && (d.displayName = e);
                var f = a[ccs.CONST_SKIN_DATA] || [],
                    g = f[0];
                if (g) {
                    var h = d.skinData;
                    h.x = g[ccs.CONST_A_X] * this._positionReadScale, h.y = g[ccs.CONST_A_Y] * this._positionReadScale, h.scaleX = null == g[ccs.CONST_A_SCALE_X] ? 1 : g[ccs.CONST_A_SCALE_X], h.scaleY = null == g[ccs.CONST_A_SCALE_Y] ? 1 : g[ccs.CONST_A_SCALE_Y], h.skewX = null == g[ccs.CONST_A_SKEW_X] ? 1 : g[ccs.CONST_A_SKEW_X], h.skewY = null == g[ccs.CONST_A_SKEW_Y] ? 1 : g[ccs.CONST_A_SKEW_Y], h.x *= b.contentScale, h.y *= b.contentScale
                }
                break;
            case ccs.DISPLAY_TYPE_ARMATURE:
                d = new ccs.ArmatureDisplayData;
                var e = a[ccs.CONST_A_NAME];
                null != e && (d.displayName = a[ccs.CONST_A_NAME]);
                break;
            case ccs.DISPLAY_TYPE_PARTICLE:
                d = new ccs.ParticleDisplayData;
                var i = a[ccs.CONST_A_PLIST];
                null != i && (d.displayName = b.asyncStruct ? b.asyncStruct.basefilePath + i : b.basefilePath + i);
                break;
            default:
                d = new ccs.SpriteDisplayData
        }
        return d.displayType = c, d
    },
    decodeAnimation: function(a, b) {
        var c = new ccs.AnimationData,
            d = a.getAttribute(ccs.CONST_A_NAME),
            e = ccs.armatureDataManager.getArmatureData(d);
        c.name = d;
        for (var f = a.querySelectorAll(ccs.CONST_ANIMATION + " > " + ccs.CONST_MOVEMENT), g = null, h = 0; h < f.length; h++) {
            g = f[h];
            var i = this.decodeMovement(g, e, b);
            c.addMovement(i)
        }
        return c
    },
    decodeAnimationFromJson: function(a, b) {
        var c = new ccs.AnimationData,
            d = a[ccs.CONST_A_NAME];
        d && (c.name = a[ccs.CONST_A_NAME]);
        for (var e = a[ccs.CONST_MOVEMENT_DATA] || [], f = 0; f < e.length; f++) {
            var g = this.decodeMovementFromJson(e[f], b);
            c.addMovement(g)
        }
        return c
    },
    decodeMovement: function(a, b, c) {
        var d = new ccs.MovementData;
        d.name = a.getAttribute(ccs.CONST_A_NAME);
        var e, f, g, h, i = 0;
        e = a.getAttribute(ccs.CONST_A_DURATION), d.duration = null == e ? 0 : parseFloat(e), f = a.getAttribute(ccs.CONST_A_DURATION_TO), d.durationTo = null == f ? 0 : parseFloat(f), g = a.getAttribute(ccs.CONST_A_DURATION_TWEEN), d.durationTween = null == g ? 0 : parseFloat(g), h = a.getAttribute(ccs.CONST_A_LOOP), d.loop = h ? Boolean(parseFloat(h)) : !0;
        var j = a.getAttribute(ccs.CONST_A_TWEEN_EASING);
        j && (j != ccs.CONST_FL_NAN ? (i = null == j ? 0 : parseFloat(j), d.tweenEasing = 2 == i ? ccs.TweenType.sineEaseInOut : i) : d.tweenEasing = ccs.TweenType.linear);
        for (var k = a.querySelectorAll(ccs.CONST_MOVEMENT + " > " + ccs.CONST_BONE), l = null, m = 0; m < k.length; m++) {
            l = k[m];
            var n = l.getAttribute(ccs.CONST_A_NAME);
            if (!d.getMovementBoneData(n)) {
                var o = b.getBoneData(n),
                    p = o.parentName,
                    q = null;
                if ("" != p)
                    for (var r = 0; r < k.length && (q = k[r], p != q.getAttribute(ccs.CONST_A_NAME)); r++);
                var s = this.decodeMovementBone(l, q, o, c);
                d.addMovementBoneData(s)
            }
        }
        return d
    },
    decodeMovementFromJson: function(a, b) {
        var c = new ccs.MovementData;
        c.loop = null == a[ccs.CONST_A_LOOP] ? !1 : a[ccs.CONST_A_LOOP], c.durationTween = a[ccs.CONST_A_DURATION_TWEEN] || 0, c.durationTo = a[ccs.CONST_A_DURATION_TO] || 0, c.duration = a[ccs.CONST_A_DURATION] || 0, c.scale = null == a[ccs.CONST_A_DURATION] ? 1 : null == a[ccs.CONST_A_MOVEMENT_SCALE] ? 1 : a[ccs.CONST_A_MOVEMENT_SCALE], c.tweenEasing = null == a[ccs.CONST_A_TWEEN_EASING] ? ccs.TweenType.linear : a[ccs.CONST_A_TWEEN_EASING];
        var d = a[ccs.CONST_A_NAME];
        d && (c.name = d);
        for (var e = a[ccs.CONST_MOVEMENT_BONE_DATA] || [], f = 0; f < e.length; f++) {
            var g = this.decodeMovementBoneFromJson(e[f], b);
            c.addMovementBoneData(g)
        }
        return c
    },
    decodeMovementBone: function(a, b, c, d) {
        var e = new ccs.MovementBoneData;
        e.init();
        var f, g;
        a && (f = parseFloat(a.getAttribute(ccs.CONST_A_MOVEMENT_SCALE)) || 0, e.scale = f, g = parseFloat(a.getAttribute(ccs.CONST_A_MOVEMENT_DELAY)) || 0, g > 0 && (g -= 1), e.delay = g);
        var h = 0,
            i = 0,
            j = 0,
            k = null,
            l = [];
        if (null != b) {
            for (var m = b.querySelectorAll(ccs.CONST_BONE + " > " + ccs.CONST_FRAME), n = 0; n < m.length; n++) l.push(m[n]);
            h = l.length
        }
        e.name = a.getAttribute(ccs.CONST_A_NAME);
        for (var o = a.querySelectorAll(ccs.CONST_BONE + " > " + ccs.CONST_FRAME), p = 0, q = 0, r = 0; r < o.length; r++) {
            var s = o[r];
            if (b)
                for (; h > p && (k ? i > q || q >= i + j : !0);) k = l[p], i += j, j = parseFloat(k.getAttribute(ccs.CONST_A_DURATION)), p++;
            var t = this.decodeFrame(s, k, c, d);
            e.addFrameData(t), t.frameID = q, q += t.duration, e.duration = q
        }
        for (var u = e.frameList, v = Math.PI, n = u.length - 1; n >= 0; n--)
            if (n > 0) {
                var w = u[n].skewX - u[n - 1].skewX,
                    x = u[n].skewY - u[n - 1].skewY;
                (-v > w || w > v) && (u[n - 1].skewX = 0 > w ? u[n - 1].skewX - 2 * v : u[n - 1].skewX + 2 * v), (-v > x || x > v) && (u[n - 1].skewY = 0 > x ? u[n - 1].skewY - 2 * v : u[n - 1].skewY + 2 * v)
            }
        var y = new ccs.FrameData;
        return y.copy(e.frameList[e.frameList.length - 1]), y.frameID = e.duration, e.addFrameData(y), e
    },
    decodeMovementBoneFromJson: function(a, b) {
        var c = new ccs.MovementBoneData;
        c.init(), c.delay = a[ccs.CONST_A_MOVEMENT_DELAY] || 0;
        var d = a[ccs.CONST_A_NAME];
        d && (c.name = d);
        for (var e = a[ccs.CONST_FRAME_DATA] || [], f = e.length, g = 0; f > g; g++) {
            var h = a[ccs.CONST_FRAME_DATA][g],
                i = this.decodeFrameFromJson(h, b);
            c.addFrameData(i), b.cocoStudioVersion < ccs.CONST_VERSION_COMBINED && (i.frameID = c.duration, c.duration += i.duration)
        }
        if (b.cocoStudioVersion < ccs.VERSION_CHANGE_ROTATION_RANGE)
            for (var j = c.frameList, k = Math.PI, g = j.length - 1; g >= 0; g--)
                if (g > 0) {
                    var l = j[g].skewX - j[g - 1].skewX,
                        m = j[g].skewY - j[g - 1].skewY;
                    (-k > l || l > k) && (j[g - 1].skewX = 0 > l ? j[g - 1].skewX - 2 * k : j[g - 1].skewX + 2 * k), (-k > m || m > k) && (j[g - 1].skewY = 0 > m ? j[g - 1].skewY - 2 * k : j[g - 1].skewY + 2 * k)
                }
        if (b.cocoStudioVersion < ccs.CONST_VERSION_COMBINED && c.frameList.length > 0) {
            var i = new ccs.FrameData;
            i.copy(c.frameList[c.frameList.length - 1]), c.addFrameData(i), i.frameID = c.duration
        }
        return c
    },
    decodeFrame: function(a, b, c, d) {
        var e = 0,
            f = 0,
            g = 0,
            h = 0,
            i = 0,
            j = 0,
            k = 0,
            l = 0,
            m = 0,
            n = 0,
            o = 0,
            p = 0,
            q = new ccs.FrameData;
        q.strMovement = a.getAttribute(ccs.CONST_A_MOVEMENT) || "", q.movement = q.strMovement, q.strEvent = a.getAttribute(ccs.CONST_A_EVENT) || "", q.event = q.strEvent, q.strSound = a.getAttribute(ccs.CONST_A_SOUND) || "", q.sound = q.strSound, q.strSoundEffect = a.getAttribute(ccs.CONST_A_SOUND_EFFECT) || "", q.soundEffect = q.strSoundEffect;
        var r = a.getAttribute(ccs.CONST_A_TWEEN_FRAME);
        if (q.isTween = !(void 0 != r && "false" == r), d.flashToolVersion >= ccs.CONST_VERSION_2_0 ? (e = a.getAttribute(ccs.CONST_A_COCOS2DX_X), e && (q.x = parseFloat(e), q.x *= this._positionReadScale), f = a.getAttribute(ccs.CONST_A_COCOS2DX_Y), f && (q.y = -parseFloat(f), q.y *= this._positionReadScale)) : (e = a.getAttribute(ccs.CONST_A_X), e && (q.x = parseFloat(e), q.x *= this._positionReadScale), f = a.getAttribute(ccs.CONST_A_Y), f && (q.y = -parseFloat(f), q.y *= this._positionReadScale)), g = a.getAttribute(ccs.CONST_A_SCALE_X), null != g && (q.scaleX = parseFloat(g)), h = a.getAttribute(ccs.CONST_A_SCALE_Y), null != h && (q.scaleY = parseFloat(h)), i = a.getAttribute(ccs.CONST_A_SKEW_X), null != i && (q.skewX = cc.degreesToRadians(parseFloat(i))), j = a.getAttribute(ccs.CONST_A_SKEW_Y), null != j && (q.skewY = cc.degreesToRadians(-parseFloat(j))), l = a.getAttribute(ccs.CONST_A_DURATION), null != l && (q.duration = parseFloat(l)), m = a.getAttribute(ccs.CONST_A_DISPLAY_INDEX), null != m && (q.displayIndex = parseFloat(m)), n = a.getAttribute(ccs.CONST_A_Z), null != n && (q.zOrder = parseInt(n)), k = a.getAttribute(ccs.CONST_A_TWEEN_ROTATE), null != k && (q.tweenRotate = parseFloat(k)), p = a.getAttribute(ccs.CONST_A_BLEND_TYPE), null != p) {
            var s = q.blendFunc;
            switch (p) {
                case ccs.BLEND_TYPE_NORMAL:
                    s.src = cc.BLEND_SRC, s.dst = cc.BLEND_DST;
                    break;
                case ccs.BLEND_TYPE_ADD:
                    s.src = cc.SRC_ALPHA, s.dst = cc.ONE;
                    break;
                case ccs.BLEND_TYPE_MULTIPLY:
                    s.src = cc.DST_COLOR, s.dst = cc.ONE_MINUS_SRC_ALPHA;
                    break;
                case ccs.BLEND_TYPE_SCREEN:
                    s.src = cc.ONE, s.dst = cc.ONE_MINUS_DST_COLOR;
                    break;
                default:
                    q.blendFunc.src = cc.BLEND_SRC, q.blendFunc.dst = cc.BLEND_DST
            }
        }
        var t = a.querySelectorAll(ccs.CONST_FRAME + " > " + ccs.CONST_A_COLOR_TRANSFORM);
        if (t && t.length > 0) {
            t = t[0];
            var u, v, w, x, y, z, A, B;
            u = parseFloat(t.getAttribute(ccs.CONST_A_ALPHA)) || 0, v = parseFloat(t.getAttribute(ccs.CONST_A_RED)) || 0, w = parseFloat(t.getAttribute(ccs.CONST_A_GREEN)) || 0, x = parseFloat(t.getAttribute(ccs.CONST_A_BLUE)) || 0, y = parseFloat(t.getAttribute(ccs.CONST_A_ALPHA_OFFSET)) || 0, z = parseFloat(t.getAttribute(ccs.CONST_A_RED_OFFSET)) || 0, A = parseFloat(t.getAttribute(ccs.CONST_A_GREEN_OFFSET)) || 0, B = parseFloat(t.getAttribute(ccs.CONST_A_BLUE_OFFSET)) || 0, q.a = 2.55 * y + u, q.r = 2.55 * z + v, q.g = 2.55 * A + w, q.b = 2.55 * B + x, q.isUseColorInfo = !0
        }
        var C = a.getAttribute(ccs.CONST_A_TWEEN_EASING);
        if (null != C && (C != ccs.CONST_FL_NAN ? (o = a.getAttribute(ccs.CONST_A_TWEEN_EASING), o && (q.tweenEasing = 2 == o ? ccs.TweenType.sineEaseInOut : o)) : q.tweenEasing = ccs.TweenType.linear), b) {
            var D = new ccs.BaseData;
            d.flashToolVersion >= ccs.CONST_VERSION_2_0 ? (D.x = parseFloat(b.getAttribute(ccs.CONST_A_COCOS2DX_X)), D.y = parseFloat(b.getAttribute(ccs.CONST_A_COCOS2DX_Y))) : (D.x = parseFloat(b.getAttribute(ccs.CONST_A_X)), D.y = parseFloat(b.getAttribute(ccs.CONST_A_Y))), D.skewX = parseFloat(b.getAttribute(ccs.CONST_A_SKEW_X)), D.skewY = parseFloat(b.getAttribute(ccs.CONST_A_SKEW_Y)), D.y = -D.y, D.skewX = cc.degreesToRadians(D.skewX), D.skewY = cc.degreesToRadians(-D.skewY), ccs.TransformHelp.transformFromParent(q, D)
        }
        return q
    },
    decodeFrameFromJson: function(a, b) {
        var c = new ccs.FrameData;
        this.decodeNodeFromJson(c, a, b), c.tweenEasing = a[ccs.CONST_A_TWEEN_EASING] || ccs.TweenType.linear, c.displayIndex = a[ccs.CONST_A_DISPLAY_INDEX];
        var d = null == a[ccs.CONST_A_BLEND_SRC] ? cc.BLEND_SRC : a[ccs.CONST_A_BLEND_SRC],
            e = null == a[ccs.CONST_A_BLEND_DST] ? cc.BLEND_DST : a[ccs.CONST_A_BLEND_DST];
        c.blendFunc.src = d, c.blendFunc.dst = e, c.isTween = null == a[ccs.CONST_A_TWEEN_FRAME] ? !0 : a[ccs.CONST_A_TWEEN_FRAME];
        var f = a[ccs.CONST_A_EVENT];
        null != f && (c.strEvent = f, c.event = f), b.cocoStudioVersion < ccs.CONST_VERSION_COMBINED ? c.duration = null == a[ccs.CONST_A_DURATION] ? 1 : a[ccs.CONST_A_DURATION] : c.frameID = a[ccs.CONST_A_FRAME_INDEX];
        for (var g = a[ccs.CONST_A_EASING_PARAM] || [], h = 0; h < g.length; h++) c.easingParams[h] = g[h];
        return c
    },
    decodeTexture: function(a, b) {
        var c = new ccs.TextureData;
        c.init(), a.getAttribute(ccs.CONST_A_NAME) && (c.name = a.getAttribute(ccs.CONST_A_NAME));
        var d, e;
        b.flashToolVersion >= ccs.CONST_VERSION_2_0 ? (d = parseFloat(a.getAttribute(ccs.CONST_A_COCOS2D_PIVOT_X)) || 0, e = parseFloat(a.getAttribute(ccs.CONST_A_COCOS2D_PIVOT_Y)) || 0) : (d = parseFloat(a.getAttribute(ccs.CONST_A_PIVOT_X)) || 0, e = parseFloat(a.getAttribute(ccs.CONST_A_PIVOT_Y)) || 0);
        var f = parseFloat(a.getAttribute(ccs.CONST_A_WIDTH)) || 0,
            g = parseFloat(a.getAttribute(ccs.CONST_A_HEIGHT)) || 0,
            h = d / f,
            i = (g - e) / g;
        c.pivotX = h, c.pivotY = i;
        for (var j = a.querySelectorAll(ccs.CONST_SUB_TEXTURE + " > " + ccs.CONST_CONTOUR), k = 0; k < j.length; k++) c.addContourData(this.decodeContour(j[k], b));
        return c
    },
    decodeTextureFromJson: function(a) {
        var b = new ccs.TextureData;
        b.init();
        var c = a[ccs.CONST_A_NAME];
        null != c && (b.name = c), b.width = a[ccs.CONST_A_WIDTH] || 0, b.height = a[ccs.CONST_A_HEIGHT] || 0, b.pivotX = a[ccs.CONST_A_PIVOT_X] || 0, b.pivotY = a[ccs.CONST_A_PIVOT_Y] || 0;
        for (var d = a[ccs.CONST_CONTOUR_DATA] || [], e = 0; e < d.length; e++) b.contourDataList.push(this.decodeContourFromJson(d[e]));
        return b
    },
    decodeContour: function(a) {
        var b = new ccs.ContourData;
        b.init();
        for (var c, d = a.querySelectorAll(ccs.CONST_CONTOUR + " > " + ccs.CONST_CONTOUR_VERTEX), e = 0; e < d.length; e++) {
            c = d[e];
            var f = cc.p(0, 0);
            f.x = parseFloat(c.getAttribute(ccs.CONST_A_X)) || 0, f.y = parseFloat(c.getAttribute(ccs.CONST_A_Y)) || 0, f.y = -f.y, b.vertexList.push(f)
        }
        return b
    },
    decodeContourFromJson: function(a) {
        var b = new ccs.ContourData;
        b.init();
        for (var c = a[ccs.CONST_VERTEX_POINT] || [], d = c.length, e = 0; d > e; e++) {
            var f = c[e],
                g = cc.p(0, 0);
            g.x = f[ccs.CONST_A_X] || 0, g.y = f[ccs.CONST_A_Y] || 0, b.vertexList.push(g)
        }
        return b
    },
    addDataFromJsonCache: function(a, b) {
        b.contentScale = null == a[ccs.CONST_CONTENT_SCALE] ? 1 : a[ccs.CONST_CONTENT_SCALE];
        var c, d, e = a[ccs.CONST_ARMATURE_DATA] || [];
        for (c = 0; c < e.length; c++) d = this.decodeArmatureFromJSON(e[c], b), ccs.armatureDataManager.addArmatureData(d.name, d, b.filename);
        var f, g = a[ccs.CONST_ANIMATION_DATA] || [];
        for (c = 0; c < g.length; c++) f = this.decodeAnimationFromJson(g[c], b), ccs.armatureDataManager.addAnimationData(f.name, f, b.filename);
        var h, i = a[ccs.CONST_TEXTURE_DATA] || [];
        for (c = 0; c < i.length; c++) h = this.decodeTextureFromJson(i[c], b), ccs.armatureDataManager.addTextureData(h.name, h, b.filename);
        var j = null == b.asyncStruct ? ccs.armatureDataManager.isAutoLoadSpriteFile() : b.asyncStruct.autoLoadSpriteFile;
        if (j) {
            var k, l, m, n, o = a[ccs.CONST_CONFIG_FILE_PATH] || [];
            for (c = 0; c < o.length; c++) k = o[c], l = k.lastIndexOf("."), k = k.substring(0, l), m = b.basefilePath + k + ".plist", n = b.basefilePath + k + ".png", ccs.armatureDataManager.addSpriteFrameFromFile(m, n, b.filename)
        }
        d = null, f = null
    },
    decodeNodeFromJson: function(a, b, c) {
        a.x = b[ccs.CONST_A_X] * this._positionReadScale, a.y = b[ccs.CONST_A_Y] * this._positionReadScale, a.x *= c.contentScale, a.y *= c.contentScale, a.zOrder = b[ccs.CONST_A_Z], a.skewX = b[ccs.CONST_A_SKEW_X] || 0, a.skewY = b[ccs.CONST_A_SKEW_Y] || 0, a.scaleX = null == b[ccs.CONST_A_SCALE_X] ? 1 : b[ccs.CONST_A_SCALE_X], a.scaleY = null == b[ccs.CONST_A_SCALE_Y] ? 1 : b[ccs.CONST_A_SCALE_Y];
        var d;
        c.cocoStudioVersion < ccs.VERSION_COLOR_READING ? (d = b[0], d && (a.a = null == d[ccs.CONST_A_ALPHA] ? 255 : d[ccs.CONST_A_ALPHA], a.r = null == d[ccs.CONST_A_RED] ? 255 : d[ccs.CONST_A_RED], a.g = null == d[ccs.CONST_A_GREEN] ? 255 : d[ccs.CONST_A_GREEN], a.b = null == d[ccs.CONST_A_BLUE] ? 255 : d[ccs.CONST_A_BLUE], a.isUseColorInfo = !0)) : (d = b[ccs.CONST_COLOR_INFO] || null, d && (a.a = null == d[ccs.CONST_A_ALPHA] ? 255 : d[ccs.CONST_A_ALPHA], a.r = null == d[ccs.CONST_A_RED] ? 255 : d[ccs.CONST_A_RED], a.g = null == d[ccs.CONST_A_GREEN] ? 255 : d[ccs.CONST_A_GREEN], a.b = null == d[ccs.CONST_A_BLUE] ? 255 : d[ccs.CONST_A_BLUE], a.isUseColorInfo = !0))
    },
    clear: function() {
        this._configFileList = [], this._asyncRefCount = 0, this._asyncRefTotalCount = 0
    },
    _asyncCallBack: function(a, b, c) {
        a && cc.isFunction(a) && a.call(b, c), b && a && "string" == typeof a && b[a](c)
    },
    _initBaseFilePath: function(a) {
        var b = a,
            c = b.lastIndexOf("/");
        return b = c > -1 ? b.substr(0, c + 1) : ""
    },
    addDataFromXML: function(a, b) {
        var c = cc.loader.getRes(a);
        if (!c) throw "Please load the resource first : " + a;
        var d = cc.saxParser.parse(c),
            e = d.documentElement;
        e && this.addDataFromCache(e, b)
    },
    addDataFromJson: function(a, b) {
        var c = cc.loader.getRes(a);
        this.addDataFromJsonCache(c, b)
    }
}, ccs.spriteFrameCacheHelper = {
    _textureAtlasDic: {},
    _imagePaths: [],
    addSpriteFrameFromFile: function(a, b) {
        cc.spriteFrameCache.addSpriteFrames(a, b)
    },
    getTextureAtlasWithTexture: function(a) {
        return null
    },
    clear: function() {
        this._textureAtlasDic = {}, this._imagePaths = []
    }
}, ccs.TransformHelp = ccs.TransformHelp || ccs.Class.extend({}), ccs.TransformHelp.helpMatrix1 = cc.affineTransformMake(1, 0, 0, 1, 0, 0), ccs.TransformHelp.helpMatrix2 = cc.affineTransformMake(1, 0, 0, 1, 0, 0), ccs.TransformHelp.helpPoint1 = cc.p(0, 0), ccs.TransformHelp.helpPoint2 = cc.p(0, 0), ccs.TransformHelp.helpParentNode = {}, ccs.TransformHelp.transformFromParent = function(a, b) {
    this.nodeToMatrix(a, this.helpMatrix1), this.nodeToMatrix(b, this.helpMatrix2), this.helpMatrix2 = cc.affineTransformInvert(this.helpMatrix2), this.helpMatrix1 = cc.affineTransformConcat(this.helpMatrix1, this.helpMatrix2), this.matrixToNode(this.helpMatrix1, a)
}, ccs.TransformHelp.transformToParent = function(a, b) {
    this.nodeToMatrix(a, this.helpMatrix1), this.nodeToMatrix(b, this.helpMatrix2), this.helpMatrix1 = cc.affineTransformConcat(this.helpMatrix1, this.helpMatrix2), this.matrixToNode(this.helpMatrix1, a)
}, ccs.TransformHelp.transformFromParentWithoutScale = function(a, b) {
    for (var c in b) this.helpParentNode[c] = b[c];
    this.helpParentNode.scaleX = 1, this.helpParentNode.scaleY = 1, this.nodeToMatrix(a, this.helpMatrix1), this.nodeToMatrix(this.helpParentNode, this.helpMatrix2), this.helpMatrix2 = cc.affineTransformInvert(this.helpMatrix2), this.helpMatrix1 = cc.affineTransformConcat(this.helpMatrix1, this.helpMatrix2), this.matrixToNode(this.helpMatrix1, a)
}, ccs.TransformHelp.transformToParentWithoutScale = function(a, b) {
    for (var c in b) this.helpParentNode[c] = b[c];
    this.helpParentNode.scaleX = 1, this.helpParentNode.scaleY = 1, this.nodeToMatrix(a, this.helpMatrix1), this.nodeToMatrix(this.helpParentNode, this.helpMatrix2), this.helpMatrix1 = cc.affineTransformConcat(this.helpMatrix1, this.helpMatrix2), this.matrixToNode(this.helpMatrix1, a)
}, ccs.TransformHelp.nodeToMatrix = function(a, b) {
    if (a.skewX == -a.skewY) {
        var c = Math.sin(a.skewX),
            d = Math.cos(a.skewX);
        b.a = a.scaleX * d, b.b = a.scaleX * -c, b.c = a.scaleY * c, b.d = a.scaleY * d
    } else b.a = a.scaleX * Math.cos(a.skewY), b.b = a.scaleX * Math.sin(a.skewY), b.c = a.scaleY * Math.sin(a.skewX), b.d = a.scaleY * Math.cos(a.skewX);
    b.tx = a.x, b.ty = a.y
}, ccs.TransformHelp.matrixToNode = function(a, b) {
    this.helpPoint1.x = 0, this.helpPoint1.y = 1, this.helpPoint1 = cc.pointApplyAffineTransform(this.helpPoint1, a), this.helpPoint1.x -= a.tx, this.helpPoint1.y -= a.ty, this.helpPoint2.x = 1, this.helpPoint2.y = 0, this.helpPoint2 = cc.pointApplyAffineTransform(this.helpPoint2, a), this.helpPoint2.x -= a.tx, this.helpPoint2.y -= a.ty, b.skewX = -(Math.atan2(this.helpPoint1.y, this.helpPoint1.x) - 1.5707964), b.skewY = Math.atan2(this.helpPoint2.y, this.helpPoint2.x), b.scaleX = Math.sqrt(a.a * a.a + a.b * a.b), b.scaleY = Math.sqrt(a.c * a.c + a.d * a.d), b.x = a.tx, b.y = a.ty
}, ccs.TransformHelp.nodeConcat = function(a, b) {
    a.x += b.x, a.y += b.y, a.skewX += b.skewX, a.skewY += b.skewY, a.scaleX += b.scaleX, a.scaleY += b.scaleY
}, ccs.TransformHelp.nodeSub = function(a, b) {
    a.x -= b.x, a.y -= b.y, a.skewX -= b.skewX, a.skewY -= b.skewY, a.scaleX -= b.scaleX, a.scaleY -= b.scaleY
}, ccs.TweenType = {
    customEasing: -1,
    linear: 0,
    sineEaseIn: 1,
    sineEaseOut: 2,
    sineEaseInOut: 3,
    quadEaseIn: 4,
    quadEaseOut: 5,
    quadEaseInOut: 6,
    cubicEaseIn: 7,
    cubicEaseOut: 8,
    cubicEaseInOut: 9,
    quartEaseIn: 10,
    quartEaseOut: 11,
    quartEaseInOut: 12,
    quintEaseIn: 13,
    quintEaseOut: 14,
    quintEaseInOut: 15,
    expoEaseIn: 16,
    expoEaseOut: 17,
    expoEaseInOut: 18,
    circEaseIn: 19,
    eircEaseOut: 20,
    circEaseInOut: 21,
    elasticEaseIn: 22,
    elasticEaseOut: 23,
    elasticEaseInOut: 24,
    backEaseIn: 25,
    backEaseOut: 26,
    backEaseInOut: 27,
    bounceEaseIn: 28,
    bounceEaseOut: 29,
    bounceEaseInOut: 30,
    tweenEasingMax: 1e4
}, ccs.TweenFunction = ccs.TweenFunction || ccs.Class.extend({}), ccs.DOUBLE_PI = ccs.M_PI_X_2 = 2 * Math.PI, ccs.HALF_PI = ccs.M_PI_2 = Math.PI / 2, ccs.M_PI = Math.PI, ccs.TweenFunction.tweenTo = function(a, b, c) {
    var d = 0;
    switch (b) {
        case ccs.TweenType.customEasing:
            d = this.customEase(a, c);
            break;
        case ccs.TweenType.linear:
            d = this.linear(a);
            break;
        case ccs.TweenType.sineEaseIn:
            d = this.sineEaseIn(a);
            break;
        case ccs.TweenType.sineEaseOut:
            d = this.sineEaseOut(a);
            break;
        case ccs.TweenType.sineEaseInOut:
            d = this.sineEaseInOut(a);
            break;
        case ccs.TweenType.quadEaseIn:
            d = this.quadEaseIn(a);
            break;
        case ccs.TweenType.quadEaseOut:
            d = this.quadEaseOut(a);
            break;
        case ccs.TweenType.quadEaseInOut:
            d = this.quadEaseInOut(a);
            break;
        case ccs.TweenType.cubicEaseIn:
            d = this.cubicEaseIn(a);
            break;
        case ccs.TweenType.cubicEaseOut:
            d = this.cubicEaseOut(a);
            break;
        case ccs.TweenType.cubicEaseInOut:
            d = this.cubicEaseInOut(a);
            break;
        case ccs.TweenType.quartEaseIn:
            d = this.quartEaseIn(a);
            break;
        case ccs.TweenType.quartEaseOut:
            d = this.quartEaseOut(a);
            break;
        case ccs.TweenType.quartEaseInOut:
            d = this.quartEaseInOut(a);
            break;
        case ccs.TweenType.quintEaseIn:
            d = this.quintEaseIn(a);
            break;
        case ccs.TweenType.quintEaseOut:
            d = this.quintEaseOut(a);
            break;
        case ccs.TweenType.quintEaseInOut:
            d = this.quintEaseInOut(a);
            break;
        case ccs.TweenType.expoEaseIn:
            d = this.expoEaseIn(a);
            break;
        case ccs.TweenType.expoEaseOut:
            d = this.expoEaseOut(a);
            break;
        case ccs.TweenType.expoEaseInOut:
            d = this.expoEaseInOut(a);
            break;
        case ccs.TweenType.circEaseIn:
            d = this.circEaseIn(a);
            break;
        case ccs.TweenType.eircEaseOut:
            d = this.circEaseOut(a);
            break;
        case ccs.TweenType.circEaseInOut:
            d = this.circEaseInOut(a);
            break;
        case ccs.TweenType.elasticEaseIn:
            var e = .3;
            null != c && c.length > 0 && (e = c[0]), d = this.elasticEaseIn(a, e);
            break;
        case ccs.TweenType.elasticEaseOut:
            var e = .3;
            null != c && c.length > 0 && (e = c[0]), d = this.elasticEaseOut(a, e);
            break;
        case ccs.TweenType.elasticEaseInOut:
            var e = .3;
            null != c && c.length > 0 && (e = c[0]), d = this.elasticEaseInOut(a, e);
            break;
        case ccs.TweenType.backEaseIn:
            d = this.backEaseIn(a);
            break;
        case ccs.TweenType.backEaseOut:
            d = this.backEaseOut(a);
            break;
        case ccs.TweenType.backEaseInOut:
            d = this.backEaseInOut(a);
            break;
        case ccs.TweenType.bounceEaseIn:
            d = this.bounceEaseIn(a);
            break;
        case ccs.TweenType.bounceEaseOut:
            d = this.bounceEaseOut(a);
            break;
        case ccs.TweenType.bounceEaseInOut:
            d = this.bounceEaseInOut(a);
            break;
        default:
            d = this.sineEaseInOut(a)
    }
    return d
}, ccs.TweenFunction.linear = function(a) {
    return a
}, ccs.TweenFunction.sineEaseIn = function(a) {
    return -1 * Math.cos(a * ccs.HALF_PI) + 1
}, ccs.TweenFunction.sineEaseOut = function(a) {
    return Math.sin(a * ccs.HALF_PI)
}, ccs.TweenFunction.sineEaseInOut = function(a) {
    return -.5 * (Math.cos(ccs.M_PI * a) - 1)
}, ccs.TweenFunction.quadEaseIn = function(a) {
    return a * a
}, ccs.TweenFunction.quadEaseOut = function(a) {
    return -1 * a * (a - 2)
}, ccs.TweenFunction.quadEaseInOut = function(a) {
    return a = 2 * a, 1 > a ? .5 * a * a : (--a, -.5 * (a * (a - 2) - 1))
}, ccs.TweenFunction.cubicEaseIn = function(a) {
    return a * a * a
}, ccs.TweenFunction.cubicEaseOut = function(a) {
    return a -= 1, a * a * a + 1
}, ccs.TweenFunction.cubicEaseInOut = function(a) {
    return a = 2 * a, 1 > a ? .5 * a * a * a : (a -= 2, .5 * (a * a * a + 2))
}, ccs.TweenFunction.quartEaseIn = function(a) {
    return a * a * a * a
}, ccs.TweenFunction.quartEaseOut = function(a) {
    return a -= 1, -(a * a * a * a - 1)
}, ccs.TweenFunction.quartEaseInOut = function(a) {
    return a = 2 * a, 1 > a ? .5 * a * a * a * a : (a -= 2, -.5 * (a * a * a * a - 2))
}, ccs.TweenFunction.quintEaseIn = function(a) {
    return a * a * a * a * a
}, ccs.TweenFunction.quintEaseOut = function(a) {
    return a -= 1, a * a * a * a * a + 1
}, ccs.TweenFunction.quintEaseInOut = function(a) {
    return a = 2 * a, 1 > a ? .5 * a * a * a * a * a : (a -= 2, .5 * (a * a * a * a * a + 2))
}, ccs.TweenFunction.expoEaseIn = function(a) {
    return 0 == a ? 0 : Math.pow(2, 10 * (a - 1)) - .001
}, ccs.TweenFunction.expoEaseOut = function(a) {
    return 1 == a ? 1 : -Math.pow(2, -10 * a) + 1
}, ccs.TweenFunction.expoEaseInOut = function(a) {
    return a /= .5, a = 1 > a ? .5 * Math.pow(2, 10 * (a - 1)) : .5 * (-Math.pow(2, -10 * (a - 1)) + 2)
}, ccs.TweenFunction.circEaseIn = function(a) {
    return -1 * (Math.sqrt(1 - a * a) - 1)
}, ccs.TweenFunction.circEaseOut = function(a) {
    return a -= 1, Math.sqrt(1 - a * a)
}, ccs.TweenFunction.circEaseInOut = function(a) {
    return a = 2 * a, 1 > a ? -.5 * (Math.sqrt(1 - a * a) - 1) : (a -= 2, .5 * (Math.sqrt(1 - a * a) + 1))
}, ccs.TweenFunction.elasticEaseIn = function(a, b) {
    var c = .3;
    b.length > 0 && (c = b[0]);
    var d = 0;
    if (0 == a || 1 == a) d = a;
    else {
        var e = c / 4;
        a -= 1, d = -Math.pow(2, 10 * a) * Math.sin((a - e) * ccs.DOUBLE_PI / c)
    }
    return d
}, ccs.TweenFunction.elasticEaseOut = function(a, b) {
    var c = .3;
    b.length > 0 && (c = b[0]);
    var d = 0;
    if (0 == a || 1 == a) d = a;
    else {
        var e = c / 4;
        d = Math.pow(2, -10 * a) * Math.sin((a - e) * ccs.DOUBLE_PI / c) + 1
    }
    return d
}, ccs.TweenFunction.elasticEaseInOut = function(a, b) {
    var c = .3;
    b.length > 0 && (c = b[0]);
    var d = 0;
    if (0 == a || 1 == a) d = a;
    else {
        a = 2 * a, c || (c = .3 * 1.5);
        var e = c / 4;
        a -= 1, d = 0 > a ? -.5 * Math.pow(2, 10 * a) * Math.sin((a - e) * ccs.DOUBLE_PI / c) : Math.pow(2, -10 * a) * Math.sin((a - e) * ccs.DOUBLE_PI / c) * .5 + 1
    }
    return d
}, ccs.TweenFunction.backEaseIn = function(a) {
    var b = 1.70158;
    return a * a * ((b + 1) * a - b)
}, ccs.TweenFunction.backEaseOut = function(a) {
    var b = 1.70158;
    return a -= 1, a * a * ((b + 1) * a + b) + 1
}, ccs.TweenFunction.backEaseInOut = function(a) {
    var b = 2.5949095;
    return a = 2 * a, 1 > a ? a * a * ((b + 1) * a - b) / 2 : (a -= 2, a * a * ((b + 1) * a + b) / 2 + 1)
}, ccs.bounceTime = function(a) {
    return 1 / 2.75 > a ? 7.5625 * a * a : 2 / 2.75 > a ? (a -= 1.5 / 2.75, 7.5625 * a * a + .75) : 2.5 / 2.75 > a ? (a -= 2.25 / 2.75, 7.5625 * a * a + .9375) : (a -= 2.625 / 2.75, 7.5625 * a * a + .984375)
}, ccs.TweenFunction.bounceEaseIn = function(a) {
    return 1 - ccs.bounceTime(1 - a)
}, ccs.TweenFunction.bounceEaseOut = function(a) {
    return ccs.bounceTime(a)
}, ccs.TweenFunction.bounceEaseInOut = function(a) {
    var b = 0;
    return .5 > a ? (a = 2 * a, b = .5 * (1 - ccs.bounceTime(1 - a))) : b = .5 * ccs.bounceTime(2 * a - 1) + .5, b
}, ccs.TweenFunction.customEase = function(a, b) {
    if (b.length > 0) {
        var c = 1 - a;
        return b[1] * c * c * c + 3 * b[3] * a * c * c + 3 * b[5] * a * a * c + b[7] * a * a * a
    }
    return a
}, ccs.TweenFunction.easeIn = function(a, b) {
    return Math.pow(a, b)
}, ccs.TweenFunction.easeOut = function(a, b) {
    return Math.pow(a, 1 / b)
}, ccs.TweenFunction.easeInOut = function(a, b) {
    return a *= 2, 1 > a ? .5 * Math.pow(a, b) : 1 - .5 * Math.pow(2 - a, b)
}, ccs.TweenFunction.quadraticIn = function(a) {
    return Math.pow(a, 2)
}, ccs.TweenFunction.quadraticOut = function(a) {
    return -a * (a - 2)
}, ccs.TweenFunction.bezieratFunction = function(a, b, c, d, e) {
    return Math.pow(1 - e, 3) * a + 3 * e * Math.pow(1 - e, 2) * b + 3 * Math.pow(e, 2) * (1 - e) * c + Math.pow(e, 3) * d
};
var ENABLE_PHYSICS_DETECT = !1;
ccs.fmodf = function(a, b) {
    for (; a > b;) a -= b;
    return a
};
var CC_SAFE_RELEASE = function(a) {
    a && a.release && a.release()
};
ccs.isSpriteContainPoint = function(a, b, c) {
    var d = a.convertToNodeSpace(b);
    c && (c.x = d.x, c.y = d.y);
    var e = a.getContentSize();
    return cc.rectContainsPoint(cc.rect(0, 0, e.width, e.height), d)
}, ccs.SPRITE_CONTAIN_POINT = ccs.isSpriteContainPoint, ccs.SPRITE_CONTAIN_POINT_WITH_RETURN = ccs.isSpriteContainPoint, ccs.extBezierTo = function(a, b, c, d, e) {
    var f = cc.p(0, 0);
    return d && !e && (f.x = Math.pow(1 - a, 2) * b.x + 2 * a * (1 - a) * c.x + Math.pow(a, 2) * d.x, f.y = Math.pow(1 - a, 2) * b.y + 2 * a * (1 - a) * c.y + Math.pow(a, 2) * d.y), e && (f.x = b.x * Math.pow(1 - a, 3) + 3 * a * c.x * Math.pow(1 - a, 2) + 3 * d.x * Math.pow(a, 2) * (1 - a) + e.x * Math.pow(a, 3), f.y = b.y * Math.pow(1 - a, 3) + 3 * a * c.y * Math.pow(1 - a, 2) + 3 * d.y * Math.pow(a, 2) * (1 - a) + e.y * Math.pow(a, 3)), f
}, ccs.extCircleTo = function(a, b, c, d, e) {
    var f = cc.p(0, 0);
    return f.x = b.x + c * Math.cos(d + e * a), f.y = b.y + c * Math.sin(d + e * a), f
}, ccs.RelativeData = function() {
    this.plistFiles = [], this.armatures = [], this.animations = [], this.textures = []
}, ccs.armatureDataManager = {
    _animationDatas: {},
    _armatureDatas: {},
    _textureDatas: {},
    _autoLoadSpriteFile: !1,
    _relativeDatas: {},
    s_sharedArmatureDataManager: null,
    removeArmatureFileInfo: function(a) {
        var b = this.getRelativeData(a);
        if (b) {
            var c, d;
            for (c = 0; c < b.armatures.length; c++) d = b.armatures[c], this.removeArmatureData(d);
            for (c = 0; c < b.animations.length; c++) d = b.animations[c], this.removeAnimationData(d);
            for (c = 0; c < b.textures.length; c++) d = b.textures[c], this.removeTextureData(d);
            for (c = 0; c < b.plistFiles.length; c++) d = b.plistFiles[c], cc.spriteFrameCache.removeSpriteFramesFromFile(d);
            delete this._relativeDatas[a], ccs.dataReaderHelper.removeConfigFile(a)
        }
    },
    addArmatureData: function(a, b, c) {
        var d = this.getRelativeData(c);
        d && d.armatures.push(a), this._armatureDatas[a] = b
    },
    getArmatureData: function(a) {
        var b = null;
        return this._armatureDatas && (b = this._armatureDatas[a]), b
    },
    removeArmatureData: function(a) {
        this._armatureDatas[a] && delete this._armatureDatas[a]
    },
    addAnimationData: function(a, b, c) {
        var d = this.getRelativeData(c);
        d && d.animations.push(a), this._animationDatas[a] = b
    },
    getAnimationData: function(a) {
        var b = null;
        return this._animationDatas[a] && (b = this._animationDatas[a]), b
    },
    removeAnimationData: function(a) {
        this._animationDatas[a] && delete this._animationDatas[a]
    },
    addTextureData: function(a, b, c) {
        var d = this.getRelativeData(c);
        d && d.textures.push(a), this._textureDatas[a] = b
    },
    getTextureData: function(a) {
        var b = null;
        return this._textureDatas && (b = this._textureDatas[a]), b
    },
    removeTextureData: function(a) {
        this._textureDatas[a] && delete this._textureDatas[a]
    },
    addArmatureFileInfo: function() {
        var a, b, c;
        switch (arguments.length) {
            case 1:
                c = arguments[0], this.addRelativeData(c), this._autoLoadSpriteFile = !0, ccs.dataReaderHelper.addDataFromFile(c);
                break;
            case 3:
                a = arguments[0], b = arguments[1], c = arguments[2], this.addRelativeData(c), this._autoLoadSpriteFile = !1, ccs.dataReaderHelper.addDataFromFile(c), this.addSpriteFrameFromFile(b, a)
        }
    },
    addArmatureFileInfoAsync: function() {
        var a, b, c, d, e;
        switch (arguments.length) {
            case 3:
                c = arguments[0], d = arguments[2], e = arguments[1], this.addRelativeData(c), this._autoLoadSpriteFile = !0, ccs.dataReaderHelper.addDataFromFileAsync("", "", c, e, d);
                break;
            case 5:
                a = arguments[0], b = arguments[1], c = arguments[2], d = arguments[4], e = arguments[3], this.addRelativeData(c), this._autoLoadSpriteFile = !1, ccs.dataReaderHelper.addDataFromFileAsync(a, b, c, e, d), this.addSpriteFrameFromFile(b, a)
        }
    },
    addSpriteFrameFromFile: function(a, b, c) {
        var d = this.getRelativeData(c);
        d && d.plistFiles.push(a), ccs.spriteFrameCacheHelper.addSpriteFrameFromFile(a, b)
    },
    isAutoLoadSpriteFile: function() {
        return this._autoLoadSpriteFile
    },
    getArmatureDatas: function() {
        return this._armatureDatas
    },
    getAnimationDatas: function() {
        return this._animationDatas
    },
    getTextureDatas: function() {
        return this._textureDatas
    },
    addRelativeData: function(a) {
        this._relativeDatas[a] || (this._relativeDatas[a] = new ccs.RelativeData)
    },
    getRelativeData: function(a) {
        return this._relativeDatas[a]
    },
    clear: function() {
        this._animationDatas = {}, this._armatureDatas = {}, this._textureDatas = {}, ccs.spriteFrameCacheHelper.clear(), ccs.dataReaderHelper.clear()
    }
}, ccs.BLEND_TYPE_NORMAL = 0, ccs.BLEND_TYPE_LAYER = 1, ccs.BLEND_TYPE_DARKEN = 2, ccs.BLEND_TYPE_MULTIPLY = 3, ccs.BLEND_TYPE_LIGHTEN = 4, ccs.BLEND_TYPE_SCREEN = 5, ccs.BLEND_TYPE_OVERLAY = 6, ccs.BLEND_TYPE_HIGHLIGHT = 7, ccs.BLEND_TYPE_ADD = 8, ccs.BLEND_TYPE_SUBTRACT = 9, ccs.BLEND_TYPE_DIFFERENCE = 10, ccs.BLEND_TYPE_INVERT = 11, ccs.BLEND_TYPE_ALPHA = 12, ccs.BLEND_TYPE_ERASE = 13, ccs.DISPLAY_TYPE_SPRITE = 0, ccs.DISPLAY_TYPE_ARMATURE = 1, ccs.DISPLAY_TYPE_PARTICLE = 2, ccs.DISPLAY_TYPE_MAX = 3, ccs.BaseData = ccs.Class.extend({
    x: 0,
    y: 0,
    zOrder: 0,
    skewX: 0,
    skewY: 0,
    scaleX: 1,
    scaleY: 1,
    tweenRotate: 0,
    isUseColorInfo: !1,
    r: 255,
    g: 255,
    b: 255,
    a: 255,
    ctor: function() {
        this.x = 0, this.y = 0, this.zOrder = 0, this.skewX = 0, this.skewY = 0, this.scaleX = 1, this.scaleY = 1, this.tweenRotate = 0, this.isUseColorInfo = !1, this.r = 255, this.g = 255, this.b = 255, this.a = 255
    },
    copy: function(a) {
        this.x = a.x, this.y = a.y, this.zOrder = a.zOrder, this.scaleX = a.scaleX, this.scaleY = a.scaleY, this.skewX = a.skewX, this.skewY = a.skewY, this.tweenRotate = a.tweenRotate, this.isUseColorInfo = a.isUseColorInfo, this.r = a.r, this.g = a.g, this.b = a.b, this.a = a.a
    },
    setColor: function(a) {
        this.r = a.r, this.g = a.g, this.b = a.b, this.a = a.a
    },
    getColor: function() {
        return cc.color(this.r, this.g, this.b, this.a)
    },
    subtract: function(a, b, c) {
        this.x = b.x - a.x, this.y = b.y - a.y, this.scaleX = b.scaleX - a.scaleX, this.scaleY = b.scaleY - a.scaleY, this.skewX = b.skewX - a.skewX, this.skewY = b.skewY - a.skewY, this.isUseColorInfo || a.isUseColorInfo || b.isUseColorInfo ? (this.a = b.a - a.a, this.r = b.r - a.r, this.g = b.g - a.g, this.b = b.b - a.b, this.isUseColorInfo = !0) : (this.a = this.r = this.g = this.b = 0, this.isUseColorInfo = !1), c && (this.skewX > ccs.M_PI && (this.skewX -= ccs.DOUBLE_PI), this.skewX < -ccs.M_PI && (this.skewX += ccs.DOUBLE_PI), this.skewY > ccs.M_PI && (this.skewY -= ccs.DOUBLE_PI), this.skewY < -ccs.M_PI && (this.skewY += ccs.DOUBLE_PI)), b.tweenRotate && (this.skewX += b.tweenRotate * ccs.PI * 2, this.skewY -= b.tweenRotate * ccs.PI * 2)
    }
}), ccs.DisplayData = ccs.Class.extend({
    displayType: ccs.DISPLAY_TYPE_MAX,
    displayName: "",
    ctor: function() {
        this.displayType = ccs.DISPLAY_TYPE_MAX
    },
    changeDisplayToTexture: function(a) {
        var b = a,
            c = b.lastIndexOf(".");
        return -1 != c && (b = b.substring(0, c)), b
    },
    copy: function(a) {
        this.displayName = a.displayName, this.displayType = a.displayType
    }
}), ccs.SpriteDisplayData = ccs.DisplayData.extend({
    skinData: null,
    ctor: function() {
        this.skinData = new ccs.BaseData, this.displayType = ccs.DISPLAY_TYPE_SPRITE
    },
    copy: function(a) {
        ccs.DisplayData.prototype.copy.call(this, a), this.skinData = a.skinData
    }
}), ccs.ArmatureDisplayData = ccs.DisplayData.extend({
    ctor: function() {
        this.displayName = "", this.displayType = ccs.DISPLAY_TYPE_ARMATURE
    }
}), ccs.ParticleDisplayData = ccs.DisplayData.extend({
    ctor: function() {
        this.displayType = ccs.DISPLAY_TYPE_PARTICLE
    }
}), ccs.BoneData = ccs.BaseData.extend({
    displayDataList: null,
    name: "",
    parentName: "",
    boneDataTransform: null,
    ctor: function() {
        this.displayDataList = [], this.name = "", this.parentName = "", this.boneDataTransform = null
    },
    init: function() {
        return this.displayDataList.length = 0, !0
    },
    addDisplayData: function(a) {
        this.displayDataList.push(a)
    },
    getDisplayData: function(a) {
        return this.displayDataList[a]
    }
}), ccs.ArmatureData = ccs.Class.extend({
    boneDataDic: null,
    name: "",
    dataVersion: .1,
    ctor: function() {
        this.boneDataDic = {}, this.name = "", this.dataVersion = .1
    },
    init: function() {
        return !0
    },
    addBoneData: function(a) {
        this.boneDataDic[a.name] = a
    },
    getBoneDataDic: function() {
        return this.boneDataDic
    },
    getBoneData: function(a) {
        return this.boneDataDic[a]
    }
}), ccs.FrameData = ccs.BaseData.extend({
    duration: 0,
    tweenEasing: 0,
    easingParamNumber: 0,
    easingParams: null,
    displayIndex: -1,
    movement: "",
    event: "",
    sound: "",
    soundEffect: "",
    blendFunc: null,
    frameID: 0,
    isTween: !0,
    ctor: function() {
        ccs.BaseData.prototype.ctor.call(this), this.duration = 1, this.tweenEasing = ccs.TweenType.linear, this.easingParamNumber = 0, this.easingParams = [], this.displayIndex = 0, this.movement = "", this.event = "", this.sound = "", this.soundEffect = "", this.blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST), this.frameID = 0, this.isTween = !0
    },
    copy: function(a) {
        if (ccs.BaseData.prototype.copy.call(this, a), this.duration = a.duration, this.displayIndex = a.displayIndex, this.tweenEasing = a.tweenEasing, this.easingParamNumber = a.easingParamNumber, 0 != this.easingParamNumber) {
            this.easingParams.length = 0;
            for (var b = 0; b < this.easingParamNumber; b++) this.easingParams[b] = a.easingParams[b]
        }
        this.blendFunc = a.blendFunc, this.isTween = a.isTween
    }
}), ccs.MovementBoneData = ccs.Class.extend({
    delay: 0,
    scale: 1,
    duration: 0,
    frameList: null,
    name: "",
    ctor: function() {
        this.delay = 0, this.scale = 1, this.duration = 0, this.frameList = [], this.name = ""
    },
    init: function() {
        return !0
    },
    addFrameData: function(a) {
        this.frameList.push(a)
    },
    getFrameData: function(a) {
        return this.frameList[a]
    }
}), ccs.MovementData = function() {
    this.name = "", this.duration = 0, this.scale = 1, this.durationTo = 0, this.durationTween = 0, this.loop = !0, this.tweenEasing = ccs.TweenType.linear, this.movBoneDataDic = {}
}, ccs.MovementData.prototype.addMovementBoneData = function(a) {
    this.movBoneDataDic[a.name] = a
}, ccs.MovementData.prototype.getMovementBoneData = function(a) {
    return this.movBoneDataDic[a]
}, ccs.AnimationData = function() {
    this.movementDataDic = {}, this.movementNames = [], this.name = ""
}, ccs.AnimationData.prototype.addMovement = function(a) {
    this.movementDataDic[a.name] = a, this.movementNames.push(a.name)
}, ccs.AnimationData.prototype.getMovement = function(a) {
    return this.movementDataDic[a]
}, ccs.AnimationData.prototype.getMovementCount = function() {
    return Object.keys(this.movementDataDic).length
}, ccs.ContourVertex2 = function(a, b) {
    this.x = a || 0, this.y = b || 0
}, ccs.ContourData = function() {
    this.vertexList = []
}, ccs.ContourData.prototype.init = function() {
    return this.vertexList.length = 0, !0
}, ccs.ContourData.prototype.addVertex = function(a) {
    this.vertexList.push(a)
}, ccs.TextureData = function() {
    this.height = 0, this.width = 0, this.pivotX = .5, this.pivotY = .5, this.name = "", this.contourDataList = []
}, ccs.TextureData.prototype.init = function() {
    this.contourDataList.length = 0
}, ccs.TextureData.prototype.addContourData = function(a) {
    this.contourDataList.push(a)
}, ccs.TextureData.prototype.getContourData = function(a) {
    return this.contourDataList[a]
}, ccs.DecorativeDisplay = ccs.Class.extend({
    _display: null,
    _colliderDetector: null,
    _displayData: null,
    ctor: function() {
        this._display = null, this._colliderDetector = null, this._displayData = null
    },
    init: function() {
        return !0
    },
    setDisplay: function(a) {
        a._parent && (a._parent.removeChild(a), delete a._parent), this._display = a
    },
    getDisplay: function() {
        return this._display
    },
    setColliderDetector: function(a) {
        this._colliderDetector = a
    },
    getColliderDetector: function() {
        return this._colliderDetector
    },
    setDisplayData: function(a) {
        this._displayData = a
    },
    getDisplayData: function() {
        return this._displayData
    },
    release: function() {
        this._display = null, this._displayData = null, this._colliderDetector = null
    }
}), ccs.DecorativeDisplay.create = function() {
    return new ccs.DecorativeDisplay
}, ccs.displayFactory = {
    addDisplay: function(a, b, c) {
        switch (c.displayType) {
            case ccs.DISPLAY_TYPE_SPRITE:
                this.addSpriteDisplay(a, b, c);
                break;
            case ccs.DISPLAY_TYPE_PARTICLE:
                this.addParticleDisplay(a, b, c);
                break;
            case ccs.DISPLAY_TYPE_ARMATURE:
                this.addArmatureDisplay(a, b, c)
        }
    },
    createDisplay: function(a, b) {
        switch (b.getDisplayData().displayType) {
            case ccs.DISPLAY_TYPE_SPRITE:
                this.createSpriteDisplay(a, b);
                break;
            case ccs.DISPLAY_TYPE_PARTICLE:
                this.createParticleDisplay(a, b);
                break;
            case ccs.DISPLAY_TYPE_ARMATURE:
                this.createArmatureDisplay(a, b)
        }
    },
    _helpTransform: {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
    },
    updateDisplay: function(a, b, c) {
        var d = a.getDisplayRenderNode();
        if (d) {
            switch (a.getDisplayRenderNodeType()) {
                case ccs.DISPLAY_TYPE_SPRITE:
                    c && d.updateArmatureTransform();
                    break;
                case ccs.DISPLAY_TYPE_PARTICLE:
                    this.updateParticleDisplay(a, d, b);
                    break;
                case ccs.DISPLAY_TYPE_ARMATURE:
                    this.updateArmatureDisplay(a, d, b);
                    break;
                default:
                    var e = a.getNodeToArmatureTransform();
                    d.setAdditionalTransform(e)
            }
            if ((ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT || ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) && c) {
                var f = a.getDisplayManager().getCurrentDecorativeDisplay(),
                    g = f.getColliderDetector();
                if (g) {
                    var h = f.getDisplay(),
                        i = h.getNodeToParentTransform(),
                        j = this._helpTransform;
                    j.a = i.a, j.b = i.b, j.c = i.c, j.d = i.d, j.tx = i.tx, j.ty = i.ty;
                    var k = cc.pointApplyAffineTransform(h.getAnchorPointInPoints(), j);
                    j.tx = k.x, j.ty = k.y;
                    var l = cc.affineTransformConcat(j, a.getArmature().getNodeToParentTransform());
                    g.updateTransform(l)
                }
            }
        }
    },
    addSpriteDisplay: function(a, b, c) {
        var d = new ccs.SpriteDisplayData;
        d.copy(c), b.setDisplayData(d), this.createSpriteDisplay(a, b)
    },
    createSpriteDisplay: function(a, b) {
        var c = null,
            d = b.getDisplayData(),
            e = d.displayName,
            f = e.lastIndexOf(".");
        if (-1 != f && (e = e.substring(0, f)), c = "" == e ? new ccs.Skin : new ccs.Skin("#" + e + ".png"), b.setDisplay(c), null != c) {
            c.setBone(a), this.initSpriteDisplay(a, b, d.displayName, c);
            var g = a.getArmature();
            g && c.setSkinData(g.getArmatureData().dataVersion >= ccs.CONST_VERSION_COMBINED ? d.skinData : a.boneData)
        }
    },
    initSpriteDisplay: function(a, b, c, d) {
        var e = c,
            f = e.lastIndexOf("."); - 1 != f && (e = e.substring(0, f));
        var g = ccs.armatureDataManager.getTextureData(e);
        if (g && d.setAnchorPoint(cc.p(g.pivotX, g.pivotY)), (ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT || ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) && g && g.contourDataList.length > 0) {
            var h = new ccs.ColliderDetector(a);
            h.addContourDataList(g.contourDataList), b.setColliderDetector(h)
        }
    },
    addArmatureDisplay: function(a, b, c) {
        var d = new ccs.ArmatureDisplayData;
        d.copy(c), b.setDisplayData(d), this.createArmatureDisplay(a, b)
    },
    createArmatureDisplay: function(a, b) {
        var c = b.getDisplayData(),
            d = new ccs.Armature(c.displayName, a);
        b.setDisplay(d)
    },
    updateArmatureDisplay: function(a, b, c) {
        b && (b.sortAllChildren(), b.update(c))
    },
    addParticleDisplay: function(a, b, c) {
        var d = new ccs.ParticleDisplayData;
        d.copy(c), b.setDisplayData(d), this.createParticleDisplay(a, b)
    },
    createParticleDisplay: function(a, b) {
        var c = b.getDisplayData(),
            d = new cc.ParticleSystem(c.displayName);
        d.removeFromParent(), d.cleanup();
        var e = a.getArmature();
        e && d.setParent(a.getArmature()), b.setDisplay(d)
    },
    updateParticleDisplay: function(a, b, c) {
        var d = new ccs.BaseData;
        ccs.TransformHelp.matrixToNode(a.nodeToArmatureTransform(), d), b.setPosition(d.x, d.y), b.setScaleX(d.scaleX), b.setScaleY(d.scaleY), b.update(c)
    }
}, ccs.DisplayManager = ccs.Class.extend({
    _decoDisplayList: null,
    _currentDecoDisplay: null,
    _displayRenderNode: null,
    _displayIndex: null,
    _forceChangeDisplay: !1,
    _bone: null,
    _visible: !0,
    _displayType: null,
    ctor: function(a) {
        this._decoDisplayList = [], this._currentDecoDisplay = null, this._displayRenderNode = null, this._displayIndex = null, this._forceChangeDisplay = !1, this._bone = null, this._visible = !0, this._displayType = ccs.DISPLAY_TYPE_MAX, a && ccs.DisplayManager.prototype.init.call(this, a)
    },
    init: function(a) {
        return this._bone = a, this.initDisplayList(a.getBoneData()), !0
    },
    addDisplay: function(a, b) {
        var c, d = this._decoDisplayList;
        if (b >= 0 && b < d.length ? c = d[b] : (c = new ccs.DecorativeDisplay, d.push(c)), a instanceof ccs.DisplayData) return cc.displayFactory.addDisplay(this._bone, c, a), void(b == this._displayIndex && (this._displayIndex = -1, this.changeDisplayWithIndex(b, !1)));
        var e = null;
        if (a instanceof ccs.Skin) {
            a.setBone(this._bone), e = new ccs.SpriteDisplayData, ccs.displayFactory.initSpriteDisplay(this._bone, c, a.getDisplayName(), a);
            var f = c.getDisplayData();
            if (f instanceof ccs.SpriteDisplayData) a.setSkinData(f.skinData), e.skinData = f.skinData;
            else {
                for (var g = !1, h = d.length - 2; h >= 0; h--) {
                    var i = d[h],
                        j = i.getDisplayData();
                    if (j instanceof ccs.SpriteDisplayData) {
                        g = !0, a.setSkinData(j.skinData), e.skinData = j.skinData;
                        break
                    }
                }
                g || a.setSkinData(new ccs.BaseData)
            }
        } else if (a instanceof cc.ParticleSystem) {
            e = new ccs.ParticleDisplayData, a.removeFromParent(), a.cleanup();
            var k = this._bone.getArmature();
            k && a.setParent(k)
        } else a instanceof ccs.Armature ? (e = new ccs.ArmatureDisplayData, e.displayName = a.getName(), a.setParentBone(this._bone)) : e = new ccs.DisplayData;
        c.setDisplay(a), c.setDisplayData(e), b == this._displayIndex && (this._displayIndex = -1, this.changeDisplayWithIndex(b, !1))
    },
    _addDisplayOther: function(a, b) {
        var c = null;
        if (b instanceof ccs.Skin) {
            var d = b;
            d.setBone(this._bone), c = new ccs.SpriteDisplayData, c.displayName = d.getDisplayName(), ccs.displayFactory.initSpriteDisplay(this._bone, a, d.getDisplayName(), d);
            var e = a.getDisplayData();
            if (e instanceof ccs.SpriteDisplayData) d.setSkinData(e.skinData);
            else {
                for (var f = !1, g = this._decoDisplayList.length - 2; g >= 0; g--) {
                    var h = this._decoDisplayList[g],
                        i = h.getDisplayData();
                    if (i) {
                        f = !0, d.setSkinData(i.skinData), c.skinData = i.skinData;
                        break
                    }
                }
                f || d.setSkinData(new ccs.BaseData), d.setSkinData(new ccs.BaseData)
            }
        } else b instanceof cc.ParticleSystem ? (c = new ccs.ParticleDisplayData, c.displayName = b._plistFile) : b instanceof ccs.Armature ? (c = new ccs.ArmatureDisplayData, c.displayName = b.getName(), b.setParentBone(this._bone)) : c = new ccs.DisplayData;
        a.setDisplay(b), a.setDisplayData(c)
    },
    removeDisplay: function(a) {
        this._decoDisplayList.splice(a, 1), a === this._displayIndex && (this.setCurrentDecorativeDisplay(null), this._displayIndex = -1)
    },
    getDecorativeDisplayList: function() {
        return this._decoDisplayList
    },
    changeDisplayWithIndex: function(a, b) {
        return a >= this._decoDisplayList.length ? void cc.log("the index value is out of range") : (this._forceChangeDisplay = b, this._displayIndex != a ? (this._displayIndex = a, 0 > a ? void(this._displayRenderNode && (this._displayRenderNode.removeFromParent(!0), this.setCurrentDecorativeDisplay(null))) : void this.setCurrentDecorativeDisplay(this._decoDisplayList[a])) : void 0)
    },
    changeDisplayWithName: function(a, b) {
        for (var c = this._decoDisplayList, d = 0; d < c.length; d++)
            if (c[d].getDisplayData().displayName == a) {
                this.changeDisplayWithIndex(d, b);
                break
            }
    },
    setCurrentDecorativeDisplay: function(a) {
        var b = this._currentDecoDisplay;
        (ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT || ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) && b && b.getColliderDetector() && b.getColliderDetector().setActive(!1), this._currentDecoDisplay = a, b = this._currentDecoDisplay, (ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT || ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) && b && b.getColliderDetector() && b.getColliderDetector().setActive(!0);
        var c = b ? b.getDisplay() : null,
            d = this._displayRenderNode,
            e = this._bone;
        d && (d instanceof ccs.Armature && e.setChildArmature(null), d.removeFromParent(!0)), this._displayRenderNode = c, c ? (c instanceof ccs.Armature ? (this._bone.setChildArmature(c), c.setParentBone(this._bone)) : c instanceof cc.ParticleSystem && (c instanceof ccs.Armature ? (e.setChildArmature(c), c.setParentBone(e)) : c instanceof cc.ParticleSystem && c.resetSystem()), c.setColor(e.getDisplayedColor()), c.setOpacity(e.getDisplayedOpacity()), this._displayRenderNode.setVisible(this._visible), this._displayType = this._currentDecoDisplay.getDisplayData().displayType) : this._displayType = ccs.DISPLAY_TYPE_MAX, cc.renderer.childrenOrderDirty = !0
    },
    getDisplayRenderNode: function() {
        return this._displayRenderNode
    },
    getDisplayRenderNodeType: function() {
        return this._displayType
    },
    getCurrentDisplayIndex: function() {
        return this._displayIndex
    },
    getCurrentDecorativeDisplay: function() {
        return this._currentDecoDisplay
    },
    getDecorativeDisplayByIndex: function(a) {
        return this._decoDisplayList[a]
    },
    initDisplayList: function(a) {
        if (this._decoDisplayList.length = 0, a)
            for (var b = a.displayDataList, c = this._decoDisplayList, d = this._bone, e = 0; e < b.length; e++) {
                var f = b[e],
                    g = new ccs.DecorativeDisplay;
                g.setDisplayData(f), ccs.displayFactory.createDisplay(d, g), c.push(g)
            }
    },
    containPoint: function(a, b) {
        if (!this._visible || this._displayIndex < 0) return !1;
        if (void 0 !== b && (a = cc.p(a, b)), this._currentDecoDisplay.getDisplayData().displayType == ccs.DISPLAY_TYPE_SPRITE) {
            var c = this._currentDecoDisplay.getDisplay();
            return c = c.getChildByTag(0), ccs.SPRITE_CONTAIN_POINT_WITH_RETURN(c, a)
        }
        return !1
    },
    setVisible: function(a) {
        this._displayRenderNode && (this._visible = a, this._displayRenderNode.setVisible(a))
    },
    isVisible: function() {
        return this._visible
    },
    getContentSize: function() {
        return this._displayRenderNode ? this._displayRenderNode.getContentSize() : cc.size(0, 0)
    },
    getBoundingBox: function() {
        return this._displayRenderNode ? this._displayRenderNode.getBoundingBox() : cc.rect(0, 0, 0, 0)
    },
    getAnchorPoint: function() {
        return this._displayRenderNode ? this._displayRenderNode.getAnchorPoint() : cc.p(0, 0)
    },
    getAnchorPointInPoints: function() {
        return this._displayRenderNode ? this._displayRenderNode.getAnchorPointInPoints() : cc.p(0, 0)
    },
    getForceChangeDisplay: function() {
        return this._forceChangeDisplay
    },
    release: function() {
        this._decoDisplayList = null, this._displayRenderNode && (this._displayRenderNode.removeFromParent(!0), this._displayRenderNode = null)
    }
}), ccs.DisplayManager.create = function(a) {
    return new ccs.DisplayManager(a)
}, ccs.Skin = ccs.Sprite.extend({
    _skinData: null,
    bone: null,
    _skinTransform: null,
    _displayName: "",
    _armature: null,
    _className: "Skin",
    ctor: function(a, b) {
        cc.Sprite.prototype.ctor.call(this), this._skinData = null, this.bone = null, this._displayName = "", this._skinTransform = cc.affineTransformIdentity(), this._armature = null, null == a || "" == a ? ccs.Skin.prototype.init.call(this) : "#" == a[0] ? ccs.Skin.prototype.initWithSpriteFrameName.call(this, a.substr(1)) : ccs.Skin.prototype.initWithFile.call(this, a, b)
    },
    initWithSpriteFrameName: function(a) {
        if ("" == a) return !1;
        var b = cc.spriteFrameCache.getSpriteFrame(a),
            c = !0;
        return b ? this.initWithSpriteFrame(b) : (cc.log("Can't find CCSpriteFrame with %s. Please check your .plist file", a), c = !1), this._displayName = a, c
    },
    initWithFile: function(a, b) {
        var c = b ? cc.Sprite.prototype.initWithFile.call(this, a, b) : cc.Sprite.prototype.initWithFile.call(this, a);
        return this._displayName = a, c
    },
    setSkinData: function(a) {
        this._skinData = a, this.setScaleX(a.scaleX), this.setScaleY(a.scaleY), this.setRotationX(cc.radiansToDegrees(a.skewX)), this.setRotationY(cc.radiansToDegrees(-a.skewY)), this.setPosition(a.x, a.y);
        var b = this.getNodeToParentTransform ? this.getNodeToParentTransform() : this.nodeToParentTransform(),
            c = this._skinTransform;
        c.a = b.a, c.b = b.b, c.c = b.c, c.d = b.d, c.tx = b.tx, c.ty = b.ty, this.updateArmatureTransform()
    },
    getSkinData: function() {
        return this._skinData
    },
    updateArmatureTransform: function() {
        this._renderCmd.updateArmatureTransform()
    },
    getNodeToWorldTransform: function() {
        return this._renderCmd.getNodeToWorldTransform()
    },
    getNodeToWorldTransformAR: function() {
        return this._renderCmd.getNodeToWorldTransformAR()
    },
    setBone: function(a) {
        this.bone = a;
        var b = this.bone.getArmature();
        b && (this._armature = b)
    },
    getBone: function() {
        return this.bone
    },
    getDisplayName: function() {
        return this._displayName
    },
    _createRenderCmd: function() {
        return cc._renderType === cc._RENDER_TYPE_CANVAS ? new ccs.Skin.CanvasRenderCmd(this) : new ccs.Skin.WebGLRenderCmd(this)
    }
});
var _p = ccs.Skin.prototype;
_p.skinData, cc.defineGetterSetter(_p, "skinData", _p.getSkinData, _p.setSkinData), _p.displayName, cc.defineGetterSetter(_p, "displayName", _p.getDisplayName), _p = null, ccs.Skin.create = function(a, b) {
        return new ccs.Skin(a, b)
    }, ccs.Skin.createWithSpriteFrameName = function(a) {
        return new ccs.Skin("#" + a)
    },
    function() {
        ccs.Skin.RenderCmd = {
            updateArmatureTransform: function() {
                var a = this._node;
                this._transform = cc.affineTransformConcat(a._skinTransform, a.bone.getNodeToArmatureTransform()), this._dirtyFlag = this._dirtyFlag & cc.Node._dirtyFlags.transformDirty ^ this._dirtyFlag
            },
            getNodeToWorldTransform: function() {
                return cc.affineTransformConcat(this._transform, this._node.bone.getArmature().getNodeToWorldTransform())
            },
            getNodeToWorldTransformAR: function() {
                var a = this._transform,
                    b = this._node;
                return this._anchorPointInPoints = cc.pointApplyAffineTransform(this._anchorPointInPoints, a), a.tx = this._anchorPointInPoints.x, a.ty = this._anchorPointInPoints.y, cc.affineTransformConcat(a, b.bone.getArmature().getNodeToWorldTransform())
            }
        }, ccs.Skin.CanvasRenderCmd = function(a) {
            cc.Sprite.CanvasRenderCmd.call(this, a), this._needDraw = !0
        };
        var a = ccs.Skin.CanvasRenderCmd.prototype = Object.create(cc.Sprite.CanvasRenderCmd.prototype);
        cc.inject(ccs.Skin.RenderCmd, a), a.constructor = ccs.Skin.CanvasRenderCmd
    }(), ccs.ANIMATION_TYPE_SINGLE_FRAME = -4, ccs.ANIMATION_TYPE_NO_LOOP = -3, ccs.ANIMATION_TYPE_TO_LOOP_FRONT = -2, ccs.ANIMATION_TYPE_TO_LOOP_BACK = -1, ccs.ANIMATION_TYPE_LOOP_FRONT = 0, ccs.ANIMATION_TYPE_LOOP_BACK = 1, ccs.ANIMATION_TYPE_MAX = 2, ccs.ProcessBase = ccs.Class.extend({
        _processScale: 1,
        _isComplete: !0,
        _isPause: !0,
        _isPlaying: !1,
        _currentPercent: 0,
        _rawDuration: 0,
        _loopType: 0,
        _tweenEasing: 0,
        animationInternal: null,
        _currentFrame: 0,
        _durationTween: 0,
        _nextFrameIndex: 0,
        _curFrameIndex: null,
        _isLoopBack: !1,
        ctor: function() {
            this._processScale = 1, this._isComplete = !0, this._isPause = !0, this._isPlaying = !1, this._currentFrame = 0, this._currentPercent = 0, this._durationTween = 0, this._rawDuration = 0, this._loopType = ccs.ANIMATION_TYPE_LOOP_BACK, this._tweenEasing = ccs.TweenType.linear, this.animationInternal = 1 / 60, this._curFrameIndex = 0, this._durationTween = 0, this._isLoopBack = !1
        },
        pause: function() {
            this._isPause = !0, this._isPlaying = !1
        },
        resume: function() {
            this._isPause = !1, this._isPlaying = !0
        },
        stop: function() {
            this._isComplete = !0, this._isPlaying = !1
        },
        play: function(a, b, c, d) {
            this._isComplete = !1, this._isPause = !1, this._isPlaying = !0, this._currentFrame = 0, this._nextFrameIndex = a, this._tweenEasing = d
        },
        update: function(a) {
            if (!this._isComplete && !this._isPause && !(this._rawDuration <= 0 || a > 1)) {
                var b = void 0 === this._nextFrameIndex ? 0 : this._nextFrameIndex,
                    c = this._currentFrame;
                0 >= b ? (this._currentPercent = 1, c = 0) : (c += this._processScale * (a / this.animationInternal), this._currentPercent = c / b, c = ccs.fmodf(c, b)), this._currentFrame = c, this.updateHandler()
            }
        },
        gotoFrame: function(a) {
            var b = this._loopType;
            b == ccs.ANIMATION_TYPE_NO_LOOP ? b = ccs.ANIMATION_TYPE_MAX : b == ccs.ANIMATION_TYPE_TO_LOOP_FRONT && (b = ccs.ANIMATION_TYPE_LOOP_FRONT), this._loopType = b, this._curFrameIndex = a, this._nextFrameIndex = this._durationTween
        },
        getCurrentFrameIndex: function() {
            return this._curFrameIndex = (this._rawDuration - 1) * this._currentPercent, this._curFrameIndex
        },
        updateHandler: function() {},
        isPause: function() {
            return this._isPause
        },
        isComplete: function() {
            return this._isComplete
        },
        getCurrentPercent: function() {
            return this._currentPercent
        },
        getRawDuration: function() {
            return this._rawDuration
        },
        getLoop: function() {
            return this._loopType
        },
        getTweenEasing: function() {
            return this._tweenEasing
        },
        getAnimationInternal: function() {
            return this.animationInternal
        },
        setAnimationInternal: function(a) {
            this.animationInternal = a
        },
        getProcessScale: function() {
            return this._processScale
        },
        setProcessScale: function(a) {
            this._processScale = a
        },
        isPlaying: function() {
            return this._isPlaying
        }
    });
var _p = ccs.ProcessBase.prototype;
_p.currentFrameIndex, cc.defineGetterSetter(_p, "currentFrameIndex", _p.getCurrentFrameIndex), _p.paused, cc.defineGetterSetter(_p, "paused", _p.isPause), _p.completed, cc.defineGetterSetter(_p, "completed", _p.isComplete), _p.currentPercent, cc.defineGetterSetter(_p, "currentPercent", _p.getCurrentPercent), _p.rawDuration, cc.defineGetterSetter(_p, "rawDuration", _p.getRawDuration), _p.loop, cc.defineGetterSetter(_p, "loop", _p.getLoop), _p.tweenEasing, cc.defineGetterSetter(_p, "tweenEasing", _p.getTweenEasing), _p.playing, cc.defineGetterSetter(_p, "playing", _p.isPlaying), _p = null, ccs.MovementEventType = {
    start: 0,
    complete: 1,
    loopComplete: 2
}, ccs.AnimationEvent = ccs.Class.extend({
    _arguments: null,
    _callFunc: null,
    _selectorTarget: null,
    ctor: function(a, b, c) {
        this._data = c, this._callFunc = a, this._selectorTarget = b
    },
    call: function() {
        this._callFunc && this._callFunc.apply(this._selectorTarget, this._arguments)
    },
    setArguments: function(a) {
        this._arguments = a
    }
}), ccs.MovementEvent = function() {
    this.armature = null, this.movementType = ccs.MovementEventType.start, this.movementID = ""
}, ccs.FrameEvent = function() {
    this.bone = null, this.frameEventName = "", this.originFrameIndex = 0, this.currentFrameIndex = 0
}, ccs.ArmatureAnimation = ccs.ProcessBase.extend({
    _animationData: null,
    _movementData: null,
    _armature: null,
    _movementID: "",
    _toIndex: 0,
    _tweenList: null,
    _speedScale: 1,
    _ignoreFrameEvent: !1,
    _frameEventQueue: null,
    _movementEventQueue: null,
    _movementList: null,
    _onMovementList: !1,
    _movementListLoop: !1,
    _movementIndex: 0,
    _movementListDurationTo: -1,
    _movementEventCallFunc: null,
    _frameEventCallFunc: null,
    _movementEventTarget: null,
    _frameEventTarget: null,
    _movementEventListener: null,
    _frameEventListener: null,
    ctor: function(a) {
        ccs.ProcessBase.prototype.ctor.call(this), this._tweenList = [], this._movementList = [], this._frameEventQueue = [], this._movementEventQueue = [], this._armature = null, a && ccs.ArmatureAnimation.prototype.init.call(this, a)
    },
    init: function(a) {
        return this._armature = a, this._tweenList.length = 0, !0
    },
    pause: function() {
        for (var a = this._tweenList, b = 0; b < a.length; b++) a[b].pause();
        ccs.ProcessBase.prototype.pause.call(this)
    },
    resume: function() {
        for (var a = this._tweenList, b = 0; b < a.length; b++) a[b].resume();
        ccs.ProcessBase.prototype.resume.call(this)
    },
    stop: function() {
        for (var a = this._tweenList, b = 0; b < a.length; b++) a[b].stop();
        a.length = 0, ccs.ProcessBase.prototype.stop.call(this)
    },
    setAnimationScale: function(a) {
        this.setSpeedScale(a)
    },
    getAnimationScale: function() {
        return this.getSpeedScale()
    },
    setSpeedScale: function(a) {
        if (a != this._speedScale) {
            this._speedScale = a, this._processScale = this._movementData ? this._speedScale * this._movementData.scale : this._speedScale;
            var b = this._armature.getBoneDic();
            for (var c in b) {
                var d = b[c];
                d.getTween().setProcessScale(this._processScale), d.getChildArmature() && d.getChildArmature().getAnimation().setSpeedScale(this._processScale)
            }
        }
    },
    getSpeedScale: function() {
        return this._speedScale
    },
    play: function(a, b, c) {
        cc.assert(this._animationData, "this.animationData can not be null"), this._movementData = this._animationData.getMovement(a), cc.assert(this._movementData, "this._movementData can not be null"), b = void 0 === b ? -1 : b, c = void 0 === c ? -1 : c, this._rawDuration = this._movementData.duration, this._movementID = a, this._processScale = this._speedScale * this._movementData.scale, b = -1 == b ? this._movementData.durationTo : b;
        var d = 0 == this._movementData.durationTween ? this._rawDuration : this._movementData.durationTween,
            e = this._movementData.tweenEasing;
        c = 0 > c ? this._movementData.loop : c, this._onMovementList = !1, ccs.ProcessBase.prototype.play.call(this, b, d, c, e), 0 == this._rawDuration ? this._loopType = ccs.ANIMATION_TYPE_SINGLE_FRAME : (this._loopType = c ? ccs.ANIMATION_TYPE_TO_LOOP_FRONT : ccs.ANIMATION_TYPE_NO_LOOP, this._durationTween = d);
        var f;
        this._tweenList = [];
        var g = this._armature.getBoneDic();
        for (var h in g) {
            var i = g[h];
            f = this._movementData.movBoneDataDic[i.getName()];
            var j = i.getTween();
            f && f.frameList.length > 0 ? (this._tweenList.push(j), f.duration = this._movementData.duration, j.play(f, b, d, c, e), j.setProcessScale(this._processScale), i.getChildArmature() && i.getChildArmature().getAnimation().setSpeedScale(this._processScale)) : i.isIgnoreMovementBoneData() || (i.getDisplayManager().changeDisplayWithIndex(-1, !1), j.stop())
        }
        this._armature.update(0)
    },
    playByIndex: function(a, b, c, d) {
        cc.log("playByIndex is deprecated. Use playWithIndex instead."), this.playWithIndex(a, b, d)
    },
    playWithIndex: function(a, b, c) {
        var d = this._animationData.movementNames;
        cc.assert(a > -1 && a < d.length);
        var e = d[a];
        this.play(e, b, c)
    },
    playWithNames: function(a, b, c) {
        b = void 0 === b ? -1 : b, c = void 0 === c ? !0 : c, this._movementListLoop = c, this._movementListDurationTo = b, this._onMovementList = !0, this._movementIndex = 0, a instanceof Array ? this._movementList = a : this._movementList.length = 0, this.updateMovementList()
    },
    playWithIndexes: function(a, b, c) {
        b = void 0 === b ? -1 : b, c = void 0 === c ? !0 : c, this._movementList.length = 0, this._movementListLoop = c, this._movementListDurationTo = b, this._onMovementList = !0, this._movementIndex = 0;
        for (var d = this._animationData.movementNames, e = 0; e < a.length; e++) {
            var f = d[a[e]];
            this._movementList.push(f)
        }
        this.updateMovementList()
    },
    gotoAndPlay: function(a) {
        if (!this._movementData || 0 > a || a >= this._movementData.duration) return void cc.log("Please ensure you have played a movement, and the frameIndex is in the range.");
        var b = this._ignoreFrameEvent;
        this._ignoreFrameEvent = !0, this._isPlaying = !0, this._isComplete = this._isPause = !1, ccs.ProcessBase.prototype.gotoFrame.call(this, a), this._currentPercent = this._curFrameIndex / (this._movementData.duration - 1), this._currentFrame = this._nextFrameIndex * this._currentPercent;
        for (var c = this._tweenList, d = 0; d < c.length; d++) c[d].gotoAndPlay(a);
        this._armature.update(0), this._ignoreFrameEvent = b
    },
    gotoAndPause: function(a) {
        this.gotoAndPlay(a), this.pause()
    },
    getMovementCount: function() {
        return this._animationData.getMovementCount()
    },
    update: function(a) {
        ccs.ProcessBase.prototype.update.call(this, a);
        for (var b = this._tweenList, c = 0; c < b.length; c++) b[c].update(a);
        for (var d, e = this._frameEventQueue; e.length > 0;) d = e.shift(), this._ignoreFrameEvent = !0, this._frameEventCallFunc && this._frameEventCallFunc.call(this._frameEventTarget, d.bone, d.frameEventName, d.originFrameIndex, d.currentFrameIndex), this._frameEventListener && this._frameEventListener(d.bone, d.frameEventName, d.originFrameIndex, d.currentFrameIndex), this._ignoreFrameEvent = !1;
        for (var f = this._movementEventQueue; f.length > 0;) d = f.shift(), this._movementEventCallFunc && this._movementEventCallFunc.call(this._movementEventTarget, d.armature, d.movementType, d.movementID), this._movementEventListener && this._movementEventListener(d.armature, d.movementType, d.movementID)
    },
    updateHandler: function() {
        var a = this._currentPercent;
        if (a >= 1) {
            switch (this._loopType) {
                case ccs.ANIMATION_TYPE_NO_LOOP:
                    if (this._loopType = ccs.ANIMATION_TYPE_MAX, this._currentFrame = (a - 1) * this._nextFrameIndex, a = this._currentFrame / this._durationTween, 1 > a) {
                        this._nextFrameIndex = this._durationTween, this.movementEvent(this._armature, ccs.MovementEventType.start, this._movementID);
                        break
                    }
                    break;
                case ccs.ANIMATION_TYPE_MAX:
                case ccs.ANIMATION_TYPE_SINGLE_FRAME:
                    a = 1, this._isComplete = !0, this._isPlaying = !1, this.movementEvent(this._armature, ccs.MovementEventType.complete, this._movementID), this.updateMovementList();
                    break;
                case ccs.ANIMATION_TYPE_TO_LOOP_FRONT:
                    this._loopType = ccs.ANIMATION_TYPE_LOOP_FRONT, a = ccs.fmodf(a, 1), this._currentFrame = 0 == this._nextFrameIndex ? 0 : ccs.fmodf(this._currentFrame, this._nextFrameIndex), this._nextFrameIndex = this._durationTween > 0 ? this._durationTween : 1, this.movementEvent(this, ccs.MovementEventType.start, this._movementID);
                    break;
                default:
                    this._currentFrame = ccs.fmodf(this._currentFrame, this._nextFrameIndex), this._toIndex = 0, this.movementEvent(this._armature, ccs.MovementEventType.loopComplete, this._movementID)
            }
            this._currentPercent = a
        }
    },
    getCurrentMovementID: function() {
        return this._isComplete ? "" : this._movementID
    },
    setMovementEventCallFunc: function(a, b) {
        1 == arguments.length ? this._frameEventListener = a : 2 == arguments.length && (this._movementEventTarget = b, this._movementEventCallFunc = a)
    },
    setFrameEventCallFunc: function(a, b) {
        1 == arguments.length ? this._frameEventListener = a : 2 == arguments.length && (this._frameEventTarget = b, this._frameEventCallFunc = a)
    },
    setUserObject: function(a) {
        this._userObject = a
    },
    frameEvent: function(a, b, c, d) {
        if (this._frameEventTarget && this._frameEventCallFunc || this._frameEventListener) {
            var e = new ccs.FrameEvent;
            e.bone = a, e.frameEventName = b, e.originFrameIndex = c, e.currentFrameIndex = d, this._frameEventQueue.push(e)
        }
    },
    movementEvent: function(a, b, c) {
        if (this._movementEventTarget && this._movementEventCallFunc || this._movementEventListener) {
            var d = new ccs.MovementEvent;
            d.armature = a, d.movementType = b, d.movementID = c, this._movementEventQueue.push(d)
        }
    },
    updateMovementList: function() {
        if (this._onMovementList) {
            var a, b = this._movementList;
            this._movementListLoop ? (a = b[this._movementIndex], this.play(a, a.durationTo, 0), this._movementIndex++, this._movementIndex >= b.length && (this._movementIndex = 0)) : this._movementIndex < b.length ? (a = b[this._movementIndex], this.play(a, a.durationTo, 0), this._movementIndex++) : this._onMovementList = !1, this._onMovementList = !0
        }
    },
    setAnimationData: function(a) {
        this._animationData != a && (this._animationData = a)
    },
    getAnimationData: function() {
        return this._animationData
    },
    getUserObject: function() {
        return this._userObject
    },
    isIgnoreFrameEvent: function() {
        return this._ignoreFrameEvent
    }
});
var _p = ccs.ArmatureAnimation.prototype;
_p.speedScale, cc.defineGetterSetter(_p, "speedScale", _p.getSpeedScale, _p.setSpeedScale), _p.animationScale, cc.defineGetterSetter(_p, "animationScale", _p.getAnimationScale, _p.setAnimationScale), _p = null, ccs.ArmatureAnimation.create = function(a) {
    return new ccs.ArmatureAnimation(a)
}, ccs.Tween = ccs.ProcessBase.extend({
    _tweenData: null,
    _to: null,
    _from: null,
    _between: null,
    _movementBoneData: null,
    _bone: null,
    _frameTweenEasing: 0,
    _betweenDuration: 0,
    _totalDuration: 0,
    _toIndex: 0,
    _fromIndex: 0,
    _animation: null,
    _passLastFrame: !1,
    ctor: function(a) {
        ccs.ProcessBase.prototype.ctor.call(this), this._frameTweenEasing = ccs.TweenType.linear, ccs.Tween.prototype.init.call(this, a)
    },
    init: function(a) {
        return this._from = new ccs.FrameData, this._between = new ccs.FrameData, this._bone = a, this._tweenData = this._bone.getTweenData(), this._tweenData.displayIndex = -1, this._animation = null != this._bone && null != this._bone.getArmature() ? this._bone.getArmature().getAnimation() : null, !0
    },
    play: function(a, b, c, d, e) {
        ccs.ProcessBase.prototype.play.call(this, b, c, d, e), this._loopType = d ? ccs.ANIMATION_TYPE_TO_LOOP_FRONT : ccs.ANIMATION_TYPE_NO_LOOP, this._totalDuration = 0, this._betweenDuration = 0, this._fromIndex = this._toIndex = 0;
        var f = a != this._movementBoneData;
        this.setMovementBoneData(a), this._rawDuration = this._movementBoneData.duration;
        var g = this._movementBoneData.getFrameData(0);
        this._tweenData.displayIndex = g.displayIndex, this._bone.getArmature().getArmatureData().dataVersion >= ccs.CONST_VERSION_COMBINED && (ccs.TransformHelp.nodeSub(this._tweenData, this._bone.getBoneData()), this._tweenData.scaleX += 1, this._tweenData.scaleY += 1), 0 == this._rawDuration ? (this._loopType = ccs.ANIMATION_TYPE_SINGLE_FRAME, 0 == b ? this.setBetween(g, g) : this.setBetween(this._tweenData, g), this._frameTweenEasing = ccs.TweenType.linear) : this._movementBoneData.frameList.length > 1 && (this._durationTween = c * this._movementBoneData.scale, d && 0 != this._movementBoneData.delay ? this.setBetween(this._tweenData, this.tweenNodeTo(this.updateFrameData(1 - this._movementBoneData.delay), this._between)) : f && 0 != b ? this.setBetween(this._tweenData, g) : this.setBetween(g, g)), this.tweenNodeTo(0)
    },
    gotoAndPlay: function(a) {
        ccs.ProcessBase.prototype.gotoFrame.call(this, a), this._totalDuration = 0, this._betweenDuration = 0, this._fromIndex = this._toIndex = 0, this._isPlaying = !0, this._isComplete = this._isPause = !1, this._currentPercent = this._curFrameIndex / (this._rawDuration - 1), this._currentFrame = this._nextFrameIndex * this._currentPercent
    },
    gotoAndPause: function(a) {
        this.gotoAndPlay(a), this.pause()
    },
    updateHandler: function() {
        var a = this._currentPercent || 1,
            b = this._loopType;
        if (a >= 1) switch (b) {
            case ccs.ANIMATION_TYPE_SINGLE_FRAME:
                a = 1, this._isComplete = !0, this._isPlaying = !1;
                break;
            case ccs.ANIMATION_TYPE_NO_LOOP:
                if (b = ccs.ANIMATION_TYPE_MAX, a = this._durationTween <= 0 ? 1 : (a - 1) * this._nextFrameIndex / this._durationTween, a >= 1) {
                    a = 1, this._isComplete = !0, this._isPlaying = !1;
                    break
                }
                this._nextFrameIndex = this._durationTween, this._currentFrame = a * this._nextFrameIndex, this._totalDuration = 0, this._betweenDuration = 0, this._fromIndex = this._toIndex = 0;
                break;
            case ccs.ANIMATION_TYPE_TO_LOOP_FRONT:
                b = ccs.ANIMATION_TYPE_LOOP_FRONT, this._nextFrameIndex = this._durationTween > 0 ? this._durationTween : 1, 0 != this._movementBoneData.delay ? (this._currentFrame = (1 - this._movementBoneData.delay) * this._nextFrameIndex, a = this._currentFrame / this._nextFrameIndex) : (a = 0, this._currentFrame = 0), this._totalDuration = 0, this._betweenDuration = 0, this._fromIndex = this._toIndex = 0;
                break;
            case ccs.ANIMATION_TYPE_MAX:
                a = 1, this._isComplete = !0, this._isPlaying = !1;
                break;
            default:
                this._currentFrame = ccs.fmodf(this._currentFrame, this._nextFrameIndex)
        }
        1 > a && b < ccs.ANIMATION_TYPE_TO_LOOP_BACK && (a = Math.sin(a * cc.PI / 2)), this._currentPercent = a, this._loopType = b, b > ccs.ANIMATION_TYPE_TO_LOOP_BACK && (a = this.updateFrameData(a)), this._frameTweenEasing != ccs.TweenType.tweenEasingMax && this.tweenNodeTo(a)
    },
    setBetween: function(a, b, c) {
        void 0 === c && (c = !0);
        do {
            if (a.displayIndex < 0 && b.displayIndex >= 0) {
                this._from.copy(b), this._between.subtract(b, b, c);
                break
            }
            if (b.displayIndex < 0 && a.displayIndex >= 0) {
                this._from.copy(a), this._between.subtract(b, b, c);
                break
            }
            this._from.copy(a), this._between.subtract(a, b, c)
        } while (0);
        a.isTween || (this._tweenData.copy(a), this._tweenData.isTween = !0), this.arriveKeyFrame(a)
    },
    arriveKeyFrame: function(a) {
        if (a) {
            var b = this._bone,
                c = b.getDisplayManager(),
                d = a.displayIndex;
            c.getForceChangeDisplay() || c.changeDisplayWithIndex(d, !1), this._tweenData.zOrder = a.zOrder, b.updateZOrder(), this._bone.setBlendFunc(a.blendFunc);
            var e = b.getChildArmature();
            e && "" != a.movement && e.getAnimation().play(a.movement)
        }
    },
    tweenNodeTo: function(a, b) {
        b || (b = this._tweenData);
        var c = this._from,
            d = this._between;
        return c.isTween || (a = 0), b.x = c.x + a * d.x, b.y = c.y + a * d.y, b.scaleX = c.scaleX + a * d.scaleX, b.scaleY = c.scaleY + a * d.scaleY, b.skewX = c.skewX + a * d.skewX, b.skewY = c.skewY + a * d.skewY, this._bone.setTransformDirty(!0), b && d.isUseColorInfo && this.tweenColorTo(a, b), b
    },
    tweenColorTo: function(a, b) {
        var c = this._from,
            d = this._between;
        b.a = c.a + a * d.a, b.r = c.r + a * d.r, b.g = c.g + a * d.g, b.b = c.b + a * d.b, this._bone.updateColor()
    },
    updateFrameData: function(a) {
        a > 1 && 0 != this._movementBoneData.delay && (a = ccs.fmodf(a, 1));
        var b, c, d = (this._rawDuration - 1) * a,
            e = this._totalDuration,
            f = this._betweenDuration,
            g = this._toIndex;
        if (e > d || d >= e + f) {
            var h = this._movementBoneData.frameList,
                i = h.length;
            if (d < h[0].frameID) return b = c = h[0], this.setBetween(b, c), this._currentPercent;
            if (d >= h[i - 1].frameID) {
                if (this._passLastFrame) return b = c = h[i - 1], this.setBetween(b, c), this._currentPercent;
                this._passLastFrame = !0
            } else this._passLastFrame = !1;
            do
                if (this._fromIndex = g, b = h[this._fromIndex], e = b.frameID, g = this._fromIndex + 1, g >= i && (g = 0), c = h[g], b.strEvent && !this._animation.isIgnoreFrameEvent() && this._animation.frameEvent(this._bone, b.strEvent, b.frameID, d), d == b.frameID || this._passLastFrame && this._fromIndex == i - 1) break;
            while (d < b.frameID || d >= c.frameID);
            f = c.frameID - b.frameID, this._frameTweenEasing = b.tweenEasing, this.setBetween(b, c, !1), this._totalDuration = e, this._betweenDuration = f, this._toIndex = g
        }
        a = 0 == f ? 0 : (d - this._totalDuration) / this._betweenDuration;
        var j = this._frameTweenEasing != ccs.TweenType.linear ? this._frameTweenEasing : this._tweenEasing;
        return j == ccs.TweenType.tweenEasingMax || j == ccs.TweenType.linear || this._passLastFrame || (a = ccs.TweenFunction.tweenTo(a, j, this._from.easingParams)), a
    },
    setAnimation: function(a) {
        this._animation = a
    },
    getAnimation: function() {
        return this._animation
    },
    setMovementBoneData: function(a) {
        this._movementBoneData = a
    }
});
var _p = ccs.Tween.prototype;
_p.animation, cc.defineGetterSetter(_p, "animation", _p.getAnimation, _p.setAnimation), _p = null, ccs.Tween.create = function(a) {
    return new ccs.Tween(a)
}, ccs.PT_RATIO = 32, ccs.ColliderFilter = ccs.Class.extend({
    _collisionType: 0,
    _group: 0,
    _categoryBits: 0,
    _groupIndex: 0,
    _maskBits: 0,
    ctor: function(a, b) {
        this._collisionType = a || 0, this._group = b || 0
    },
    updateShape: function(a) {
        if (a instanceof cp.Shape) a.collision_type = this._collisionType, a.group = this._group;
        else if (a instanceof Box2D.b2FilterData) {
            var b = new Box2D.b2FilterData;
            b.categoryBits = this._categoryBits, b.groupIndex = this._groupIndex, b.maskBits = this._maskBits, a.SetFilterData(b)
        }
    }
}), ccs.ColliderBody = ccs.Class.extend({
    shape: null,
    coutourData: null,
    colliderFilter: null,
    _calculatedVertexList: null,
    ctor: function(a) {
        this.shape = null, this.coutourData = a, this.colliderFilter = new ccs.ColliderFilter, ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX && (this._calculatedVertexList = [])
    },
    getContourData: function() {
        return this.coutourData
    },
    setColliderFilter: function(a) {
        this.colliderFilter = a
    },
    getCalculatedVertexList: function() {
        return this._calculatedVertexList
    },
    setB2Fixture: function(a) {
        this._fixture = a
    },
    getB2Fixture: function() {
        return this._fixture
    },
    setShape: function(a) {
        this.shape = a
    },
    getShape: function() {
        return this.shape
    },
    setContourData: function(a) {
        this.coutourData = a
    },
    getColliderFilter: function() {
        return this.colliderFilter
    }
}), ccs.ColliderDetector = ccs.Class.extend({
    _colliderBodyList: null,
    _bone: null,
    _body: null,
    _active: !1,
    _filter: null,
    helpPoint: cc.p(0, 0),
    ctor: function(a) {
        this._colliderBodyList = [], this._bone = null, this._body = null, this._active = !1, this._filter = null, ccs.ColliderDetector.prototype.init.call(this, a)
    },
    init: function(a) {
        return this._colliderBodyList.length = 0, a && (this._bone = a), this._filter = new ccs.ColliderFilter, !0
    },
    addContourData: function(a) {
        var b = new ccs.ColliderBody(a);
        if (this._colliderBodyList.push(b), ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX)
            for (var c = b.getCalculatedVertexList(), d = a.vertexList, e = 0; e < d.length; e++) {
                var f = new ccs.ContourVertex2(0, 0);
                c.push(f)
            }
    },
    addContourDataList: function(a) {
        for (var b = 0; b < a.length; b++) this.addContourData(a[b])
    },
    removeContourData: function(a) {
        var b, c = [],
            d = this._colliderBodyList;
        for (b = 0; b < d.length; b++) {
            var e = d[b];
            e && e.getContourData() == a && c.push(e)
        }
        for (b = 0; b < c.length; b++) cc.arrayRemoveObject(d, c[b])
    },
    removeAll: function() {
        this._colliderBodyList.length = 0
    },
    setActive: function(a) {
        if (this._active != a) {
            this._active = a;
            var b, c = this._body;
            if (c) {
                var d = null;
                if (this._active)
                    for (var e = 0; e < this._colliderBodyList.length; e++) d = this._colliderBodyList[e], b = d.getShape(), c.space.addShape(b);
                else
                    for (var e = 0; e < this._colliderBodyList.length; e++) d = this._colliderBodyList[e], b = d.getShape(), c.space.removeShape(b)
            }
        }
    },
    getActive: function() {
        return this._active
    },
    getColliderBodyList: function() {
        return this._colliderBodyList
    },
    setColliderFilter: function(a) {
        this._filter = a;
        for (var b = this._colliderBodyList, c = 0; c < b.length; c++) {
            var d = b[c];
            d.setColliderFilter(a), d.getShape() && d.getColliderFilter().updateShape(d.getShape())
        }
    },
    getColliderFilter: function() {
        return this._filter
    },
    updateTransform: function(a) {
        if (this._active)
            for (var b = null, c = this._body, d = this.helpPoint, e = 0; e < this._colliderBodyList.length; e++) {
                b = this._colliderBodyList[e];
                var f = b.getContourData(),
                    g = null;
                c && (g = b.getShape());
                for (var h = f.vertexList, i = b.getCalculatedVertexList(), j = 0; j < h.length; j++) {
                    if (d.x = h[j].x, d.y = h[j].y, d = cc.pointApplyAffineTransform(d, a), ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) {
                        var k = cc.p(0, 0);
                        k.x = d.x, k.y = d.y, i[j] = k
                    }
                    g && (g.verts[2 * j] = d.x, g.verts[2 * j + 1] = d.y)
                }
                if (g)
                    for (var j = 0; j < h.length; j++) {
                        var l = g.verts[(j + 1) % g.verts.length],
                            m = cp.v.normalize(cp.v.perp(cp.v.sub(l, g.verts[j])));
                        g.planes && (g.planes[j].n = m, g.planes[j].d = cp.v.dot(m, g.verts[j]))
                    }
            }
    },
    setBody: function(a) {
        this._body = a;
        for (var b, c = this._colliderBodyList, d = 0; d < c.length; d++) {
            b = c[d];
            for (var e = b.getContourData(), f = [], g = e.vertexList, h = 0; h < g.length; h++) {
                var i = g[h];
                f.push(i.x), f.push(i.y)
            }
            var j = new cp.PolyShape(this._body, f, cp.vzero);
            j.sensor = !0, j.data = this._bone, this._active && this._body.space.addShape(j), b.setShape(j), b.getColliderFilter().updateShape(j)
        }
    },
    getBody: function() {
        return this._body
    }
});
var _p = ccs.ColliderDetector.prototype;
_p.colliderFilter, cc.defineGetterSetter(_p, "colliderFilter", _p.getColliderFilter, _p.setColliderFilter), _p.active, cc.defineGetterSetter(_p, "active", _p.getActive, _p.setActive), _p.body, cc.defineGetterSetter(_p, "body", _p.getBody, _p.setBody), _p = null, ccs.ColliderDetector.create = function(a) {
    return new ccs.ColliderDetector(a)
}, ccs.Armature = ccs.Node.extend({
    animation: null,
    armatureData: null,
    batchNode: null,
    _textureAtlas: null,
    _parentBone: null,
    _boneDic: null,
    _topBoneList: null,
    _armatureIndexDic: null,
    _offsetPoint: null,
    version: 0,
    _armatureTransformDirty: !0,
    _body: null,
    _blendFunc: null,
    _className: "Armature",
    ctor: function(a, b) {
        cc.Node.prototype.ctor.call(this), this._name = "", this._topBoneList = [], this._armatureIndexDic = {}, this._offsetPoint = cc.p(0, 0), this._armatureTransformDirty = !0, this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        }, a && ccs.Armature.prototype.init.call(this, a, b)
    },
    init: function(a, b) {
        cc.Node.prototype.init.call(this), b && (this._parentBone = b), this.removeAllChildren(), this.animation = new ccs.ArmatureAnimation, this.animation.init(this), this._boneDic = {}, this._topBoneList.length = 0, this._name = a || "";
        var c, d = ccs.armatureDataManager;
        if ("" != a) {
            c = d.getAnimationData(a), cc.assert(c, "AnimationData not exist!"), this.animation.setAnimationData(c);
            var e = d.getArmatureData(a);
            cc.assert(e, "ArmatureData not exist!"), this.armatureData = e;
            var f = e.getBoneDataDic();
            for (var g in f) {
                var h = this.createBone(String(g));
                do {
                    var i = c.getMovement(c.movementNames[0]);
                    if (!i) break;
                    var j = i.getMovementBoneData(h.getName());
                    if (!j || j.frameList.length <= 0) break;
                    var k = j.getFrameData(0);
                    if (!k) break;
                    h.getTweenData().copy(k), h.changeDisplayWithIndex(k.displayIndex, !1)
                } while (0)
            }
            this.update(0), this.updateOffsetPoint()
        } else this._name = "new_armature", this.armatureData = new ccs.ArmatureData, this.armatureData.name = this._name, c = new ccs.AnimationData, c.name = this._name, d.addArmatureData(this._name, this.armatureData), d.addAnimationData(this._name, c), this.animation.setAnimationData(c);
        return this._renderCmd.initShaderCache(), this.setCascadeOpacityEnabled(!0), this.setCascadeColorEnabled(!0), !0
    },
    createBone: function(a) {
        var b = this.getBone(a);
        if (b) return b;
        var c = this.armatureData.getBoneData(a),
            d = c.parentName,
            e = null;
        return d ? (this.createBone(d), e = new ccs.Bone(a), this.addBone(e, d)) : (e = new ccs.Bone(a), this.addBone(e, "")), e.setBoneData(c), e.getDisplayManager().changeDisplayWithIndex(-1, !1), e
    },
    addBone: function(a, b) {
        cc.assert(a, "Argument must be non-nil");
        var c = this._boneDic;
        if (a.getName() && cc.assert(!c[a.getName()], "bone already added. It can't be added again"), b) {
            var d = c[b];
            d ? d.addChildBone(a) : this._topBoneList.push(a)
        } else this._topBoneList.push(a);
        a.setArmature(this), c[a.getName()] = a, this.addChild(a)
    },
    removeBone: function(a, b) {
        cc.assert(a, "bone must be added to the bone dictionary!"), a.setArmature(null), a.removeFromParent(b), cc.arrayRemoveObject(this._topBoneList, a), delete this._boneDic[a.getName()], this.removeChild(a, !0)
    },
    getBone: function(a) {
        return this._boneDic[a]
    },
    changeBoneParent: function(a, b) {
        cc.assert(a, "bone must be added to the bone dictionary!");
        var c = a.getParentBone();
        if (c && (cc.arrayRemoveObject(c.getChildren(), a), a.setParentBone(null)), b) {
            var d = this._boneDic[b];
            d ? (d.addChildBone(a), cc.arrayRemoveObject(this._topBoneList, a)) : this._topBoneList.push(a)
        }
    },
    getBoneDic: function() {
        return this._boneDic
    },
    updateOffsetPoint: function() {
        var a = this.getBoundingBox();
        this.setContentSize(a);
        var b = this._offsetPoint;
        b.x = -a.x, b.y = -a.y, 0 != a.width && 0 != a.height && this.setAnchorPoint(b.x / a.width, b.y / a.height)
    },
    getOffsetPoints: function() {
        return {
            x: this._offsetPoint.x,
            y: this._offsetPoint.y
        }
    },
    setAnimation: function(a) {
        this.animation = a
    },
    getAnimation: function() {
        return this.animation
    },
    getArmatureTransformDirty: function() {
        return this._armatureTransformDirty
    },
    update: function(a) {
        this.animation.update(a);
        for (var b = this._topBoneList, c = 0; c < b.length; c++) b[c].update(a);
        this._armatureTransformDirty = !1
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this), this.scheduleUpdate()
    },
    onExit: function() {
        cc.Node.prototype.onExit.call(this), this.unscheduleUpdate()
    },
    getBoundingBox: function() {
        for (var a, b, c, d = 0, e = !0, f = cc.rect(0, 0, 0, 0), g = this._children, h = g.length, i = 0; h > i; i++) {
            var j = g[i];
            if (j) {
                var k = j.getDisplayManager().getBoundingBox();
                if (0 == k.x && 0 == k.y && 0 == k.width && 0 == k.height) continue;
                e ? (a = k.x, b = k.y, c = k.x + k.width, d = k.y + k.height, e = !1) : (a = k.x < f.x ? k.x : f.x, b = k.y < f.y ? k.y : f.y, c = k.x + k.width > f.x + f.width ? k.x + k.width : f.x + f.width, d = k.y + k.height > f.y + f.height ? k.y + k.height : f.y + f.height), f.x = a, f.y = b, f.width = c - a, f.height = d - b
            }
        }
        return cc.rectApplyAffineTransform(f, this.getNodeToParentTransform())
    },
    getBoneAtPoint: function(a, b) {
        for (var c = this._children, d = c.length - 1; d >= 0; d--) {
            var e = c[d];
            if (e instanceof ccs.Bone && e.getDisplayManager().containPoint(a, b)) return e
        }
        return null
    },
    setParentBone: function(a) {
        this._parentBone = a;
        var b = this._boneDic;
        for (var c in b) b[c].setArmature(this)
    },
    getParentBone: function() {
        return this._parentBone
    },
    drawContour: function() {
        cc._drawingUtil.setDrawColor(255, 255, 255, 255), cc._drawingUtil.setLineWidth(1);
        var a = this._boneDic;
        for (var b in a) {
            var c = a[b],
                d = c.getColliderDetector();
            if (d)
                for (var e = d.getColliderBodyList(), f = 0; f < e.length; f++) {
                    var g = e[f],
                        h = g.getCalculatedVertexList();
                    cc._drawingUtil.drawPoly(h, h.length, !0)
                }
        }
    },
    setBody: function(a) {
        if (this._body != a) {
            this._body = a, this._body.data = this;
            for (var b, c, d = this._children, e = 0; e < d.length; e++)
                if (b = d[e], b instanceof ccs.Bone)
                    for (var f = b.getDisplayManager().getDecorativeDisplayList(), g = 0; g < f.length; g++) {
                        c = f[g];
                        var h = c.getColliderDetector();
                        h && h.setBody(this._body)
                    }
        }
    },
    getShapeList: function() {
        return this._body ? this._body.shapeList : null
    },
    getBody: function() {
        return this._body
    },
    setBlendFunc: function(a, b) {
        void 0 === b ? (this._blendFunc.src = a.src, this._blendFunc.dst = a.dst) : (this._blendFunc.src = a, this._blendFunc.dst = b)
    },
    getBlendFunc: function() {
        return new cc.BlendFunc(this._blendFunc.src, this._blendFunc.dst)
    },
    setColliderFilter: function(a) {
        var b = this._boneDic;
        for (var c in b) b[c].setColliderFilter(a)
    },
    getArmatureData: function() {
        return this.armatureData
    },
    setArmatureData: function(a) {
        this.armatureData = a
    },
    getBatchNode: function() {
        return this.batchNode
    },
    setBatchNode: function(a) {
        this.batchNode = a
    },
    getVersion: function() {
        return this.version
    },
    setVersion: function(a) {
        this.version = a
    },
    _createRenderCmd: function() {
        return cc._renderType === cc._RENDER_TYPE_CANVAS ? new ccs.Armature.CanvasRenderCmd(this) : new ccs.Armature.WebGLRenderCmd(this)
    }
});
var _p = ccs.Armature.prototype;
_p.parentBone, cc.defineGetterSetter(_p, "parentBone", _p.getParentBone, _p.setParentBone), _p.body, cc.defineGetterSetter(_p, "body", _p.getBody, _p.setBody), _p.colliderFilter, cc.defineGetterSetter(_p, "colliderFilter", null, _p.setColliderFilter), _p = null, ccs.Armature.create = function(a, b) {
        return new ccs.Armature(a, b)
    },
    function() {
        ccs.Armature.RenderCmd = {
            _updateAnchorPointInPoint: function() {
                var a = this._node,
                    b = a._contentSize,
                    c = a._anchorPoint,
                    d = a._offsetPoint;
                this._anchorPointInPoints.x = b.width * c.x - d.x, this._anchorPointInPoints.y = b.height * c.y - d.y, this._realAnchorPointInPoints.x = b.width * c.x, this._realAnchorPointInPoints.y = b.height * c.y, this.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
            },
            getAnchorPointInPoints: function() {
                return cc.p(this._realAnchorPointInPoints)
            }
        }
    }(),
    function() {
        ccs.Armature.CanvasRenderCmd = function(a) {
            cc.Node.CanvasRenderCmd.call(this, a), this._needDraw = !0, this._realAnchorPointInPoints = new cc.Point(0, 0), this._startRenderCmd = new cc.CustomRenderCmd(this, this._startCmdCallback), this._RestoreRenderCmd = new cc.CustomRenderCmd(this, this._RestoreCmdCallback)
        };
        var a = ccs.Armature.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
        cc.inject(ccs.Armature.RenderCmd, a), a.constructor = ccs.Armature.CanvasRenderCmd, a._startCmdCallback = function(a, b, c) {
            var d = this._node,
                e = d._parent;
            this.transform(e ? e._renderCmd : null);
            var f = a || cc._renderContext;
            f.save(), f._switchToArmatureMode(!0, this._worldTransform, b, c)
        }, a.transform = function(a, b) {
            ccs.Node.CanvasRenderCmd.prototype.transform.call(this, a, b);
            var c = this._node._children;
            window.allBones = c;
            for (var d = 0, e = c.length; e > d; d++) {
                var f = c[d];
                if (f && f.getDisplayRenderNode) {
                    var g = f.getDisplayRenderNode();
                    g && g._renderCmd && g._renderCmd.transform(null)
                }
            }
        }, a._RestoreCmdCallback = function(a) {
            this._cacheDirty = !1, a._switchToArmatureMode(!1), a.restore()
        }, a.initShaderCache = function() {}, a.setShaderProgram = function() {}, a.updateChildPosition = function(a, b) {
            cc.renderer.pushRenderCommand(b._renderCmd)
        }, a.rendering = function(a, b, c) {
            for (var d = this._node, e = d._children, f = cc.BlendFunc.ALPHA_PREMULTIPLIED, g = cc.BlendFunc.ALPHA_NON_PREMULTIPLIED, h = 0, i = e.length; i > h; h++) {
                var j = e[h];
                if (j && j.getDisplayRenderNode) {
                    var k = j.getDisplayRenderNode();
                    if (null == k) continue;
                    switch (j.getDisplayRenderNodeType()) {
                        case ccs.DISPLAY_TYPE_SPRITE:
                            k instanceof ccs.Skin && this.updateChildPosition(a, k, j, f, g);
                            break;
                        case ccs.DISPLAY_TYPE_ARMATURE:
                            k._renderCmd.rendering(a, b, c);
                            break;
                        default:
                            k.visit(this)
                    }
                } else j instanceof cc.Node && this._visitNormalChild(j)
            }
        }, a._visitNormalChild = function(a) {
            if (null != a) {
                var b = a._renderCmd;
                if (a._visible) {
                    b._curLevel = this._curLevel + 1;
                    var c, d, e = a._children;
                    b._syncStatus(this), b.transform(null);
                    var f = e.length;
                    if (f > 0) {
                        for (a.sortAllChildren(), c = 0; f > c && (d = e[c], d._localZOrder < 0); c++) d._renderCmd.visit(b);
                        for (cc.renderer.pushRenderCommand(b); f > c; c++) e[c]._renderCmd.visit(b)
                    } else cc.renderer.pushRenderCommand(b);
                    this._dirtyFlag = 0
                }
            }
        }, a.visit = function(a) {
            var b = this._node;
            b._visible && (this.updateStatus(a), b.sortAllChildren(), cc.renderer.pushRenderCommand(this._startRenderCmd), this.rendering(), cc.renderer.pushRenderCommand(this._RestoreRenderCmd), this._cacheDirty = !1)
        }
    }(), ccs.Bone = ccs.Node.extend({
        _boneData: null,
        _armature: null,
        _childArmature: null,
        _displayManager: null,
        ignoreMovementBoneData: !1,
        _tween: null,
        _tweenData: null,
        _parentBone: null,
        _boneTransformDirty: !1,
        _worldTransform: null,
        _blendFunc: null,
        blendDirty: !1,
        _worldInfo: null,
        _armatureParentBone: null,
        _dataVersion: 0,
        _className: "Bone",
        ctor: function(a) {
            cc.Node.prototype.ctor.call(this), this._tweenData = null, this._parentBone = null, this._armature = null, this._childArmature = null, this._boneData = null, this._tween = null, this._displayManager = null, this.ignoreMovementBoneData = !1, this._worldTransform = cc.affineTransformMake(1, 0, 0, 1, 0, 0), this._boneTransformDirty = !0, this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST), this.blendDirty = !1, this._worldInfo = null, this._armatureParentBone = null, this._dataVersion = 0, ccs.Bone.prototype.init.call(this, a)
        },
        init: function(a) {
            return a && (this._name = a), this._tweenData = new ccs.FrameData, this._tween = new ccs.Tween(this), this._displayManager = new ccs.DisplayManager(this), this._worldInfo = new ccs.BaseData, this._boneData = new ccs.BaseData, !0
        },
        setBoneData: function(a) {
            cc.assert(a, "_boneData must not be null"), this._boneData != a && (this._boneData = a), this.setName(this._boneData.name), this._localZOrder = this._boneData.zOrder, this._displayManager.initDisplayList(a)
        },
        getBoneData: function() {
            return this._boneData
        },
        setArmature: function(a) {
            this._armature = a, a ? (this._tween.setAnimation(this._armature.getAnimation()), this._dataVersion = this._armature.getArmatureData().dataVersion, this._armatureParentBone = this._armature.getParentBone()) : this._armatureParentBone = null
        },
        getArmature: function() {
            return this._armature
        },
        update: function(a) {
            if (this._parentBone && (this._boneTransformDirty = this._boneTransformDirty || this._parentBone.isTransformDirty()), this._armatureParentBone && !this._boneTransformDirty && (this._boneTransformDirty = this._armatureParentBone.isTransformDirty()), this._boneTransformDirty) {
                var b = this._tweenData;
                this._dataVersion >= ccs.CONST_VERSION_COMBINED && (ccs.TransformHelp.nodeConcat(b, this._boneData), b.scaleX -= 1, b.scaleY -= 1);
                var c = this._worldInfo;
                c.copy(b), c.x = b.x + this._position.x, c.y = b.y + this._position.y, c.scaleX = b.scaleX * this._scaleX, c.scaleY = b.scaleY * this._scaleY, c.skewX = b.skewX + this._skewX + cc.degreesToRadians(this._rotationX), c.skewY = b.skewY + this._skewY - cc.degreesToRadians(this._rotationY), this._parentBone ? this._applyParentTransform(this._parentBone) : this._armatureParentBone && this._applyParentTransform(this._armatureParentBone), ccs.TransformHelp.nodeToMatrix(c, this._worldTransform), this._armatureParentBone && (this._worldTransform = cc.affineTransformConcat(this._worldTransform, this._armature.getNodeToParentTransform()))
            }
            ccs.displayFactory.updateDisplay(this, a, this._boneTransformDirty || this._armature.getArmatureTransformDirty());
            for (var d = 0; d < this._children.length; d++) {
                var e = this._children[d];
                e.update(a)
            }
            this._boneTransformDirty = !1
        },
        _applyParentTransform: function(a) {
            var b = this._worldInfo,
                c = a._worldTransform,
                d = a._worldInfo,
                e = b.x,
                f = b.y;
            b.x = e * c.a + f * c.c + d.x, b.y = e * c.b + f * c.d + d.y, b.scaleX = b.scaleX * d.scaleX, b.scaleY = b.scaleY * d.scaleY, b.skewX = b.skewX + d.skewX, b.skewY = b.skewY + d.skewY
        },
        setBlendFunc: function(a, b) {
            var c, d, e = this._blendFunc;
            void 0 === b ? (c = a.src, d = a.dst) : (c = a, d = b), (e.src != c || e.dst != d) && (e.src = c, e.dst = d, this.blendDirty = !0)
        },
        updateDisplayedColor: function(a) {
            this._realColor = cc.color(255, 255, 255), cc.Node.prototype.updateDisplayedColor.call(this, a), this.updateColor()
        },
        updateDisplayedOpacity: function(a) {
            this._realOpacity = 255, cc.Node.prototype.updateDisplayedOpacity.call(this, a), this.updateColor()
        },
        updateColor: function() {
            var a = this._displayManager.getDisplayRenderNode();
            null != a && (a.setColor(cc.color(this._displayedColor.r * this._tweenData.r / 255, this._displayedColor.g * this._tweenData.g / 255, this._displayedColor.b * this._tweenData.b / 255)), a.setOpacity(this._displayedOpacity * this._tweenData.a / 255))
        },
        updateZOrder: function() {
            this.setLocalZOrder(this._armature.getArmatureData().dataVersion >= ccs.CONST_VERSION_COMBINED ? this._tweenData.zOrder + this._boneData.zOrder : this._tweenData.zOrder)
        },
        addChildBone: function(a) {
            cc.assert(a, "Argument must be non-nil"), cc.assert(!a.parentBone, "child already added. It can't be added again"), this._children.indexOf(a) < 0 && (this._children.push(a), a.setParentBone(this))
        },
        removeChildBone: function(a, b) {
            if (this._children.length > 0 && -1 != this._children.getIndex(a)) {
                if (b)
                    for (var c = a._children, d = 0; d < c.length; d++) {
                        var e = c[d];
                        a.removeChildBone(e, b)
                    }
                a.setParentBone(null), a.getDisplayManager().setCurrentDecorativeDisplay(null), cc.arrayRemoveObject(this._children, a)
            }
        },
        removeFromParent: function(a) {
            this._parentBone && this._parentBone.removeChildBone(this, a)
        },
        setParentBone: function(a) {
            this._parentBone = a
        },
        getParentBone: function() {
            return this._parentBone
        },
        setChildArmature: function(a) {
            this._childArmature != a && (null == a && this._childArmature && this._childArmature.setParentBone(null), this._childArmature = a)
        },
        getChildArmature: function() {
            return this._childArmature
        },
        getTween: function() {
            return this._tween
        },
        setLocalZOrder: function(a) {
            this._localZOrder != a && cc.Node.prototype.setLocalZOrder.call(this, a)
        },
        getNodeToArmatureTransform: function() {
            return this._worldTransform
        },
        getNodeToWorldTransform: function() {
            return cc.affineTransformConcat(this._worldTransform, this._armature.getNodeToWorldTransform())
        },
        getDisplayRenderNode: function() {
            return this._displayManager.getDisplayRenderNode()
        },
        getDisplayRenderNodeType: function() {
            return this._displayManager.getDisplayRenderNodeType()
        },
        addDisplay: function(a, b) {
            return b = b || 0, this._displayManager.addDisplay(a, b)
        },
        removeDisplay: function(a) {
            this._displayManager.removeDisplay(a)
        },
        changeDisplayByIndex: function(a, b) {
            cc.log("changeDisplayByIndex is deprecated. Use changeDisplayWithIndex instead."), this.changeDisplayWithIndex(a, b)
        },
        changeDisplayByName: function(a, b) {
            cc.log("changeDisplayByName is deprecated. Use changeDisplayWithName instead."), this.changeDisplayWithName(a, b)
        },
        changeDisplayWithIndex: function(a, b) {
            this._displayManager.changeDisplayWithIndex(a, b)
        },
        changeDisplayWithName: function(a, b) {
            this._displayManager.changeDisplayWithName(a, b)
        },
        getColliderDetector: function() {
            var a = this._displayManager.getCurrentDecorativeDisplay();
            if (a) {
                var b = a.getColliderDetector();
                if (b) return b
            }
            return null
        },
        setColliderFilter: function(a) {
            for (var b = this._displayManager.getDecorativeDisplayList(), c = 0; c < b.length; c++) {
                var d = b[c],
                    e = d.getColliderDetector();
                e && e.setColliderFilter(a)
            }
        },
        getColliderFilter: function() {
            var a = this.displayManager.getCurrentDecorativeDisplay();
            if (a) {
                var b = a.getColliderDetector();
                if (b) return b.getColliderFilter()
            }
            return null
        },
        setTransformDirty: function(a) {
            this._boneTransformDirty = a
        },
        isTransformDirty: function() {
            return this._boneTransformDirty
        },
        getDisplayManager: function() {
            return this._displayManager
        },
        setIgnoreMovementBoneData: function(a) {
            this._ignoreMovementBoneData = a
        },
        isIgnoreMovementBoneData: function() {
            return this._ignoreMovementBoneData
        },
        getBlendFunc: function() {
            return new cc.BlendFunc(this._blendFunc.src, this._blendFunc.dst)
        },
        setBlendDirty: function(a) {
            this._blendDirty = a
        },
        isBlendDirty: function() {
            return this._blendDirty
        },
        getTweenData: function() {
            return this._tweenData
        },
        getWorldInfo: function() {
            return this._worldInfo
        },
        getChildrenBone: function() {
            return this._children
        },
        nodeToArmatureTransform: function() {
            return this.getNodeToArmatureTransform()
        },
        nodeToWorldTransform: function() {
            return this.getNodeToWorldTransform()
        },
        getColliderBodyList: function() {
            var a = this.getColliderDetector();
            return a ? a.getColliderBodyList() : null
        },
        getIgnoreMovementBoneData: function() {
            return this.isIgnoreMovementBoneData()
        },
        _createRenderCmd: function() {
            return cc._renderType === cc._RENDER_TYPE_CANVAS ? new ccs.Bone.CanvasRenderCmd(this) : new ccs.Bone.WebGLRenderCmd(this)
        }
    });
var _p = ccs.Bone.prototype;
_p.boneData, cc.defineGetterSetter(_p, "boneData", _p.getBoneData, _p.setBoneData), _p.armature, cc.defineGetterSetter(_p, "armature", _p.getArmature, _p.setArmature), _p.childArmature, cc.defineGetterSetter(_p, "childArmature", _p.getChildArmature, _p.setChildArmature), _p.childrenBone, cc.defineGetterSetter(_p, "childrenBone", _p.getChildrenBone), _p.tween, cc.defineGetterSetter(_p, "tween", _p.getTween), _p.tweenData, cc.defineGetterSetter(_p, "tweenData", _p.getTweenData), _p.colliderFilter, cc.defineGetterSetter(_p, "colliderFilter", _p.getColliderFilter, _p.setColliderFilter), _p = null, ccs.Bone.create = function(a) {
        return new ccs.Bone(a)
    }, ccs.Bone.RenderCmd = {
        _updateColor: function() {
            var a = this._node,
                b = a._displayManager.getDisplayRenderNode();
            if (null != b) {
                var c = b._renderCmd;
                b.setColor(cc.color(a._tweenData.r, a._tweenData.g, a._tweenData.g)), b.setOpacity(a._tweenData.a), c._syncDisplayColor(this._displayedColor), c._syncDisplayOpacity(this._displayedOpacity), c._updateColor()
            }
        }
    },
    function() {
        ccs.Bone.CanvasRenderCmd = function(a) {
            cc.Node.CanvasRenderCmd.call(this, a), this._needDraw = !1
        };
        var a = ccs.Bone.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
        cc.inject(ccs.Bone.RenderCmd, a), a.constructor = ccs.Bone.CanvasRenderCmd
    }(),
    function() {
        ccs.Bone.WebGLRenderCmd = function(a) {
            cc.Node.WebGLRenderCmd.call(this, a), this._needDraw = !1
        };
        var a = ccs.Bone.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
        cc.inject(ccs.Bone.RenderCmd, a), a.constructor = ccs.Bone.WebGLRenderCmd
    }(), ccs.FRAME_TYPE_MOVE = 0, ccs.FRAME_TYPE_SCALE = 1, ccs.FRAME_TYPE_ROTATE = 2, ccs.FRAME_TYPE_TINT = 3, ccs.FRAME_TYPE_FADE = 4, ccs.FRAME_TYPE_MAX = 5, ccs.FrameEaseType = {
        Custom: -1,
        Linear: 0,
        Sine_EaseIn: 1,
        Sine_EaseOut: 2,
        Sine_EaseInOut: 3,
        Quad_EaseIn: 4,
        Quad_EaseOut: 5,
        Quad_EaseInOut: 6,
        Cubic_EaseIn: 7,
        Cubic_EaseOut: 8,
        Cubic_EaseInOut: 9,
        Quart_EaseIn: 10,
        Quart_EaseOut: 11,
        Quart_EaseInOut: 12,
        Quint_EaseIn: 13,
        Quint_EaseOut: 14,
        Quint_EaseInOut: 15,
        Expo_EaseIn: 16,
        Expo_EaseOut: 17,
        Expo_EaseInOut: 18,
        Circ_EaseIn: 19,
        Circ_EaseOut: 20,
        Circ_EaseInOut: 21,
        Elastic_EaesIn: 22,
        Elastic_EaesOut: 23,
        Elastic_EaesInOut: 24,
        Back_EaseIn: 25,
        Back_EaseOut: 26,
        Back_EaseInOut: 27,
        Bounce_EaseIn: 28,
        Bounce_EaseOut: 29,
        Bounce_EaseInOut: 30
    }, ccs.ActionFrame = ccs.Class.extend({
        frameType: 0,
        easingType: 0,
        frameIndex: 0,
        _Parameter: null,
        time: 0,
        ctor: function() {
            this.frameType = 0, this.easingType = ccs.FrameEaseType.Linear, this.frameIndex = 0, this.time = 0
        },
        getAction: function() {
            return cc.log("Need a definition of <getAction> for ActionFrame"), null
        },
        _getEasingAction: function(a) {
            if (null === a) return console.error("Action cannot be null!"), null;
            var b;
            switch (this.easingType) {
                case ccs.FrameEaseType.Custom:
                    break;
                case ccs.FrameEaseType.Linear:
                    b = a;
                    break;
                case ccs.FrameEaseType.Sine_EaseIn:
                    b = a.easing(cc.easeSineIn());
                    break;
                case ccs.FrameEaseType.Sine_EaseOut:
                    b = a.easing(cc.easeSineOut());
                    break;
                case ccs.FrameEaseType.Sine_EaseInOut:
                    b = a.easing(cc.easeSineInOut());
                    break;
                case ccs.FrameEaseType.Quad_EaseIn:
                    b = a.easing(cc.easeQuadraticActionIn());
                    break;
                case ccs.FrameEaseType.Quad_EaseOut:
                    b = a.easing(cc.easeQuadraticActionOut());
                    break;
                case ccs.FrameEaseType.Quad_EaseInOut:
                    b = a.easing(cc.easeQuadraticActionInOut());
                    break;
                case ccs.FrameEaseType.Cubic_EaseIn:
                    b = a.easing(cc.easeCubicActionIn());
                    break;
                case ccs.FrameEaseType.Cubic_EaseOut:
                    b = a.easing(cc.easeCubicActionOut());
                    break;
                case ccs.FrameEaseType.Cubic_EaseInOut:
                    b = a.easing(cc.easeCubicActionInOut());
                    break;
                case ccs.FrameEaseType.Quart_EaseIn:
                    b = a.easing(cc.easeQuarticActionIn());
                    break;
                case ccs.FrameEaseType.Quart_EaseOut:
                    b = a.easing(cc.easeQuarticActionOut());
                    break;
                case ccs.FrameEaseType.Quart_EaseInOut:
                    b = a.easing(cc.easeQuarticActionInOut());
                    break;
                case ccs.FrameEaseType.Quint_EaseIn:
                    b = a.easing(cc.easeQuinticActionIn());
                    break;
                case ccs.FrameEaseType.Quint_EaseOut:
                    b = a.easing(cc.easeQuinticActionOut());
                    break;
                case ccs.FrameEaseType.Quint_EaseInOut:
                    b = a.easing(cc.easeQuinticActionInOut());
                    break;
                case ccs.FrameEaseType.Expo_EaseIn:
                    b = a.easing(cc.easeExponentialIn());
                    break;
                case ccs.FrameEaseType.Expo_EaseOut:
                    b = a.easing(cc.easeExponentialOut());
                    break;
                case ccs.FrameEaseType.Expo_EaseInOut:
                    b = a.easing(cc.easeExponentialInOut());
                    break;
                case ccs.FrameEaseType.Circ_EaseIn:
                    b = a.easing(cc.easeCircleActionIn());
                    break;
                case ccs.FrameEaseType.Circ_EaseOut:
                    b = a.easing(cc.easeCircleActionOut());
                    break;
                case ccs.FrameEaseType.Circ_EaseInOut:
                    b = a.easing(cc.easeCircleActionInOut());
                    break;
                case ccs.FrameEaseType.Elastic_EaesIn:
                    b = a.easing(cc.easeElasticIn());
                    break;
                case ccs.FrameEaseType.Elastic_EaesOut:
                    b = a.easing(cc.easeElasticOut());
                    break;
                case ccs.FrameEaseType.Elastic_EaesInOut:
                    b = a.easing(cc.easeElasticInOut());
                    break;
                case ccs.FrameEaseType.Back_EaseIn:
                    b = a.easing(cc.easeBackIn());
                    break;
                case ccs.FrameEaseType.Back_EaseOut:
                    b = a.easing(cc.easeBackOut());
                    break;
                case ccs.FrameEaseType.Back_EaseInOut:
                    b = a.easing(cc.easeBackInOut());
                    break;
                case ccs.FrameEaseType.Bounce_EaseIn:
                    b = a.easing(cc.easeBounceIn());
                    break;
                case ccs.FrameEaseType.Bounce_EaseOut:
                    b = a.easing(cc.easeBounceOut());
                    break;
                case ccs.FrameEaseType.Bounce_EaseInOut:
                    b = a.easing(cc.easeBounceInOut())
            }
            return b
        },
        setEasingParameter: function(a) {
            this._Parameter = [];
            for (var b = 0; b < a.length; b++) this._Parameter.push(a[b])
        },
        setEasingType: function(a) {
            this.easingType = a
        }
    }), ccs.ActionMoveFrame = ccs.ActionFrame.extend({
        _position: null,
        ctor: function() {
            ccs.ActionFrame.prototype.ctor.call(this), this._position = cc.p(0, 0), this.frameType = ccs.FRAME_TYPE_MOVE
        },
        setPosition: function(a, b) {
            void 0 === b ? (this._position.x = a.x, this._position.y = a.y) : (this._position.x = a, this._position.y = b)
        },
        getPosition: function() {
            return this._position
        },
        getAction: function(a) {
            return this._getEasingAction(cc.moveTo(a, this._position))
        }
    }), ccs.ActionScaleFrame = ccs.ActionFrame.extend({
        _scaleX: 1,
        _scaleY: 1,
        ctor: function() {
            ccs.ActionFrame.prototype.ctor.call(this), this._scaleX = 1, this._scaleY = 1, this.frameType = ccs.FRAME_TYPE_SCALE
        },
        setScaleX: function(a) {
            this._scaleX = a
        },
        getScaleX: function() {
            return this._scaleX
        },
        setScaleY: function(a) {
            this._scaleY = a
        },
        getScaleY: function() {
            return this._scaleY
        },
        getAction: function(a) {
            return this._getEasingAction(cc.scaleTo(a, this._scaleX, this._scaleY))
        }
    }), ccs.ActionRotationFrame = ccs.ActionFrame.extend({
        _rotation: 0,
        ctor: function() {
            ccs.ActionFrame.prototype.ctor.call(this), this._rotation = 0, this.frameType = ccs.FRAME_TYPE_ROTATE
        },
        setRotation: function(a) {
            this._rotation = a
        },
        getRotation: function() {
            return this._rotation
        },
        getAction: function(a, b) {
            if (void 0 === b) return this._getEasingAction(cc.rotateTo(a, this._rotation));
            if (b instanceof cc.ActionRotationFrame) {
                var c = this._rotation - b._rotation;
                return this._getEasingAction(cc.rotateBy(a, c))
            }
            return this.getAction(a)
        }
    }), ccs.ActionFadeFrame = ccs.ActionFrame.extend({
        _opacity: 255,
        ctor: function() {
            ccs.ActionFrame.prototype.ctor.call(this), this._opacity = 255, this.frameType = ccs.FRAME_TYPE_FADE
        },
        setOpacity: function(a) {
            this._opacity = a
        },
        getOpacity: function() {
            return this._opacity
        },
        getAction: function(a) {
            return this._getEasingAction(cc.fadeTo(a, this._opacity))
        }
    }), ccs.ActionTintFrame = ccs.ActionFrame.extend({
        _color: null,
        ctor: function() {
            ccs.ActionFrame.prototype.ctor.call(this), this._color = cc.color(255, 255, 255, 255), this.frameType = ccs.FRAME_TYPE_TINT
        },
        setColor: function(a) {
            var b = this._color;
            b.r = a.r, b.g = a.g, b.b = a.b
        },
        getColor: function() {
            var a = this._color;
            return cc.color(a.r, a.g, a.b, a.a)
        },
        getAction: function(a) {
            return this._getEasingAction(cc.tintTo(a, this._color.r, this._color.g, this._color.b))
        }
    }), ccs.actionManager = {
        _actionDic: {},
        initWithDictionary: function(a, b, c) {
            for (var d = a, e = d.lastIndexOf("/"), f = d.substr(e + 1, d.length), g = b.actionlist, h = [], i = 0; i < g.length; i++) {
                var j = new ccs.ActionObject,
                    k = g[i];
                j.initWithDictionary(k, c), h.push(j)
            }
            this._actionDic[f] = h
        },
        getActionByName: function(a, b) {
            var c = this._actionDic[a];
            if (!c) return null;
            for (var d = 0; d < c.length; d++) {
                var e = c[d];
                if (b == e.getName()) return e
            }
            return null
        },
        playActionByName: function(a, b, c) {
            var d = this.getActionByName(a, b);
            d && d.play(c)
        },
        stopActionByName: function(a, b) {
            var c = this.getActionByName(a, b);
            c && c.stop()
        },
        releaseActions: function() {
            this._actionDic = {}
        },
        clear: function() {
            this._actionDic = {}
        }
    }, ccs.ActionNode = ccs.Class.extend({
        _currentFrameIndex: 0,
        _destFrameIndex: 0,
        _unitTime: 0,
        _actionTag: 0,
        _object: null,
        _actionSpawn: null,
        _action: null,
        _frameArray: null,
        _frameArrayNum: 0,
        ctor: function() {
            this._currentFrameIndex = 0, this._destFrameIndex = 0, this._unitTime = .1, this._actionTag = 0, this._object = null, this._actionSpawn = null, this._action = null, this._frameArray = [], this._frameArrayNum = ccs.FRAME_TYPE_MAX;
            for (var a = 0; a < this._frameArrayNum; a++) this._frameArray.push([])
        },
        initWithDictionary: function(a, b) {
            this.setActionTag(a.ActionTag);
            for (var c = a.actionframelist, d = 0; d < c.length; d++) {
                var e = c[d],
                    f = e.frameid,
                    g = e.tweenType;
                null == g && (g = 0);
                for (var h = e.tweenParameter, i = [], j = 0; h > j; j++) {
                    var k = e.tweenParameter[j];
                    i.push(k)
                }
                var l, m;
                if (void 0 !== e.positionx) {
                    var n = e.positionx,
                        o = e.positiony;
                    l = new ccs.ActionMoveFrame, l.frameIndex = f, l.setEasingType(g), l.setEasingParameter(i), l.setPosition(n, o), m = this._frameArray[ccs.FRAME_TYPE_MOVE], m.push(l)
                }
                if (void 0 !== e.scalex) {
                    var p = e.scalex,
                        q = e.scaley;
                    l = new ccs.ActionScaleFrame, l.frameIndex = f, l.setEasingType(g), l.setEasingParameter(i), l.setScaleX(p), l.setScaleY(q), m = this._frameArray[ccs.FRAME_TYPE_SCALE], m.push(l)
                }
                if (void 0 !== e.rotation) {
                    var r = e.rotation;
                    l = new ccs.ActionRotationFrame, l.frameIndex = f, l.setEasingType(g), l.setEasingParameter(i), l.setRotation(r), m = this._frameArray[ccs.FRAME_TYPE_ROTATE], m.push(l)
                }
                if (void 0 !== e.opacity) {
                    var s = e.opacity;
                    l = new ccs.ActionFadeFrame, l.frameIndex = f, l.setEasingType(g), l.setEasingParameter(i), l.setOpacity(s), m = this._frameArray[ccs.FRAME_TYPE_FADE], m.push(l)
                }
                if (void 0 !== e.colorr) {
                    var t = e.colorr,
                        u = e.colorg,
                        v = e.colorb;
                    l = new ccs.ActionTintFrame, l.frameIndex = f, l.setEasingType(g), l.setEasingParameter(i), l.setColor(cc.color(t, u, v)), m = this._frameArray[ccs.FRAME_TYPE_TINT], m.push(l)
                }
                e = null
            }
            this._initActionNodeFromRoot(b)
        },
        _initActionNodeFromRoot: function(a) {
            if (a instanceof ccui.Widget) {
                var b = ccui.helper.seekActionWidgetByActionTag(a, this.getActionTag());
                b && this.setObject(b)
            }
        },
        setUnitTime: function(a) {
            this._unitTime = a, this._refreshActionProperty()
        },
        getUnitTime: function() {
            return this._unitTime
        },
        setActionTag: function(a) {
            this._actionTag = a
        },
        getActionTag: function() {
            return this._actionTag
        },
        setObject: function(a) {
            this._object = a
        },
        getObject: function() {
            return this._object
        },
        getActionNode: function() {
            return this._object instanceof cc.Node ? this._object : null
        },
        insertFrame: function(a, b) {
            if (null != b) {
                var c = b.frameType,
                    d = this._frameArray[c];
                d.splice(a, 0, b)
            }
        },
        addFrame: function(a) {
            if (a) {
                var b = a.frameType,
                    c = this._frameArray[b];
                c.push(a)
            }
        },
        deleteFrame: function(a) {
            if (null != a) {
                var b = a.frameType,
                    c = this._frameArray[b];
                cc.arrayRemoveObject(c, a)
            }
        },
        clearAllFrame: function() {
            for (var a = 0; a < this._frameArrayNum; a++) this._frameArray[a].length = 0
        },
        _refreshActionProperty: function() {
            if (null == this._object) return null;
            for (var a = [], b = 0; b < this._frameArrayNum; b++) {
                var c = this._frameArray[b];
                if (!(c.length <= 0)) {
                    for (var d = [], e = 0; e < c.length; e++) {
                        var f = c[e];
                        if (0 != e) {
                            var g = c[e - 1],
                                h = (f.frameIndex - g.frameIndex) * this.getUnitTime(),
                                i = f.getAction(h);
                            i && d.push(i)
                        }
                    }
                    if (d) {
                        var j = cc.sequence(d);
                        null != j && a.push(j)
                    }
                }
            }
            return this._action = null, this._actionSpawn = cc.spawn(a), this._actionSpawn
        },
        playAction: function(a) {
            null != this._object && null != this._actionSpawn && (this._action = a ? cc.sequence(this._actionSpawn, a) : cc.sequence(this._actionSpawn), this._runAction())
        },
        _runAction: function() {
            var a = this.getActionNode();
            null != a && null != this._action && a.runAction(this._action)
        },
        stopAction: function() {
            var a = this.getActionNode();
            null != a && null != this._action && (this._action.isDone() || a.stopAction(this._action))
        },
        getFirstFrameIndex: function() {
            for (var a = 99999, b = !1, c = this._frameArray, d = 0, e = this._frameArrayNum; e > d; d++) {
                var f = c[d];
                if (!(f.length <= 0)) {
                    b = !0;
                    var g = f[0].frameIndex;
                    a = a > g ? g : a
                }
            }
            return b || (a = 0), a
        },
        getLastFrameIndex: function() {
            for (var a = -1, b = !1, c = this._frameArray, d = 0, e = this._frameArrayNum; e > d; d++) {
                var f = c[d];
                if (!(f.length <= 0)) {
                    b = !0;
                    var g = f[f.length - 1],
                        h = g.frameIndex;
                    a = h > a ? h : a
                }
            }
            return b || (a = 0), a
        },
        updateActionToTimeLine: function(a) {
            for (var b = !1, c = this.getUnitTime(), d = 0; d < this._frameArrayNum; d++) {
                var e = this._frameArray[d];
                if (null != e)
                    for (var f = 0; f < e.length; f++) {
                        var g = e[f];
                        if (g.frameIndex * c == a) {
                            this._easingToFrame(1, 1, g), b = !0;
                            break
                        }
                        if (g.frameIndex * c > a) {
                            if (0 == f) this._easingToFrame(1, 1, g), b = !1;
                            else {
                                var h = e[f - 1],
                                    i = (g.frameIndex - h.frameIndex) * c,
                                    j = a - h.frameIndex * c;
                                this._easingToFrame(i, 1, h), this._easingToFrame(i, j / i, g), b = !0
                            }
                            break
                        }
                    }
            }
            return b
        },
        _easingToFrame: function(a, b, c) {
            var d = c.getAction(a),
                e = this.getActionNode();
            null != d && null != e && (d.startWithTarget(e), d.update(b))
        },
        isActionDoneOnce: function() {
            return null == this._action ? !0 : this._action.isDone()
        }
    }), ccs.ActionObject = ccs.Class.extend({
        _actionNodeList: null,
        _name: "",
        _loop: !1,
        _pause: !1,
        _playing: !1,
        _unitTime: 0,
        _currentTime: 0,
        _scheduler: null,
        _callback: null,
        _fTotalTime: 0,
        ctor: function() {
            this._actionNodeList = [], this._name = "", this._loop = !1, this._pause = !1, this._playing = !1, this._unitTime = .1, this._currentTime = 0, this._fTotalTime = 0, this._scheduler = cc.director.getScheduler()
        },
        setName: function(a) {
            this._name = a
        },
        getName: function() {
            return this._name
        },
        setLoop: function(a) {
            this._loop = a
        },
        getLoop: function() {
            return this._loop
        },
        setUnitTime: function(a) {
            this._unitTime = a;
            for (var b = this._actionNodeList.length, c = 0; b > c; c++) {
                var d = this._actionNodeList[c];
                d.setUnitTime(this._unitTime)
            }
        },
        getUnitTime: function() {
            return this._unitTime
        },
        getCurrentTime: function() {
            return this._currentTime
        },
        setCurrentTime: function(a) {
            this._currentTime = a
        },
        getTotalTime: function() {
            return this._fTotalTime
        },
        isPlaying: function() {
            return this._playing
        },
        initWithDictionary: function(a, b) {
            this.setName(a.name), this.setLoop(a.loop), this.setUnitTime(a.unittime);
            for (var c = a.actionnodelist, d = 0, e = 0; e < c.length; e++) {
                var f = new ccs.ActionNode,
                    g = c[e];
                f.initWithDictionary(g, b), f.setUnitTime(this.getUnitTime()), this._actionNodeList.push(f);
                var h = f.getLastFrameIndex() - f.getFirstFrameIndex();
                h > d && (d = h)
            }
            this._fTotalTime = d * this._unitTime
        },
        addActionNode: function(a) {
            a && (this._actionNodeList.push(a), a.setUnitTime(this._unitTime))
        },
        removeActionNode: function(a) {
            null != a && cc.arrayRemoveObject(this._actionNodeList, a)
        },
        play: function(a) {
            this.stop(), this.updateToFrameByTime(0);
            for (var b = this._actionNodeList, c = b.length, d = 0; c > d; d++) b[d].playAction(a);
            this._loop && this._scheduler.scheduleCallbackForTarget(this, this.simulationActionUpdate, 0, cc.REPEAT_FOREVER, 0, !1), void 0 !== a && (this._callback = a)
        },
        pause: function() {
            this._pause = !0, this._playing = !1
        },
        stop: function() {
            for (var a = this._actionNodeList, b = 0; b < a.length; b++) a[b].stopAction();
            this._scheduler.unscheduleCallbackForTarget(this, this.simulationActionUpdate), this._pause = !1, this._playing = !1
        },
        updateToFrameByTime: function(a) {
            this._currentTime = a;
            for (var b = 0; b < this._actionNodeList.length; b++) {
                var c = this._actionNodeList[b];
                c.updateActionToTimeLine(a)
            }
        },
        simulationActionUpdate: function() {
            for (var a = !0, b = this._actionNodeList, c = 0, d = b.length; d > c; c++)
                if (!b[c].isActionDoneOnce()) {
                    a = !1;
                    break
                }
            a && (null != this._callback && this._callback.execute(), this._loop ? this.play() : (this._playing = !1, this._scheduler.unschedule(this.simulationActionUpdate, this)))
        }
    }), ccs.ComAttribute = ccs.Component.extend({
        _jsonDict: null,
        _filePath: "",
        ctor: function() {
            cc.Component.prototype.ctor.call(this), this._jsonDict = {}, this._filePath = "", this._name = "CCComAttribute", ccs.ComAttribute.prototype.init.call(this)
        },
        init: function() {
            return this._jsonDict = {}, !0
        },
        setInt: function(a, b) {
            return a ? void(this._jsonDict[a] = b) : void cc.log("Argument must be non-nil")
        },
        setDouble: function(a, b) {
            return a ? void(this._jsonDict[a] = b) : void cc.log("Argument must be non-nil")
        },
        setFloat: function(a, b) {
            return a ? void(this._jsonDict[a] = b) : void cc.log("Argument must be non-nil")
        },
        setBool: function(a, b) {
            return a ? void(this._jsonDict[a] = b) : void cc.log("Argument must be non-nil")
        },
        setString: function(a, b) {
            return a ? void(this._jsonDict[a] = b) : void cc.log("Argument must be non-nil")
        },
        setObject: function(a, b) {
            return a ? void(this._jsonDict[a] = b) : void cc.log("Argument must be non-nil")
        },
        getInt: function(a) {
            var b = this._jsonDict[a];
            return parseInt(b || 0)
        },
        getDouble: function(a) {
            var b = this._jsonDict[a];
            return parseFloat(b || 0)
        },
        getFloat: function(a) {
            var b = this._jsonDict[a];
            return parseFloat(b || 0)
        },
        getBool: function(a) {
            var b = this._jsonDict[a];
            return Boolean(b || !1)
        },
        getString: function(a) {
            var b = this._jsonDict[a];
            return b || ""
        },
        getObject: function(a) {
            return this._jsonDict[a]
        },
        parse: function(a) {
            this._jsonDict = cc.loader.getRes(a)
        }
    }), ccs.ComAttribute.create = function() {
        return new ccs.ComAttribute
    }, ccs.ComAudio = ccs.Component.extend({
        _filePath: "",
        _loop: !1,
        ctor: function() {
            cc.Component.prototype.ctor.call(this), this._name = "Audio", ccs.ComAudio.prototype.init.call(this)
        },
        init: function() {
            return !0
        },
        onExit: function() {
            this.stopBackgroundMusic(!0), this.stopAllEffects()
        },
        end: function() {
            cc.audioEngine.end()
        },
        preloadBackgroundMusic: function(a) {
            cc.loader.load(a)
        },
        playBackgroundMusic: function(a, b) {
            a ? cc.audioEngine.playMusic(a, b) : cc.audioEngine.playMusic(this._filePath, this._loop)
        },
        stopBackgroundMusic: function(a) {
            cc.audioEngine.stopMusic(a)
        },
        pauseBackgroundMusic: function() {
            cc.audioEngine.pauseMusic()
        },
        resumeBackgroundMusic: function() {
            cc.audioEngine.resumeMusic()
        },
        rewindBackgroundMusic: function() {
            cc.audioEngine.rewindMusic()
        },
        willPlayBackgroundMusic: function() {
            return cc.audioEngine.willPlayMusic()
        },
        isBackgroundMusicPlaying: function() {
            return cc.audioEngine.isMusicPlaying()
        },
        getBackgroundMusicVolume: function() {
            return cc.audioEngine.getMusicVolume()
        },
        setBackgroundMusicVolume: function(a) {
            cc.audioEngine.setMusicVolume(a)
        },
        getEffectsVolume: function() {
            return cc.audioEngine.getEffectsVolume()
        },
        setEffectsVolume: function(a) {
            cc.audioEngine.setEffectsVolume(a)
        },
        playEffect: function(a, b) {
            return a ? cc.audioEngine.playEffect(a, b) : cc.audioEngine.playEffect(this._filePath, this._loop)
        },
        pauseEffect: function(a) {
            cc.audioEngine.pauseEffect(a)
        },
        pauseAllEffects: function() {
            cc.audioEngine.pauseAllEffects()
        },
        resumeEffect: function(a) {
            cc.audioEngine.resumeEffect(a)
        },
        resumeAllEffects: function() {
            cc.audioEngine.resumeAllEffects()
        },
        stopEffect: function(a) {
            cc.audioEngine.stopEffect(a)
        },
        stopAllEffects: function() {
            cc.audioEngine.stopAllEffects()
        },
        preloadEffect: function(a) {
            cc.loader.getRes(a), this.setFile(a), this.setLoop(!1)
        },
        unloadEffect: function(a) {
            cc.audioEngine.unloadEffect(a)
        },
        setFile: function(a) {
            this._filePath = a
        },
        setLoop: function(a) {
            this._loop = a
        },
        getFile: function() {
            return this._filePath
        },
        isLoop: function() {
            return this._loop
        }
    }), ccs.ComAudio.create = function() {
        return new ccs.ComAudio
    }, ccs.ComController = ccs.Component.extend({
        ctor: function() {
            cc.Component.prototype.ctor.call(this), this._name = "ComController", ccs.ComController.prototype.init.call(this)
        },
        onEnter: function() {
            null != this._owner && this._owner.scheduleUpdate()
        },
        isEnabled: function() {
            return this._enabled
        },
        setEnabled: function(a) {
            this._enabled = a
        }
    }), ccs.ComController.create = function() {
        return new ccs.ComController
    }, ccs.ComRender = ccs.Component.extend({
        _render: null,
        ctor: function(a, b) {
            cc.Component.prototype.ctor.call(this), this._render = a, this._name = b, this.isRenderer = !0, ccs.ComRender.prototype.init.call(this)
        },
        onEnter: function() {
            this._owner && this._owner.addChild(this._render)
        },
        onExit: function() {
            this._owner && (this._owner.removeChild(this._render, !0), this._render = null)
        },
        getNode: function() {
            return this._render
        },
        setNode: function(a) {
            this._render = a
        }
    }), ccs.ComRender.create = function(a, b) {
        return new ccs.ComRender(a, b)
    }, ccs.objectFactory = {
        _typeMap: {},
        createObject: function(a) {
            var b = null,
                c = this._typeMap[a];
            return c && (b = cc.isFunction(c._fun) ? new c._fun : c._fun), b
        },
        registerType: function(a) {
            this._typeMap[a._className] = a
        },
        createGUI: function(a) {
            var b = null;
            "Panel" === a ? a = "Layout" : "TextArea" === a ? a = "Label" : "TextButton" === a && (a = "Button");
            var c = this._typeMap[a];
            return c && c._fun && (b = c._fun), b
        },
        removeAll: function() {
            this._typeMap = {}
        }
    }, ccs.TInfo = ccs.Class.extend({
        _className: "",
        _fun: null,
        ctor: function(a, b) {
            b ? (this._className = a, this._fun = b) : (this._className = a._className, this._fun = a._fun), ccs.objectFactory.registerType(this)
        }
    }), ccs.sendEvent = function(a) {
        var b = ccs.triggerManager.get(a);
        if (null != b)
            for (var c = 0; c < b.length; c++) {
                var d = b[c];
                null != d && d.detect() && d.done()
            }
    }, ccs.registerTriggerClass = function(a, b) {
        new ccs.TInfo(a, b)
    }, ccs.triggerManager = {
        _eventTriggers: {},
        _triggerObjs: {},
        _movementDispatches: [],
        parse: function(a) {
            for (var b = 0; b < a.length; ++b) {
                var c = a[b],
                    d = new ccs.TriggerObj;
                d.serialize(c);
                for (var e = d.getEvents(), f = 0; f < e.length; f++) {
                    var g = e[f];
                    this.add(g, d)
                }
                this._triggerObjs[d.getId()] = d
            }
        },
        get: function(a) {
            return this._eventTriggers[a]
        },
        getTriggerObj: function(a) {
            return this._triggerObjs[a]
        },
        add: function(a, b) {
            var c = this._eventTriggers[a];
            c || (c = []), -1 == c.indexOf(b) && (c.push(b), this._eventTriggers[a] = c)
        },
        removeAll: function() {
            for (var a in this._eventTriggers)
                for (var b = this._eventTriggers[a], c = 0; c < b.length; c++) {
                    var d = b[c];
                    d.removeAll()
                }
            this._eventTriggers = {}
        },
        remove: function(a, b) {
            if (b) return this._removeObj(a, b);
            var c = !1;
            do {
                var d = this._eventTriggers[a];
                if (!d) break;
                for (var e = 0; e < d.length; e++) {
                    var f = d[e];
                    f && f.removeAll()
                }
                delete this._eventTriggers[a], c = !0
            } while (0);
            return c
        },
        _removeObj: function(a, b) {
            var c = !1;
            do {
                var d = this._eventTriggers[a];
                if (!d) break;
                for (var e = 0; e < d.length; e++) {
                    var f = d[e];
                    if (f && f == b) {
                        f.removeAll(), d.splice(e, 1);
                        break
                    }
                }
                c = !0
            } while (0);
            return c
        },
        removeTriggerObj: function(a) {
            var b = this.getTriggerObj(a);
            if (!b) return !1;
            for (var c = b.getEvents(), d = 0; d < c.length; d++) {
                var e = c[d];
                this.remove(e, b)
            }
            return !0
        },
        isEmpty: function() {
            return !this._eventTriggers || this._eventTriggers.length <= 0
        },
        addArmatureMovementCallBack: function(a, b, c) {
            if (null != a && null != c && null != b) {
                for (var d, e = !1, f = 0; f < this._movementDispatches.length; f++) d = this._movementDispatches[f], d && d[0] == a && (d.addAnimationEventCallBack(b, c), e = !0);
                if (!e) {
                    var g = new ccs.ArmatureMovementDispatcher;
                    a.getAnimation().setMovementEventCallFunc(g.animationEvent, g), g.addAnimationEventCallBack(b, c), this._movementDispatches.push([a, g])
                }
            }
        },
        removeArmatureMovementCallBack: function(a, b, c) {
            if (null != a && null != b && null != c)
                for (var d, e = 0; e < this._movementDispatches.length; e++) d = this._movementDispatches[e], d && d[0] == a && d.removeAnimationEventCallBack(c, b)
        },
        removeArmatureAllMovementCallBack: function(a) {
            if (null != a)
                for (var b, c = 0; c < this._movementDispatches.length; c++)
                    if (b = this._movementDispatches[c], b && b[0] == a) {
                        this._movementDispatches.splice(c, 1);
                        break
                    }
        },
        removeAllArmatureMovementCallBack: function() {
            this._movementDispatches.length = 0
        },
        version: function() {
            return "1.2.0.0"
        }
    }, ccs.ArmatureMovementDispatcher = ccs.Class.extend({
        _mapEventAnimation: null,
        ctor: function() {
            this._mapEventAnimation = []
        },
        animationEvent: function(a, b, c) {
            for (var d, e, f, g = 0; g < this._mapEventAnimation.length; g++) d = this._mapEventAnimation[g], e = d[0], f = d[1], f && f.call(e, a, b, c)
        },
        addAnimationEventCallBack: function(a, b) {
            this._mapEventAnimation.push([b, a])
        },
        removeAnimationEventCallBack: function(a, b) {
            for (var c, d = 0; d < this._mapEventAnimation.length; d++) c = this._mapEventAnimation[d], c[0] == b && this._mapEventAnimation.splice(d, 1)
        }
    }), ccs.BaseTriggerCondition = ccs.Class.extend({
        ctor: function() {},
        init: function() {
            return !0
        },
        detect: function() {
            return !0
        },
        serialize: function() {},
        removeAll: function() {}
    }), ccs.BaseTriggerAction = ccs.Class.extend({
        ctor: function() {},
        init: function() {
            return !0
        },
        done: function() {},
        serialize: function() {},
        removeAll: function() {}
    }), ccs.TriggerObj = ccs.Class.extend({
        _cons: null,
        _acts: null,
        _id: 0,
        _enable: !0,
        _vInt: null,
        ctor: function() {
            this._id = 0, this._enable = !0, ccs.TriggerObj.prototype.init.call(this)
        },
        init: function() {
            return this._cons = [], this._acts = [], this._vInt = [], !0
        },
        detect: function() {
            if (!this._enable || 0 == this._cons.length) return !0;
            for (var a = !0, b = null, c = 0; c < this._cons.length; c++) b = this._cons[c], b && b.detect && (a = a && b.detect());
            return a
        },
        done: function() {
            if (this._enable && 0 != this._acts.length)
                for (var a, b = 0; b < this._acts.length; b++) a = this._acts[b], a && a.done && a.done()
        },
        removeAll: function() {
            for (var a = null, b = 0; b < this._cons.length; b++) a = this._cons[b], a && a.removeAll();
            this._cons = [];
            for (var b = 0; b < this._acts.length; b++) a = this._acts[b], a && a.removeAll();
            this._acts = []
        },
        serialize: function(a) {
            this._id = a.id || 0;
            for (var b = a.conditions || [], c = 0; c < b.length; c++) {
                var d = b[c],
                    e = d.classname,
                    f = ccs.objectFactory.createObject(e);
                f ? (f.serialize(d), f.init(), this._cons.push(f)) : cc.log("class named classname(" + e + ") can not implement!")
            }
            for (var g = a.actions || [], c = 0; c < g.length; c++) {
                var d = g[c],
                    e = d.classname,
                    h = ccs.objectFactory.createObject(e);
                h ? (h.serialize(d), h.init(), this._acts.push(h)) : cc.log("class named classname(" + e + ") can not implement!")
            }
            for (var i = a.events || [], c = 0; c < i.length; c++) {
                var d = i[c],
                    j = d.id;
                0 > j || this._vInt.push(j)
            }
        },
        getId: function() {
            return this._id
        },
        setEnable: function(a) {
            this._enable = a
        },
        getEvents: function() {
            return this._vInt
        }
    }), ccs.TriggerObj.create = function() {
        return new ccs.TriggerObj
    }, ccs.buttonReader = {
        setPropsFromJsonDictionary: function(a, b) {
            ccs.widgetReader.setPropsFromJsonDictionary.call(this, a, b);
            var c = ccs.uiReader.getFilePath(),
                d = a,
                e = b.scale9Enable;
            d.setScale9Enabled(e);
            var f = b.normalData,
                g = f.resourceType;
            switch (g) {
                case 0:
                    var h = c,
                        i = f.path,
                        j = i && "" !== i ? h + i : null;
                    d.loadTextureNormal(j);
                    break;
                case 1:
                    var i = f.path;
                    d.loadTextureNormal(i, 1)
            }
            var k = b.pressedData,
                l = k.resourceType;
            switch (l) {
                case 0:
                    var m = c,
                        n = k.path,
                        o = n && "" !== n ? m + n : null;
                    d.loadTexturePressed(o);
                    break;
                case 1:
                    var n = k.path;
                    d.loadTexturePressed(n, 1)
            }
            var p = b.disabledData,
                q = p.resourceType;
            switch (q) {
                case 0:
                    var r = c,
                        s = p.path,
                        t = s && "" !== s ? r + s : null;
                    d.loadTextureDisabled(t);
                    break;
                case 1:
                    var s = p.path;
                    d.loadTextureDisabled(s, 1)
            }
            if (e) {
                var u = b.capInsetsX,
                    v = b.capInsetsY,
                    w = b.capInsetsWidth,
                    x = b.capInsetsHeight;
                d.setCapInsets(cc.rect(u, v, w, x));
                var y = b.scale9Width,
                    z = b.scale9Height;
                null != y && null != z && d.setSize(cc.size(y, z))
            }
            var A = b.text;
            null != A && d.setTitleText(A);
            var B = b.textColorR,
                C = b.textColorG,
                D = b.textColorB,
                E = null !== B ? b.textColorR : 255,
                F = null !== C ? b.textColorG : 255,
                G = null !== D ? b.textColorB : 255;
            d.setTitleColor(cc.color(E, F, G));
            var H = b.fontSize;
            null != H && d.setTitleFontSize(b.fontSize);
            var I = b.fontName;
            I && d.setTitleFontName(b.fontName), ccs.widgetReader.setColorPropsFromJsonDictionary.call(this, a, b)
        }
    }, ccs.checkBoxReader = {
        setPropsFromJsonDictionary: function(a, b) {
            ccs.widgetReader.setPropsFromJsonDictionary.call(this, a, b);
            var c = a,
                d = b.backGroundBoxData,
                e = d.resourceType,
                f = ccs.widgetReader._getResourcePath(d, "path", e);
            c.loadTextureBackGround(f, e);
            var g = b.backGroundBoxSelectedData,
                h = g.resourceType,
                i = ccs.widgetReader._getResourcePath(g, "path", h);
            i || (h = e, i = f), c.loadTextureBackGroundSelected(i, h);
            var j = b.frontCrossData,
                k = j.resourceType,
                l = ccs.widgetReader._getResourcePath(j, "path", k);
            c.loadTextureFrontCross(l, k);
            var m = b.backGroundBoxDisabledData,
                n = m.resourceType,
                o = ccs.widgetReader._getResourcePath(m, "path", n);
            o || (n = k, o = l), c.loadTextureBackGroundDisabled(o, n);
            var p = b.frontCrossDisabledData,
                q = p.resourceType,
                r = ccs.widgetReader._getResourcePath(p, "path", q);
            c.loadTextureFrontCrossDisabled(r, q), b.selectedState && c.setSelected(b.selectedState), ccs.widgetReader.setColorPropsFromJsonDictionary.call(this, a, b)
        },
        getResourceType: function(a) {
            return "Normal" == a || "Default" == a || "MarkedSubImage" == a ? 0 : 1
        }
    }, ccs.imageViewReader = {
        setPropsFromJsonDictionary: function(a, b) {
            ccs.widgetReader.setPropsFromJsonDictionary.call(this, a, b);
            var c = ccs.uiReader.getFilePath(),
                d = a,
                e = b.fileNameData,
                f = e.resourceType;
            switch (f) {
                case 0:
                    var g = c,
                        h = e.path,
                        i = null;
                    h && "" !== h && (i = g + h, d.loadTexture(i));
                    break;
                case 1:
                    var h = e.path;
                    d.loadTexture(h, 1)
            }
            var j = b.scale9Enable,
                k = !1;
            if (j && (k = b.scale9Enable), d.setScale9Enabled(k), k) {
                var l = b.scale9Width,
                    m = b.scale9Height;
                if (l && m) {
                    var n = b.scale9Width,
                        o = b.scale9Height;
                    d.setSize(cc.size(n, o))
                }
                var p = b.capInsetsX,
                    q = b.capInsetsY,
                    r = b.capInsetsWidth,
                    s = b.capInsetsHeight;
                d.setCapInsets(cc.rect(p, q, r, s))
            }
            ccs.widgetReader.setColorPropsFromJsonDictionary.call(this, a, b)
        }
    }, ccs.labelAtlasReader = {
        setPropsFromJsonDictionary: function(a, b) {
            ccs.widgetReader.setPropsFromJsonDictionary.call(this, a, b);
            var c = ccs.uiReader.getFilePath(),
                d = a,
                e = b.stringValue,
                f = b.charMapFileData,
                g = b.itemWidth,
                h = b.itemHeight,
                i = b.startCharMap;
            if (null != e && f && null != g && null != h && null != i) {
                var j = b.charMapFileData,
                    k = j.resourceType;
                switch (k) {
                    case 0:
                        var l = c,
                            m = j.path,
                            n = l + m;
                        d.setProperty(e, n, g, h, i);
                        break;
                    case 1:
                        cc.log("Wrong res type of LabelAtlas!")
                }
            }
            ccs.widgetReader.setColorPropsFromJsonDictionary.call(this, a, b)
        }
    }, ccs.labelBMFontReader = {
        setPropsFromJsonDictionary: function(a, b) {
            ccs.widgetReader.setPropsFromJsonDictionary.call(this, a, b);
            var c = ccs.uiReader.getFilePath(),
                d = a,
                e = b.fileNameData,
                f = e.resourceType;
            switch (f) {
                case 0:
                    var g = c,
                        h = e.path,
                        i = g + h;
                    d.setFntFile(i);
                    break;
                case 1:
                    cc.log("Wrong res type of LabelAtlas!")
            }
            var j = b.text;
            d.setString(j), ccs.widgetReader.setColorPropsFromJsonDictionary.call(this, a, b)
        }
    }, ccs.labelReader = {
        setPropsFromJsonDictionary: function(a, b) {
            ccs.widgetReader.setPropsFromJsonDictionary.call(this, a, b);
            var c = a,
                d = b.touchScaleEnable;
            c.setTouchScaleChangeEnabled(d);
            var e = b.text;
            c.setString(e);
            var f = b.fontSize;
            null != f && c.setFontSize(b.fontSize);
            var g = b.fontName;
            null != g && c.setFontName(b.fontName);
            var h = b.areaWidth,
                i = b.areaHeight;
            if (null != h && null != i) {
                var j = cc.size(b.areaWidth, b.areaHeight);
                c.setTextAreaSize(j)
            }
            var k = b.hAlignment;
            null != k && c.setTextHorizontalAlignment(b.hAlignment);
            var l = b.vAlignment;
            null != l && c.setTextVerticalAlignment(b.vAlignment), ccs.widgetReader.setColorPropsFromJsonDictionary.call(this, a, b)
        }
    }, ccs.layoutReader = {
        setPropsFromJsonDictionary: function(a, b) {
            ccs.widgetReader.setPropsFromJsonDictionary.call(this, a, b);
            var c = ccs.uiReader.getFilePath(),
                d = a,
                e = 0,
                f = 0,
                g = b.adaptScreen;
            if (g) {
                var h = cc.director.getWinSize();
                e = h.width, f = h.height
            } else e = b.width, f = b.height;
            d.setSize(cc.size(e, f)), d.setClippingEnabled(b.clipAble);
            var i = b.backGroundScale9Enable;
            d.setBackGroundImageScale9Enabled(i);
            var j = b.bgColorR,
                k = b.bgColorG,
                l = b.bgColorB,
                m = b.bgStartColorR,
                n = b.bgStartColorG,
                o = b.bgStartColorB,
                p = b.bgEndColorR,
                q = b.bgEndColorG,
                r = b.bgEndColorB,
                s = b.vectorX,
                t = b.vectorY;
            d.setBackGroundColorVector(cc.p(s, t));
            var u = b.bgColorOpacity,
                v = b.colorType;
            d.setBackGroundColorType(v), d.setBackGroundColor(cc.color(m, n, o), cc.color(p, q, r)), d.setBackGroundColor(cc.color(j, k, l)), d.setBackGroundColorOpacity(u);
            var w = b.backGroundImageData;
            if (w) {
                var x = w.resourceType;
                switch (x) {
                    case 0:
                        var y = c,
                            z = w.path,
                            A = z && "" !== z ? y + z : null;
                        d.setBackGroundImage(A);
                        break;
                    case 1:
                        var z = w.path;
                        d.setBackGroundImage(z, 1)
                }
            }
            if (i) {
                var B = b.capInsetsX,
                    C = b.capInsetsY,
                    D = b.capInsetsWidth,
                    E = b.capInsetsHeight;
                d.setBackGroundImageCapInsets(cc.rect(B, C, D, E))
            }
            d.setLayoutType(b.layoutType), ccs.widgetReader.setColorPropsFromJsonDictionary.call(this, a, b)
        }
    }, ccs.scrollViewReader = {
        setPropsFromJsonDictionary: function(a, b) {
            ccs.layoutReader.setPropsFromJsonDictionary.call(this, a, b);
            var c = a,
                d = null != b.innerWidth ? b.innerWidth : 200,
                e = null != b.innerHeight ? b.innerHeight : 200;
            c.setInnerContainerSize(cc.size(d, e));
            var f = null != b.direction ? b.direction : 1;
            c.setDirection(f), c.setBounceEnabled(b.bounceEnable), ccs.widgetReader.setColorPropsFromJsonDictionary.call(this, a, b)
        }
    }, ccs.listViewReader = {
        setPropsFromJsonDictionary: function(a, b) {
            ccs.scrollViewReader.setPropsFromJsonDictionary.call(this, a, b);
            var c = a,
                d = b.direction;
            c.setDirection(d);
            var e = b.gravity;
            c.setGravity(e);
            var f = b.itemMargin;
            c.setItemsMargin(f)
        }
    }, ccs.loadingBarReader = {
        setPropsFromJsonDictionary: function(a, b) {
            ccs.widgetReader.setPropsFromJsonDictionary.call(this, a, b);
            var c = ccs.uiReader.getFilePath(),
                d = a,
                e = b.textureData,
                f = e.resourceType;
            switch (f) {
                case 0:
                    var g = c,
                        h = e.path,
                        i = null;
                    h && "" !== h && (i = g + h, d.loadTexture(i));
                    break;
                case 1:
                    var h = e.path;
                    d.loadTexture(h, 1)
            }
            var j = b.scale9Enable;
            if (d.setScale9Enabled(j), j) {
                var k = b.capInsetsX,
                    l = b.capInsetsY,
                    m = b.capInsetsWidth,
                    n = b.capInsetsHeight;
                d.setCapInsets(cc.rect(k, l, m, n));
                var o = b.width,
                    p = b.height;
                d.setSize(cc.size(o, p))
            }
            d.setDirection(b.direction), d.setPercent(b.percent), ccs.widgetReader.setColorPropsFromJsonDictionary.call(this, a, b)
        }
    }, ccs.pageViewReader = {
        setPropsFromJsonDictionary: function(a, b) {
            ccs.layoutReader.setPropsFromJsonDictionary.call(this, a, b)
        }
    }, ccs.sliderReader = {
        setPropsFromJsonDictionary: function(a, b) {
            ccs.widgetReader.setPropsFromJsonDictionary.call(this, a, b);
            var c = ccs.uiReader.getFilePath(),
                d = a,
                e = c,
                f = b.scale9Enable;
            d.setScale9Enabled(f);
            var g, h = b.barFileName,
                i = b.length,
                j = b.barFileNameData,
                k = j.resourceType,
                l = j.path;
            if (null != h) {
                if (f) {
                    switch (k) {
                        case 0:
                            g = l ? e + l : null, d.loadBarTexture(g);
                            break;
                        case 1:
                            d.loadBarTexture(l, 1)
                    }
                    d.setSize(cc.size(i, d.getContentSize().height))
                }
            } else switch (k) {
                case 0:
                    g = l ? e + l : null, d.loadBarTexture(g);
                    break;
                case 1:
                    d.loadBarTexture(l, 1)
            }
            var m = b.ballNormalData,
                n = m.resourceType,
                o = m.path;
            switch (n) {
                case 0:
                    var p = o ? e + o : null;
                    d.loadSlidBallTextureNormal(p);
                    break;
                case 1:
                    d.loadSlidBallTextureNormal(o, 1)
            }
            var q = b.ballPressedData,
                r = q.resourceType,
                s = q.path;
            switch (null === s && (r = n, s = o), r) {
                case 0:
                    var t = s ? e + s : null;
                    d.loadSlidBallTexturePressed(t);
                    break;
                case 1:
                    d.loadSlidBallTexturePressed(s, 1)
            }
            var u = b.ballDisabledData,
                v = u.resourceType,
                w = u.path;
            switch (v) {
                case 0:
                    var x = w ? e + w : null;
                    d.loadSlidBallTextureDisabled(x);
                    break;
                case 1:
                    d.loadSlidBallTextureDisabled(w, 1)
            }
            var y = b.progressBarData,
                z = y.resourceType,
                A = y.path;
            switch (z) {
                case 0:
                    var B = A ? e + A : null;
                    d.loadProgressBarTexture(B);
                    break;
                case 1:
                    d.loadProgressBarTexture(A, 1)
            }
            ccs.widgetReader.setColorPropsFromJsonDictionary.call(this, a, b)
        }
    }, ccs.textFieldReader = {
        setPropsFromJsonDictionary: function(a, b) {
            ccs.widgetReader.setPropsFromJsonDictionary.call(this, a, b);
            var c = a,
                d = b.placeHolder;
            d && c.setPlaceHolder(d), c.setString(b.text || "");
            var e = b.fontSize1;
            e && c.setFontSize(e);
            var f = b.fontName;
            f && c.setFontName(f);
            var g = b.touchSizeWidth,
                h = b.touchSizeHeight;
            null != g && null != h && c.setTouchSize(g, h);
            var i = (b.width, b.height, b.maxLengthEnable);
            if (c.setMaxLengthEnabled(i), i) {
                var j = b.maxLength;
                c.setMaxLength(j)
            }
            var k = b.passwordEnable;
            c.setPasswordEnabled(k), k && c.setPasswordStyleText(b.passwordStyleText);
            var l = b.areaWidth,
                m = b.areaHeight;
            if (l && m) {
                var n = cc.size(l, m);
                c.setTextAreaSize(n)
            }
            var o = b.hAlignment;
            o && c.setTextHorizontalAlignment(o);
            var p = b.vAlignment;
            p && c.setTextVerticalAlignment(p), ccs.widgetReader.setColorPropsFromJsonDictionary.call(this, a, b)
        }
    }, ccs.WidgetReaderProtocol = ccs.Class.extend({
        setPropsFromJsonDictionary: function() {}
    }), ccs.widgetReader = {
        setPropsFromJsonDictionary: function(a, b) {
            var c = b.ignoreSize;
            null != c && a.ignoreContentAdaptWithSize(c), a.setSizeType(b.sizeType), a.setPositionType(b.positionType), a.setSizePercent(cc.p(b.sizePercentX, b.sizePercentY)), a.setPositionPercent(cc.p(b.positionPercentX, b.positionPercentY));
            var d = 0,
                e = 0,
                f = b.adaptScreen;
            if (f) {
                var g = cc.director.getWinSize();
                d = g.width, e = g.height
            } else d = b.width, e = b.height;
            a.setContentSize(d, e), a.setTag(b.tag), a.setActionTag(b.actiontag), a.setTouchEnabled(b.touchAble);
            var h = b.name,
                i = h ? h : "default";
            a.setName(i);
            var j = b.x,
                k = b.y;
            a.setPosition(j, k);
            var l = null != b.scaleX ? b.scaleX : 1;
            a.setScaleX(l);
            var m = null != b.scaleY ? b.scaleY : 1;
            a.setScaleY(m);
            var n = b.rotation || 0;
            a.setRotation(n);
            var o = b.visible || !1;
            null != o && a.setVisible(o), a.setLocalZOrder(b.ZOrder);
            var p = b.layoutParameter;
            if (null != p) {
                var q = b.layoutParameter,
                    r = q.type,
                    s = null;
                switch (r) {
                    case 0:
                        break;
                    case 1:
                        s = new ccui.LinearLayoutParameter;
                        var t = q.gravity;
                        s.setGravity(t);
                        break;
                    case 2:
                        s = new ccui.RelativeLayoutParameter;
                        var u = s,
                            v = q.relativeName;
                        u.setRelativeName(v);
                        var w = q.relativeToName;
                        u.setRelativeToWidgetName(w);
                        var x = q.align;
                        u.setAlign(x)
                }
                if (null != s) {
                    var y = q.marginLeft || 0,
                        z = q.marginTop || 0,
                        A = q.marginRight || 0,
                        B = q.marginDown || 0;
                    s.setMargin(y, z, A, B), a.setLayoutParameter(s)
                }
            }
        },
        setColorPropsFromJsonDictionary: function(a, b) {
            var c = b.opacity;
            null != c && a.setOpacity(c);
            var d = b.colorR,
                e = b.colorG,
                f = b.colorB;
            a.setColor(cc.color(null == d ? 255 : d, null == e ? 255 : e, null == f ? 255 : f)), ccs.widgetReader._setAnchorPointForWidget(a, b), a.setFlippedX(b.flipX), a.setFlippedY(b.flipY)
        },
        _setAnchorPointForWidget: function(a, b) {
            var c, d = b.anchorPointX;
            c = null != d ? b.anchorPointX : a.getAnchorPoint().x;
            var e, f = b.anchorPointY;
            e = null != f ? b.anchorPointY : a.getAnchorPoint().y, (null != d || null != f) && a.setAnchorPoint(cc.p(c, e))
        },
        _getResourcePath: function(a, b, c) {
            var d, e = a[b];
            return null != e && (0 == c ? d = ccs.uiReader.getFilePath() + e : 1 == c ? d = e : cc.assert(0, "invalid TextureResType!!!")), d
        },
        setAnchorPointForWidget: function(a, b) {
            var c, d = b.widgetOptions,
                e = d.anchorPointX;
            c = e ? d.anchorPointX : a.getAnchorPoint().x;
            var f, g = d.anchorPointY;
            f = g ? d.anchorPointY : a.getAnchorPoint().y, (e || g) && a.setAnchorPoint(cc.p(c, f))
        },
        getResourcePath: function(a, b) {
            var c, d = ccs.uiReader.getFilePath(),
                e = a;
            return null != e && 0 != e && (b == ccui.Widget.LOCAL_TEXTURE ? c = d + e : b == ccui.Widget.PLIST_TEXTURE ? c = e : cc.assert(0, "invalid TextureResType!!!")), c
        }
    },
    function() {
        var a = ccs.objectFactory;
        a.registerType({
            _className: "ButtonReader",
            _fun: ccs.buttonReader
        }), a.registerType({
            _className: "CheckBoxReader",
            _fun: ccs.checkBoxReader
        }), a.registerType({
            _className: "SliderReader",
            _fun: ccs.sliderReader
        }), a.registerType({
            _className: "ImageViewReader",
            _fun: ccs.imageViewReader
        }), a.registerType({
            _className: "LoadingBarReader",
            _fun: ccs.loadingBarReader
        }), a.registerType({
            _className: "TextAtlasReader",
            _fun: ccs.labelAtlasReader
        }), a.registerType({
            _className: "TextReader",
            _fun: ccs.labelReader
        }), a.registerType({
            _className: "TextBMFontReader",
            _fun: ccs.labelBMFontReader
        }), a.registerType({
            _className: "TextFieldReader",
            _fun: ccs.textFieldReader
        }), a.registerType({
            _className: "LayoutReader",
            _fun: ccs.layoutReader
        }), a.registerType({
            _className: "PageViewReader",
            _fun: ccs.pageViewReader
        }), a.registerType({
            _className: "ScrollViewReader",
            _fun: ccs.scrollViewReader
        }), a.registerType({
            _className: "ListViewReader",
            _fun: ccs.listViewReader
        }), a.registerType({
            _className: "WidgetReader",
            _fun: ccs.widgetReader
        }), a.registerType({
            _className: "Button",
            _fun: ccui.Button
        }), a.registerType({
            _className: "CheckBox",
            _fun: ccui.CheckBox
        }), a.registerType({
            _className: "ImageView",
            _fun: ccui.ImageView
        }), a.registerType({
            _className: "Text",
            _fun: ccui.Text
        }), a.registerType({
            _className: "TextAtlas",
            _fun: ccui.TextAtlas
        }), a.registerType({
            _className: "TextBMFont",
            _fun: ccui.TextBMFont
        }), a.registerType({
            _className: "LoadingBar",
            _fun: ccui.LoadingBar
        }), a.registerType({
            _className: "Slider",
            _fun: ccui.Slider
        }), a.registerType({
            _className: "TextField",
            _fun: ccui.TextField
        }), a.registerType({
            _className: "Layout",
            _fun: ccui.Layout
        }), a.registerType({
            _className: "ListView",
            _fun: ccui.ListView
        }), a.registerType({
            _className: "PageView",
            _fun: ccui.PageView
        }), a.registerType({
            _className: "ScrollView",
            _fun: ccui.ScrollView
        })
    }(), ccs.uiReader = {
        _filePath: "",
        _olderVersion: !1,
        _fileDesignSizes: {},
        _mapObject: {},
        _mapParseSelector: {},
        getVersionInteger: function(a) {
            if (!a) return 0;
            var b = a,
                c = b.length;
            if (7 > c) return 0;
            var d = b.indexOf("."),
                e = b.substr(0, d);
            b = b.substr(d + 1, c - 1), d = b.indexOf(".");
            var f = b.substr(0, d);
            b = b.substr(d + 1, c - 1), d = b.indexOf(".");
            var g = b.substr(0, d);
            b = b.substr(d + 1, c - 1), d = b.indexOf(".");
            var h = -1 == d ? b : b.substr(0, d),
                i = parseInt(e),
                j = parseInt(f),
                k = parseInt(g),
                l = parseInt(h);
            return 1e3 * i + 100 * j + 10 * k + l
        },
        storeFileDesignSize: function(a, b) {
            this._fileDesignSizes[a] = b
        },
        getFileDesignSize: function(a) {
            return this._fileDesignSizes[a]
        },
        widgetFromJsonFile: function(a) {
            var b = cc.loader.getRes(a);
            if (!b) throw "Please load the resource first : " + a;
            var c = cc.path.dirname(a);
            this._filePath = "" == c ? c : c + "/";
            var d, e, f = b.version,
                g = this.getVersionInteger(f);
            return f ? 250 > g ? (d = new ccs.WidgetPropertiesReader0250, e = d.createWidget(b, this._filePath, a)) : (d = new ccs.WidgetPropertiesReader0300, e = d.createWidget(b, this._filePath, a)) : (d = new ccs.WidgetPropertiesReader0250, e = d.createWidget(b, this._filePath, a)), (!f || 250 > g) && (this._olderVersion = !0), b = null, e
        },
        clear: function() {
            this._filePath = "", this._olderVersion = !1, this._fileDesignSizes = {}
        },
        registerTypeAndCallBack: function(a, b, c, d) {
            var e = ccs.objectFactory,
                f = new ccs.TInfo(a, b);
            e.registerType(f), c && (this._mapObject[a] = c), d && (this._mapParseSelector[a] = d)
        },
        getFilePath: function() {
            return this._filePath
        },
        setFilePath: function(a) {
            this._filePath = a
        },
        getParseObjectMap: function() {
            return this._mapObject
        },
        getParseCallBackMap: function() {
            return this._mapParseSelector
        }
    }, ccs.WidgetPropertiesReader = ccs.Class.extend({
        _filePath: "",
        createWidget: function() {},
        widgetFromJsonDictionary: function() {},
        _createGUI: function(a) {
            var b = this._getGUIClassName(a);
            return ccs.objectFactory.createObject(b)
        },
        _getGUIClassName: function(a) {
            var b = a;
            return "Panel" == a ? b = "Layout" : "TextArea" == a ? b = "Text" : "TextButton" == a ? b = "Button" : "Label" == a ? b = "Text" : "LabelAtlas" == a ? b = "TextAtlas" : "LabelBMFont" == a ? b = "TextBMFont" : "Node" == a && (b = "Layout"), b
        },
        _getWidgetReaderClassName: function(a) {
            var b = a;
            return "Panel" == b ? b = "Layout" : "TextArea" == b ? b = "Text" : "TextButton" == b ? b = "Button" : "Label" == b ? b = "Text" : "LabelAtlas" == b ? b = "TextAtlas" : "LabelBMFont" == b && (b = "TextBMFont"), b += "Reader"
        },
        _getWidgetReaderClassNameFromWidget: function(a) {
            var b = "";
            return a instanceof ccui.Button ? b = "ButtonReader" : a instanceof ccui.CheckBox ? b = "CheckBoxReader" : a instanceof ccui.ImageView ? b = "ImageViewReader" : a instanceof ccui.TextAtlas ? b = "TextAtlasReader" : a instanceof ccui.TextBMFont ? b = "TextBMFontReader" : a instanceof ccui.Text ? b = "TextReader" : a instanceof ccui.LoadingBar ? b = "LoadingBarReader" : a instanceof ccui.Slider ? b = "SliderReader" : a instanceof ccui.TextField ? b = "TextFieldReader" : a instanceof ccui.ListView ? b = "ListViewReader" : a instanceof ccui.PageView ? b = "PageViewReader" : a instanceof ccui.ScrollView ? b = "ScrollViewReader" : a instanceof ccui.Layout ? b = "LayoutReader" : a instanceof ccui.Widget && (b = "WidgetReader"), b
        },
        _createWidgetReaderProtocol: function(a) {
            return ccs.objectFactory.createObject(a)
        }
    }), ccs.WidgetPropertiesReader0250 = ccs.WidgetPropertiesReader.extend({
        createWidget: function(a, b, c) {
            this._filePath = "" == b ? b : cc.path.join(b, "/");
            for (var d = a.textures, e = 0; e < d.length; e++) {
                var f = d[e],
                    g = b;
                g += f, cc.spriteFrameCache.addSpriteFrames(g)
            }
            var h = a.designWidth,
                i = a.designHeight;
            if (0 >= h || 0 >= i) {
                cc.log("Read design size error!");
                var j = cc.director.getWinSize();
                ccs.uiReader.storeFileDesignSize(c, j)
            } else ccs.uiReader.storeFileDesignSize(c, cc.size(h, i));
            var k = a.widgetTree,
                l = this.widgetFromJsonDictionary(k),
                m = l.getContentSize();
            0 == m.width && 0 == m.height && l.setSize(cc.size(h, i));
            var n = a.animation;
            return ccs.actionManager.initWithDictionary(c, n, l), k = null, n = null, l
        },
        widgetFromJsonDictionary: function(a) {
            var b = null,
                c = a.classname,
                d = a.options;
            "Button" == c ? (b = new ccui.Button, this.setPropsForButtonFromJsonDictionary(b, d)) : "CheckBox" == c ? (b = new ccui.CheckBox, this.setPropsForCheckBoxFromJsonDictionary(b, d)) : "Label" == c ? (b = new ccui.Text, this.setPropsForLabelFromJsonDictionary(b, d)) : "LabelAtlas" == c ? (b = new ccui.TextAtlas, this.setPropsForLabelAtlasFromJsonDictionary(b, d)) : "LoadingBar" == c ? (b = new ccui.LoadingBar, this.setPropsForLoadingBarFromJsonDictionary(b, d)) : "ScrollView" == c ? (b = new ccui.ScrollView, this.setPropsForScrollViewFromJsonDictionary(b, d)) : "TextArea" == c ? (b = new ccui.Text, this.setPropsForLabelFromJsonDictionary(b, d)) : "TextButton" == c ? (b = new ccui.Button, this.setPropsForButtonFromJsonDictionary(b, d)) : "TextField" == c ? (b = new ccui.TextField, this.setPropsForTextFieldFromJsonDictionary(b, d)) : "ImageView" == c ? (b = new ccui.ImageView, this.setPropsForImageViewFromJsonDictionary(b, d)) : "Panel" == c ? (b = new ccui.Layout, this.setPropsForLayoutFromJsonDictionary(b, d)) : "Slider" == c ? (b = new ccui.Slider, this.setPropsForSliderFromJsonDictionary(b, d)) : "LabelBMFont" == c ? (b = new ccui.TextBMFont, this.setPropsForLabelBMFontFromJsonDictionary(b, d)) : "DragPanel" == c && (b = new ccui.ScrollView, this.setPropsForScrollViewFromJsonDictionary(b, d));
            for (var e = a.children, f = 0; f < e.length; f++) {
                var g = e[f],
                    h = this.widgetFromJsonDictionary(g);
                h && b.addChild(h), g = null
            }
            return d = null, b
        },
        setPropsForWidgetFromJsonDictionary: function(a, b) {
            void 0 !== b.ignoreSize && a.ignoreContentAdaptWithSize(b.ignoreSize);
            var c = b.width,
                d = b.height;
            a.setSize(cc.size(c, d)), a.setTag(b.tag), a.setActionTag(b.actiontag), a.setTouchEnabled(b.touchAble);
            var e = b.name,
                f = e ? e : "default";
            a.setName(f);
            var g = b.x,
                h = b.y;
            a.setPosition(cc.p(g, h)), void 0 !== b.scaleX && a.setScaleX(b.scaleX), void 0 !== b.scaleY && a.setScaleY(b.scaleY), void 0 !== b.rotation && a.setRotation(b.rotation), void 0 !== b.visible && a.setVisible(b.visible);
            var i = b.ZOrder;
            a.setLocalZOrder(i)
        },
        setPropsForAllWidgetFromJsonDictionary: function() {},
        setPropsForAllCustomWidgetFromJsonDictionary: function() {},
        setColorPropsForWidgetFromJsonDictionary: function(a, b) {
            void 0 !== b.opacity && a.setOpacity(b.opacity);
            var c = void 0 !== b.colorR ? b.colorR : 255,
                d = void 0 !== b.colorG ? b.colorG : 255,
                e = void 0 !== b.colorB ? b.colorB : 255;
            a.setColor(cc.color(c, d, e));
            var f = void 0 !== b.anchorPointX ? b.anchorPointX : a.getWidgetType() == ccui.Widget.TYPE_WIDGET ? .5 : 0,
                g = void 0 !== b.anchorPointY ? b.anchorPointY : a.getWidgetType() == ccui.Widget.TYPE_WIDGET ? .5 : 0;
            a.setAnchorPoint(f, g);
            var h = b.flipX,
                i = b.flipY;
            a.setFlippedX(h), a.setFlippedY(i)
        },
        setPropsForButtonFromJsonDictionary: function(a, b) {
            this.setPropsForWidgetFromJsonDictionary(a, b);
            var c = a,
                d = b.scale9Enable;
            c.setScale9Enabled(d);
            var e = b.normal,
                f = b.pressed,
                g = b.disabled,
                h = e ? this._filePath + e : null,
                i = f ? this._filePath + f : null,
                j = g ? this._filePath + g : null,
                k = b.useMergedTexture;
            if (d) {
                {
                    b.capInsetsX, b.capInsetsY, b.capInsetsWidth, b.capInsetsHeight
                }
                if (k ? c.loadTextures(e, f, g, ccui.Widget.PLIST_TEXTURE) : c.loadTextures(h, i, j), void 0 !== b.scale9Width && void 0 !== b.scale9Height) {
                    var l = b.scale9Width,
                        m = b.scale9Height;
                    c.setSize(cc.size(l, m))
                }
            } else k ? c.loadTextures(e, f, g, ccui.Widget.PLIST_TEXTURE) : c.loadTextures(h, i, j); if (void 0 !== b.text) {
                var n = b.text || "";
                n && c.setTitleText(n)
            }
            void 0 !== b.fontSize && c.setTitleFontSize(b.fontSize), void 0 !== b.fontName && c.setTitleFontName(b.fontName);
            var o = void 0 !== b.textColorR ? b.textColorR : 255,
                p = void 0 !== b.textColorG ? b.textColorG : 255,
                q = void 0 !== b.textColorB ? b.textColorB : 255,
                r = cc.color(o, p, q);
            c.setTitleColor(r), this.setColorPropsForWidgetFromJsonDictionary(a, b)
        },
        setPropsForCheckBoxFromJsonDictionary: function(a, b) {
            this.setPropsForWidgetFromJsonDictionary(a, b);
            var c = a,
                d = b.backGroundBox,
                e = b.backGroundBoxSelected,
                f = b.frontCross,
                g = b.backGroundBoxDisabled,
                h = b.frontCrossDisabled,
                i = this._filePath,
                j = d ? i + d : null,
                k = e ? i + e : null,
                l = f ? i + f : null,
                m = g ? i + g : null,
                n = h ? i + h : null,
                o = b.useMergedTexture;
            o ? c.loadTextures(d, e, f, g, h, ccui.Widget.PLIST_TEXTURE) : c.loadTextures(j, k, l, m, n), c.setSelected(b.selectedState || !1), this.setColorPropsForWidgetFromJsonDictionary(a, b)
        },
        setPropsForImageViewFromJsonDictionary: function(a, b) {
            this.setPropsForWidgetFromJsonDictionary(a, b);
            var c = a,
                d = b.fileName,
                e = b.scale9Enable || !1;
            c.setScale9Enabled(e);
            var f = this._filePath,
                g = null;
            d && (g = f + d);
            var h = b.useMergedTexture;
            if (e) {
                if (h ? c.loadTexture(d, ccui.Widget.PLIST_TEXTURE) : c.loadTexture(g), void 0 !== b.scale9Width && void 0 !== b.scale9Height) {
                    var i = b.scale9Width,
                        j = b.scale9Height;
                    c.setSize(cc.size(i, j))
                }
                var k = b.capInsetsX,
                    l = b.capInsetsY,
                    m = b.capInsetsWidth,
                    n = b.capInsetsHeight;
                c.setCapInsets(cc.rect(k, l, m, n))
            } else h ? c.loadTexture(d, ccui.Widget.PLIST_TEXTURE) : c.loadTexture(g);
            this.setColorPropsForWidgetFromJsonDictionary(a, b)
        },
        setPropsForLabelFromJsonDictionary: function(a, b) {
            this.setPropsForWidgetFromJsonDictionary(a, b);
            var c = a,
                d = b.touchScaleEnable;
            c.setTouchScaleChangeEnabled(d);
            var e = b.text;
            if (c.setString(e), void 0 !== b.fontSize && c.setFontSize(b.fontSize), void 0 !== b.fontName && c.setFontName(b.fontName), void 0 !== b.areaWidth && void 0 !== b.areaHeight) {
                var f = cc.size(b.areaWidth, b.areaHeight);
                c.setTextAreaSize(f)
            }
            b.hAlignment && c.setTextHorizontalAlignment(b.hAlignment), b.vAlignment && c.setTextVerticalAlignment(b.vAlignment), this.setColorPropsForWidgetFromJsonDictionary(a, b)
        },
        setPropsForLabelAtlasFromJsonDictionary: function(a, b) {
            this.setPropsForWidgetFromJsonDictionary(a, b);
            var c = a,
                d = b.charMapFileData,
                e = b.stringValue,
                f = b.itemWidth,
                g = b.itemHeight,
                h = b.startCharMap,
                i = void 0 !== e,
                j = void 0 !== d,
                k = void 0 !== f,
                l = void 0 !== g,
                m = void 0 !== h;
            if (i && j && k && l && m && d) {
                var n = this._filePath + d;
                c.setProperty(e, n, f, g, h)
            }
            this.setColorPropsForWidgetFromJsonDictionary(a, b)
        },
        setPropsForLayoutFromJsonDictionary: function(a, b) {
            this.setPropsForWidgetFromJsonDictionary(a, b);
            var c = a;
            c instanceof ccui.ScrollView || c instanceof ccui.ListView || c.setClippingEnabled(b.clipAble);
            var d = a,
                e = b.backGroundScale9Enable;
            d.setBackGroundImageScale9Enabled(e);
            var f = b.bgColorR,
                g = b.bgColorG,
                h = b.bgColorB,
                i = b.bgStartColorR,
                j = b.bgStartColorG,
                k = b.bgStartColorB,
                l = b.bgEndColorR,
                m = b.bgEndColorG,
                n = b.bgEndColorB,
                o = b.vectorX,
                p = b.vectorY;
            d.setBackGroundColorVector(cc.p(o, p));
            var q = b.bgColorOpacity,
                r = b.colorType;
            d.setBackGroundColorType(r), d.setBackGroundColor(cc.color(i, j, k), cc.color(l, m, n)), d.setBackGroundColor(cc.color(f, g, h)), d.setBackGroundColorOpacity(q);
            var s = b.backGroundImage,
                t = s ? this._filePath + s : null,
                u = b.useMergedTexture;
            if (u ? d.setBackGroundImage(s, ccui.Widget.PLIST_TEXTURE) : d.setBackGroundImage(t), e) {
                var v = b.capInsetsX,
                    w = b.capInsetsY,
                    x = b.capInsetsWidth,
                    y = b.capInsetsHeight;
                d.setBackGroundImageCapInsets(cc.rect(v, w, x, y))
            }
            this.setColorPropsForWidgetFromJsonDictionary(a, b)
        },
        setPropsForScrollViewFromJsonDictionary: function(a, b) {
            this.setPropsForLayoutFromJsonDictionary(a, b);
            var c = a,
                d = b.innerWidth,
                e = b.innerHeight;
            c.setInnerContainerSize(cc.size(d, e));
            var f = b.direction;
            c.setDirection(f), c.setBounceEnabled(b.bounceEnable), this.setColorPropsForWidgetFromJsonDictionary(a, b)
        },
        setPropsForContainerWidgetFromJsonDictionary: function(a, b) {
            this.setPropsForWidgetFromJsonDictionary(a, b);
            var c = a;
            (c instanceof ccui.ScrollView || c instanceof ccui.ListView) && c.setClippingEnabled(b.clipAble), this.setColorPropsForWidgetFromJsonDictionary(a, b)
        },
        setPropsForSliderFromJsonDictionary: function(a, b) {
            this.setPropsForWidgetFromJsonDictionary(a, b);
            var c = a,
                d = b.barTextureScale9Enable || !1;
            c.setScale9Enabled(d);
            var e = b.length,
                f = b.useMergedTexture,
                g = void 0 !== b.barFileName;
            if (g)
                if (d) {
                    var h = b.barFileName,
                        i = h ? this._filePath + h : null;
                    f ? c.loadBarTexture(h, ccui.Widget.PLIST_TEXTURE) : c.loadBarTexture(i), c.setSize(cc.size(e, c.getContentSize().height))
                } else {
                    var h = b.barFileName,
                        i = h ? this._filePath + h : null;
                    f ? c.loadBarTexture(h, ccui.Widget.PLIST_TEXTURE) : c.loadBarTexture(i)
                }
            var j = b.ballNormal,
                k = b.ballPressed,
                l = b.ballDisabled,
                m = j ? this._filePath + j : null,
                n = k ? this._filePath + k : null,
                o = l ? this._filePath + l : null;
            f ? c.loadSlidBallTextures(j, k, l, ccui.Widget.PLIST_TEXTURE) : c.loadSlidBallTextures(m, n, o), c.setPercent(b.percent);
            var h = b.progressBarFileName,
                i = h ? this._filePath + h : null;
            f ? c.loadProgressBarTexture(h, ccui.Widget.PLIST_TEXTURE) : c.loadProgressBarTexture(i), this.setColorPropsForWidgetFromJsonDictionary(a, b)
        },
        setPropsForTextAreaFromJsonDictionary: function(a, b) {
            this.setPropsForWidgetFromJsonDictionary(a, b);
            var c = a;
            c.setString(b.text), void 0 !== b.fontSize && c.setFontSize(b.fontSize);
            var d = b.colorR,
                e = b.colorG,
                f = b.colorB;
            if (c.setColor(cc.color(null == d ? 255 : d, null == e ? 255 : e, null == f ? 255 : f)), c.setFontName(b.fontName), void 0 !== b.areaWidth && void 0 !== b.areaHeight) {
                var g = cc.size(b.areaWidth, b.areaHeight);
                c.setTextAreaSize(g)
            }
            b.hAlignment && c.setTextHorizontalAlignment(b.hAlignment), b.vAlignment && c.setTextVerticalAlignment(b.vAlignment), this.setColorPropsForWidgetFromJsonDictionary(a, b)
        },
        setPropsForTextButtonFromJsonDictionary: function(a, b) {
            this.setPropsForButtonFromJsonDictionary(a, b);
            var c = a;
            c.setTitleText(b.text || "");
            var d = void 0 !== b.textColorR ? b.textColorR : 255,
                e = void 0 !== b.textColorG ? b.textColorG : 255,
                f = void 0 !== b.textColorB ? b.textColorB : 255;
            c.setTitleColor(cc.color(d, e, f)), void 0 !== b.fontSize && c.setTitleFontSize(b.fontSize), void 0 !== b.fontName && c.setTitleFontName(b.fontName), this.setColorPropsForWidgetFromJsonDictionary(a, b)
        },
        setPropsForTextFieldFromJsonDictionary: function(a, b) {
            this.setPropsForWidgetFromJsonDictionary(a, b);
            var c = a;
            void 0 !== b.placeHolder && c.setPlaceHolder(b.placeHolder), c.setString(b.text), void 0 !== b.fontSize && c.setFontSize(b.fontSize), void 0 !== b.fontName && c.setFontName(b.fontName), void 0 !== b.touchSizeWidth && void 0 !== b.touchSizeHeight && c.setTouchSize(cc.size(b.touchSizeWidth, b.touchSizeHeight));
            var d = (b.width, b.height, b.maxLengthEnable);
            if (c.setMaxLengthEnabled(d), d) {
                var e = b.maxLength;
                c.setMaxLength(e)
            }
            var f = b.passwordEnable;
            c.setPasswordEnabled(f), f && c.setPasswordStyleText(b.passwordStyleText), this.setColorPropsForWidgetFromJsonDictionary(a, b)
        },
        setPropsForLoadingBarFromJsonDictionary: function(a, b) {
            this.setPropsForWidgetFromJsonDictionary(a, b);
            var c = a,
                d = b.useMergedTexture,
                e = b.texture,
                f = e ? this._filePath + e : null;
            d ? c.loadTexture(e, ccui.Widget.PLIST_TEXTURE) : c.loadTexture(f), c.setDirection(b.direction), c.setPercent(b.percent), this.setColorPropsForWidgetFromJsonDictionary(a, b)
        },
        setPropsForListViewFromJsonDictionary: function(a, b) {
            this.setPropsForLayoutFromJsonDictionary(a, b)
        },
        setPropsForPageViewFromJsonDictionary: function(a, b) {
            this.setPropsForLayoutFromJsonDictionary(a, b)
        },
        setPropsForLabelBMFontFromJsonDictionary: function(a, b) {
            this.setPropsForWidgetFromJsonDictionary(a, b);
            var c = a,
                d = b.fileName,
                e = this._filePath + d;
            c.setFntFile(e);
            var f = b.text;
            c.setString(f), this.setColorPropsForWidgetFromJsonDictionary(a, b)
        }
    }), ccs.WidgetPropertiesReader0300 = ccs.WidgetPropertiesReader.extend({
        createWidget: function(a, b, c) {
            this._filePath = "" == b ? b : cc.path.join(b, "/");
            for (var d = a.textures, e = 0; e < d.length; e++) {
                var f = d[e],
                    g = b;
                g += f, cc.spriteFrameCache.addSpriteFrames(g)
            }
            var h = a.designWidth,
                i = a.designHeight;
            if (0 >= h || 0 >= i) {
                cc.log("Read design size error!");
                var j = cc.director.getWinSize();
                ccs.uiReader.storeFileDesignSize(c, j)
            } else ccs.uiReader.storeFileDesignSize(c, cc.size(h, i));
            var k = a.widgetTree,
                l = this.widgetFromJsonDictionary(k),
                m = l.getContentSize();
            0 == m.width && 0 == m.height && l.setSize(cc.size(h, i));
            var n = a.animation;
            return ccs.actionManager.initWithDictionary(c, n, l), k = null, n = null, l
        },
        setPropsForAllWidgetFromJsonDictionary: function(a, b, c) {
            a && a.setPropsFromJsonDictionary && a.setPropsFromJsonDictionary(b, c)
        },
        setPropsForAllCustomWidgetFromJsonDictionary: function(a, b, c) {
            var d = ccs.uiReader,
                e = d.getParseObjectMap(),
                f = e[a],
                g = d.getParseCallBackMap(),
                h = g[a];
            f && h && h.call(f, a, b, c)
        },
        widgetFromJsonDictionary: function(a) {
            var b = a.classname,
                c = a.options,
                d = this._createGUI(b),
                e = this._getWidgetReaderClassName(b),
                f = this._createWidgetReaderProtocol(e);
            if (f) this.setPropsForAllWidgetFromJsonDictionary(f, d, c);
            else if (e = this._getWidgetReaderClassNameFromWidget(d), f = ccs.objectFactory.createObject(e), f && d) {
                this.setPropsForAllWidgetFromJsonDictionary(f, d, c);
                var g = c.customProperty,
                    h = JSON.parse(g);
                this.setPropsForAllCustomWidgetFromJsonDictionary(b, d, h)
            } else cc.log("Widget or WidgetReader doesn't exists!!!  Please check your json file.");
            for (var i = a.children, j = 0; j < i.length; j++) {
                var k = this.widgetFromJsonDictionary(i[j]);
                if (k)
                    if (d instanceof ccui.PageView) d.addPage(k);
                    else if (d instanceof ccui.ListView) d.pushBackCustomItem(k);
                else {
                    if (!(d instanceof ccui.Layout)) {
                        if (k.getPositionType() == ccui.Widget.POSITION_PERCENT) {
                            var l = k.getPositionPercent(),
                                m = d.getAnchorPoint();
                            k.setPositionPercent(cc.p(l.x + m.x, l.y + m.y))
                        }
                        var n = d.getAnchorPointInPoints();
                        k.setPosition(cc.p(k.getPositionX() + n.x, k.getPositionY() + n.y))
                    }
                    d.addChild(k)
                }
            }
            return d
        },
        setPropsForWidgetFromJsonDictionary: function(a, b) {
            var c = b.name,
                d = c ? c : "default";
            a.setName(d), void 0 !== b.ignoreSize && a.ignoreContentAdaptWithSize(b.ignoreSize), a.setSizeType(b.sizeType), a.setPositionType(b.positionType), a.setSizePercent(cc.p(b.sizePercentX, b.sizePercentY)), a.setPositionPercent(cc.p(b.positionPercentX, b.positionPercentY));
            var e = b.width,
                f = b.height;
            a.setSize(cc.size(e, f)), a.setTag(b.tag), a.setActionTag(b.actiontag), a.setTouchEnabled(b.touchAble);
            var g = b.x,
                h = b.y;
            a.setPosition(cc.p(g, h)), void 0 !== b.scaleX && a.setScaleX(b.scaleX), void 0 !== b.scaleY && a.setScaleY(b.scaleY), void 0 !== b.rotation && a.setRotation(b.rotation), void 0 !== b.visible && a.setVisible(b.visible), a.setLocalZOrder(b.ZOrder);
            var i = b.layoutParameter;
            if (i) {
                var j, k = i.type;
                switch (k) {
                    case 0:
                        break;
                    case 1:
                        j = new ccui.LinearLayoutParameter;
                        var l = i.gravity;
                        j.setGravity(l);
                        break;
                    case 2:
                        j = new ccui.RelativeLayoutParameter;
                        var m = i.relativeName;
                        j.setRelativeName(m);
                        var n = i.relativeToName;
                        j.setRelativeToWidgetName(n), j.setAlign(i.align)
                }
                var o = i.marginLeft,
                    p = i.marginTop,
                    q = i.marginRight,
                    r = i.marginDown;
                j.setMargin(new ccui.Margin(o, p, q, r)), a.setLayoutParameter(j)
            }
        },
        setColorPropsForWidgetFromJsonDictionary: function(a, b) {
            void 0 !== b.opacity && a.setOpacity(b.opacity);
            var c = void 0 !== b.colorR ? b.colorR : 255,
                d = void 0 !== b.colorG ? b.colorG : 255,
                e = void 0 !== b.colorB ? b.colorB : 255;
            a.setColor(cc.color(c, d, e));
            var f = void 0 !== b.anchorPointX ? b.anchorPointX : a.getWidgetType() == ccui.Widget.TYPE_WIDGET ? .5 : 0,
                g = void 0 !== b.anchorPointY ? b.anchorPointY : a.getWidgetType() == ccui.Widget.TYPE_WIDGET ? .5 : 0;
            a.setAnchorPoint(f, g);
            var h = b.flipX,
                i = b.flipY;
            a.setFlippedX(h), a.setFlippedY(i)
        },
        setPropsForButtonFromJsonDictionary: function(a, b) {
            this.setPropsForWidgetFromJsonDictionary(a, b);
            var c = a,
                d = b.scale9Enable;
            c.setScale9Enabled(d);
            var e = b.normalData,
                f = e.resourceType;
            switch (f) {
                case 0:
                    var g = e.path,
                        h = g ? this._filePath + g : null;
                    c.loadTextureNormal(h);
                    break;
                case 1:
                    var g = e.path;
                    c.loadTextureNormal(g, ccui.Widget.PLIST_TEXTURE)
            }
            e = null;
            var i = b.pressedData,
                j = i.resourceType;
            switch (j) {
                case 0:
                    var k = i.path,
                        l = k ? this._filePath + k : null;
                    c.loadTexturePressed(l);
                    break;
                case 1:
                    var k = i.path;
                    c.loadTexturePressed(k, ccui.Widget.PLIST_TEXTURE)
            }
            i = null;
            var m = b.disabledData,
                n = m.resourceType;
            switch (n) {
                case 0:
                    var o = m.path,
                        p = o ? this._filePath + o : null;
                    c.loadTextureDisabled(p);
                    break;
                case 1:
                    var o = m.path;
                    c.loadTextureDisabled(o, ccui.Widget.PLIST_TEXTURE)
            }
            if (m = null, d) {
                var q = b.capInsetsX,
                    r = b.capInsetsY,
                    s = b.capInsetsWidth,
                    t = b.capInsetsHeight;
                if (c.setCapInsets(cc.rect(q, r, s, t)), void 0 !== b.scale9Width && void 0 !== b.scale9Height) {
                    var u = b.scale9Width,
                        v = b.scale9Height;
                    c.setSize(cc.size(u, v))
                }
            }
            if (void 0 !== b.text) {
                var w = b.text || "";
                w && c.setTitleText(w)
            }
            void 0 !== b.fontSize && c.setTitleFontSize(b.fontSize), void 0 !== b.fontName && c.setTitleFontName(b.fontName);
            var x = void 0 !== b.textColorR ? b.textColorR : 255,
                y = void 0 !== b.textColorG ? b.textColorG : 255,
                z = void 0 !== b.textColorB ? b.textColorB : 255,
                A = cc.color(x, y, z);
            c.setTitleColor(A), this.setColorPropsForWidgetFromJsonDictionary(a, b)
        },
        setPropsForCheckBoxFromJsonDictionary: function(a, b) {
            this.setPropsForWidgetFromJsonDictionary(a, b);
            var c = a,
                d = b.backGroundBoxData,
                e = d.resourceType;
            switch (e) {
                case 0:
                    var f = d.path,
                        g = f ? this._filePath + f : null;
                    c.loadTextureBackGround(g);
                    break;
                case 1:
                    var f = d.path;
                    c.loadTextureBackGround(f, ccui.Widget.PLIST_TEXTURE)
            }
            d = null;
            var h = b.backGroundBoxSelectedData,
                i = h.resourceType;
            switch (i) {
                case 0:
                    var j = h.path,
                        k = j ? this._filePath + j : null;
                    c.loadTextureBackGroundSelected(k);
                    break;
                case 1:
                    var j = h.path;
                    c.loadTextureBackGroundSelected(j, ccui.Widget.PLIST_TEXTURE)
            }
            h = null;
            var l = b.frontCrossData,
                m = l.resourceType;
            switch (m) {
                case 0:
                    var n = l.path,
                        o = n ? this._filePath + n : null;
                    c.loadTextureFrontCross(o);
                    break;
                case 1:
                    var n = l.path;
                    c.loadTextureFrontCross(n, ccui.Widget.PLIST_TEXTURE)
            }
            l = null;
            var p = b.backGroundBoxDisabledData,
                q = p.resourceType;
            switch (q) {
                case 0:
                    var r = p.path,
                        s = r ? this._filePath + r : null;
                    c.loadTextureBackGroundDisabled(s);
                    break;
                case 1:
                    var r = p.path;
                    c.loadTextureBackGroundDisabled(r, ccui.Widget.PLIST_TEXTURE)
            }
            p = null;
            var t = b.frontCrossDisabledData,
                u = t.resourceType;
            switch (u) {
                case 0:
                    var v = b.path,
                        w = v ? this._filePath + v : null;
                    c.loadTextureFrontCrossDisabled(w);
                    break;
                case 1:
                    var v = b.path;
                    c.loadTextureFrontCrossDisabled(v, ccui.Widget.PLIST_TEXTURE)
            }
            t = null;
            var x = b.selectedState || !1;
            a.setSelectedState(x), c.setSelectedState(b, "selectedState"), this.setColorPropsForWidgetFromJsonDictionary(a, b)
        },
        setPropsForImageViewFromJsonDictionary: function(a, b) {
            this.setPropsForWidgetFromJsonDictionary(a, b);
            var c = a,
                d = b.fileNameData,
                e = d.resourceType;
            switch (e) {
                case 0:
                    var f = this._filePath,
                        g = d.path,
                        h = null;
                    g && (h = f + g, c.loadTexture(h));
                    break;
                case 1:
                    var g = d.path;
                    c.loadTexture(g, ccui.Widget.PLIST_TEXTURE)
            }
            d = null;
            var i = b.scale9Enable || !1;
            if (c.setScale9Enabled(i), i) {
                if (void 0 !== b.scale9Width && void 0 !== b.scale9Height) {
                    var j = b.scale9Width,
                        k = b.scale9Height;
                    c.setSize(cc.size(j, k))
                }
                var l = b.capInsetsX,
                    m = b.capInsetsY,
                    n = b.capInsetsWidth,
                    o = b.capInsetsHeight;
                c.setCapInsets(cc.rect(l, m, n, o))
            }
            this.setColorPropsForWidgetFromJsonDictionary(a, b)
        },
        setPropsForLabelFromJsonDictionary: function(a, b) {
            this.setPropsForWidgetFromJsonDictionary(a, b);
            var c = a,
                d = b.touchScaleEnable;
            c.setTouchScaleChangeEnabled(d);
            var e = b.text;
            if (c.setString(e), void 0 !== b.fontSize && c.setFontSize(b.fontSize), void 0 !== b.fontName && c.setFontName(b.fontName), void 0 !== b.areaWidth && void 0 !== b.areaHeight) {
                var f = cc.size(b.areaWidth, b.areaHeight);
                c.setTextAreaSize(f)
            }
            b.hAlignment && c.setTextHorizontalAlignment(b.hAlignment), b.vAlignment && c.setTextVerticalAlignment(b.vAlignment), this.setColorPropsForWidgetFromJsonDictionary(a, b)
        },
        setPropsForLabelAtlasFromJsonDictionary: function(a, b) {
            this.setPropsForWidgetFromJsonDictionary(a, b);
            var c = a,
                d = void 0 !== b.stringValue,
                e = void 0 !== b.charMapFile,
                f = void 0 !== b.itemWidth,
                g = void 0 !== b.itemHeight,
                h = void 0 !== b.startCharMap;
            if (d && e && f && g && h) {
                var i = b.charMapFileData,
                    j = i.resourceType;
                switch (j) {
                    case 0:
                        var k = i.path,
                            l = this._filePath + k;
                        c.setProperty(b.stringValue, l, b.itemWidth, b.itemHeight, b.startCharMap);
                        break;
                    case 1:
                        cc.log("Wrong res type of LabelAtlas!")
                }
                i = null
            }
            this.setColorPropsForWidgetFromJsonDictionary(a, b)
        },
        setPropsForLayoutFromJsonDictionary: function(a, b) {
            this.setPropsForWidgetFromJsonDictionary(a, b);
            var c = a;
            c instanceof ccui.ScrollView || c instanceof ccui.ListView || c.setClippingEnabled(b.clipAble);
            var d = b.backGroundScale9Enable;
            c.setBackGroundImageScale9Enabled(d);
            var e = b.bgColorR,
                f = b.bgColorG,
                g = b.bgColorB,
                h = b.bgStartColorR,
                i = b.bgStartColorG,
                j = b.bgStartColorB,
                k = b.bgEndColorR,
                l = b.bgEndColorG,
                m = b.bgEndColorB,
                n = b.vectorX,
                o = b.vectorY;
            c.setBackGroundColorVector(cc.p(n, o));
            var p = b.bgColorOpacity,
                q = b.colorType;
            c.setBackGroundColorType(q), c.setBackGroundColor(cc.color(h, i, j), cc.color(k, l, m)), c.setBackGroundColor(cc.color(e, f, g)), c.setBackGroundColorOpacity(p);
            var r = b.backGroundImageData || {},
                s = r.resourceType;
            switch (s) {
                case 0:
                    var t = r.path,
                        u = t ? this._filePath + t : null;
                    c.setBackGroundImage(u);
                    break;
                case 1:
                    var t = r.path;
                    c.setBackGroundImage(t, ccui.Widget.PLIST_TEXTURE)
            }
            if (r = null, d) {
                var v = b.capInsetsX,
                    w = b.capInsetsY,
                    x = b.capInsetsWidth,
                    y = b.capInsetsHeight;
                c.setBackGroundImageCapInsets(cc.rect(v, w, x, y))
            }
            c.setLayoutType(b.layoutType), this.setColorPropsForWidgetFromJsonDictionary(a, b)
        },
        setPropsForScrollViewFromJsonDictionary: function(a, b) {
            this.setPropsForLayoutFromJsonDictionary(a, b);
            var c = a,
                d = b.innerWidth,
                e = b.innerHeight;
            c.setInnerContainerSize(cc.size(d, e));
            var f = b.direction;
            c.setDirection(f), c.setBounceEnabled(b.bounceEnable), this.setColorPropsForWidgetFromJsonDictionary(a, b)
        },
        setPropsForSliderFromJsonDictionary: function(a, b) {
            this.setPropsForWidgetFromJsonDictionary(a, b);
            var c = a,
                d = b.barTextureScale9Enable || !1;
            c.setScale9Enabled(d);
            var e = b.length,
                f = void 0 !== b.barFileName;
            if (f)
                if (d) {
                    var g = b.barFileNameData,
                        h = g.resourceType;
                    switch (h) {
                        case 0:
                            var i = g.path,
                                j = i ? this._filePath + i : null;
                            c.loadBarTexture(j);
                            break;
                        case 1:
                            var i = g.path;
                            c.loadBarTexture(i, ccui.Widget.PLIST_TEXTURE)
                    }
                    c.setSize(cc.size(e, c.getContentSize().height)), g = null
                } else {
                    var g = b.barFileNameData,
                        h = g.resourceType;
                    switch (h) {
                        case 0:
                            var i = g.path,
                                j = i ? this._filePath + i : null;
                            c.loadBarTexture(j);
                            break;
                        case 1:
                            var i = g.path;
                            c.loadBarTexture(i, ccui.Widget.PLIST_TEXTURE)
                    }
                    g = null
                }
            var k = b.ballNormalData,
                l = k.resourceType;
            switch (l) {
                case 0:
                    var m = k.path,
                        n = m ? this._filePath + m : null;
                    c.loadSlidBallTextureNormal(n);
                    break;
                case 1:
                    var m = k.path;
                    c.loadSlidBallTextureNormal(m, ccui.Widget.PLIST_TEXTURE)
            }
            k = null;
            var o = b.ballPressedData,
                p = o.resourceType;
            switch (p) {
                case 0:
                    var q = o.path,
                        r = q ? this._filePath + q : null;
                    c.loadSlidBallTexturePressed(r);
                    break;
                case 1:
                    var q = o.path;
                    c.loadSlidBallTexturePressed(q, ccui.Widget.PLIST_TEXTURE)
            }
            o = null;
            var s = b.ballDisabledData,
                t = s.resourceType;
            switch (t) {
                case 0:
                    var u = s.path,
                        v = u ? this._filePath + u : null;
                    c.loadSlidBallTextureDisabled(v);
                    break;
                case 1:
                    var u = s.path;
                    c.loadSlidBallTextureDisabled(u, ccui.Widget.PLIST_TEXTURE)
            }
            s = null;
            var w = b.progressBarData,
                x = w.resourceType;
            switch (x) {
                case 0:
                    var i = w.path,
                        j = i ? this._filePath + i : null;
                    c.loadProgressBarTexture(j);
                    break;
                case 1:
                    var i = w.path;
                    c.loadProgressBarTexture(i, ccui.Widget.PLIST_TEXTURE)
            }
            this.setColorPropsForWidgetFromJsonDictionary(a, b), c.setPercent(b.percent)
        },
        setPropsForTextAreaFromJsonDictionary: function(a, b) {
            this.setPropsForWidgetFromJsonDictionary(a, b);
            var c = a;
            c.setString(b.text), void 0 !== b.fontSize && c.setFontSize(b.fontSize);
            var d = b.colorR,
                e = b.colorG,
                f = b.colorB;
            if (c.setColor(cc.color(null == d ? 255 : d, null == e ? 255 : e, null == f ? 255 : f)), c.setFontName(b.fontName), void 0 !== b.areaWidth && void 0 !== b.areaHeight) {
                var g = cc.size(b.areaWidth, b.areaHeight);
                c.setTextAreaSize(g)
            }
            b.hAlignment && c.setTextHorizontalAlignment(b.hAlignment), b.vAlignment && c.setTextVerticalAlignment(b.vAlignment), this.setColorPropsForWidgetFromJsonDictionary(a, b)
        },
        setPropsForTextButtonFromJsonDictionary: function(a, b) {
            this.setPropsForButtonFromJsonDictionary(a, b);
            var c = a;
            c.setTitleText(b.text || "");
            var d = void 0 !== b.textColorR ? b.textColorR : 255,
                e = void 0 !== b.textColorG ? b.textColorG : 255,
                f = void 0 !== b.textColorB ? b.textColorB : 255;
            c.setTitleColor(cc.color(d, e, f)), void 0 !== b.fontSize && c.setTitleFontSize(b.fontSize), void 0 !== b.fontName && c.setTitleFontName(b.fontName), this.setColorPropsForWidgetFromJsonDictionary(a, b)
        },
        setPropsForTextFieldFromJsonDictionary: function(a, b) {
            this.setPropsForWidgetFromJsonDictionary(a, b);
            var c = a;
            void 0 !== b.placeHolder && c.setPlaceHolder(b.placeHolder), c.setString(b.text), void 0 !== b.fontSize && c.setFontSize(b.fontSize), void 0 !== b.fontName && c.setFontName(b.fontName), void 0 !== b.touchSizeWidth && void 0 !== b.touchSizeHeight && c.setTouchSize(cc.size(b.touchSizeWidth, b.touchSizeHeight));
            var d = (b.width, b.height, b.maxLengthEnable);
            if (c.setMaxLengthEnabled(d), d) {
                var e = b.maxLength;
                c.setMaxLength(e)
            }
            var f = b.passwordEnable;
            c.setPasswordEnabled(f), f && c.setPasswordStyleText(b.passwordStyleText), this.setColorPropsForWidgetFromJsonDictionary(a, b)
        },
        setPropsForLoadingBarFromJsonDictionary: function(a, b) {
            this.setPropsForWidgetFromJsonDictionary(a, b);
            var c = a,
                d = b.textureData,
                e = d.resourceType;
            switch (e) {
                case 0:
                    var f = this._filePath,
                        g = d.path,
                        h = null;
                    g && (h = f + g, c.loadTexture(h));
                    break;
                case 1:
                    var g = d.path;
                    c.loadTexture(g, ccui.Widget.PLIST_TEXTURE)
            }
            d = null;
            var i = b.scale9Enable;
            if (c.setScale9Enabled(i), i) {
                var j = b.capInsetsX,
                    k = b.capInsetsY,
                    l = b.capInsetsWidth,
                    m = b.capInsetsHeight;
                c.setCapInsets(cc.rect(j, k, l, m));
                var n = b.width,
                    o = b.height;
                c.setSize(cc.size(n, o))
            }
            c.setDirection(b.direction), c.setPercent(b.percent), this.setColorPropsForWidgetFromJsonDictionary(a, b)
        },
        setPropsForListViewFromJsonDictionary: function(a, b) {
            this.setPropsForLayoutFromJsonDictionary(a, b);
            var c = b.innerWidth || 0,
                d = b.innerHeight || 0;
            a.setInnerContainerSize(cc.size(c, d)), a.setDirection(b.direction || 0), a.setGravity(b.gravity || 0), a.setItemsMargin(b.itemMargin || 0)
        },
        setPropsForPageViewFromJsonDictionary: function(a, b) {
            this.setPropsForLayoutFromJsonDictionary(a, b)
        },
        setPropsForLabelBMFontFromJsonDictionary: function(a, b) {
            this.setPropsForWidgetFromJsonDictionary(a, b);
            var c = a,
                d = b.fileNameData,
                e = d.resourceType;
            switch (e) {
                case 0:
                    var f = d.path,
                        g = this._filePath + f;
                    c.setFntFile(g);
                    break;
                case 1:
                    cc.log("Wrong res type of LabelAtlas!")
            }
            d = null;
            var h = b.text;
            c.setString(h), this.setColorPropsForWidgetFromJsonDictionary(a, b)
        },
        widgetFromXML: function(a, b) {
            var c = b.substr(0, b.find("ObjectData")),
                d = this.createGUI(c),
                e = this.getWidgetReaderClassName(c),
                f = this.createWidgetReaderProtocol(e);
            if (f) this.setPropsForAllWidgetFromXML(f, d, a);
            else if (e = this.getWidgetReaderClassName(d), f = this.createWidgetReaderProtocol(e), f && d) {
                this.setPropsForAllWidgetFromXML(f, d, a);
                var g, h = "";
                g.Parse(h), g.HasParseError() && cc.log("GetParseError %s\n", g.GetParseError()), this.setPropsForAllCustomWidgetFromJsonDictionary(c, d, g)
            } else cc.log("Widget or WidgetReader doesn't exists!!!  Please check your json file.");
            var i = !1;
            for (a = a.FirstChildElement(); a;) {
                if ("Children" !== a.Name()) {
                    i = !0;
                    break
                }
                a = a.NextSiblingElement()
            }
            if (i)
                for (a = a.FirstChildElement(); a;) {
                    for (var j = a.FirstAttribute(); j;) {
                        var k = j.Name(),
                            l = j.Value();
                        if ("ctype" == k) {
                            var m = this.widgetFromXML(a, l);
                            if (m) {
                                var n = d,
                                    o = d;
                                if (n instanceof ccui.PageView) {
                                    var p = m;
                                    p instanceof ccui.Layout && n.addPage(p)
                                } else if (o) {
                                    var q = m;
                                    q instanceof ccui.Widget && o.pushBackCustomItem(q)
                                } else d.addChild(m)
                            }
                            break
                        }
                        j = j.Next()
                    }
                    a = a.NextSiblingElement()
                }
            return d
        },
        setPropsForAllWidgetFromXML: function(a, b, c) {
            a.setPropsFromXML(b, c)
        }
    }), ccs.sceneReader = {
        _baseBath: "",
        _listener: null,
        _selector: null,
        _node: null,
        createNodeWithSceneFile: function(a) {
            this._node = null;
            do {
                this._baseBath = cc.path.dirname(a);
                var b = cc.loader.getRes(a);
                if (!b) throw "Please load the resource first : " + a;
                this._node = this.createObject(b, null), ccs.triggerManager.parse(b.Triggers || [])
            } while (0);
            return this._node
        },
        createObject: function(a, b) {
            var c = a.classname;
            if ("CCNode" == c) {
                var d = null;
                b ? (d = new cc.Node, b.addChild(d)) : d = new cc.Node, this.setPropertyFromJsonDict(d, a);
                for (var e = a.components, f = 0; f < e.length; f++) {
                    var g = e[f];
                    if (!g) break;
                    c = g.classname;
                    var h = g.name,
                        i = g.fileData,
                        j = "",
                        k = "",
                        l = 0;
                    null != i && (l = void 0 !== i.resourceType ? i.resourceType : -1, j = cc.path.join(this._baseBath, i.path), k = i.plistFile);
                    var m = cc.path.extname(j);
                    if ("CCSprite" == c) {
                        var n = null;
                        if (0 == l) {
                            if (".png" != m) continue;
                            n = new cc.Sprite(j)
                        } else {
                            if (1 != l) continue;
                            if (".plist" != m) continue;
                            k = cc.path.join(this._baseBath, k);
                            var o = cc.path.changeExtname(k, ".png");
                            cc.spriteFrameCache.addSpriteFrames(k, o), n = new cc.Sprite("#" + i.path)
                        }
                        var p = new ccs.ComRender(n, "CCSprite");
                        null != h && p.setName(h), d.addComponent(p), this._callSelector(n, g)
                    } else if ("CCTMXTiledMap" == c) {
                        var q = null;
                        if (0 != l) continue;
                        if (".tmx" != m) continue;
                        q = new cc.TMXTiledMap(j);
                        var p = new ccs.ComRender(q, "CCTMXTiledMap");
                        null != h && p.setName(h), d.addComponent(p), this._callSelector(q, g)
                    } else if ("CCParticleSystemQuad" == c) {
                        if (".plist" != m) continue;
                        var r = null;
                        if (0 != l) {
                            cc.log("unknown resourcetype on CCParticleSystemQuad!");
                            continue
                        }
                        r = new cc.ParticleSystem(j), r.setPosition(0, 0);
                        var p = new ccs.ComRender(r, "CCParticleSystemQuad");
                        null != h && p.setName(h), d.addComponent(p), this._callSelector(r, g)
                    } else if ("CCArmature" == c) {
                        if (0 != l) continue;
                        var s = cc.loader.getRes(j);
                        s || cc.log("Please load the resource [%s] first!", j);
                        var t = s.armature_data,
                            u = t[0],
                            v = u.name;
                        ccs.armatureDataManager.addArmatureFileInfo(j);
                        var w = new ccs.Armature(v),
                            p = new ccs.ComRender(w, "CCArmature");
                        null != h && p.setName(h), d.addComponent(p);
                        var x = g.selectedactionname;
                        x && w.getAnimation() && w.getAnimation().play(x), s = null, u = null, this._callSelector(w, g)
                    } else if ("CCComAudio" == c) {
                        var y = null;
                        if (0 != l) continue;
                        y = new ccs.ComAudio, y.preloadEffect(j), h && y.setName(h), d.addComponent(y), this._callSelector(y, g)
                    } else if ("CCComAttribute" == c) {
                        var z = null;
                        if (0 != l) {
                            cc.log("unknown resourcetype on CCComAttribute!");
                            continue
                        }
                        z = new ccs.ComAttribute, "" != j && z.parse(j), h && z.setName(h), d.addComponent(z), this._callSelector(z, g)
                    } else if ("CCBackgroundAudio" == c) {
                        if (!m) continue;
                        if (0 != l) continue;
                        var y = new ccs.ComAudio;
                        y.preloadBackgroundMusic(j), y.setFile(j);
                        var A = Boolean(g.loop || 0);
                        y.setLoop(A), h && y.setName(h), d.addComponent(y), y.playBackgroundMusic(j, A), this._callSelector(y, g)
                    } else if ("GUIComponent" == c) {
                        var B = ccs.uiReader.widgetFromJsonFile(j),
                            p = new ccs.ComRender(B, "GUIComponent");
                        null != h && p.setName(h), d.addComponent(p), this._callSelector(y, g)
                    }
                    g = null
                }
                for (var C = a.gameobjects, f = 0; f < C.length; f++) {
                    var g = C[f];
                    if (!g) break;
                    this.createObject(g, d), g = null
                }
                var D = a.CanvasSize;
                if (D) {
                    var E = D._width,
                        F = D._height;
                    d.setContentSize(cc.size(E, F))
                }
                return d
            }
            return null
        },
        _nodeByTag: function(a, b) {
            if (null == a) return null;
            for (var c = null, d = a.getChildren(), e = 0; e < d.length; e++) {
                var f = d[e];
                if (f && f.getTag() == b) {
                    c = f;
                    break
                }
                if (c = this._nodeByTag(f, b)) break
            }
            return c
        },
        getNodeByTag: function(a) {
            return null == this._node ? null : this._node.getTag() == a ? this._node : this._nodeByTag(this._node, a)
        },
        setPropertyFromJsonDict: function(a, b) {
            var c = cc.isUndefined(b.x) ? 0 : b.x,
                d = cc.isUndefined(b.y) ? 0 : b.y;
            a.setPosition(c, d);
            var e = Boolean(cc.isUndefined(b.visible) ? 1 : b.visible);
            a.setVisible(e);
            var f = cc.isUndefined(b.objecttag) ? -1 : b.objecttag;
            a.setTag(f);
            var g = cc.isUndefined(b.zorder) ? 0 : b.zorder;
            a.setLocalZOrder(g);
            var h = cc.isUndefined(b.scalex) ? 1 : b.scalex,
                i = cc.isUndefined(b.scaley) ? 1 : b.scaley;
            a.setScaleX(h), a.setScaleY(i);
            var j = cc.isUndefined(b.rotation) ? 0 : b.rotation;
            a.setRotation(j);
            var k = b.name || "";
            a.setName(k)
        },
        setTarget: function(a, b) {
            this._listener = b, this._selector = a
        },
        _callSelector: function(a, b) {
            this._selector && this._selector.call(this._listener, a, b)
        },
        version: function() {
            return "1.2.0.0"
        },
        clear: function() {
            ccs.triggerManager.removeAll(), cc.audioEngine.end()
        }
    }, ccs.ActionTimelineData = ccs.Class.extend({
        _actionTag: 0,
        ctor: function(a) {
            this._init(a)
        },
        _init: function(a) {
            return this._actionTag = a, !0
        },
        setActionTag: function(a) {
            this._actionTag = a
        },
        getActionTag: function() {
            return this._actionTag
        }
    }), ccs.ActionTimelineData.create = function(a) {
        return new ccs.ActionTimelineData(a)
    }, ccs.ActionTimeline = cc.Action.extend({
        _timelineMap: null,
        _timelineList: null,
        _duration: 0,
        _time: null,
        _timeSpeed: 1,
        _frameInternal: 1 / 60,
        _playing: !1,
        _currentFrame: 0,
        _startFrame: 0,
        _endFrame: 0,
        _loop: null,
        _frameEventListener: null,
        ctor: function() {
            cc.Action.prototype.ctor.call(this), this._timelineMap = {}, this._timelineList = [], this.init()
        },
        _gotoFrame: function(a) {
            for (var b = this._timelineList.length, c = 0; b > c; c++) this._timelineList[c]._gotoFrame(a)
        },
        _stepToFrame: function(a) {
            for (var b = this._timelineList.length, c = 0; b > c; c++) this._timelineList[c]._stepToFrame(a)
        },
        _emitFrameEvent: function(a) {
            this._frameEventListener && this._frameEventListener(a)
        },
        init: function() {
            return !0
        },
        gotoFrameAndPlay: function(a, b, c, d) {
            var e, f = 0,
                g = arguments.length,
                h = [];
            for (f; g > f; f++) "boolean" == typeof arguments[f] ? e = arguments[f] : h.push(arguments[f]);
            a = h[0], b = h[1] || this._duration, c = h[2] || a, d = null != e ? e : !0, this._startFrame = a, this._endFrame = b, this._currentFrame = c, this._loop = d, this._time = this._currentFrame * this._frameInternal, this.resume(), this._gotoFrame(this._currentFrame)
        },
        gotoFrameAndPause: function(a) {
            this._startFrame = this._currentFrame = a, this._time = this._currentFrame * this._frameInternal, this.pause(), this._gotoFrame(this._currentFrame)
        },
        pause: function() {
            this._playing = !1
        },
        resume: function() {
            this._playing = !0
        },
        isPlaying: function() {
            return this._playing
        },
        setTimeSpeed: function(a) {
            this._timeSpeed = a
        },
        getTimeSpeed: function() {
            return this._timeSpeed
        },
        setDuration: function(a) {
            this._duration = a
        },
        getDuration: function() {
            return this._duration
        },
        getStartFrame: function() {
            return this._startFrame
        },
        getEndFrame: function() {
            return this._endFrame
        },
        setCurrentFrame: function(a) {
            a >= this._startFrame && a >= this._endFrame ? (this._currentFrame = a, this._time = this._currentFrame * this._frameInternal) : cc.log("frame index is not between start frame and end frame")
        },
        getCurrentFrame: function() {
            return this._currentFrame
        },
        addTimeline: function(a) {
            var b = a.getActionTag();
            this._timelineMap[b] || (this._timelineMap[b] = []), this._timelineMap[b].some(function(b) {
                return b === a ? !0 : void 0
            }) || (this._timelineList.push(a), this._timelineMap[b].push(a), a.setActionTimeline(this))
        },
        removeTimeline: function(a) {
            var b = a.getActionTag();
            this._timelineMap[b] && this._timelineMap[b].some(function(b) {
                return b === a ? !0 : void 0
            }) && (cc.arrayRemoveObject(this._timelineMap[b], a), cc.arrayRemoveObject(this._timelineList, a), a.setActionTimeline(null))
        },
        getTimelines: function() {
            return this._timelineList
        },
        setFrameEventCallFunc: function(a) {
            this._frameEventListener = a
        },
        clearFrameEventCallFunc: function() {
            this._frameEventListener = null
        },
        clone: function() {
            var a = new ccs.ActionTimeline;
            a.setDuration(this._duration), a.setTimeSpeed(this._timeSpeed);
            for (var b in this._timelineMap) {
                var c = this._timelineMap[b];
                for (var d in c) {
                    var e = c[d],
                        f = e.clone();
                    a.addTimeline(f)
                }
            }
            return a
        },
        reverse: function() {
            return null
        },
        step: function(a) {
            this._playing && 0 != this._timelineMap.length && 0 != this._duration && (this._time += a * this._timeSpeed, this._currentFrame = this._time / this._frameInternal, this._stepToFrame(this._currentFrame), this._time > this._endFrame * this._frameInternal && (this._playing = this._loop, this._playing ? this.gotoFrameAndPlay(this._startFrame, this._endFrame, this._loop) : this._time = this._endFrame * this._frameInternal))
        },
        _foreachNodeDescendant: function(a, b) {
            b(a);
            for (var c = a.getChildren(), d = 0; d < c.length; d++) {
                var e = c[d];
                this._foreachNodeDescendant(e, b)
            }
        },
        startWithTarget: function(a) {
            cc.Action.prototype.startWithTarget.call(this, a);
            var b = this,
                c = function(a) {
                    var c = a.getUserObject();
                    if (c) {
                        var d = c.getActionTag();
                        if (b._timelineMap[d])
                            for (var e = b._timelineMap[d], f = 0; f < e.length; f++) {
                                var g = e[f];
                                g.setNode(a)
                            }
                    }
                };
            this._foreachNodeDescendant(a, c)
        },
        isDone: function() {
            return !1
        }
    }), ccs.ActionTimeline.create = function() {
        return new ccs.ActionTimeline
    }, ccui.actionTimelineCacheStatic = {
        FrameType_VisibleFrame: "VisibleFrame",
        FrameType_PositionFrame: "PositionFrame",
        FrameType_ScaleFrame: "ScaleFrame",
        FrameType_RotationFrame: "RotationFrame",
        FrameType_SkewFrame: "SkewFrame",
        FrameType_RotationSkewFrame: "RotationSkewFrame",
        FrameType_AnchorFrame: "AnchorPointFrame",
        FrameType_InnerActionFrame: "InnerActionFrame",
        FrameType_ColorFrame: "ColorFrame",
        FrameType_TextureFrame: "TextureFrame",
        FrameType_EventFrame: "EventFrame",
        FrameType_ZOrderFrame: "ZOrderFrame",
        ACTION: "action",
        DURATION: "duration",
        TIMELINES: "timelines",
        FRAME_TYPE: "frameType",
        FRAMES: "frames",
        FRAME_INDEX: "frameIndex",
        TWEEN: "tween",
        TIME_SPEED: "speed",
        ACTION_TAG: "actionTag",
        INNER_ACTION: "innerActionType",
        START_FRAME: "startFrame",
        X: "x",
        Y: "y",
        ROTATION: "rotation",
        ALPHA: "alpha",
        RED: "red",
        GREEN: "green",
        BLUE: "blue",
        Value: "value"
    }, ccs.actionTimelineCache = {
        _FrameCreateFunc: null,
        _Pair: null,
        _funcs: null,
        _animationActions: null,
        init: function() {
            this._animationActions = {}, this._funcs = {}, this._funcs.VisibleFrame = this._loadVisibleFrame, this._funcs.PositionFrame = this._loadPositionFrame, this._funcs.ScaleFrame = this._loadScaleFrame, this._funcs.RotationFrame = this._loadRotationFrame, this._funcs.SkewFrame = this._loadSkewFrame, this._funcs.RotationSkewFrame = this._loadRotationSkewFrame, this._funcs.AnchorFrame = this._loadAnchorPointFrame, this._funcs.InnerActionFrame = this._loadInnerActionFrame, this._funcs.ColorFrame = this._loadColorFrame, this._funcs.TextureFrame = this._loadTextureFrame, this._funcs.EventFrame = this._loadEventFrame, this._funcs.ZOrderFrame = this._loadZOrderFrame
        },
        removeAction: function(a) {
            this._animationActions[a] && delete this._animationActions[a]
        },
        createAction: function(a) {
            var b = a,
                c = b.lastIndexOf("."),
                d = b.substr(c + 1, b.length),
                e = ccs.actionTimelineCache;
            if ("csb" == d) throw "Does not support protobuf";
            return "json" == d || "ExportJson" == d ? e.createActionFromJson(a) : ("xml" == d && cc.log("Does not support"), null)
        },
        createActionFromJson: function(a) {
            var b = this._animationActions[a];
            return null == b && (b = this.loadAnimationActionWithFile(a)), b.clone()
        },
        loadAnimationActionWithFile: function(a) {
            var b = cc.loader.getRes(a);
            return this.loadAnimationActionWithContent(a, b)
        },
        loadAnimationActionWithContent: function(a, b) {
            var c = this._animationActions[a];
            if (c) return c;
            var d = b[ccui.actionTimelineCacheStatic.ACTION];
            c = new ccs.ActionTimeline, c.setDuration(d[ccui.actionTimelineCacheStatic.DURATION]), c.setTimeSpeed(d[ccui.actionTimelineCacheStatic.TIME_SPEED] || 1);
            for (var e = d[ccui.actionTimelineCacheStatic.TIMELINES].length, f = 0; e > f; f++) {
                var g = d[ccui.actionTimelineCacheStatic.TIMELINES][f],
                    h = this._loadTimeline(g);
                h && c.addTimeline(h)
            }
            return this._animationActions[a] = c, c
        },
        _loadTimeline: function(a) {
            var b = null,
                c = a[ccui.actionTimelineCacheStatic.FRAME_TYPE];
            if (null == c) return null;
            if (c && this._funcs[c]) {
                b = new ccs.Timeline;
                var d = a[ccui.actionTimelineCacheStatic.ACTION_TAG];
                b.setActionTag(d);
                for (var e = this._funcs[c], f = a[ccui.actionTimelineCacheStatic.FRAMES].length, g = 0; f > g; g++) {
                    var h = a[ccui.actionTimelineCacheStatic.FRAMES][g],
                        i = null;
                    if (null != e) {
                        i = e(h);
                        var j = h[ccui.actionTimelineCacheStatic.FRAME_INDEX];
                        i.setFrameIndex(j);
                        var k = h[ccui.actionTimelineCacheStatic.TWEEN] || !1;
                        i.setTween(k)
                    }
                    b.addFrame(i)
                }
            }
            return b
        },
        _loadVisibleFrame: function(a) {
            var b = new ccs.VisibleFrame,
                c = a[ccui.actionTimelineCacheStatic.Value];
            return b.setVisible(c), b
        },
        _loadPositionFrame: function(a) {
            var b = new ccs.PositionFrame,
                c = a[ccui.actionTimelineCacheStatic.X],
                d = a[ccui.actionTimelineCacheStatic.Y];
            return b.setPosition(cc.p(c, d)), b
        },
        _loadScaleFrame: function(a) {
            var b = new ccs.ScaleFrame,
                c = a[ccui.actionTimelineCacheStatic.X],
                d = a[ccui.actionTimelineCacheStatic.Y];
            return b.setScaleX(c), b.setScaleY(d), b
        },
        _loadSkewFrame: function(a) {
            var b = new ccs.SkewFrame,
                c = a[ccui.actionTimelineCacheStatic.X],
                d = a[ccui.actionTimelineCacheStatic.Y];
            return b.setSkewX(c), b.setSkewY(d), b
        },
        _loadRotationSkewFrame: function(a) {
            var b = new ccs.RotationSkewFrame,
                c = a[ccui.actionTimelineCacheStatic.X],
                d = a[ccui.actionTimelineCacheStatic.Y];
            return b.setSkewX(c), b.setSkewY(d), b
        },
        _loadRotationFrame: function(a) {
            var b = new ccs.RotationFrame,
                c = a[ccui.actionTimelineCacheStatic.ROTATION];
            return b.setRotation(c), b
        },
        _loadAnchorPointFrame: function(a) {
            var b = new ccs.AnchorPointFrame,
                c = a[ccui.actionTimelineCacheStatic.X],
                d = a[ccui.actionTimelineCacheStatic.Y];
            return b.setAnchorPoint(Point(c, d)), b
        },
        _loadInnerActionFrame: function(a) {
            var b = new ccs.InnerActionFrame,
                c = a[ccui.actionTimelineCacheStatic.INNER_ACTION],
                d = a[ccui.actionTimelineCacheStatic.START_FRAME];
            return b.setInnerActionType(c), b.setStartFrameIndex(d), b
        },
        _loadColorFrame: function(a) {
            var b = new ccs.ColorFrame,
                c = a[ccui.actionTimelineCacheStatic.ALPHA],
                d = a[ccui.actionTimelineCacheStatic.RED],
                e = a[ccui.actionTimelineCacheStatic.GREEN],
                f = a[ccui.actionTimelineCacheStatic.BLUE];
            return b.setAlpha(c), b.setColor(cc.color(d, e, f)), b
        },
        _loadTextureFrame: function(a) {
            var b = new ccs.TextureFrame,
                c = a[ccui.actionTimelineCacheStatic.Value];
            if (null != c) {
                var d = c,
                    e = cc.spriteFrameCache.getSpriteFrame(d);
                if (null == e) {
                    var f = ccs.csLoader.getJsonPath();
                    d = f + c
                }
                b.setTextureName(d)
            }
            return b
        },
        _loadEventFrame: function(a) {
            var b = new ccs.EventFrame,
                c = a[ccui.actionTimelineCacheStatic.Value];
            return null != c && b.setEvent(c), b
        },
        _loadZOrderFrame: function(a) {
            var b = new ccs.ZOrderFrame,
                c = a[ccui.actionTimelineCacheStatic.Value];
            return b.setZOrder(c), b
        },
        createActionFromXML: function(a) {
            var b = this._animationActions[a];
            return null == b && (b = this.loadAnimationActionWithFileFromXML(a)), b.clone()
        },
        loadAnimationActionWithFileFromXML: function(a) {
            var b = this._animationActions[a];
            if (b) return b;
            var c = cc.loader.getRes(a),
                d = new tinyxml2.XMLDocument;
            d.Parse(c);
            for (var e = d.RootElement(), f = e.FirstChildElement(), g = !1; f;) {
                if (0 == strcmp("Content", f.Name())) {
                    var h = f.FirstAttribute();
                    h || (g = !0)
                }
                if (g) break;
                var i = f.FirstChildElement();
                f = i ? i : f.NextSiblingElement()
            }
            if (g)
                for (var i = f.FirstChildElement(); i;) {
                    var j = i.Name();
                    if ("Animation" == j) {
                        var k = i;
                        b = this.loadActionTimelineFromXML(k)
                    }
                    i = i.NextSiblingElement()
                }
            return b
        },
        loadActionTimelineFromXML: function(a) {
            for (var b = new ccs.ActionTimeline, c = a.FirstAttribute(); c;) {
                var d = c.Name(),
                    e = c.Value();
                "Duration" == d ? b.setDuration(atoi(e.c_str())) : "Speed" == d && b.setTimeSpeed(atof(e.c_str())), c = c.Next()
            }
            for (var f = a.FirstChildElement(); f;) {
                var g = loadTimelineFromXML(f);
                g && b.addTimeline(g), f = f.NextSiblingElement()
            }
            return b
        },
        loadTimelineFromXML: function(a) {
            for (var b = null, c = 0, d = "", e = a.FirstAttribute(); e;) {
                var f = e.Name(),
                    g = e.Value();
                "ActionTag" == f ? c = atoi(g.c_str()) : "FrameType" == f && (d = g), e = e.Next()
            }
            "" != d && (b = new ccs.Timeline, b.setActionTag(c));
            for (var h = a.FirstChildElement(); h;) {
                var i = null;
                d == FrameType_VisibleFrame ? i = loadVisibleFrameFromXML(h) : d == FrameType_PositionFrame ? i = loadPositionFrameFromXML(h) : d == FrameType_ScaleFrame ? i = loadScaleFrameFromXML(h) : d == FrameType_RotationSkewFrame ? i = loadRotationSkewFrameFromXML(h) : d == FrameType_AnchorFrame ? i = loadAnchorPointFrameFromXML(h) : d == FrameType_ColorFrame ? i = loadColorFrameFromXML(h) : d == FrameType_TextureFrame ? i = loadTextureFrameFromXML(h) : d == FrameType_EventFrame ? i = loadEventFrameFromXML(h) : d == FrameType_ZOrderFrame && (i = loadZOrderFrameFromXML(h)), i && b.addFrame(i), h = h.NextSiblingElement()
            }
            return b
        },
        loadVisibleFrameFromXML: function(a) {
            var b = new ccs.VisibleFrame;
            b.setTween(!0);
            for (var c = a.FirstAttribute(); c;) {
                var d = c.Name(),
                    e = c.Value();
                "Value" == d ? b.setVisible("True" == e ? !0 : !1) : "FrameIndex" == d ? b.setFrameIndex(atoi(e)) : "Tween" == d && b.setTween("True" == e ? !0 : !1), c = c.Next()
            }
            return b
        },
        loadPositionFrameFromXML: function(a) {
            var b = new ccs.PositionFrame;
            b.setTween(!0);
            for (var c = a.FirstAttribute(); c;) {
                var d = c.Name(),
                    e = c.Value();
                "X" == d ? b.setX(atof(e)) : "Y" == d ? b.setY(atof(e)) : "FrameIndex" == d ? b.setFrameIndex(atoi(e)) : "Tween" == d && b.setTween("True" == e ? !0 : !1), c = c.Next()
            }
            return b
        },
        loadScaleFrameFromXML: function(a) {
            var b = new ccs.ScaleFrame;
            b.setTween(!0);
            for (var c = a.FirstAttribute(); c;) {
                var d = c.Name(),
                    e = c.Value();
                "X" == d ? b.setScaleX(atof(e)) : "Y" == d ? b.setScaleY(atof(e)) : "FrameIndex" == d ? b.setFrameIndex(atoi(e)) : "Tween" == d && b.setTween("True" == e ? !0 : !1), c = c.Next()
            }
            return b
        },
        loadRotationSkewFrameFromXML: function(a) {
            var b = new ccs.RotationSkewFrame;
            b.setTween(!0);
            for (var c = a.FirstAttribute(); c;) {
                var d = c.Name(),
                    e = c.Value();
                "X" == d ? b.setSkewX(atof(e)) : "Y" == d ? b.setSkewY(atof(e)) : "FrameIndex" == d ? b.setFrameIndex(atoi(e)) : "Tween" == d && b.setTween("True" == e ? !0 : !1), c = c.Next()
            }
            return b
        },
        loadAnchorPointFrameFromXML: function(a) {
            var b = new ccs.AnchorPointFrame,
                c = .5,
                d = .5;
            b.setTween(!0);
            for (var e = a.FirstAttribute(); e;) {
                var f = e.Name(),
                    g = e.Value();
                "X" == f ? c = atof(g) : "Y" == f ? d = atof(g) : "FrameIndex" == f ? b.setFrameIndex(atoi(g)) : "Tween" == f && b.setTween("True" == g ? !0 : !1), e = e.Next()
            }
            return b.setAnchorPoint(cc.p(c, d)), b
        },
        loadColorFrameFromXML: function(a) {
            var b = new ccs.ColorFrame,
                c = 255,
                d = 255,
                e = 255;
            b.setTween(!0);
            for (var f = a.FirstAttribute(); f;) {
                var g = f.Name(),
                    h = f.Value();
                "FrameIndex" == g ? b.setFrameIndex(atoi(h)) : "Alpha" == g ? b.setAlpha(atoi(h)) : "Tween" == g && b.setTween("True" == h ? !0 : !1), f = f.Next()
            }
            for (var i = a.FirstChildElement(); i;) {
                for (var f = i.FirstAttribute(); f;) {
                    var g = f.Name(),
                        h = f.Value();
                    "R" == g ? c = atoi(h) : "G" == g ? d = atoi(h) : "B" == g && (e = atoi(h)), f = f.Next()
                }
                i = i.NextSiblingElement()
            }
            return b.setColor(cc.color(c, d, e)), b
        },
        loadTextureFrameFromXML: function(a) {
            var b = new ccs.TextureFrame;
            b.setTween(!0);
            for (var c = a.FirstAttribute(); c;) {
                var d = c.Name(),
                    e = c.Value();
                "Path" == d ? b.setTextureName(e) : "FrameIndex" == d ? b.setFrameIndex(atoi(e.c_str())) : "Tween" == d && b.setTween("True" == e ? !0 : !1), c = c.Next()
            }
            return b
        },
        loadEventFrameFromXML: function(a) {
            var b = new ccs.EventFrame;
            b.setTween(!0);
            for (var c = a.FirstAttribute(); c;) {
                var d = c.Name(),
                    e = c.Value();
                "EventStr" == d ? b.setEvent(e) : "FrameIndex" == d ? b.setFrameIndex(atoi(e.c_str())) : "Tween" == d && b.setTween("True" == e ? !0 : !1), c = c.Next()
            }
            return b
        },
        loadZOrderFrameFromXML: function() {
            var a = new ccs.ZOrderFrame;
            a.setTween(!0);
            for (var b = frameElement.FirstAttribute(); b;) {
                var c = b.Name(),
                    d = b.Value();
                "zorder" == c ? a.setZOrder(atoi(d)) : "FrameIndex" == c ? a.setFrameIndex(atoi(d)) : "Tween" == c && a.setTween("True" == d ? !0 : !1), b = b.Next()
            }
            return a
        }
    }, ccs.actionTimelineCache.init(), ccs.actionTimelineCache._sharedActionCache = null, ccs.Frame = ccs.Class.extend({
        _frameIndex: null,
        _tween: null,
        _timeline: null,
        _node: null,
        ctor: function() {
            this._frameIndex = 0, this._tween = !0, this._timeline = null, this._node = null
        },
        _emitEvent: function() {
            this._timeline && this._timeline.getActionTimeline()._emitFrameEvent(this)
        },
        _cloneProperty: function(a) {
            this._frameIndex = a.getFrameIndex(), this._tween = a.isTween()
        },
        setFrameIndex: function(a) {
            this._frameIndex = a
        },
        getFrameIndex: function() {
            return this._frameIndex
        },
        setTimeline: function(a) {
            this._timeline = a
        },
        getTimeline: function() {
            return this._timeline
        },
        setNode: function(a) {
            this._node = a
        },
        getNode: function() {
            return this._node
        },
        setTween: function(a) {
            this._tween = a
        },
        isTween: function() {
            return this._tween
        },
        onEnter: function() {},
        apply: function() {},
        clone: function() {}
    }), ccs.VisibleFrame = ccs.Frame.extend({
        _visible: !0,
        ctor: function() {
            ccs.Frame.prototype.ctor.call(this), this._visible = !0
        },
        onEnter: function() {
            this._node.setVisible(this._visible)
        },
        clone: function() {
            var a = new ccs.VisibleFrame;
            return a.setVisible(this._visible), a._cloneProperty(this), a
        },
        setVisible: function(a) {
            this._visible = a
        },
        isVisible: function() {
            return this._visible
        }
    }), ccs.VisibleFrame.create = function() {
        return new ccs.VisibleFrame
    }, ccs.TextureFrame = ccs.Frame.extend({
        _sprite: null,
        _textureName: null,
        ctor: function() {
            ccs.Frame.prototype.ctor.call(this), this._textureName = ""
        },
        setNode: function(a) {
            ccs.Frame.prototype.setNode.call(this, a), this._sprite = a
        },
        onEnter: function() {
            if (this._sprite) {
                var a = cc.spriteFrameCache.getSpriteFrame(this._textureName);
                null != a ? this._sprite.setSpriteFrame(a) : this._sprite.setTexture(this._textureName)
            }
        },
        clone: function() {
            var a = new ccs.TextureFrame;
            return a.setTextureName(this._textureName), a._cloneProperty(this), a
        },
        setTextureName: function(a) {
            this._textureName = a
        },
        getTextureName: function() {
            return this._textureName
        }
    }), ccs.TextureFrame.create = function() {
        return new ccs.TextureFrame
    }, ccs.RotationFrame = ccs.Frame.extend({
        _rotation: null,
        _betwennRotation: null,
        ctor: function() {
            ccs.Frame.prototype.ctor.call(this), this._rotation = 0
        },
        onEnter: function(a) {
            this._node.setRotation(this._rotation), this._tween && (this._betwennRotation = a._rotation - this._rotation)
        },
        apply: function(a) {
            if (this._tween && 0 != this._betwennRotation) {
                var b = this._rotation + a * this._betwennRotation;
                this._node.setRotation(b)
            }
        },
        clone: function() {
            var a = new ccs.RotationFrame;
            return a.setRotation(this._rotation), a._cloneProperty(this), a
        },
        setRotation: function(a) {
            this._rotation = a
        },
        getRotation: function() {
            return this._rotation
        }
    }), ccs.RotationFrame.create = function() {
        return new ccs.RotationFrame
    }, ccs.SkewFrame = ccs.Frame.extend({
        _skewX: null,
        _skewY: null,
        _betweenSkewX: null,
        _betweenSkewY: null,
        ctor: function() {
            ccs.Frame.prototype.ctor.call(this), this._skewX = 0, this._skewY = 0
        },
        onEnter: function(a) {
            this._node.setSkewX(this._skewX), this._node.setSkewY(this._skewY), this._tween && (this._betweenSkewX = a._skewX - this._skewX, this._betweenSkewY = a._skewY - this._skewY)
        },
        apply: function(a) {
            if (this._tween && (0 != this._betweenSkewX || 0 != this._betweenSkewY)) {
                var b = this._skewX + a * this._betweenSkewX,
                    c = this._skewY + a * this._betweenSkewY;
                this._node.setSkewX(b), this._node.setSkewY(c)
            }
        },
        clone: function() {
            var a = new ccs.SkewFrame;
            return a.setSkewX(this._skewX), a.setSkewY(this._skewY), a._cloneProperty(this), a
        },
        setSkewX: function(a) {
            this._skewX = a
        },
        getSkewX: function() {
            return this._skewX
        },
        setSkewY: function(a) {
            this._skewY = a
        },
        getSkewY: function() {
            return this._skewY
        }
    }), ccs.SkewFrame.create = function() {
        return new ccs.SkewFrame
    }, ccs.RotationSkewFrame = ccs.SkewFrame.extend({
        onEnter: function(a) {
            this._node.setRotationX(this._skewX), this._node.setRotationY(this._skewY), this._tween && (this._betweenSkewX = a._skewX - this._skewX, this._betweenSkewY = a._skewY - this._skewY)
        },
        apply: function(a) {
            if (this._tween && (0 != this._betweenSkewX || 0 != this._betweenSkewY)) {
                var b = this._skewX + a * this._betweenSkewX,
                    c = this._skewY + a * this._betweenSkewY;
                this._node.setRotationX(b), this._node.setRotationY(c)
            }
        },
        clone: function() {
            var a = new ccs.RotationSkewFrame;
            return a.setSkewX(this._skewX), a.setSkewY(this._skewY), a._cloneProperty(this), a
        }
    }), ccs.RotationSkewFrame.create = function() {
        return new ccs.RotationSkewFrame
    }, ccs.PositionFrame = ccs.Frame.extend({
        _position: null,
        _betweenX: null,
        _betweenY: null,
        ctor: function() {
            ccs.Frame.prototype.ctor.call(this), this._position = cc.p(0, 0)
        },
        onEnter: function(a) {
            this._node.setPosition(this._position), this._tween && (this._betweenX = a._position.x - this._position.x, this._betweenY = a._position.y - this._position.y)
        },
        apply: function(a) {
            if (this._tween && (0 != this._betweenX || 0 != this._betweenY)) {
                var b = cc.p(0, 0);
                b.x = this._position.x + this._betweenX * a, b.y = this._position.y + this._betweenY * a, this._node.setPosition(b)
            }
        },
        clone: function() {
            var a = new ccs.PositionFrame;
            return a.setPosition(this._position), a._cloneProperty(this), a
        },
        setPosition: function(a) {
            this._position = a
        },
        getPosition: function() {
            return this._position
        },
        setX: function(a) {
            this._position.x = a
        },
        getX: function() {
            return this._position.x
        },
        setY: function(a) {
            this._position.y = a
        },
        getY: function() {
            return this._position.y
        }
    }), ccs.PositionFrame.create = function() {
        return new ccs.PositionFrame
    }, ccs.ScaleFrame = ccs.Frame.extend({
        _scaleX: null,
        _scaleY: null,
        _betweenScaleX: null,
        _betweenScaleY: null,
        ctor: function() {
            ccs.Frame.prototype.ctor.call(this), this._scaleX = 1, this._scaleY = 1
        },
        onEnter: function(a) {
            this._node.setScaleX(this._scaleX), this._node.setScaleY(this._scaleY), this._tween && (this._betweenScaleX = a._scaleX - this._scaleX, this._betweenScaleY = a._scaleY - this._scaleY)
        },
        apply: function(a) {
            if (this._tween && (0 != this._betweenScaleX || 0 != this._betweenScaleY)) {
                var b = this._scaleX + this._betweenScaleX * a,
                    c = this._scaleY + this._betweenScaleY * a;
                this._node.setScaleX(b), this._node.setScaleY(c)
            }
        },
        clone: function() {
            var a = new ccs.ScaleFrame;
            return a.setScaleX(this._scaleX), a.setScaleY(this._scaleY), a._cloneProperty(this), a
        },
        setScale: function(a) {
            this._scaleX = a, this._scaleY = a
        },
        setScaleX: function(a) {
            this._scaleX = a
        },
        getScaleX: function() {
            return this._scaleX
        },
        setScaleY: function(a) {
            this._scaleY = a
        },
        getScaleY: function() {
            return this._scaleY
        }
    }), ccs.ScaleFrame.create = function() {
        return new ccs.ScaleFrame
    }, ccs.AnchorPointFrame = ccs.Frame.extend({
        _anchorPoint: null,
        ctor: function() {
            ccs.Frame.prototype.ctor.call(this), this._anchorPoint = cc.p(0, 0)
        },
        onEnter: function() {
            this._node.setAnchorPoint(this._anchorPoint)
        },
        clone: function() {
            var a = new ccs.AnchorPointFrame;
            return a.setAnchorPoint(this._anchorPoint), a._cloneProperty(this), a
        },
        setAnchorPoint: function(a) {
            this._anchorPoint = a
        },
        getAnchorPoint: function() {
            return this._anchorPoint
        }
    }), ccs.AnchorPointFrame.create = function() {
        return new ccs.AnchorPointFrame
    }, ccs.InnerActionType = {
        LoopAction: 0,
        NoLoopAction: 1,
        SingleFrame: 2
    }, ccs.InnerActionFrame = ccs.Frame.extend({
        _innerActionType: null,
        _startFrameIndex: null,
        ctor: function() {
            ccs.Frame.prototype.ctor.call(this), this._innerActionType = ccs.InnerActionType.LoopAction, this._startFrameIndex = 0
        },
        onEnter: function() {},
        clone: function() {
            var a = new ccs.InnerActionFrame;
            return a.setInnerActionType(this._innerActionType), a.setStartFrameIndex(this._startFrameIndex), a._cloneProperty(this), a
        },
        setInnerActionType: function(a) {
            this._innerActionType = a
        },
        getInnerActionType: function() {
            return this._innerActionType
        },
        setStartFrameIndex: function(a) {
            this._startFrameIndex = a
        },
        getStartFrameIndex: function() {
            return this._startFrameIndex
        }
    }), ccs.InnerActionFrame.create = function() {
        return new ccs.InnerActionFrame
    }, ccs.ColorFrame = ccs.Frame.extend({
        _alpha: null,
        _color: null,
        _betweenAlpha: null,
        _betweenRed: null,
        _betweenGreen: null,
        _betweenBlue: null,
        ctor: function() {
            ccs.Frame.prototype.ctor.call(this), this._alpha = 255, this.color = cc.color(255, 255, 255)
        },
        onEnter: function(a) {
            if (this._node.setOpacity(this._alpha), this._node.setColor(this._color), this._tween) {
                this._betweenAlpha = a._alpha - this._alpha;
                var b = a._color;
                this._betweenRed = b.r - this._color.r, this._betweenGreen = b.g - this._color.g, this._betweenBlue = b.b - this._color.b
            }
        },
        apply: function(a) {
            if (this._tween && (0 != this._betweenAlpha || 0 != this._betweenRed || 0 != this._betweenGreen || 0 != this._betweenBlue)) {
                var b = this._alpha + this._betweenAlpha * a,
                    c = cc.color(255, 255, 255);
                c.r = this._color.r + this._betweenRed * a, c.g = this._color.g + this._betweenGreen * a, c.b = this._color.b + this._betweenBlue * a, this._node.setOpacity(b), this._node.setColor(c)
            }
        },
        clone: function() {
            var a = new ccs.ColorFrame;
            return a.setAlpha(this._alpha), a.setColor(this._color), a._cloneProperty(this), a
        },
        setAlpha: function(a) {
            this._alpha = a
        },
        getAlpha: function() {
            return this._alpha
        },
        setColor: function(a) {
            this._color = a
        },
        getColor: function() {
            return this._color
        }
    }), ccs.ColorFrame.create = function() {
        return new ccs.ColorFrame
    }, ccs.EventFrame = ccs.Frame.extend({
        _event: null,
        ctor: function() {
            ccs.Frame.prototype.ctor.call(this), this._event = ""
        },
        onEnter: function() {
            this._emitEvent()
        },
        clone: function() {
            var a = new ccs.EventFrame;
            return a.setEvent(this._event), a._cloneProperty(this), a
        },
        setEvent: function(a) {
            this._event = a
        },
        getEvent: function() {
            return this._event
        }
    }), ccs.EventFrame.create = function() {
        return new ccs.EventFrame
    }, ccs.ZOrderFrame = ccs.Frame.extend({
        _zorder: null,
        onEnter: function() {
            this._node && this._node.setLocalZOrder(this._zorder)
        },
        clone: function() {
            var a = new ccs.ZOrderFrame;
            return a.setZOrder(this._zorder), a._cloneProperty(this), a
        },
        setZOrder: function(a) {
            this._zorder = a
        },
        getZOrder: function() {
            return this._zorder
        }
    }), ccs.ZOrderFrame.create = function() {
        return new ccs.ZOrderFrame
    }, ccs.Timeline = ccs.Class.extend({
        _frames: null,
        _currentKeyFrame: null,
        _currentKeyFrameIndex: null,
        _fromIndex: null,
        _toIndex: null,
        _betweenDuration: null,
        _actionTag: null,
        _ActionTimeline: null,
        _node: null,
        ctor: function() {
            this._frames = [], this._currentKeyFrame = null, this._currentKeyFrameIndex = 0, this._fromIndex = 0, this._toIndex = 0, this._betweenDuration = 0, this._actionTag = 0, this._ActionTimeline = null, this._node = null
        },
        _gotoFrame: function(a) {
            0 != this._frames.length && (this._binarySearchKeyFrame(a), this._apply(a))
        },
        _stepToFrame: function(a) {
            0 != this._frames.length && (this._updateCurrentKeyFrame(a), this._apply(a))
        },
        getFrames: function() {
            return this._frames
        },
        addFrame: function(a) {
            this._frames.push(a), a.setTimeline(this)
        },
        insertFrame: function(a, b) {
            this._frames.splice(b, 0, a), a.setTimeline(this)
        },
        removeFrame: function(a) {
            cc.arrayRemoveObject(this._frames, a), a.setTimeline(null)
        },
        setActionTag: function(a) {
            this._actionTag = a
        },
        getActionTag: function() {
            return this._actionTag
        },
        setNode: function(a) {
            for (var b = 0; b < this._frames.length; b++) {
                var c = this._frames[b];
                c.setNode(a)
            }
        },
        getNode: function() {
            return this._node
        },
        setActionTimeline: function(a) {
            this._ActionTimeline = a
        },
        getActionTimeline: function() {
            return this._ActionTimeline
        },
        clone: function() {
            var a = new ccs.Timeline;
            a._actionTag = this._actionTag;
            for (var b = 0; b < this._frames.length; b++) {
                var c = this._frames[b],
                    d = c.clone();
                a.addFrame(d)
            }
            return a
        },
        _apply: function(a) {
            if (this._currentKeyFrame) {
                var b = 0 == this._betweenDuration ? 0 : (a - this._currentKeyFrameIndex) / this._betweenDuration;
                this._currentKeyFrame.apply(b)
            }
        },
        _binarySearchKeyFrame: function(a) {
            var b = null,
                c = null,
                d = this._frames.length,
                e = !1;
            do {
                if (a <= this._frames[0].getFrameIndex()) {
                    this._currentKeyFrameIndex >= this._frames[0].getFrameIndex() && (e = !0), b = c = this._frames[0], this._currentKeyFrameIndex = 0, this._betweenDuration = this._frames[0].getFrameIndex();
                    break
                }
                if (a >= this._frames[d - 1].getFrameIndex()) {
                    b = c = this._frames[d - 1], this._currentKeyFrameIndex = this._frames[d - 1].getFrameIndex(), this._betweenDuration = 0;
                    break
                }
                for (var f = -1, g = 0, h = d - 1, i = 0; h >= g;) {
                    if (i = Math.ceil((g + h) / 2), a >= this._frames[i].getFrameIndex() && a < this._frames[i + 1].getFrameIndex()) {
                        f = i;
                        break
                    }
                    this._frames[i].getFrameIndex() > a ? h = i - 1 : g = i + 1
                }
                b = this._frames[f], c = this._frames[f + 1], 0 == f && this._currentKeyFrameIndex < b.getFrameIndex() && (e = !0), this._currentKeyFrameIndex = b.getFrameIndex(), this._betweenDuration = c.getFrameIndex() - b.getFrameIndex()
            } while (0);
            (e || this._currentKeyFrame != b) && (this._currentKeyFrame = b, this._currentKeyFrame.onEnter(c))
        },
        _updateCurrentKeyFrame: function(a) {
            if (a < this._currentKeyFrameIndex || a >= this._currentKeyFrameIndex + this._betweenDuration) {
                var b = null,
                    c = null;
                do {
                    var d = this._frames.length;
                    if (a < this._frames[0].getFrameIndex()) {
                        b = c = this._frames[0], this._currentKeyFrameIndex = 0, this._betweenDuration = this._frames[0].getFrameIndex();
                        break
                    }
                    if (a >= this._frames[d - 1].getFrameIndex()) {
                        b = c = this._frames[d - 1], this._currentKeyFrameIndex = this._frames[d - 1].getFrameIndex(), this._betweenDuration = 0;
                        break
                    }
                    do
                        if (this._fromIndex = this._toIndex, b = this._frames[this._fromIndex], this._currentKeyFrameIndex = b.getFrameIndex(), this._toIndex = this._fromIndex + 1, this._toIndex >= d && (this._toIndex = 0), c = this._frames[this._toIndex], a == b.getFrameIndex()) break;
                    while (a < b.getFrameIndex() || a >= c.getFrameIndex());
                    this._betweenDuration = c.getFrameIndex() - b.getFrameIndex()
                } while (0);
                this._currentKeyFrame = b, this._currentKeyFrame.onEnter(c)
            }
        }
    }), ccs.Timeline.create = function() {
        return new ccs.Timeline
    };
! function() {
    ccs.Skin.WebGLRenderCmd = function(a) {
        cc.Sprite.WebGLRenderCmd.call(this, a)
    };
    var a = ccs.Skin.WebGLRenderCmd.prototype = Object.create(cc.Sprite.WebGLRenderCmd.prototype);
    cc.inject(ccs.Skin.RenderCmd, a), a.constructor = ccs.Skin.WebGLRenderCmd, a.updateTransform = function() {
        var a = this._node,
            b = this._quad;
        if (a._visible) {
            var c = this.getNodeToParentTransform(),
                d = a._rect,
                e = a._offsetPosition.x,
                f = a._offsetPosition.y,
                g = e + d.width,
                h = f + d.height,
                i = c.tx,
                j = c.ty,
                k = c.a,
                l = c.b,
                m = c.d,
                n = -c.c,
                o = e * k - f * n + i,
                p = e * l + f * m + j,
                q = g * k - f * n + i,
                r = g * l + f * m + j,
                s = g * k - h * n + i,
                t = g * l + h * m + j,
                u = e * k - h * n + i,
                v = e * l + h * m + j,
                w = a._vertexZ;
            cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (o = 0 | o, p = 0 | p, q = 0 | q, r = 0 | r, s = 0 | s, t = 0 | t, u = 0 | u, v = 0 | v), this.SET_VERTEX3F(b.bl.vertices, o, p, w), this.SET_VERTEX3F(b.br.vertices, q, r, w), this.SET_VERTEX3F(b.tl.vertices, u, v, w), this.SET_VERTEX3F(b.tr.vertices, s, t, w)
        } else b.br.vertices = b.tl.vertices = b.tr.vertices = b.bl.vertices = {
            x: 0,
            y: 0,
            z: 0
        };
        a.textureAtlas && a.textureAtlas.updateQuad(b, a.textureAtlas.getTotalQuads()), this._quadDirty = !0
    }, a.SET_VERTEX3F = function(a, b, c, d) {
        a.x = b, a.y = c, a.z = d
    }, a.rendering = function(a) {
        var b = this._node;
        if (b._textureLoaded) {
            var c = a || cc._renderContext,
                d = b._texture;
            if (d && d._isLoaded && (this._shaderProgram.use(), this._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glBlendFunc(b._blendFunc.src, b._blendFunc.dst), cc.glBindTexture2DN(0, d), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), c.bindBuffer(c.ARRAY_BUFFER, this._quadWebBuffer), this._quadDirty && (c.bufferData(c.ARRAY_BUFFER, this._quad.arrayBuffer, c.DYNAMIC_DRAW), this._quadDirty = !1), c.vertexAttribPointer(0, 3, c.FLOAT, !1, 24, 0), c.vertexAttribPointer(1, 4, c.UNSIGNED_BYTE, !0, 24, 12), c.vertexAttribPointer(2, 2, c.FLOAT, !1, 24, 16), c.drawArrays(c.TRIANGLE_STRIP, 0, 4)), cc.g_NumberOfDraws++, 0 !== cc.SPRITE_DEBUG_DRAW || b._showNode)
                if (1 === cc.SPRITE_DEBUG_DRAW || b._showNode) {
                    var e = this._quad,
                        f = [cc.p(e.tl.vertices.x, e.tl.vertices.y), cc.p(e.bl.vertices.x, e.bl.vertices.y), cc.p(e.br.vertices.x, e.br.vertices.y), cc.p(e.tr.vertices.x, e.tr.vertices.y)];
                    cc._drawingUtil.drawPoly(f, 4, !0)
                } else if (2 === cc.SPRITE_DEBUG_DRAW) {
                var g = b.getTextureRect(),
                    h = b.getOffsetPosition(),
                    i = [cc.p(h.x, h.y), cc.p(h.x + g.width, h.y), cc.p(h.x + g.width, h.y + g.height), cc.p(h.x, h.y + g.height)];
                cc._drawingUtil.drawPoly(i, 4, !0)
            }
        }
    }
}(),
function() {
    ccs.Armature.WebGLRenderCmd = function(a) {
        cc.Node.WebGLRenderCmd.call(this, a), this._needDraw = !0, this._realAnchorPointInPoints = new cc.Point(0, 0)
    };
    var a = ccs.Armature.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    cc.inject(ccs.Armature.RenderCmd, a), a.constructor = ccs.Armature.WebGLRenderCmd, a.rendering = function(a, b) {
        var c = this._node;
        b || (cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW), cc.kmGLPushMatrix(), cc.kmGLLoadMatrix(this._stackMatrix));
        for (var d = c._children, e = cc.BlendFunc.ALPHA_PREMULTIPLIED, f = cc.BlendFunc.ALPHA_NON_PREMULTIPLIED, g = 0, h = d.length; h > g; g++) {
            var i = d[g];
            if (i && i.getDisplayRenderNode) {
                var j = i.getDisplayRenderNode();
                if (null == j) continue;
                switch (j.setShaderProgram(this._shaderProgram), i.getDisplayRenderNodeType()) {
                    case ccs.DISPLAY_TYPE_SPRITE:
                        if (j instanceof ccs.Skin) {
                            j.updateTransform();
                            var k = i.getBlendFunc();
                            j.setBlendFunc(k.src != e.src || k.dst != e.dst ? i.getBlendFunc() : c._blendFunc.src != e.src || c._blendFunc.dst != e.dst || j.getTexture().hasPremultipliedAlpha() ? c._blendFunc : f), j._renderCmd.rendering(a)
                        }
                        break;
                    case ccs.DISPLAY_TYPE_ARMATURE:
                        j._renderCmd.rendering(a, !0);
                        break;
                    default:
                        j._renderCmd.transform(), j._renderCmd.rendering(a)
                }
            } else i instanceof cc.Node && (i.setShaderProgram(this._shaderProgram), i._renderCmd.transform(), i._renderCmd.rendering(a))
        }
        b || cc.kmGLPopMatrix()
    }, a.initShaderCache = function() {
        this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)
    }, a.setShaderProgram = function(a) {
        this._shaderProgram = a
    }, a.updateChildPosition = function(a, b, c, d, e) {
        var f = this._node;
        b.updateTransform();
        var g = c.getBlendFunc();
        b.setBlendFunc(g.src != d.src || g.dst != d.dst ? c.getBlendFunc() : f._blendFunc.src != d.src || node_blendFunc.dst != d.dst || b.getTexture().hasPremultipliedAlpha() ? f._blendFunc : e), b.rendering(a)
    }, a.visit = function(a) {
        var b = this._node;
        if (b._visible) {
            var c = cc.current_stack;
            c.stack.push(c.top), this.updateStatus(a), c.top = this._stackMatrix, b.sortAllChildren(), cc.renderer.pushRenderCommand(this), this._dirtyFlag = 0, c.top = c.stack.pop()
        }
    }
}();
cc.pool = {
    _pool: {},
    _releaseCB: function() {
        this.release()
    },
    _autoRelease: function(a) {
        var b = void 0 === a._running ? !1 : !a._running;
        cc.director.getScheduler().scheduleCallbackForTarget(a, this._releaseCB, 0, 0, 0, b)
    },
    putInPool: function(a) {
        var b = a.constructor.prototype.__pid;
        if (!b) {
            var c = {
                writable: !0,
                enumerable: !1,
                configurable: !0
            };
            c.value = ClassManager.getNewID(), Object.defineProperty(a.constructor.prototype, "__pid", c)
        }
        this._pool[b] || (this._pool[b] = []), a.retain && a.retain(), a.unuse && a.unuse(), this._pool[b].push(a)
    },
    hasObject: function(a) {
        var b = a.prototype.__pid,
            c = this._pool[b];
        return c && 0 != c.length ? !0 : !1
    },
    removeObject: function(a) {
        var b = a.constructor.prototype.__pid;
        if (b) {
            var c = this._pool[b];
            if (c)
                for (var d = 0; d < c.length; d++) a === c[d] && (a.release && a.release(), c.splice(d, 1))
        }
    },
    getFromPool: function(a) {
        if (this.hasObject(a)) {
            var b = a.prototype.__pid,
                c = this._pool[b],
                d = Array.prototype.slice.call(arguments);
            d.shift();
            var e = c.pop();
            return e.reuse && e.reuse.apply(e, d), cc.sys.isNative && e.release && this._autoRelease(e), e
        }
    },
    drainAllPools: function() {
        for (var a in this._pool)
            for (var b = 0; b < this._pool[a].length; b++) {
                var c = this._pool[a][b];
                c.release && c.release()
            }
        this._pool = {}
    }
};
! function() {
    if (void 0 !== cc) {
        var config = cc.game.config.plugin || {},
            PluginManager = function() {};
        PluginManager.prototype = {
            constructor: PluginManager,
            getInstance: function() {
                return this
            },
            loadPlugin: function() {},
            unloadPlugin: function() {}
        };
        var PluginAssembly = function() {};
        PluginAssembly.prototype = {
            constructor: PluginAssembly,
            setDebugMode: function() {},
            startSession: function() {},
            setCaptureUncaughtException: function() {},
            callFuncWithParam: function(a) {
                return "function" == typeof this[a] ? this[a].apply(this, Array.prototype.splice.call(arguments, 1)) : void cc.log("function is not define")
            },
            callStringFuncWithParam: function() {
                this.callFuncWithParam.apply(arguments)
            },
            getPluginName: function() {
                return this._name
            },
            getPluginVersion: function() {
                return this._version
            }
        }, PluginAssembly.extend = function(name, porp) {
            var p, prototype = {};
            for (p in PluginAssembly.prototype) prototype[p] = PluginAssembly.prototype[p];
            for (p in porp) prototype[p] = porp[p];
            var tmp = eval("(function " + name + "Plugin(){})");
            return prototype.constructor = tmp, tmp.prototype = prototype, tmp
        };
        var Param = function(a, b) {
            var c, d = plugin.PluginParam.ParamType;
            switch (a) {
                case d.TypeInt:
                    c = parseInt(b);
                    break;
                case d.TypeFloat:
                    c = parseFloat(b);
                    break;
                case d.TypeBool:
                    c = Boolean(b);
                    break;
                case d.TypeString:
                    c = String(b);
                    break;
                case d.TypeStringMap:
                    c = b;
                    break;
                default:
                    c = b
            }
            return c
        };
        Param.ParamType = {
            TypeInt: 1,
            TypeFloat: 2,
            TypeBool: 3,
            TypeString: 4,
            TypeStringMap: 5
        }, Param.AdsResultCode = {
            AdsReceived: 0,
            FullScreenViewShown: 1,
            FullScreenViewDismissed: 2,
            PointsSpendSucceed: 3,
            PointsSpendFailed: 4,
            NetworkError: 5,
            UnknownError: 6
        }, Param.PayResultCode = {
            PaySuccess: 0,
            PayFail: 1,
            PayCancel: 2,
            PayTimeOut: 3
        }, Param.ShareResultCode = {
            ShareSuccess: 0,
            ShareFail: 1,
            ShareCancel: 2,
            ShareTimeOut: 3
        };
        var PluginList = {},
            Plugin = {
                extend: function(a, b) {
                    PluginList[a] = new(PluginAssembly.extend(a, b)), "function" == typeof PluginList[a].ctor && PluginList[a].ctor(config[a])
                },
                PluginList: PluginList,
                PluginParam: Param,
                PluginManager: new PluginManager
            };
        window.plugin = Plugin
    }
}();
! function() {
    var a = {
        _ignoreBodyRotation: !1,
        _body: null,
        _rotation: 1,
        ctor: function(a, b) {
            if (cc.Sprite.prototype.ctor.call(this), void 0 === a) cc.PhysicsSprite.prototype.init.call(this);
            else if (cc.isString(a))
                if ("#" === a[0]) {
                    var c = a.substr(1, a.length - 1),
                        d = cc.spriteFrameCache.getSpriteFrame(c);
                    this.initWithSpriteFrame(d)
                } else this.init(a, b);
            else cc.isObject(a) && (a instanceof cc.Texture2D ? this.initWithTexture(a, b) : a instanceof cc.SpriteFrame && this.initWithSpriteFrame(a));
            cc.renderer.pushRenderCommand(this._renderCmd)
        },
        visit: function() {
            cc.renderer.pushRenderCommand(this._renderCmd), cc.Sprite.prototype.visit.call(this)
        },
        setBody: function(a) {
            this._body = a
        },
        getBody: function() {
            return this._body
        },
        getPosition: function() {
            var a = this._body;
            return {
                x: a.p.x,
                y: a.p.y
            }
        },
        getPositionX: function() {
            return this._body.p.x
        },
        getPositionY: function() {
            return this._body.p.y
        },
        setPosition: function(a, b) {
            void 0 === b ? (this._body.p.x = a.x, this._body.p.y = a.y) : (this._body.p.x = a, this._body.p.y = b)
        },
        setPositionX: function(a) {
            this._body.p.x = a
        },
        setPositionY: function(a) {
            this._body.p.y = a
        },
        _syncPosition: function() {
            var a = this._position,
                b = this._body;
            (a.x != b.p.x || a.y != b.p.y) && cc.Sprite.prototype.setPosition.call(this, b.p.x, b.p.y)
        },
        getRotation: function() {
            return this._ignoreBodyRotation ? this._rotationX : -cc.radiansToDegrees(this._body.a)
        },
        setRotation: function(a) {
            this._ignoreBodyRotation ? cc.Sprite.prototype.setRotation.call(this, a) : this._body.a = -cc.degreesToRadians(a)
        },
        _syncRotation: function() {
            this._rotationX != -cc.radiansToDegrees(this._body.a) && cc.Sprite.prototype.setRotation.call(this, -cc.radiansToDegrees(this._body.a))
        },
        getNodeToParentTransform: function() {
            return this._renderCmd.getNodeToParentTransform()
        },
        isDirty: function() {
            return !this._body.isSleeping()
        },
        setDirty: function() {},
        setIgnoreBodyRotation: function(a) {
            this._ignoreBodyRotation = a
        },
        _createRenderCmd: function() {
            return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.PhysicsSprite.CanvasRenderCmd(this) : new cc.PhysicsSprite.WebGLRenderCmd(this)
        }
    };
    cc.PhysicsSprite = cc.Sprite.extend(a), cc.PhysicsSprite._className = "PhysicsSprite";
    var b = cc.PhysicsSprite.prototype;
    b.body, cc.defineGetterSetter(b, "body", b.getBody, b.setBody), b.dirty, cc.defineGetterSetter(b, "dirty", b.isDirty, b.setDirty), cc.PhysicsSprite.create = function(a, b) {
        return new cc.PhysicsSprite(a, b)
    }, cc.PhysicsSprite.createWithSpriteFrameName = cc.PhysicsSprite.create, cc.PhysicsSprite.createWithSpriteFrame = cc.PhysicsSprite.create
}(),
function() {
    cc.PhysicsSprite.CanvasRenderCmd = function(a) {
        cc.Sprite.CanvasRenderCmd.call(this, a), this._needDraw = !0
    };
    var a = cc.PhysicsSprite.CanvasRenderCmd.prototype = Object.create(cc.Sprite.CanvasRenderCmd.prototype);
    a.constructor = cc.PhysicsSprite.CanvasRenderCmd, a.rendering = function(a, b, c) {
        this._node.transform && this._node.transform(), cc.Sprite.CanvasRenderCmd.prototype.rendering.call(this, a, b, c)
    }, a.getNodeToParentTransform = function() {
        var a = this._node;
        if (a._usingNormalizedPosition && a._parent) {
            var b = a._parent._contentSize;
            a._position.x = a._normalizedPosition.x * b.width, a._position.y = a._normalizedPosition.y * b.height, a._normalizedPositionDirty = !1
        }
        var c = this._transform,
            d = a._body,
            e = a._scaleX,
            f = a._scaleY,
            g = this._anchorPointInPoints;
        c.tx = d.p.x, c.ty = d.p.y;
        var h = -d.a,
            i = 1,
            j = 0;
        return h && (i = Math.cos(h), j = Math.sin(h)), c.a = c.d = i, c.b = -j, c.c = j, (1 !== e || 1 !== f) && (c.a *= e, c.c *= e, c.b *= f, c.d *= f), c.tx += i * -g.x * e + -j * g.y * f, c.ty -= j * -g.x * e + i * g.y * f, this._ignoreAnchorPointForPosition && (c.tx += g.x, c.ty += g.y), this._transform
    }
}(), cc.__convertVerts = function(a) {
        for (var b = [], c = 0; c < a.length / 2; c++) b[c] = {
            x: a[2 * c],
            y: a[2 * c + 1]
        };
        return b
    }, cc.ColorForBody = function(a) {
        return a.isRogue() || a.isSleeping() ? cc.color(128, 128, 128, 128) : a.nodeIdleTime > a.space.sleepTimeThreshold ? cc.color(84, 84, 84, 128) : cc.color(255, 0, 0, 128)
    }, cc.DrawShape = function(a) {
        var b = a.body,
            c = cc.ColorForBody(b);
        switch (a.collisionCode) {
            case cp.CircleShape.prototype.collisionCode:
                this.drawDot(a.tc, Math.max(a.r, 1), c), this.drawSegment(a.tc, cp.v.add(a.tc, cp.v.mult(b.rot, a.r)), 1, c);
                break;
            case cp.SegmentShape.prototype.collisionCode:
                this.drawSegment(a.ta, a.tb, Math.max(a.r, 2), c);
                break;
            case cp.PolyShape.prototype.collisionCode:
                var d = cc.color(c.r, c.g, c.b, cc.lerp(c.a, 255, .5));
                this.drawPoly(cc.__convertVerts(a.tVerts), c, 1, d);
                break;
            default:
                cc.log("cc.DrawShape(): Bad assertion in DrawShape()")
        }
    }, cc.DrawConstraint = function(a) {
        var b, c, d = a.a,
            e = a.b;
        if (a instanceof cp.PinJoint) b = d.local2World(a.anchr1), c = e.local2World(a.anchr2), this.drawDot(b, 3, cc.CONSTRAINT_COLOR), this.drawDot(c, 3, cc.CONSTRAINT_COLOR), this.drawSegment(b, c, 1, cc.CONSTRAINT_COLOR);
        else if (a instanceof cp.SlideJoint) b = d.local2World(a.anchr1), c = e.local2World(a.anchr2), this.drawDot(b, 3, cc.CONSTRAINT_COLOR), this.drawDot(c, 3, cc.CONSTRAINT_COLOR), this.drawSegment(b, c, 1, cc.CONSTRAINT_COLOR);
        else if (a instanceof cp.PivotJoint) b = d.local2World(a.anchr1), c = e.local2World(a.anchr2), this.drawDot(b, 3, cc.CONSTRAINT_COLOR), this.drawDot(c, 3, cc.CONSTRAINT_COLOR);
        else if (a instanceof cp.GrooveJoint) {
            b = d.local2World(a.grv_a), c = d.local2World(a.grv_b);
            var f = e.local2World(a.anchr2);
            this.drawDot(f, 3, cc.CONSTRAINT_COLOR), this.drawSegment(b, c, 1, cc.CONSTRAINT_COLOR)
        } else a instanceof cp.DampedSpring
    }, cc.CONSTRAINT_COLOR = cc.color(0, 255, 0, 128), cc.PhysicsDebugNode = cc.DrawNode.extend({
        _space: null,
        _className: "PhysicsDebugNode",
        ctor: function(a) {
            cc.DrawNode.prototype.ctor.call(this), this._space = a
        },
        getSpace: function() {
            return this._space
        },
        setSpace: function(a) {
            this._space = a
        },
        draw: function() {
            this._space && (this._space.eachShape(cc.DrawShape.bind(this)), this._space.eachConstraint(cc.DrawConstraint.bind(this)), cc.DrawNode.prototype.draw.call(this), this.clear())
        },
        _createRenderCmd: function() {
            return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.PhysicsDebugNode.CanvasRenderCmd(this) : new cc.PhysicsDebugNode.WebGLRenderCmd(this)
        }
    }), cc.PhysicsDebugNode.create = function(a) {
        return new cc.PhysicsDebugNode(a)
    },
    function() {
        cc.PhysicsDebugNode.CanvasRenderCmd = function(a) {
            cc.Node.CanvasRenderCmd.call(this, a), this._buffer = a._buffer, this._needDraw = !0
        };
        var a = cc.PhysicsDebugNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
        a.constructor = cc.PhysicsDebugNode.CanvasRenderCmd, a.rendering = function(a, b, c) {
            var d = this._node;
            d._space && (d._space.eachShape(cc.DrawShape.bind(d)), d._space.eachConstraint(cc.DrawConstraint.bind(d)), cc.DrawNode.CanvasRenderCmd.prototype.rendering.call(this, a, b, c), d.clear())
        }, a._drawDot = cc.DrawNode.CanvasRenderCmd.prototype._drawDot, a._drawSegment = cc.DrawNode.CanvasRenderCmd.prototype._drawSegment, a._drawPoly = cc.DrawNode.CanvasRenderCmd.prototype._drawPoly
    }();
! function() {
    cc.PhysicsDebugNode.WebGLRenderCmd = function(a) {
        cc.Node.WebGLRenderCmd.call(this, a), this._needDraw = !0
    }, cc.PhysicsDebugNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype), cc.PhysicsDebugNode.WebGLRenderCmd.prototype.constructor = cc.PhysicsDebugNode.WebGLRenderCmd, cc.PhysicsDebugNode.WebGLRenderCmd.prototype.rendering = function() {
        var a = this._node;
        a._space && (a._space.eachShape(cc.DrawShape.bind(a)), a._space.eachConstraint(cc.DrawConstraint.bind(a)), cc.glBlendFunc(a._blendFunc.src, a._blendFunc.dst), this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix), a._render(), a.clear())
    }
}(),
function() {
    cc.PhysicsSprite.WebGLRenderCmd = function(a) {
        cc.Sprite.WebGLRenderCmd.call(this, a), this._needDraw = !0
    };
    var a = cc.PhysicsSprite.WebGLRenderCmd.prototype = Object.create(cc.Sprite.WebGLRenderCmd.prototype);
    a.constructor = cc.PhysicsSprite.WebGLRenderCmd, a.rendering = function(a) {
        var b = this._node;
        b._syncPosition(), b._ignoreBodyRotation || b._syncRotation(), this.transform(this.getParentRenderCmd()), cc.Sprite.WebGLRenderCmd.prototype.rendering.call(this, a)
    }, a.getNodeToParentTransform = function() {
        var a = this._node,
            b = a._body,
            c = this._anchorPointInPoints,
            d = a._scaleX,
            e = a._scaleY,
            f = b.p.x,
            g = b.p.y;
        this._ignoreAnchorPointForPosition && (f += c.x, g += c.y);
        var h = b.a,
            i = Math.cos(h),
            j = Math.sin(h);
        return cc._rectEqualToZero(c) || (f += i * -c.x * d + -j * -c.y * e, g += j * -c.x * d + i * -c.y * e), this._transform = cc.affineTransformMake(i * d, j * d, -j * e, i * e, f, g), this._transform
    }, a.updateTransform = function() {
        this._dirty = this._node.isDirty(), cc.Sprite.WebGLRenderCmd.prototype.updateTransform.call(this)
    }
}();
var io = "undefined" == typeof module ? {} : module.exports;
! function() {
    if (function(a, b) {
        var c = a;
        c.version = "0.9.16", c.protocol = 1, c.transports = [], c.j = [], c.sockets = {}, c.connect = function(a, d) {
            var e, f, g = c.util.parseUri(a);
            b && b.location && (g.protocol = g.protocol || b.location.protocol.slice(0, -1), g.host = g.host || (b.document ? b.document.domain : b.location.hostname), g.port = g.port || b.location.port), e = c.util.uniqueUri(g);
            var h = {
                host: g.host,
                secure: "https" == g.protocol,
                port: g.port || ("https" == g.protocol ? 443 : 80),
                query: g.query || ""
            };
            return c.util.merge(h, d), (h["force new connection"] || !c.sockets[e]) && (f = new c.Socket(h)), !h["force new connection"] && f && (c.sockets[e] = f), f = f || c.sockets[e], f.of(g.path.length > 1 ? g.path : "")
        }
    }("object" == typeof module ? module.exports : this.io = {}, this), function(a, b) {
        var c = a.util = {},
            d = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,
            e = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"];
        c.parseUri = function(a) {
            for (var b = d.exec(a || ""), c = {}, f = 14; f--;) c[e[f]] = b[f] || "";
            return c
        }, c.uniqueUri = function(a) {
            var c = a.protocol,
                d = a.host,
                e = a.port;
            return "document" in b ? (d = d || document.domain, e = e || ("https" == c && "https:" !== document.location.protocol ? 443 : document.location.port)) : (d = d || "localhost", !e && "https" == c && (e = 443)), (c || "http") + "://" + d + ":" + (e || 80)
        }, c.query = function(a, b) {
            var d = c.chunkQuery(a || ""),
                e = [];
            c.merge(d, c.chunkQuery(b || ""));
            for (var f in d) d.hasOwnProperty(f) && e.push(f + "=" + d[f]);
            return e.length ? "?" + e.join("&") : ""
        }, c.chunkQuery = function(a) {
            for (var b, c = {}, d = a.split("&"), e = 0, f = d.length; f > e; ++e) b = d[e].split("="), b[0] && (c[b[0]] = b[1]);
            return c
        };
        var f = !1;
        c.load = function(a) {
            return "document" in b && "complete" === document.readyState || f ? a() : void c.on(b, "load", a, !1)
        }, c.on = function(a, b, c, d) {
            a.attachEvent ? a.attachEvent("on" + b, c) : a.addEventListener && a.addEventListener(b, c, d)
        }, c.request = function(a) {
            if (a && "undefined" != typeof XDomainRequest && !c.ua.hasCORS) return new XDomainRequest;
            if ("undefined" != typeof XMLHttpRequest && (!a || c.ua.hasCORS)) return new XMLHttpRequest;
            if (!a) try {
                return new(window[["Active"].concat("Object").join("X")])("Microsoft.XMLHTTP")
            } catch (b) {}
            return null
        }, "undefined" != typeof window && c.load(function() {
            f = !0
        }), c.defer = function(a) {
            return c.ua.webkit && "undefined" == typeof importScripts ? void c.load(function() {
                setTimeout(a, 100)
            }) : a()
        }, c.merge = function(a, b, d, e) {
            var f, g = e || [],
                h = "undefined" == typeof d ? 2 : d;
            for (f in b) b.hasOwnProperty(f) && c.indexOf(g, f) < 0 && ("object" == typeof a[f] && h ? c.merge(a[f], b[f], h - 1, g) : (a[f] = b[f], g.push(b[f])));
            return a
        }, c.mixin = function(a, b) {
            c.merge(a.prototype, b.prototype)
        }, c.inherit = function(a, b) {
            function c() {}
            c.prototype = b.prototype, a.prototype = new c
        }, c.isArray = Array.isArray || function(a) {
            return "[object Array]" === Object.prototype.toString.call(a)
        }, c.intersect = function(a, b) {
            for (var d = [], e = a.length > b.length ? a : b, f = a.length > b.length ? b : a, g = 0, h = f.length; h > g; g++)~c.indexOf(e, f[g]) && d.push(f[g]);
            return d
        }, c.indexOf = function(a, b, c) {
            for (var d = a.length, c = 0 > c ? 0 > c + d ? 0 : c + d : c || 0; d > c && a[c] !== b; c++);
            return c >= d ? -1 : c
        }, c.toArray = function(a) {
            for (var b = [], c = 0, d = a.length; d > c; c++) b.push(a[c]);
            return b
        }, c.ua = {}, c.ua.hasCORS = "undefined" != typeof XMLHttpRequest && function() {
            try {
                var a = new XMLHttpRequest
            } catch (b) {
                return !1
            }
            return void 0 != a.withCredentials
        }(), c.ua.webkit = "undefined" != typeof navigator && /webkit/i.test(navigator.userAgent), c.ua.iDevice = "undefined" != typeof navigator && /iPad|iPhone|iPod/i.test(navigator.userAgent)
    }("undefined" != typeof io ? io : module.exports, this), function(a, b) {
        function c() {}
        a.EventEmitter = c, c.prototype.on = function(a, c) {
            return this.$events || (this.$events = {}), this.$events[a] ? b.util.isArray(this.$events[a]) ? this.$events[a].push(c) : this.$events[a] = [this.$events[a], c] : this.$events[a] = c, this
        }, c.prototype.addListener = c.prototype.on, c.prototype.once = function(a, b) {
            function c() {
                d.removeListener(a, c), b.apply(this, arguments)
            }
            var d = this;
            return c.listener = b, this.on(a, c), this
        }, c.prototype.removeListener = function(a, c) {
            if (this.$events && this.$events[a]) {
                var d = this.$events[a];
                if (b.util.isArray(d)) {
                    for (var e = -1, f = 0, g = d.length; g > f; f++)
                        if (d[f] === c || d[f].listener && d[f].listener === c) {
                            e = f;
                            break
                        }
                    if (0 > e) return this;
                    d.splice(e, 1), d.length || delete this.$events[a]
                } else(d === c || d.listener && d.listener === c) && delete this.$events[a]
            }
            return this
        }, c.prototype.removeAllListeners = function(a) {
            return void 0 === a ? (this.$events = {}, this) : (this.$events && this.$events[a] && (this.$events[a] = null), this)
        }, c.prototype.listeners = function(a) {
            return this.$events || (this.$events = {}), this.$events[a] || (this.$events[a] = []), b.util.isArray(this.$events[a]) || (this.$events[a] = [this.$events[a]]), this.$events[a]
        }, c.prototype.emit = function(a) {
            if (!this.$events) return !1;
            var c = this.$events[a];
            if (!c) return !1;
            var d = Array.prototype.slice.call(arguments, 1);
            if ("function" == typeof c) c.apply(this, d);
            else {
                if (!b.util.isArray(c)) return !1;
                for (var e = c.slice(), f = 0, g = e.length; g > f; f++) e[f].apply(this, d)
            }
            return !0
        }
    }("undefined" != typeof io ? io : module.exports, "undefined" != typeof io ? io : module.parent.exports), function(exports, nativeJSON) {
        function f(a) {
            return 10 > a ? "0" + a : a
        }

        function date(a) {
            return isFinite(a.valueOf()) ? a.getUTCFullYear() + "-" + f(a.getUTCMonth() + 1) + "-" + f(a.getUTCDate()) + "T" + f(a.getUTCHours()) + ":" + f(a.getUTCMinutes()) + ":" + f(a.getUTCSeconds()) + "Z" : null
        }

        function quote(a) {
            return escapable.lastIndex = 0, escapable.test(a) ? '"' + a.replace(escapable, function(a) {
                var b = meta[a];
                return "string" == typeof b ? b : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4)
            }) + '"' : '"' + a + '"'
        }

        function str(a, b) {
            var c, d, e, f, g, h = gap,
                i = b[a];
            switch (i instanceof Date && (i = date(a)), "function" == typeof rep && (i = rep.call(b, a, i)), typeof i) {
                case "string":
                    return quote(i);
                case "number":
                    return isFinite(i) ? String(i) : "null";
                case "boolean":
                case "null":
                    return String(i);
                case "object":
                    if (!i) return "null";
                    if (gap += indent, g = [], "[object Array]" === Object.prototype.toString.apply(i)) {
                        for (f = i.length, c = 0; f > c; c += 1) g[c] = str(c, i) || "null";
                        return e = 0 === g.length ? "[]" : gap ? "[\n" + gap + g.join(",\n" + gap) + "\n" + h + "]" : "[" + g.join(",") + "]", gap = h, e
                    }
                    if (rep && "object" == typeof rep)
                        for (f = rep.length, c = 0; f > c; c += 1) "string" == typeof rep[c] && (d = rep[c], e = str(d, i), e && g.push(quote(d) + (gap ? ": " : ":") + e));
                    else
                        for (d in i) Object.prototype.hasOwnProperty.call(i, d) && (e = str(d, i), e && g.push(quote(d) + (gap ? ": " : ":") + e));
                    return e = 0 === g.length ? "{}" : gap ? "{\n" + gap + g.join(",\n" + gap) + "\n" + h + "}" : "{" + g.join(",") + "}", gap = h, e
            }
        }
        if (nativeJSON && nativeJSON.parse) return exports.JSON = {
            parse: nativeJSON.parse,
            stringify: nativeJSON.stringify
        };
        var JSON = exports.JSON = {},
            cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
            escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
            gap, indent, meta = {
                "\b": "\\b",
                "	": "\\t",
                "\n": "\\n",
                "\f": "\\f",
                "\r": "\\r",
                '"': '\\"',
                "\\": "\\\\"
            },
            rep;
        JSON.stringify = function(a, b, c) {
            var d;
            if (gap = "", indent = "", "number" == typeof c)
                for (d = 0; c > d; d += 1) indent += " ";
            else "string" == typeof c && (indent = c); if (rep = b, !b || "function" == typeof b || "object" == typeof b && "number" == typeof b.length) return str("", {
                "": a
            });
            throw new Error("JSON.stringify")
        }, JSON.parse = function(text, reviver) {
            function walk(a, b) {
                var c, d, e = a[b];
                if (e && "object" == typeof e)
                    for (c in e) Object.prototype.hasOwnProperty.call(e, c) && (d = walk(e, c), void 0 !== d ? e[c] = d : delete e[c]);
                return reviver.call(a, b, e)
            }
            var j;
            if (text = String(text), cx.lastIndex = 0, cx.test(text) && (text = text.replace(cx, function(a) {
                return "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4)
            })), /^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, "@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, "]").replace(/(?:^|:|,)(?:\s*\[)+/g, ""))) return j = eval("(" + text + ")"), "function" == typeof reviver ? walk({
                "": j
            }, "") : j;
            throw new SyntaxError("JSON.parse")
        }
    }("undefined" != typeof io ? io : module.exports, "undefined" != typeof JSON ? JSON : void 0), function(a, b) {
        var c = a.parser = {},
            d = c.packets = ["disconnect", "connect", "heartbeat", "message", "json", "event", "ack", "error", "noop"],
            e = c.reasons = ["transport not supported", "client not handshaken", "unauthorized"],
            f = c.advice = ["reconnect"],
            g = b.JSON,
            h = b.util.indexOf;
        c.encodePacket = function(a) {
            var b = h(d, a.type),
                c = a.id || "",
                i = a.endpoint || "",
                j = a.ack,
                k = null;
            switch (a.type) {
                case "error":
                    var l = a.reason ? h(e, a.reason) : "",
                        m = a.advice ? h(f, a.advice) : "";
                    ("" !== l || "" !== m) && (k = l + ("" !== m ? "+" + m : ""));
                    break;
                case "message":
                    "" !== a.data && (k = a.data);
                    break;
                case "event":
                    var n = {
                        name: a.name
                    };
                    a.args && a.args.length && (n.args = a.args), k = g.stringify(n);
                    break;
                case "json":
                    k = g.stringify(a.data);
                    break;
                case "connect":
                    a.qs && (k = a.qs);
                    break;
                case "ack":
                    k = a.ackId + (a.args && a.args.length ? "+" + g.stringify(a.args) : "")
            }
            var o = [b, c + ("data" == j ? "+" : ""), i];
            return null !== k && void 0 !== k && o.push(k), o.join(":")
        }, c.encodePayload = function(a) {
            var b = "";
            if (1 == a.length) return a[0];
            for (var c = 0, d = a.length; d > c; c++) {
                var e = a[c];
                b += "�" + e.length + "�" + a[c]
            }
            return b
        };
        var i = /([^:]+):([0-9]+)?(\+)?:([^:]+)?:?([\s\S]*)?/;
        c.decodePacket = function(a) {
            var b = a.match(i);
            if (!b) return {};
            var c = b[2] || "",
                a = b[5] || "",
                h = {
                    type: d[b[1]],
                    endpoint: b[4] || ""
                };
            switch (c && (h.id = c, h.ack = b[3] ? "data" : !0), h.type) {
                case "error":
                    var b = a.split("+");
                    h.reason = e[b[0]] || "", h.advice = f[b[1]] || "";
                    break;
                case "message":
                    h.data = a || "";
                    break;
                case "event":
                    try {
                        var j = g.parse(a);
                        h.name = j.name, h.args = j.args
                    } catch (k) {}
                    h.args = h.args || [];
                    break;
                case "json":
                    try {
                        h.data = g.parse(a)
                    } catch (k) {}
                    break;
                case "connect":
                    h.qs = a || "";
                    break;
                case "ack":
                    var b = a.match(/^([0-9]+)(\+)?(.*)/);
                    if (b && (h.ackId = b[1], h.args = [], b[3])) try {
                        h.args = b[3] ? g.parse(b[3]) : []
                    } catch (k) {}
                    break;
                case "disconnect":
                case "heartbeat":
            }
            return h
        }, c.decodePayload = function(a) {
            if ("�" == a.charAt(0)) {
                for (var b = [], d = 1, e = ""; d < a.length; d++) "�" == a.charAt(d) ? (b.push(c.decodePacket(a.substr(d + 1).substr(0, e))), d += Number(e) + 1, e = "") : e += a.charAt(d);
                return b
            }
            return [c.decodePacket(a)]
        }
    }("undefined" != typeof io ? io : module.exports, "undefined" != typeof io ? io : module.parent.exports), function(a, b) {
        function c(a, b) {
            this.socket = a, this.sessid = b
        }
        a.Transport = c, b.util.mixin(c, b.EventEmitter), c.prototype.heartbeats = function() {
            return !0
        }, c.prototype.onData = function(a) {
            if (this.clearCloseTimeout(), (this.socket.connected || this.socket.connecting || this.socket.reconnecting) && this.setCloseTimeout(), "" !== a) {
                var c = b.parser.decodePayload(a);
                if (c && c.length)
                    for (var d = 0, e = c.length; e > d; d++) this.onPacket(c[d])
            }
            return this
        }, c.prototype.onPacket = function(a) {
            return this.socket.setHeartbeatTimeout(), "heartbeat" == a.type ? this.onHeartbeat() : ("connect" == a.type && "" == a.endpoint && this.onConnect(), "error" == a.type && "reconnect" == a.advice && (this.isOpen = !1), this.socket.onPacket(a), this)
        }, c.prototype.setCloseTimeout = function() {
            if (!this.closeTimeout) {
                var a = this;
                this.closeTimeout = setTimeout(function() {
                    a.onDisconnect()
                }, this.socket.closeTimeout)
            }
        }, c.prototype.onDisconnect = function() {
            return this.isOpen && this.close(), this.clearTimeouts(), this.socket.onDisconnect(), this
        }, c.prototype.onConnect = function() {
            return this.socket.onConnect(), this
        }, c.prototype.clearCloseTimeout = function() {
            this.closeTimeout && (clearTimeout(this.closeTimeout), this.closeTimeout = null)
        }, c.prototype.clearTimeouts = function() {
            this.clearCloseTimeout(), this.reopenTimeout && clearTimeout(this.reopenTimeout)
        }, c.prototype.packet = function(a) {
            this.send(b.parser.encodePacket(a))
        }, c.prototype.onHeartbeat = function() {
            this.packet({
                type: "heartbeat"
            })
        }, c.prototype.onOpen = function() {
            this.isOpen = !0, this.clearCloseTimeout(), this.socket.onOpen()
        }, c.prototype.onClose = function() {
            this.isOpen = !1, this.socket.onClose(), this.onDisconnect()
        }, c.prototype.prepareUrl = function() {
            var a = this.socket.options;
            return this.scheme() + "://" + a.host + ":" + a.port + "/" + a.resource + "/" + b.protocol + "/" + this.name + "/" + this.sessid
        }, c.prototype.ready = function(a, b) {
            b.call(this)
        }
    }("undefined" != typeof io ? io : module.exports, "undefined" != typeof io ? io : module.parent.exports), function(a, b, c) {
        function d(a) {
            if (this.options = {
                port: 80,
                secure: !1,
                document: "document" in c ? document : !1,
                resource: "socket.io",
                transports: b.transports,
                "connect timeout": 1e4,
                "try multiple transports": !0,
                reconnect: !0,
                "reconnection delay": 500,
                "reconnection limit": 1 / 0,
                "reopen delay": 3e3,
                "max reconnection attempts": 10,
                "sync disconnect on unload": !1,
                "auto connect": !0,
                "flash policy port": 10843,
                manualFlush: !1
            }, b.util.merge(this.options, a), this.connected = !1, this.open = !1, this.connecting = !1, this.reconnecting = !1, this.namespaces = {}, this.buffer = [], this.doBuffer = !1, this.options["sync disconnect on unload"] && (!this.isXDomain() || b.util.ua.hasCORS)) {
                var d = this;
                b.util.on(c, "beforeunload", function() {
                    d.disconnectSync()
                }, !1)
            }
            this.options["auto connect"] && this.connect()
        }

        function e() {}
        a.Socket = d, b.util.mixin(d, b.EventEmitter), d.prototype.of = function(a) {
            return this.namespaces[a] || (this.namespaces[a] = new b.SocketNamespace(this, a), "" !== a && this.namespaces[a].packet({
                type: "connect"
            })), this.namespaces[a]
        }, d.prototype.publish = function() {
            this.emit.apply(this, arguments);
            var a;
            for (var b in this.namespaces) this.namespaces.hasOwnProperty(b) && (a = this.of(b), a.$emit.apply(a, arguments))
        }, d.prototype.handshake = function(a) {
            function c(b) {
                b instanceof Error ? (d.connecting = !1, d.onError(b.message)) : a.apply(null, b.split(":"))
            }
            var d = this,
                f = this.options,
                g = ["http" + (f.secure ? "s" : "") + ":/", f.host + ":" + f.port, f.resource, b.protocol, b.util.query(this.options.query, "t=" + +new Date)].join("/");
            if (this.isXDomain() && !b.util.ua.hasCORS) {
                var h = document.getElementsByTagName("script")[0],
                    i = document.createElement("script");
                i.src = g + "&jsonp=" + b.j.length, h.parentNode.insertBefore(i, h), b.j.push(function(a) {
                    c(a), i.parentNode.removeChild(i)
                })
            } else {
                var j = b.util.request();
                j.open("GET", g, !0), this.isXDomain() && (j.withCredentials = !0), j.onreadystatechange = function() {
                    4 == j.readyState && (j.onreadystatechange = e, 200 == j.status ? c(j.responseText) : 403 == j.status ? d.onError(j.responseText) : (d.connecting = !1, !d.reconnecting && d.onError(j.responseText)))
                }, j.send(null)
            }
        }, d.prototype.getTransport = function(a) {
            for (var c, d = a || this.transports, e = 0; c = d[e]; e++)
                if (b.Transport[c] && b.Transport[c].check(this) && (!this.isXDomain() || b.Transport[c].xdomainCheck(this))) return new b.Transport[c](this, this.sessionid);
            return null
        }, d.prototype.connect = function(a) {
            if (this.connecting) return this;
            var c = this;
            return c.connecting = !0, this.handshake(function(d, e, f, g) {
                function h(a) {
                    return c.transport && c.transport.clearTimeouts(), c.transport = c.getTransport(a), c.transport ? void c.transport.ready(c, function() {
                        c.connecting = !0, c.publish("connecting", c.transport.name), c.transport.open(), c.options["connect timeout"] && (c.connectTimeoutTimer = setTimeout(function() {
                            if (!c.connected && (c.connecting = !1, c.options["try multiple transports"])) {
                                for (var a = c.transports; a.length > 0 && a.splice(0, 1)[0] != c.transport.name;);
                                a.length ? h(a) : c.publish("connect_failed")
                            }
                        }, c.options["connect timeout"]))
                    }) : c.publish("connect_failed")
                }
                c.sessionid = d, c.closeTimeout = 1e3 * f, c.heartbeatTimeout = 1e3 * e, c.transports || (c.transports = c.origTransports = g ? b.util.intersect(g.split(","), c.options.transports) : c.options.transports), c.setHeartbeatTimeout(), h(c.transports), c.once("connect", function() {
                    clearTimeout(c.connectTimeoutTimer), a && "function" == typeof a && a()
                })
            }), this
        }, d.prototype.setHeartbeatTimeout = function() {
            if (clearTimeout(this.heartbeatTimeoutTimer), !this.transport || this.transport.heartbeats()) {
                var a = this;
                this.heartbeatTimeoutTimer = setTimeout(function() {
                    a.transport.onClose()
                }, this.heartbeatTimeout)
            }
        }, d.prototype.packet = function(a) {
            return this.connected && !this.doBuffer ? this.transport.packet(a) : this.buffer.push(a), this
        }, d.prototype.setBuffer = function(a) {
            this.doBuffer = a, !a && this.connected && this.buffer.length && (this.options.manualFlush || this.flushBuffer())
        }, d.prototype.flushBuffer = function() {
            this.transport.payload(this.buffer), this.buffer = []
        }, d.prototype.disconnect = function() {
            return (this.connected || this.connecting) && (this.open && this.of("").packet({
                type: "disconnect"
            }), this.onDisconnect("booted")), this
        }, d.prototype.disconnectSync = function() {
            var a = b.util.request(),
                c = ["http" + (this.options.secure ? "s" : "") + ":/", this.options.host + ":" + this.options.port, this.options.resource, b.protocol, "", this.sessionid].join("/") + "/?disconnect=1";
            a.open("GET", c, !1), a.send(null), this.onDisconnect("booted")
        }, d.prototype.isXDomain = function() {
            var a = c.location.port || ("https:" == c.location.protocol ? 443 : 80);
            return this.options.host !== c.location.hostname || this.options.port != a
        }, d.prototype.onConnect = function() {
            this.connected || (this.connected = !0, this.connecting = !1, this.doBuffer || this.setBuffer(!1), this.emit("connect"))
        }, d.prototype.onOpen = function() {
            this.open = !0
        }, d.prototype.onClose = function() {
            this.open = !1, clearTimeout(this.heartbeatTimeoutTimer)
        }, d.prototype.onPacket = function(a) {
            this.of(a.endpoint).onPacket(a)
        }, d.prototype.onError = function(a) {
            a && a.advice && "reconnect" === a.advice && (this.connected || this.connecting) && (this.disconnect(), this.options.reconnect && this.reconnect()), this.publish("error", a && a.reason ? a.reason : a)
        }, d.prototype.onDisconnect = function(a) {
            var b = this.connected,
                c = this.connecting;
            this.connected = !1, this.connecting = !1, this.open = !1, (b || c) && (this.transport.close(), this.transport.clearTimeouts(), b && (this.publish("disconnect", a), "booted" != a && this.options.reconnect && !this.reconnecting && this.reconnect()))
        }, d.prototype.reconnect = function() {
            function a() {
                if (c.connected) {
                    for (var a in c.namespaces) c.namespaces.hasOwnProperty(a) && "" !== a && c.namespaces[a].packet({
                        type: "connect"
                    });
                    c.publish("reconnect", c.transport.name, c.reconnectionAttempts)
                }
                clearTimeout(c.reconnectionTimer), c.removeListener("connect_failed", b), c.removeListener("connect", b), c.reconnecting = !1, delete c.reconnectionAttempts, delete c.reconnectionDelay, delete c.reconnectionTimer, delete c.redoTransports, c.options["try multiple transports"] = e
            }

            function b() {
                return c.reconnecting ? c.connected ? a() : c.connecting && c.reconnecting ? c.reconnectionTimer = setTimeout(b, 1e3) : void(c.reconnectionAttempts++ >= d ? c.redoTransports ? (c.publish("reconnect_failed"), a()) : (c.on("connect_failed", b), c.options["try multiple transports"] = !0, c.transports = c.origTransports, c.transport = c.getTransport(), c.redoTransports = !0, c.connect()) : (c.reconnectionDelay < f && (c.reconnectionDelay *= 2), c.connect(), c.publish("reconnecting", c.reconnectionDelay, c.reconnectionAttempts), c.reconnectionTimer = setTimeout(b, c.reconnectionDelay))) : void 0
            }
            this.reconnecting = !0, this.reconnectionAttempts = 0, this.reconnectionDelay = this.options["reconnection delay"];
            var c = this,
                d = this.options["max reconnection attempts"],
                e = this.options["try multiple transports"],
                f = this.options["reconnection limit"];
            this.options["try multiple transports"] = !1, this.reconnectionTimer = setTimeout(b, this.reconnectionDelay), this.on("connect", b)
        }
    }("undefined" != typeof io ? io : module.exports, "undefined" != typeof io ? io : module.parent.exports, this), function(a, b) {
        function c(a, b) {
            this.socket = a, this.name = b || "", this.flags = {}, this.json = new d(this, "json"), this.ackPackets = 0, this.acks = {}
        }

        function d(a, b) {
            this.namespace = a, this.name = b
        }
        a.SocketNamespace = c, b.util.mixin(c, b.EventEmitter), c.prototype.$emit = b.EventEmitter.prototype.emit, c.prototype.of = function() {
            return this.socket.of.apply(this.socket, arguments)
        }, c.prototype.packet = function(a) {
            return a.endpoint = this.name, this.socket.packet(a), this.flags = {}, this
        }, c.prototype.send = function(a, b) {
            var c = {
                type: this.flags.json ? "json" : "message",
                data: a
            };
            return "function" == typeof b && (c.id = ++this.ackPackets, c.ack = !0, this.acks[c.id] = b), this.packet(c)
        }, c.prototype.emit = function(a) {
            var b = Array.prototype.slice.call(arguments, 1),
                c = b[b.length - 1],
                d = {
                    type: "event",
                    name: a
                };
            return "function" == typeof c && (d.id = ++this.ackPackets, d.ack = "data", this.acks[d.id] = c, b = b.slice(0, b.length - 1)), d.args = b, this.packet(d)
        }, c.prototype.disconnect = function() {
            return "" === this.name ? this.socket.disconnect() : (this.packet({
                type: "disconnect"
            }), this.$emit("disconnect")), this
        }, c.prototype.onPacket = function(a) {
            function c() {
                d.packet({
                    type: "ack",
                    args: b.util.toArray(arguments),
                    ackId: a.id
                })
            }
            var d = this;
            switch (a.type) {
                case "connect":
                    this.$emit("connect");
                    break;
                case "disconnect":
                    "" === this.name ? this.socket.onDisconnect(a.reason || "booted") : this.$emit("disconnect", a.reason);
                    break;
                case "message":
                case "json":
                    var e = ["message", a.data];
                    "data" == a.ack ? e.push(c) : a.ack && this.packet({
                        type: "ack",
                        ackId: a.id
                    }), this.$emit.apply(this, e);
                    break;
                case "event":
                    var e = [a.name].concat(a.args);
                    "data" == a.ack && e.push(c), this.$emit.apply(this, e);
                    break;
                case "ack":
                    this.acks[a.ackId] && (this.acks[a.ackId].apply(this, a.args), delete this.acks[a.ackId]);
                    break;
                case "error":
                    a.advice ? this.socket.onError(a) : "unauthorized" == a.reason ? this.$emit("connect_failed", a.reason) : this.$emit("error", a.reason)
            }
        }, d.prototype.send = function() {
            this.namespace.flags[this.name] = !0, this.namespace.send.apply(this.namespace, arguments)
        }, d.prototype.emit = function() {
            this.namespace.flags[this.name] = !0, this.namespace.emit.apply(this.namespace, arguments)
        }
    }("undefined" != typeof io ? io : module.exports, "undefined" != typeof io ? io : module.parent.exports), function(a, b, c) {
        function d() {
            b.Transport.apply(this, arguments)
        }
        a.websocket = d, b.util.inherit(d, b.Transport), d.prototype.name = "websocket", d.prototype.open = function() {
            var a, d = b.util.query(this.socket.options.query),
                e = this;
            return a || (a = c.MozWebSocket || c.WebSocket), this.websocket = new a(this.prepareUrl() + d), this.websocket.onopen = function() {
                e.onOpen(), e.socket.setBuffer(!1)
            }, this.websocket.onmessage = function(a) {
                e.onData(a.data)
            }, this.websocket.onclose = function() {
                e.onClose(), e.socket.setBuffer(!0)
            }, this.websocket.onerror = function(a) {
                e.onError(a)
            }, this
        }, d.prototype.send = b.util.ua.iDevice ? function(a) {
            var b = this;
            return setTimeout(function() {
                b.websocket.send(a)
            }, 0), this
        } : function(a) {
            return this.websocket.send(a), this
        }, d.prototype.payload = function(a) {
            for (var b = 0, c = a.length; c > b; b++) this.packet(a[b]);
            return this
        }, d.prototype.close = function() {
            return this.websocket.close(), this
        }, d.prototype.onError = function(a) {
            this.socket.onError(a)
        }, d.prototype.scheme = function() {
            return this.socket.options.secure ? "wss" : "ws"
        }, d.check = function() {
            return "WebSocket" in c && !("__addTask" in WebSocket) || "MozWebSocket" in c
        }, d.xdomainCheck = function() {
            return !0
        }, b.transports.push("websocket")
    }("undefined" != typeof io ? io.Transport : module.exports, "undefined" != typeof io ? io : module.parent.exports, this), function(a, b) {
        function c() {
            b.Transport.websocket.apply(this, arguments)
        }
        a.flashsocket = c, b.util.inherit(c, b.Transport.websocket), c.prototype.name = "flashsocket", c.prototype.open = function() {
            var a = this,
                c = arguments;
            return WebSocket.__addTask(function() {
                b.Transport.websocket.prototype.open.apply(a, c)
            }), this
        }, c.prototype.send = function() {
            var a = this,
                c = arguments;
            return WebSocket.__addTask(function() {
                b.Transport.websocket.prototype.send.apply(a, c)
            }), this
        }, c.prototype.close = function() {
            return WebSocket.__tasks.length = 0, b.Transport.websocket.prototype.close.call(this), this
        }, c.prototype.ready = function(a, d) {
            function e() {
                var b = a.options,
                    e = b["flash policy port"],
                    g = ["http" + (b.secure ? "s" : "") + ":/", b.host + ":" + b.port, b.resource, "static/flashsocket", "WebSocketMain" + (a.isXDomain() ? "Insecure" : "") + ".swf"];
                c.loaded || ("undefined" == typeof WEB_SOCKET_SWF_LOCATION && (WEB_SOCKET_SWF_LOCATION = g.join("/")), 843 !== e && WebSocket.loadFlashPolicyFile("xmlsocket://" + b.host + ":" + e), WebSocket.__initialize(), c.loaded = !0), d.call(f)
            }
            var f = this;
            return document.body ? e() : void b.util.load(e)
        }, c.check = function() {
            return "undefined" != typeof WebSocket && "__initialize" in WebSocket && swfobject ? swfobject.getFlashPlayerVersion().major >= 10 : !1
        }, c.xdomainCheck = function() {
            return !0
        }, "undefined" != typeof window && (WEB_SOCKET_DISABLE_AUTO_INITIALIZATION = !0), b.transports.push("flashsocket")
    }("undefined" != typeof io ? io.Transport : module.exports, "undefined" != typeof io ? io : module.parent.exports), "undefined" != typeof window) var swfobject = function() {
        function a() {
            if (!R) {
                try {
                    var a = K.getElementsByTagName("body")[0].appendChild(q("span"));
                    a.parentNode.removeChild(a)
                } catch (b) {
                    return
                }
                R = !0;
                for (var c = N.length, d = 0; c > d; d++) N[d]()
            }
        }

        function b(a) {
            R ? a() : N[N.length] = a
        }

        function c(a) {
            if (typeof J.addEventListener != C) J.addEventListener("load", a, !1);
            else if (typeof K.addEventListener != C) K.addEventListener("load", a, !1);
            else if (typeof J.attachEvent != C) r(J, "onload", a);
            else if ("function" == typeof J.onload) {
                var b = J.onload;
                J.onload = function() {
                    b(), a()
                }
            } else J.onload = a
        }

        function d() {
            M ? e() : f()
        }

        function e() {
            var a = K.getElementsByTagName("body")[0],
                b = q(D);
            b.setAttribute("type", G);
            var c = a.appendChild(b);
            if (c) {
                var d = 0;
                ! function() {
                    if (typeof c.GetVariable != C) {
                        var e = c.GetVariable("$version");
                        e && (e = e.split(" ")[1].split(","), U.pv = [parseInt(e[0], 10), parseInt(e[1], 10), parseInt(e[2], 10)])
                    } else if (10 > d) return d++, void setTimeout(arguments.callee, 10);
                    a.removeChild(b), c = null, f()
                }()
            } else f()
        }

        function f() {
            var a = O.length;
            if (a > 0)
                for (var b = 0; a > b; b++) {
                    var c = O[b].id,
                        d = O[b].callbackFn,
                        e = {
                            success: !1,
                            id: c
                        };
                    if (U.pv[0] > 0) {
                        var f = p(c);
                        if (f)
                            if (!s(O[b].swfVersion) || U.wk && U.wk < 312)
                                if (O[b].expressInstall && h()) {
                                    var k = {};
                                    k.data = O[b].expressInstall, k.width = f.getAttribute("width") || "0", k.height = f.getAttribute("height") || "0", f.getAttribute("class") && (k.styleclass = f.getAttribute("class")), f.getAttribute("align") && (k.align = f.getAttribute("align"));
                                    for (var l = {}, m = f.getElementsByTagName("param"), n = m.length, o = 0; n > o; o++) "movie" != m[o].getAttribute("name").toLowerCase() && (l[m[o].getAttribute("name")] = m[o].getAttribute("value"));
                                    i(k, l, c, d)
                                } else j(f), d && d(e);
                        else u(c, !0), d && (e.success = !0, e.ref = g(c), d(e))
                    } else if (u(c, !0), d) {
                        var q = g(c);
                        q && typeof q.SetVariable != C && (e.success = !0, e.ref = q), d(e)
                    }
                }
        }

        function g(a) {
            var b = null,
                c = p(a);
            if (c && "OBJECT" == c.nodeName)
                if (typeof c.SetVariable != C) b = c;
                else {
                    var d = c.getElementsByTagName(D)[0];
                    d && (b = d)
                }
            return b
        }

        function h() {
            return !S && s("6.0.65") && (U.win || U.mac) && !(U.wk && U.wk < 312)
        }

        function i(a, b, c, d) {
            S = !0, y = d || null, z = {
                success: !1,
                id: c
            };
            var e = p(c);
            if (e) {
                "OBJECT" == e.nodeName ? (w = k(e), x = null) : (w = e, x = c), a.id = H, (typeof a.width == C || !/%$/.test(a.width) && parseInt(a.width, 10) < 310) && (a.width = "310"), (typeof a.height == C || !/%$/.test(a.height) && parseInt(a.height, 10) < 137) && (a.height = "137"), K.title = K.title.slice(0, 47) + " - Flash Player Installation";
                var f = U.ie && U.win ? ["Active"].concat("").join("X") : "PlugIn",
                    g = "MMredirectURL=" + J.location.toString().replace(/&/g, "%26") + "&MMplayerType=" + f + "&MMdoctitle=" + K.title;
                if (typeof b.flashvars != C ? b.flashvars += "&" + g : b.flashvars = g, U.ie && U.win && 4 != e.readyState) {
                    var h = q("div");
                    c += "SWFObjectNew", h.setAttribute("id", c), e.parentNode.insertBefore(h, e), e.style.display = "none",
                        function() {
                            4 == e.readyState ? e.parentNode.removeChild(e) : setTimeout(arguments.callee, 10)
                        }()
                }
                l(a, b, c)
            }
        }

        function j(a) {
            if (U.ie && U.win && 4 != a.readyState) {
                var b = q("div");
                a.parentNode.insertBefore(b, a), b.parentNode.replaceChild(k(a), b), a.style.display = "none",
                    function() {
                        4 == a.readyState ? a.parentNode.removeChild(a) : setTimeout(arguments.callee, 10)
                    }()
            } else a.parentNode.replaceChild(k(a), a)
        }

        function k(a) {
            var b = q("div");
            if (U.win && U.ie) b.innerHTML = a.innerHTML;
            else {
                var c = a.getElementsByTagName(D)[0];
                if (c) {
                    var d = c.childNodes;
                    if (d)
                        for (var e = d.length, f = 0; e > f; f++)(1 != d[f].nodeType || "PARAM" != d[f].nodeName) && 8 != d[f].nodeType && b.appendChild(d[f].cloneNode(!0))
                }
            }
            return b
        }

        function l(a, b, c) {
            var d, e = p(c);
            if (U.wk && U.wk < 312) return d;
            if (e)
                if (typeof a.id == C && (a.id = c), U.ie && U.win) {
                    var f = "";
                    for (var g in a) a[g] != Object.prototype[g] && ("data" == g.toLowerCase() ? b.movie = a[g] : "styleclass" == g.toLowerCase() ? f += ' class="' + a[g] + '"' : "classid" != g.toLowerCase() && (f += " " + g + '="' + a[g] + '"'));
                    var h = "";
                    for (var i in b) b[i] != Object.prototype[i] && (h += '<param name="' + i + '" value="' + b[i] + '" />');
                    e.outerHTML = '<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"' + f + ">" + h + "</object>", P[P.length] = a.id, d = p(a.id)
                } else {
                    var j = q(D);
                    j.setAttribute("type", G);
                    for (var k in a) a[k] != Object.prototype[k] && ("styleclass" == k.toLowerCase() ? j.setAttribute("class", a[k]) : "classid" != k.toLowerCase() && j.setAttribute(k, a[k]));
                    for (var l in b) b[l] != Object.prototype[l] && "movie" != l.toLowerCase() && m(j, l, b[l]);
                    e.parentNode.replaceChild(j, e), d = j
                }
            return d
        }

        function m(a, b, c) {
            var d = q("param");
            d.setAttribute("name", b), d.setAttribute("value", c), a.appendChild(d)
        }

        function n(a) {
            var b = p(a);
            b && "OBJECT" == b.nodeName && (U.ie && U.win ? (b.style.display = "none", function() {
                4 == b.readyState ? o(a) : setTimeout(arguments.callee, 10)
            }()) : b.parentNode.removeChild(b))
        }

        function o(a) {
            var b = p(a);
            if (b) {
                for (var c in b) "function" == typeof b[c] && (b[c] = null);
                b.parentNode.removeChild(b)
            }
        }

        function p(a) {
            var b = null;
            try {
                b = K.getElementById(a)
            } catch (c) {}
            return b
        }

        function q(a) {
            return K.createElement(a)
        }

        function r(a, b, c) {
            a.attachEvent(b, c), Q[Q.length] = [a, b, c]
        }

        function s(a) {
            var b = U.pv,
                c = a.split(".");
            return c[0] = parseInt(c[0], 10), c[1] = parseInt(c[1], 10) || 0, c[2] = parseInt(c[2], 10) || 0, b[0] > c[0] || b[0] == c[0] && b[1] > c[1] || b[0] == c[0] && b[1] == c[1] && b[2] >= c[2] ? !0 : !1
        }

        function t(a, b, c, d) {
            if (!U.ie || !U.mac) {
                var e = K.getElementsByTagName("head")[0];
                if (e) {
                    var f = c && "string" == typeof c ? c : "screen";
                    if (d && (A = null, B = null), !A || B != f) {
                        var g = q("style");
                        g.setAttribute("type", "text/css"), g.setAttribute("media", f), A = e.appendChild(g), U.ie && U.win && typeof K.styleSheets != C && K.styleSheets.length > 0 && (A = K.styleSheets[K.styleSheets.length - 1]), B = f
                    }
                    U.ie && U.win ? A && typeof A.addRule == D && A.addRule(a, b) : A && typeof K.createTextNode != C && A.appendChild(K.createTextNode(a + " {" + b + "}"))
                }
            }
        }

        function u(a, b) {
            if (T) {
                var c = b ? "visible" : "hidden";
                R && p(a) ? p(a).style.visibility = c : t("#" + a, "visibility:" + c)
            }
        }

        function v(a) {
            var b = /[\\\"<>\.;]/,
                c = null != b.exec(a);
            return c && typeof encodeURIComponent != C ? encodeURIComponent(a) : a
        } {
            var w, x, y, z, A, B, C = "undefined",
                D = "object",
                E = "Shockwave Flash",
                F = "ShockwaveFlash.ShockwaveFlash",
                G = "application/x-shockwave-flash",
                H = "SWFObjectExprInst",
                I = "onreadystatechange",
                J = window,
                K = document,
                L = navigator,
                M = !1,
                N = [d],
                O = [],
                P = [],
                Q = [],
                R = !1,
                S = !1,
                T = !0,
                U = function() {
                    var a = typeof K.getElementById != C && typeof K.getElementsByTagName != C && typeof K.createElement != C,
                        b = L.userAgent.toLowerCase(),
                        c = L.platform.toLowerCase(),
                        d = /win/.test(c ? c : b),
                        e = /mac/.test(c ? c : b),
                        f = /webkit/.test(b) ? parseFloat(b.replace(/^.*webkit\/(\d+(\.\d+)?).*$/, "$1")) : !1,
                        g = !1,
                        h = [0, 0, 0],
                        i = null;
                    if (typeof L.plugins != C && typeof L.plugins[E] == D) i = L.plugins[E].description, i && (typeof L.mimeTypes == C || !L.mimeTypes[G] || !!L.mimeTypes[G].enabledPlugin) && (M = !0, g = !1, i = i.replace(/^.*\s+(\S+\s+\S+$)/, "$1"), h[0] = parseInt(i.replace(/^(.*)\..*$/, "$1"), 10), h[1] = parseInt(i.replace(/^.*\.(.*)\s.*$/, "$1"), 10), h[2] = /[a-zA-Z]/.test(i) ? parseInt(i.replace(/^.*[a-zA-Z]+(.*)$/, "$1"), 10) : 0);
                    else if (typeof J[["Active"].concat("Object").join("X")] != C) try {
                        var j = new(window[["Active"].concat("Object").join("X")])(F);
                        j && (i = j.GetVariable("$version"), i && (g = !0, i = i.split(" ")[1].split(","), h = [parseInt(i[0], 10), parseInt(i[1], 10), parseInt(i[2], 10)]))
                    } catch (k) {}
                    return {
                        w3: a,
                        pv: h,
                        wk: f,
                        ie: g,
                        win: d,
                        mac: e
                    }
                }();
            ! function() {
                U.w3 && ((typeof K.readyState != C && "complete" == K.readyState || typeof K.readyState == C && (K.getElementsByTagName("body")[0] || K.body)) && a(), R || (typeof K.addEventListener != C && K.addEventListener("DOMContentLoaded", a, !1), U.ie && U.win && (K.attachEvent(I, function() {
                    "complete" == K.readyState && (K.detachEvent(I, arguments.callee), a())
                }), J == top && function() {
                    if (!R) {
                        try {
                            K.documentElement.doScroll("left")
                        } catch (b) {
                            return void setTimeout(arguments.callee, 0)
                        }
                        a()
                    }
                }()), U.wk && function() {
                    return R ? void 0 : /loaded|complete/.test(K.readyState) ? void a() : void setTimeout(arguments.callee, 0)
                }(), c(a)))
            }(),
            function() {
                U.ie && U.win && window.attachEvent("onunload", function() {
                    for (var a = Q.length, b = 0; a > b; b++) Q[b][0].detachEvent(Q[b][1], Q[b][2]);
                    for (var c = P.length, d = 0; c > d; d++) n(P[d]);
                    for (var e in U) U[e] = null;
                    U = null;
                    for (var f in swfobject) swfobject[f] = null;
                    swfobject = null
                })
            }()
        }
        return {
            registerObject: function(a, b, c, d) {
                if (U.w3 && a && b) {
                    var e = {};
                    e.id = a, e.swfVersion = b, e.expressInstall = c, e.callbackFn = d, O[O.length] = e, u(a, !1)
                } else d && d({
                    success: !1,
                    id: a
                })
            },
            getObjectById: function(a) {
                return U.w3 ? g(a) : void 0
            },
            embedSWF: function(a, c, d, e, f, g, j, k, m, n) {
                var o = {
                    success: !1,
                    id: c
                };
                U.w3 && !(U.wk && U.wk < 312) && a && c && d && e && f ? (u(c, !1), b(function() {
                    d += "", e += "";
                    var b = {};
                    if (m && typeof m === D)
                        for (var p in m) b[p] = m[p];
                    b.data = a, b.width = d, b.height = e;
                    var q = {};
                    if (k && typeof k === D)
                        for (var r in k) q[r] = k[r];
                    if (j && typeof j === D)
                        for (var t in j) typeof q.flashvars != C ? q.flashvars += "&" + t + "=" + j[t] : q.flashvars = t + "=" + j[t];
                    if (s(f)) {
                        var v = l(b, q, c);
                        b.id == c && u(c, !0), o.success = !0, o.ref = v
                    } else {
                        if (g && h()) return b.data = g, void i(b, q, c, n);
                        u(c, !0)
                    }
                    n && n(o)
                })) : n && n(o)
            },
            switchOffAutoHideShow: function() {
                T = !1
            },
            ua: U,
            getFlashPlayerVersion: function() {
                return {
                    major: U.pv[0],
                    minor: U.pv[1],
                    release: U.pv[2]
                }
            },
            hasFlashPlayerVersion: s,
            createSWF: function(a, b, c) {
                return U.w3 ? l(a, b, c) : void 0
            },
            showExpressInstall: function(a, b, c, d) {
                U.w3 && h() && i(a, b, c, d)
            },
            removeSWF: function(a) {
                U.w3 && n(a)
            },
            createCSS: function(a, b, c, d) {
                U.w3 && t(a, b, c, d)
            },
            addDomLoadEvent: b,
            addLoadEvent: c,
            getQueryParamValue: function(a) {
                var b = K.location.search || K.location.hash;
                if (b) {
                    if (/\?/.test(b) && (b = b.split("?")[1]), null == a) return v(b);
                    for (var c = b.split("&"), d = 0; d < c.length; d++)
                        if (c[d].substring(0, c[d].indexOf("=")) == a) return v(c[d].substring(c[d].indexOf("=") + 1))
                }
                return ""
            },
            expressInstallCallback: function() {
                if (S) {
                    var a = p(H);
                    a && w && (a.parentNode.replaceChild(w, a), x && (u(x, !0), U.ie && U.win && (w.style.display = "block")), y && y(z)), S = !1
                }
            }
        }
    }();
    ! function() {
        if ("undefined" != typeof window && !window.WebSocket) {
            var a = window.console;
            return a && a.log && a.error || (a = {
                log: function() {},
                error: function() {}
            }), swfobject.hasFlashPlayerVersion("10.0.0") ? ("file:" == location.protocol && a.error("WARNING: web-socket-js doesn't work in file:///... URL unless you set Flash Security Settings properly. Open the page via Web server i.e. http://..."), WebSocket = function(a, b, c, d, e) {
                var f = this;
                f.__id = WebSocket.__nextId++, WebSocket.__instances[f.__id] = f, f.readyState = WebSocket.CONNECTING, f.bufferedAmount = 0, f.__events = {}, b ? "string" == typeof b && (b = [b]) : b = [], setTimeout(function() {
                    WebSocket.__addTask(function() {
                        WebSocket.__flash.create(f.__id, a, b, c || null, d || 0, e || null)
                    })
                }, 0)
            }, WebSocket.prototype.send = function(a) {
                if (this.readyState == WebSocket.CONNECTING) throw "INVALID_STATE_ERR: Web Socket connection has not been established";
                var b = WebSocket.__flash.send(this.__id, encodeURIComponent(a));
                return 0 > b ? !0 : (this.bufferedAmount += b, !1)
            }, WebSocket.prototype.close = function() {
                this.readyState != WebSocket.CLOSED && this.readyState != WebSocket.CLOSING && (this.readyState = WebSocket.CLOSING, WebSocket.__flash.close(this.__id))
            }, WebSocket.prototype.addEventListener = function(a, b) {
                a in this.__events || (this.__events[a] = []), this.__events[a].push(b)
            }, WebSocket.prototype.removeEventListener = function(a, b) {
                if (a in this.__events)
                    for (var c = this.__events[a], d = c.length - 1; d >= 0; --d)
                        if (c[d] === b) {
                            c.splice(d, 1);
                            break
                        }
            }, WebSocket.prototype.dispatchEvent = function(a) {
                for (var b = this.__events[a.type] || [], c = 0; c < b.length; ++c) b[c](a);
                var d = this["on" + a.type];
                d && d(a)
            }, WebSocket.prototype.__handleEvent = function(a) {
                "readyState" in a && (this.readyState = a.readyState), "protocol" in a && (this.protocol = a.protocol);
                var b;
                if ("open" == a.type || "error" == a.type) b = this.__createSimpleEvent(a.type);
                else if ("close" == a.type) b = this.__createSimpleEvent("close");
                else {
                    if ("message" != a.type) throw "unknown event type: " + a.type;
                    var c = decodeURIComponent(a.message);
                    b = this.__createMessageEvent("message", c)
                }
                this.dispatchEvent(b)
            }, WebSocket.prototype.__createSimpleEvent = function(a) {
                if (document.createEvent && window.Event) {
                    var b = document.createEvent("Event");
                    return b.initEvent(a, !1, !1), b
                }
                return {
                    type: a,
                    bubbles: !1,
                    cancelable: !1
                }
            }, WebSocket.prototype.__createMessageEvent = function(a, b) {
                if (document.createEvent && window.MessageEvent && !window.opera) {
                    var c = document.createEvent("MessageEvent");
                    return c.initMessageEvent("message", !1, !1, b, null, null, window, null), c
                }
                return {
                    type: a,
                    data: b,
                    bubbles: !1,
                    cancelable: !1
                }
            }, WebSocket.CONNECTING = 0, WebSocket.OPEN = 1, WebSocket.CLOSING = 2, WebSocket.CLOSED = 3, WebSocket.__flash = null, WebSocket.__instances = {}, WebSocket.__tasks = [], WebSocket.__nextId = 0, WebSocket.loadFlashPolicyFile = function(a) {
                WebSocket.__addTask(function() {
                    WebSocket.__flash.loadManualPolicyFile(a)
                })
            }, WebSocket.__initialize = function() {
                if (!WebSocket.__flash) {
                    if (WebSocket.__swfLocation && (window.WEB_SOCKET_SWF_LOCATION = WebSocket.__swfLocation), !window.WEB_SOCKET_SWF_LOCATION) return void a.error("[WebSocket] set WEB_SOCKET_SWF_LOCATION to location of WebSocketMain.swf");
                    var b = document.createElement("div");
                    b.id = "webSocketContainer", b.style.position = "absolute", WebSocket.__isFlashLite() ? (b.style.left = "0px", b.style.top = "0px") : (b.style.left = "-100px", b.style.top = "-100px");
                    var c = document.createElement("div");
                    c.id = "webSocketFlash", b.appendChild(c), document.body.appendChild(b), swfobject.embedSWF(WEB_SOCKET_SWF_LOCATION, "webSocketFlash", "1", "1", "10.0.0", null, null, {
                        hasPriority: !0,
                        swliveconnect: !0,
                        allowScriptAccess: "always"
                    }, null, function(b) {
                        b.success || a.error("[WebSocket] swfobject.embedSWF failed")
                    })
                }
            }, WebSocket.__onFlashInitialized = function() {
                setTimeout(function() {
                    WebSocket.__flash = document.getElementById("webSocketFlash"), WebSocket.__flash.setCallerUrl(location.href), WebSocket.__flash.setDebug(!!window.WEB_SOCKET_DEBUG);
                    for (var a = 0; a < WebSocket.__tasks.length; ++a) WebSocket.__tasks[a]();
                    WebSocket.__tasks = []
                }, 0)
            }, WebSocket.__onFlashEvent = function() {
                return setTimeout(function() {
                    try {
                        for (var b = WebSocket.__flash.receiveEvents(), c = 0; c < b.length; ++c) WebSocket.__instances[b[c].webSocketId].__handleEvent(b[c])
                    } catch (d) {
                        a.error(d)
                    }
                }, 0), !0
            }, WebSocket.__log = function(b) {
                a.log(decodeURIComponent(b))
            }, WebSocket.__error = function(b) {
                a.error(decodeURIComponent(b))
            }, WebSocket.__addTask = function(a) {
                WebSocket.__flash ? a() : WebSocket.__tasks.push(a)
            }, WebSocket.__isFlashLite = function() {
                if (!window.navigator || !window.navigator.mimeTypes) return !1;
                var a = window.navigator.mimeTypes["application/x-shockwave-flash"];
                return a && a.enabledPlugin && a.enabledPlugin.filename && a.enabledPlugin.filename.match(/flashlite/i) ? !0 : !1
            }, window.WEB_SOCKET_DISABLE_AUTO_INITIALIZATION || (window.addEventListener ? window.addEventListener("load", function() {
                WebSocket.__initialize()
            }, !1) : window.attachEvent("onload", function() {
                WebSocket.__initialize()
            })), void 0) : void a.error("Flash Player >= 10.0.0 is required.")
        }
    }(),
    function(a, b, c) {
        function d(a) {
            a && (b.Transport.apply(this, arguments), this.sendBuffer = [])
        }

        function e() {}
        a.XHR = d, b.util.inherit(d, b.Transport), d.prototype.open = function() {
            return this.socket.setBuffer(!1), this.onOpen(), this.get(), this.setCloseTimeout(), this
        }, d.prototype.payload = function(a) {
            for (var c = [], d = 0, e = a.length; e > d; d++) c.push(b.parser.encodePacket(a[d]));
            this.send(b.parser.encodePayload(c))
        }, d.prototype.send = function(a) {
            return this.post(a), this
        }, d.prototype.post = function(a) {
            function b() {
                4 == this.readyState && (this.onreadystatechange = e, f.posting = !1, 200 == this.status ? f.socket.setBuffer(!1) : f.onClose())
            }

            function d() {
                this.onload = e, f.socket.setBuffer(!1)
            }
            var f = this;
            this.socket.setBuffer(!0), this.sendXHR = this.request("POST"), c.XDomainRequest && this.sendXHR instanceof XDomainRequest ? this.sendXHR.onload = this.sendXHR.onerror = d : this.sendXHR.onreadystatechange = b, this.sendXHR.send(a)
        }, d.prototype.close = function() {
            return this.onClose(), this
        }, d.prototype.request = function(a) {
            var c = b.util.request(this.socket.isXDomain()),
                d = b.util.query(this.socket.options.query, "t=" + +new Date);
            if (c.open(a || "GET", this.prepareUrl() + d, !0), "POST" == a) try {
                c.setRequestHeader ? c.setRequestHeader("Content-type", "text/plain;charset=UTF-8") : c.contentType = "text/plain"
            } catch (e) {}
            return c
        }, d.prototype.scheme = function() {
            return this.socket.options.secure ? "https" : "http"
        }, d.check = function(a, d) {
            try {
                var e = b.util.request(d),
                    f = c.XDomainRequest && e instanceof XDomainRequest,
                    g = a && a.options && a.options.secure ? "https:" : "http:",
                    h = c.location && g != c.location.protocol;
                if (e && (!f || !h)) return !0
            } catch (i) {}
            return !1
        }, d.xdomainCheck = function(a) {
            return d.check(a, !0)
        }
    }("undefined" != typeof io ? io.Transport : module.exports, "undefined" != typeof io ? io : module.parent.exports, this),
    function(a, b) {
        function c() {
            b.Transport.XHR.apply(this, arguments)
        }
        a.htmlfile = c, b.util.inherit(c, b.Transport.XHR), c.prototype.name = "htmlfile", c.prototype.get = function() {
            this.doc = new(window[["Active"].concat("Object").join("X")])("htmlfile"), this.doc.open(), this.doc.write("<html></html>"), this.doc.close(), this.doc.parentWindow.s = this;
            var a = this.doc.createElement("div");
            a.className = "socketio", this.doc.body.appendChild(a), this.iframe = this.doc.createElement("iframe"), a.appendChild(this.iframe);
            var c = this,
                d = b.util.query(this.socket.options.query, "t=" + +new Date);
            this.iframe.src = this.prepareUrl() + d, b.util.on(window, "unload", function() {
                c.destroy()
            })
        }, c.prototype._ = function(a, b) {
            a = a.replace(/\\\//g, "/"), this.onData(a);
            try {
                var c = b.getElementsByTagName("script")[0];
                c.parentNode.removeChild(c)
            } catch (d) {}
        }, c.prototype.destroy = function() {
            if (this.iframe) {
                try {
                    this.iframe.src = "about:blank"
                } catch (a) {}
                this.doc = null, this.iframe.parentNode.removeChild(this.iframe), this.iframe = null, CollectGarbage()
            }
        }, c.prototype.close = function() {
            return this.destroy(), b.Transport.XHR.prototype.close.call(this)
        }, c.check = function(a) {
            if ("undefined" != typeof window && ["Active"].concat("Object").join("X") in window) try {
                var c = new(window[["Active"].concat("Object").join("X")])("htmlfile");
                return c && b.Transport.XHR.check(a)
            } catch (d) {}
            return !1
        }, c.xdomainCheck = function() {
            return !1
        }, b.transports.push("htmlfile")
    }("undefined" != typeof io ? io.Transport : module.exports, "undefined" != typeof io ? io : module.parent.exports),
    function(a, b, c) {
        function d() {
            b.Transport.XHR.apply(this, arguments)
        }

        function e() {}
        a["xhr-polling"] = d, b.util.inherit(d, b.Transport.XHR), b.util.merge(d, b.Transport.XHR), d.prototype.name = "xhr-polling", d.prototype.heartbeats = function() {
            return !1
        }, d.prototype.open = function() {
            var a = this;
            return b.Transport.XHR.prototype.open.call(a), !1
        }, d.prototype.get = function() {
            function a() {
                4 == this.readyState && (this.onreadystatechange = e, 200 == this.status ? (f.onData(this.responseText), f.get()) : f.onClose())
            }

            function b() {
                this.onload = e, this.onerror = e, f.retryCounter = 1, f.onData(this.responseText), f.get()
            }

            function d() {
                f.retryCounter++, !f.retryCounter || f.retryCounter > 3 ? f.onClose() : f.get()
            }
            if (this.isOpen) {
                var f = this;
                this.xhr = this.request(), c.XDomainRequest && this.xhr instanceof XDomainRequest ? (this.xhr.onload = b, this.xhr.onerror = d) : this.xhr.onreadystatechange = a, this.xhr.send(null)
            }
        }, d.prototype.onClose = function() {
            if (b.Transport.XHR.prototype.onClose.call(this), this.xhr) {
                this.xhr.onreadystatechange = this.xhr.onload = this.xhr.onerror = e;
                try {
                    this.xhr.abort()
                } catch (a) {}
                this.xhr = null
            }
        }, d.prototype.ready = function(a, c) {
            var d = this;
            b.util.defer(function() {
                c.call(d)
            })
        }, b.transports.push("xhr-polling")
    }("undefined" != typeof io ? io.Transport : module.exports, "undefined" != typeof io ? io : module.parent.exports, this),
    function(a, b, c) {
        function d() {
            b.Transport["xhr-polling"].apply(this, arguments), this.index = b.j.length;
            var a = this;
            b.j.push(function(b) {
                a._(b)
            })
        }
        var e = c.document && "MozAppearance" in c.document.documentElement.style;
        a["jsonp-polling"] = d, b.util.inherit(d, b.Transport["xhr-polling"]), d.prototype.name = "jsonp-polling", d.prototype.post = function(a) {
            function c() {
                d(), e.socket.setBuffer(!1)
            }

            function d() {
                e.iframe && e.form.removeChild(e.iframe);
                try {
                    g = document.createElement('<iframe name="' + e.iframeId + '">')
                } catch (a) {
                    g = document.createElement("iframe"), g.name = e.iframeId
                }
                g.id = e.iframeId, e.form.appendChild(g), e.iframe = g
            }
            var e = this,
                f = b.util.query(this.socket.options.query, "t=" + +new Date + "&i=" + this.index);
            if (!this.form) {
                var g, h = document.createElement("form"),
                    i = document.createElement("textarea"),
                    j = this.iframeId = "socketio_iframe_" + this.index;
                h.className = "socketio", h.style.position = "absolute", h.style.top = "0px", h.style.left = "0px", h.style.display = "none", h.target = j, h.method = "POST", h.setAttribute("accept-charset", "utf-8"), i.name = "d", h.appendChild(i), document.body.appendChild(h), this.form = h, this.area = i
            }
            this.form.action = this.prepareUrl() + f, d(), this.area.value = b.JSON.stringify(a);
            try {
                this.form.submit()
            } catch (k) {}
            this.iframe.attachEvent ? g.onreadystatechange = function() {
                "complete" == e.iframe.readyState && c()
            } : this.iframe.onload = c, this.socket.setBuffer(!0)
        }, d.prototype.get = function() {
            var a = this,
                c = document.createElement("script"),
                d = b.util.query(this.socket.options.query, "t=" + +new Date + "&i=" + this.index);
            this.script && (this.script.parentNode.removeChild(this.script), this.script = null), c.async = !0, c.src = this.prepareUrl() + d, c.onerror = function() {
                a.onClose()
            };
            var f = document.getElementsByTagName("script")[0];
            f.parentNode.insertBefore(c, f), this.script = c, e && setTimeout(function() {
                var a = document.createElement("iframe");
                document.body.appendChild(a), document.body.removeChild(a)
            }, 100)
        }, d.prototype._ = function(a) {
            return this.onData(a), this.isOpen && this.get(), this
        }, d.prototype.ready = function(a, c) {
            var d = this;
            return e ? void b.util.load(function() {
                c.call(d)
            }) : c.call(this)
        }, d.check = function() {
            return "document" in c
        }, d.xdomainCheck = function() {
            return !0
        }, b.transports.push("jsonp-polling")
    }("undefined" != typeof io ? io.Transport : module.exports, "undefined" != typeof io ? io : module.parent.exports, this), "function" == typeof define && define.amd && define([], function() {
        return io
    })
}();
var Box2D = {};
! function(a, b) {
    function c() {}!(Object.defineProperty instanceof Function) && Object.prototype.__defineGetter__ instanceof Function && Object.prototype.__defineSetter__ instanceof Function && (Object.defineProperty = function(a, b, c) {
        c.get instanceof Function && a.__defineGetter__(b, c.get), c.set instanceof Function && a.__defineSetter__(b, c.set)
    }), a.inherit = function(a, b) {
        var d = a;
        c.prototype = b.prototype, a.prototype = new c, a.prototype.constructor = d
    }, a.generateCallback = function(a, b) {
        return function() {
            b.apply(a, arguments)
        }
    }, a.NVector = function(a) {
        a === b && (a = 0);
        for (var c = new Array(a || 0), d = 0; a > d; ++d) c[d] = 0;
        return c
    }, a.is = function(a, c) {
        return null === a ? !1 : c instanceof Function && a instanceof c ? !0 : a.constructor.__implements != b && a.constructor.__implements[c] ? !0 : !1
    }, a.parseUInt = function(a) {
        return Math.abs(parseInt(a))
    }
}(Box2D);
var Vector = Array,
    Vector_a2j_Number = Box2D.NVector;
"undefined" == typeof Box2D && (Box2D = {}), "undefined" == typeof Box2D.Collision && (Box2D.Collision = {}), "undefined" == typeof Box2D.Collision.Shapes && (Box2D.Collision.Shapes = {}), "undefined" == typeof Box2D.Common && (Box2D.Common = {}), "undefined" == typeof Box2D.Common.Math && (Box2D.Common.Math = {}), "undefined" == typeof Box2D.Dynamics && (Box2D.Dynamics = {}), "undefined" == typeof Box2D.Dynamics.Contacts && (Box2D.Dynamics.Contacts = {}), "undefined" == typeof Box2D.Dynamics.Controllers && (Box2D.Dynamics.Controllers = {}), "undefined" == typeof Box2D.Dynamics.Joints && (Box2D.Dynamics.Joints = {}),
    function() {
        function a() {
            a.b2AABB.apply(this, arguments)
        }

        function b() {
            b.b2Bound.apply(this, arguments)
        }

        function c() {
            c.b2BoundValues.apply(this, arguments), this.constructor === c && this.b2BoundValues.apply(this, arguments)
        }

        function d() {
            d.b2Collision.apply(this, arguments)
        }

        function e() {
            e.b2ContactID.apply(this, arguments), this.constructor === e && this.b2ContactID.apply(this, arguments)
        }

        function f() {
            f.b2ContactPoint.apply(this, arguments)
        }

        function g() {
            g.b2Distance.apply(this, arguments)
        }

        function h() {
            h.b2DistanceInput.apply(this, arguments)
        }

        function i() {
            i.b2DistanceOutput.apply(this, arguments)
        }

        function j() {
            j.b2DistanceProxy.apply(this, arguments)
        }

        function k() {
            k.b2DynamicTree.apply(this, arguments), this.constructor === k && this.b2DynamicTree.apply(this, arguments)
        }

        function l() {
            l.b2DynamicTreeBroadPhase.apply(this, arguments)
        }

        function m() {
            m.b2DynamicTreeNode.apply(this, arguments)
        }

        function n() {
            n.b2DynamicTreePair.apply(this, arguments)
        }

        function o() {
            o.b2Manifold.apply(this, arguments), this.constructor === o && this.b2Manifold.apply(this, arguments)
        }

        function p() {
            p.b2ManifoldPoint.apply(this, arguments), this.constructor === p && this.b2ManifoldPoint.apply(this, arguments)
        }

        function q() {
            q.b2Point.apply(this, arguments)
        }

        function r() {
            r.b2RayCastInput.apply(this, arguments), this.constructor === r && this.b2RayCastInput.apply(this, arguments)
        }

        function s() {
            s.b2RayCastOutput.apply(this, arguments)
        }

        function t() {
            t.b2Segment.apply(this, arguments)
        }

        function u() {
            u.b2SeparationFunction.apply(this, arguments)
        }

        function v() {
            v.b2Simplex.apply(this, arguments), this.constructor === v && this.b2Simplex.apply(this, arguments)
        }

        function w() {
            w.b2SimplexCache.apply(this, arguments)
        }

        function x() {
            x.b2SimplexVertex.apply(this, arguments)
        }

        function y() {
            y.b2TimeOfImpact.apply(this, arguments)
        }

        function z() {
            z.b2TOIInput.apply(this, arguments)
        }

        function A() {
            A.b2WorldManifold.apply(this, arguments), this.constructor === A && this.b2WorldManifold.apply(this, arguments)
        }

        function B() {
            B.ClipVertex.apply(this, arguments)
        }

        function C() {
            C.Features.apply(this, arguments)
        }

        function D() {
            D.b2CircleShape.apply(this, arguments), this.constructor === D && this.b2CircleShape.apply(this, arguments)
        }

        function E() {
            E.b2EdgeChainDef.apply(this, arguments), this.constructor === E && this.b2EdgeChainDef.apply(this, arguments)
        }

        function F() {
            F.b2EdgeShape.apply(this, arguments), this.constructor === F && this.b2EdgeShape.apply(this, arguments)
        }

        function G() {
            G.b2MassData.apply(this, arguments)
        }

        function H() {
            H.b2PolygonShape.apply(this, arguments), this.constructor === H && this.b2PolygonShape.apply(this, arguments)
        }

        function I() {
            I.b2Shape.apply(this, arguments), this.constructor === I && this.b2Shape.apply(this, arguments)
        }

        function J() {
            J.b2Color.apply(this, arguments), this.constructor === J && this.b2Color.apply(this, arguments)
        }

        function K() {
            K.b2Settings.apply(this, arguments)
        }

        function L() {
            L.b2Mat22.apply(this, arguments), this.constructor === L && this.b2Mat22.apply(this, arguments)
        }

        function M() {
            M.b2Mat33.apply(this, arguments), this.constructor === M && this.b2Mat33.apply(this, arguments)
        }

        function N() {
            N.b2Math.apply(this, arguments)
        }

        function O() {
            O.b2Sweep.apply(this, arguments)
        }

        function P() {
            P.b2Transform.apply(this, arguments), this.constructor === P && this.b2Transform.apply(this, arguments)
        }

        function Q() {
            Q.b2Vec2.apply(this, arguments), this.constructor === Q && this.b2Vec2.apply(this, arguments)
        }

        function R() {
            R.b2Vec3.apply(this, arguments), this.constructor === R && this.b2Vec3.apply(this, arguments)
        }

        function S() {
            S.b2Body.apply(this, arguments), this.constructor === S && this.b2Body.apply(this, arguments)
        }

        function T() {
            T.b2BodyDef.apply(this, arguments), this.constructor === T && this.b2BodyDef.apply(this, arguments)
        }

        function U() {
            U.b2ContactFilter.apply(this, arguments)
        }

        function V() {
            V.b2ContactImpulse.apply(this, arguments)
        }

        function W() {
            W.b2ContactListener.apply(this, arguments)
        }

        function X() {
            X.b2ContactManager.apply(this, arguments), this.constructor === X && this.b2ContactManager.apply(this, arguments)
        }

        function Y() {
            Y.b2DebugDraw.apply(this, arguments), this.constructor === Y && this.b2DebugDraw.apply(this, arguments)
        }

        function Z() {
            Z.b2DestructionListener.apply(this, arguments)
        }

        function $() {
            $.b2FilterData.apply(this, arguments)
        }

        function _() {
            _.b2Fixture.apply(this, arguments), this.constructor === _ && this.b2Fixture.apply(this, arguments)
        }

        function ab() {
            ab.b2FixtureDef.apply(this, arguments), this.constructor === ab && this.b2FixtureDef.apply(this, arguments)
        }

        function bb() {
            bb.b2Island.apply(this, arguments), this.constructor === bb && this.b2Island.apply(this, arguments)
        }

        function cb() {
            cb.b2TimeStep.apply(this, arguments)
        }

        function db() {
            db.b2World.apply(this, arguments), this.constructor === db && this.b2World.apply(this, arguments)
        }

        function eb() {
            eb.b2CircleContact.apply(this, arguments)
        }

        function fb() {
            fb.b2Contact.apply(this, arguments), this.constructor === fb && this.b2Contact.apply(this, arguments)
        }

        function gb() {
            gb.b2ContactConstraint.apply(this, arguments), this.constructor === gb && this.b2ContactConstraint.apply(this, arguments)
        }

        function hb() {
            hb.b2ContactConstraintPoint.apply(this, arguments)
        }

        function ib() {
            ib.b2ContactEdge.apply(this, arguments)
        }

        function jb() {
            jb.b2ContactFactory.apply(this, arguments), this.constructor === jb && this.b2ContactFactory.apply(this, arguments)
        }

        function kb() {
            kb.b2ContactRegister.apply(this, arguments)
        }

        function lb() {
            lb.b2ContactResult.apply(this, arguments)
        }

        function mb() {
            mb.b2ContactSolver.apply(this, arguments), this.constructor === mb && this.b2ContactSolver.apply(this, arguments)
        }

        function nb() {
            nb.b2EdgeAndCircleContact.apply(this, arguments)
        }

        function ob() {
            ob.b2NullContact.apply(this, arguments), this.constructor === ob && this.b2NullContact.apply(this, arguments)
        }

        function pb() {
            pb.b2PolyAndCircleContact.apply(this, arguments)
        }

        function qb() {
            qb.b2PolyAndEdgeContact.apply(this, arguments)
        }

        function rb() {
            rb.b2PolygonContact.apply(this, arguments)
        }

        function sb() {
            sb.b2PositionSolverManifold.apply(this, arguments), this.constructor === sb && this.b2PositionSolverManifold.apply(this, arguments)
        }

        function tb() {
            tb.b2BuoyancyController.apply(this, arguments)
        }

        function ub() {
            ub.b2ConstantAccelController.apply(this, arguments)
        }

        function vb() {
            vb.b2ConstantForceController.apply(this, arguments)
        }

        function wb() {
            wb.b2Controller.apply(this, arguments)
        }

        function xb() {
            xb.b2ControllerEdge.apply(this, arguments)
        }

        function yb() {
            yb.b2GravityController.apply(this, arguments)
        }

        function zb() {
            zb.b2TensorDampingController.apply(this, arguments)
        }

        function Ab() {
            Ab.b2DistanceJoint.apply(this, arguments), this.constructor === Ab && this.b2DistanceJoint.apply(this, arguments)
        }

        function Bb() {
            Bb.b2DistanceJointDef.apply(this, arguments), this.constructor === Bb && this.b2DistanceJointDef.apply(this, arguments)
        }

        function Cb() {
            Cb.b2FrictionJoint.apply(this, arguments), this.constructor === Cb && this.b2FrictionJoint.apply(this, arguments)
        }

        function Db() {
            Db.b2FrictionJointDef.apply(this, arguments), this.constructor === Db && this.b2FrictionJointDef.apply(this, arguments)
        }

        function Eb() {
            Eb.b2GearJoint.apply(this, arguments), this.constructor === Eb && this.b2GearJoint.apply(this, arguments)
        }

        function Fb() {
            Fb.b2GearJointDef.apply(this, arguments), this.constructor === Fb && this.b2GearJointDef.apply(this, arguments)
        }

        function Gb() {
            Gb.b2Jacobian.apply(this, arguments)
        }

        function Hb() {
            Hb.b2Joint.apply(this, arguments), this.constructor === Hb && this.b2Joint.apply(this, arguments)
        }

        function Ib() {
            Ib.b2JointDef.apply(this, arguments), this.constructor === Ib && this.b2JointDef.apply(this, arguments)
        }

        function Jb() {
            Jb.b2JointEdge.apply(this, arguments)
        }

        function Kb() {
            Kb.b2LineJoint.apply(this, arguments), this.constructor === Kb && this.b2LineJoint.apply(this, arguments)
        }

        function Lb() {
            Lb.b2LineJointDef.apply(this, arguments), this.constructor === Lb && this.b2LineJointDef.apply(this, arguments)
        }

        function Mb() {
            Mb.b2MouseJoint.apply(this, arguments), this.constructor === Mb && this.b2MouseJoint.apply(this, arguments)
        }

        function Nb() {
            Nb.b2MouseJointDef.apply(this, arguments), this.constructor === Nb && this.b2MouseJointDef.apply(this, arguments)
        }

        function Ob() {
            Ob.b2PrismaticJoint.apply(this, arguments), this.constructor === Ob && this.b2PrismaticJoint.apply(this, arguments)
        }

        function Pb() {
            Pb.b2PrismaticJointDef.apply(this, arguments), this.constructor === Pb && this.b2PrismaticJointDef.apply(this, arguments)
        }

        function Qb() {
            Qb.b2PulleyJoint.apply(this, arguments), this.constructor === Qb && this.b2PulleyJoint.apply(this, arguments)
        }

        function Rb() {
            Rb.b2PulleyJointDef.apply(this, arguments), this.constructor === Rb && this.b2PulleyJointDef.apply(this, arguments)
        }

        function Sb() {
            Sb.b2RevoluteJoint.apply(this, arguments), this.constructor === Sb && this.b2RevoluteJoint.apply(this, arguments)
        }

        function Tb() {
            Tb.b2RevoluteJointDef.apply(this, arguments), this.constructor === Tb && this.b2RevoluteJointDef.apply(this, arguments)
        }

        function Ub() {
            Ub.b2WeldJoint.apply(this, arguments), this.constructor === Ub && this.b2WeldJoint.apply(this, arguments)
        }

        function Vb() {
            Vb.b2WeldJointDef.apply(this, arguments), this.constructor === Vb && this.b2WeldJointDef.apply(this, arguments)
        }
        Box2D.Collision.IBroadPhase = "Box2D.Collision.IBroadPhase", Box2D.Collision.b2AABB = a, Box2D.Collision.b2Bound = b, Box2D.Collision.b2BoundValues = c, Box2D.Collision.b2Collision = d, Box2D.Collision.b2ContactID = e, Box2D.Collision.b2ContactPoint = f, Box2D.Collision.b2Distance = g, Box2D.Collision.b2DistanceInput = h, Box2D.Collision.b2DistanceOutput = i, Box2D.Collision.b2DistanceProxy = j, Box2D.Collision.b2DynamicTree = k, Box2D.Collision.b2DynamicTreeBroadPhase = l, Box2D.Collision.b2DynamicTreeNode = m, Box2D.Collision.b2DynamicTreePair = n, Box2D.Collision.b2Manifold = o, Box2D.Collision.b2ManifoldPoint = p, Box2D.Collision.b2Point = q, Box2D.Collision.b2RayCastInput = r, Box2D.Collision.b2RayCastOutput = s, Box2D.Collision.b2Segment = t, Box2D.Collision.b2SeparationFunction = u, Box2D.Collision.b2Simplex = v, Box2D.Collision.b2SimplexCache = w, Box2D.Collision.b2SimplexVertex = x, Box2D.Collision.b2TimeOfImpact = y, Box2D.Collision.b2TOIInput = z, Box2D.Collision.b2WorldManifold = A, Box2D.Collision.ClipVertex = B, Box2D.Collision.Features = C, Box2D.Collision.Shapes.b2CircleShape = D, Box2D.Collision.Shapes.b2EdgeChainDef = E, Box2D.Collision.Shapes.b2EdgeShape = F, Box2D.Collision.Shapes.b2MassData = G, Box2D.Collision.Shapes.b2PolygonShape = H, Box2D.Collision.Shapes.b2Shape = I, Box2D.Common.b2internal = "Box2D.Common.b2internal", Box2D.Common.b2Color = J, Box2D.Common.b2Settings = K, Box2D.Common.Math.b2Mat22 = L, Box2D.Common.Math.b2Mat33 = M, Box2D.Common.Math.b2Math = N, Box2D.Common.Math.b2Sweep = O, Box2D.Common.Math.b2Transform = P, Box2D.Common.Math.b2Vec2 = Q, Box2D.Common.Math.b2Vec3 = R, Box2D.Dynamics.b2Body = S, Box2D.Dynamics.b2BodyDef = T, Box2D.Dynamics.b2ContactFilter = U, Box2D.Dynamics.b2ContactImpulse = V, Box2D.Dynamics.b2ContactListener = W, Box2D.Dynamics.b2ContactManager = X, Box2D.Dynamics.b2DebugDraw = Y, Box2D.Dynamics.b2DestructionListener = Z, Box2D.Dynamics.b2FilterData = $, Box2D.Dynamics.b2Fixture = _, Box2D.Dynamics.b2FixtureDef = ab, Box2D.Dynamics.b2Island = bb, Box2D.Dynamics.b2TimeStep = cb, Box2D.Dynamics.b2World = db, Box2D.Dynamics.Contacts.b2CircleContact = eb, Box2D.Dynamics.Contacts.b2Contact = fb, Box2D.Dynamics.Contacts.b2ContactConstraint = gb, Box2D.Dynamics.Contacts.b2ContactConstraintPoint = hb, Box2D.Dynamics.Contacts.b2ContactEdge = ib, Box2D.Dynamics.Contacts.b2ContactFactory = jb, Box2D.Dynamics.Contacts.b2ContactRegister = kb, Box2D.Dynamics.Contacts.b2ContactResult = lb, Box2D.Dynamics.Contacts.b2ContactSolver = mb, Box2D.Dynamics.Contacts.b2EdgeAndCircleContact = nb, Box2D.Dynamics.Contacts.b2NullContact = ob, Box2D.Dynamics.Contacts.b2PolyAndCircleContact = pb, Box2D.Dynamics.Contacts.b2PolyAndEdgeContact = qb, Box2D.Dynamics.Contacts.b2PolygonContact = rb, Box2D.Dynamics.Contacts.b2PositionSolverManifold = sb, Box2D.Dynamics.Controllers.b2BuoyancyController = tb, Box2D.Dynamics.Controllers.b2ConstantAccelController = ub, Box2D.Dynamics.Controllers.b2ConstantForceController = vb, Box2D.Dynamics.Controllers.b2Controller = wb, Box2D.Dynamics.Controllers.b2ControllerEdge = xb, Box2D.Dynamics.Controllers.b2GravityController = yb, Box2D.Dynamics.Controllers.b2TensorDampingController = zb, Box2D.Dynamics.Joints.b2DistanceJoint = Ab, Box2D.Dynamics.Joints.b2DistanceJointDef = Bb, Box2D.Dynamics.Joints.b2FrictionJoint = Cb, Box2D.Dynamics.Joints.b2FrictionJointDef = Db, Box2D.Dynamics.Joints.b2GearJoint = Eb, Box2D.Dynamics.Joints.b2GearJointDef = Fb, Box2D.Dynamics.Joints.b2Jacobian = Gb, Box2D.Dynamics.Joints.b2Joint = Hb, Box2D.Dynamics.Joints.b2JointDef = Ib, Box2D.Dynamics.Joints.b2JointEdge = Jb, Box2D.Dynamics.Joints.b2LineJoint = Kb, Box2D.Dynamics.Joints.b2LineJointDef = Lb, Box2D.Dynamics.Joints.b2MouseJoint = Mb, Box2D.Dynamics.Joints.b2MouseJointDef = Nb, Box2D.Dynamics.Joints.b2PrismaticJoint = Ob, Box2D.Dynamics.Joints.b2PrismaticJointDef = Pb, Box2D.Dynamics.Joints.b2PulleyJoint = Qb, Box2D.Dynamics.Joints.b2PulleyJointDef = Rb, Box2D.Dynamics.Joints.b2RevoluteJoint = Sb, Box2D.Dynamics.Joints.b2RevoluteJointDef = Tb, Box2D.Dynamics.Joints.b2WeldJoint = Ub, Box2D.Dynamics.Joints.b2WeldJointDef = Vb
    }(), Box2D.postDefs = [],
    function() {
        var a = Box2D.Collision.Shapes.b2CircleShape,
            b = (Box2D.Collision.Shapes.b2EdgeChainDef, Box2D.Collision.Shapes.b2EdgeShape, Box2D.Collision.Shapes.b2MassData, Box2D.Collision.Shapes.b2PolygonShape),
            c = Box2D.Collision.Shapes.b2Shape,
            d = (Box2D.Common.b2Color, Box2D.Common.b2internal, Box2D.Common.b2Settings),
            e = (Box2D.Common.Math.b2Mat22, Box2D.Common.Math.b2Mat33, Box2D.Common.Math.b2Math),
            f = Box2D.Common.Math.b2Sweep,
            g = Box2D.Common.Math.b2Transform,
            h = Box2D.Common.Math.b2Vec2,
            i = (Box2D.Common.Math.b2Vec3, Box2D.Collision.b2AABB),
            j = Box2D.Collision.b2Bound,
            k = Box2D.Collision.b2BoundValues,
            l = Box2D.Collision.b2Collision,
            m = Box2D.Collision.b2ContactID,
            n = Box2D.Collision.b2ContactPoint,
            o = Box2D.Collision.b2Distance,
            p = Box2D.Collision.b2DistanceInput,
            q = Box2D.Collision.b2DistanceOutput,
            r = Box2D.Collision.b2DistanceProxy,
            s = Box2D.Collision.b2DynamicTree,
            t = Box2D.Collision.b2DynamicTreeBroadPhase,
            u = Box2D.Collision.b2DynamicTreeNode,
            v = Box2D.Collision.b2DynamicTreePair,
            w = Box2D.Collision.b2Manifold,
            x = Box2D.Collision.b2ManifoldPoint,
            y = Box2D.Collision.b2Point,
            z = Box2D.Collision.b2RayCastInput,
            A = Box2D.Collision.b2RayCastOutput,
            B = Box2D.Collision.b2Segment,
            C = Box2D.Collision.b2SeparationFunction,
            D = Box2D.Collision.b2Simplex,
            E = Box2D.Collision.b2SimplexCache,
            F = Box2D.Collision.b2SimplexVertex,
            G = Box2D.Collision.b2TimeOfImpact,
            H = Box2D.Collision.b2TOIInput,
            I = Box2D.Collision.b2WorldManifold,
            J = Box2D.Collision.ClipVertex,
            K = Box2D.Collision.Features,
            L = Box2D.Collision.IBroadPhase;
        i.b2AABB = function() {
            this.lowerBound = new h, this.upperBound = new h
        }, i.prototype.IsValid = function() {
            var a = this.upperBound.x - this.lowerBound.x,
                b = this.upperBound.y - this.lowerBound.y,
                c = a >= 0 && b >= 0;
            return c = c && this.lowerBound.IsValid() && this.upperBound.IsValid()
        }, i.prototype.GetCenter = function() {
            return new h((this.lowerBound.x + this.upperBound.x) / 2, (this.lowerBound.y + this.upperBound.y) / 2)
        }, i.prototype.GetExtents = function() {
            return new h((this.upperBound.x - this.lowerBound.x) / 2, (this.upperBound.y - this.lowerBound.y) / 2)
        }, i.prototype.Contains = function(a) {
            var b = !0;
            return b = b && this.lowerBound.x <= a.lowerBound.x, b = b && this.lowerBound.y <= a.lowerBound.y, b = b && a.upperBound.x <= this.upperBound.x, b = b && a.upperBound.y <= this.upperBound.y
        }, i.prototype.RayCast = function(a, b) {
            var c = -Number.MAX_VALUE,
                d = Number.MAX_VALUE,
                e = b.p1.x,
                f = b.p1.y,
                g = b.p2.x - b.p1.x,
                h = b.p2.y - b.p1.y,
                i = Math.abs(g),
                j = Math.abs(h),
                k = a.normal,
                l = 0,
                m = 0,
                n = 0,
                o = 0,
                p = 0;
            if (i < Number.MIN_VALUE) {
                if (e < this.lowerBound.x || this.upperBound.x < e) return !1
            } else if (l = 1 / g, m = (this.lowerBound.x - e) * l, n = (this.upperBound.x - e) * l, p = -1, m > n && (o = m, m = n, n = o, p = 1), m > c && (k.x = p, k.y = 0, c = m), d = Math.min(d, n), c > d) return !1;
            if (j < Number.MIN_VALUE) {
                if (f < this.lowerBound.y || this.upperBound.y < f) return !1
            } else if (l = 1 / h, m = (this.lowerBound.y - f) * l, n = (this.upperBound.y - f) * l, p = -1, m > n && (o = m, m = n, n = o, p = 1), m > c && (k.y = p, k.x = 0, c = m), d = Math.min(d, n), c > d) return !1;
            return a.fraction = c, !0
        }, i.prototype.TestOverlap = function(a) {
            var b = a.lowerBound.x - this.upperBound.x,
                c = a.lowerBound.y - this.upperBound.y,
                d = this.lowerBound.x - a.upperBound.x,
                e = this.lowerBound.y - a.upperBound.y;
            return b > 0 || c > 0 ? !1 : d > 0 || e > 0 ? !1 : !0
        }, i.Combine = function(a, b) {
            var c = new i;
            return c.Combine(a, b), c
        }, i.prototype.Combine = function(a, b) {
            this.lowerBound.x = Math.min(a.lowerBound.x, b.lowerBound.x), this.lowerBound.y = Math.min(a.lowerBound.y, b.lowerBound.y), this.upperBound.x = Math.max(a.upperBound.x, b.upperBound.x), this.upperBound.y = Math.max(a.upperBound.y, b.upperBound.y)
        }, j.b2Bound = function() {}, j.prototype.IsLower = function() {
            return 0 == (1 & this.value)
        }, j.prototype.IsUpper = function() {
            return 1 == (1 & this.value)
        }, j.prototype.Swap = function(a) {
            var b = this.value,
                c = this.proxy,
                d = this.stabbingCount;
            this.value = a.value, this.proxy = a.proxy, this.stabbingCount = a.stabbingCount, a.value = b, a.proxy = c, a.stabbingCount = d
        }, k.b2BoundValues = function() {}, k.prototype.b2BoundValues = function() {
            this.lowerValues = new Vector_a2j_Number, this.lowerValues[0] = 0, this.lowerValues[1] = 0, this.upperValues = new Vector_a2j_Number, this.upperValues[0] = 0, this.upperValues[1] = 0
        }, l.b2Collision = function() {}, l.ClipSegmentToLine = function(a, b, c, d) {
            void 0 === d && (d = 0);
            var e, f = 0;
            e = b[0];
            var g = e.v;
            e = b[1];
            var h = e.v,
                i = c.x * g.x + c.y * g.y - d,
                j = c.x * h.x + c.y * h.y - d;
            if (0 >= i && a[f++].Set(b[0]), 0 >= j && a[f++].Set(b[1]), 0 > i * j) {
                var k = i / (i - j);
                e = a[f];
                var l = e.v;
                l.x = g.x + k * (h.x - g.x), l.y = g.y + k * (h.y - g.y), e = a[f];
                var m;
                i > 0 ? (m = b[0], e.id = m.id) : (m = b[1], e.id = m.id), ++f
            }
            return f
        }, l.EdgeSeparation = function(a, b, c, d, e) {
            void 0 === c && (c = 0);
            var f, g, h = (parseInt(a.m_vertexCount), a.m_vertices),
                i = a.m_normals,
                j = parseInt(d.m_vertexCount),
                k = d.m_vertices;
            f = b.R, g = i[c];
            var l = f.col1.x * g.x + f.col2.x * g.y,
                m = f.col1.y * g.x + f.col2.y * g.y;
            f = e.R;
            for (var n = f.col1.x * l + f.col1.y * m, o = f.col2.x * l + f.col2.y * m, p = 0, q = Number.MAX_VALUE, r = 0; j > r; ++r) {
                g = k[r];
                var s = g.x * n + g.y * o;
                q > s && (q = s, p = r)
            }
            g = h[c], f = b.R;
            var t = b.position.x + (f.col1.x * g.x + f.col2.x * g.y),
                u = b.position.y + (f.col1.y * g.x + f.col2.y * g.y);
            g = k[p], f = e.R;
            var v = e.position.x + (f.col1.x * g.x + f.col2.x * g.y),
                w = e.position.y + (f.col1.y * g.x + f.col2.y * g.y);
            v -= t, w -= u;
            var x = v * l + w * m;
            return x
        }, l.FindMaxSeparation = function(a, b, c, d, e) {
            var f, g, h = parseInt(b.m_vertexCount),
                i = b.m_normals;
            g = e.R, f = d.m_centroid;
            var j = e.position.x + (g.col1.x * f.x + g.col2.x * f.y),
                k = e.position.y + (g.col1.y * f.x + g.col2.y * f.y);
            g = c.R, f = b.m_centroid, j -= c.position.x + (g.col1.x * f.x + g.col2.x * f.y), k -= c.position.y + (g.col1.y * f.x + g.col2.y * f.y);
            for (var m = j * c.R.col1.x + k * c.R.col1.y, n = j * c.R.col2.x + k * c.R.col2.y, o = 0, p = -Number.MAX_VALUE, q = 0; h > q; ++q) {
                f = i[q];
                var r = f.x * m + f.y * n;
                r > p && (p = r, o = q)
            }
            var s = l.EdgeSeparation(b, c, o, d, e),
                t = parseInt(o - 1 >= 0 ? o - 1 : h - 1),
                u = l.EdgeSeparation(b, c, t, d, e),
                v = parseInt(h > o + 1 ? o + 1 : 0),
                w = l.EdgeSeparation(b, c, v, d, e),
                x = 0,
                y = 0,
                z = 0;
            if (u > s && u > w) z = -1, x = t, y = u;
            else {
                if (!(w > s)) return a[0] = o, s;
                z = 1, x = v, y = w
            }
            for (;;) {
                if (o = -1 == z ? x - 1 >= 0 ? x - 1 : h - 1 : h > x + 1 ? x + 1 : 0, s = l.EdgeSeparation(b, c, o, d, e), !(s > y)) break;
                x = o, y = s
            }
            return a[0] = x, y
        }, l.FindIncidentEdge = function(a, b, c, d, e, f) {
            void 0 === d && (d = 0);
            var g, h, i = (parseInt(b.m_vertexCount), b.m_normals),
                j = parseInt(e.m_vertexCount),
                k = e.m_vertices,
                l = e.m_normals;
            g = c.R, h = i[d];
            var m = g.col1.x * h.x + g.col2.x * h.y,
                n = g.col1.y * h.x + g.col2.y * h.y;
            g = f.R;
            var o = g.col1.x * m + g.col1.y * n;
            n = g.col2.x * m + g.col2.y * n, m = o;
            for (var p = 0, q = Number.MAX_VALUE, r = 0; j > r; ++r) {
                h = l[r];
                var s = m * h.x + n * h.y;
                q > s && (q = s, p = r)
            }
            var t, u = parseInt(p),
                v = parseInt(j > u + 1 ? u + 1 : 0);
            t = a[0], h = k[u], g = f.R, t.v.x = f.position.x + (g.col1.x * h.x + g.col2.x * h.y), t.v.y = f.position.y + (g.col1.y * h.x + g.col2.y * h.y), t.id.features.referenceEdge = d, t.id.features.incidentEdge = u, t.id.features.incidentVertex = 0, t = a[1], h = k[v], g = f.R, t.v.x = f.position.x + (g.col1.x * h.x + g.col2.x * h.y), t.v.y = f.position.y + (g.col1.y * h.x + g.col2.y * h.y), t.id.features.referenceEdge = d, t.id.features.incidentEdge = v, t.id.features.incidentVertex = 1
        }, l.MakeClipPointVector = function() {
            var a = new Vector(2);
            return a[0] = new J, a[1] = new J, a
        }, l.CollidePolygons = function(a, b, c, e, f) {
            var g;
            a.m_pointCount = 0;
            var h = b.m_radius + e.m_radius,
                i = 0;
            l.s_edgeAO[0] = i;
            var j = l.FindMaxSeparation(l.s_edgeAO, b, c, e, f);
            if (i = l.s_edgeAO[0], !(j > h)) {
                var k = 0;
                l.s_edgeBO[0] = k;
                var m = l.FindMaxSeparation(l.s_edgeBO, e, f, b, c);
                if (k = l.s_edgeBO[0], !(m > h)) {
                    var n, o, p, q, r, s = 0,
                        t = 0,
                        u = .98,
                        v = .001;
                    m > u * j + v ? (n = e, o = b, p = f, q = c, s = k, a.m_type = w.e_faceB, t = 1) : (n = b, o = e, p = c, q = f, s = i, a.m_type = w.e_faceA, t = 0);
                    var x = l.s_incidentEdge;
                    l.FindIncidentEdge(x, n, p, s, o, q);
                    var y, z = parseInt(n.m_vertexCount),
                        A = n.m_vertices,
                        B = A[s];
                    y = z > s + 1 ? A[parseInt(s + 1)] : A[0];
                    var C = l.s_localTangent;
                    C.Set(y.x - B.x, y.y - B.y), C.Normalize();
                    var D = l.s_localNormal;
                    D.x = C.y, D.y = -C.x;
                    var E = l.s_planePoint;
                    E.Set(.5 * (B.x + y.x), .5 * (B.y + y.y));
                    var F = l.s_tangent;
                    r = p.R, F.x = r.col1.x * C.x + r.col2.x * C.y, F.y = r.col1.y * C.x + r.col2.y * C.y;
                    var G = l.s_tangent2;
                    G.x = -F.x, G.y = -F.y;
                    var H = l.s_normal;
                    H.x = F.y, H.y = -F.x;
                    var I = l.s_v11,
                        J = l.s_v12;
                    I.x = p.position.x + (r.col1.x * B.x + r.col2.x * B.y), I.y = p.position.y + (r.col1.y * B.x + r.col2.y * B.y), J.x = p.position.x + (r.col1.x * y.x + r.col2.x * y.y), J.y = p.position.y + (r.col1.y * y.x + r.col2.y * y.y);
                    var K = H.x * I.x + H.y * I.y,
                        L = -F.x * I.x - F.y * I.y + h,
                        M = F.x * J.x + F.y * J.y + h,
                        N = l.s_clipPoints1,
                        O = l.s_clipPoints2,
                        P = 0;
                    if (P = l.ClipSegmentToLine(N, x, G, L), !(2 > P || (P = l.ClipSegmentToLine(O, N, F, M), 2 > P))) {
                        a.m_localPlaneNormal.SetV(D), a.m_localPoint.SetV(E);
                        for (var Q = 0, R = 0; R < d.b2_maxManifoldPoints; ++R) {
                            g = O[R];
                            var S = H.x * g.v.x + H.y * g.v.y - K;
                            if (h >= S) {
                                var T = a.m_points[Q];
                                r = q.R;
                                var U = g.v.x - q.position.x,
                                    V = g.v.y - q.position.y;
                                T.m_localPoint.x = U * r.col1.x + V * r.col1.y, T.m_localPoint.y = U * r.col2.x + V * r.col2.y, T.m_id.Set(g.id), T.m_id.features.flip = t, ++Q
                            }
                        }
                        a.m_pointCount = Q
                    }
                }
            }
        }, l.CollideCircles = function(a, b, c, d, e) {
            a.m_pointCount = 0;
            var f, g;
            f = c.R, g = b.m_p;
            var h = c.position.x + (f.col1.x * g.x + f.col2.x * g.y),
                i = c.position.y + (f.col1.y * g.x + f.col2.y * g.y);
            f = e.R, g = d.m_p;
            var j = e.position.x + (f.col1.x * g.x + f.col2.x * g.y),
                k = e.position.y + (f.col1.y * g.x + f.col2.y * g.y),
                l = j - h,
                m = k - i,
                n = l * l + m * m,
                o = b.m_radius + d.m_radius;
            n > o * o || (a.m_type = w.e_circles, a.m_localPoint.SetV(b.m_p), a.m_localPlaneNormal.SetZero(), a.m_pointCount = 1, a.m_points[0].m_localPoint.SetV(d.m_p), a.m_points[0].m_id.key = 0)
        }, l.CollidePolygonAndCircle = function(a, b, c, d, e) {
            a.m_pointCount = 0;
            var f, g, h = 0,
                i = 0;
            g = e.R, f = d.m_p;
            var j = e.position.x + (g.col1.x * f.x + g.col2.x * f.y),
                k = e.position.y + (g.col1.y * f.x + g.col2.y * f.y);
            h = j - c.position.x, i = k - c.position.y, g = c.R;
            for (var l = h * g.col1.x + i * g.col1.y, m = h * g.col2.x + i * g.col2.y, n = 0, o = -Number.MAX_VALUE, p = b.m_radius + d.m_radius, q = parseInt(b.m_vertexCount), r = b.m_vertices, s = b.m_normals, t = 0; q > t; ++t) {
                f = r[t], h = l - f.x, i = m - f.y, f = s[t];
                var u = f.x * h + f.y * i;
                if (u > p) return;
                u > o && (o = u, n = t)
            }
            var v = parseInt(n),
                x = parseInt(q > v + 1 ? v + 1 : 0),
                y = r[v],
                z = r[x];
            if (o < Number.MIN_VALUE) return a.m_pointCount = 1, a.m_type = w.e_faceA, a.m_localPlaneNormal.SetV(s[n]), a.m_localPoint.x = .5 * (y.x + z.x), a.m_localPoint.y = .5 * (y.y + z.y), a.m_points[0].m_localPoint.SetV(d.m_p), void(a.m_points[0].m_id.key = 0);
            var A = (l - y.x) * (z.x - y.x) + (m - y.y) * (z.y - y.y),
                B = (l - z.x) * (y.x - z.x) + (m - z.y) * (y.y - z.y);
            if (0 >= A) {
                if ((l - y.x) * (l - y.x) + (m - y.y) * (m - y.y) > p * p) return;
                a.m_pointCount = 1, a.m_type = w.e_faceA, a.m_localPlaneNormal.x = l - y.x, a.m_localPlaneNormal.y = m - y.y, a.m_localPlaneNormal.Normalize(), a.m_localPoint.SetV(y), a.m_points[0].m_localPoint.SetV(d.m_p), a.m_points[0].m_id.key = 0
            } else if (0 >= B) {
                if ((l - z.x) * (l - z.x) + (m - z.y) * (m - z.y) > p * p) return;
                a.m_pointCount = 1, a.m_type = w.e_faceA, a.m_localPlaneNormal.x = l - z.x, a.m_localPlaneNormal.y = m - z.y, a.m_localPlaneNormal.Normalize(), a.m_localPoint.SetV(z), a.m_points[0].m_localPoint.SetV(d.m_p), a.m_points[0].m_id.key = 0
            } else {
                var C = .5 * (y.x + z.x),
                    D = .5 * (y.y + z.y);
                if (o = (l - C) * s[v].x + (m - D) * s[v].y, o > p) return;
                a.m_pointCount = 1, a.m_type = w.e_faceA, a.m_localPlaneNormal.x = s[v].x, a.m_localPlaneNormal.y = s[v].y, a.m_localPlaneNormal.Normalize(), a.m_localPoint.Set(C, D), a.m_points[0].m_localPoint.SetV(d.m_p), a.m_points[0].m_id.key = 0
            }
        }, l.TestOverlap = function(a, b) {
            var c = b.lowerBound,
                d = a.upperBound,
                e = c.x - d.x,
                f = c.y - d.y;
            c = a.lowerBound, d = b.upperBound;
            var g = c.x - d.x,
                h = c.y - d.y;
            return e > 0 || f > 0 ? !1 : g > 0 || h > 0 ? !1 : !0
        }, Box2D.postDefs.push(function() {
            Box2D.Collision.b2Collision.s_incidentEdge = l.MakeClipPointVector(), Box2D.Collision.b2Collision.s_clipPoints1 = l.MakeClipPointVector(), Box2D.Collision.b2Collision.s_clipPoints2 = l.MakeClipPointVector(), Box2D.Collision.b2Collision.s_edgeAO = new Vector_a2j_Number(1), Box2D.Collision.b2Collision.s_edgeBO = new Vector_a2j_Number(1), Box2D.Collision.b2Collision.s_localTangent = new h, Box2D.Collision.b2Collision.s_localNormal = new h, Box2D.Collision.b2Collision.s_planePoint = new h, Box2D.Collision.b2Collision.s_normal = new h, Box2D.Collision.b2Collision.s_tangent = new h, Box2D.Collision.b2Collision.s_tangent2 = new h, Box2D.Collision.b2Collision.s_v11 = new h, Box2D.Collision.b2Collision.s_v12 = new h, Box2D.Collision.b2Collision.b2CollidePolyTempVec = new h, Box2D.Collision.b2Collision.b2_nullFeature = 255
        }), m.b2ContactID = function() {
            this.features = new K
        }, m.prototype.b2ContactID = function() {
            this.features._m_id = this
        }, m.prototype.Set = function(a) {
            this.key = a._key
        }, m.prototype.Copy = function() {
            var a = new m;
            return a.key = this.key, a
        }, Object.defineProperty(m.prototype, "key", {
            enumerable: !1,
            configurable: !0,
            get: function() {
                return this._key
            }
        }), Object.defineProperty(m.prototype, "key", {
            enumerable: !1,
            configurable: !0,
            set: function(a) {
                void 0 === a && (a = 0), this._key = a, this.features._referenceEdge = 255 & this._key, this.features._incidentEdge = (65280 & this._key) >> 8 & 255, this.features._incidentVertex = (16711680 & this._key) >> 16 & 255, this.features._flip = (4278190080 & this._key) >> 24 & 255
            }
        }), n.b2ContactPoint = function() {
            this.position = new h, this.velocity = new h, this.normal = new h, this.id = new m
        }, o.b2Distance = function() {}, o.Distance = function(a, b, c) {
            ++o.b2_gjkCalls;
            var f = c.proxyA,
                g = c.proxyB,
                i = c.transformA,
                j = c.transformB,
                k = o.s_simplex;
            k.ReadCache(b, f, i, g, j);
            for (var l, m = k.m_vertices, n = 20, p = o.s_saveA, q = o.s_saveB, r = 0, s = k.GetClosestPoint(), t = s.LengthSquared(), u = t, v = 0, w = 0; n > w;) {
                for (r = k.m_count, v = 0; r > v; v++) p[v] = m[v].indexA, q[v] = m[v].indexB;
                switch (k.m_count) {
                    case 1:
                        break;
                    case 2:
                        k.Solve2();
                        break;
                    case 3:
                        k.Solve3();
                        break;
                    default:
                        d.b2Assert(!1)
                }
                if (3 == k.m_count) break;
                l = k.GetClosestPoint(), u = l.LengthSquared(), t = u;
                var x = k.GetSearchDirection();
                if (x.LengthSquared() < Number.MIN_VALUE * Number.MIN_VALUE) break;
                var y = m[k.m_count];
                y.indexA = f.GetSupport(e.MulTMV(i.R, x.GetNegative())), y.wA = e.MulX(i, f.GetVertex(y.indexA)), y.indexB = g.GetSupport(e.MulTMV(j.R, x)), y.wB = e.MulX(j, g.GetVertex(y.indexB)), y.w = e.SubtractVV(y.wB, y.wA), ++w, ++o.b2_gjkIters;
                var z = !1;
                for (v = 0; r > v; v++)
                    if (y.indexA == p[v] && y.indexB == q[v]) {
                        z = !0;
                        break
                    }
                if (z) break;
                ++k.m_count
            }
            if (o.b2_gjkMaxIters = e.Max(o.b2_gjkMaxIters, w), k.GetWitnessPoints(a.pointA, a.pointB), a.distance = e.SubtractVV(a.pointA, a.pointB).Length(), a.iterations = w, k.WriteCache(b), c.useRadii) {
                var A = f.m_radius,
                    B = g.m_radius;
                if (a.distance > A + B && a.distance > Number.MIN_VALUE) {
                    a.distance -= A + B;
                    var C = e.SubtractVV(a.pointB, a.pointA);
                    C.Normalize(), a.pointA.x += A * C.x, a.pointA.y += A * C.y, a.pointB.x -= B * C.x, a.pointB.y -= B * C.y
                } else l = new h, l.x = .5 * (a.pointA.x + a.pointB.x), l.y = .5 * (a.pointA.y + a.pointB.y), a.pointA.x = a.pointB.x = l.x, a.pointA.y = a.pointB.y = l.y, a.distance = 0
            }
        }, Box2D.postDefs.push(function() {
            Box2D.Collision.b2Distance.s_simplex = new D, Box2D.Collision.b2Distance.s_saveA = new Vector_a2j_Number(3), Box2D.Collision.b2Distance.s_saveB = new Vector_a2j_Number(3)
        }), p.b2DistanceInput = function() {}, q.b2DistanceOutput = function() {
            this.pointA = new h, this.pointB = new h
        }, r.b2DistanceProxy = function() {}, r.prototype.Set = function(e) {
            switch (e.GetType()) {
                case c.e_circleShape:
                    var f = e instanceof a ? e : null;
                    this.m_vertices = new Vector(1, !0), this.m_vertices[0] = f.m_p, this.m_count = 1, this.m_radius = f.m_radius;
                    break;
                case c.e_polygonShape:
                    var g = e instanceof b ? e : null;
                    this.m_vertices = g.m_vertices, this.m_count = g.m_vertexCount, this.m_radius = g.m_radius;
                    break;
                default:
                    d.b2Assert(!1)
            }
        }, r.prototype.GetSupport = function(a) {
            for (var b = 0, c = this.m_vertices[0].x * a.x + this.m_vertices[0].y * a.y, d = 1; d < this.m_count; ++d) {
                var e = this.m_vertices[d].x * a.x + this.m_vertices[d].y * a.y;
                e > c && (b = d, c = e)
            }
            return b
        }, r.prototype.GetSupportVertex = function(a) {
            for (var b = 0, c = this.m_vertices[0].x * a.x + this.m_vertices[0].y * a.y, d = 1; d < this.m_count; ++d) {
                var e = this.m_vertices[d].x * a.x + this.m_vertices[d].y * a.y;
                e > c && (b = d, c = e)
            }
            return this.m_vertices[b]
        }, r.prototype.GetVertexCount = function() {
            return this.m_count
        }, r.prototype.GetVertex = function(a) {
            return void 0 === a && (a = 0), d.b2Assert(a >= 0 && a < this.m_count), this.m_vertices[a]
        }, s.b2DynamicTree = function() {}, s.prototype.b2DynamicTree = function() {
            this.m_root = null, this.m_freeList = null, this.m_path = 0, this.m_insertionCount = 0
        }, s.prototype.CreateProxy = function(a, b) {
            var c = this.AllocateNode(),
                e = d.b2_aabbExtension,
                f = d.b2_aabbExtension;
            return c.aabb.lowerBound.x = a.lowerBound.x - e, c.aabb.lowerBound.y = a.lowerBound.y - f, c.aabb.upperBound.x = a.upperBound.x + e, c.aabb.upperBound.y = a.upperBound.y + f, c.userData = b, this.InsertLeaf(c), c
        }, s.prototype.DestroyProxy = function(a) {
            this.RemoveLeaf(a), this.FreeNode(a)
        }, s.prototype.MoveProxy = function(a, b, c) {
            if (d.b2Assert(a.IsLeaf()), a.aabb.Contains(b)) return !1;
            this.RemoveLeaf(a);
            var e = d.b2_aabbExtension + d.b2_aabbMultiplier * (c.x > 0 ? c.x : -c.x),
                f = d.b2_aabbExtension + d.b2_aabbMultiplier * (c.y > 0 ? c.y : -c.y);
            return a.aabb.lowerBound.x = b.lowerBound.x - e, a.aabb.lowerBound.y = b.lowerBound.y - f, a.aabb.upperBound.x = b.upperBound.x + e, a.aabb.upperBound.y = b.upperBound.y + f, this.InsertLeaf(a), !0
        }, s.prototype.Rebalance = function(a) {
            if (void 0 === a && (a = 0), null != this.m_root)
                for (var b = 0; a > b; b++) {
                    for (var c = this.m_root, d = 0; 0 == c.IsLeaf();) c = this.m_path >> d & 1 ? c.child2 : c.child1, d = d + 1 & 31;
                    ++this.m_path, this.RemoveLeaf(c), this.InsertLeaf(c)
                }
        }, s.prototype.GetFatAABB = function(a) {
            return a.aabb
        }, s.prototype.GetUserData = function(a) {
            return a.userData
        }, s.prototype.Query = function(a, b) {
            if (null != this.m_root) {
                var c = new Vector,
                    d = 0;
                for (c[d++] = this.m_root; d > 0;) {
                    var e = c[--d];
                    if (e.aabb.TestOverlap(b))
                        if (e.IsLeaf()) {
                            var f = a(e);
                            if (!f) return
                        } else c[d++] = e.child1, c[d++] = e.child2
                }
            }
        }, s.prototype.RayCast = function(a, b) {
            if (null != this.m_root) {
                var c = b.p1,
                    d = b.p2,
                    f = e.SubtractVV(c, d);
                f.Normalize();
                var g = e.CrossFV(1, f),
                    h = e.AbsV(g),
                    j = b.maxFraction,
                    k = new i,
                    l = 0,
                    m = 0;
                l = c.x + j * (d.x - c.x), m = c.y + j * (d.y - c.y), k.lowerBound.x = Math.min(c.x, l), k.lowerBound.y = Math.min(c.y, m), k.upperBound.x = Math.max(c.x, l), k.upperBound.y = Math.max(c.y, m);
                var n = new Vector,
                    o = 0;
                for (n[o++] = this.m_root; o > 0;) {
                    var p = n[--o];
                    if (0 != p.aabb.TestOverlap(k)) {
                        var q = p.aabb.GetCenter(),
                            r = p.aabb.GetExtents(),
                            s = Math.abs(g.x * (c.x - q.x) + g.y * (c.y - q.y)) - h.x * r.x - h.y * r.y;
                        if (!(s > 0))
                            if (p.IsLeaf()) {
                                var t = new z;
                                if (t.p1 = b.p1, t.p2 = b.p2, t.maxFraction = b.maxFraction, j = a(t, p), 0 == j) return;
                                j > 0 && (l = c.x + j * (d.x - c.x), m = c.y + j * (d.y - c.y), k.lowerBound.x = Math.min(c.x, l), k.lowerBound.y = Math.min(c.y, m), k.upperBound.x = Math.max(c.x, l), k.upperBound.y = Math.max(c.y, m))
                            } else n[o++] = p.child1, n[o++] = p.child2
                    }
                }
            }
        }, s.prototype.AllocateNode = function() {
            if (this.m_freeList) {
                var a = this.m_freeList;
                return this.m_freeList = a.parent, a.parent = null, a.child1 = null, a.child2 = null, a
            }
            return new u
        }, s.prototype.FreeNode = function(a) {
            a.parent = this.m_freeList, this.m_freeList = a
        }, s.prototype.InsertLeaf = function(a) {
            if (++this.m_insertionCount, null == this.m_root) return this.m_root = a, void(this.m_root.parent = null);
            var b = a.aabb.GetCenter(),
                c = this.m_root;
            if (0 == c.IsLeaf())
                do {
                    var d = c.child1,
                        e = c.child2,
                        f = Math.abs((d.aabb.lowerBound.x + d.aabb.upperBound.x) / 2 - b.x) + Math.abs((d.aabb.lowerBound.y + d.aabb.upperBound.y) / 2 - b.y),
                        g = Math.abs((e.aabb.lowerBound.x + e.aabb.upperBound.x) / 2 - b.x) + Math.abs((e.aabb.lowerBound.y + e.aabb.upperBound.y) / 2 - b.y);
                    c = g > f ? d : e
                } while (0 == c.IsLeaf());
            var h = c.parent,
                i = this.AllocateNode();
            if (i.parent = h, i.userData = null, i.aabb.Combine(a.aabb, c.aabb), h) {
                c.parent.child1 == c ? h.child1 = i : h.child2 = i, i.child1 = c, i.child2 = a, c.parent = i, a.parent = i;
                do {
                    if (h.aabb.Contains(i.aabb)) break;
                    h.aabb.Combine(h.child1.aabb, h.child2.aabb), i = h, h = h.parent
                } while (h)
            } else i.child1 = c, i.child2 = a, c.parent = i, a.parent = i, this.m_root = i
        }, s.prototype.RemoveLeaf = function(a) {
            if (a == this.m_root) return void(this.m_root = null);
            var b, c = a.parent,
                d = c.parent;
            if (b = c.child1 == a ? c.child2 : c.child1, d)
                for (d.child1 == c ? d.child1 = b : d.child2 = b, b.parent = d, this.FreeNode(c); d;) {
                    var e = d.aabb;
                    if (d.aabb = i.Combine(d.child1.aabb, d.child2.aabb), e.Contains(d.aabb)) break;
                    d = d.parent
                } else this.m_root = b, b.parent = null, this.FreeNode(c)
        }, t.b2DynamicTreeBroadPhase = function() {
            this.m_tree = new s, this.m_moveBuffer = new Vector, this.m_pairBuffer = new Vector, this.m_pairCount = 0
        }, t.prototype.CreateProxy = function(a, b) {
            var c = this.m_tree.CreateProxy(a, b);
            return ++this.m_proxyCount, this.BufferMove(c), c
        }, t.prototype.DestroyProxy = function(a) {
            this.UnBufferMove(a), --this.m_proxyCount, this.m_tree.DestroyProxy(a)
        }, t.prototype.MoveProxy = function(a, b, c) {
            var d = this.m_tree.MoveProxy(a, b, c);
            d && this.BufferMove(a)
        }, t.prototype.TestOverlap = function(a, b) {
            var c = this.m_tree.GetFatAABB(a),
                d = this.m_tree.GetFatAABB(b);
            return c.TestOverlap(d)
        }, t.prototype.GetUserData = function(a) {
            return this.m_tree.GetUserData(a)
        }, t.prototype.GetFatAABB = function(a) {
            return this.m_tree.GetFatAABB(a)
        }, t.prototype.GetProxyCount = function() {
            return this.m_proxyCount
        }, t.prototype.UpdatePairs = function(a) {
            function b(a) {
                if (a == d) return !0;
                c.m_pairCount == c.m_pairBuffer.length && (c.m_pairBuffer[c.m_pairCount] = new v);
                var b = c.m_pairBuffer[c.m_pairCount];
                return b.proxyA = d > a ? a : d, b.proxyB = a >= d ? a : d, ++c.m_pairCount, !0
            }
            var c = this;
            c.m_pairCount = 0;
            var d, e = 0;
            for (e = 0; e < c.m_moveBuffer.length; ++e) {
                d = c.m_moveBuffer[e];
                var f = c.m_tree.GetFatAABB(d);
                c.m_tree.Query(b, f)
            }
            c.m_moveBuffer.length = 0;
            for (var e = 0; e < c.m_pairCount;) {
                var g = c.m_pairBuffer[e],
                    h = c.m_tree.GetUserData(g.proxyA),
                    i = c.m_tree.GetUserData(g.proxyB);
                for (a(h, i), ++e; e < c.m_pairCount;) {
                    var j = c.m_pairBuffer[e];
                    if (j.proxyA != g.proxyA || j.proxyB != g.proxyB) break;
                    ++e
                }
            }
        }, t.prototype.Query = function(a, b) {
            this.m_tree.Query(a, b)
        }, t.prototype.RayCast = function(a, b) {
            this.m_tree.RayCast(a, b)
        }, t.prototype.Validate = function() {}, t.prototype.Rebalance = function(a) {
            void 0 === a && (a = 0), this.m_tree.Rebalance(a)
        }, t.prototype.BufferMove = function(a) {
            this.m_moveBuffer[this.m_moveBuffer.length] = a
        }, t.prototype.UnBufferMove = function(a) {
            var b = parseInt(this.m_moveBuffer.indexOf(a));
            this.m_moveBuffer.splice(b, 1)
        }, t.prototype.ComparePairs = function() {
            return 0
        }, t.__implements = {}, t.__implements[L] = !0, u.b2DynamicTreeNode = function() {
            this.aabb = new i
        }, u.prototype.IsLeaf = function() {
            return null == this.child1
        }, v.b2DynamicTreePair = function() {}, w.b2Manifold = function() {
            this.m_pointCount = 0
        }, w.prototype.b2Manifold = function() {
            this.m_points = new Vector(d.b2_maxManifoldPoints);
            for (var a = 0; a < d.b2_maxManifoldPoints; a++) this.m_points[a] = new x;
            this.m_localPlaneNormal = new h, this.m_localPoint = new h
        }, w.prototype.Reset = function() {
            for (var a = 0; a < d.b2_maxManifoldPoints; a++)(this.m_points[a] instanceof x ? this.m_points[a] : null).Reset();
            this.m_localPlaneNormal.SetZero(), this.m_localPoint.SetZero(), this.m_type = 0, this.m_pointCount = 0
        }, w.prototype.Set = function(a) {
            this.m_pointCount = a.m_pointCount;
            for (var b = 0; b < d.b2_maxManifoldPoints; b++)(this.m_points[b] instanceof x ? this.m_points[b] : null).Set(a.m_points[b]);
            this.m_localPlaneNormal.SetV(a.m_localPlaneNormal), this.m_localPoint.SetV(a.m_localPoint), this.m_type = a.m_type
        }, w.prototype.Copy = function() {
            var a = new w;
            return a.Set(this), a
        }, Box2D.postDefs.push(function() {
            Box2D.Collision.b2Manifold.e_circles = 1, Box2D.Collision.b2Manifold.e_faceA = 2, Box2D.Collision.b2Manifold.e_faceB = 4
        }), x.b2ManifoldPoint = function() {
            this.m_localPoint = new h, this.m_id = new m
        }, x.prototype.b2ManifoldPoint = function() {
            this.Reset()
        }, x.prototype.Reset = function() {
            this.m_localPoint.SetZero(), this.m_normalImpulse = 0, this.m_tangentImpulse = 0, this.m_id.key = 0
        }, x.prototype.Set = function(a) {
            this.m_localPoint.SetV(a.m_localPoint), this.m_normalImpulse = a.m_normalImpulse, this.m_tangentImpulse = a.m_tangentImpulse, this.m_id.Set(a.m_id)
        }, y.b2Point = function() {
            this.p = new h
        }, y.prototype.Support = function(a, b, c) {
            return void 0 === b && (b = 0), void 0 === c && (c = 0), this.p
        }, y.prototype.GetFirstVertex = function() {
            return this.p
        }, z.b2RayCastInput = function() {
            this.p1 = new h, this.p2 = new h
        }, z.prototype.b2RayCastInput = function(a, b, c) {
            void 0 === a && (a = null), void 0 === b && (b = null), void 0 === c && (c = 1), a && this.p1.SetV(a), b && this.p2.SetV(b), this.maxFraction = c
        }, A.b2RayCastOutput = function() {
            this.normal = new h
        }, B.b2Segment = function() {
            this.p1 = new h, this.p2 = new h
        }, B.prototype.TestSegment = function(a, b, c, d) {
            void 0 === d && (d = 0);
            var e = c.p1,
                f = c.p2.x - e.x,
                g = c.p2.y - e.y,
                h = this.p2.x - this.p1.x,
                i = this.p2.y - this.p1.y,
                j = i,
                k = -h,
                l = 100 * Number.MIN_VALUE,
                m = -(f * j + g * k);
            if (m > l) {
                var n = e.x - this.p1.x,
                    o = e.y - this.p1.y,
                    p = n * j + o * k;
                if (p >= 0 && d * m >= p) {
                    var q = -f * o + g * n;
                    if (q >= -l * m && m * (1 + l) >= q) {
                        p /= m;
                        var r = Math.sqrt(j * j + k * k);
                        return j /= r, k /= r, a[0] = p, b.Set(j, k), !0
                    }
                }
            }
            return !1
        }, B.prototype.Extend = function(a) {
            this.ExtendForward(a), this.ExtendBackward(a)
        }, B.prototype.ExtendForward = function(a) {
            var b = this.p2.x - this.p1.x,
                c = this.p2.y - this.p1.y,
                d = Math.min(b > 0 ? (a.upperBound.x - this.p1.x) / b : 0 > b ? (a.lowerBound.x - this.p1.x) / b : Number.POSITIVE_INFINITY, c > 0 ? (a.upperBound.y - this.p1.y) / c : 0 > c ? (a.lowerBound.y - this.p1.y) / c : Number.POSITIVE_INFINITY);
            this.p2.x = this.p1.x + b * d, this.p2.y = this.p1.y + c * d
        }, B.prototype.ExtendBackward = function(a) {
            var b = -this.p2.x + this.p1.x,
                c = -this.p2.y + this.p1.y,
                d = Math.min(b > 0 ? (a.upperBound.x - this.p2.x) / b : 0 > b ? (a.lowerBound.x - this.p2.x) / b : Number.POSITIVE_INFINITY, c > 0 ? (a.upperBound.y - this.p2.y) / c : 0 > c ? (a.lowerBound.y - this.p2.y) / c : Number.POSITIVE_INFINITY);
            this.p1.x = this.p2.x + b * d, this.p1.y = this.p2.y + c * d
        }, C.b2SeparationFunction = function() {
            this.m_localPoint = new h, this.m_axis = new h
        }, C.prototype.Initialize = function(a, b, c, f, g) {
            this.m_proxyA = b, this.m_proxyB = f;
            var i = parseInt(a.count);
            d.b2Assert(i > 0 && 3 > i);
            var j, k, l, m, n, o, p, q, r = 0,
                s = 0,
                t = 0,
                u = 0,
                v = 0,
                w = 0,
                x = 0,
                y = 0;
            if (1 == i) this.m_type = C.e_points, j = this.m_proxyA.GetVertex(a.indexA[0]), m = this.m_proxyB.GetVertex(a.indexB[0]), q = j, p = c.R, r = c.position.x + (p.col1.x * q.x + p.col2.x * q.y), s = c.position.y + (p.col1.y * q.x + p.col2.y * q.y), q = m, p = g.R, t = g.position.x + (p.col1.x * q.x + p.col2.x * q.y), u = g.position.y + (p.col1.y * q.x + p.col2.y * q.y), this.m_axis.x = t - r, this.m_axis.y = u - s, this.m_axis.Normalize();
            else if (a.indexB[0] == a.indexB[1]) this.m_type = C.e_faceA, k = this.m_proxyA.GetVertex(a.indexA[0]), l = this.m_proxyA.GetVertex(a.indexA[1]), m = this.m_proxyB.GetVertex(a.indexB[0]), this.m_localPoint.x = .5 * (k.x + l.x), this.m_localPoint.y = .5 * (k.y + l.y), this.m_axis = e.CrossVF(e.SubtractVV(l, k), 1), this.m_axis.Normalize(), q = this.m_axis, p = c.R, v = p.col1.x * q.x + p.col2.x * q.y, w = p.col1.y * q.x + p.col2.y * q.y, q = this.m_localPoint, p = c.R, r = c.position.x + (p.col1.x * q.x + p.col2.x * q.y), s = c.position.y + (p.col1.y * q.x + p.col2.y * q.y), q = m, p = g.R, t = g.position.x + (p.col1.x * q.x + p.col2.x * q.y), u = g.position.y + (p.col1.y * q.x + p.col2.y * q.y), x = (t - r) * v + (u - s) * w, 0 > x && this.m_axis.NegativeSelf();
            else if (a.indexA[0] == a.indexA[0]) this.m_type = C.e_faceB, n = this.m_proxyB.GetVertex(a.indexB[0]), o = this.m_proxyB.GetVertex(a.indexB[1]), j = this.m_proxyA.GetVertex(a.indexA[0]), this.m_localPoint.x = .5 * (n.x + o.x), this.m_localPoint.y = .5 * (n.y + o.y), this.m_axis = e.CrossVF(e.SubtractVV(o, n), 1), this.m_axis.Normalize(), q = this.m_axis, p = g.R, v = p.col1.x * q.x + p.col2.x * q.y, w = p.col1.y * q.x + p.col2.y * q.y, q = this.m_localPoint, p = g.R, t = g.position.x + (p.col1.x * q.x + p.col2.x * q.y), u = g.position.y + (p.col1.y * q.x + p.col2.y * q.y), q = j, p = c.R, r = c.position.x + (p.col1.x * q.x + p.col2.x * q.y), s = c.position.y + (p.col1.y * q.x + p.col2.y * q.y), x = (r - t) * v + (s - u) * w, 0 > x && this.m_axis.NegativeSelf();
            else {
                k = this.m_proxyA.GetVertex(a.indexA[0]), l = this.m_proxyA.GetVertex(a.indexA[1]), n = this.m_proxyB.GetVertex(a.indexB[0]), o = this.m_proxyB.GetVertex(a.indexB[1]);
                var z = (e.MulX(c, j), e.MulMV(c.R, e.SubtractVV(l, k))),
                    A = (e.MulX(g, m), e.MulMV(g.R, e.SubtractVV(o, n))),
                    B = z.x * z.x + z.y * z.y,
                    D = A.x * A.x + A.y * A.y,
                    E = e.SubtractVV(A, z),
                    F = z.x * E.x + z.y * E.y,
                    G = A.x * E.x + A.y * E.y,
                    H = z.x * A.x + z.y * A.y,
                    I = B * D - H * H;
                x = 0, 0 != I && (x = e.Clamp((H * G - F * D) / I, 0, 1));
                var J = (H * x + G) / D;
                0 > J && (J = 0, x = e.Clamp((H - F) / B, 0, 1)), j = new h, j.x = k.x + x * (l.x - k.x), j.y = k.y + x * (l.y - k.y), m = new h, m.x = n.x + x * (o.x - n.x), m.y = n.y + x * (o.y - n.y), 0 == x || 1 == x ? (this.m_type = C.e_faceB, this.m_axis = e.CrossVF(e.SubtractVV(o, n), 1), this.m_axis.Normalize(), this.m_localPoint = m, q = this.m_axis, p = g.R, v = p.col1.x * q.x + p.col2.x * q.y, w = p.col1.y * q.x + p.col2.y * q.y, q = this.m_localPoint, p = g.R, t = g.position.x + (p.col1.x * q.x + p.col2.x * q.y), u = g.position.y + (p.col1.y * q.x + p.col2.y * q.y), q = j, p = c.R, r = c.position.x + (p.col1.x * q.x + p.col2.x * q.y), s = c.position.y + (p.col1.y * q.x + p.col2.y * q.y), y = (r - t) * v + (s - u) * w, 0 > x && this.m_axis.NegativeSelf()) : (this.m_type = C.e_faceA, this.m_axis = e.CrossVF(e.SubtractVV(l, k), 1), this.m_localPoint = j, q = this.m_axis, p = c.R, v = p.col1.x * q.x + p.col2.x * q.y, w = p.col1.y * q.x + p.col2.y * q.y, q = this.m_localPoint, p = c.R, r = c.position.x + (p.col1.x * q.x + p.col2.x * q.y), s = c.position.y + (p.col1.y * q.x + p.col2.y * q.y), q = m, p = g.R, t = g.position.x + (p.col1.x * q.x + p.col2.x * q.y), u = g.position.y + (p.col1.y * q.x + p.col2.y * q.y), y = (t - r) * v + (u - s) * w, 0 > x && this.m_axis.NegativeSelf())
            }
        }, C.prototype.Evaluate = function(a, b) {
            var c, f, g, h, i, j, k, l = 0;
            switch (this.m_type) {
                case C.e_points:
                    return c = e.MulTMV(a.R, this.m_axis), f = e.MulTMV(b.R, this.m_axis.GetNegative()), g = this.m_proxyA.GetSupportVertex(c), h = this.m_proxyB.GetSupportVertex(f), i = e.MulX(a, g), j = e.MulX(b, h), l = (j.x - i.x) * this.m_axis.x + (j.y - i.y) * this.m_axis.y;
                case C.e_faceA:
                    return k = e.MulMV(a.R, this.m_axis), i = e.MulX(a, this.m_localPoint), f = e.MulTMV(b.R, k.GetNegative()), h = this.m_proxyB.GetSupportVertex(f), j = e.MulX(b, h), l = (j.x - i.x) * k.x + (j.y - i.y) * k.y;
                case C.e_faceB:
                    return k = e.MulMV(b.R, this.m_axis), j = e.MulX(b, this.m_localPoint), c = e.MulTMV(a.R, k.GetNegative()), g = this.m_proxyA.GetSupportVertex(c), i = e.MulX(a, g), l = (i.x - j.x) * k.x + (i.y - j.y) * k.y;
                default:
                    return d.b2Assert(!1), 0
            }
        }, Box2D.postDefs.push(function() {
            Box2D.Collision.b2SeparationFunction.e_points = 1, Box2D.Collision.b2SeparationFunction.e_faceA = 2, Box2D.Collision.b2SeparationFunction.e_faceB = 4
        }), D.b2Simplex = function() {
            this.m_v1 = new F, this.m_v2 = new F, this.m_v3 = new F, this.m_vertices = new Vector(3)
        }, D.prototype.b2Simplex = function() {
            this.m_vertices[0] = this.m_v1, this.m_vertices[1] = this.m_v2, this.m_vertices[2] = this.m_v3
        }, D.prototype.ReadCache = function(a, b, c, f, g) {
            d.b2Assert(0 <= a.count && a.count <= 3);
            var h, i;
            this.m_count = a.count;
            for (var j = this.m_vertices, k = 0; k < this.m_count; k++) {
                var l = j[k];
                l.indexA = a.indexA[k], l.indexB = a.indexB[k], h = b.GetVertex(l.indexA), i = f.GetVertex(l.indexB), l.wA = e.MulX(c, h), l.wB = e.MulX(g, i), l.w = e.SubtractVV(l.wB, l.wA), l.a = 0
            }
            if (this.m_count > 1) {
                var m = a.metric,
                    n = this.GetMetric();
                (.5 * m > n || n > 2 * m || n < Number.MIN_VALUE) && (this.m_count = 0)
            }
            0 == this.m_count && (l = j[0], l.indexA = 0, l.indexB = 0, h = b.GetVertex(0), i = f.GetVertex(0), l.wA = e.MulX(c, h), l.wB = e.MulX(g, i), l.w = e.SubtractVV(l.wB, l.wA), this.m_count = 1)
        }, D.prototype.WriteCache = function(a) {
            a.metric = this.GetMetric(), a.count = Box2D.parseUInt(this.m_count);
            for (var b = this.m_vertices, c = 0; c < this.m_count; c++) a.indexA[c] = Box2D.parseUInt(b[c].indexA), a.indexB[c] = Box2D.parseUInt(b[c].indexB)
        }, D.prototype.GetSearchDirection = function() {
            switch (this.m_count) {
                case 1:
                    return this.m_v1.w.GetNegative();
                case 2:
                    var a = e.SubtractVV(this.m_v2.w, this.m_v1.w),
                        b = e.CrossVV(a, this.m_v1.w.GetNegative());
                    return b > 0 ? e.CrossFV(1, a) : e.CrossVF(a, 1);
                default:
                    return d.b2Assert(!1), new h
            }
        }, D.prototype.GetClosestPoint = function() {
            switch (this.m_count) {
                case 0:
                    return d.b2Assert(!1), new h;
                case 1:
                    return this.m_v1.w;
                case 2:
                    return new h(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);
                default:
                    return d.b2Assert(!1), new h
            }
        }, D.prototype.GetWitnessPoints = function(a, b) {
            switch (this.m_count) {
                case 0:
                    d.b2Assert(!1);
                    break;
                case 1:
                    a.SetV(this.m_v1.wA), b.SetV(this.m_v1.wB);
                    break;
                case 2:
                    a.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x, a.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y, b.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x, b.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;
                    break;
                case 3:
                    b.x = a.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x, b.y = a.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;
                    break;
                default:
                    d.b2Assert(!1)
            }
        }, D.prototype.GetMetric = function() {
            switch (this.m_count) {
                case 0:
                    return d.b2Assert(!1), 0;
                case 1:
                    return 0;
                case 2:
                    return e.SubtractVV(this.m_v1.w, this.m_v2.w).Length();
                case 3:
                    return e.CrossVV(e.SubtractVV(this.m_v2.w, this.m_v1.w), e.SubtractVV(this.m_v3.w, this.m_v1.w));
                default:
                    return d.b2Assert(!1), 0
            }
        }, D.prototype.Solve2 = function() {
            var a = this.m_v1.w,
                b = this.m_v2.w,
                c = e.SubtractVV(b, a),
                d = -(a.x * c.x + a.y * c.y);
            if (0 >= d) return this.m_v1.a = 1, void(this.m_count = 1);
            var f = b.x * c.x + b.y * c.y;
            if (0 >= f) return this.m_v2.a = 1, this.m_count = 1, void this.m_v1.Set(this.m_v2);
            var g = 1 / (f + d);
            this.m_v1.a = f * g, this.m_v2.a = d * g, this.m_count = 2
        }, D.prototype.Solve3 = function() {
            var a = this.m_v1.w,
                b = this.m_v2.w,
                c = this.m_v3.w,
                d = e.SubtractVV(b, a),
                f = e.Dot(a, d),
                g = e.Dot(b, d),
                h = g,
                i = -f,
                j = e.SubtractVV(c, a),
                k = e.Dot(a, j),
                l = e.Dot(c, j),
                m = l,
                n = -k,
                o = e.SubtractVV(c, b),
                p = e.Dot(b, o),
                q = e.Dot(c, o),
                r = q,
                s = -p,
                t = e.CrossVV(d, j),
                u = t * e.CrossVV(b, c),
                v = t * e.CrossVV(c, a),
                w = t * e.CrossVV(a, b);
            if (0 >= i && 0 >= n) return this.m_v1.a = 1, void(this.m_count = 1);
            if (h > 0 && i > 0 && 0 >= w) {
                var x = 1 / (h + i);
                return this.m_v1.a = h * x, this.m_v2.a = i * x, void(this.m_count = 2)
            }
            if (m > 0 && n > 0 && 0 >= v) {
                var y = 1 / (m + n);
                return this.m_v1.a = m * y, this.m_v3.a = n * y, this.m_count = 2, void this.m_v2.Set(this.m_v3)
            }
            if (0 >= h && 0 >= s) return this.m_v2.a = 1, this.m_count = 1, void this.m_v1.Set(this.m_v2);
            if (0 >= m && 0 >= r) return this.m_v3.a = 1, this.m_count = 1, void this.m_v1.Set(this.m_v3);
            if (r > 0 && s > 0 && 0 >= u) {
                var z = 1 / (r + s);
                return this.m_v2.a = r * z, this.m_v3.a = s * z, this.m_count = 2, void this.m_v1.Set(this.m_v3)
            }
            var A = 1 / (u + v + w);
            this.m_v1.a = u * A, this.m_v2.a = v * A, this.m_v3.a = w * A, this.m_count = 3
        }, E.b2SimplexCache = function() {
            this.indexA = new Vector_a2j_Number(3), this.indexB = new Vector_a2j_Number(3)
        }, F.b2SimplexVertex = function() {}, F.prototype.Set = function(a) {
            this.wA.SetV(a.wA), this.wB.SetV(a.wB), this.w.SetV(a.w), this.a = a.a, this.indexA = a.indexA, this.indexB = a.indexB
        }, G.b2TimeOfImpact = function() {}, G.TimeOfImpact = function(a) {
            ++G.b2_toiCalls;
            var b = a.proxyA,
                c = a.proxyB,
                f = a.sweepA,
                g = a.sweepB;
            d.b2Assert(f.t0 == g.t0), d.b2Assert(1 - f.t0 > Number.MIN_VALUE);
            var h = b.m_radius + c.m_radius,
                i = a.tolerance,
                j = 0,
                k = 1e3,
                l = 0,
                m = 0;
            for (G.s_cache.count = 0, G.s_distanceInput.useRadii = !1;;) {
                if (f.GetTransform(G.s_xfA, j), g.GetTransform(G.s_xfB, j), G.s_distanceInput.proxyA = b, G.s_distanceInput.proxyB = c, G.s_distanceInput.transformA = G.s_xfA, G.s_distanceInput.transformB = G.s_xfB, o.Distance(G.s_distanceOutput, G.s_cache, G.s_distanceInput), G.s_distanceOutput.distance <= 0) {
                    j = 1;
                    break
                }
                G.s_fcn.Initialize(G.s_cache, b, G.s_xfA, c, G.s_xfB);
                var n = G.s_fcn.Evaluate(G.s_xfA, G.s_xfB);
                if (0 >= n) {
                    j = 1;
                    break
                }
                if (0 == l && (m = n > h ? e.Max(h - i, .75 * h) : e.Max(n - i, .02 * h)), .5 * i > n - m) {
                    if (0 == l) {
                        j = 1;
                        break
                    }
                    break
                }
                var p = j,
                    q = j,
                    r = 1,
                    s = n;
                f.GetTransform(G.s_xfA, r), g.GetTransform(G.s_xfB, r);
                var t = G.s_fcn.Evaluate(G.s_xfA, G.s_xfB);
                if (t >= m) {
                    j = 1;
                    break
                }
                for (var u = 0;;) {
                    var v = 0;
                    v = 1 & u ? q + (m - s) * (r - q) / (t - s) : .5 * (q + r), f.GetTransform(G.s_xfA, v), g.GetTransform(G.s_xfB, v);
                    var w = G.s_fcn.Evaluate(G.s_xfA, G.s_xfB);
                    if (e.Abs(w - m) < .025 * i) {
                        p = v;
                        break
                    }
                    if (w > m ? (q = v, s = w) : (r = v, t = w), ++u, ++G.b2_toiRootIters, 50 == u) break
                }
                if (G.b2_toiMaxRootIters = e.Max(G.b2_toiMaxRootIters, u), p < (1 + 100 * Number.MIN_VALUE) * j) break;
                if (j = p, l++, ++G.b2_toiIters, l == k) break
            }
            return G.b2_toiMaxIters = e.Max(G.b2_toiMaxIters, l), j
        }, Box2D.postDefs.push(function() {
            Box2D.Collision.b2TimeOfImpact.b2_toiCalls = 0, Box2D.Collision.b2TimeOfImpact.b2_toiIters = 0, Box2D.Collision.b2TimeOfImpact.b2_toiMaxIters = 0, Box2D.Collision.b2TimeOfImpact.b2_toiRootIters = 0, Box2D.Collision.b2TimeOfImpact.b2_toiMaxRootIters = 0, Box2D.Collision.b2TimeOfImpact.s_cache = new E, Box2D.Collision.b2TimeOfImpact.s_distanceInput = new p, Box2D.Collision.b2TimeOfImpact.s_xfA = new g, Box2D.Collision.b2TimeOfImpact.s_xfB = new g, Box2D.Collision.b2TimeOfImpact.s_fcn = new C, Box2D.Collision.b2TimeOfImpact.s_distanceOutput = new q
        }), H.b2TOIInput = function() {
            this.proxyA = new r, this.proxyB = new r, this.sweepA = new f, this.sweepB = new f
        }, I.b2WorldManifold = function() {
            this.m_normal = new h
        }, I.prototype.b2WorldManifold = function() {
            this.m_points = new Vector(d.b2_maxManifoldPoints);
            for (var a = 0; a < d.b2_maxManifoldPoints; a++) this.m_points[a] = new h
        }, I.prototype.Initialize = function(a, b, c, d, e) {
            if (void 0 === c && (c = 0), void 0 === e && (e = 0), 0 != a.m_pointCount) {
                var f, g, h = 0,
                    i = 0,
                    j = 0,
                    k = 0,
                    l = 0,
                    m = 0,
                    n = 0;
                switch (a.m_type) {
                    case w.e_circles:
                        g = b.R, f = a.m_localPoint;
                        var o = b.position.x + g.col1.x * f.x + g.col2.x * f.y,
                            p = b.position.y + g.col1.y * f.x + g.col2.y * f.y;
                        g = d.R, f = a.m_points[0].m_localPoint;
                        var q = d.position.x + g.col1.x * f.x + g.col2.x * f.y,
                            r = d.position.y + g.col1.y * f.x + g.col2.y * f.y,
                            s = q - o,
                            t = r - p,
                            u = s * s + t * t;
                        if (u > Number.MIN_VALUE * Number.MIN_VALUE) {
                            var v = Math.sqrt(u);
                            this.m_normal.x = s / v, this.m_normal.y = t / v
                        } else this.m_normal.x = 1, this.m_normal.y = 0;
                        var x = o + c * this.m_normal.x,
                            y = p + c * this.m_normal.y,
                            z = q - e * this.m_normal.x,
                            A = r - e * this.m_normal.y;
                        this.m_points[0].x = .5 * (x + z), this.m_points[0].y = .5 * (y + A);
                        break;
                    case w.e_faceA:
                        for (g = b.R, f = a.m_localPlaneNormal, i = g.col1.x * f.x + g.col2.x * f.y, j = g.col1.y * f.x + g.col2.y * f.y, g = b.R, f = a.m_localPoint, k = b.position.x + g.col1.x * f.x + g.col2.x * f.y, l = b.position.y + g.col1.y * f.x + g.col2.y * f.y, this.m_normal.x = i, this.m_normal.y = j, h = 0; h < a.m_pointCount; h++) g = d.R, f = a.m_points[h].m_localPoint, m = d.position.x + g.col1.x * f.x + g.col2.x * f.y, n = d.position.y + g.col1.y * f.x + g.col2.y * f.y, this.m_points[h].x = m + .5 * (c - (m - k) * i - (n - l) * j - e) * i, this.m_points[h].y = n + .5 * (c - (m - k) * i - (n - l) * j - e) * j;
                        break;
                    case w.e_faceB:
                        for (g = d.R, f = a.m_localPlaneNormal, i = g.col1.x * f.x + g.col2.x * f.y, j = g.col1.y * f.x + g.col2.y * f.y, g = d.R, f = a.m_localPoint, k = d.position.x + g.col1.x * f.x + g.col2.x * f.y, l = d.position.y + g.col1.y * f.x + g.col2.y * f.y, this.m_normal.x = -i, this.m_normal.y = -j, h = 0; h < a.m_pointCount; h++) g = b.R, f = a.m_points[h].m_localPoint, m = b.position.x + g.col1.x * f.x + g.col2.x * f.y, n = b.position.y + g.col1.y * f.x + g.col2.y * f.y, this.m_points[h].x = m + .5 * (e - (m - k) * i - (n - l) * j - c) * i, this.m_points[h].y = n + .5 * (e - (m - k) * i - (n - l) * j - c) * j
                }
            }
        }, J.ClipVertex = function() {
            this.v = new h, this.id = new m
        }, J.prototype.Set = function(a) {
            this.v.SetV(a.v), this.id.Set(a.id)
        }, K.Features = function() {}, Object.defineProperty(K.prototype, "referenceEdge", {
            enumerable: !1,
            configurable: !0,
            get: function() {
                return this._referenceEdge
            }
        }), Object.defineProperty(K.prototype, "referenceEdge", {
            enumerable: !1,
            configurable: !0,
            set: function(a) {
                void 0 === a && (a = 0), this._referenceEdge = a, this._m_id._key = 4294967040 & this._m_id._key | 255 & this._referenceEdge
            }
        }), Object.defineProperty(K.prototype, "incidentEdge", {
            enumerable: !1,
            configurable: !0,
            get: function() {
                return this._incidentEdge
            }
        }), Object.defineProperty(K.prototype, "incidentEdge", {
            enumerable: !1,
            configurable: !0,
            set: function(a) {
                void 0 === a && (a = 0), this._incidentEdge = a, this._m_id._key = 4294902015 & this._m_id._key | this._incidentEdge << 8 & 65280
            }
        }), Object.defineProperty(K.prototype, "incidentVertex", {
            enumerable: !1,
            configurable: !0,
            get: function() {
                return this._incidentVertex
            }
        }), Object.defineProperty(K.prototype, "incidentVertex", {
            enumerable: !1,
            configurable: !0,
            set: function(a) {
                void 0 === a && (a = 0), this._incidentVertex = a, this._m_id._key = 4278255615 & this._m_id._key | this._incidentVertex << 16 & 16711680
            }
        }), Object.defineProperty(K.prototype, "flip", {
            enumerable: !1,
            configurable: !0,
            get: function() {
                return this._flip
            }
        }), Object.defineProperty(K.prototype, "flip", {
            enumerable: !1,
            configurable: !0,
            set: function(a) {
                void 0 === a && (a = 0), this._flip = a, this._m_id._key = 16777215 & this._m_id._key | this._flip << 24 & 4278190080
            }
        })
    }(),
    function() {
        {
            var a = (Box2D.Common.b2Color, Box2D.Common.b2internal, Box2D.Common.b2Settings),
                b = Box2D.Collision.Shapes.b2CircleShape,
                c = Box2D.Collision.Shapes.b2EdgeChainDef,
                d = Box2D.Collision.Shapes.b2EdgeShape,
                e = Box2D.Collision.Shapes.b2MassData,
                f = Box2D.Collision.Shapes.b2PolygonShape,
                g = Box2D.Collision.Shapes.b2Shape,
                h = Box2D.Common.Math.b2Mat22,
                i = (Box2D.Common.Math.b2Mat33, Box2D.Common.Math.b2Math),
                j = (Box2D.Common.Math.b2Sweep, Box2D.Common.Math.b2Transform),
                k = Box2D.Common.Math.b2Vec2,
                l = (Box2D.Common.Math.b2Vec3, Box2D.Dynamics.b2Body, Box2D.Dynamics.b2BodyDef, Box2D.Dynamics.b2ContactFilter, Box2D.Dynamics.b2ContactImpulse, Box2D.Dynamics.b2ContactListener, Box2D.Dynamics.b2ContactManager, Box2D.Dynamics.b2DebugDraw, Box2D.Dynamics.b2DestructionListener, Box2D.Dynamics.b2FilterData, Box2D.Dynamics.b2Fixture, Box2D.Dynamics.b2FixtureDef, Box2D.Dynamics.b2Island, Box2D.Dynamics.b2TimeStep, Box2D.Dynamics.b2World, Box2D.Collision.b2AABB, Box2D.Collision.b2Bound, Box2D.Collision.b2BoundValues, Box2D.Collision.b2Collision, Box2D.Collision.b2ContactID, Box2D.Collision.b2ContactPoint, Box2D.Collision.b2Distance),
                m = Box2D.Collision.b2DistanceInput,
                n = Box2D.Collision.b2DistanceOutput,
                o = Box2D.Collision.b2DistanceProxy,
                p = (Box2D.Collision.b2DynamicTree, Box2D.Collision.b2DynamicTreeBroadPhase, Box2D.Collision.b2DynamicTreeNode, Box2D.Collision.b2DynamicTreePair, Box2D.Collision.b2Manifold, Box2D.Collision.b2ManifoldPoint, Box2D.Collision.b2Point, Box2D.Collision.b2RayCastInput, Box2D.Collision.b2RayCastOutput, Box2D.Collision.b2Segment, Box2D.Collision.b2SeparationFunction, Box2D.Collision.b2Simplex, Box2D.Collision.b2SimplexCache);
            Box2D.Collision.b2SimplexVertex, Box2D.Collision.b2TimeOfImpact, Box2D.Collision.b2TOIInput, Box2D.Collision.b2WorldManifold, Box2D.Collision.ClipVertex, Box2D.Collision.Features, Box2D.Collision.IBroadPhase
        }
        Box2D.inherit(b, Box2D.Collision.Shapes.b2Shape), b.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype, b.b2CircleShape = function() {
            Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments), this.m_p = new k
        }, b.prototype.Copy = function() {
            var a = new b;
            return a.Set(this), a
        }, b.prototype.Set = function(a) {
            if (this.__super.Set.call(this, a), Box2D.is(a, b)) {
                var c = a instanceof b ? a : null;
                this.m_p.SetV(c.m_p)
            }
        }, b.prototype.TestPoint = function(a, b) {
            var c = a.R,
                d = a.position.x + (c.col1.x * this.m_p.x + c.col2.x * this.m_p.y),
                e = a.position.y + (c.col1.y * this.m_p.x + c.col2.y * this.m_p.y);
            return d = b.x - d, e = b.y - e, d * d + e * e <= this.m_radius * this.m_radius
        }, b.prototype.RayCast = function(a, b, c) {
            var d = c.R,
                e = c.position.x + (d.col1.x * this.m_p.x + d.col2.x * this.m_p.y),
                f = c.position.y + (d.col1.y * this.m_p.x + d.col2.y * this.m_p.y),
                g = b.p1.x - e,
                h = b.p1.y - f,
                i = g * g + h * h - this.m_radius * this.m_radius,
                j = b.p2.x - b.p1.x,
                k = b.p2.y - b.p1.y,
                l = g * j + h * k,
                m = j * j + k * k,
                n = l * l - m * i;
            if (0 > n || m < Number.MIN_VALUE) return !1;
            var o = -(l + Math.sqrt(n));
            return o >= 0 && o <= b.maxFraction * m ? (o /= m, a.fraction = o, a.normal.x = g + o * j, a.normal.y = h + o * k, a.normal.Normalize(), !0) : !1
        }, b.prototype.ComputeAABB = function(a, b) {
            var c = b.R,
                d = b.position.x + (c.col1.x * this.m_p.x + c.col2.x * this.m_p.y),
                e = b.position.y + (c.col1.y * this.m_p.x + c.col2.y * this.m_p.y);
            a.lowerBound.Set(d - this.m_radius, e - this.m_radius), a.upperBound.Set(d + this.m_radius, e + this.m_radius)
        }, b.prototype.ComputeMass = function(b, c) {
            void 0 === c && (c = 0), b.mass = c * a.b2_pi * this.m_radius * this.m_radius, b.center.SetV(this.m_p), b.I = b.mass * (.5 * this.m_radius * this.m_radius + (this.m_p.x * this.m_p.x + this.m_p.y * this.m_p.y))
        }, b.prototype.ComputeSubmergedArea = function(a, b, c, d) {
            void 0 === b && (b = 0);
            var e = i.MulX(c, this.m_p),
                f = -(i.Dot(a, e) - b);
            if (f < -this.m_radius + Number.MIN_VALUE) return 0;
            if (f > this.m_radius) return d.SetV(e), Math.PI * this.m_radius * this.m_radius;
            var g = this.m_radius * this.m_radius,
                h = f * f,
                j = g * (Math.asin(f / this.m_radius) + Math.PI / 2) + f * Math.sqrt(g - h),
                k = -2 / 3 * Math.pow(g - h, 1.5) / j;
            return d.x = e.x + a.x * k, d.y = e.y + a.y * k, j
        }, b.prototype.GetLocalPosition = function() {
            return this.m_p
        }, b.prototype.SetLocalPosition = function(a) {
            this.m_p.SetV(a)
        }, b.prototype.GetRadius = function() {
            return this.m_radius
        }, b.prototype.SetRadius = function(a) {
            void 0 === a && (a = 0), this.m_radius = a
        }, b.prototype.b2CircleShape = function(a) {
            void 0 === a && (a = 0), this.__super.b2Shape.call(this), this.m_type = g.e_circleShape, this.m_radius = a
        }, c.b2EdgeChainDef = function() {}, c.prototype.b2EdgeChainDef = function() {
            this.vertexCount = 0, this.isALoop = !0, this.vertices = []
        }, Box2D.inherit(d, Box2D.Collision.Shapes.b2Shape), d.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype, d.b2EdgeShape = function() {
            Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments), this.s_supportVec = new k, this.m_v1 = new k, this.m_v2 = new k, this.m_coreV1 = new k, this.m_coreV2 = new k, this.m_normal = new k, this.m_direction = new k, this.m_cornerDir1 = new k, this.m_cornerDir2 = new k
        }, d.prototype.TestPoint = function() {
            return !1
        }, d.prototype.RayCast = function(a, b, c) {
            var d, e = b.p2.x - b.p1.x,
                f = b.p2.y - b.p1.y;
            d = c.R;
            var g = c.position.x + (d.col1.x * this.m_v1.x + d.col2.x * this.m_v1.y),
                h = c.position.y + (d.col1.y * this.m_v1.x + d.col2.y * this.m_v1.y),
                i = c.position.y + (d.col1.y * this.m_v2.x + d.col2.y * this.m_v2.y) - h,
                j = -(c.position.x + (d.col1.x * this.m_v2.x + d.col2.x * this.m_v2.y) - g),
                k = 100 * Number.MIN_VALUE,
                l = -(e * i + f * j);
            if (l > k) {
                var m = b.p1.x - g,
                    n = b.p1.y - h,
                    o = m * i + n * j;
                if (o >= 0 && o <= b.maxFraction * l) {
                    var p = -e * n + f * m;
                    if (p >= -k * l && l * (1 + k) >= p) {
                        o /= l, a.fraction = o;
                        var q = Math.sqrt(i * i + j * j);
                        return a.normal.x = i / q, a.normal.y = j / q, !0
                    }
                }
            }
            return !1
        }, d.prototype.ComputeAABB = function(a, b) {
            var c = b.R,
                d = b.position.x + (c.col1.x * this.m_v1.x + c.col2.x * this.m_v1.y),
                e = b.position.y + (c.col1.y * this.m_v1.x + c.col2.y * this.m_v1.y),
                f = b.position.x + (c.col1.x * this.m_v2.x + c.col2.x * this.m_v2.y),
                g = b.position.y + (c.col1.y * this.m_v2.x + c.col2.y * this.m_v2.y);
            f > d ? (a.lowerBound.x = d, a.upperBound.x = f) : (a.lowerBound.x = f, a.upperBound.x = d), g > e ? (a.lowerBound.y = e, a.upperBound.y = g) : (a.lowerBound.y = g, a.upperBound.y = e)
        }, d.prototype.ComputeMass = function(a, b) {
            void 0 === b && (b = 0), a.mass = 0, a.center.SetV(this.m_v1), a.I = 0
        }, d.prototype.ComputeSubmergedArea = function(a, b, c, d) {
            void 0 === b && (b = 0);
            var e = new k(a.x * b, a.y * b),
                f = i.MulX(c, this.m_v1),
                g = i.MulX(c, this.m_v2),
                h = i.Dot(a, f) - b,
                j = i.Dot(a, g) - b;
            if (h > 0) {
                if (j > 0) return 0;
                f.x = -j / (h - j) * f.x + h / (h - j) * g.x, f.y = -j / (h - j) * f.y + h / (h - j) * g.y
            } else j > 0 && (g.x = -j / (h - j) * f.x + h / (h - j) * g.x, g.y = -j / (h - j) * f.y + h / (h - j) * g.y);
            return d.x = (e.x + f.x + g.x) / 3, d.y = (e.y + f.y + g.y) / 3, .5 * ((f.x - e.x) * (g.y - e.y) - (f.y - e.y) * (g.x - e.x))
        }, d.prototype.GetLength = function() {
            return this.m_length
        }, d.prototype.GetVertex1 = function() {
            return this.m_v1
        }, d.prototype.GetVertex2 = function() {
            return this.m_v2
        }, d.prototype.GetCoreVertex1 = function() {
            return this.m_coreV1
        }, d.prototype.GetCoreVertex2 = function() {
            return this.m_coreV2
        }, d.prototype.GetNormalVector = function() {
            return this.m_normal
        }, d.prototype.GetDirectionVector = function() {
            return this.m_direction
        }, d.prototype.GetCorner1Vector = function() {
            return this.m_cornerDir1
        }, d.prototype.GetCorner2Vector = function() {
            return this.m_cornerDir2
        }, d.prototype.Corner1IsConvex = function() {
            return this.m_cornerConvex1
        }, d.prototype.Corner2IsConvex = function() {
            return this.m_cornerConvex2
        }, d.prototype.GetFirstVertex = function(a) {
            var b = a.R;
            return new k(a.position.x + (b.col1.x * this.m_coreV1.x + b.col2.x * this.m_coreV1.y), a.position.y + (b.col1.y * this.m_coreV1.x + b.col2.y * this.m_coreV1.y))
        }, d.prototype.GetNextEdge = function() {
            return this.m_nextEdge
        }, d.prototype.GetPrevEdge = function() {
            return this.m_prevEdge
        }, d.prototype.Support = function(a, b, c) {
            void 0 === b && (b = 0), void 0 === c && (c = 0);
            var d = a.R,
                e = a.position.x + (d.col1.x * this.m_coreV1.x + d.col2.x * this.m_coreV1.y),
                f = a.position.y + (d.col1.y * this.m_coreV1.x + d.col2.y * this.m_coreV1.y),
                g = a.position.x + (d.col1.x * this.m_coreV2.x + d.col2.x * this.m_coreV2.y),
                h = a.position.y + (d.col1.y * this.m_coreV2.x + d.col2.y * this.m_coreV2.y);
            return e * b + f * c > g * b + h * c ? (this.s_supportVec.x = e, this.s_supportVec.y = f) : (this.s_supportVec.x = g, this.s_supportVec.y = h), this.s_supportVec
        }, d.prototype.b2EdgeShape = function(b, c) {
            this.__super.b2Shape.call(this), this.m_type = g.e_edgeShape, this.m_prevEdge = null, this.m_nextEdge = null, this.m_v1 = b, this.m_v2 = c, this.m_direction.Set(this.m_v2.x - this.m_v1.x, this.m_v2.y - this.m_v1.y), this.m_length = this.m_direction.Normalize(), this.m_normal.Set(this.m_direction.y, -this.m_direction.x), this.m_coreV1.Set(-a.b2_toiSlop * (this.m_normal.x - this.m_direction.x) + this.m_v1.x, -a.b2_toiSlop * (this.m_normal.y - this.m_direction.y) + this.m_v1.y), this.m_coreV2.Set(-a.b2_toiSlop * (this.m_normal.x + this.m_direction.x) + this.m_v2.x, -a.b2_toiSlop * (this.m_normal.y + this.m_direction.y) + this.m_v2.y), this.m_cornerDir1 = this.m_normal, this.m_cornerDir2.Set(-this.m_normal.x, -this.m_normal.y)
        }, d.prototype.SetPrevEdge = function(a, b, c, d) {
            this.m_prevEdge = a, this.m_coreV1 = b, this.m_cornerDir1 = c, this.m_cornerConvex1 = d
        }, d.prototype.SetNextEdge = function(a, b, c, d) {
            this.m_nextEdge = a, this.m_coreV2 = b, this.m_cornerDir2 = c, this.m_cornerConvex2 = d
        }, e.b2MassData = function() {
            this.mass = 0, this.center = new k(0, 0), this.I = 0
        }, Box2D.inherit(f, Box2D.Collision.Shapes.b2Shape), f.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype, f.b2PolygonShape = function() {
            Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments)
        }, f.prototype.Copy = function() {
            var a = new f;
            return a.Set(this), a
        }, f.prototype.Set = function(a) {
            if (this.__super.Set.call(this, a), Box2D.is(a, f)) {
                var b = a instanceof f ? a : null;
                this.m_centroid.SetV(b.m_centroid), this.m_vertexCount = b.m_vertexCount, this.Reserve(this.m_vertexCount);
                for (var c = 0; c < this.m_vertexCount; c++) this.m_vertices[c].SetV(b.m_vertices[c]), this.m_normals[c].SetV(b.m_normals[c])
            }
        }, f.prototype.SetAsArray = function(a, b) {
            void 0 === b && (b = 0);
            var c, d = new Vector,
                e = 0;
            for (e = 0; e < a.length; ++e) c = a[e], d.push(c);
            this.SetAsVector(d, b)
        }, f.AsArray = function(a, b) {
            void 0 === b && (b = 0);
            var c = new f;
            return c.SetAsArray(a, b), c
        }, f.prototype.SetAsVector = function(b, c) {
            void 0 === c && (c = 0), 0 == c && (c = b.length), a.b2Assert(c >= 2), this.m_vertexCount = c, this.Reserve(c);
            var d = 0;
            for (d = 0; d < this.m_vertexCount; d++) this.m_vertices[d].SetV(b[d]);
            for (d = 0; d < this.m_vertexCount; ++d) {
                var e = parseInt(d),
                    g = parseInt(d + 1 < this.m_vertexCount ? d + 1 : 0),
                    h = i.SubtractVV(this.m_vertices[g], this.m_vertices[e]);
                a.b2Assert(h.LengthSquared() > Number.MIN_VALUE), this.m_normals[d].SetV(i.CrossVF(h, 1)), this.m_normals[d].Normalize()
            }
            this.m_centroid = f.ComputeCentroid(this.m_vertices, this.m_vertexCount)
        }, f.AsVector = function(a, b) {
            void 0 === b && (b = 0);
            var c = new f;
            return c.SetAsVector(a, b), c
        }, f.prototype.SetAsBox = function(a, b) {
            void 0 === a && (a = 0), void 0 === b && (b = 0), this.m_vertexCount = 4, this.Reserve(4), this.m_vertices[0].Set(-a, -b), this.m_vertices[1].Set(a, -b), this.m_vertices[2].Set(a, b), this.m_vertices[3].Set(-a, b), this.m_normals[0].Set(0, -1), this.m_normals[1].Set(1, 0), this.m_normals[2].Set(0, 1), this.m_normals[3].Set(-1, 0), this.m_centroid.SetZero()
        }, f.AsBox = function(a, b) {
            void 0 === a && (a = 0), void 0 === b && (b = 0);
            var c = new f;
            return c.SetAsBox(a, b), c
        }, f.prototype.SetAsOrientedBox = function(a, b, c, d) {
            void 0 === a && (a = 0), void 0 === b && (b = 0), void 0 === c && (c = null), void 0 === d && (d = 0), this.m_vertexCount = 4, this.Reserve(4), this.m_vertices[0].Set(-a, -b), this.m_vertices[1].Set(a, -b), this.m_vertices[2].Set(a, b), this.m_vertices[3].Set(-a, b), this.m_normals[0].Set(0, -1), this.m_normals[1].Set(1, 0), this.m_normals[2].Set(0, 1), this.m_normals[3].Set(-1, 0), this.m_centroid = c;
            var e = new j;
            e.position = c, e.R.Set(d);
            for (var f = 0; f < this.m_vertexCount; ++f) this.m_vertices[f] = i.MulX(e, this.m_vertices[f]), this.m_normals[f] = i.MulMV(e.R, this.m_normals[f])
        }, f.AsOrientedBox = function(a, b, c, d) {
            void 0 === a && (a = 0), void 0 === b && (b = 0), void 0 === c && (c = null), void 0 === d && (d = 0);
            var e = new f;
            return e.SetAsOrientedBox(a, b, c, d), e
        }, f.prototype.SetAsEdge = function(a, b) {
            this.m_vertexCount = 2, this.Reserve(2), this.m_vertices[0].SetV(a), this.m_vertices[1].SetV(b), this.m_centroid.x = .5 * (a.x + b.x), this.m_centroid.y = .5 * (a.y + b.y), this.m_normals[0] = i.CrossVF(i.SubtractVV(b, a), 1), this.m_normals[0].Normalize(), this.m_normals[1].x = -this.m_normals[0].x, this.m_normals[1].y = -this.m_normals[0].y
        }, f.AsEdge = function(a, b) {
            var c = new f;
            return c.SetAsEdge(a, b), c
        }, f.prototype.TestPoint = function(a, b) {
            for (var c, d = a.R, e = b.x - a.position.x, f = b.y - a.position.y, g = e * d.col1.x + f * d.col1.y, h = e * d.col2.x + f * d.col2.y, i = 0; i < this.m_vertexCount; ++i) {
                c = this.m_vertices[i], e = g - c.x, f = h - c.y, c = this.m_normals[i];
                var j = c.x * e + c.y * f;
                if (j > 0) return !1
            }
            return !0
        }, f.prototype.RayCast = function(a, b, c) {
            var d, e, f = 0,
                g = b.maxFraction,
                h = 0,
                i = 0;
            h = b.p1.x - c.position.x, i = b.p1.y - c.position.y, d = c.R;
            var j = h * d.col1.x + i * d.col1.y,
                k = h * d.col2.x + i * d.col2.y;
            h = b.p2.x - c.position.x, i = b.p2.y - c.position.y, d = c.R;
            for (var l = h * d.col1.x + i * d.col1.y, m = h * d.col2.x + i * d.col2.y, n = l - j, o = m - k, p = parseInt(-1), q = 0; q < this.m_vertexCount; ++q) {
                e = this.m_vertices[q], h = e.x - j, i = e.y - k, e = this.m_normals[q];
                var r = e.x * h + e.y * i,
                    s = e.x * n + e.y * o;
                if (0 == s) {
                    if (0 > r) return !1
                } else 0 > s && f * s > r ? (f = r / s, p = q) : s > 0 && g * s > r && (g = r / s); if (g < f - Number.MIN_VALUE) return !1
            }
            return p >= 0 ? (a.fraction = f, d = c.R, e = this.m_normals[p], a.normal.x = d.col1.x * e.x + d.col2.x * e.y, a.normal.y = d.col1.y * e.x + d.col2.y * e.y, !0) : !1
        }, f.prototype.ComputeAABB = function(a, b) {
            for (var c = b.R, d = this.m_vertices[0], e = b.position.x + (c.col1.x * d.x + c.col2.x * d.y), f = b.position.y + (c.col1.y * d.x + c.col2.y * d.y), g = e, h = f, i = 1; i < this.m_vertexCount; ++i) {
                d = this.m_vertices[i];
                var j = b.position.x + (c.col1.x * d.x + c.col2.x * d.y),
                    k = b.position.y + (c.col1.y * d.x + c.col2.y * d.y);
                e = j > e ? e : j, f = k > f ? f : k, g = g > j ? g : j, h = h > k ? h : k
            }
            a.lowerBound.x = e - this.m_radius, a.lowerBound.y = f - this.m_radius, a.upperBound.x = g + this.m_radius, a.upperBound.y = h + this.m_radius
        }, f.prototype.ComputeMass = function(a, b) {
            if (void 0 === b && (b = 0), 2 == this.m_vertexCount) return a.center.x = .5 * (this.m_vertices[0].x + this.m_vertices[1].x), a.center.y = .5 * (this.m_vertices[0].y + this.m_vertices[1].y), a.mass = 0, void(a.I = 0);
            for (var c = 0, d = 0, e = 0, f = 0, g = 0, h = 0, i = 1 / 3, j = 0; j < this.m_vertexCount; ++j) {
                var k = this.m_vertices[j],
                    l = j + 1 < this.m_vertexCount ? this.m_vertices[parseInt(j + 1)] : this.m_vertices[0],
                    m = k.x - g,
                    n = k.y - h,
                    o = l.x - g,
                    p = l.y - h,
                    q = m * p - n * o,
                    r = .5 * q;
                e += r, c += r * i * (g + k.x + l.x), d += r * i * (h + k.y + l.y);
                var s = g,
                    t = h,
                    u = m,
                    v = n,
                    w = o,
                    x = p,
                    y = i * (.25 * (u * u + w * u + w * w) + (s * u + s * w)) + .5 * s * s,
                    z = i * (.25 * (v * v + x * v + x * x) + (t * v + t * x)) + .5 * t * t;
                f += q * (y + z)
            }
            a.mass = b * e, c *= 1 / e, d *= 1 / e, a.center.Set(c, d), a.I = b * f
        }, f.prototype.ComputeSubmergedArea = function(a, b, c, d) {
            void 0 === b && (b = 0);
            var f = i.MulTMV(c.R, a),
                g = b - i.Dot(a, c.position),
                h = new Vector_a2j_Number,
                j = 0,
                l = parseInt(-1),
                m = parseInt(-1),
                n = !1,
                o = 0;
            for (o = 0; o < this.m_vertexCount; ++o) {
                h[o] = i.Dot(f, this.m_vertices[o]) - g;
                var p = h[o] < -Number.MIN_VALUE;
                o > 0 && (p ? n || (l = o - 1, j++) : n && (m = o - 1, j++)), n = p
            }
            switch (j) {
                case 0:
                    if (n) {
                        var q = new e;
                        return this.ComputeMass(q, 1), d.SetV(i.MulX(c, q.center)), q.mass
                    }
                    return 0;
                case 1:
                    -1 == l ? l = this.m_vertexCount - 1 : m = this.m_vertexCount - 1
            }
            var r, s = parseInt((l + 1) % this.m_vertexCount),
                t = parseInt((m + 1) % this.m_vertexCount),
                u = (0 - h[l]) / (h[s] - h[l]),
                v = (0 - h[m]) / (h[t] - h[m]),
                w = new k(this.m_vertices[l].x * (1 - u) + this.m_vertices[s].x * u, this.m_vertices[l].y * (1 - u) + this.m_vertices[s].y * u),
                x = new k(this.m_vertices[m].x * (1 - v) + this.m_vertices[t].x * v, this.m_vertices[m].y * (1 - v) + this.m_vertices[t].y * v),
                y = 0,
                z = new k,
                A = this.m_vertices[s];
            for (o = s; o != t;) {
                o = (o + 1) % this.m_vertexCount, r = o == t ? x : this.m_vertices[o];
                var B = .5 * ((A.x - w.x) * (r.y - w.y) - (A.y - w.y) * (r.x - w.x));
                y += B, z.x += B * (w.x + A.x + r.x) / 3, z.y += B * (w.y + A.y + r.y) / 3, A = r
            }
            return z.Multiply(1 / y), d.SetV(i.MulX(c, z)), y
        }, f.prototype.GetVertexCount = function() {
            return this.m_vertexCount
        }, f.prototype.GetVertices = function() {
            return this.m_vertices
        }, f.prototype.GetNormals = function() {
            return this.m_normals
        }, f.prototype.GetSupport = function(a) {
            for (var b = 0, c = this.m_vertices[0].x * a.x + this.m_vertices[0].y * a.y, d = 1; d < this.m_vertexCount; ++d) {
                var e = this.m_vertices[d].x * a.x + this.m_vertices[d].y * a.y;
                e > c && (b = d, c = e)
            }
            return b
        }, f.prototype.GetSupportVertex = function(a) {
            for (var b = 0, c = this.m_vertices[0].x * a.x + this.m_vertices[0].y * a.y, d = 1; d < this.m_vertexCount; ++d) {
                var e = this.m_vertices[d].x * a.x + this.m_vertices[d].y * a.y;
                e > c && (b = d, c = e)
            }
            return this.m_vertices[b]
        }, f.prototype.Validate = function() {
            return !1
        }, f.prototype.b2PolygonShape = function() {
            this.__super.b2Shape.call(this), this.m_type = g.e_polygonShape, this.m_centroid = new k, this.m_vertices = new Vector, this.m_normals = new Vector
        }, f.prototype.Reserve = function(a) {
            void 0 === a && (a = 0);
            for (var b = parseInt(this.m_vertices.length); a > b; b++) this.m_vertices[b] = new k, this.m_normals[b] = new k
        }, f.ComputeCentroid = function(a, b) {
            void 0 === b && (b = 0);
            for (var c = new k, d = 0, e = 0, f = 0, g = 1 / 3, h = 0; b > h; ++h) {
                var i = a[h],
                    j = b > h + 1 ? a[parseInt(h + 1)] : a[0],
                    l = i.x - e,
                    m = i.y - f,
                    n = j.x - e,
                    o = j.y - f,
                    p = l * o - m * n,
                    q = .5 * p;
                d += q, c.x += q * g * (e + i.x + j.x), c.y += q * g * (f + i.y + j.y)
            }
            return c.x *= 1 / d, c.y *= 1 / d, c
        }, f.ComputeOBB = function(a, b, c) {
            void 0 === c && (c = 0);
            var d = 0,
                e = new Vector(c + 1);
            for (d = 0; c > d; ++d) e[d] = b[d];
            e[c] = e[0];
            var f = Number.MAX_VALUE;
            for (d = 1; c >= d; ++d) {
                var g = e[parseInt(d - 1)],
                    h = e[d].x - g.x,
                    i = e[d].y - g.y,
                    j = Math.sqrt(h * h + i * i);
                h /= j, i /= j;
                for (var k = -i, l = h, m = Number.MAX_VALUE, n = Number.MAX_VALUE, o = -Number.MAX_VALUE, p = -Number.MAX_VALUE, q = 0; c > q; ++q) {
                    var r = e[q].x - g.x,
                        s = e[q].y - g.y,
                        t = h * r + i * s,
                        u = k * r + l * s;
                    m > t && (m = t), n > u && (n = u), t > o && (o = t), u > p && (p = u)
                }
                var v = (o - m) * (p - n);
                if (.95 * f > v) {
                    f = v, a.R.col1.x = h, a.R.col1.y = i, a.R.col2.x = k, a.R.col2.y = l;
                    var w = .5 * (m + o),
                        x = .5 * (n + p),
                        y = a.R;
                    a.center.x = g.x + (y.col1.x * w + y.col2.x * x), a.center.y = g.y + (y.col1.y * w + y.col2.y * x), a.extents.x = .5 * (o - m), a.extents.y = .5 * (p - n)
                }
            }
        }, Box2D.postDefs.push(function() {
            Box2D.Collision.Shapes.b2PolygonShape.s_mat = new h
        }), g.b2Shape = function() {}, g.prototype.Copy = function() {
            return null
        }, g.prototype.Set = function(a) {
            this.m_radius = a.m_radius
        }, g.prototype.GetType = function() {
            return this.m_type
        }, g.prototype.TestPoint = function() {
            return !1
        }, g.prototype.RayCast = function() {
            return !1
        }, g.prototype.ComputeAABB = function() {}, g.prototype.ComputeMass = function(a, b) {
            void 0 === b && (b = 0)
        }, g.prototype.ComputeSubmergedArea = function(a, b) {
            return void 0 === b && (b = 0), 0
        }, g.TestOverlap = function(a, b, c, d) {
            var e = new m;
            e.proxyA = new o, e.proxyA.Set(a), e.proxyB = new o, e.proxyB.Set(c), e.transformA = b, e.transformB = d, e.useRadii = !0;
            var f = new p;
            f.count = 0;
            var g = new n;
            return l.Distance(g, f, e), g.distance < 10 * Number.MIN_VALUE
        }, g.prototype.b2Shape = function() {
            this.m_type = g.e_unknownShape, this.m_radius = a.b2_linearSlop
        }, Box2D.postDefs.push(function() {
            Box2D.Collision.Shapes.b2Shape.e_unknownShape = parseInt(-1), Box2D.Collision.Shapes.b2Shape.e_circleShape = 0, Box2D.Collision.Shapes.b2Shape.e_polygonShape = 1, Box2D.Collision.Shapes.b2Shape.e_edgeShape = 2, Box2D.Collision.Shapes.b2Shape.e_shapeTypeCount = 3, Box2D.Collision.Shapes.b2Shape.e_hitCollide = 1, Box2D.Collision.Shapes.b2Shape.e_missCollide = 0, Box2D.Collision.Shapes.b2Shape.e_startsInsideCollide = parseInt(-1)
        })
    }(),
    function() {
        {
            var a = Box2D.Common.b2Color,
                b = (Box2D.Common.b2internal, Box2D.Common.b2Settings),
                c = (Box2D.Common.Math.b2Mat22, Box2D.Common.Math.b2Mat33, Box2D.Common.Math.b2Math);
            Box2D.Common.Math.b2Sweep, Box2D.Common.Math.b2Transform, Box2D.Common.Math.b2Vec2, Box2D.Common.Math.b2Vec3
        }
        a.b2Color = function() {
            this._r = 0, this._g = 0, this._b = 0
        }, a.prototype.b2Color = function(a, b, d) {
            void 0 === a && (a = 0), void 0 === b && (b = 0), void 0 === d && (d = 0), this._r = Box2D.parseUInt(255 * c.Clamp(a, 0, 1)), this._g = Box2D.parseUInt(255 * c.Clamp(b, 0, 1)), this._b = Box2D.parseUInt(255 * c.Clamp(d, 0, 1))
        }, a.prototype.Set = function(a, b, d) {
            void 0 === a && (a = 0), void 0 === b && (b = 0), void 0 === d && (d = 0), this._r = Box2D.parseUInt(255 * c.Clamp(a, 0, 1)), this._g = Box2D.parseUInt(255 * c.Clamp(b, 0, 1)), this._b = Box2D.parseUInt(255 * c.Clamp(d, 0, 1))
        }, Object.defineProperty(a.prototype, "r", {
            enumerable: !1,
            configurable: !0,
            set: function(a) {
                void 0 === a && (a = 0), this._r = Box2D.parseUInt(255 * c.Clamp(a, 0, 1))
            }
        }), Object.defineProperty(a.prototype, "g", {
            enumerable: !1,
            configurable: !0,
            set: function(a) {
                void 0 === a && (a = 0), this._g = Box2D.parseUInt(255 * c.Clamp(a, 0, 1))
            }
        }), Object.defineProperty(a.prototype, "b", {
            enumerable: !1,
            configurable: !0,
            set: function(a) {
                void 0 === a && (a = 0), this._b = Box2D.parseUInt(255 * c.Clamp(a, 0, 1))
            }
        }), Object.defineProperty(a.prototype, "color", {
            enumerable: !1,
            configurable: !0,
            get: function() {
                return this._r << 16 | this._g << 8 | this._b
            }
        }), b.b2Settings = function() {}, b.b2MixFriction = function(a, b) {
            return void 0 === a && (a = 0), void 0 === b && (b = 0), Math.sqrt(a * b)
        }, b.b2MixRestitution = function(a, b) {
            return void 0 === a && (a = 0), void 0 === b && (b = 0), a > b ? a : b
        }, b.b2Assert = function(a) {
            if (!a) throw "Assertion Failed"
        }, Box2D.postDefs.push(function() {
            Box2D.Common.b2Settings.VERSION = "2.1alpha", Box2D.Common.b2Settings.USHRT_MAX = 65535, Box2D.Common.b2Settings.b2_pi = Math.PI, Box2D.Common.b2Settings.b2_maxManifoldPoints = 2, Box2D.Common.b2Settings.b2_aabbExtension = .1, Box2D.Common.b2Settings.b2_aabbMultiplier = 2, Box2D.Common.b2Settings.b2_polygonRadius = 2 * b.b2_linearSlop, Box2D.Common.b2Settings.b2_linearSlop = .005, Box2D.Common.b2Settings.b2_angularSlop = 2 / 180 * b.b2_pi, Box2D.Common.b2Settings.b2_toiSlop = 8 * b.b2_linearSlop, Box2D.Common.b2Settings.b2_maxTOIContactsPerIsland = 32, Box2D.Common.b2Settings.b2_maxTOIJointsPerIsland = 32, Box2D.Common.b2Settings.b2_velocityThreshold = 1, Box2D.Common.b2Settings.b2_maxLinearCorrection = .2, Box2D.Common.b2Settings.b2_maxAngularCorrection = 8 / 180 * b.b2_pi, Box2D.Common.b2Settings.b2_maxTranslation = 2, Box2D.Common.b2Settings.b2_maxTranslationSquared = b.b2_maxTranslation * b.b2_maxTranslation, Box2D.Common.b2Settings.b2_maxRotation = .5 * b.b2_pi, Box2D.Common.b2Settings.b2_maxRotationSquared = b.b2_maxRotation * b.b2_maxRotation, Box2D.Common.b2Settings.b2_contactBaumgarte = .2, Box2D.Common.b2Settings.b2_timeToSleep = .5, Box2D.Common.b2Settings.b2_linearSleepTolerance = .01, Box2D.Common.b2Settings.b2_angularSleepTolerance = 2 / 180 * b.b2_pi
        })
    }(),
    function() {
        var a = (Box2D.Collision.b2AABB, Box2D.Common.b2Color, Box2D.Common.b2internal, Box2D.Common.b2Settings, Box2D.Common.Math.b2Mat22),
            b = Box2D.Common.Math.b2Mat33,
            c = Box2D.Common.Math.b2Math,
            d = Box2D.Common.Math.b2Sweep,
            e = Box2D.Common.Math.b2Transform,
            f = Box2D.Common.Math.b2Vec2,
            g = Box2D.Common.Math.b2Vec3;
        a.b2Mat22 = function() {
            this.col1 = new f, this.col2 = new f
        }, a.prototype.b2Mat22 = function() {
            this.SetIdentity()
        }, a.FromAngle = function(b) {
            void 0 === b && (b = 0);
            var c = new a;
            return c.Set(b), c
        }, a.FromVV = function(b, c) {
            var d = new a;
            return d.SetVV(b, c), d
        }, a.prototype.Set = function(a) {
            void 0 === a && (a = 0);
            var b = Math.cos(a),
                c = Math.sin(a);
            this.col1.x = b, this.col2.x = -c, this.col1.y = c, this.col2.y = b
        }, a.prototype.SetVV = function(a, b) {
            this.col1.SetV(a), this.col2.SetV(b)
        }, a.prototype.Copy = function() {
            var b = new a;
            return b.SetM(this), b
        }, a.prototype.SetM = function(a) {
            this.col1.SetV(a.col1), this.col2.SetV(a.col2)
        }, a.prototype.AddM = function(a) {
            this.col1.x += a.col1.x, this.col1.y += a.col1.y, this.col2.x += a.col2.x, this.col2.y += a.col2.y
        }, a.prototype.SetIdentity = function() {
            this.col1.x = 1, this.col2.x = 0, this.col1.y = 0, this.col2.y = 1
        }, a.prototype.SetZero = function() {
            this.col1.x = 0, this.col2.x = 0, this.col1.y = 0, this.col2.y = 0
        }, a.prototype.GetAngle = function() {
            return Math.atan2(this.col1.y, this.col1.x)
        }, a.prototype.GetInverse = function(a) {
            var b = this.col1.x,
                c = this.col2.x,
                d = this.col1.y,
                e = this.col2.y,
                f = b * e - c * d;
            return 0 != f && (f = 1 / f), a.col1.x = f * e, a.col2.x = -f * c, a.col1.y = -f * d, a.col2.y = f * b, a
        }, a.prototype.Solve = function(a, b, c) {
            void 0 === b && (b = 0), void 0 === c && (c = 0);
            var d = this.col1.x,
                e = this.col2.x,
                f = this.col1.y,
                g = this.col2.y,
                h = d * g - e * f;
            return 0 != h && (h = 1 / h), a.x = h * (g * b - e * c), a.y = h * (d * c - f * b), a
        }, a.prototype.Abs = function() {
            this.col1.Abs(), this.col2.Abs()
        }, b.b2Mat33 = function() {
            this.col1 = new g, this.col2 = new g, this.col3 = new g
        }, b.prototype.b2Mat33 = function(a, b, c) {
            void 0 === a && (a = null), void 0 === b && (b = null), void 0 === c && (c = null), a || b || c ? (this.col1.SetV(a), this.col2.SetV(b), this.col3.SetV(c)) : (this.col1.SetZero(), this.col2.SetZero(), this.col3.SetZero())
        }, b.prototype.SetVVV = function(a, b, c) {
            this.col1.SetV(a), this.col2.SetV(b), this.col3.SetV(c)
        }, b.prototype.Copy = function() {
            return new b(this.col1, this.col2, this.col3)
        }, b.prototype.SetM = function(a) {
            this.col1.SetV(a.col1), this.col2.SetV(a.col2), this.col3.SetV(a.col3)
        }, b.prototype.AddM = function(a) {
            this.col1.x += a.col1.x, this.col1.y += a.col1.y, this.col1.z += a.col1.z, this.col2.x += a.col2.x, this.col2.y += a.col2.y, this.col2.z += a.col2.z, this.col3.x += a.col3.x, this.col3.y += a.col3.y, this.col3.z += a.col3.z
        }, b.prototype.SetIdentity = function() {
            this.col1.x = 1, this.col2.x = 0, this.col3.x = 0, this.col1.y = 0, this.col2.y = 1, this.col3.y = 0, this.col1.z = 0, this.col2.z = 0, this.col3.z = 1
        }, b.prototype.SetZero = function() {
            this.col1.x = 0, this.col2.x = 0, this.col3.x = 0, this.col1.y = 0, this.col2.y = 0, this.col3.y = 0, this.col1.z = 0, this.col2.z = 0, this.col3.z = 0
        }, b.prototype.Solve22 = function(a, b, c) {
            void 0 === b && (b = 0), void 0 === c && (c = 0);
            var d = this.col1.x,
                e = this.col2.x,
                f = this.col1.y,
                g = this.col2.y,
                h = d * g - e * f;
            return 0 != h && (h = 1 / h), a.x = h * (g * b - e * c), a.y = h * (d * c - f * b), a
        }, b.prototype.Solve33 = function(a, b, c, d) {
            void 0 === b && (b = 0), void 0 === c && (c = 0), void 0 === d && (d = 0);
            var e = this.col1.x,
                f = this.col1.y,
                g = this.col1.z,
                h = this.col2.x,
                i = this.col2.y,
                j = this.col2.z,
                k = this.col3.x,
                l = this.col3.y,
                m = this.col3.z,
                n = e * (i * m - j * l) + f * (j * k - h * m) + g * (h * l - i * k);
            return 0 != n && (n = 1 / n), a.x = n * (b * (i * m - j * l) + c * (j * k - h * m) + d * (h * l - i * k)), a.y = n * (e * (c * m - d * l) + f * (d * k - b * m) + g * (b * l - c * k)), a.z = n * (e * (i * d - j * c) + f * (j * b - h * d) + g * (h * c - i * b)), a
        }, c.b2Math = function() {}, c.IsValid = function(a) {
            return void 0 === a && (a = 0), isFinite(a)
        }, c.Dot = function(a, b) {
            return a.x * b.x + a.y * b.y
        }, c.CrossVV = function(a, b) {
            return a.x * b.y - a.y * b.x
        }, c.CrossVF = function(a, b) {
            void 0 === b && (b = 0);
            var c = new f(b * a.y, -b * a.x);
            return c
        }, c.CrossFV = function(a, b) {
            void 0 === a && (a = 0);
            var c = new f(-a * b.y, a * b.x);
            return c
        }, c.MulMV = function(a, b) {
            var c = new f(a.col1.x * b.x + a.col2.x * b.y, a.col1.y * b.x + a.col2.y * b.y);
            return c
        }, c.MulTMV = function(a, b) {
            var d = new f(c.Dot(b, a.col1), c.Dot(b, a.col2));
            return d
        }, c.MulX = function(a, b) {
            var d = c.MulMV(a.R, b);
            return d.x += a.position.x, d.y += a.position.y, d
        }, c.MulXT = function(a, b) {
            var d = c.SubtractVV(b, a.position),
                e = d.x * a.R.col1.x + d.y * a.R.col1.y;
            return d.y = d.x * a.R.col2.x + d.y * a.R.col2.y, d.x = e, d
        }, c.AddVV = function(a, b) {
            var c = new f(a.x + b.x, a.y + b.y);
            return c
        }, c.SubtractVV = function(a, b) {
            var c = new f(a.x - b.x, a.y - b.y);
            return c
        }, c.Distance = function(a, b) {
            var c = a.x - b.x,
                d = a.y - b.y;
            return Math.sqrt(c * c + d * d)
        }, c.DistanceSquared = function(a, b) {
            var c = a.x - b.x,
                d = a.y - b.y;
            return c * c + d * d
        }, c.MulFV = function(a, b) {
            void 0 === a && (a = 0);
            var c = new f(a * b.x, a * b.y);
            return c
        }, c.AddMM = function(b, d) {
            var e = a.FromVV(c.AddVV(b.col1, d.col1), c.AddVV(b.col2, d.col2));
            return e
        }, c.MulMM = function(b, d) {
            var e = a.FromVV(c.MulMV(b, d.col1), c.MulMV(b, d.col2));
            return e
        }, c.MulTMM = function(b, d) {
            var e = new f(c.Dot(b.col1, d.col1), c.Dot(b.col2, d.col1)),
                g = new f(c.Dot(b.col1, d.col2), c.Dot(b.col2, d.col2)),
                h = a.FromVV(e, g);
            return h
        }, c.Abs = function(a) {
            return void 0 === a && (a = 0), a > 0 ? a : -a
        }, c.AbsV = function(a) {
            var b = new f(c.Abs(a.x), c.Abs(a.y));
            return b
        }, c.AbsM = function(b) {
            var d = a.FromVV(c.AbsV(b.col1), c.AbsV(b.col2));
            return d
        }, c.Min = function(a, b) {
            return void 0 === a && (a = 0), void 0 === b && (b = 0), b > a ? a : b
        }, c.MinV = function(a, b) {
            var d = new f(c.Min(a.x, b.x), c.Min(a.y, b.y));
            return d
        }, c.Max = function(a, b) {
            return void 0 === a && (a = 0), void 0 === b && (b = 0), a > b ? a : b
        }, c.MaxV = function(a, b) {
            var d = new f(c.Max(a.x, b.x), c.Max(a.y, b.y));
            return d
        }, c.Clamp = function(a, b, c) {
            return void 0 === a && (a = 0), void 0 === b && (b = 0), void 0 === c && (c = 0), b > a ? b : a > c ? c : a
        }, c.ClampV = function(a, b, d) {
            return c.MaxV(b, c.MinV(a, d))
        }, c.Swap = function(a, b) {
            var c = a[0];
            a[0] = b[0], b[0] = c
        }, c.Random = function() {
            return 2 * Math.random() - 1
        }, c.RandomRange = function(a, b) {
            void 0 === a && (a = 0), void 0 === b && (b = 0);
            var c = Math.random();
            return c = (b - a) * c + a
        }, c.NextPowerOfTwo = function(a) {
            return void 0 === a && (a = 0), a |= a >> 1 & 2147483647, a |= a >> 2 & 1073741823, a |= a >> 4 & 268435455, a |= a >> 8 & 16777215, a |= a >> 16 & 65535, a + 1
        }, c.IsPowerOfTwo = function(a) {
            void 0 === a && (a = 0);
            var b = a > 0 && 0 == (a & a - 1);
            return b
        }, Box2D.postDefs.push(function() {
            Box2D.Common.Math.b2Math.b2Vec2_zero = new f(0, 0), Box2D.Common.Math.b2Math.b2Mat22_identity = a.FromVV(new f(1, 0), new f(0, 1)), Box2D.Common.Math.b2Math.b2Transform_identity = new e(c.b2Vec2_zero, c.b2Mat22_identity)
        }), d.b2Sweep = function() {
            this.localCenter = new f, this.c0 = new f, this.c = new f
        }, d.prototype.Set = function(a) {
            this.localCenter.SetV(a.localCenter), this.c0.SetV(a.c0), this.c.SetV(a.c), this.a0 = a.a0, this.a = a.a, this.t0 = a.t0
        }, d.prototype.Copy = function() {
            var a = new d;
            return a.localCenter.SetV(this.localCenter), a.c0.SetV(this.c0), a.c.SetV(this.c), a.a0 = this.a0, a.a = this.a, a.t0 = this.t0, a
        }, d.prototype.GetTransform = function(a, b) {
            void 0 === b && (b = 0), a.position.x = (1 - b) * this.c0.x + b * this.c.x, a.position.y = (1 - b) * this.c0.y + b * this.c.y;
            var c = (1 - b) * this.a0 + b * this.a;
            a.R.Set(c);
            var d = a.R;
            a.position.x -= d.col1.x * this.localCenter.x + d.col2.x * this.localCenter.y, a.position.y -= d.col1.y * this.localCenter.x + d.col2.y * this.localCenter.y
        }, d.prototype.Advance = function(a) {
            if (void 0 === a && (a = 0), this.t0 < a && 1 - this.t0 > Number.MIN_VALUE) {
                var b = (a - this.t0) / (1 - this.t0);
                this.c0.x = (1 - b) * this.c0.x + b * this.c.x, this.c0.y = (1 - b) * this.c0.y + b * this.c.y, this.a0 = (1 - b) * this.a0 + b * this.a, this.t0 = a
            }
        }, e.b2Transform = function() {
            this.position = new f, this.R = new a
        }, e.prototype.b2Transform = function(a, b) {
            void 0 === a && (a = null), void 0 === b && (b = null), a && (this.position.SetV(a), this.R.SetM(b))
        }, e.prototype.Initialize = function(a, b) {
            this.position.SetV(a), this.R.SetM(b)
        }, e.prototype.SetIdentity = function() {
            this.position.SetZero(), this.R.SetIdentity()
        }, e.prototype.Set = function(a) {
            this.position.SetV(a.position), this.R.SetM(a.R)
        }, e.prototype.GetAngle = function() {
            return Math.atan2(this.R.col1.y, this.R.col1.x)
        }, f.b2Vec2 = function() {}, f.prototype.b2Vec2 = function(a, b) {
            void 0 === a && (a = 0), void 0 === b && (b = 0), this.x = a, this.y = b
        }, f.prototype.SetZero = function() {
            this.x = 0, this.y = 0
        }, f.prototype.Set = function(a, b) {
            void 0 === a && (a = 0), void 0 === b && (b = 0), this.x = a, this.y = b
        }, f.prototype.SetV = function(a) {
            this.x = a.x, this.y = a.y
        }, f.prototype.GetNegative = function() {
            return new f(-this.x, -this.y)
        }, f.prototype.NegativeSelf = function() {
            this.x = -this.x, this.y = -this.y
        }, f.Make = function(a, b) {
            return void 0 === a && (a = 0), void 0 === b && (b = 0), new f(a, b)
        }, f.prototype.Copy = function() {
            return new f(this.x, this.y)
        }, f.prototype.Add = function(a) {
            this.x += a.x, this.y += a.y
        }, f.prototype.Subtract = function(a) {
            this.x -= a.x, this.y -= a.y
        }, f.prototype.Multiply = function(a) {
            void 0 === a && (a = 0), this.x *= a, this.y *= a
        }, f.prototype.MulM = function(a) {
            var b = this.x;
            this.x = a.col1.x * b + a.col2.x * this.y, this.y = a.col1.y * b + a.col2.y * this.y
        }, f.prototype.MulTM = function(a) {
            var b = c.Dot(this, a.col1);
            this.y = c.Dot(this, a.col2), this.x = b
        }, f.prototype.CrossVF = function(a) {
            void 0 === a && (a = 0);
            var b = this.x;
            this.x = a * this.y, this.y = -a * b
        }, f.prototype.CrossFV = function(a) {
            void 0 === a && (a = 0);
            var b = this.x;
            this.x = -a * this.y, this.y = a * b
        }, f.prototype.MinV = function(a) {
            this.x = this.x < a.x ? this.x : a.x, this.y = this.y < a.y ? this.y : a.y
        }, f.prototype.MaxV = function(a) {
            this.x = this.x > a.x ? this.x : a.x, this.y = this.y > a.y ? this.y : a.y
        }, f.prototype.Abs = function() {
            this.x < 0 && (this.x = -this.x), this.y < 0 && (this.y = -this.y)
        }, f.prototype.Length = function() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        }, f.prototype.LengthSquared = function() {
            return this.x * this.x + this.y * this.y
        }, f.prototype.Normalize = function() {
            var a = Math.sqrt(this.x * this.x + this.y * this.y);
            if (a < Number.MIN_VALUE) return 0;
            var b = 1 / a;
            return this.x *= b, this.y *= b, a
        }, f.prototype.IsValid = function() {
            return c.IsValid(this.x) && c.IsValid(this.y)
        }, g.b2Vec3 = function() {}, g.prototype.b2Vec3 = function(a, b, c) {
            void 0 === a && (a = 0), void 0 === b && (b = 0), void 0 === c && (c = 0), this.x = a, this.y = b, this.z = c
        }, g.prototype.SetZero = function() {
            this.x = this.y = this.z = 0
        }, g.prototype.Set = function(a, b, c) {
            void 0 === a && (a = 0), void 0 === b && (b = 0), void 0 === c && (c = 0), this.x = a, this.y = b, this.z = c
        }, g.prototype.SetV = function(a) {
            this.x = a.x, this.y = a.y, this.z = a.z
        }, g.prototype.GetNegative = function() {
            return new g(-this.x, -this.y, -this.z)
        }, g.prototype.NegativeSelf = function() {
            this.x = -this.x, this.y = -this.y, this.z = -this.z
        }, g.prototype.Copy = function() {
            return new g(this.x, this.y, this.z)
        }, g.prototype.Add = function(a) {
            this.x += a.x, this.y += a.y, this.z += a.z
        }, g.prototype.Subtract = function(a) {
            this.x -= a.x, this.y -= a.y, this.z -= a.z
        }, g.prototype.Multiply = function(a) {
            void 0 === a && (a = 0), this.x *= a, this.y *= a, this.z *= a
        }
    }(),
    function() {
        {
            var a = (Box2D.Dynamics.Controllers.b2ControllerEdge, Box2D.Common.Math.b2Mat22, Box2D.Common.Math.b2Mat33, Box2D.Common.Math.b2Math),
                b = Box2D.Common.Math.b2Sweep,
                c = Box2D.Common.Math.b2Transform,
                d = Box2D.Common.Math.b2Vec2,
                e = (Box2D.Common.Math.b2Vec3, Box2D.Common.b2Color),
                f = (Box2D.Common.b2internal, Box2D.Common.b2Settings),
                g = Box2D.Collision.b2AABB,
                h = (Box2D.Collision.b2Bound, Box2D.Collision.b2BoundValues, Box2D.Collision.b2Collision, Box2D.Collision.b2ContactID, Box2D.Collision.b2ContactPoint),
                i = (Box2D.Collision.b2Distance, Box2D.Collision.b2DistanceInput, Box2D.Collision.b2DistanceOutput, Box2D.Collision.b2DistanceProxy, Box2D.Collision.b2DynamicTree, Box2D.Collision.b2DynamicTreeBroadPhase),
                j = (Box2D.Collision.b2DynamicTreeNode, Box2D.Collision.b2DynamicTreePair, Box2D.Collision.b2Manifold, Box2D.Collision.b2ManifoldPoint, Box2D.Collision.b2Point, Box2D.Collision.b2RayCastInput),
                k = Box2D.Collision.b2RayCastOutput,
                l = (Box2D.Collision.b2Segment, Box2D.Collision.b2SeparationFunction, Box2D.Collision.b2Simplex, Box2D.Collision.b2SimplexCache, Box2D.Collision.b2SimplexVertex, Box2D.Collision.b2TimeOfImpact, Box2D.Collision.b2TOIInput, Box2D.Collision.b2WorldManifold, Box2D.Collision.ClipVertex, Box2D.Collision.Features, Box2D.Collision.IBroadPhase, Box2D.Collision.Shapes.b2CircleShape),
                m = (Box2D.Collision.Shapes.b2EdgeChainDef, Box2D.Collision.Shapes.b2EdgeShape),
                n = Box2D.Collision.Shapes.b2MassData,
                o = Box2D.Collision.Shapes.b2PolygonShape,
                p = Box2D.Collision.Shapes.b2Shape,
                q = Box2D.Dynamics.b2Body,
                r = Box2D.Dynamics.b2BodyDef,
                s = Box2D.Dynamics.b2ContactFilter,
                t = Box2D.Dynamics.b2ContactImpulse,
                u = Box2D.Dynamics.b2ContactListener,
                v = Box2D.Dynamics.b2ContactManager,
                w = Box2D.Dynamics.b2DebugDraw,
                x = Box2D.Dynamics.b2DestructionListener,
                y = Box2D.Dynamics.b2FilterData,
                z = Box2D.Dynamics.b2Fixture,
                A = Box2D.Dynamics.b2FixtureDef,
                B = Box2D.Dynamics.b2Island,
                C = Box2D.Dynamics.b2TimeStep,
                D = Box2D.Dynamics.b2World,
                E = (Box2D.Dynamics.Contacts.b2CircleContact, Box2D.Dynamics.Contacts.b2Contact),
                F = (Box2D.Dynamics.Contacts.b2ContactConstraint, Box2D.Dynamics.Contacts.b2ContactConstraintPoint, Box2D.Dynamics.Contacts.b2ContactEdge, Box2D.Dynamics.Contacts.b2ContactFactory),
                G = (Box2D.Dynamics.Contacts.b2ContactRegister, Box2D.Dynamics.Contacts.b2ContactResult, Box2D.Dynamics.Contacts.b2ContactSolver),
                H = (Box2D.Dynamics.Contacts.b2EdgeAndCircleContact, Box2D.Dynamics.Contacts.b2NullContact, Box2D.Dynamics.Contacts.b2PolyAndCircleContact, Box2D.Dynamics.Contacts.b2PolyAndEdgeContact, Box2D.Dynamics.Contacts.b2PolygonContact, Box2D.Dynamics.Contacts.b2PositionSolverManifold, Box2D.Dynamics.Controllers.b2Controller, Box2D.Dynamics.Joints.b2DistanceJoint, Box2D.Dynamics.Joints.b2DistanceJointDef, Box2D.Dynamics.Joints.b2FrictionJoint, Box2D.Dynamics.Joints.b2FrictionJointDef, Box2D.Dynamics.Joints.b2GearJoint, Box2D.Dynamics.Joints.b2GearJointDef, Box2D.Dynamics.Joints.b2Jacobian, Box2D.Dynamics.Joints.b2Joint),
                I = (Box2D.Dynamics.Joints.b2JointDef, Box2D.Dynamics.Joints.b2JointEdge, Box2D.Dynamics.Joints.b2LineJoint, Box2D.Dynamics.Joints.b2LineJointDef, Box2D.Dynamics.Joints.b2MouseJoint, Box2D.Dynamics.Joints.b2MouseJointDef, Box2D.Dynamics.Joints.b2PrismaticJoint, Box2D.Dynamics.Joints.b2PrismaticJointDef, Box2D.Dynamics.Joints.b2PulleyJoint);
            Box2D.Dynamics.Joints.b2PulleyJointDef, Box2D.Dynamics.Joints.b2RevoluteJoint, Box2D.Dynamics.Joints.b2RevoluteJointDef, Box2D.Dynamics.Joints.b2WeldJoint, Box2D.Dynamics.Joints.b2WeldJointDef
        }
        q.b2Body = function() {
            this.m_xf = new c, this.m_sweep = new b, this.m_linearVelocity = new d, this.m_force = new d
        }, q.prototype.connectEdges = function(b, c, d) {
            void 0 === d && (d = 0);
            var e = Math.atan2(c.GetDirectionVector().y, c.GetDirectionVector().x),
                g = Math.tan(.5 * (e - d)),
                h = a.MulFV(g, c.GetDirectionVector());
            h = a.SubtractVV(h, c.GetNormalVector()), h = a.MulFV(f.b2_toiSlop, h), h = a.AddVV(h, c.GetVertex1());
            var i = a.AddVV(b.GetDirectionVector(), c.GetDirectionVector());
            i.Normalize();
            var j = a.Dot(b.GetDirectionVector(), c.GetNormalVector()) > 0;
            return b.SetNextEdge(c, h, i, j), c.SetPrevEdge(b, h, i, j), e
        }, q.prototype.CreateFixture = function(a) {
            if (1 == this.m_world.IsLocked()) return null;
            var b = new z;
            if (b.Create(this, this.m_xf, a), this.m_flags & q.e_activeFlag) {
                var c = this.m_world.m_contactManager.m_broadPhase;
                b.CreateProxy(c, this.m_xf)
            }
            return b.m_next = this.m_fixtureList, this.m_fixtureList = b, ++this.m_fixtureCount, b.m_body = this, b.m_density > 0 && this.ResetMassData(), this.m_world.m_flags |= D.e_newFixture, b
        }, q.prototype.CreateFixture2 = function(a, b) {
            void 0 === b && (b = 0);
            var c = new A;
            return c.shape = a, c.density = b, this.CreateFixture(c)
        }, q.prototype.DestroyFixture = function(a) {
            if (1 != this.m_world.IsLocked()) {
                for (var b = this.m_fixtureList, c = null, d = !1; null != b;) {
                    if (b == a) {
                        c ? c.m_next = a.m_next : this.m_fixtureList = a.m_next, d = !0;
                        break
                    }
                    c = b, b = b.m_next
                }
                for (var e = this.m_contactList; e;) {
                    var f = e.contact;
                    e = e.next;
                    var g = f.GetFixtureA(),
                        h = f.GetFixtureB();
                    (a == g || a == h) && this.m_world.m_contactManager.Destroy(f)
                }
                if (this.m_flags & q.e_activeFlag) {
                    var i = this.m_world.m_contactManager.m_broadPhase;
                    a.DestroyProxy(i)
                }
                a.Destroy(), a.m_body = null, a.m_next = null, --this.m_fixtureCount, this.ResetMassData()
            }
        }, q.prototype.SetPositionAndAngle = function(a, b) {
            void 0 === b && (b = 0);
            var c;
            if (1 != this.m_world.IsLocked()) {
                this.m_xf.R.Set(b), this.m_xf.position.SetV(a);
                var d = this.m_xf.R,
                    e = this.m_sweep.localCenter;
                this.m_sweep.c.x = d.col1.x * e.x + d.col2.x * e.y, this.m_sweep.c.y = d.col1.y * e.x + d.col2.y * e.y, this.m_sweep.c.x += this.m_xf.position.x, this.m_sweep.c.y += this.m_xf.position.y, this.m_sweep.c0.SetV(this.m_sweep.c), this.m_sweep.a0 = this.m_sweep.a = b;
                var f = this.m_world.m_contactManager.m_broadPhase;
                for (c = this.m_fixtureList; c; c = c.m_next) c.Synchronize(f, this.m_xf, this.m_xf);
                this.m_world.m_contactManager.FindNewContacts()
            }
        }, q.prototype.SetTransform = function(a) {
            this.SetPositionAndAngle(a.position, a.GetAngle())
        }, q.prototype.GetTransform = function() {
            return this.m_xf
        }, q.prototype.GetPosition = function() {
            return this.m_xf.position
        }, q.prototype.SetPosition = function(a) {
            this.SetPositionAndAngle(a, this.GetAngle())
        }, q.prototype.GetAngle = function() {
            return this.m_sweep.a
        }, q.prototype.SetAngle = function(a) {
            void 0 === a && (a = 0), this.SetPositionAndAngle(this.GetPosition(), a)
        }, q.prototype.GetWorldCenter = function() {
            return this.m_sweep.c
        }, q.prototype.GetLocalCenter = function() {
            return this.m_sweep.localCenter
        }, q.prototype.SetLinearVelocity = function(a) {
            this.m_type != q.b2_staticBody && this.m_linearVelocity.SetV(a)
        }, q.prototype.GetLinearVelocity = function() {
            return this.m_linearVelocity
        }, q.prototype.SetAngularVelocity = function(a) {
            void 0 === a && (a = 0), this.m_type != q.b2_staticBody && (this.m_angularVelocity = a)
        }, q.prototype.GetAngularVelocity = function() {
            return this.m_angularVelocity
        }, q.prototype.GetDefinition = function() {
            var a = new r;
            return a.type = this.GetType(), a.allowSleep = (this.m_flags & q.e_allowSleepFlag) == q.e_allowSleepFlag, a.angle = this.GetAngle(), a.angularDamping = this.m_angularDamping, a.angularVelocity = this.m_angularVelocity, a.fixedRotation = (this.m_flags & q.e_fixedRotationFlag) == q.e_fixedRotationFlag, a.bullet = (this.m_flags & q.e_bulletFlag) == q.e_bulletFlag, a.awake = (this.m_flags & q.e_awakeFlag) == q.e_awakeFlag, a.linearDamping = this.m_linearDamping, a.linearVelocity.SetV(this.GetLinearVelocity()), a.position = this.GetPosition(), a.userData = this.GetUserData(), a
        }, q.prototype.ApplyForce = function(a, b) {
            this.m_type == q.b2_dynamicBody && (0 == this.IsAwake() && this.SetAwake(!0), this.m_force.x += a.x, this.m_force.y += a.y, this.m_torque += (b.x - this.m_sweep.c.x) * a.y - (b.y - this.m_sweep.c.y) * a.x)
        }, q.prototype.ApplyTorque = function(a) {
            void 0 === a && (a = 0), this.m_type == q.b2_dynamicBody && (0 == this.IsAwake() && this.SetAwake(!0), this.m_torque += a)
        }, q.prototype.ApplyImpulse = function(a, b) {
            this.m_type == q.b2_dynamicBody && (0 == this.IsAwake() && this.SetAwake(!0), this.m_linearVelocity.x += this.m_invMass * a.x, this.m_linearVelocity.y += this.m_invMass * a.y, this.m_angularVelocity += this.m_invI * ((b.x - this.m_sweep.c.x) * a.y - (b.y - this.m_sweep.c.y) * a.x))
        }, q.prototype.Split = function(b) {
            for (var c, d = this.GetLinearVelocity().Copy(), e = this.GetAngularVelocity(), f = this.GetWorldCenter(), g = this, h = this.m_world.CreateBody(this.GetDefinition()), i = g.m_fixtureList; i;)
                if (b(i)) {
                    var j = i.m_next;
                    c ? c.m_next = j : g.m_fixtureList = j, g.m_fixtureCount--, i.m_next = h.m_fixtureList, h.m_fixtureList = i, h.m_fixtureCount++, i.m_body = h, i = j
                } else c = i, i = i.m_next;
            g.ResetMassData(), h.ResetMassData();
            var k = g.GetWorldCenter(),
                l = h.GetWorldCenter(),
                m = a.AddVV(d, a.CrossFV(e, a.SubtractVV(k, f))),
                n = a.AddVV(d, a.CrossFV(e, a.SubtractVV(l, f)));
            return g.SetLinearVelocity(m), h.SetLinearVelocity(n), g.SetAngularVelocity(e), h.SetAngularVelocity(e), g.SynchronizeFixtures(), h.SynchronizeFixtures(), h
        }, q.prototype.Merge = function(a) {
            var b;
            for (b = a.m_fixtureList; b;) {
                var c = b.m_next;
                a.m_fixtureCount--, b.m_next = this.m_fixtureList, this.m_fixtureList = b, this.m_fixtureCount++, b.m_body = e, b = c
            }
            d.m_fixtureCount = 0; {
                var d = this,
                    e = a;
                d.GetWorldCenter(), e.GetWorldCenter(), d.GetLinearVelocity().Copy(), e.GetLinearVelocity().Copy(), d.GetAngularVelocity(), e.GetAngularVelocity()
            }
            d.ResetMassData(), this.SynchronizeFixtures()
        }, q.prototype.GetMass = function() {
            return this.m_mass
        }, q.prototype.GetInertia = function() {
            return this.m_I
        }, q.prototype.GetMassData = function(a) {
            a.mass = this.m_mass, a.I = this.m_I, a.center.SetV(this.m_sweep.localCenter)
        }, q.prototype.SetMassData = function(b) {
            if (f.b2Assert(0 == this.m_world.IsLocked()), 1 != this.m_world.IsLocked() && this.m_type == q.b2_dynamicBody) {
                this.m_invMass = 0, this.m_I = 0, this.m_invI = 0, this.m_mass = b.mass, this.m_mass <= 0 && (this.m_mass = 1), this.m_invMass = 1 / this.m_mass, b.I > 0 && 0 == (this.m_flags & q.e_fixedRotationFlag) && (this.m_I = b.I - this.m_mass * (b.center.x * b.center.x + b.center.y * b.center.y), this.m_invI = 1 / this.m_I);
                var c = this.m_sweep.c.Copy();
                this.m_sweep.localCenter.SetV(b.center), this.m_sweep.c0.SetV(a.MulX(this.m_xf, this.m_sweep.localCenter)), this.m_sweep.c.SetV(this.m_sweep.c0), this.m_linearVelocity.x += this.m_angularVelocity * -(this.m_sweep.c.y - c.y), this.m_linearVelocity.y += this.m_angularVelocity * +(this.m_sweep.c.x - c.x)
            }
        }, q.prototype.ResetMassData = function() {
            if (this.m_mass = 0, this.m_invMass = 0, this.m_I = 0, this.m_invI = 0, this.m_sweep.localCenter.SetZero(), this.m_type != q.b2_staticBody && this.m_type != q.b2_kinematicBody) {
                for (var b = d.Make(0, 0), c = this.m_fixtureList; c; c = c.m_next)
                    if (0 != c.m_density) {
                        var e = c.GetMassData();
                        this.m_mass += e.mass, b.x += e.center.x * e.mass, b.y += e.center.y * e.mass, this.m_I += e.I
                    }
                this.m_mass > 0 ? (this.m_invMass = 1 / this.m_mass, b.x *= this.m_invMass, b.y *= this.m_invMass) : (this.m_mass = 1, this.m_invMass = 1), this.m_I > 0 && 0 == (this.m_flags & q.e_fixedRotationFlag) ? (this.m_I -= this.m_mass * (b.x * b.x + b.y * b.y), this.m_I *= this.m_inertiaScale, f.b2Assert(this.m_I > 0), this.m_invI = 1 / this.m_I) : (this.m_I = 0, this.m_invI = 0);
                var g = this.m_sweep.c.Copy();
                this.m_sweep.localCenter.SetV(b), this.m_sweep.c0.SetV(a.MulX(this.m_xf, this.m_sweep.localCenter)), this.m_sweep.c.SetV(this.m_sweep.c0), this.m_linearVelocity.x += this.m_angularVelocity * -(this.m_sweep.c.y - g.y), this.m_linearVelocity.y += this.m_angularVelocity * +(this.m_sweep.c.x - g.x)
            }
        }, q.prototype.GetWorldPoint = function(a) {
            var b = this.m_xf.R,
                c = new d(b.col1.x * a.x + b.col2.x * a.y, b.col1.y * a.x + b.col2.y * a.y);
            return c.x += this.m_xf.position.x, c.y += this.m_xf.position.y, c
        }, q.prototype.GetWorldVector = function(b) {
            return a.MulMV(this.m_xf.R, b)
        }, q.prototype.GetLocalPoint = function(b) {
            return a.MulXT(this.m_xf, b)
        }, q.prototype.GetLocalVector = function(b) {
            return a.MulTMV(this.m_xf.R, b)
        }, q.prototype.GetLinearVelocityFromWorldPoint = function(a) {
            return new d(this.m_linearVelocity.x - this.m_angularVelocity * (a.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (a.x - this.m_sweep.c.x))
        }, q.prototype.GetLinearVelocityFromLocalPoint = function(a) {
            var b = this.m_xf.R,
                c = new d(b.col1.x * a.x + b.col2.x * a.y, b.col1.y * a.x + b.col2.y * a.y);
            return c.x += this.m_xf.position.x, c.y += this.m_xf.position.y, new d(this.m_linearVelocity.x - this.m_angularVelocity * (c.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (c.x - this.m_sweep.c.x))
        }, q.prototype.GetLinearDamping = function() {
            return this.m_linearDamping
        }, q.prototype.SetLinearDamping = function(a) {
            void 0 === a && (a = 0), this.m_linearDamping = a
        }, q.prototype.GetAngularDamping = function() {
            return this.m_angularDamping
        }, q.prototype.SetAngularDamping = function(a) {
            void 0 === a && (a = 0), this.m_angularDamping = a
        }, q.prototype.SetType = function(a) {
            if (void 0 === a && (a = 0), this.m_type != a) {
                this.m_type = a, this.ResetMassData(), this.m_type == q.b2_staticBody && (this.m_linearVelocity.SetZero(), this.m_angularVelocity = 0), this.SetAwake(!0), this.m_force.SetZero(), this.m_torque = 0;
                for (var b = this.m_contactList; b; b = b.next) b.contact.FlagForFiltering()
            }
        }, q.prototype.GetType = function() {
            return this.m_type
        }, q.prototype.SetBullet = function(a) {
            a ? this.m_flags |= q.e_bulletFlag : this.m_flags &= ~q.e_bulletFlag
        }, q.prototype.IsBullet = function() {
            return (this.m_flags & q.e_bulletFlag) == q.e_bulletFlag
        }, q.prototype.SetSleepingAllowed = function(a) {
            a ? this.m_flags |= q.e_allowSleepFlag : (this.m_flags &= ~q.e_allowSleepFlag, this.SetAwake(!0))
        }, q.prototype.SetAwake = function(a) {
            a ? (this.m_flags |= q.e_awakeFlag, this.m_sleepTime = 0) : (this.m_flags &= ~q.e_awakeFlag, this.m_sleepTime = 0, this.m_linearVelocity.SetZero(), this.m_angularVelocity = 0, this.m_force.SetZero(), this.m_torque = 0)
        }, q.prototype.IsAwake = function() {
            return (this.m_flags & q.e_awakeFlag) == q.e_awakeFlag
        }, q.prototype.SetFixedRotation = function(a) {
            a ? this.m_flags |= q.e_fixedRotationFlag : this.m_flags &= ~q.e_fixedRotationFlag, this.ResetMassData()
        }, q.prototype.IsFixedRotation = function() {
            return (this.m_flags & q.e_fixedRotationFlag) == q.e_fixedRotationFlag
        }, q.prototype.SetActive = function(a) {
            if (a != this.IsActive()) {
                var b, c;
                if (a)
                    for (this.m_flags |= q.e_activeFlag, b = this.m_world.m_contactManager.m_broadPhase, c = this.m_fixtureList; c; c = c.m_next) c.CreateProxy(b, this.m_xf);
                else {
                    for (this.m_flags &= ~q.e_activeFlag, b = this.m_world.m_contactManager.m_broadPhase, c = this.m_fixtureList; c; c = c.m_next) c.DestroyProxy(b);
                    for (var d = this.m_contactList; d;) {
                        var e = d;
                        d = d.next, this.m_world.m_contactManager.Destroy(e.contact)
                    }
                    this.m_contactList = null
                }
            }
        }, q.prototype.IsActive = function() {
            return (this.m_flags & q.e_activeFlag) == q.e_activeFlag
        }, q.prototype.IsSleepingAllowed = function() {
            return (this.m_flags & q.e_allowSleepFlag) == q.e_allowSleepFlag
        }, q.prototype.GetFixtureList = function() {
            return this.m_fixtureList
        }, q.prototype.GetJointList = function() {
            return this.m_jointList
        }, q.prototype.GetControllerList = function() {
            return this.m_controllerList
        }, q.prototype.GetContactList = function() {
            return this.m_contactList
        }, q.prototype.GetNext = function() {
            return this.m_next
        }, q.prototype.GetUserData = function() {
            return this.m_userData
        }, q.prototype.SetUserData = function(a) {
            this.m_userData = a
        }, q.prototype.GetWorld = function() {
            return this.m_world
        }, q.prototype.b2Body = function(a, b) {
            this.m_flags = 0, a.bullet && (this.m_flags |= q.e_bulletFlag), a.fixedRotation && (this.m_flags |= q.e_fixedRotationFlag), a.allowSleep && (this.m_flags |= q.e_allowSleepFlag), a.awake && (this.m_flags |= q.e_awakeFlag), a.active && (this.m_flags |= q.e_activeFlag), this.m_world = b, this.m_xf.position.SetV(a.position), this.m_xf.R.Set(a.angle), this.m_sweep.localCenter.SetZero(), this.m_sweep.t0 = 1, this.m_sweep.a0 = this.m_sweep.a = a.angle;
            var c = this.m_xf.R,
                d = this.m_sweep.localCenter;
            this.m_sweep.c.x = c.col1.x * d.x + c.col2.x * d.y, this.m_sweep.c.y = c.col1.y * d.x + c.col2.y * d.y, this.m_sweep.c.x += this.m_xf.position.x, this.m_sweep.c.y += this.m_xf.position.y, this.m_sweep.c0.SetV(this.m_sweep.c), this.m_jointList = null, this.m_controllerList = null, this.m_contactList = null, this.m_controllerCount = 0, this.m_prev = null, this.m_next = null, this.m_linearVelocity.SetV(a.linearVelocity), this.m_angularVelocity = a.angularVelocity, this.m_linearDamping = a.linearDamping, this.m_angularDamping = a.angularDamping, this.m_force.Set(0, 0), this.m_torque = 0, this.m_sleepTime = 0, this.m_type = a.type, this.m_type == q.b2_dynamicBody ? (this.m_mass = 1, this.m_invMass = 1) : (this.m_mass = 0, this.m_invMass = 0), this.m_I = 0, this.m_invI = 0, this.m_inertiaScale = a.inertiaScale, this.m_userData = a.userData, this.m_fixtureList = null, this.m_fixtureCount = 0
        }, q.prototype.SynchronizeFixtures = function() {
            var a = q.s_xf1;
            a.R.Set(this.m_sweep.a0);
            var b = a.R,
                c = this.m_sweep.localCenter;
            a.position.x = this.m_sweep.c0.x - (b.col1.x * c.x + b.col2.x * c.y), a.position.y = this.m_sweep.c0.y - (b.col1.y * c.x + b.col2.y * c.y);
            var d, e = this.m_world.m_contactManager.m_broadPhase;
            for (d = this.m_fixtureList; d; d = d.m_next) d.Synchronize(e, a, this.m_xf)
        }, q.prototype.SynchronizeTransform = function() {
            this.m_xf.R.Set(this.m_sweep.a);
            var a = this.m_xf.R,
                b = this.m_sweep.localCenter;
            this.m_xf.position.x = this.m_sweep.c.x - (a.col1.x * b.x + a.col2.x * b.y), this.m_xf.position.y = this.m_sweep.c.y - (a.col1.y * b.x + a.col2.y * b.y)
        }, q.prototype.ShouldCollide = function(a) {
            if (this.m_type != q.b2_dynamicBody && a.m_type != q.b2_dynamicBody) return !1;
            for (var b = this.m_jointList; b; b = b.next)
                if (b.other == a && 0 == b.joint.m_collideConnected) return !1;
            return !0
        }, q.prototype.Advance = function(a) {
            void 0 === a && (a = 0), this.m_sweep.Advance(a), this.m_sweep.c.SetV(this.m_sweep.c0), this.m_sweep.a = this.m_sweep.a0, this.SynchronizeTransform()
        }, Box2D.postDefs.push(function() {
            Box2D.Dynamics.b2Body.s_xf1 = new c, Box2D.Dynamics.b2Body.e_islandFlag = 1, Box2D.Dynamics.b2Body.e_awakeFlag = 2, Box2D.Dynamics.b2Body.e_allowSleepFlag = 4, Box2D.Dynamics.b2Body.e_bulletFlag = 8, Box2D.Dynamics.b2Body.e_fixedRotationFlag = 16, Box2D.Dynamics.b2Body.e_activeFlag = 32, Box2D.Dynamics.b2Body.b2_staticBody = 0, Box2D.Dynamics.b2Body.b2_kinematicBody = 1, Box2D.Dynamics.b2Body.b2_dynamicBody = 2
        }), r.b2BodyDef = function() {
            this.position = new d, this.linearVelocity = new d
        }, r.prototype.b2BodyDef = function() {
            this.userData = null, this.position.Set(0, 0), this.angle = 0, this.linearVelocity.Set(0, 0), this.angularVelocity = 0, this.linearDamping = 0, this.angularDamping = 0, this.allowSleep = !0, this.awake = !0, this.fixedRotation = !1, this.bullet = !1, this.type = q.b2_staticBody, this.active = !0, this.inertiaScale = 1
        }, s.b2ContactFilter = function() {}, s.prototype.ShouldCollide = function(a, b) {
            var c = a.GetFilterData(),
                d = b.GetFilterData();
            if (c.groupIndex == d.groupIndex && 0 != c.groupIndex) return c.groupIndex > 0;
            var e = 0 != (c.maskBits & d.categoryBits) && 0 != (c.categoryBits & d.maskBits);
            return e
        }, s.prototype.RayCollide = function(a, b) {
            return a ? this.ShouldCollide(a instanceof z ? a : null, b) : !0
        }, Box2D.postDefs.push(function() {
            Box2D.Dynamics.b2ContactFilter.b2_defaultFilter = new s
        }), t.b2ContactImpulse = function() {
            this.normalImpulses = new Vector_a2j_Number(f.b2_maxManifoldPoints), this.tangentImpulses = new Vector_a2j_Number(f.b2_maxManifoldPoints)
        }, u.b2ContactListener = function() {}, u.prototype.BeginContact = function() {}, u.prototype.EndContact = function() {}, u.prototype.PreSolve = function() {}, u.prototype.PostSolve = function() {}, Box2D.postDefs.push(function() {
            Box2D.Dynamics.b2ContactListener.b2_defaultListener = new u
        }), v.b2ContactManager = function() {}, v.prototype.b2ContactManager = function() {
            this.m_world = null, this.m_contactCount = 0, this.m_contactFilter = s.b2_defaultFilter, this.m_contactListener = u.b2_defaultListener, this.m_contactFactory = new F(this.m_allocator), this.m_broadPhase = new i
        }, v.prototype.AddPair = function(a, b) {
            var c = a instanceof z ? a : null,
                d = b instanceof z ? b : null,
                e = c.GetBody(),
                f = d.GetBody();
            if (e != f) {
                for (var g = f.GetContactList(); g;) {
                    if (g.other == e) {
                        var h = g.contact.GetFixtureA(),
                            i = g.contact.GetFixtureB();
                        if (h == c && i == d) return;
                        if (h == d && i == c) return
                    }
                    g = g.next
                }
                if (0 != f.ShouldCollide(e) && 0 != this.m_contactFilter.ShouldCollide(c, d)) {
                    var j = this.m_contactFactory.Create(c, d);
                    c = j.GetFixtureA(), d = j.GetFixtureB(), e = c.m_body, f = d.m_body, j.m_prev = null, j.m_next = this.m_world.m_contactList, null != this.m_world.m_contactList && (this.m_world.m_contactList.m_prev = j), this.m_world.m_contactList = j, j.m_nodeA.contact = j, j.m_nodeA.other = f, j.m_nodeA.prev = null, j.m_nodeA.next = e.m_contactList, null != e.m_contactList && (e.m_contactList.prev = j.m_nodeA), e.m_contactList = j.m_nodeA, j.m_nodeB.contact = j, j.m_nodeB.other = e, j.m_nodeB.prev = null, j.m_nodeB.next = f.m_contactList, null != f.m_contactList && (f.m_contactList.prev = j.m_nodeB), f.m_contactList = j.m_nodeB, ++this.m_world.m_contactCount
                }
            }
        }, v.prototype.FindNewContacts = function() {
            this.m_broadPhase.UpdatePairs(Box2D.generateCallback(this, this.AddPair))
        }, v.prototype.Destroy = function(a) {
            var b = a.GetFixtureA(),
                c = a.GetFixtureB(),
                d = b.GetBody(),
                e = c.GetBody();
            a.IsTouching() && this.m_contactListener.EndContact(a), a.m_prev && (a.m_prev.m_next = a.m_next), a.m_next && (a.m_next.m_prev = a.m_prev), a == this.m_world.m_contactList && (this.m_world.m_contactList = a.m_next), a.m_nodeA.prev && (a.m_nodeA.prev.next = a.m_nodeA.next), a.m_nodeA.next && (a.m_nodeA.next.prev = a.m_nodeA.prev), a.m_nodeA == d.m_contactList && (d.m_contactList = a.m_nodeA.next), a.m_nodeB.prev && (a.m_nodeB.prev.next = a.m_nodeB.next), a.m_nodeB.next && (a.m_nodeB.next.prev = a.m_nodeB.prev), a.m_nodeB == e.m_contactList && (e.m_contactList = a.m_nodeB.next), this.m_contactFactory.Destroy(a), --this.m_contactCount
        }, v.prototype.Collide = function() {
            for (var a = this.m_world.m_contactList; a;) {
                var b = a.GetFixtureA(),
                    c = a.GetFixtureB(),
                    d = b.GetBody(),
                    e = c.GetBody();
                if (0 != d.IsAwake() || 0 != e.IsAwake()) {
                    if (a.m_flags & E.e_filterFlag) {
                        if (0 == e.ShouldCollide(d)) {
                            var f = a;
                            a = f.GetNext(), this.Destroy(f);
                            continue
                        }
                        if (0 == this.m_contactFilter.ShouldCollide(b, c)) {
                            f = a, a = f.GetNext(), this.Destroy(f);
                            continue
                        }
                        a.m_flags &= ~E.e_filterFlag
                    }
                    var g = b.m_proxy,
                        h = c.m_proxy,
                        i = this.m_broadPhase.TestOverlap(g, h);
                    0 != i ? (a.Update(this.m_contactListener), a = a.GetNext()) : (f = a, a = f.GetNext(), this.Destroy(f))
                } else a = a.GetNext()
            }
        }, Box2D.postDefs.push(function() {
            Box2D.Dynamics.b2ContactManager.s_evalCP = new h
        }), w.b2DebugDraw = function() {}, w.prototype.b2DebugDraw = function() {}, w.prototype.SetFlags = function(a) {
            void 0 === a && (a = 0)
        }, w.prototype.GetFlags = function() {}, w.prototype.AppendFlags = function(a) {
            void 0 === a && (a = 0)
        }, w.prototype.ClearFlags = function(a) {
            void 0 === a && (a = 0)
        }, w.prototype.SetSprite = function() {}, w.prototype.GetSprite = function() {}, w.prototype.SetDrawScale = function(a) {
            void 0 === a && (a = 0)
        }, w.prototype.GetDrawScale = function() {}, w.prototype.SetLineThickness = function(a) {
            void 0 === a && (a = 0)
        }, w.prototype.GetLineThickness = function() {}, w.prototype.SetAlpha = function(a) {
            void 0 === a && (a = 0)
        }, w.prototype.GetAlpha = function() {}, w.prototype.SetFillAlpha = function(a) {
            void 0 === a && (a = 0)
        }, w.prototype.GetFillAlpha = function() {}, w.prototype.SetXFormScale = function(a) {
            void 0 === a && (a = 0)
        }, w.prototype.GetXFormScale = function() {}, w.prototype.DrawPolygon = function(a, b) {
            void 0 === b && (b = 0)
        }, w.prototype.DrawSolidPolygon = function(a, b) {
            void 0 === b && (b = 0)
        }, w.prototype.DrawCircle = function(a, b) {
            void 0 === b && (b = 0)
        }, w.prototype.DrawSolidCircle = function(a, b) {
            void 0 === b && (b = 0)
        }, w.prototype.DrawSegment = function() {}, w.prototype.DrawTransform = function() {}, Box2D.postDefs.push(function() {
            Box2D.Dynamics.b2DebugDraw.e_shapeBit = 1, Box2D.Dynamics.b2DebugDraw.e_jointBit = 2, Box2D.Dynamics.b2DebugDraw.e_aabbBit = 4, Box2D.Dynamics.b2DebugDraw.e_pairBit = 8, Box2D.Dynamics.b2DebugDraw.e_centerOfMassBit = 16, Box2D.Dynamics.b2DebugDraw.e_controllerBit = 32
        }), x.b2DestructionListener = function() {}, x.prototype.SayGoodbyeJoint = function() {}, x.prototype.SayGoodbyeFixture = function() {}, y.b2FilterData = function() {
            this.categoryBits = 1, this.maskBits = 65535, this.groupIndex = 0
        }, y.prototype.Copy = function() {
            var a = new y;
            return a.categoryBits = this.categoryBits, a.maskBits = this.maskBits, a.groupIndex = this.groupIndex, a
        }, z.b2Fixture = function() {
            this.m_filter = new y
        }, z.prototype.GetType = function() {
            return this.m_shape.GetType()
        }, z.prototype.GetShape = function() {
            return this.m_shape
        }, z.prototype.SetSensor = function(a) {
            if (this.m_isSensor != a && (this.m_isSensor = a, null != this.m_body))
                for (var b = this.m_body.GetContactList(); b;) {
                    var c = b.contact,
                        d = c.GetFixtureA(),
                        e = c.GetFixtureB();
                    (d == this || e == this) && c.SetSensor(d.IsSensor() || e.IsSensor()), b = b.next
                }
        }, z.prototype.IsSensor = function() {
            return this.m_isSensor
        }, z.prototype.SetFilterData = function(a) {
            if (this.m_filter = a.Copy(), !this.m_body)
                for (var b = this.m_body.GetContactList(); b;) {
                    var c = b.contact,
                        d = c.GetFixtureA(),
                        e = c.GetFixtureB();
                    (d == this || e == this) && c.FlagForFiltering(), b = b.next
                }
        }, z.prototype.GetFilterData = function() {
            return this.m_filter.Copy()
        }, z.prototype.GetBody = function() {
            return this.m_body
        }, z.prototype.GetNext = function() {
            return this.m_next
        }, z.prototype.GetUserData = function() {
            return this.m_userData
        }, z.prototype.SetUserData = function(a) {
            this.m_userData = a
        }, z.prototype.TestPoint = function(a) {
            return this.m_shape.TestPoint(this.m_body.GetTransform(), a)
        }, z.prototype.RayCast = function(a, b) {
            return this.m_shape.RayCast(a, b, this.m_body.GetTransform())
        }, z.prototype.GetMassData = function(a) {
            return void 0 === a && (a = null), null == a && (a = new n), this.m_shape.ComputeMass(a, this.m_density), a
        }, z.prototype.SetDensity = function(a) {
            void 0 === a && (a = 0), this.m_density = a
        }, z.prototype.GetDensity = function() {
            return this.m_density
        }, z.prototype.GetFriction = function() {
            return this.m_friction
        }, z.prototype.SetFriction = function(a) {
            void 0 === a && (a = 0), this.m_friction = a
        }, z.prototype.GetRestitution = function() {
            return this.m_restitution
        }, z.prototype.SetRestitution = function(a) {
            void 0 === a && (a = 0), this.m_restitution = a
        }, z.prototype.GetAABB = function() {
            return this.m_aabb
        }, z.prototype.b2Fixture = function() {
            this.m_aabb = new g, this.m_userData = null, this.m_body = null, this.m_next = null, this.m_shape = null, this.m_density = 0, this.m_friction = 0, this.m_restitution = 0
        }, z.prototype.Create = function(a, b, c) {
            this.m_userData = c.userData, this.m_friction = c.friction, this.m_restitution = c.restitution, this.m_body = a, this.m_next = null, this.m_filter = c.filter.Copy(), this.m_isSensor = c.isSensor, this.m_shape = c.shape.Copy(), this.m_density = c.density
        }, z.prototype.Destroy = function() {
            this.m_shape = null
        }, z.prototype.CreateProxy = function(a, b) {
            this.m_shape.ComputeAABB(this.m_aabb, b), this.m_proxy = a.CreateProxy(this.m_aabb, this)
        }, z.prototype.DestroyProxy = function(a) {
            null != this.m_proxy && (a.DestroyProxy(this.m_proxy), this.m_proxy = null)
        }, z.prototype.Synchronize = function(b, c, d) {
            if (this.m_proxy) {
                var e = new g,
                    f = new g;
                this.m_shape.ComputeAABB(e, c), this.m_shape.ComputeAABB(f, d), this.m_aabb.Combine(e, f);
                var h = a.SubtractVV(d.position, c.position);
                b.MoveProxy(this.m_proxy, this.m_aabb, h)
            }
        }, A.b2FixtureDef = function() {
            this.filter = new y
        }, A.prototype.b2FixtureDef = function() {
            this.shape = null, this.userData = null, this.friction = .2, this.restitution = 0, this.density = 0, this.filter.categoryBits = 1, this.filter.maskBits = 65535, this.filter.groupIndex = 0, this.isSensor = !1
        }, B.b2Island = function() {}, B.prototype.b2Island = function() {
            this.m_bodies = new Vector, this.m_contacts = new Vector, this.m_joints = new Vector
        }, B.prototype.Initialize = function(a, b, c, d, e, f) {
            void 0 === a && (a = 0), void 0 === b && (b = 0), void 0 === c && (c = 0);
            var g = 0;
            for (this.m_bodyCapacity = a, this.m_contactCapacity = b, this.m_jointCapacity = c, this.m_bodyCount = 0, this.m_contactCount = 0, this.m_jointCount = 0, this.m_allocator = d, this.m_listener = e, this.m_contactSolver = f, g = this.m_bodies.length; a > g; g++) this.m_bodies[g] = null;
            for (g = this.m_contacts.length; b > g; g++) this.m_contacts[g] = null;
            for (g = this.m_joints.length; c > g; g++) this.m_joints[g] = null
        }, B.prototype.Clear = function() {
            this.m_bodyCount = 0, this.m_contactCount = 0, this.m_jointCount = 0
        }, B.prototype.Solve = function(b, c, d) {
            var e, g, h = 0,
                i = 0;
            for (h = 0; h < this.m_bodyCount; ++h) e = this.m_bodies[h], e.GetType() == q.b2_dynamicBody && (e.m_linearVelocity.x += b.dt * (c.x + e.m_invMass * e.m_force.x), e.m_linearVelocity.y += b.dt * (c.y + e.m_invMass * e.m_force.y), e.m_angularVelocity += b.dt * e.m_invI * e.m_torque, e.m_linearVelocity.Multiply(a.Clamp(1 - b.dt * e.m_linearDamping, 0, 1)), e.m_angularVelocity *= a.Clamp(1 - b.dt * e.m_angularDamping, 0, 1));
            this.m_contactSolver.Initialize(b, this.m_contacts, this.m_contactCount, this.m_allocator);
            var j = this.m_contactSolver;
            for (j.InitVelocityConstraints(b), h = 0; h < this.m_jointCount; ++h) g = this.m_joints[h], g.InitVelocityConstraints(b);
            for (h = 0; h < b.velocityIterations; ++h) {
                for (i = 0; i < this.m_jointCount; ++i) g = this.m_joints[i], g.SolveVelocityConstraints(b);
                j.SolveVelocityConstraints()
            }
            for (h = 0; h < this.m_jointCount; ++h) g = this.m_joints[h], g.FinalizeVelocityConstraints();
            for (j.FinalizeVelocityConstraints(), h = 0; h < this.m_bodyCount; ++h)
                if (e = this.m_bodies[h], e.GetType() != q.b2_staticBody) {
                    var k = b.dt * e.m_linearVelocity.x,
                        l = b.dt * e.m_linearVelocity.y;
                    k * k + l * l > f.b2_maxTranslationSquared && (e.m_linearVelocity.Normalize(), e.m_linearVelocity.x *= f.b2_maxTranslation * b.inv_dt, e.m_linearVelocity.y *= f.b2_maxTranslation * b.inv_dt);
                    var m = b.dt * e.m_angularVelocity;
                    m * m > f.b2_maxRotationSquared && (e.m_angularVelocity = e.m_angularVelocity < 0 ? -f.b2_maxRotation * b.inv_dt : f.b2_maxRotation * b.inv_dt), e.m_sweep.c0.SetV(e.m_sweep.c), e.m_sweep.a0 = e.m_sweep.a, e.m_sweep.c.x += b.dt * e.m_linearVelocity.x, e.m_sweep.c.y += b.dt * e.m_linearVelocity.y, e.m_sweep.a += b.dt * e.m_angularVelocity, e.SynchronizeTransform()
                }
            for (h = 0; h < b.positionIterations; ++h) {
                var n = j.SolvePositionConstraints(f.b2_contactBaumgarte),
                    o = !0;
                for (i = 0; i < this.m_jointCount; ++i) {
                    g = this.m_joints[i];
                    var p = g.SolvePositionConstraints(f.b2_contactBaumgarte);
                    o = o && p
                }
                if (n && o) break
            }
            if (this.Report(j.m_constraints), d) {
                var r = Number.MAX_VALUE,
                    s = f.b2_linearSleepTolerance * f.b2_linearSleepTolerance,
                    t = f.b2_angularSleepTolerance * f.b2_angularSleepTolerance;
                for (h = 0; h < this.m_bodyCount; ++h) e = this.m_bodies[h], e.GetType() != q.b2_staticBody && (0 == (e.m_flags & q.e_allowSleepFlag) && (e.m_sleepTime = 0, r = 0), 0 == (e.m_flags & q.e_allowSleepFlag) || e.m_angularVelocity * e.m_angularVelocity > t || a.Dot(e.m_linearVelocity, e.m_linearVelocity) > s ? (e.m_sleepTime = 0, r = 0) : (e.m_sleepTime += b.dt, r = a.Min(r, e.m_sleepTime)));
                if (r >= f.b2_timeToSleep)
                    for (h = 0; h < this.m_bodyCount; ++h) e = this.m_bodies[h], e.SetAwake(!1)
            }
        }, B.prototype.SolveTOI = function(a) {
            var b = 0,
                c = 0;
            this.m_contactSolver.Initialize(a, this.m_contacts, this.m_contactCount, this.m_allocator);
            var d = this.m_contactSolver;
            for (b = 0; b < this.m_jointCount; ++b) this.m_joints[b].InitVelocityConstraints(a);
            for (b = 0; b < a.velocityIterations; ++b)
                for (d.SolveVelocityConstraints(), c = 0; c < this.m_jointCount; ++c) this.m_joints[c].SolveVelocityConstraints(a);
            for (b = 0; b < this.m_bodyCount; ++b) {
                var e = this.m_bodies[b];
                if (e.GetType() != q.b2_staticBody) {
                    var g = a.dt * e.m_linearVelocity.x,
                        h = a.dt * e.m_linearVelocity.y;
                    g * g + h * h > f.b2_maxTranslationSquared && (e.m_linearVelocity.Normalize(), e.m_linearVelocity.x *= f.b2_maxTranslation * a.inv_dt, e.m_linearVelocity.y *= f.b2_maxTranslation * a.inv_dt);
                    var i = a.dt * e.m_angularVelocity;
                    i * i > f.b2_maxRotationSquared && (e.m_angularVelocity = e.m_angularVelocity < 0 ? -f.b2_maxRotation * a.inv_dt : f.b2_maxRotation * a.inv_dt), e.m_sweep.c0.SetV(e.m_sweep.c), e.m_sweep.a0 = e.m_sweep.a, e.m_sweep.c.x += a.dt * e.m_linearVelocity.x, e.m_sweep.c.y += a.dt * e.m_linearVelocity.y, e.m_sweep.a += a.dt * e.m_angularVelocity, e.SynchronizeTransform()
                }
            }
            var j = .75;
            for (b = 0; b < a.positionIterations; ++b) {
                var k = d.SolvePositionConstraints(j),
                    l = !0;
                for (c = 0; c < this.m_jointCount; ++c) {
                    var m = this.m_joints[c].SolvePositionConstraints(f.b2_contactBaumgarte);
                    l = l && m
                }
                if (k && l) break
            }
            this.Report(d.m_constraints)
        }, B.prototype.Report = function(a) {
            if (null != this.m_listener)
                for (var b = 0; b < this.m_contactCount; ++b) {
                    for (var c = this.m_contacts[b], d = a[b], e = 0; e < d.pointCount; ++e) B.s_impulse.normalImpulses[e] = d.points[e].normalImpulse, B.s_impulse.tangentImpulses[e] = d.points[e].tangentImpulse;
                    this.m_listener.PostSolve(c, B.s_impulse)
                }
        }, B.prototype.AddBody = function(a) {
            a.m_islandIndex = this.m_bodyCount, this.m_bodies[this.m_bodyCount++] = a
        }, B.prototype.AddContact = function(a) {
            this.m_contacts[this.m_contactCount++] = a
        }, B.prototype.AddJoint = function(a) {
            this.m_joints[this.m_jointCount++] = a
        }, Box2D.postDefs.push(function() {
            Box2D.Dynamics.b2Island.s_impulse = new t
        }), C.b2TimeStep = function() {}, C.prototype.Set = function(a) {
            this.dt = a.dt, this.inv_dt = a.inv_dt, this.positionIterations = a.positionIterations, this.velocityIterations = a.velocityIterations, this.warmStarting = a.warmStarting
        }, D.b2World = function() {
            this.s_stack = new Vector, this.m_contactManager = new v, this.m_contactSolver = new G, this.m_island = new B
        }, D.prototype.b2World = function(a, b) {
            this.m_destructionListener = null, this.m_debugDraw = null, this.m_bodyList = null, this.m_contactList = null, this.m_jointList = null, this.m_controllerList = null, this.m_bodyCount = 0, this.m_contactCount = 0, this.m_jointCount = 0, this.m_controllerCount = 0, D.m_warmStarting = !0, D.m_continuousPhysics = !0, this.m_allowSleep = b, a.y = a.y, this.m_gravity = a, this.m_inv_dt0 = 0, this.m_contactManager.m_world = this;
            var c = new r;
            this.m_groundBody = this.CreateBody(c)
        }, D.prototype.SetDestructionListener = function(a) {
            this.m_destructionListener = a
        }, D.prototype.SetContactFilter = function(a) {
            this.m_contactManager.m_contactFilter = a
        }, D.prototype.SetContactListener = function(a) {
            this.m_contactManager.m_contactListener = a
        }, D.prototype.SetDebugDraw = function(a) {
            this.m_debugDraw = a
        }, D.prototype.SetBroadPhase = function(a) {
            var b = this.m_contactManager.m_broadPhase;
            this.m_contactManager.m_broadPhase = a;
            for (var c = this.m_bodyList; c; c = c.m_next)
                for (var d = c.m_fixtureList; d; d = d.m_next) d.m_proxy = a.CreateProxy(b.GetFatAABB(d.m_proxy), d)
        }, D.prototype.Validate = function() {
            this.m_contactManager.m_broadPhase.Validate()
        }, D.prototype.GetProxyCount = function() {
            return this.m_contactManager.m_broadPhase.GetProxyCount()
        }, D.prototype.CreateBody = function(a) {
            if (1 == this.IsLocked()) return null;
            var b = new q(a, this);
            return b.m_prev = null, b.m_next = this.m_bodyList, this.m_bodyList && (this.m_bodyList.m_prev = b), this.m_bodyList = b, ++this.m_bodyCount, b
        }, D.prototype.DestroyBody = function(a) {
            if (1 != this.IsLocked()) {
                for (var b = a.m_jointList; b;) {
                    var c = b;
                    b = b.next, this.m_destructionListener && this.m_destructionListener.SayGoodbyeJoint(c.joint), this.DestroyJoint(c.joint)
                }
                for (var d = a.m_controllerList; d;) {
                    var e = d;
                    d = d.nextController, e.controller.RemoveBody(a)
                }
                for (var f = a.m_contactList; f;) {
                    var g = f;
                    f = f.next, this.m_contactManager.Destroy(g.contact)
                }
                a.m_contactList = null;
                for (var h = a.m_fixtureList; h;) {
                    var i = h;
                    h = h.m_next, this.m_destructionListener && this.m_destructionListener.SayGoodbyeFixture(i), i.DestroyProxy(this.m_contactManager.m_broadPhase), i.Destroy()
                }
                a.m_fixtureList = null, a.m_fixtureCount = 0, a.m_prev && (a.m_prev.m_next = a.m_next), a.m_next && (a.m_next.m_prev = a.m_prev), a == this.m_bodyList && (this.m_bodyList = a.m_next), --this.m_bodyCount
            }
        }, D.prototype.CreateJoint = function(a) {
            var b = H.Create(a, null);
            b.m_prev = null, b.m_next = this.m_jointList, this.m_jointList && (this.m_jointList.m_prev = b), this.m_jointList = b, ++this.m_jointCount, b.m_edgeA.joint = b, b.m_edgeA.other = b.m_bodyB, b.m_edgeA.prev = null, b.m_edgeA.next = b.m_bodyA.m_jointList, b.m_bodyA.m_jointList && (b.m_bodyA.m_jointList.prev = b.m_edgeA), b.m_bodyA.m_jointList = b.m_edgeA, b.m_edgeB.joint = b, b.m_edgeB.other = b.m_bodyA, b.m_edgeB.prev = null, b.m_edgeB.next = b.m_bodyB.m_jointList, b.m_bodyB.m_jointList && (b.m_bodyB.m_jointList.prev = b.m_edgeB), b.m_bodyB.m_jointList = b.m_edgeB;
            var c = a.bodyA,
                d = a.bodyB;
            if (0 == a.collideConnected)
                for (var e = d.GetContactList(); e;) e.other == c && e.contact.FlagForFiltering(), e = e.next;
            return b
        }, D.prototype.DestroyJoint = function(a) {
            var b = a.m_collideConnected;
            a.m_prev && (a.m_prev.m_next = a.m_next), a.m_next && (a.m_next.m_prev = a.m_prev), a == this.m_jointList && (this.m_jointList = a.m_next);
            var c = a.m_bodyA,
                d = a.m_bodyB;
            if (c.SetAwake(!0), d.SetAwake(!0), a.m_edgeA.prev && (a.m_edgeA.prev.next = a.m_edgeA.next), a.m_edgeA.next && (a.m_edgeA.next.prev = a.m_edgeA.prev), a.m_edgeA == c.m_jointList && (c.m_jointList = a.m_edgeA.next), a.m_edgeA.prev = null, a.m_edgeA.next = null, a.m_edgeB.prev && (a.m_edgeB.prev.next = a.m_edgeB.next), a.m_edgeB.next && (a.m_edgeB.next.prev = a.m_edgeB.prev), a.m_edgeB == d.m_jointList && (d.m_jointList = a.m_edgeB.next), a.m_edgeB.prev = null, a.m_edgeB.next = null, H.Destroy(a, null), --this.m_jointCount, 0 == b)
                for (var e = d.GetContactList(); e;) e.other == c && e.contact.FlagForFiltering(), e = e.next
        }, D.prototype.AddController = function(a) {
            return a.m_next = this.m_controllerList, a.m_prev = null, this.m_controllerList = a, a.m_world = this, this.m_controllerCount++, a
        }, D.prototype.RemoveController = function(a) {
            a.m_prev && (a.m_prev.m_next = a.m_next), a.m_next && (a.m_next.m_prev = a.m_prev), this.m_controllerList == a && (this.m_controllerList = a.m_next), this.m_controllerCount--
        }, D.prototype.CreateController = function(a) {
            if (a.m_world != this) throw new Error("Controller can only be a member of one world");
            return a.m_next = this.m_controllerList, a.m_prev = null, this.m_controllerList && (this.m_controllerList.m_prev = a), this.m_controllerList = a, ++this.m_controllerCount, a.m_world = this, a
        }, D.prototype.DestroyController = function(a) {
            a.Clear(), a.m_next && (a.m_next.m_prev = a.m_prev), a.m_prev && (a.m_prev.m_next = a.m_next), a == this.m_controllerList && (this.m_controllerList = a.m_next), --this.m_controllerCount
        }, D.prototype.SetWarmStarting = function(a) {
            D.m_warmStarting = a
        }, D.prototype.SetContinuousPhysics = function(a) {
            D.m_continuousPhysics = a
        }, D.prototype.GetBodyCount = function() {
            return this.m_bodyCount
        }, D.prototype.GetJointCount = function() {
            return this.m_jointCount
        }, D.prototype.GetContactCount = function() {
            return this.m_contactCount
        }, D.prototype.SetGravity = function(a) {
            this.m_gravity = a
        }, D.prototype.GetGravity = function() {
            return this.m_gravity
        }, D.prototype.GetGroundBody = function() {
            return this.m_groundBody
        }, D.prototype.Step = function(a, b, c) {
            void 0 === a && (a = 0), void 0 === b && (b = 0), void 0 === c && (c = 0), this.m_flags & D.e_newFixture && (this.m_contactManager.FindNewContacts(), this.m_flags &= ~D.e_newFixture), this.m_flags |= D.e_locked;
            var d = D.s_timestep2;
            d.dt = a, d.velocityIterations = b, d.positionIterations = c, d.inv_dt = a > 0 ? 1 / a : 0, d.dtRatio = this.m_inv_dt0 * a, d.warmStarting = D.m_warmStarting, this.m_contactManager.Collide(), d.dt > 0 && this.Solve(d), D.m_continuousPhysics && d.dt > 0 && this.SolveTOI(d), d.dt > 0 && (this.m_inv_dt0 = d.inv_dt), this.m_flags &= ~D.e_locked
        }, D.prototype.ClearForces = function() {
            for (var a = this.m_bodyList; a; a = a.m_next) a.m_force.SetZero(), a.m_torque = 0
        }, D.prototype.DrawDebugData = function() {
            if (null != this.m_debugDraw) {
                this.m_debugDraw.m_sprite.graphics.clear();
                var a, b, c, f, h, i, j = this.m_debugDraw.GetFlags(),
                    k = (new d, new d, new d, new g, new g, [new d, new d, new d, new d]),
                    l = new e(0, 0, 0);
                if (j & w.e_shapeBit)
                    for (a = this.m_bodyList; a; a = a.m_next)
                        for (i = a.m_xf, b = a.GetFixtureList(); b; b = b.m_next) c = b.GetShape(), 0 == a.IsActive() ? (l.Set(.5, .5, .3), this.DrawShape(c, i, l)) : a.GetType() == q.b2_staticBody ? (l.Set(.5, .9, .5), this.DrawShape(c, i, l)) : a.GetType() == q.b2_kinematicBody ? (l.Set(.5, .5, .9), this.DrawShape(c, i, l)) : 0 == a.IsAwake() ? (l.Set(.6, .6, .6), this.DrawShape(c, i, l)) : (l.Set(.9, .7, .7), this.DrawShape(c, i, l));
                if (j & w.e_jointBit)
                    for (f = this.m_jointList; f; f = f.m_next) this.DrawJoint(f);
                if (j & w.e_controllerBit)
                    for (var m = this.m_controllerList; m; m = m.m_next) m.Draw(this.m_debugDraw);
                if (j & w.e_pairBit) {
                    l.Set(.3, .9, .9);
                    for (var n = this.m_contactManager.m_contactList; n; n = n.GetNext()) {
                        var o = n.GetFixtureA(),
                            p = n.GetFixtureB(),
                            r = o.GetAABB().GetCenter(),
                            s = p.GetAABB().GetCenter();
                        this.m_debugDraw.DrawSegment(r, s, l)
                    }
                }
                if (j & w.e_aabbBit)
                    for (h = this.m_contactManager.m_broadPhase, k = [new d, new d, new d, new d], a = this.m_bodyList; a; a = a.GetNext())
                        if (0 != a.IsActive())
                            for (b = a.GetFixtureList(); b; b = b.GetNext()) {
                                var t = h.GetFatAABB(b.m_proxy);
                                k[0].Set(t.lowerBound.x, t.lowerBound.y), k[1].Set(t.upperBound.x, t.lowerBound.y), k[2].Set(t.upperBound.x, t.upperBound.y), k[3].Set(t.lowerBound.x, t.upperBound.y), this.m_debugDraw.DrawPolygon(k, 4, l)
                            }
                        if (j & w.e_centerOfMassBit)
                            for (a = this.m_bodyList; a; a = a.m_next) i = D.s_xf, i.R = a.m_xf.R, i.position = a.GetWorldCenter(), this.m_debugDraw.DrawTransform(i)
            }
        }, D.prototype.QueryAABB = function(a, b) {
            function c(b) {
                return a(e.GetUserData(b))
            }
            var d = this,
                e = d.m_contactManager.m_broadPhase;
            e.Query(c, b)
        }, D.prototype.QueryShape = function(a, b, d) {
            function e(c) {
                var e = h.GetUserData(c) instanceof z ? h.GetUserData(c) : null;
                return p.TestOverlap(b, d, e.GetShape(), e.GetBody().GetTransform()) ? a(e) : !0
            }
            var f = this;
            void 0 === d && (d = null), null == d && (d = new c, d.SetIdentity());
            var h = f.m_contactManager.m_broadPhase,
                i = new g;
            b.ComputeAABB(i, d), h.Query(e, i)
        }, D.prototype.QueryPoint = function(a, b) {
            function c(c) {
                var d = e.GetUserData(c) instanceof z ? e.GetUserData(c) : null;
                return d.TestPoint(b) ? a(d) : !0
            }
            var d = this,
                e = d.m_contactManager.m_broadPhase,
                h = new g;
            h.lowerBound.Set(b.x - f.b2_linearSlop, b.y - f.b2_linearSlop), h.upperBound.Set(b.x + f.b2_linearSlop, b.y + f.b2_linearSlop), e.Query(c, h)
        }, D.prototype.RayCast = function(a, b, c) {
            function e(e, f) {
                var i = g.GetUserData(f),
                    j = i instanceof z ? i : null,
                    k = j.RayCast(h, e);
                if (k) {
                    var l = h.fraction,
                        m = new d((1 - l) * b.x + l * c.x, (1 - l) * b.y + l * c.y);
                    return a(j, m, h.normal, l)
                }
                return e.maxFraction
            }
            var f = this,
                g = f.m_contactManager.m_broadPhase,
                h = new k,
                i = new j(b, c);
            g.RayCast(e, i)
        }, D.prototype.RayCastOne = function(a, b) {
            function c(a, b, c, e) {
                return void 0 === e && (e = 0), d = a, e
            }
            var d, e = this;
            return e.RayCast(c, a, b), d
        }, D.prototype.RayCastAll = function(a, b) {
            function c(a, b, c, d) {
                return void 0 === d && (d = 0), e[e.length] = a, 1
            }
            var d = this,
                e = new Vector;
            return d.RayCast(c, a, b), e
        }, D.prototype.GetBodyList = function() {
            return this.m_bodyList
        }, D.prototype.GetJointList = function() {
            return this.m_jointList
        }, D.prototype.GetContactList = function() {
            return this.m_contactList
        }, D.prototype.IsLocked = function() {
            return (this.m_flags & D.e_locked) > 0
        }, D.prototype.Solve = function(a) {
            for (var b, c = this.m_controllerList; c; c = c.m_next) c.Step(a);
            var d = this.m_island;
            for (d.Initialize(this.m_bodyCount, this.m_contactCount, this.m_jointCount, null, this.m_contactManager.m_contactListener, this.m_contactSolver), b = this.m_bodyList; b; b = b.m_next) b.m_flags &= ~q.e_islandFlag;
            for (var e = this.m_contactList; e; e = e.m_next) e.m_flags &= ~E.e_islandFlag;
            for (var f = this.m_jointList; f; f = f.m_next) f.m_islandFlag = !1;
            for (var g = (parseInt(this.m_bodyCount), this.s_stack), h = this.m_bodyList; h; h = h.m_next)
                if (!(h.m_flags & q.e_islandFlag) && 0 != h.IsAwake() && 0 != h.IsActive() && h.GetType() != q.b2_staticBody) {
                    d.Clear();
                    var i = 0;
                    for (g[i++] = h, h.m_flags |= q.e_islandFlag; i > 0;)
                        if (b = g[--i], d.AddBody(b), 0 == b.IsAwake() && b.SetAwake(!0), b.GetType() != q.b2_staticBody) {
                            for (var j, k = b.m_contactList; k; k = k.next) k.contact.m_flags & E.e_islandFlag || 1 != k.contact.IsSensor() && 0 != k.contact.IsEnabled() && 0 != k.contact.IsTouching() && (d.AddContact(k.contact), k.contact.m_flags |= E.e_islandFlag, j = k.other, j.m_flags & q.e_islandFlag || (g[i++] = j, j.m_flags |= q.e_islandFlag));
                            for (var l = b.m_jointList; l; l = l.next) 1 != l.joint.m_islandFlag && (j = l.other, 0 != j.IsActive() && (d.AddJoint(l.joint), l.joint.m_islandFlag = !0, j.m_flags & q.e_islandFlag || (g[i++] = j, j.m_flags |= q.e_islandFlag)))
                        }
                    d.Solve(a, this.m_gravity, this.m_allowSleep);
                    for (var m = 0; m < d.m_bodyCount; ++m) b = d.m_bodies[m], b.GetType() == q.b2_staticBody && (b.m_flags &= ~q.e_islandFlag)
                }
            for (m = 0; m < g.length && g[m]; ++m) g[m] = null;
            for (b = this.m_bodyList; b; b = b.m_next) 0 != b.IsAwake() && 0 != b.IsActive() && b.GetType() != q.b2_staticBody && b.SynchronizeFixtures();
            this.m_contactManager.FindNewContacts()
        }, D.prototype.SolveTOI = function(a) {
            var b, c, d, e, g, h, i, j = this.m_island;
            j.Initialize(this.m_bodyCount, f.b2_maxTOIContactsPerIsland, f.b2_maxTOIJointsPerIsland, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
            var k = D.s_queue;
            for (b = this.m_bodyList; b; b = b.m_next) b.m_flags &= ~q.e_islandFlag, b.m_sweep.t0 = 0;
            var l;
            for (l = this.m_contactList; l; l = l.m_next) l.m_flags &= ~(E.e_toiFlag | E.e_islandFlag);
            for (i = this.m_jointList; i; i = i.m_next) i.m_islandFlag = !1;
            for (;;) {
                var m = null,
                    n = 1;
                for (l = this.m_contactList; l; l = l.m_next)
                    if (1 != l.IsSensor() && 0 != l.IsEnabled() && 0 != l.IsContinuous()) {
                        var o = 1;
                        if (l.m_flags & E.e_toiFlag) o = l.m_toi;
                        else {
                            if (c = l.m_fixtureA, d = l.m_fixtureB, e = c.m_body, g = d.m_body, !(e.GetType() == q.b2_dynamicBody && 0 != e.IsAwake() || g.GetType() == q.b2_dynamicBody && 0 != g.IsAwake())) continue;
                            var p = e.m_sweep.t0;
                            e.m_sweep.t0 < g.m_sweep.t0 ? (p = g.m_sweep.t0, e.m_sweep.Advance(p)) : g.m_sweep.t0 < e.m_sweep.t0 && (p = e.m_sweep.t0, g.m_sweep.Advance(p)), o = l.ComputeTOI(e.m_sweep, g.m_sweep), f.b2Assert(o >= 0 && 1 >= o), o > 0 && 1 > o && (o = (1 - o) * p + o, o > 1 && (o = 1)), l.m_toi = o, l.m_flags |= E.e_toiFlag
                        }
                        Number.MIN_VALUE < o && n > o && (m = l, n = o)
                    }
                if (null == m || 1 - 100 * Number.MIN_VALUE < n) break;
                if (c = m.m_fixtureA, d = m.m_fixtureB, e = c.m_body, g = d.m_body, D.s_backupA.Set(e.m_sweep), D.s_backupB.Set(g.m_sweep), e.Advance(n), g.Advance(n), m.Update(this.m_contactManager.m_contactListener), m.m_flags &= ~E.e_toiFlag, 1 != m.IsSensor() && 0 != m.IsEnabled()) {
                    if (0 != m.IsTouching()) {
                        var r = e;
                        r.GetType() != q.b2_dynamicBody && (r = g), j.Clear();
                        var s = 0,
                            t = 0;
                        for (k[s + t++] = r, r.m_flags |= q.e_islandFlag; t > 0;)
                            if (b = k[s++], --t, j.AddBody(b), 0 == b.IsAwake() && b.SetAwake(!0), b.GetType() == q.b2_dynamicBody) {
                                for (h = b.m_contactList; h && j.m_contactCount != j.m_contactCapacity; h = h.next)
                                    if (!(h.contact.m_flags & E.e_islandFlag) && 1 != h.contact.IsSensor() && 0 != h.contact.IsEnabled() && 0 != h.contact.IsTouching()) {
                                        j.AddContact(h.contact), h.contact.m_flags |= E.e_islandFlag;
                                        var u = h.other;
                                        u.m_flags & q.e_islandFlag || (u.GetType() != q.b2_staticBody && (u.Advance(n), u.SetAwake(!0)), k[s + t] = u, ++t, u.m_flags |= q.e_islandFlag)
                                    }
                                for (var v = b.m_jointList; v; v = v.next) j.m_jointCount != j.m_jointCapacity && 1 != v.joint.m_islandFlag && (u = v.other, 0 != u.IsActive() && (j.AddJoint(v.joint), v.joint.m_islandFlag = !0, u.m_flags & q.e_islandFlag || (u.GetType() != q.b2_staticBody && (u.Advance(n), u.SetAwake(!0)), k[s + t] = u, ++t, u.m_flags |= q.e_islandFlag)))
                            }
                        var w = D.s_timestep;
                        w.warmStarting = !1, w.dt = (1 - n) * a.dt, w.inv_dt = 1 / w.dt, w.dtRatio = 0, w.velocityIterations = a.velocityIterations, w.positionIterations = a.positionIterations, j.SolveTOI(w);
                        var x = 0;
                        for (x = 0; x < j.m_bodyCount; ++x)
                            if (b = j.m_bodies[x], b.m_flags &= ~q.e_islandFlag, 0 != b.IsAwake() && b.GetType() == q.b2_dynamicBody)
                                for (b.SynchronizeFixtures(), h = b.m_contactList; h; h = h.next) h.contact.m_flags &= ~E.e_toiFlag;
                        for (x = 0; x < j.m_contactCount; ++x) l = j.m_contacts[x], l.m_flags &= ~(E.e_toiFlag | E.e_islandFlag);
                        for (x = 0; x < j.m_jointCount; ++x) i = j.m_joints[x], i.m_islandFlag = !1;
                        this.m_contactManager.FindNewContacts()
                    }
                } else e.m_sweep.Set(D.s_backupA), g.m_sweep.Set(D.s_backupB), e.SynchronizeTransform(), g.SynchronizeTransform()
            }
        }, D.prototype.DrawJoint = function(a) {
            var b = a.GetBodyA(),
                c = a.GetBodyB(),
                d = b.m_xf,
                e = c.m_xf,
                f = d.position,
                g = e.position,
                h = a.GetAnchorA(),
                i = a.GetAnchorB(),
                j = D.s_jointColor;
            switch (a.m_type) {
                case H.e_distanceJoint:
                    this.m_debugDraw.DrawSegment(h, i, j);
                    break;
                case H.e_pulleyJoint:
                    var k = a instanceof I ? a : null,
                        l = k.GetGroundAnchorA(),
                        m = k.GetGroundAnchorB();
                    this.m_debugDraw.DrawSegment(l, h, j), this.m_debugDraw.DrawSegment(m, i, j), this.m_debugDraw.DrawSegment(l, m, j);
                    break;
                case H.e_mouseJoint:
                    this.m_debugDraw.DrawSegment(h, i, j);
                    break;
                default:
                    b != this.m_groundBody && this.m_debugDraw.DrawSegment(f, h, j), this.m_debugDraw.DrawSegment(h, i, j), c != this.m_groundBody && this.m_debugDraw.DrawSegment(g, i, j)
            }
        }, D.prototype.DrawShape = function(b, c, d) {
            switch (b.m_type) {
                case p.e_circleShape:
                    var e = b instanceof l ? b : null,
                        f = a.MulX(c, e.m_p),
                        g = e.m_radius,
                        h = c.R.col1;
                    this.m_debugDraw.DrawSolidCircle(f, g, h, d);
                    break;
                case p.e_polygonShape:
                    var i = 0,
                        j = b instanceof o ? b : null,
                        k = parseInt(j.GetVertexCount()),
                        n = j.GetVertices(),
                        q = new Vector(k);
                    for (i = 0; k > i; ++i) q[i] = a.MulX(c, n[i]);
                    this.m_debugDraw.DrawSolidPolygon(q, k, d);
                    break;
                case p.e_edgeShape:
                    var r = b instanceof m ? b : null;
                    this.m_debugDraw.DrawSegment(a.MulX(c, r.GetVertex1()), a.MulX(c, r.GetVertex2()), d)
            }
        }, Box2D.postDefs.push(function() {
            Box2D.Dynamics.b2World.s_timestep2 = new C, Box2D.Dynamics.b2World.s_xf = new c, Box2D.Dynamics.b2World.s_backupA = new b, Box2D.Dynamics.b2World.s_backupB = new b, Box2D.Dynamics.b2World.s_timestep = new C, Box2D.Dynamics.b2World.s_queue = new Vector, Box2D.Dynamics.b2World.s_jointColor = new e(.5, .8, .8), Box2D.Dynamics.b2World.e_newFixture = 1, Box2D.Dynamics.b2World.e_locked = 2
        })
    }(),
    function() {
        {
            var a = Box2D.Collision.Shapes.b2CircleShape,
                b = (Box2D.Collision.Shapes.b2EdgeChainDef, Box2D.Collision.Shapes.b2EdgeShape),
                c = (Box2D.Collision.Shapes.b2MassData, Box2D.Collision.Shapes.b2PolygonShape),
                d = Box2D.Collision.Shapes.b2Shape,
                e = Box2D.Dynamics.Contacts.b2CircleContact,
                f = Box2D.Dynamics.Contacts.b2Contact,
                g = Box2D.Dynamics.Contacts.b2ContactConstraint,
                h = Box2D.Dynamics.Contacts.b2ContactConstraintPoint,
                i = Box2D.Dynamics.Contacts.b2ContactEdge,
                j = Box2D.Dynamics.Contacts.b2ContactFactory,
                k = Box2D.Dynamics.Contacts.b2ContactRegister,
                l = Box2D.Dynamics.Contacts.b2ContactResult,
                m = Box2D.Dynamics.Contacts.b2ContactSolver,
                n = Box2D.Dynamics.Contacts.b2EdgeAndCircleContact,
                o = Box2D.Dynamics.Contacts.b2NullContact,
                p = Box2D.Dynamics.Contacts.b2PolyAndCircleContact,
                q = Box2D.Dynamics.Contacts.b2PolyAndEdgeContact,
                r = Box2D.Dynamics.Contacts.b2PolygonContact,
                s = Box2D.Dynamics.Contacts.b2PositionSolverManifold,
                t = Box2D.Dynamics.b2Body,
                u = (Box2D.Dynamics.b2BodyDef, Box2D.Dynamics.b2ContactFilter, Box2D.Dynamics.b2ContactImpulse, Box2D.Dynamics.b2ContactListener, Box2D.Dynamics.b2ContactManager, Box2D.Dynamics.b2DebugDraw, Box2D.Dynamics.b2DestructionListener, Box2D.Dynamics.b2FilterData, Box2D.Dynamics.b2Fixture, Box2D.Dynamics.b2FixtureDef, Box2D.Dynamics.b2Island, Box2D.Dynamics.b2TimeStep),
                v = (Box2D.Dynamics.b2World, Box2D.Common.b2Color, Box2D.Common.b2internal, Box2D.Common.b2Settings),
                w = Box2D.Common.Math.b2Mat22,
                x = (Box2D.Common.Math.b2Mat33, Box2D.Common.Math.b2Math),
                y = (Box2D.Common.Math.b2Sweep, Box2D.Common.Math.b2Transform, Box2D.Common.Math.b2Vec2),
                z = (Box2D.Common.Math.b2Vec3, Box2D.Collision.b2AABB, Box2D.Collision.b2Bound, Box2D.Collision.b2BoundValues, Box2D.Collision.b2Collision),
                A = Box2D.Collision.b2ContactID,
                B = (Box2D.Collision.b2ContactPoint, Box2D.Collision.b2Distance, Box2D.Collision.b2DistanceInput, Box2D.Collision.b2DistanceOutput, Box2D.Collision.b2DistanceProxy, Box2D.Collision.b2DynamicTree, Box2D.Collision.b2DynamicTreeBroadPhase, Box2D.Collision.b2DynamicTreeNode, Box2D.Collision.b2DynamicTreePair, Box2D.Collision.b2Manifold),
                C = (Box2D.Collision.b2ManifoldPoint, Box2D.Collision.b2Point, Box2D.Collision.b2RayCastInput, Box2D.Collision.b2RayCastOutput, Box2D.Collision.b2Segment, Box2D.Collision.b2SeparationFunction, Box2D.Collision.b2Simplex, Box2D.Collision.b2SimplexCache, Box2D.Collision.b2SimplexVertex, Box2D.Collision.b2TimeOfImpact),
                D = Box2D.Collision.b2TOIInput,
                E = Box2D.Collision.b2WorldManifold;
            Box2D.Collision.ClipVertex, Box2D.Collision.Features, Box2D.Collision.IBroadPhase
        }
        Box2D.inherit(e, Box2D.Dynamics.Contacts.b2Contact), e.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype, e.b2CircleContact = function() {
            Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments)
        }, e.Create = function() {
            return new e
        }, e.Destroy = function() {}, e.prototype.Reset = function(a, b) {
            this.__super.Reset.call(this, a, b)
        }, e.prototype.Evaluate = function() {
            var b = this.m_fixtureA.GetBody(),
                c = this.m_fixtureB.GetBody();
            z.CollideCircles(this.m_manifold, this.m_fixtureA.GetShape() instanceof a ? this.m_fixtureA.GetShape() : null, b.m_xf, this.m_fixtureB.GetShape() instanceof a ? this.m_fixtureB.GetShape() : null, c.m_xf)
        }, f.b2Contact = function() {
            this.m_nodeA = new i, this.m_nodeB = new i, this.m_manifold = new B, this.m_oldManifold = new B
        }, f.prototype.GetManifold = function() {
            return this.m_manifold
        }, f.prototype.GetWorldManifold = function(a) {
            var b = this.m_fixtureA.GetBody(),
                c = this.m_fixtureB.GetBody(),
                d = this.m_fixtureA.GetShape(),
                e = this.m_fixtureB.GetShape();
            a.Initialize(this.m_manifold, b.GetTransform(), d.m_radius, c.GetTransform(), e.m_radius)
        }, f.prototype.IsTouching = function() {
            return (this.m_flags & f.e_touchingFlag) == f.e_touchingFlag
        }, f.prototype.IsContinuous = function() {
            return (this.m_flags & f.e_continuousFlag) == f.e_continuousFlag
        }, f.prototype.SetSensor = function(a) {
            a ? this.m_flags |= f.e_sensorFlag : this.m_flags &= ~f.e_sensorFlag
        }, f.prototype.IsSensor = function() {
            return (this.m_flags & f.e_sensorFlag) == f.e_sensorFlag
        }, f.prototype.SetEnabled = function(a) {
            a ? this.m_flags |= f.e_enabledFlag : this.m_flags &= ~f.e_enabledFlag
        }, f.prototype.IsEnabled = function() {
            return (this.m_flags & f.e_enabledFlag) == f.e_enabledFlag
        }, f.prototype.GetNext = function() {
            return this.m_next
        }, f.prototype.GetFixtureA = function() {
            return this.m_fixtureA
        }, f.prototype.GetFixtureB = function() {
            return this.m_fixtureB
        }, f.prototype.FlagForFiltering = function() {
            this.m_flags |= f.e_filterFlag
        }, f.prototype.b2Contact = function() {}, f.prototype.Reset = function(a, b) {
            if (void 0 === a && (a = null), void 0 === b && (b = null), this.m_flags = f.e_enabledFlag, !a || !b) return this.m_fixtureA = null, void(this.m_fixtureB = null);
            (a.IsSensor() || b.IsSensor()) && (this.m_flags |= f.e_sensorFlag);
            var c = a.GetBody(),
                d = b.GetBody();
            (c.GetType() != t.b2_dynamicBody || c.IsBullet() || d.GetType() != t.b2_dynamicBody || d.IsBullet()) && (this.m_flags |= f.e_continuousFlag), this.m_fixtureA = a, this.m_fixtureB = b, this.m_manifold.m_pointCount = 0, this.m_prev = null, this.m_next = null, this.m_nodeA.contact = null, this.m_nodeA.prev = null, this.m_nodeA.next = null, this.m_nodeA.other = null, this.m_nodeB.contact = null, this.m_nodeB.prev = null, this.m_nodeB.next = null, this.m_nodeB.other = null
        }, f.prototype.Update = function(a) {
            var b = this.m_oldManifold;
            this.m_oldManifold = this.m_manifold, this.m_manifold = b, this.m_flags |= f.e_enabledFlag;
            var c = !1,
                e = (this.m_flags & f.e_touchingFlag) == f.e_touchingFlag,
                g = this.m_fixtureA.m_body,
                h = this.m_fixtureB.m_body,
                i = this.m_fixtureA.m_aabb.TestOverlap(this.m_fixtureB.m_aabb);
            if (this.m_flags & f.e_sensorFlag) {
                if (i) {
                    var j = this.m_fixtureA.GetShape(),
                        k = this.m_fixtureB.GetShape(),
                        l = g.GetTransform(),
                        m = h.GetTransform();
                    c = d.TestOverlap(j, l, k, m)
                }
                this.m_manifold.m_pointCount = 0
            } else {
                if (g.GetType() != t.b2_dynamicBody || g.IsBullet() || h.GetType() != t.b2_dynamicBody || h.IsBullet() ? this.m_flags |= f.e_continuousFlag : this.m_flags &= ~f.e_continuousFlag, i) {
                    this.Evaluate(), c = this.m_manifold.m_pointCount > 0;
                    for (var n = 0; n < this.m_manifold.m_pointCount; ++n) {
                        var o = this.m_manifold.m_points[n];
                        o.m_normalImpulse = 0, o.m_tangentImpulse = 0;
                        for (var p = o.m_id, q = 0; q < this.m_oldManifold.m_pointCount; ++q) {
                            var r = this.m_oldManifold.m_points[q];
                            if (r.m_id.key == p.key) {
                                o.m_normalImpulse = r.m_normalImpulse, o.m_tangentImpulse = r.m_tangentImpulse;
                                break
                            }
                        }
                    }
                } else this.m_manifold.m_pointCount = 0;
                c != e && (g.SetAwake(!0), h.SetAwake(!0))
            }
            c ? this.m_flags |= f.e_touchingFlag : this.m_flags &= ~f.e_touchingFlag, 0 == e && 1 == c && a.BeginContact(this), 1 == e && 0 == c && a.EndContact(this), 0 == (this.m_flags & f.e_sensorFlag) && a.PreSolve(this, this.m_oldManifold)
        }, f.prototype.Evaluate = function() {}, f.prototype.ComputeTOI = function(a, b) {
            return f.s_input.proxyA.Set(this.m_fixtureA.GetShape()), f.s_input.proxyB.Set(this.m_fixtureB.GetShape()), f.s_input.sweepA = a, f.s_input.sweepB = b, f.s_input.tolerance = v.b2_linearSlop, C.TimeOfImpact(f.s_input)
        }, Box2D.postDefs.push(function() {
            Box2D.Dynamics.Contacts.b2Contact.e_sensorFlag = 1, Box2D.Dynamics.Contacts.b2Contact.e_continuousFlag = 2, Box2D.Dynamics.Contacts.b2Contact.e_islandFlag = 4, Box2D.Dynamics.Contacts.b2Contact.e_toiFlag = 8, Box2D.Dynamics.Contacts.b2Contact.e_touchingFlag = 16, Box2D.Dynamics.Contacts.b2Contact.e_enabledFlag = 32, Box2D.Dynamics.Contacts.b2Contact.e_filterFlag = 64, Box2D.Dynamics.Contacts.b2Contact.s_input = new D
        }), g.b2ContactConstraint = function() {
            this.localPlaneNormal = new y, this.localPoint = new y, this.normal = new y, this.normalMass = new w, this.K = new w
        }, g.prototype.b2ContactConstraint = function() {
            this.points = new Vector(v.b2_maxManifoldPoints);
            for (var a = 0; a < v.b2_maxManifoldPoints; a++) this.points[a] = new h
        }, h.b2ContactConstraintPoint = function() {
            this.localPoint = new y, this.rA = new y, this.rB = new y
        }, i.b2ContactEdge = function() {}, j.b2ContactFactory = function() {}, j.prototype.b2ContactFactory = function(a) {
            this.m_allocator = a, this.InitializeRegisters()
        }, j.prototype.AddType = function(a, b, c, d) {
            void 0 === c && (c = 0), void 0 === d && (d = 0), this.m_registers[c][d].createFcn = a, this.m_registers[c][d].destroyFcn = b, this.m_registers[c][d].primary = !0, c != d && (this.m_registers[d][c].createFcn = a, this.m_registers[d][c].destroyFcn = b, this.m_registers[d][c].primary = !1)
        }, j.prototype.InitializeRegisters = function() {
            this.m_registers = new Vector(d.e_shapeTypeCount);
            for (var a = 0; a < d.e_shapeTypeCount; a++) {
                this.m_registers[a] = new Vector(d.e_shapeTypeCount);
                for (var b = 0; b < d.e_shapeTypeCount; b++) this.m_registers[a][b] = new k
            }
            this.AddType(e.Create, e.Destroy, d.e_circleShape, d.e_circleShape), this.AddType(p.Create, p.Destroy, d.e_polygonShape, d.e_circleShape), this.AddType(r.Create, r.Destroy, d.e_polygonShape, d.e_polygonShape), this.AddType(n.Create, n.Destroy, d.e_edgeShape, d.e_circleShape), this.AddType(q.Create, q.Destroy, d.e_polygonShape, d.e_edgeShape)
        }, j.prototype.Create = function(a, b) {
            var c, d = parseInt(a.GetType()),
                e = parseInt(b.GetType()),
                f = this.m_registers[d][e];
            if (f.pool) return c = f.pool, f.pool = c.m_next, f.poolCount--, c.Reset(a, b), c;
            var g = f.createFcn;
            return null != g ? f.primary ? (c = g(this.m_allocator), c.Reset(a, b), c) : (c = g(this.m_allocator), c.Reset(b, a), c) : null
        }, j.prototype.Destroy = function(a) {
            a.m_manifold.m_pointCount > 0 && (a.m_fixtureA.m_body.SetAwake(!0), a.m_fixtureB.m_body.SetAwake(!0));
            var b = parseInt(a.m_fixtureA.GetType()),
                c = parseInt(a.m_fixtureB.GetType()),
                d = this.m_registers[b][c];
            d.poolCount++, a.m_next = d.pool, d.pool = a;
            var e = d.destroyFcn;
            e(a, this.m_allocator)
        }, k.b2ContactRegister = function() {}, l.b2ContactResult = function() {
            this.position = new y, this.normal = new y, this.id = new A
        }, m.b2ContactSolver = function() {
            this.m_step = new u, this.m_constraints = new Vector
        }, m.prototype.b2ContactSolver = function() {}, m.prototype.Initialize = function(a, b, c, d) {
            void 0 === c && (c = 0);
            var e;
            this.m_step.Set(a), this.m_allocator = d;
            var f = 0;
            for (this.m_constraintCount = c; this.m_constraints.length < this.m_constraintCount;) this.m_constraints[this.m_constraints.length] = new g;
            for (f = 0; c > f; ++f) {
                e = b[f];
                var h = e.m_fixtureA,
                    i = e.m_fixtureB,
                    j = h.m_shape,
                    k = i.m_shape,
                    l = j.m_radius,
                    n = k.m_radius,
                    o = h.m_body,
                    p = i.m_body,
                    q = e.GetManifold(),
                    r = v.b2MixFriction(h.GetFriction(), i.GetFriction()),
                    s = v.b2MixRestitution(h.GetRestitution(), i.GetRestitution()),
                    t = o.m_linearVelocity.x,
                    u = o.m_linearVelocity.y,
                    w = p.m_linearVelocity.x,
                    x = p.m_linearVelocity.y,
                    y = o.m_angularVelocity,
                    z = p.m_angularVelocity;
                v.b2Assert(q.m_pointCount > 0), m.s_worldManifold.Initialize(q, o.m_xf, l, p.m_xf, n);
                var A = m.s_worldManifold.m_normal.x,
                    B = m.s_worldManifold.m_normal.y,
                    C = this.m_constraints[f];
                C.bodyA = o, C.bodyB = p, C.manifold = q, C.normal.x = A, C.normal.y = B, C.pointCount = q.m_pointCount, C.friction = r, C.restitution = s, C.localPlaneNormal.x = q.m_localPlaneNormal.x, C.localPlaneNormal.y = q.m_localPlaneNormal.y, C.localPoint.x = q.m_localPoint.x, C.localPoint.y = q.m_localPoint.y, C.radius = l + n, C.type = q.m_type;
                for (var D = 0; D < C.pointCount; ++D) {
                    var E = q.m_points[D],
                        F = C.points[D];
                    F.normalImpulse = E.m_normalImpulse, F.tangentImpulse = E.m_tangentImpulse, F.localPoint.SetV(E.m_localPoint);
                    var G = F.rA.x = m.s_worldManifold.m_points[D].x - o.m_sweep.c.x,
                        H = F.rA.y = m.s_worldManifold.m_points[D].y - o.m_sweep.c.y,
                        I = F.rB.x = m.s_worldManifold.m_points[D].x - p.m_sweep.c.x,
                        J = F.rB.y = m.s_worldManifold.m_points[D].y - p.m_sweep.c.y,
                        K = G * B - H * A,
                        L = I * B - J * A;
                    K *= K, L *= L;
                    var M = o.m_invMass + p.m_invMass + o.m_invI * K + p.m_invI * L;
                    F.normalMass = 1 / M;
                    var N = o.m_mass * o.m_invMass + p.m_mass * p.m_invMass;
                    N += o.m_mass * o.m_invI * K + p.m_mass * p.m_invI * L, F.equalizedMass = 1 / N;
                    var O = B,
                        P = -A,
                        Q = G * P - H * O,
                        R = I * P - J * O;
                    Q *= Q, R *= R;
                    var S = o.m_invMass + p.m_invMass + o.m_invI * Q + p.m_invI * R;
                    F.tangentMass = 1 / S, F.velocityBias = 0;
                    var T = w + -z * J - t - -y * H,
                        U = x + z * I - u - y * G,
                        V = C.normal.x * T + C.normal.y * U;
                    V < -v.b2_velocityThreshold && (F.velocityBias += -C.restitution * V)
                }
                if (2 == C.pointCount) {
                    var W = C.points[0],
                        X = C.points[1],
                        Y = o.m_invMass,
                        Z = o.m_invI,
                        $ = p.m_invMass,
                        _ = p.m_invI,
                        ab = W.rA.x * B - W.rA.y * A,
                        bb = W.rB.x * B - W.rB.y * A,
                        cb = X.rA.x * B - X.rA.y * A,
                        db = X.rB.x * B - X.rB.y * A,
                        eb = Y + $ + Z * ab * ab + _ * bb * bb,
                        fb = Y + $ + Z * cb * cb + _ * db * db,
                        gb = Y + $ + Z * ab * cb + _ * bb * db,
                        hb = 100;
                    hb * (eb * fb - gb * gb) > eb * eb ? (C.K.col1.Set(eb, gb), C.K.col2.Set(gb, fb), C.K.GetInverse(C.normalMass)) : C.pointCount = 1
                }
            }
        }, m.prototype.InitVelocityConstraints = function(a) {
            for (var b = 0; b < this.m_constraintCount; ++b) {
                var c = this.m_constraints[b],
                    d = c.bodyA,
                    e = c.bodyB,
                    f = d.m_invMass,
                    g = d.m_invI,
                    h = e.m_invMass,
                    i = e.m_invI,
                    j = c.normal.x,
                    k = c.normal.y,
                    l = k,
                    m = -j,
                    n = 0,
                    o = 0;
                if (a.warmStarting)
                    for (o = c.pointCount, n = 0; o > n; ++n) {
                        var p = c.points[n];
                        p.normalImpulse *= a.dtRatio, p.tangentImpulse *= a.dtRatio;
                        var q = p.normalImpulse * j + p.tangentImpulse * l,
                            r = p.normalImpulse * k + p.tangentImpulse * m;
                        d.m_angularVelocity -= g * (p.rA.x * r - p.rA.y * q), d.m_linearVelocity.x -= f * q, d.m_linearVelocity.y -= f * r, e.m_angularVelocity += i * (p.rB.x * r - p.rB.y * q), e.m_linearVelocity.x += h * q, e.m_linearVelocity.y += h * r
                    } else
                        for (o = c.pointCount, n = 0; o > n; ++n) {
                            var s = c.points[n];
                            s.normalImpulse = 0, s.tangentImpulse = 0
                        }
            }
        }, m.prototype.SolveVelocityConstraints = function() {
            for (var a, b, c = 0, d = 0, e = 0, f = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0; s < this.m_constraintCount; ++s) {
                var t = this.m_constraints[s],
                    u = t.bodyA,
                    v = t.bodyB,
                    w = u.m_angularVelocity,
                    y = v.m_angularVelocity,
                    z = u.m_linearVelocity,
                    A = v.m_linearVelocity,
                    B = u.m_invMass,
                    C = u.m_invI,
                    D = v.m_invMass,
                    E = v.m_invI,
                    F = t.normal.x,
                    G = t.normal.y,
                    H = G,
                    I = -F,
                    J = t.friction;
                for (c = 0; c < t.pointCount; c++) a = t.points[c], d = A.x - y * a.rB.y - z.x + w * a.rA.y, e = A.y + y * a.rB.x - z.y - w * a.rA.x, g = d * H + e * I, h = a.tangentMass * -g, i = J * a.normalImpulse, j = x.Clamp(a.tangentImpulse + h, -i, i), h = j - a.tangentImpulse, k = h * H, l = h * I, z.x -= B * k, z.y -= B * l, w -= C * (a.rA.x * l - a.rA.y * k), A.x += D * k, A.y += D * l, y += E * (a.rB.x * l - a.rB.y * k), a.tangentImpulse = j; {
                    parseInt(t.pointCount)
                }
                if (1 == t.pointCount) a = t.points[0], d = A.x + -y * a.rB.y - z.x - -w * a.rA.y, e = A.y + y * a.rB.x - z.y - w * a.rA.x, f = d * F + e * G, h = -a.normalMass * (f - a.velocityBias), j = a.normalImpulse + h, j = j > 0 ? j : 0, h = j - a.normalImpulse, k = h * F, l = h * G, z.x -= B * k, z.y -= B * l, w -= C * (a.rA.x * l - a.rA.y * k), A.x += D * k, A.y += D * l, y += E * (a.rB.x * l - a.rB.y * k), a.normalImpulse = j;
                else {
                    var K = t.points[0],
                        L = t.points[1],
                        M = K.normalImpulse,
                        N = L.normalImpulse,
                        O = A.x - y * K.rB.y - z.x + w * K.rA.y,
                        P = A.y + y * K.rB.x - z.y - w * K.rA.x,
                        Q = A.x - y * L.rB.y - z.x + w * L.rA.y,
                        R = A.y + y * L.rB.x - z.y - w * L.rA.x,
                        S = O * F + P * G,
                        T = Q * F + R * G,
                        U = S - K.velocityBias,
                        V = T - L.velocityBias;
                    b = t.K, U -= b.col1.x * M + b.col2.x * N, V -= b.col1.y * M + b.col2.y * N;
                    for (;;) {
                        b = t.normalMass;
                        var W = -(b.col1.x * U + b.col2.x * V),
                            X = -(b.col1.y * U + b.col2.y * V);
                        if (W >= 0 && X >= 0) {
                            m = W - M, n = X - N, o = m * F, p = m * G, q = n * F, r = n * G, z.x -= B * (o + q), z.y -= B * (p + r), w -= C * (K.rA.x * p - K.rA.y * o + L.rA.x * r - L.rA.y * q), A.x += D * (o + q), A.y += D * (p + r), y += E * (K.rB.x * p - K.rB.y * o + L.rB.x * r - L.rB.y * q), K.normalImpulse = W, L.normalImpulse = X;
                            break
                        }
                        if (W = -K.normalMass * U, X = 0, S = 0, T = t.K.col1.y * W + V, W >= 0 && T >= 0) {
                            m = W - M, n = X - N, o = m * F, p = m * G, q = n * F, r = n * G, z.x -= B * (o + q), z.y -= B * (p + r), w -= C * (K.rA.x * p - K.rA.y * o + L.rA.x * r - L.rA.y * q), A.x += D * (o + q), A.y += D * (p + r), y += E * (K.rB.x * p - K.rB.y * o + L.rB.x * r - L.rB.y * q), K.normalImpulse = W, L.normalImpulse = X;
                            break
                        }
                        if (W = 0, X = -L.normalMass * V, S = t.K.col2.x * X + U, T = 0, X >= 0 && S >= 0) {
                            m = W - M, n = X - N, o = m * F, p = m * G, q = n * F, r = n * G, z.x -= B * (o + q), z.y -= B * (p + r), w -= C * (K.rA.x * p - K.rA.y * o + L.rA.x * r - L.rA.y * q), A.x += D * (o + q), A.y += D * (p + r), y += E * (K.rB.x * p - K.rB.y * o + L.rB.x * r - L.rB.y * q), K.normalImpulse = W, L.normalImpulse = X;
                            break
                        }
                        if (W = 0, X = 0, S = U, T = V, S >= 0 && T >= 0) {
                            m = W - M, n = X - N, o = m * F, p = m * G, q = n * F, r = n * G, z.x -= B * (o + q), z.y -= B * (p + r), w -= C * (K.rA.x * p - K.rA.y * o + L.rA.x * r - L.rA.y * q), A.x += D * (o + q), A.y += D * (p + r), y += E * (K.rB.x * p - K.rB.y * o + L.rB.x * r - L.rB.y * q), K.normalImpulse = W, L.normalImpulse = X;
                            break
                        }
                        break
                    }
                }
                u.m_angularVelocity = w, v.m_angularVelocity = y
            }
        }, m.prototype.FinalizeVelocityConstraints = function() {
            for (var a = 0; a < this.m_constraintCount; ++a)
                for (var b = this.m_constraints[a], c = b.manifold, d = 0; d < b.pointCount; ++d) {
                    var e = c.m_points[d],
                        f = b.points[d];
                    e.m_normalImpulse = f.normalImpulse, e.m_tangentImpulse = f.tangentImpulse
                }
        }, m.prototype.SolvePositionConstraints = function(a) {
            void 0 === a && (a = 0);
            for (var b = 0, c = 0; c < this.m_constraintCount; c++) {
                var d = this.m_constraints[c],
                    e = d.bodyA,
                    f = d.bodyB,
                    g = e.m_mass * e.m_invMass,
                    h = e.m_mass * e.m_invI,
                    i = f.m_mass * f.m_invMass,
                    j = f.m_mass * f.m_invI;
                m.s_psm.Initialize(d);
                for (var k = m.s_psm.m_normal, l = 0; l < d.pointCount; l++) {
                    var n = d.points[l],
                        o = m.s_psm.m_points[l],
                        p = m.s_psm.m_separations[l],
                        q = o.x - e.m_sweep.c.x,
                        r = o.y - e.m_sweep.c.y,
                        s = o.x - f.m_sweep.c.x,
                        t = o.y - f.m_sweep.c.y;
                    b = p > b ? b : p;
                    var u = x.Clamp(a * (p + v.b2_linearSlop), -v.b2_maxLinearCorrection, 0),
                        w = -n.equalizedMass * u,
                        y = w * k.x,
                        z = w * k.y;
                    e.m_sweep.c.x -= g * y, e.m_sweep.c.y -= g * z, e.m_sweep.a -= h * (q * z - r * y), e.SynchronizeTransform(), f.m_sweep.c.x += i * y, f.m_sweep.c.y += i * z, f.m_sweep.a += j * (s * z - t * y), f.SynchronizeTransform()
                }
            }
            return b > -1.5 * v.b2_linearSlop
        }, Box2D.postDefs.push(function() {
            Box2D.Dynamics.Contacts.b2ContactSolver.s_worldManifold = new E, Box2D.Dynamics.Contacts.b2ContactSolver.s_psm = new s
        }), Box2D.inherit(n, Box2D.Dynamics.Contacts.b2Contact), n.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype, n.b2EdgeAndCircleContact = function() {
            Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments)
        }, n.Create = function() {
            return new n
        }, n.Destroy = function() {}, n.prototype.Reset = function(a, b) {
            this.__super.Reset.call(this, a, b)
        }, n.prototype.Evaluate = function() {
            var c = this.m_fixtureA.GetBody(),
                d = this.m_fixtureB.GetBody();
            this.b2CollideEdgeAndCircle(this.m_manifold, this.m_fixtureA.GetShape() instanceof b ? this.m_fixtureA.GetShape() : null, c.m_xf, this.m_fixtureB.GetShape() instanceof a ? this.m_fixtureB.GetShape() : null, d.m_xf)
        }, n.prototype.b2CollideEdgeAndCircle = function() {}, Box2D.inherit(o, Box2D.Dynamics.Contacts.b2Contact), o.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype, o.b2NullContact = function() {
            Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments)
        }, o.prototype.b2NullContact = function() {
            this.__super.b2Contact.call(this)
        }, o.prototype.Evaluate = function() {}, Box2D.inherit(p, Box2D.Dynamics.Contacts.b2Contact), p.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype, p.b2PolyAndCircleContact = function() {
            Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments)
        }, p.Create = function() {
            return new p
        }, p.Destroy = function() {}, p.prototype.Reset = function(a, b) {
            this.__super.Reset.call(this, a, b), v.b2Assert(a.GetType() == d.e_polygonShape), v.b2Assert(b.GetType() == d.e_circleShape)
        }, p.prototype.Evaluate = function() {
            var b = this.m_fixtureA.m_body,
                d = this.m_fixtureB.m_body;
            z.CollidePolygonAndCircle(this.m_manifold, this.m_fixtureA.GetShape() instanceof c ? this.m_fixtureA.GetShape() : null, b.m_xf, this.m_fixtureB.GetShape() instanceof a ? this.m_fixtureB.GetShape() : null, d.m_xf)
        }, Box2D.inherit(q, Box2D.Dynamics.Contacts.b2Contact), q.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype, q.b2PolyAndEdgeContact = function() {
            Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments)
        }, q.Create = function() {
            return new q
        }, q.Destroy = function() {}, q.prototype.Reset = function(a, b) {
            this.__super.Reset.call(this, a, b), v.b2Assert(a.GetType() == d.e_polygonShape), v.b2Assert(b.GetType() == d.e_edgeShape)
        }, q.prototype.Evaluate = function() {
            var a = this.m_fixtureA.GetBody(),
                d = this.m_fixtureB.GetBody();
            this.b2CollidePolyAndEdge(this.m_manifold, this.m_fixtureA.GetShape() instanceof c ? this.m_fixtureA.GetShape() : null, a.m_xf, this.m_fixtureB.GetShape() instanceof b ? this.m_fixtureB.GetShape() : null, d.m_xf)
        }, q.prototype.b2CollidePolyAndEdge = function() {}, Box2D.inherit(r, Box2D.Dynamics.Contacts.b2Contact), r.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype, r.b2PolygonContact = function() {
            Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments)
        }, r.Create = function() {
            return new r
        }, r.Destroy = function() {}, r.prototype.Reset = function(a, b) {
            this.__super.Reset.call(this, a, b)
        }, r.prototype.Evaluate = function() {
            var a = this.m_fixtureA.GetBody(),
                b = this.m_fixtureB.GetBody();
            z.CollidePolygons(this.m_manifold, this.m_fixtureA.GetShape() instanceof c ? this.m_fixtureA.GetShape() : null, a.m_xf, this.m_fixtureB.GetShape() instanceof c ? this.m_fixtureB.GetShape() : null, b.m_xf)
        }, s.b2PositionSolverManifold = function() {}, s.prototype.b2PositionSolverManifold = function() {
            this.m_normal = new y, this.m_separations = new Vector_a2j_Number(v.b2_maxManifoldPoints), this.m_points = new Vector(v.b2_maxManifoldPoints);
            for (var a = 0; a < v.b2_maxManifoldPoints; a++) this.m_points[a] = new y
        }, s.prototype.Initialize = function(a) {
            v.b2Assert(a.pointCount > 0);
            var b, c, d = 0,
                e = 0,
                f = 0,
                g = 0,
                h = 0;
            switch (a.type) {
                case B.e_circles:
                    b = a.bodyA.m_xf.R, c = a.localPoint;
                    var i = a.bodyA.m_xf.position.x + (b.col1.x * c.x + b.col2.x * c.y),
                        j = a.bodyA.m_xf.position.y + (b.col1.y * c.x + b.col2.y * c.y);
                    b = a.bodyB.m_xf.R, c = a.points[0].localPoint;
                    var k = a.bodyB.m_xf.position.x + (b.col1.x * c.x + b.col2.x * c.y),
                        l = a.bodyB.m_xf.position.y + (b.col1.y * c.x + b.col2.y * c.y),
                        m = k - i,
                        n = l - j,
                        o = m * m + n * n;
                    if (o > Number.MIN_VALUE * Number.MIN_VALUE) {
                        var p = Math.sqrt(o);
                        this.m_normal.x = m / p, this.m_normal.y = n / p
                    } else this.m_normal.x = 1, this.m_normal.y = 0;
                    this.m_points[0].x = .5 * (i + k), this.m_points[0].y = .5 * (j + l), this.m_separations[0] = m * this.m_normal.x + n * this.m_normal.y - a.radius;
                    break;
                case B.e_faceA:
                    for (b = a.bodyA.m_xf.R, c = a.localPlaneNormal, this.m_normal.x = b.col1.x * c.x + b.col2.x * c.y, this.m_normal.y = b.col1.y * c.x + b.col2.y * c.y, b = a.bodyA.m_xf.R, c = a.localPoint, g = a.bodyA.m_xf.position.x + (b.col1.x * c.x + b.col2.x * c.y), h = a.bodyA.m_xf.position.y + (b.col1.y * c.x + b.col2.y * c.y), b = a.bodyB.m_xf.R, d = 0; d < a.pointCount; ++d) c = a.points[d].localPoint, e = a.bodyB.m_xf.position.x + (b.col1.x * c.x + b.col2.x * c.y), f = a.bodyB.m_xf.position.y + (b.col1.y * c.x + b.col2.y * c.y), this.m_separations[d] = (e - g) * this.m_normal.x + (f - h) * this.m_normal.y - a.radius, this.m_points[d].x = e, this.m_points[d].y = f;
                    break;
                case B.e_faceB:
                    for (b = a.bodyB.m_xf.R, c = a.localPlaneNormal, this.m_normal.x = b.col1.x * c.x + b.col2.x * c.y, this.m_normal.y = b.col1.y * c.x + b.col2.y * c.y, b = a.bodyB.m_xf.R, c = a.localPoint, g = a.bodyB.m_xf.position.x + (b.col1.x * c.x + b.col2.x * c.y), h = a.bodyB.m_xf.position.y + (b.col1.y * c.x + b.col2.y * c.y), b = a.bodyA.m_xf.R, d = 0; d < a.pointCount; ++d) c = a.points[d].localPoint, e = a.bodyA.m_xf.position.x + (b.col1.x * c.x + b.col2.x * c.y), f = a.bodyA.m_xf.position.y + (b.col1.y * c.x + b.col2.y * c.y), this.m_separations[d] = (e - g) * this.m_normal.x + (f - h) * this.m_normal.y - a.radius, this.m_points[d].Set(e, f);
                    this.m_normal.x *= -1, this.m_normal.y *= -1
            }
        }, Box2D.postDefs.push(function() {
            Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointA = new y, Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointB = new y
        })
    }(),
    function() {
        var a = (Box2D.Dynamics.b2Body, Box2D.Dynamics.b2BodyDef, Box2D.Dynamics.b2ContactFilter, Box2D.Dynamics.b2ContactImpulse, Box2D.Dynamics.b2ContactListener, Box2D.Dynamics.b2ContactManager, Box2D.Dynamics.b2DebugDraw, Box2D.Dynamics.b2DestructionListener, Box2D.Dynamics.b2FilterData, Box2D.Dynamics.b2Fixture, Box2D.Dynamics.b2FixtureDef, Box2D.Dynamics.b2Island, Box2D.Dynamics.b2TimeStep, Box2D.Dynamics.b2World, Box2D.Common.Math.b2Mat22),
            b = (Box2D.Common.Math.b2Mat33, Box2D.Common.Math.b2Math),
            c = (Box2D.Common.Math.b2Sweep, Box2D.Common.Math.b2Transform, Box2D.Common.Math.b2Vec2),
            d = (Box2D.Common.Math.b2Vec3, Box2D.Common.b2Color),
            e = (Box2D.Common.b2internal, Box2D.Common.b2Settings, Box2D.Collision.Shapes.b2CircleShape, Box2D.Collision.Shapes.b2EdgeChainDef, Box2D.Collision.Shapes.b2EdgeShape, Box2D.Collision.Shapes.b2MassData, Box2D.Collision.Shapes.b2PolygonShape, Box2D.Collision.Shapes.b2Shape, Box2D.Dynamics.Controllers.b2BuoyancyController),
            f = Box2D.Dynamics.Controllers.b2ConstantAccelController,
            g = Box2D.Dynamics.Controllers.b2ConstantForceController,
            h = Box2D.Dynamics.Controllers.b2Controller,
            i = Box2D.Dynamics.Controllers.b2ControllerEdge,
            j = Box2D.Dynamics.Controllers.b2GravityController,
            k = Box2D.Dynamics.Controllers.b2TensorDampingController;
        Box2D.inherit(e, Box2D.Dynamics.Controllers.b2Controller), e.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype, e.b2BuoyancyController = function() {
            Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments), this.normal = new c(0, -1), this.offset = 0, this.density = 0, this.velocity = new c(0, 0), this.linearDrag = 2, this.angularDrag = 1, this.useDensity = !1, this.useWorldGravity = !0, this.gravity = null
        }, e.prototype.Step = function() {
            if (this.m_bodyList) {
                this.useWorldGravity && (this.gravity = this.GetWorld().GetGravity().Copy());
                for (var a = this.m_bodyList; a; a = a.nextBody) {
                    var b = a.body;
                    if (0 != b.IsAwake()) {
                        for (var d = new c, e = new c, f = 0, g = 0, h = b.GetFixtureList(); h; h = h.GetNext()) {
                            var i = new c,
                                j = h.GetShape().ComputeSubmergedArea(this.normal, this.offset, b.GetTransform(), i);
                            f += j, d.x += j * i.x, d.y += j * i.y;
                            var k = 0;
                            k = (this.useDensity, 1), g += j * k, e.x += j * i.x * k, e.y += j * i.y * k
                        }
                        if (d.x /= f, d.y /= f, e.x /= g, e.y /= g, !(f < Number.MIN_VALUE)) {
                            var l = this.gravity.GetNegative();
                            l.Multiply(this.density * f), b.ApplyForce(l, e);
                            var m = b.GetLinearVelocityFromWorldPoint(d);
                            m.Subtract(this.velocity), m.Multiply(-this.linearDrag * f), b.ApplyForce(m, d), b.ApplyTorque(-b.GetInertia() / b.GetMass() * f * b.GetAngularVelocity() * this.angularDrag)
                        }
                    }
                }
            }
        }, e.prototype.Draw = function(a) {
            var b = 1e3,
                e = new c,
                f = new c;
            e.x = this.normal.x * this.offset + this.normal.y * b, e.y = this.normal.y * this.offset - this.normal.x * b, f.x = this.normal.x * this.offset - this.normal.y * b, f.y = this.normal.y * this.offset + this.normal.x * b;
            var g = new d(0, 0, 1);
            a.DrawSegment(e, f, g)
        }, Box2D.inherit(f, Box2D.Dynamics.Controllers.b2Controller), f.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype, f.b2ConstantAccelController = function() {
            Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments), this.A = new c(0, 0)
        }, f.prototype.Step = function(a) {
            for (var b = new c(this.A.x * a.dt, this.A.y * a.dt), d = this.m_bodyList; d; d = d.nextBody) {
                var e = d.body;
                e.IsAwake() && e.SetLinearVelocity(new c(e.GetLinearVelocity().x + b.x, e.GetLinearVelocity().y + b.y))
            }
        }, Box2D.inherit(g, Box2D.Dynamics.Controllers.b2Controller), g.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype, g.b2ConstantForceController = function() {
            Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments), this.F = new c(0, 0)
        }, g.prototype.Step = function() {
            for (var a = this.m_bodyList; a; a = a.nextBody) {
                var b = a.body;
                b.IsAwake() && b.ApplyForce(this.F, b.GetWorldCenter())
            }
        }, h.b2Controller = function() {}, h.prototype.Step = function() {}, h.prototype.Draw = function() {}, h.prototype.AddBody = function(a) {
            var b = new i;
            b.controller = this, b.body = a, b.nextBody = this.m_bodyList, b.prevBody = null, this.m_bodyList = b, b.nextBody && (b.nextBody.prevBody = b), this.m_bodyCount++, b.nextController = a.m_controllerList, b.prevController = null, a.m_controllerList = b, b.nextController && (b.nextController.prevController = b), a.m_controllerCount++
        }, h.prototype.RemoveBody = function(a) {
            for (var b = a.m_controllerList; b && b.controller != this;) b = b.nextController;
            b.prevBody && (b.prevBody.nextBody = b.nextBody), b.nextBody && (b.nextBody.prevBody = b.prevBody), b.nextController && (b.nextController.prevController = b.prevController), b.prevController && (b.prevController.nextController = b.nextController), this.m_bodyList == b && (this.m_bodyList = b.nextBody), a.m_controllerList == b && (a.m_controllerList = b.nextController), a.m_controllerCount--, this.m_bodyCount--
        }, h.prototype.Clear = function() {
            for (; this.m_bodyList;) this.RemoveBody(this.m_bodyList.body)
        }, h.prototype.GetNext = function() {
            return this.m_next
        }, h.prototype.GetWorld = function() {
            return this.m_world
        }, h.prototype.GetBodyList = function() {
            return this.m_bodyList
        }, i.b2ControllerEdge = function() {}, Box2D.inherit(j, Box2D.Dynamics.Controllers.b2Controller), j.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype, j.b2GravityController = function() {
            Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments), this.G = 1, this.invSqr = !0
        }, j.prototype.Step = function() {
            var a = null,
                b = null,
                d = null,
                e = 0,
                f = null,
                g = null,
                h = null,
                i = 0,
                j = 0,
                k = 0,
                l = null;
            if (this.invSqr)
                for (a = this.m_bodyList; a; a = a.nextBody)
                    for (b = a.body, d = b.GetWorldCenter(), e = b.GetMass(), f = this.m_bodyList; f != a; f = f.nextBody) g = f.body, h = g.GetWorldCenter(), i = h.x - d.x, j = h.y - d.y, k = i * i + j * j, k < Number.MIN_VALUE || (l = new c(i, j), l.Multiply(this.G / k / Math.sqrt(k) * e * g.GetMass()), b.IsAwake() && b.ApplyForce(l, d), l.Multiply(-1), g.IsAwake() && g.ApplyForce(l, h));
            else
                for (a = this.m_bodyList; a; a = a.nextBody)
                    for (b = a.body, d = b.GetWorldCenter(), e = b.GetMass(), f = this.m_bodyList; f != a; f = f.nextBody) g = f.body, h = g.GetWorldCenter(), i = h.x - d.x, j = h.y - d.y, k = i * i + j * j, k < Number.MIN_VALUE || (l = new c(i, j), l.Multiply(this.G / k * e * g.GetMass()), b.IsAwake() && b.ApplyForce(l, d), l.Multiply(-1), g.IsAwake() && g.ApplyForce(l, h))
        }, Box2D.inherit(k, Box2D.Dynamics.Controllers.b2Controller), k.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype, k.b2TensorDampingController = function() {
            Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments), this.T = new a, this.maxTimestep = 0
        }, k.prototype.SetAxisAligned = function(a, b) {
            void 0 === a && (a = 0), void 0 === b && (b = 0), this.T.col1.x = -a, this.T.col1.y = 0, this.T.col2.x = 0, this.T.col2.y = -b, this.maxTimestep = a > 0 || b > 0 ? 1 / Math.max(a, b) : 0
        }, k.prototype.Step = function(a) {
            var d = a.dt;
            if (!(d <= Number.MIN_VALUE)) {
                d > this.maxTimestep && this.maxTimestep > 0 && (d = this.maxTimestep);
                for (var e = this.m_bodyList; e; e = e.nextBody) {
                    var f = e.body;
                    if (f.IsAwake()) {
                        var g = f.GetWorldVector(b.MulMV(this.T, f.GetLocalVector(f.GetLinearVelocity())));
                        f.SetLinearVelocity(new c(f.GetLinearVelocity().x + g.x * d, f.GetLinearVelocity().y + g.y * d))
                    }
                }
            }
        }
    }(),
    function() {
        {
            var a = (Box2D.Common.b2Color, Box2D.Common.b2internal, Box2D.Common.b2Settings),
                b = Box2D.Common.Math.b2Mat22,
                c = Box2D.Common.Math.b2Mat33,
                d = Box2D.Common.Math.b2Math,
                e = (Box2D.Common.Math.b2Sweep, Box2D.Common.Math.b2Transform, Box2D.Common.Math.b2Vec2),
                f = Box2D.Common.Math.b2Vec3,
                g = Box2D.Dynamics.Joints.b2DistanceJoint,
                h = Box2D.Dynamics.Joints.b2DistanceJointDef,
                i = Box2D.Dynamics.Joints.b2FrictionJoint,
                j = Box2D.Dynamics.Joints.b2FrictionJointDef,
                k = Box2D.Dynamics.Joints.b2GearJoint,
                l = Box2D.Dynamics.Joints.b2GearJointDef,
                m = Box2D.Dynamics.Joints.b2Jacobian,
                n = Box2D.Dynamics.Joints.b2Joint,
                o = Box2D.Dynamics.Joints.b2JointDef,
                p = Box2D.Dynamics.Joints.b2JointEdge,
                q = Box2D.Dynamics.Joints.b2LineJoint,
                r = Box2D.Dynamics.Joints.b2LineJointDef,
                s = Box2D.Dynamics.Joints.b2MouseJoint,
                t = Box2D.Dynamics.Joints.b2MouseJointDef,
                u = Box2D.Dynamics.Joints.b2PrismaticJoint,
                v = Box2D.Dynamics.Joints.b2PrismaticJointDef,
                w = Box2D.Dynamics.Joints.b2PulleyJoint,
                x = Box2D.Dynamics.Joints.b2PulleyJointDef,
                y = Box2D.Dynamics.Joints.b2RevoluteJoint,
                z = Box2D.Dynamics.Joints.b2RevoluteJointDef,
                A = Box2D.Dynamics.Joints.b2WeldJoint,
                B = Box2D.Dynamics.Joints.b2WeldJointDef;
            Box2D.Dynamics.b2Body, Box2D.Dynamics.b2BodyDef, Box2D.Dynamics.b2ContactFilter, Box2D.Dynamics.b2ContactImpulse, Box2D.Dynamics.b2ContactListener, Box2D.Dynamics.b2ContactManager, Box2D.Dynamics.b2DebugDraw, Box2D.Dynamics.b2DestructionListener, Box2D.Dynamics.b2FilterData, Box2D.Dynamics.b2Fixture, Box2D.Dynamics.b2FixtureDef, Box2D.Dynamics.b2Island, Box2D.Dynamics.b2TimeStep, Box2D.Dynamics.b2World
        }
        Box2D.inherit(g, Box2D.Dynamics.Joints.b2Joint), g.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype, g.b2DistanceJoint = function() {
            Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_localAnchor1 = new e, this.m_localAnchor2 = new e, this.m_u = new e
        }, g.prototype.GetAnchorA = function() {
            return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
        }, g.prototype.GetAnchorB = function() {
            return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
        }, g.prototype.GetReactionForce = function(a) {
            return void 0 === a && (a = 0), new e(a * this.m_impulse * this.m_u.x, a * this.m_impulse * this.m_u.y)
        }, g.prototype.GetReactionTorque = function(a) {
            return void 0 === a && (a = 0), 0
        }, g.prototype.GetLength = function() {
            return this.m_length
        }, g.prototype.SetLength = function(a) {
            void 0 === a && (a = 0), this.m_length = a
        }, g.prototype.GetFrequency = function() {
            return this.m_frequencyHz
        }, g.prototype.SetFrequency = function(a) {
            void 0 === a && (a = 0), this.m_frequencyHz = a
        }, g.prototype.GetDampingRatio = function() {
            return this.m_dampingRatio
        }, g.prototype.SetDampingRatio = function(a) {
            void 0 === a && (a = 0), this.m_dampingRatio = a
        }, g.prototype.b2DistanceJoint = function(a) {
            this.__super.b2Joint.call(this, a);
            this.m_localAnchor1.SetV(a.localAnchorA), this.m_localAnchor2.SetV(a.localAnchorB), this.m_length = a.length, this.m_frequencyHz = a.frequencyHz, this.m_dampingRatio = a.dampingRatio, this.m_impulse = 0, this.m_gamma = 0, this.m_bias = 0
        }, g.prototype.InitVelocityConstraints = function(b) {
            var c, d = 0,
                e = this.m_bodyA,
                f = this.m_bodyB;
            c = e.m_xf.R;
            var g = this.m_localAnchor1.x - e.m_sweep.localCenter.x,
                h = this.m_localAnchor1.y - e.m_sweep.localCenter.y;
            d = c.col1.x * g + c.col2.x * h, h = c.col1.y * g + c.col2.y * h, g = d, c = f.m_xf.R;
            var i = this.m_localAnchor2.x - f.m_sweep.localCenter.x,
                j = this.m_localAnchor2.y - f.m_sweep.localCenter.y;
            d = c.col1.x * i + c.col2.x * j, j = c.col1.y * i + c.col2.y * j, i = d, this.m_u.x = f.m_sweep.c.x + i - e.m_sweep.c.x - g, this.m_u.y = f.m_sweep.c.y + j - e.m_sweep.c.y - h;
            var k = Math.sqrt(this.m_u.x * this.m_u.x + this.m_u.y * this.m_u.y);
            k > a.b2_linearSlop ? this.m_u.Multiply(1 / k) : this.m_u.SetZero();
            var l = g * this.m_u.y - h * this.m_u.x,
                m = i * this.m_u.y - j * this.m_u.x,
                n = e.m_invMass + e.m_invI * l * l + f.m_invMass + f.m_invI * m * m;
            if (this.m_mass = 0 != n ? 1 / n : 0, this.m_frequencyHz > 0) {
                var o = k - this.m_length,
                    p = 2 * Math.PI * this.m_frequencyHz,
                    q = 2 * this.m_mass * this.m_dampingRatio * p,
                    r = this.m_mass * p * p;
                this.m_gamma = b.dt * (q + b.dt * r), this.m_gamma = 0 != this.m_gamma ? 1 / this.m_gamma : 0, this.m_bias = o * b.dt * r * this.m_gamma, this.m_mass = n + this.m_gamma, this.m_mass = 0 != this.m_mass ? 1 / this.m_mass : 0
            }
            if (b.warmStarting) {
                this.m_impulse *= b.dtRatio;
                var s = this.m_impulse * this.m_u.x,
                    t = this.m_impulse * this.m_u.y;
                e.m_linearVelocity.x -= e.m_invMass * s, e.m_linearVelocity.y -= e.m_invMass * t, e.m_angularVelocity -= e.m_invI * (g * t - h * s), f.m_linearVelocity.x += f.m_invMass * s, f.m_linearVelocity.y += f.m_invMass * t, f.m_angularVelocity += f.m_invI * (i * t - j * s)
            } else this.m_impulse = 0
        }, g.prototype.SolveVelocityConstraints = function() {
            var a, b = this.m_bodyA,
                c = this.m_bodyB;
            a = b.m_xf.R;
            var d = this.m_localAnchor1.x - b.m_sweep.localCenter.x,
                e = this.m_localAnchor1.y - b.m_sweep.localCenter.y,
                f = a.col1.x * d + a.col2.x * e;
            e = a.col1.y * d + a.col2.y * e, d = f, a = c.m_xf.R;
            var g = this.m_localAnchor2.x - c.m_sweep.localCenter.x,
                h = this.m_localAnchor2.y - c.m_sweep.localCenter.y;
            f = a.col1.x * g + a.col2.x * h, h = a.col1.y * g + a.col2.y * h, g = f;
            var i = b.m_linearVelocity.x + -b.m_angularVelocity * e,
                j = b.m_linearVelocity.y + b.m_angularVelocity * d,
                k = c.m_linearVelocity.x + -c.m_angularVelocity * h,
                l = c.m_linearVelocity.y + c.m_angularVelocity * g,
                m = this.m_u.x * (k - i) + this.m_u.y * (l - j),
                n = -this.m_mass * (m + this.m_bias + this.m_gamma * this.m_impulse);
            this.m_impulse += n;
            var o = n * this.m_u.x,
                p = n * this.m_u.y;
            b.m_linearVelocity.x -= b.m_invMass * o, b.m_linearVelocity.y -= b.m_invMass * p, b.m_angularVelocity -= b.m_invI * (d * p - e * o), c.m_linearVelocity.x += c.m_invMass * o, c.m_linearVelocity.y += c.m_invMass * p, c.m_angularVelocity += c.m_invI * (g * p - h * o)
        }, g.prototype.SolvePositionConstraints = function(b) {
            void 0 === b && (b = 0);
            var c;
            if (this.m_frequencyHz > 0) return !0;
            var e = this.m_bodyA,
                f = this.m_bodyB;
            c = e.m_xf.R;
            var g = this.m_localAnchor1.x - e.m_sweep.localCenter.x,
                h = this.m_localAnchor1.y - e.m_sweep.localCenter.y,
                i = c.col1.x * g + c.col2.x * h;
            h = c.col1.y * g + c.col2.y * h, g = i, c = f.m_xf.R;
            var j = this.m_localAnchor2.x - f.m_sweep.localCenter.x,
                k = this.m_localAnchor2.y - f.m_sweep.localCenter.y;
            i = c.col1.x * j + c.col2.x * k, k = c.col1.y * j + c.col2.y * k, j = i;
            var l = f.m_sweep.c.x + j - e.m_sweep.c.x - g,
                m = f.m_sweep.c.y + k - e.m_sweep.c.y - h,
                n = Math.sqrt(l * l + m * m);
            l /= n, m /= n;
            var o = n - this.m_length;
            o = d.Clamp(o, -a.b2_maxLinearCorrection, a.b2_maxLinearCorrection);
            var p = -this.m_mass * o;
            this.m_u.Set(l, m);
            var q = p * this.m_u.x,
                r = p * this.m_u.y;
            return e.m_sweep.c.x -= e.m_invMass * q, e.m_sweep.c.y -= e.m_invMass * r, e.m_sweep.a -= e.m_invI * (g * r - h * q), f.m_sweep.c.x += f.m_invMass * q, f.m_sweep.c.y += f.m_invMass * r, f.m_sweep.a += f.m_invI * (j * r - k * q), e.SynchronizeTransform(), f.SynchronizeTransform(), d.Abs(o) < a.b2_linearSlop
        }, Box2D.inherit(h, Box2D.Dynamics.Joints.b2JointDef), h.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype, h.b2DistanceJointDef = function() {
            Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new e, this.localAnchorB = new e
        }, h.prototype.b2DistanceJointDef = function() {
            this.__super.b2JointDef.call(this), this.type = n.e_distanceJoint, this.length = 1, this.frequencyHz = 0, this.dampingRatio = 0
        }, h.prototype.Initialize = function(a, b, c, d) {
            this.bodyA = a, this.bodyB = b, this.localAnchorA.SetV(this.bodyA.GetLocalPoint(c)), this.localAnchorB.SetV(this.bodyB.GetLocalPoint(d));
            var e = d.x - c.x,
                f = d.y - c.y;
            this.length = Math.sqrt(e * e + f * f), this.frequencyHz = 0, this.dampingRatio = 0
        }, Box2D.inherit(i, Box2D.Dynamics.Joints.b2Joint), i.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype, i.b2FrictionJoint = function() {
            Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_localAnchorA = new e, this.m_localAnchorB = new e, this.m_linearMass = new b, this.m_linearImpulse = new e
        }, i.prototype.GetAnchorA = function() {
            return this.m_bodyA.GetWorldPoint(this.m_localAnchorA)
        }, i.prototype.GetAnchorB = function() {
            return this.m_bodyB.GetWorldPoint(this.m_localAnchorB)
        }, i.prototype.GetReactionForce = function(a) {
            return void 0 === a && (a = 0), new e(a * this.m_linearImpulse.x, a * this.m_linearImpulse.y)
        }, i.prototype.GetReactionTorque = function(a) {
            return void 0 === a && (a = 0), a * this.m_angularImpulse
        }, i.prototype.SetMaxForce = function(a) {
            void 0 === a && (a = 0), this.m_maxForce = a
        }, i.prototype.GetMaxForce = function() {
            return this.m_maxForce
        }, i.prototype.SetMaxTorque = function(a) {
            void 0 === a && (a = 0), this.m_maxTorque = a
        }, i.prototype.GetMaxTorque = function() {
            return this.m_maxTorque
        }, i.prototype.b2FrictionJoint = function(a) {
            this.__super.b2Joint.call(this, a), this.m_localAnchorA.SetV(a.localAnchorA), this.m_localAnchorB.SetV(a.localAnchorB), this.m_linearMass.SetZero(), this.m_angularMass = 0, this.m_linearImpulse.SetZero(), this.m_angularImpulse = 0, this.m_maxForce = a.maxForce, this.m_maxTorque = a.maxTorque
        }, i.prototype.InitVelocityConstraints = function(a) {
            var c, d = 0,
                e = this.m_bodyA,
                f = this.m_bodyB;
            c = e.m_xf.R;
            var g = this.m_localAnchorA.x - e.m_sweep.localCenter.x,
                h = this.m_localAnchorA.y - e.m_sweep.localCenter.y;
            d = c.col1.x * g + c.col2.x * h, h = c.col1.y * g + c.col2.y * h, g = d, c = f.m_xf.R;
            var i = this.m_localAnchorB.x - f.m_sweep.localCenter.x,
                j = this.m_localAnchorB.y - f.m_sweep.localCenter.y;
            d = c.col1.x * i + c.col2.x * j, j = c.col1.y * i + c.col2.y * j, i = d;
            var k = e.m_invMass,
                l = f.m_invMass,
                m = e.m_invI,
                n = f.m_invI,
                o = new b;
            if (o.col1.x = k + l, o.col2.x = 0, o.col1.y = 0, o.col2.y = k + l, o.col1.x += m * h * h, o.col2.x += -m * g * h, o.col1.y += -m * g * h, o.col2.y += m * g * g, o.col1.x += n * j * j, o.col2.x += -n * i * j, o.col1.y += -n * i * j, o.col2.y += n * i * i, o.GetInverse(this.m_linearMass), this.m_angularMass = m + n, this.m_angularMass > 0 && (this.m_angularMass = 1 / this.m_angularMass), a.warmStarting) {
                this.m_linearImpulse.x *= a.dtRatio, this.m_linearImpulse.y *= a.dtRatio, this.m_angularImpulse *= a.dtRatio;
                var p = this.m_linearImpulse;
                e.m_linearVelocity.x -= k * p.x, e.m_linearVelocity.y -= k * p.y, e.m_angularVelocity -= m * (g * p.y - h * p.x + this.m_angularImpulse), f.m_linearVelocity.x += l * p.x, f.m_linearVelocity.y += l * p.y, f.m_angularVelocity += n * (i * p.y - j * p.x + this.m_angularImpulse)
            } else this.m_linearImpulse.SetZero(), this.m_angularImpulse = 0
        }, i.prototype.SolveVelocityConstraints = function(a) {
            var b, c = 0,
                f = this.m_bodyA,
                g = this.m_bodyB,
                h = f.m_linearVelocity,
                i = f.m_angularVelocity,
                j = g.m_linearVelocity,
                k = g.m_angularVelocity,
                l = f.m_invMass,
                m = g.m_invMass,
                n = f.m_invI,
                o = g.m_invI;
            b = f.m_xf.R;
            var p = this.m_localAnchorA.x - f.m_sweep.localCenter.x,
                q = this.m_localAnchorA.y - f.m_sweep.localCenter.y;
            c = b.col1.x * p + b.col2.x * q, q = b.col1.y * p + b.col2.y * q, p = c, b = g.m_xf.R;
            var r = this.m_localAnchorB.x - g.m_sweep.localCenter.x,
                s = this.m_localAnchorB.y - g.m_sweep.localCenter.y;
            c = b.col1.x * r + b.col2.x * s, s = b.col1.y * r + b.col2.y * s, r = c;
            var t = 0,
                u = k - i,
                v = -this.m_angularMass * u,
                w = this.m_angularImpulse;
            t = a.dt * this.m_maxTorque, this.m_angularImpulse = d.Clamp(this.m_angularImpulse + v, -t, t), v = this.m_angularImpulse - w, i -= n * v, k += o * v;
            var x = j.x - k * s - h.x + i * q,
                y = j.y + k * r - h.y - i * p,
                z = d.MulMV(this.m_linearMass, new e(-x, -y)),
                A = this.m_linearImpulse.Copy();
            this.m_linearImpulse.Add(z), t = a.dt * this.m_maxForce, this.m_linearImpulse.LengthSquared() > t * t && (this.m_linearImpulse.Normalize(), this.m_linearImpulse.Multiply(t)), z = d.SubtractVV(this.m_linearImpulse, A), h.x -= l * z.x, h.y -= l * z.y, i -= n * (p * z.y - q * z.x), j.x += m * z.x, j.y += m * z.y, k += o * (r * z.y - s * z.x), f.m_angularVelocity = i, g.m_angularVelocity = k
        }, i.prototype.SolvePositionConstraints = function(a) {
            return void 0 === a && (a = 0), !0
        }, Box2D.inherit(j, Box2D.Dynamics.Joints.b2JointDef), j.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype, j.b2FrictionJointDef = function() {
            Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new e, this.localAnchorB = new e
        }, j.prototype.b2FrictionJointDef = function() {
            this.__super.b2JointDef.call(this), this.type = n.e_frictionJoint, this.maxForce = 0, this.maxTorque = 0
        }, j.prototype.Initialize = function(a, b, c) {
            this.bodyA = a, this.bodyB = b, this.localAnchorA.SetV(this.bodyA.GetLocalPoint(c)), this.localAnchorB.SetV(this.bodyB.GetLocalPoint(c))
        }, Box2D.inherit(k, Box2D.Dynamics.Joints.b2Joint), k.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype, k.b2GearJoint = function() {
            Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_groundAnchor1 = new e, this.m_groundAnchor2 = new e, this.m_localAnchor1 = new e, this.m_localAnchor2 = new e, this.m_J = new m
        }, k.prototype.GetAnchorA = function() {
            return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
        }, k.prototype.GetAnchorB = function() {
            return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
        }, k.prototype.GetReactionForce = function(a) {
            return void 0 === a && (a = 0), new e(a * this.m_impulse * this.m_J.linearB.x, a * this.m_impulse * this.m_J.linearB.y)
        }, k.prototype.GetReactionTorque = function(a) {
            void 0 === a && (a = 0);
            var b = this.m_bodyB.m_xf.R,
                c = this.m_localAnchor1.x - this.m_bodyB.m_sweep.localCenter.x,
                d = this.m_localAnchor1.y - this.m_bodyB.m_sweep.localCenter.y,
                e = b.col1.x * c + b.col2.x * d;
            d = b.col1.y * c + b.col2.y * d, c = e;
            var f = this.m_impulse * this.m_J.linearB.x,
                g = this.m_impulse * this.m_J.linearB.y;
            return a * (this.m_impulse * this.m_J.angularB - c * g + d * f)
        }, k.prototype.GetRatio = function() {
            return this.m_ratio
        }, k.prototype.SetRatio = function(a) {
            void 0 === a && (a = 0), this.m_ratio = a
        }, k.prototype.b2GearJoint = function(a) {
            this.__super.b2Joint.call(this, a);
            var b = parseInt(a.joint1.m_type),
                c = parseInt(a.joint2.m_type);
            this.m_revolute1 = null, this.m_prismatic1 = null, this.m_revolute2 = null, this.m_prismatic2 = null;
            var d = 0,
                e = 0;
            this.m_ground1 = a.joint1.GetBodyA(), this.m_bodyA = a.joint1.GetBodyB(), b == n.e_revoluteJoint ? (this.m_revolute1 = a.joint1 instanceof y ? a.joint1 : null, this.m_groundAnchor1.SetV(this.m_revolute1.m_localAnchor1), this.m_localAnchor1.SetV(this.m_revolute1.m_localAnchor2), d = this.m_revolute1.GetJointAngle()) : (this.m_prismatic1 = a.joint1 instanceof u ? a.joint1 : null, this.m_groundAnchor1.SetV(this.m_prismatic1.m_localAnchor1), this.m_localAnchor1.SetV(this.m_prismatic1.m_localAnchor2), d = this.m_prismatic1.GetJointTranslation()), this.m_ground2 = a.joint2.GetBodyA(), this.m_bodyB = a.joint2.GetBodyB(), c == n.e_revoluteJoint ? (this.m_revolute2 = a.joint2 instanceof y ? a.joint2 : null, this.m_groundAnchor2.SetV(this.m_revolute2.m_localAnchor1), this.m_localAnchor2.SetV(this.m_revolute2.m_localAnchor2), e = this.m_revolute2.GetJointAngle()) : (this.m_prismatic2 = a.joint2 instanceof u ? a.joint2 : null, this.m_groundAnchor2.SetV(this.m_prismatic2.m_localAnchor1), this.m_localAnchor2.SetV(this.m_prismatic2.m_localAnchor2), e = this.m_prismatic2.GetJointTranslation()), this.m_ratio = a.ratio, this.m_constant = d + this.m_ratio * e, this.m_impulse = 0
        }, k.prototype.InitVelocityConstraints = function(a) {
            var b, c, d = this.m_ground1,
                e = this.m_ground2,
                f = this.m_bodyA,
                g = this.m_bodyB,
                h = 0,
                i = 0,
                j = 0,
                k = 0,
                l = 0,
                m = 0,
                n = 0;
            this.m_J.SetZero(), this.m_revolute1 ? (this.m_J.angularA = -1, n += f.m_invI) : (b = d.m_xf.R, c = this.m_prismatic1.m_localXAxis1, h = b.col1.x * c.x + b.col2.x * c.y, i = b.col1.y * c.x + b.col2.y * c.y, b = f.m_xf.R, j = this.m_localAnchor1.x - f.m_sweep.localCenter.x, k = this.m_localAnchor1.y - f.m_sweep.localCenter.y, m = b.col1.x * j + b.col2.x * k, k = b.col1.y * j + b.col2.y * k, j = m, l = j * i - k * h, this.m_J.linearA.Set(-h, -i), this.m_J.angularA = -l, n += f.m_invMass + f.m_invI * l * l), this.m_revolute2 ? (this.m_J.angularB = -this.m_ratio, n += this.m_ratio * this.m_ratio * g.m_invI) : (b = e.m_xf.R, c = this.m_prismatic2.m_localXAxis1, h = b.col1.x * c.x + b.col2.x * c.y, i = b.col1.y * c.x + b.col2.y * c.y, b = g.m_xf.R, j = this.m_localAnchor2.x - g.m_sweep.localCenter.x, k = this.m_localAnchor2.y - g.m_sweep.localCenter.y, m = b.col1.x * j + b.col2.x * k, k = b.col1.y * j + b.col2.y * k, j = m, l = j * i - k * h, this.m_J.linearB.Set(-this.m_ratio * h, -this.m_ratio * i), this.m_J.angularB = -this.m_ratio * l, n += this.m_ratio * this.m_ratio * (g.m_invMass + g.m_invI * l * l)), this.m_mass = n > 0 ? 1 / n : 0, a.warmStarting ? (f.m_linearVelocity.x += f.m_invMass * this.m_impulse * this.m_J.linearA.x, f.m_linearVelocity.y += f.m_invMass * this.m_impulse * this.m_J.linearA.y, f.m_angularVelocity += f.m_invI * this.m_impulse * this.m_J.angularA, g.m_linearVelocity.x += g.m_invMass * this.m_impulse * this.m_J.linearB.x, g.m_linearVelocity.y += g.m_invMass * this.m_impulse * this.m_J.linearB.y, g.m_angularVelocity += g.m_invI * this.m_impulse * this.m_J.angularB) : this.m_impulse = 0
        }, k.prototype.SolveVelocityConstraints = function() {
            var a = this.m_bodyA,
                b = this.m_bodyB,
                c = this.m_J.Compute(a.m_linearVelocity, a.m_angularVelocity, b.m_linearVelocity, b.m_angularVelocity),
                d = -this.m_mass * c;
            this.m_impulse += d, a.m_linearVelocity.x += a.m_invMass * d * this.m_J.linearA.x, a.m_linearVelocity.y += a.m_invMass * d * this.m_J.linearA.y, a.m_angularVelocity += a.m_invI * d * this.m_J.angularA, b.m_linearVelocity.x += b.m_invMass * d * this.m_J.linearB.x, b.m_linearVelocity.y += b.m_invMass * d * this.m_J.linearB.y, b.m_angularVelocity += b.m_invI * d * this.m_J.angularB
        }, k.prototype.SolvePositionConstraints = function(b) {
            void 0 === b && (b = 0);
            var c = 0,
                d = this.m_bodyA,
                e = this.m_bodyB,
                f = 0,
                g = 0;
            f = this.m_revolute1 ? this.m_revolute1.GetJointAngle() : this.m_prismatic1.GetJointTranslation(), g = this.m_revolute2 ? this.m_revolute2.GetJointAngle() : this.m_prismatic2.GetJointTranslation();
            var h = this.m_constant - (f + this.m_ratio * g),
                i = -this.m_mass * h;
            return d.m_sweep.c.x += d.m_invMass * i * this.m_J.linearA.x, d.m_sweep.c.y += d.m_invMass * i * this.m_J.linearA.y, d.m_sweep.a += d.m_invI * i * this.m_J.angularA, e.m_sweep.c.x += e.m_invMass * i * this.m_J.linearB.x, e.m_sweep.c.y += e.m_invMass * i * this.m_J.linearB.y, e.m_sweep.a += e.m_invI * i * this.m_J.angularB, d.SynchronizeTransform(), e.SynchronizeTransform(), c < a.b2_linearSlop
        }, Box2D.inherit(l, Box2D.Dynamics.Joints.b2JointDef), l.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype, l.b2GearJointDef = function() {
            Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments)
        }, l.prototype.b2GearJointDef = function() {
            this.__super.b2JointDef.call(this), this.type = n.e_gearJoint, this.joint1 = null, this.joint2 = null, this.ratio = 1
        }, m.b2Jacobian = function() {
            this.linearA = new e, this.linearB = new e
        }, m.prototype.SetZero = function() {
            this.linearA.SetZero(), this.angularA = 0, this.linearB.SetZero(), this.angularB = 0
        }, m.prototype.Set = function(a, b, c, d) {
            void 0 === b && (b = 0), void 0 === d && (d = 0), this.linearA.SetV(a), this.angularA = b, this.linearB.SetV(c), this.angularB = d
        }, m.prototype.Compute = function(a, b, c, d) {
            return void 0 === b && (b = 0), void 0 === d && (d = 0), this.linearA.x * a.x + this.linearA.y * a.y + this.angularA * b + (this.linearB.x * c.x + this.linearB.y * c.y) + this.angularB * d
        }, n.b2Joint = function() {
            this.m_edgeA = new p, this.m_edgeB = new p, this.m_localCenterA = new e, this.m_localCenterB = new e
        }, n.prototype.GetType = function() {
            return this.m_type
        }, n.prototype.GetAnchorA = function() {
            return null
        }, n.prototype.GetAnchorB = function() {
            return null
        }, n.prototype.GetReactionForce = function(a) {
            return void 0 === a && (a = 0), null
        }, n.prototype.GetReactionTorque = function(a) {
            return void 0 === a && (a = 0), 0
        }, n.prototype.GetBodyA = function() {
            return this.m_bodyA
        }, n.prototype.GetBodyB = function() {
            return this.m_bodyB
        }, n.prototype.GetNext = function() {
            return this.m_next
        }, n.prototype.GetUserData = function() {
            return this.m_userData
        }, n.prototype.SetUserData = function(a) {
            this.m_userData = a
        }, n.prototype.IsActive = function() {
            return this.m_bodyA.IsActive() && this.m_bodyB.IsActive()
        }, n.Create = function(a) {
            var b = null;
            switch (a.type) {
                case n.e_distanceJoint:
                    b = new g(a instanceof h ? a : null);
                    break;
                case n.e_mouseJoint:
                    b = new s(a instanceof t ? a : null);
                    break;
                case n.e_prismaticJoint:
                    b = new u(a instanceof v ? a : null);
                    break;
                case n.e_revoluteJoint:
                    b = new y(a instanceof z ? a : null);
                    break;
                case n.e_pulleyJoint:
                    b = new w(a instanceof x ? a : null);
                    break;
                case n.e_gearJoint:
                    b = new k(a instanceof l ? a : null);
                    break;
                case n.e_lineJoint:
                    b = new q(a instanceof r ? a : null);
                    break;
                case n.e_weldJoint:
                    b = new A(a instanceof B ? a : null);
                    break;
                case n.e_frictionJoint:
                    b = new i(a instanceof j ? a : null)
            }
            return b
        }, n.Destroy = function() {}, n.prototype.b2Joint = function(b) {
            a.b2Assert(b.bodyA != b.bodyB), this.m_type = b.type, this.m_prev = null, this.m_next = null, this.m_bodyA = b.bodyA, this.m_bodyB = b.bodyB, this.m_collideConnected = b.collideConnected, this.m_islandFlag = !1, this.m_userData = b.userData
        }, n.prototype.InitVelocityConstraints = function() {}, n.prototype.SolveVelocityConstraints = function() {}, n.prototype.FinalizeVelocityConstraints = function() {}, n.prototype.SolvePositionConstraints = function(a) {
            return void 0 === a && (a = 0), !1
        }, Box2D.postDefs.push(function() {
            Box2D.Dynamics.Joints.b2Joint.e_unknownJoint = 0, Box2D.Dynamics.Joints.b2Joint.e_revoluteJoint = 1, Box2D.Dynamics.Joints.b2Joint.e_prismaticJoint = 2, Box2D.Dynamics.Joints.b2Joint.e_distanceJoint = 3, Box2D.Dynamics.Joints.b2Joint.e_pulleyJoint = 4, Box2D.Dynamics.Joints.b2Joint.e_mouseJoint = 5, Box2D.Dynamics.Joints.b2Joint.e_gearJoint = 6, Box2D.Dynamics.Joints.b2Joint.e_lineJoint = 7, Box2D.Dynamics.Joints.b2Joint.e_weldJoint = 8, Box2D.Dynamics.Joints.b2Joint.e_frictionJoint = 9, Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit = 0, Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit = 1, Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit = 2, Box2D.Dynamics.Joints.b2Joint.e_equalLimits = 3
        }), o.b2JointDef = function() {}, o.prototype.b2JointDef = function() {
            this.type = n.e_unknownJoint, this.userData = null, this.bodyA = null, this.bodyB = null, this.collideConnected = !1
        }, p.b2JointEdge = function() {}, Box2D.inherit(q, Box2D.Dynamics.Joints.b2Joint), q.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype, q.b2LineJoint = function() {
            Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_localAnchor1 = new e, this.m_localAnchor2 = new e, this.m_localXAxis1 = new e, this.m_localYAxis1 = new e, this.m_axis = new e, this.m_perp = new e, this.m_K = new b, this.m_impulse = new e
        }, q.prototype.GetAnchorA = function() {
            return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
        }, q.prototype.GetAnchorB = function() {
            return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
        }, q.prototype.GetReactionForce = function(a) {
            return void 0 === a && (a = 0), new e(a * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x), a * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y))
        }, q.prototype.GetReactionTorque = function(a) {
            return void 0 === a && (a = 0), a * this.m_impulse.y
        }, q.prototype.GetJointTranslation = function() {
            var a = this.m_bodyA,
                b = this.m_bodyB,
                c = a.GetWorldPoint(this.m_localAnchor1),
                d = b.GetWorldPoint(this.m_localAnchor2),
                e = d.x - c.x,
                f = d.y - c.y,
                g = a.GetWorldVector(this.m_localXAxis1),
                h = g.x * e + g.y * f;
            return h
        }, q.prototype.GetJointSpeed = function() {
            var a, b = this.m_bodyA,
                c = this.m_bodyB;
            a = b.m_xf.R;
            var d = this.m_localAnchor1.x - b.m_sweep.localCenter.x,
                e = this.m_localAnchor1.y - b.m_sweep.localCenter.y,
                f = a.col1.x * d + a.col2.x * e;
            e = a.col1.y * d + a.col2.y * e, d = f, a = c.m_xf.R;
            var g = this.m_localAnchor2.x - c.m_sweep.localCenter.x,
                h = this.m_localAnchor2.y - c.m_sweep.localCenter.y;
            f = a.col1.x * g + a.col2.x * h, h = a.col1.y * g + a.col2.y * h, g = f;
            var i = b.m_sweep.c.x + d,
                j = b.m_sweep.c.y + e,
                k = c.m_sweep.c.x + g,
                l = c.m_sweep.c.y + h,
                m = k - i,
                n = l - j,
                o = b.GetWorldVector(this.m_localXAxis1),
                p = b.m_linearVelocity,
                q = c.m_linearVelocity,
                r = b.m_angularVelocity,
                s = c.m_angularVelocity,
                t = m * -r * o.y + n * r * o.x + (o.x * (q.x + -s * h - p.x - -r * e) + o.y * (q.y + s * g - p.y - r * d));
            return t
        }, q.prototype.IsLimitEnabled = function() {
            return this.m_enableLimit
        }, q.prototype.EnableLimit = function(a) {
            this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableLimit = a
        }, q.prototype.GetLowerLimit = function() {
            return this.m_lowerTranslation
        }, q.prototype.GetUpperLimit = function() {
            return this.m_upperTranslation
        }, q.prototype.SetLimits = function(a, b) {
            void 0 === a && (a = 0), void 0 === b && (b = 0), this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_lowerTranslation = a, this.m_upperTranslation = b
        }, q.prototype.IsMotorEnabled = function() {
            return this.m_enableMotor
        }, q.prototype.EnableMotor = function(a) {
            this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableMotor = a
        }, q.prototype.SetMotorSpeed = function(a) {
            void 0 === a && (a = 0), this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_motorSpeed = a
        }, q.prototype.GetMotorSpeed = function() {
            return this.m_motorSpeed
        }, q.prototype.SetMaxMotorForce = function(a) {
            void 0 === a && (a = 0), this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_maxMotorForce = a
        }, q.prototype.GetMaxMotorForce = function() {
            return this.m_maxMotorForce
        }, q.prototype.GetMotorForce = function() {
            return this.m_motorImpulse
        }, q.prototype.b2LineJoint = function(a) {
            this.__super.b2Joint.call(this, a);
            this.m_localAnchor1.SetV(a.localAnchorA), this.m_localAnchor2.SetV(a.localAnchorB), this.m_localXAxis1.SetV(a.localAxisA), this.m_localYAxis1.x = -this.m_localXAxis1.y, this.m_localYAxis1.y = this.m_localXAxis1.x, this.m_impulse.SetZero(), this.m_motorMass = 0, this.m_motorImpulse = 0, this.m_lowerTranslation = a.lowerTranslation, this.m_upperTranslation = a.upperTranslation, this.m_maxMotorForce = a.maxMotorForce, this.m_motorSpeed = a.motorSpeed, this.m_enableLimit = a.enableLimit, this.m_enableMotor = a.enableMotor, this.m_limitState = n.e_inactiveLimit, this.m_axis.SetZero(), this.m_perp.SetZero()
        }, q.prototype.InitVelocityConstraints = function(b) {
            var c, e = this.m_bodyA,
                f = this.m_bodyB,
                g = 0;
            this.m_localCenterA.SetV(e.GetLocalCenter()), this.m_localCenterB.SetV(f.GetLocalCenter()); {
                var h = e.GetTransform();
                f.GetTransform()
            }
            c = e.m_xf.R;
            var i = this.m_localAnchor1.x - this.m_localCenterA.x,
                j = this.m_localAnchor1.y - this.m_localCenterA.y;
            g = c.col1.x * i + c.col2.x * j, j = c.col1.y * i + c.col2.y * j, i = g, c = f.m_xf.R;
            var k = this.m_localAnchor2.x - this.m_localCenterB.x,
                l = this.m_localAnchor2.y - this.m_localCenterB.y;
            g = c.col1.x * k + c.col2.x * l, l = c.col1.y * k + c.col2.y * l, k = g;
            var m = f.m_sweep.c.x + k - e.m_sweep.c.x - i,
                o = f.m_sweep.c.y + l - e.m_sweep.c.y - j;
            this.m_invMassA = e.m_invMass, this.m_invMassB = f.m_invMass, this.m_invIA = e.m_invI, this.m_invIB = f.m_invI, this.m_axis.SetV(d.MulMV(h.R, this.m_localXAxis1)), this.m_a1 = (m + i) * this.m_axis.y - (o + j) * this.m_axis.x, this.m_a2 = k * this.m_axis.y - l * this.m_axis.x, this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2, this.m_motorMass = this.m_motorMass > Number.MIN_VALUE ? 1 / this.m_motorMass : 0, this.m_perp.SetV(d.MulMV(h.R, this.m_localYAxis1)), this.m_s1 = (m + i) * this.m_perp.y - (o + j) * this.m_perp.x, this.m_s2 = k * this.m_perp.y - l * this.m_perp.x;
            var p = this.m_invMassA,
                q = this.m_invMassB,
                r = this.m_invIA,
                s = this.m_invIB;
            if (this.m_K.col1.x = p + q + r * this.m_s1 * this.m_s1 + s * this.m_s2 * this.m_s2, this.m_K.col1.y = r * this.m_s1 * this.m_a1 + s * this.m_s2 * this.m_a2, this.m_K.col2.x = this.m_K.col1.y, this.m_K.col2.y = p + q + r * this.m_a1 * this.m_a1 + s * this.m_a2 * this.m_a2, this.m_enableLimit) {
                var t = this.m_axis.x * m + this.m_axis.y * o;
                d.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * a.b2_linearSlop ? this.m_limitState = n.e_equalLimits : t <= this.m_lowerTranslation ? this.m_limitState != n.e_atLowerLimit && (this.m_limitState = n.e_atLowerLimit, this.m_impulse.y = 0) : t >= this.m_upperTranslation ? this.m_limitState != n.e_atUpperLimit && (this.m_limitState = n.e_atUpperLimit, this.m_impulse.y = 0) : (this.m_limitState = n.e_inactiveLimit, this.m_impulse.y = 0)
            } else this.m_limitState = n.e_inactiveLimit; if (0 == this.m_enableMotor && (this.m_motorImpulse = 0), b.warmStarting) {
                this.m_impulse.x *= b.dtRatio, this.m_impulse.y *= b.dtRatio, this.m_motorImpulse *= b.dtRatio;
                var u = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x,
                    v = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y,
                    w = this.m_impulse.x * this.m_s1 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a1,
                    x = this.m_impulse.x * this.m_s2 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a2;
                e.m_linearVelocity.x -= this.m_invMassA * u, e.m_linearVelocity.y -= this.m_invMassA * v, e.m_angularVelocity -= this.m_invIA * w, f.m_linearVelocity.x += this.m_invMassB * u, f.m_linearVelocity.y += this.m_invMassB * v, f.m_angularVelocity += this.m_invIB * x
            } else this.m_impulse.SetZero(), this.m_motorImpulse = 0
        }, q.prototype.SolveVelocityConstraints = function(a) {
            var b = this.m_bodyA,
                c = this.m_bodyB,
                f = b.m_linearVelocity,
                g = b.m_angularVelocity,
                h = c.m_linearVelocity,
                i = c.m_angularVelocity,
                j = 0,
                k = 0,
                l = 0,
                m = 0;
            if (this.m_enableMotor && this.m_limitState != n.e_equalLimits) {
                var o = this.m_axis.x * (h.x - f.x) + this.m_axis.y * (h.y - f.y) + this.m_a2 * i - this.m_a1 * g,
                    p = this.m_motorMass * (this.m_motorSpeed - o),
                    q = this.m_motorImpulse,
                    r = a.dt * this.m_maxMotorForce;
                this.m_motorImpulse = d.Clamp(this.m_motorImpulse + p, -r, r), p = this.m_motorImpulse - q, j = p * this.m_axis.x, k = p * this.m_axis.y, l = p * this.m_a1, m = p * this.m_a2, f.x -= this.m_invMassA * j, f.y -= this.m_invMassA * k, g -= this.m_invIA * l, h.x += this.m_invMassB * j, h.y += this.m_invMassB * k, i += this.m_invIB * m
            }
            var s = this.m_perp.x * (h.x - f.x) + this.m_perp.y * (h.y - f.y) + this.m_s2 * i - this.m_s1 * g;
            if (this.m_enableLimit && this.m_limitState != n.e_inactiveLimit) {
                var t = this.m_axis.x * (h.x - f.x) + this.m_axis.y * (h.y - f.y) + this.m_a2 * i - this.m_a1 * g,
                    u = this.m_impulse.Copy(),
                    v = this.m_K.Solve(new e, -s, -t);
                this.m_impulse.Add(v), this.m_limitState == n.e_atLowerLimit ? this.m_impulse.y = d.Max(this.m_impulse.y, 0) : this.m_limitState == n.e_atUpperLimit && (this.m_impulse.y = d.Min(this.m_impulse.y, 0));
                var w = -s - (this.m_impulse.y - u.y) * this.m_K.col2.x,
                    x = 0;
                x = 0 != this.m_K.col1.x ? w / this.m_K.col1.x + u.x : u.x, this.m_impulse.x = x, v.x = this.m_impulse.x - u.x, v.y = this.m_impulse.y - u.y, j = v.x * this.m_perp.x + v.y * this.m_axis.x, k = v.x * this.m_perp.y + v.y * this.m_axis.y, l = v.x * this.m_s1 + v.y * this.m_a1, m = v.x * this.m_s2 + v.y * this.m_a2, f.x -= this.m_invMassA * j, f.y -= this.m_invMassA * k, g -= this.m_invIA * l, h.x += this.m_invMassB * j, h.y += this.m_invMassB * k, i += this.m_invIB * m
            } else {
                var y = 0;
                y = 0 != this.m_K.col1.x ? -s / this.m_K.col1.x : 0, this.m_impulse.x += y, j = y * this.m_perp.x, k = y * this.m_perp.y, l = y * this.m_s1, m = y * this.m_s2, f.x -= this.m_invMassA * j, f.y -= this.m_invMassA * k, g -= this.m_invIA * l, h.x += this.m_invMassB * j, h.y += this.m_invMassB * k, i += this.m_invIB * m
            }
            b.m_linearVelocity.SetV(f), b.m_angularVelocity = g, c.m_linearVelocity.SetV(h), c.m_angularVelocity = i
        }, q.prototype.SolvePositionConstraints = function(c) {
            void 0 === c && (c = 0);
            var f, g = this.m_bodyA,
                h = this.m_bodyB,
                i = g.m_sweep.c,
                j = g.m_sweep.a,
                k = h.m_sweep.c,
                l = h.m_sweep.a,
                m = 0,
                n = 0,
                o = 0,
                p = 0,
                q = 0,
                r = 0,
                s = 0,
                t = !1,
                u = 0,
                v = b.FromAngle(j),
                w = b.FromAngle(l);
            f = v;
            var x = this.m_localAnchor1.x - this.m_localCenterA.x,
                y = this.m_localAnchor1.y - this.m_localCenterA.y;
            m = f.col1.x * x + f.col2.x * y, y = f.col1.y * x + f.col2.y * y, x = m, f = w;
            var z = this.m_localAnchor2.x - this.m_localCenterB.x,
                A = this.m_localAnchor2.y - this.m_localCenterB.y;
            m = f.col1.x * z + f.col2.x * A, A = f.col1.y * z + f.col2.y * A, z = m;
            var B = k.x + z - i.x - x,
                C = k.y + A - i.y - y;
            if (this.m_enableLimit) {
                this.m_axis = d.MulMV(v, this.m_localXAxis1), this.m_a1 = (B + x) * this.m_axis.y - (C + y) * this.m_axis.x, this.m_a2 = z * this.m_axis.y - A * this.m_axis.x;
                var D = this.m_axis.x * B + this.m_axis.y * C;
                d.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * a.b2_linearSlop ? (u = d.Clamp(D, -a.b2_maxLinearCorrection, a.b2_maxLinearCorrection), r = d.Abs(D), t = !0) : D <= this.m_lowerTranslation ? (u = d.Clamp(D - this.m_lowerTranslation + a.b2_linearSlop, -a.b2_maxLinearCorrection, 0), r = this.m_lowerTranslation - D, t = !0) : D >= this.m_upperTranslation && (u = d.Clamp(D - this.m_upperTranslation + a.b2_linearSlop, 0, a.b2_maxLinearCorrection), r = D - this.m_upperTranslation, t = !0)
            }
            this.m_perp = d.MulMV(v, this.m_localYAxis1), this.m_s1 = (B + x) * this.m_perp.y - (C + y) * this.m_perp.x, this.m_s2 = z * this.m_perp.y - A * this.m_perp.x;
            var E = new e,
                F = this.m_perp.x * B + this.m_perp.y * C;
            if (r = d.Max(r, d.Abs(F)), s = 0, t) n = this.m_invMassA, o = this.m_invMassB, p = this.m_invIA, q = this.m_invIB, this.m_K.col1.x = n + o + p * this.m_s1 * this.m_s1 + q * this.m_s2 * this.m_s2, this.m_K.col1.y = p * this.m_s1 * this.m_a1 + q * this.m_s2 * this.m_a2, this.m_K.col2.x = this.m_K.col1.y, this.m_K.col2.y = n + o + p * this.m_a1 * this.m_a1 + q * this.m_a2 * this.m_a2, this.m_K.Solve(E, -F, -u);
            else {
                n = this.m_invMassA, o = this.m_invMassB, p = this.m_invIA, q = this.m_invIB;
                var G = n + o + p * this.m_s1 * this.m_s1 + q * this.m_s2 * this.m_s2,
                    H = 0;
                H = 0 != G ? -F / G : 0, E.x = H, E.y = 0
            }
            var I = E.x * this.m_perp.x + E.y * this.m_axis.x,
                J = E.x * this.m_perp.y + E.y * this.m_axis.y,
                K = E.x * this.m_s1 + E.y * this.m_a1,
                L = E.x * this.m_s2 + E.y * this.m_a2;
            return i.x -= this.m_invMassA * I, i.y -= this.m_invMassA * J, j -= this.m_invIA * K, k.x += this.m_invMassB * I, k.y += this.m_invMassB * J, l += this.m_invIB * L, g.m_sweep.a = j, h.m_sweep.a = l, g.SynchronizeTransform(), h.SynchronizeTransform(), r <= a.b2_linearSlop && s <= a.b2_angularSlop
        }, Box2D.inherit(r, Box2D.Dynamics.Joints.b2JointDef), r.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype, r.b2LineJointDef = function() {
            Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new e, this.localAnchorB = new e, this.localAxisA = new e
        }, r.prototype.b2LineJointDef = function() {
            this.__super.b2JointDef.call(this), this.type = n.e_lineJoint, this.localAxisA.Set(1, 0), this.enableLimit = !1, this.lowerTranslation = 0, this.upperTranslation = 0, this.enableMotor = !1, this.maxMotorForce = 0, this.motorSpeed = 0
        }, r.prototype.Initialize = function(a, b, c, d) {
            this.bodyA = a, this.bodyB = b, this.localAnchorA = this.bodyA.GetLocalPoint(c), this.localAnchorB = this.bodyB.GetLocalPoint(c), this.localAxisA = this.bodyA.GetLocalVector(d)
        }, Box2D.inherit(s, Box2D.Dynamics.Joints.b2Joint), s.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype, s.b2MouseJoint = function() {
            Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.K = new b, this.K1 = new b, this.K2 = new b, this.m_localAnchor = new e, this.m_target = new e, this.m_impulse = new e, this.m_mass = new b, this.m_C = new e
        }, s.prototype.GetAnchorA = function() {
            return this.m_target
        }, s.prototype.GetAnchorB = function() {
            return this.m_bodyB.GetWorldPoint(this.m_localAnchor)
        }, s.prototype.GetReactionForce = function(a) {
            return void 0 === a && (a = 0), new e(a * this.m_impulse.x, a * this.m_impulse.y)
        }, s.prototype.GetReactionTorque = function(a) {
            return void 0 === a && (a = 0), 0
        }, s.prototype.GetTarget = function() {
            return this.m_target
        }, s.prototype.SetTarget = function(a) {
            0 == this.m_bodyB.IsAwake() && this.m_bodyB.SetAwake(!0), this.m_target = a
        }, s.prototype.GetMaxForce = function() {
            return this.m_maxForce
        }, s.prototype.SetMaxForce = function(a) {
            void 0 === a && (a = 0), this.m_maxForce = a
        }, s.prototype.GetFrequency = function() {
            return this.m_frequencyHz
        }, s.prototype.SetFrequency = function(a) {
            void 0 === a && (a = 0), this.m_frequencyHz = a
        }, s.prototype.GetDampingRatio = function() {
            return this.m_dampingRatio
        }, s.prototype.SetDampingRatio = function(a) {
            void 0 === a && (a = 0), this.m_dampingRatio = a
        }, s.prototype.b2MouseJoint = function(a) {
            this.__super.b2Joint.call(this, a), this.m_target.SetV(a.target);
            var b = this.m_target.x - this.m_bodyB.m_xf.position.x,
                c = this.m_target.y - this.m_bodyB.m_xf.position.y,
                d = this.m_bodyB.m_xf.R;
            this.m_localAnchor.x = b * d.col1.x + c * d.col1.y, this.m_localAnchor.y = b * d.col2.x + c * d.col2.y, this.m_maxForce = a.maxForce, this.m_impulse.SetZero(), this.m_frequencyHz = a.frequencyHz, this.m_dampingRatio = a.dampingRatio, this.m_beta = 0, this.m_gamma = 0
        }, s.prototype.InitVelocityConstraints = function(a) {
            var b = this.m_bodyB,
                c = b.GetMass(),
                d = 2 * Math.PI * this.m_frequencyHz,
                e = 2 * c * this.m_dampingRatio * d,
                f = c * d * d;
            this.m_gamma = a.dt * (e + a.dt * f), this.m_gamma = 0 != this.m_gamma ? 1 / this.m_gamma : 0, this.m_beta = a.dt * f * this.m_gamma;
            var g;
            g = b.m_xf.R;
            var h = this.m_localAnchor.x - b.m_sweep.localCenter.x,
                i = this.m_localAnchor.y - b.m_sweep.localCenter.y,
                j = g.col1.x * h + g.col2.x * i;
            i = g.col1.y * h + g.col2.y * i, h = j;
            var k = b.m_invMass,
                l = b.m_invI;
            this.K1.col1.x = k, this.K1.col2.x = 0, this.K1.col1.y = 0, this.K1.col2.y = k, this.K2.col1.x = l * i * i, this.K2.col2.x = -l * h * i, this.K2.col1.y = -l * h * i, this.K2.col2.y = l * h * h, this.K.SetM(this.K1), this.K.AddM(this.K2), this.K.col1.x += this.m_gamma, this.K.col2.y += this.m_gamma, this.K.GetInverse(this.m_mass), this.m_C.x = b.m_sweep.c.x + h - this.m_target.x, this.m_C.y = b.m_sweep.c.y + i - this.m_target.y, b.m_angularVelocity *= .98, this.m_impulse.x *= a.dtRatio, this.m_impulse.y *= a.dtRatio, b.m_linearVelocity.x += k * this.m_impulse.x, b.m_linearVelocity.y += k * this.m_impulse.y, b.m_angularVelocity += l * (h * this.m_impulse.y - i * this.m_impulse.x)
        }, s.prototype.SolveVelocityConstraints = function(a) {
            var b, c = this.m_bodyB,
                d = 0,
                e = 0;
            b = c.m_xf.R;
            var f = this.m_localAnchor.x - c.m_sweep.localCenter.x,
                g = this.m_localAnchor.y - c.m_sweep.localCenter.y;
            d = b.col1.x * f + b.col2.x * g, g = b.col1.y * f + b.col2.y * g, f = d;
            var h = c.m_linearVelocity.x + -c.m_angularVelocity * g,
                i = c.m_linearVelocity.y + c.m_angularVelocity * f;
            b = this.m_mass, d = h + this.m_beta * this.m_C.x + this.m_gamma * this.m_impulse.x, e = i + this.m_beta * this.m_C.y + this.m_gamma * this.m_impulse.y;
            var j = -(b.col1.x * d + b.col2.x * e),
                k = -(b.col1.y * d + b.col2.y * e),
                l = this.m_impulse.x,
                m = this.m_impulse.y;
            this.m_impulse.x += j, this.m_impulse.y += k;
            var n = a.dt * this.m_maxForce;
            this.m_impulse.LengthSquared() > n * n && this.m_impulse.Multiply(n / this.m_impulse.Length()), j = this.m_impulse.x - l, k = this.m_impulse.y - m, c.m_linearVelocity.x += c.m_invMass * j, c.m_linearVelocity.y += c.m_invMass * k, c.m_angularVelocity += c.m_invI * (f * k - g * j)
        }, s.prototype.SolvePositionConstraints = function(a) {
            return void 0 === a && (a = 0), !0
        }, Box2D.inherit(t, Box2D.Dynamics.Joints.b2JointDef), t.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype, t.b2MouseJointDef = function() {
            Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.target = new e
        }, t.prototype.b2MouseJointDef = function() {
            this.__super.b2JointDef.call(this), this.type = n.e_mouseJoint, this.maxForce = 0, this.frequencyHz = 5, this.dampingRatio = .7
        }, Box2D.inherit(u, Box2D.Dynamics.Joints.b2Joint), u.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype, u.b2PrismaticJoint = function() {
            Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_localAnchor1 = new e, this.m_localAnchor2 = new e, this.m_localXAxis1 = new e, this.m_localYAxis1 = new e, this.m_axis = new e, this.m_perp = new e, this.m_K = new c, this.m_impulse = new f
        }, u.prototype.GetAnchorA = function() {
            return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
        }, u.prototype.GetAnchorB = function() {
            return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
        }, u.prototype.GetReactionForce = function(a) {
            return void 0 === a && (a = 0), new e(a * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x), a * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y))
        }, u.prototype.GetReactionTorque = function(a) {
            return void 0 === a && (a = 0), a * this.m_impulse.y
        }, u.prototype.GetJointTranslation = function() {
            var a = this.m_bodyA,
                b = this.m_bodyB,
                c = a.GetWorldPoint(this.m_localAnchor1),
                d = b.GetWorldPoint(this.m_localAnchor2),
                e = d.x - c.x,
                f = d.y - c.y,
                g = a.GetWorldVector(this.m_localXAxis1),
                h = g.x * e + g.y * f;
            return h
        }, u.prototype.GetJointSpeed = function() {
            var a, b = this.m_bodyA,
                c = this.m_bodyB;
            a = b.m_xf.R;
            var d = this.m_localAnchor1.x - b.m_sweep.localCenter.x,
                e = this.m_localAnchor1.y - b.m_sweep.localCenter.y,
                f = a.col1.x * d + a.col2.x * e;
            e = a.col1.y * d + a.col2.y * e, d = f, a = c.m_xf.R;
            var g = this.m_localAnchor2.x - c.m_sweep.localCenter.x,
                h = this.m_localAnchor2.y - c.m_sweep.localCenter.y;
            f = a.col1.x * g + a.col2.x * h, h = a.col1.y * g + a.col2.y * h, g = f;
            var i = b.m_sweep.c.x + d,
                j = b.m_sweep.c.y + e,
                k = c.m_sweep.c.x + g,
                l = c.m_sweep.c.y + h,
                m = k - i,
                n = l - j,
                o = b.GetWorldVector(this.m_localXAxis1),
                p = b.m_linearVelocity,
                q = c.m_linearVelocity,
                r = b.m_angularVelocity,
                s = c.m_angularVelocity,
                t = m * -r * o.y + n * r * o.x + (o.x * (q.x + -s * h - p.x - -r * e) + o.y * (q.y + s * g - p.y - r * d));
            return t
        }, u.prototype.IsLimitEnabled = function() {
            return this.m_enableLimit
        }, u.prototype.EnableLimit = function(a) {
            this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableLimit = a
        }, u.prototype.GetLowerLimit = function() {
            return this.m_lowerTranslation
        }, u.prototype.GetUpperLimit = function() {
            return this.m_upperTranslation
        }, u.prototype.SetLimits = function(a, b) {
            void 0 === a && (a = 0), void 0 === b && (b = 0), this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_lowerTranslation = a, this.m_upperTranslation = b
        }, u.prototype.IsMotorEnabled = function() {
            return this.m_enableMotor
        }, u.prototype.EnableMotor = function(a) {
            this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableMotor = a
        }, u.prototype.SetMotorSpeed = function(a) {
            void 0 === a && (a = 0), this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_motorSpeed = a
        }, u.prototype.GetMotorSpeed = function() {
            return this.m_motorSpeed
        }, u.prototype.SetMaxMotorForce = function(a) {
            void 0 === a && (a = 0), this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_maxMotorForce = a
        }, u.prototype.GetMotorForce = function() {
            return this.m_motorImpulse
        }, u.prototype.b2PrismaticJoint = function(a) {
            this.__super.b2Joint.call(this, a);
            this.m_localAnchor1.SetV(a.localAnchorA), this.m_localAnchor2.SetV(a.localAnchorB), this.m_localXAxis1.SetV(a.localAxisA), this.m_localYAxis1.x = -this.m_localXAxis1.y, this.m_localYAxis1.y = this.m_localXAxis1.x, this.m_refAngle = a.referenceAngle, this.m_impulse.SetZero(), this.m_motorMass = 0, this.m_motorImpulse = 0, this.m_lowerTranslation = a.lowerTranslation, this.m_upperTranslation = a.upperTranslation, this.m_maxMotorForce = a.maxMotorForce, this.m_motorSpeed = a.motorSpeed, this.m_enableLimit = a.enableLimit, this.m_enableMotor = a.enableMotor, this.m_limitState = n.e_inactiveLimit, this.m_axis.SetZero(), this.m_perp.SetZero()
        }, u.prototype.InitVelocityConstraints = function(b) {
            var c, e = this.m_bodyA,
                f = this.m_bodyB,
                g = 0;
            this.m_localCenterA.SetV(e.GetLocalCenter()), this.m_localCenterB.SetV(f.GetLocalCenter()); {
                var h = e.GetTransform();
                f.GetTransform()
            }
            c = e.m_xf.R;
            var i = this.m_localAnchor1.x - this.m_localCenterA.x,
                j = this.m_localAnchor1.y - this.m_localCenterA.y;
            g = c.col1.x * i + c.col2.x * j, j = c.col1.y * i + c.col2.y * j, i = g, c = f.m_xf.R;
            var k = this.m_localAnchor2.x - this.m_localCenterB.x,
                l = this.m_localAnchor2.y - this.m_localCenterB.y;
            g = c.col1.x * k + c.col2.x * l, l = c.col1.y * k + c.col2.y * l, k = g;
            var m = f.m_sweep.c.x + k - e.m_sweep.c.x - i,
                o = f.m_sweep.c.y + l - e.m_sweep.c.y - j;
            this.m_invMassA = e.m_invMass, this.m_invMassB = f.m_invMass, this.m_invIA = e.m_invI, this.m_invIB = f.m_invI, this.m_axis.SetV(d.MulMV(h.R, this.m_localXAxis1)), this.m_a1 = (m + i) * this.m_axis.y - (o + j) * this.m_axis.x, this.m_a2 = k * this.m_axis.y - l * this.m_axis.x, this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2, this.m_motorMass > Number.MIN_VALUE && (this.m_motorMass = 1 / this.m_motorMass), this.m_perp.SetV(d.MulMV(h.R, this.m_localYAxis1)), this.m_s1 = (m + i) * this.m_perp.y - (o + j) * this.m_perp.x, this.m_s2 = k * this.m_perp.y - l * this.m_perp.x;
            var p = this.m_invMassA,
                q = this.m_invMassB,
                r = this.m_invIA,
                s = this.m_invIB;
            if (this.m_K.col1.x = p + q + r * this.m_s1 * this.m_s1 + s * this.m_s2 * this.m_s2, this.m_K.col1.y = r * this.m_s1 + s * this.m_s2, this.m_K.col1.z = r * this.m_s1 * this.m_a1 + s * this.m_s2 * this.m_a2, this.m_K.col2.x = this.m_K.col1.y, this.m_K.col2.y = r + s, this.m_K.col2.z = r * this.m_a1 + s * this.m_a2, this.m_K.col3.x = this.m_K.col1.z, this.m_K.col3.y = this.m_K.col2.z, this.m_K.col3.z = p + q + r * this.m_a1 * this.m_a1 + s * this.m_a2 * this.m_a2, this.m_enableLimit) {
                var t = this.m_axis.x * m + this.m_axis.y * o;
                d.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * a.b2_linearSlop ? this.m_limitState = n.e_equalLimits : t <= this.m_lowerTranslation ? this.m_limitState != n.e_atLowerLimit && (this.m_limitState = n.e_atLowerLimit, this.m_impulse.z = 0) : t >= this.m_upperTranslation ? this.m_limitState != n.e_atUpperLimit && (this.m_limitState = n.e_atUpperLimit, this.m_impulse.z = 0) : (this.m_limitState = n.e_inactiveLimit, this.m_impulse.z = 0)
            } else this.m_limitState = n.e_inactiveLimit; if (0 == this.m_enableMotor && (this.m_motorImpulse = 0), b.warmStarting) {
                this.m_impulse.x *= b.dtRatio, this.m_impulse.y *= b.dtRatio, this.m_motorImpulse *= b.dtRatio;
                var u = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x,
                    v = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y,
                    w = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1,
                    x = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;
                e.m_linearVelocity.x -= this.m_invMassA * u, e.m_linearVelocity.y -= this.m_invMassA * v, e.m_angularVelocity -= this.m_invIA * w, f.m_linearVelocity.x += this.m_invMassB * u, f.m_linearVelocity.y += this.m_invMassB * v, f.m_angularVelocity += this.m_invIB * x
            } else this.m_impulse.SetZero(), this.m_motorImpulse = 0
        }, u.prototype.SolveVelocityConstraints = function(a) {
            var b = this.m_bodyA,
                c = this.m_bodyB,
                g = b.m_linearVelocity,
                h = b.m_angularVelocity,
                i = c.m_linearVelocity,
                j = c.m_angularVelocity,
                k = 0,
                l = 0,
                m = 0,
                o = 0;
            if (this.m_enableMotor && this.m_limitState != n.e_equalLimits) {
                var p = this.m_axis.x * (i.x - g.x) + this.m_axis.y * (i.y - g.y) + this.m_a2 * j - this.m_a1 * h,
                    q = this.m_motorMass * (this.m_motorSpeed - p),
                    r = this.m_motorImpulse,
                    s = a.dt * this.m_maxMotorForce;
                this.m_motorImpulse = d.Clamp(this.m_motorImpulse + q, -s, s), q = this.m_motorImpulse - r, k = q * this.m_axis.x, l = q * this.m_axis.y, m = q * this.m_a1, o = q * this.m_a2, g.x -= this.m_invMassA * k, g.y -= this.m_invMassA * l, h -= this.m_invIA * m, i.x += this.m_invMassB * k, i.y += this.m_invMassB * l, j += this.m_invIB * o
            }
            var t = this.m_perp.x * (i.x - g.x) + this.m_perp.y * (i.y - g.y) + this.m_s2 * j - this.m_s1 * h,
                u = j - h;
            if (this.m_enableLimit && this.m_limitState != n.e_inactiveLimit) {
                var v = this.m_axis.x * (i.x - g.x) + this.m_axis.y * (i.y - g.y) + this.m_a2 * j - this.m_a1 * h,
                    w = this.m_impulse.Copy(),
                    x = this.m_K.Solve33(new f, -t, -u, -v);
                this.m_impulse.Add(x), this.m_limitState == n.e_atLowerLimit ? this.m_impulse.z = d.Max(this.m_impulse.z, 0) : this.m_limitState == n.e_atUpperLimit && (this.m_impulse.z = d.Min(this.m_impulse.z, 0));
                var y = -t - (this.m_impulse.z - w.z) * this.m_K.col3.x,
                    z = -u - (this.m_impulse.z - w.z) * this.m_K.col3.y,
                    A = this.m_K.Solve22(new e, y, z);
                A.x += w.x, A.y += w.y, this.m_impulse.x = A.x, this.m_impulse.y = A.y, x.x = this.m_impulse.x - w.x, x.y = this.m_impulse.y - w.y, x.z = this.m_impulse.z - w.z, k = x.x * this.m_perp.x + x.z * this.m_axis.x, l = x.x * this.m_perp.y + x.z * this.m_axis.y, m = x.x * this.m_s1 + x.y + x.z * this.m_a1, o = x.x * this.m_s2 + x.y + x.z * this.m_a2, g.x -= this.m_invMassA * k, g.y -= this.m_invMassA * l, h -= this.m_invIA * m, i.x += this.m_invMassB * k, i.y += this.m_invMassB * l, j += this.m_invIB * o
            } else {
                var B = this.m_K.Solve22(new e, -t, -u);
                this.m_impulse.x += B.x, this.m_impulse.y += B.y, k = B.x * this.m_perp.x, l = B.x * this.m_perp.y, m = B.x * this.m_s1 + B.y, o = B.x * this.m_s2 + B.y, g.x -= this.m_invMassA * k, g.y -= this.m_invMassA * l, h -= this.m_invIA * m, i.x += this.m_invMassB * k, i.y += this.m_invMassB * l, j += this.m_invIB * o
            }
            b.m_linearVelocity.SetV(g), b.m_angularVelocity = h, c.m_linearVelocity.SetV(i), c.m_angularVelocity = j
        }, u.prototype.SolvePositionConstraints = function(c) {
            void 0 === c && (c = 0);
            var g, h = this.m_bodyA,
                i = this.m_bodyB,
                j = h.m_sweep.c,
                k = h.m_sweep.a,
                l = i.m_sweep.c,
                m = i.m_sweep.a,
                n = 0,
                o = 0,
                p = 0,
                q = 0,
                r = 0,
                s = 0,
                t = 0,
                u = !1,
                v = 0,
                w = b.FromAngle(k),
                x = b.FromAngle(m);
            g = w;
            var y = this.m_localAnchor1.x - this.m_localCenterA.x,
                z = this.m_localAnchor1.y - this.m_localCenterA.y;
            n = g.col1.x * y + g.col2.x * z, z = g.col1.y * y + g.col2.y * z, y = n, g = x;
            var A = this.m_localAnchor2.x - this.m_localCenterB.x,
                B = this.m_localAnchor2.y - this.m_localCenterB.y;
            n = g.col1.x * A + g.col2.x * B, B = g.col1.y * A + g.col2.y * B, A = n;
            var C = l.x + A - j.x - y,
                D = l.y + B - j.y - z;
            if (this.m_enableLimit) {
                this.m_axis = d.MulMV(w, this.m_localXAxis1), this.m_a1 = (C + y) * this.m_axis.y - (D + z) * this.m_axis.x, this.m_a2 = A * this.m_axis.y - B * this.m_axis.x;
                var E = this.m_axis.x * C + this.m_axis.y * D;
                d.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * a.b2_linearSlop ? (v = d.Clamp(E, -a.b2_maxLinearCorrection, a.b2_maxLinearCorrection), s = d.Abs(E), u = !0) : E <= this.m_lowerTranslation ? (v = d.Clamp(E - this.m_lowerTranslation + a.b2_linearSlop, -a.b2_maxLinearCorrection, 0), s = this.m_lowerTranslation - E, u = !0) : E >= this.m_upperTranslation && (v = d.Clamp(E - this.m_upperTranslation + a.b2_linearSlop, 0, a.b2_maxLinearCorrection), s = E - this.m_upperTranslation, u = !0)
            }
            this.m_perp = d.MulMV(w, this.m_localYAxis1), this.m_s1 = (C + y) * this.m_perp.y - (D + z) * this.m_perp.x, this.m_s2 = A * this.m_perp.y - B * this.m_perp.x;
            var F = new f,
                G = this.m_perp.x * C + this.m_perp.y * D,
                H = m - k - this.m_refAngle;
            if (s = d.Max(s, d.Abs(G)), t = d.Abs(H), u) o = this.m_invMassA, p = this.m_invMassB, q = this.m_invIA, r = this.m_invIB, this.m_K.col1.x = o + p + q * this.m_s1 * this.m_s1 + r * this.m_s2 * this.m_s2, this.m_K.col1.y = q * this.m_s1 + r * this.m_s2, this.m_K.col1.z = q * this.m_s1 * this.m_a1 + r * this.m_s2 * this.m_a2, this.m_K.col2.x = this.m_K.col1.y, this.m_K.col2.y = q + r, this.m_K.col2.z = q * this.m_a1 + r * this.m_a2, this.m_K.col3.x = this.m_K.col1.z, this.m_K.col3.y = this.m_K.col2.z, this.m_K.col3.z = o + p + q * this.m_a1 * this.m_a1 + r * this.m_a2 * this.m_a2, this.m_K.Solve33(F, -G, -H, -v);
            else {
                o = this.m_invMassA, p = this.m_invMassB, q = this.m_invIA, r = this.m_invIB;
                var I = o + p + q * this.m_s1 * this.m_s1 + r * this.m_s2 * this.m_s2,
                    J = q * this.m_s1 + r * this.m_s2,
                    K = q + r;
                this.m_K.col1.Set(I, J, 0), this.m_K.col2.Set(J, K, 0);
                var L = this.m_K.Solve22(new e, -G, -H);
                F.x = L.x, F.y = L.y, F.z = 0
            }
            var M = F.x * this.m_perp.x + F.z * this.m_axis.x,
                N = F.x * this.m_perp.y + F.z * this.m_axis.y,
                O = F.x * this.m_s1 + F.y + F.z * this.m_a1,
                P = F.x * this.m_s2 + F.y + F.z * this.m_a2;
            return j.x -= this.m_invMassA * M, j.y -= this.m_invMassA * N, k -= this.m_invIA * O, l.x += this.m_invMassB * M, l.y += this.m_invMassB * N, m += this.m_invIB * P, h.m_sweep.a = k, i.m_sweep.a = m, h.SynchronizeTransform(), i.SynchronizeTransform(), s <= a.b2_linearSlop && t <= a.b2_angularSlop
        }, Box2D.inherit(v, Box2D.Dynamics.Joints.b2JointDef), v.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype, v.b2PrismaticJointDef = function() {
            Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new e, this.localAnchorB = new e, this.localAxisA = new e
        }, v.prototype.b2PrismaticJointDef = function() {
            this.__super.b2JointDef.call(this), this.type = n.e_prismaticJoint, this.localAxisA.Set(1, 0), this.referenceAngle = 0, this.enableLimit = !1, this.lowerTranslation = 0, this.upperTranslation = 0, this.enableMotor = !1, this.maxMotorForce = 0, this.motorSpeed = 0
        }, v.prototype.Initialize = function(a, b, c, d) {
            this.bodyA = a, this.bodyB = b, this.localAnchorA = this.bodyA.GetLocalPoint(c), this.localAnchorB = this.bodyB.GetLocalPoint(c), this.localAxisA = this.bodyA.GetLocalVector(d), this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()
        }, Box2D.inherit(w, Box2D.Dynamics.Joints.b2Joint), w.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype, w.b2PulleyJoint = function() {
            Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_groundAnchor1 = new e, this.m_groundAnchor2 = new e, this.m_localAnchor1 = new e, this.m_localAnchor2 = new e, this.m_u1 = new e, this.m_u2 = new e
        }, w.prototype.GetAnchorA = function() {
            return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
        }, w.prototype.GetAnchorB = function() {
            return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
        }, w.prototype.GetReactionForce = function(a) {
            return void 0 === a && (a = 0), new e(a * this.m_impulse * this.m_u2.x, a * this.m_impulse * this.m_u2.y)
        }, w.prototype.GetReactionTorque = function(a) {
            return void 0 === a && (a = 0), 0
        }, w.prototype.GetGroundAnchorA = function() {
            var a = this.m_ground.m_xf.position.Copy();
            return a.Add(this.m_groundAnchor1), a
        }, w.prototype.GetGroundAnchorB = function() {
            var a = this.m_ground.m_xf.position.Copy();
            return a.Add(this.m_groundAnchor2), a
        }, w.prototype.GetLength1 = function() {
            var a = this.m_bodyA.GetWorldPoint(this.m_localAnchor1),
                b = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x,
                c = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y,
                d = a.x - b,
                e = a.y - c;
            return Math.sqrt(d * d + e * e)
        }, w.prototype.GetLength2 = function() {
            var a = this.m_bodyB.GetWorldPoint(this.m_localAnchor2),
                b = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x,
                c = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y,
                d = a.x - b,
                e = a.y - c;
            return Math.sqrt(d * d + e * e)
        }, w.prototype.GetRatio = function() {
            return this.m_ratio
        }, w.prototype.b2PulleyJoint = function(a) {
            this.__super.b2Joint.call(this, a);
            this.m_ground = this.m_bodyA.m_world.m_groundBody, this.m_groundAnchor1.x = a.groundAnchorA.x - this.m_ground.m_xf.position.x, this.m_groundAnchor1.y = a.groundAnchorA.y - this.m_ground.m_xf.position.y, this.m_groundAnchor2.x = a.groundAnchorB.x - this.m_ground.m_xf.position.x, this.m_groundAnchor2.y = a.groundAnchorB.y - this.m_ground.m_xf.position.y, this.m_localAnchor1.SetV(a.localAnchorA), this.m_localAnchor2.SetV(a.localAnchorB), this.m_ratio = a.ratio, this.m_constant = a.lengthA + this.m_ratio * a.lengthB, this.m_maxLength1 = d.Min(a.maxLengthA, this.m_constant - this.m_ratio * w.b2_minPulleyLength), this.m_maxLength2 = d.Min(a.maxLengthB, (this.m_constant - w.b2_minPulleyLength) / this.m_ratio), this.m_impulse = 0, this.m_limitImpulse1 = 0, this.m_limitImpulse2 = 0
        }, w.prototype.InitVelocityConstraints = function(b) {
            var c, d = this.m_bodyA,
                e = this.m_bodyB;
            c = d.m_xf.R;
            var f = this.m_localAnchor1.x - d.m_sweep.localCenter.x,
                g = this.m_localAnchor1.y - d.m_sweep.localCenter.y,
                h = c.col1.x * f + c.col2.x * g;
            g = c.col1.y * f + c.col2.y * g, f = h, c = e.m_xf.R;
            var i = this.m_localAnchor2.x - e.m_sweep.localCenter.x,
                j = this.m_localAnchor2.y - e.m_sweep.localCenter.y;
            h = c.col1.x * i + c.col2.x * j, j = c.col1.y * i + c.col2.y * j, i = h;
            var k = d.m_sweep.c.x + f,
                l = d.m_sweep.c.y + g,
                m = e.m_sweep.c.x + i,
                o = e.m_sweep.c.y + j,
                p = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x,
                q = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y,
                r = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x,
                s = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
            this.m_u1.Set(k - p, l - q), this.m_u2.Set(m - r, o - s);
            var t = this.m_u1.Length(),
                u = this.m_u2.Length();
            t > a.b2_linearSlop ? this.m_u1.Multiply(1 / t) : this.m_u1.SetZero(), u > a.b2_linearSlop ? this.m_u2.Multiply(1 / u) : this.m_u2.SetZero();
            var v = this.m_constant - t - this.m_ratio * u;
            v > 0 ? (this.m_state = n.e_inactiveLimit, this.m_impulse = 0) : this.m_state = n.e_atUpperLimit, t < this.m_maxLength1 ? (this.m_limitState1 = n.e_inactiveLimit, this.m_limitImpulse1 = 0) : this.m_limitState1 = n.e_atUpperLimit, u < this.m_maxLength2 ? (this.m_limitState2 = n.e_inactiveLimit, this.m_limitImpulse2 = 0) : this.m_limitState2 = n.e_atUpperLimit;
            var w = f * this.m_u1.y - g * this.m_u1.x,
                x = i * this.m_u2.y - j * this.m_u2.x;
            if (this.m_limitMass1 = d.m_invMass + d.m_invI * w * w, this.m_limitMass2 = e.m_invMass + e.m_invI * x * x, this.m_pulleyMass = this.m_limitMass1 + this.m_ratio * this.m_ratio * this.m_limitMass2, this.m_limitMass1 = 1 / this.m_limitMass1, this.m_limitMass2 = 1 / this.m_limitMass2, this.m_pulleyMass = 1 / this.m_pulleyMass, b.warmStarting) {
                this.m_impulse *= b.dtRatio, this.m_limitImpulse1 *= b.dtRatio, this.m_limitImpulse2 *= b.dtRatio;
                var y = (-this.m_impulse - this.m_limitImpulse1) * this.m_u1.x,
                    z = (-this.m_impulse - this.m_limitImpulse1) * this.m_u1.y,
                    A = (-this.m_ratio * this.m_impulse - this.m_limitImpulse2) * this.m_u2.x,
                    B = (-this.m_ratio * this.m_impulse - this.m_limitImpulse2) * this.m_u2.y;
                d.m_linearVelocity.x += d.m_invMass * y, d.m_linearVelocity.y += d.m_invMass * z, d.m_angularVelocity += d.m_invI * (f * z - g * y), e.m_linearVelocity.x += e.m_invMass * A, e.m_linearVelocity.y += e.m_invMass * B, e.m_angularVelocity += e.m_invI * (i * B - j * A)
            } else this.m_impulse = 0, this.m_limitImpulse1 = 0, this.m_limitImpulse2 = 0
        }, w.prototype.SolveVelocityConstraints = function() {
            var a, b = this.m_bodyA,
                c = this.m_bodyB;
            a = b.m_xf.R;
            var e = this.m_localAnchor1.x - b.m_sweep.localCenter.x,
                f = this.m_localAnchor1.y - b.m_sweep.localCenter.y,
                g = a.col1.x * e + a.col2.x * f;
            f = a.col1.y * e + a.col2.y * f, e = g, a = c.m_xf.R;
            var h = this.m_localAnchor2.x - c.m_sweep.localCenter.x,
                i = this.m_localAnchor2.y - c.m_sweep.localCenter.y;
            g = a.col1.x * h + a.col2.x * i, i = a.col1.y * h + a.col2.y * i, h = g;
            var j = 0,
                k = 0,
                l = 0,
                m = 0,
                o = 0,
                p = 0,
                q = 0,
                r = 0,
                s = 0,
                t = 0,
                u = 0;
            this.m_state == n.e_atUpperLimit && (j = b.m_linearVelocity.x + -b.m_angularVelocity * f, k = b.m_linearVelocity.y + b.m_angularVelocity * e, l = c.m_linearVelocity.x + -c.m_angularVelocity * i, m = c.m_linearVelocity.y + c.m_angularVelocity * h, s = -(this.m_u1.x * j + this.m_u1.y * k) - this.m_ratio * (this.m_u2.x * l + this.m_u2.y * m), t = this.m_pulleyMass * -s, u = this.m_impulse, this.m_impulse = d.Max(0, this.m_impulse + t), t = this.m_impulse - u, o = -t * this.m_u1.x, p = -t * this.m_u1.y, q = -this.m_ratio * t * this.m_u2.x, r = -this.m_ratio * t * this.m_u2.y, b.m_linearVelocity.x += b.m_invMass * o, b.m_linearVelocity.y += b.m_invMass * p, b.m_angularVelocity += b.m_invI * (e * p - f * o), c.m_linearVelocity.x += c.m_invMass * q, c.m_linearVelocity.y += c.m_invMass * r, c.m_angularVelocity += c.m_invI * (h * r - i * q)), this.m_limitState1 == n.e_atUpperLimit && (j = b.m_linearVelocity.x + -b.m_angularVelocity * f, k = b.m_linearVelocity.y + b.m_angularVelocity * e, s = -(this.m_u1.x * j + this.m_u1.y * k), t = -this.m_limitMass1 * s, u = this.m_limitImpulse1, this.m_limitImpulse1 = d.Max(0, this.m_limitImpulse1 + t), t = this.m_limitImpulse1 - u, o = -t * this.m_u1.x, p = -t * this.m_u1.y, b.m_linearVelocity.x += b.m_invMass * o, b.m_linearVelocity.y += b.m_invMass * p, b.m_angularVelocity += b.m_invI * (e * p - f * o)), this.m_limitState2 == n.e_atUpperLimit && (l = c.m_linearVelocity.x + -c.m_angularVelocity * i, m = c.m_linearVelocity.y + c.m_angularVelocity * h, s = -(this.m_u2.x * l + this.m_u2.y * m), t = -this.m_limitMass2 * s, u = this.m_limitImpulse2, this.m_limitImpulse2 = d.Max(0, this.m_limitImpulse2 + t), t = this.m_limitImpulse2 - u, q = -t * this.m_u2.x, r = -t * this.m_u2.y, c.m_linearVelocity.x += c.m_invMass * q, c.m_linearVelocity.y += c.m_invMass * r, c.m_angularVelocity += c.m_invI * (h * r - i * q))
        }, w.prototype.SolvePositionConstraints = function(b) {
            void 0 === b && (b = 0);
            var c, e = this.m_bodyA,
                f = this.m_bodyB,
                g = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x,
                h = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y,
                i = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x,
                j = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y,
                k = 0,
                l = 0,
                m = 0,
                o = 0,
                p = 0,
                q = 0,
                r = 0,
                s = 0,
                t = 0,
                u = 0,
                v = 0,
                w = 0,
                x = 0,
                y = 0;
            return this.m_state == n.e_atUpperLimit && (c = e.m_xf.R, k = this.m_localAnchor1.x - e.m_sweep.localCenter.x, l = this.m_localAnchor1.y - e.m_sweep.localCenter.y, x = c.col1.x * k + c.col2.x * l, l = c.col1.y * k + c.col2.y * l, k = x, c = f.m_xf.R, m = this.m_localAnchor2.x - f.m_sweep.localCenter.x, o = this.m_localAnchor2.y - f.m_sweep.localCenter.y, x = c.col1.x * m + c.col2.x * o, o = c.col1.y * m + c.col2.y * o, m = x, p = e.m_sweep.c.x + k, q = e.m_sweep.c.y + l, r = f.m_sweep.c.x + m, s = f.m_sweep.c.y + o, this.m_u1.Set(p - g, q - h), this.m_u2.Set(r - i, s - j), t = this.m_u1.Length(), u = this.m_u2.Length(), t > a.b2_linearSlop ? this.m_u1.Multiply(1 / t) : this.m_u1.SetZero(), u > a.b2_linearSlop ? this.m_u2.Multiply(1 / u) : this.m_u2.SetZero(), v = this.m_constant - t - this.m_ratio * u, y = d.Max(y, -v), v = d.Clamp(v + a.b2_linearSlop, -a.b2_maxLinearCorrection, 0), w = -this.m_pulleyMass * v, p = -w * this.m_u1.x, q = -w * this.m_u1.y, r = -this.m_ratio * w * this.m_u2.x, s = -this.m_ratio * w * this.m_u2.y, e.m_sweep.c.x += e.m_invMass * p, e.m_sweep.c.y += e.m_invMass * q, e.m_sweep.a += e.m_invI * (k * q - l * p), f.m_sweep.c.x += f.m_invMass * r, f.m_sweep.c.y += f.m_invMass * s, f.m_sweep.a += f.m_invI * (m * s - o * r), e.SynchronizeTransform(), f.SynchronizeTransform()), this.m_limitState1 == n.e_atUpperLimit && (c = e.m_xf.R, k = this.m_localAnchor1.x - e.m_sweep.localCenter.x, l = this.m_localAnchor1.y - e.m_sweep.localCenter.y, x = c.col1.x * k + c.col2.x * l, l = c.col1.y * k + c.col2.y * l, k = x, p = e.m_sweep.c.x + k, q = e.m_sweep.c.y + l, this.m_u1.Set(p - g, q - h), t = this.m_u1.Length(), t > a.b2_linearSlop ? (this.m_u1.x *= 1 / t, this.m_u1.y *= 1 / t) : this.m_u1.SetZero(), v = this.m_maxLength1 - t, y = d.Max(y, -v), v = d.Clamp(v + a.b2_linearSlop, -a.b2_maxLinearCorrection, 0), w = -this.m_limitMass1 * v, p = -w * this.m_u1.x, q = -w * this.m_u1.y, e.m_sweep.c.x += e.m_invMass * p, e.m_sweep.c.y += e.m_invMass * q, e.m_sweep.a += e.m_invI * (k * q - l * p), e.SynchronizeTransform()), this.m_limitState2 == n.e_atUpperLimit && (c = f.m_xf.R, m = this.m_localAnchor2.x - f.m_sweep.localCenter.x, o = this.m_localAnchor2.y - f.m_sweep.localCenter.y, x = c.col1.x * m + c.col2.x * o, o = c.col1.y * m + c.col2.y * o, m = x, r = f.m_sweep.c.x + m, s = f.m_sweep.c.y + o, this.m_u2.Set(r - i, s - j), u = this.m_u2.Length(), u > a.b2_linearSlop ? (this.m_u2.x *= 1 / u, this.m_u2.y *= 1 / u) : this.m_u2.SetZero(), v = this.m_maxLength2 - u, y = d.Max(y, -v), v = d.Clamp(v + a.b2_linearSlop, -a.b2_maxLinearCorrection, 0), w = -this.m_limitMass2 * v, r = -w * this.m_u2.x, s = -w * this.m_u2.y, f.m_sweep.c.x += f.m_invMass * r, f.m_sweep.c.y += f.m_invMass * s, f.m_sweep.a += f.m_invI * (m * s - o * r), f.SynchronizeTransform()), y < a.b2_linearSlop
        }, Box2D.postDefs.push(function() {
            Box2D.Dynamics.Joints.b2PulleyJoint.b2_minPulleyLength = 2
        }), Box2D.inherit(x, Box2D.Dynamics.Joints.b2JointDef), x.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype, x.b2PulleyJointDef = function() {
            Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.groundAnchorA = new e, this.groundAnchorB = new e, this.localAnchorA = new e, this.localAnchorB = new e
        }, x.prototype.b2PulleyJointDef = function() {
            this.__super.b2JointDef.call(this), this.type = n.e_pulleyJoint, this.groundAnchorA.Set(-1, 1), this.groundAnchorB.Set(1, 1), this.localAnchorA.Set(-1, 0), this.localAnchorB.Set(1, 0), this.lengthA = 0, this.maxLengthA = 0, this.lengthB = 0, this.maxLengthB = 0, this.ratio = 1, this.collideConnected = !0
        }, x.prototype.Initialize = function(a, b, c, d, e, f, g) {
            void 0 === g && (g = 0), this.bodyA = a, this.bodyB = b, this.groundAnchorA.SetV(c), this.groundAnchorB.SetV(d), this.localAnchorA = this.bodyA.GetLocalPoint(e), this.localAnchorB = this.bodyB.GetLocalPoint(f);
            var h = e.x - c.x,
                i = e.y - c.y;
            this.lengthA = Math.sqrt(h * h + i * i);
            var j = f.x - d.x,
                k = f.y - d.y;
            this.lengthB = Math.sqrt(j * j + k * k), this.ratio = g;
            var l = this.lengthA + this.ratio * this.lengthB;
            this.maxLengthA = l - this.ratio * w.b2_minPulleyLength, this.maxLengthB = (l - w.b2_minPulleyLength) / this.ratio
        }, Box2D.inherit(y, Box2D.Dynamics.Joints.b2Joint), y.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype, y.b2RevoluteJoint = function() {
            Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.K = new b, this.K1 = new b, this.K2 = new b, this.K3 = new b, this.impulse3 = new f, this.impulse2 = new e, this.reduced = new e, this.m_localAnchor1 = new e, this.m_localAnchor2 = new e, this.m_impulse = new f, this.m_mass = new c
        }, y.prototype.GetAnchorA = function() {
            return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
        }, y.prototype.GetAnchorB = function() {
            return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
        }, y.prototype.GetReactionForce = function(a) {
            return void 0 === a && (a = 0), new e(a * this.m_impulse.x, a * this.m_impulse.y)
        }, y.prototype.GetReactionTorque = function(a) {
            return void 0 === a && (a = 0), a * this.m_impulse.z
        }, y.prototype.GetJointAngle = function() {
            return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle
        }, y.prototype.GetJointSpeed = function() {
            return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity
        }, y.prototype.IsLimitEnabled = function() {
            return this.m_enableLimit
        }, y.prototype.EnableLimit = function(a) {
            this.m_enableLimit = a
        }, y.prototype.GetLowerLimit = function() {
            return this.m_lowerAngle
        }, y.prototype.GetUpperLimit = function() {
            return this.m_upperAngle
        }, y.prototype.SetLimits = function(a, b) {
            void 0 === a && (a = 0), void 0 === b && (b = 0), this.m_lowerAngle = a, this.m_upperAngle = b
        }, y.prototype.IsMotorEnabled = function() {
            return this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableMotor
        }, y.prototype.EnableMotor = function(a) {
            this.m_enableMotor = a
        }, y.prototype.SetMotorSpeed = function(a) {
            void 0 === a && (a = 0), this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_motorSpeed = a
        }, y.prototype.GetMotorSpeed = function() {
            return this.m_motorSpeed
        }, y.prototype.SetMaxMotorTorque = function(a) {
            void 0 === a && (a = 0), this.m_maxMotorTorque = a
        }, y.prototype.GetMotorTorque = function() {
            return this.m_maxMotorTorque
        }, y.prototype.b2RevoluteJoint = function(a) {
            this.__super.b2Joint.call(this, a), this.m_localAnchor1.SetV(a.localAnchorA), this.m_localAnchor2.SetV(a.localAnchorB), this.m_referenceAngle = a.referenceAngle, this.m_impulse.SetZero(), this.m_motorImpulse = 0, this.m_lowerAngle = a.lowerAngle, this.m_upperAngle = a.upperAngle, this.m_maxMotorTorque = a.maxMotorTorque, this.m_motorSpeed = a.motorSpeed, this.m_enableLimit = a.enableLimit, this.m_enableMotor = a.enableMotor, this.m_limitState = n.e_inactiveLimit
        }, y.prototype.InitVelocityConstraints = function(b) {
            var c, e = this.m_bodyA,
                f = this.m_bodyB,
                g = 0;
            this.m_enableMotor || this.m_enableLimit, c = e.m_xf.R;
            var h = this.m_localAnchor1.x - e.m_sweep.localCenter.x,
                i = this.m_localAnchor1.y - e.m_sweep.localCenter.y;
            g = c.col1.x * h + c.col2.x * i, i = c.col1.y * h + c.col2.y * i, h = g, c = f.m_xf.R;
            var j = this.m_localAnchor2.x - f.m_sweep.localCenter.x,
                k = this.m_localAnchor2.y - f.m_sweep.localCenter.y;
            g = c.col1.x * j + c.col2.x * k, k = c.col1.y * j + c.col2.y * k, j = g;
            var l = e.m_invMass,
                m = f.m_invMass,
                o = e.m_invI,
                p = f.m_invI;
            if (this.m_mass.col1.x = l + m + i * i * o + k * k * p, this.m_mass.col2.x = -i * h * o - k * j * p, this.m_mass.col3.x = -i * o - k * p, this.m_mass.col1.y = this.m_mass.col2.x, this.m_mass.col2.y = l + m + h * h * o + j * j * p, this.m_mass.col3.y = h * o + j * p, this.m_mass.col1.z = this.m_mass.col3.x, this.m_mass.col2.z = this.m_mass.col3.y, this.m_mass.col3.z = o + p, this.m_motorMass = 1 / (o + p), 0 == this.m_enableMotor && (this.m_motorImpulse = 0), this.m_enableLimit) {
                var q = f.m_sweep.a - e.m_sweep.a - this.m_referenceAngle;
                d.Abs(this.m_upperAngle - this.m_lowerAngle) < 2 * a.b2_angularSlop ? this.m_limitState = n.e_equalLimits : q <= this.m_lowerAngle ? (this.m_limitState != n.e_atLowerLimit && (this.m_impulse.z = 0), this.m_limitState = n.e_atLowerLimit) : q >= this.m_upperAngle ? (this.m_limitState != n.e_atUpperLimit && (this.m_impulse.z = 0), this.m_limitState = n.e_atUpperLimit) : (this.m_limitState = n.e_inactiveLimit, this.m_impulse.z = 0)
            } else this.m_limitState = n.e_inactiveLimit; if (b.warmStarting) {
                this.m_impulse.x *= b.dtRatio, this.m_impulse.y *= b.dtRatio, this.m_motorImpulse *= b.dtRatio;
                var r = this.m_impulse.x,
                    s = this.m_impulse.y;
                e.m_linearVelocity.x -= l * r, e.m_linearVelocity.y -= l * s, e.m_angularVelocity -= o * (h * s - i * r + this.m_motorImpulse + this.m_impulse.z), f.m_linearVelocity.x += m * r, f.m_linearVelocity.y += m * s, f.m_angularVelocity += p * (j * s - k * r + this.m_motorImpulse + this.m_impulse.z)
            } else this.m_impulse.SetZero(), this.m_motorImpulse = 0
        }, y.prototype.SolveVelocityConstraints = function(a) {
            var b, c = this.m_bodyA,
                e = this.m_bodyB,
                f = 0,
                g = 0,
                h = 0,
                i = 0,
                j = 0,
                k = 0,
                l = c.m_linearVelocity,
                m = c.m_angularVelocity,
                o = e.m_linearVelocity,
                p = e.m_angularVelocity,
                q = c.m_invMass,
                r = e.m_invMass,
                s = c.m_invI,
                t = e.m_invI;
            if (this.m_enableMotor && this.m_limitState != n.e_equalLimits) {
                var u = p - m - this.m_motorSpeed,
                    v = this.m_motorMass * -u,
                    w = this.m_motorImpulse,
                    x = a.dt * this.m_maxMotorTorque;
                this.m_motorImpulse = d.Clamp(this.m_motorImpulse + v, -x, x), v = this.m_motorImpulse - w, m -= s * v, p += t * v
            }
            if (this.m_enableLimit && this.m_limitState != n.e_inactiveLimit) {
                b = c.m_xf.R, h = this.m_localAnchor1.x - c.m_sweep.localCenter.x, i = this.m_localAnchor1.y - c.m_sweep.localCenter.y, f = b.col1.x * h + b.col2.x * i, i = b.col1.y * h + b.col2.y * i, h = f, b = e.m_xf.R, j = this.m_localAnchor2.x - e.m_sweep.localCenter.x, k = this.m_localAnchor2.y - e.m_sweep.localCenter.y, f = b.col1.x * j + b.col2.x * k, k = b.col1.y * j + b.col2.y * k, j = f;
                var y = o.x + -p * k - l.x - -m * i,
                    z = o.y + p * j - l.y - m * h,
                    A = p - m;
                this.m_mass.Solve33(this.impulse3, -y, -z, -A), this.m_limitState == n.e_equalLimits ? this.m_impulse.Add(this.impulse3) : this.m_limitState == n.e_atLowerLimit ? (g = this.m_impulse.z + this.impulse3.z, 0 > g && (this.m_mass.Solve22(this.reduced, -y, -z), this.impulse3.x = this.reduced.x, this.impulse3.y = this.reduced.y, this.impulse3.z = -this.m_impulse.z, this.m_impulse.x += this.reduced.x, this.m_impulse.y += this.reduced.y, this.m_impulse.z = 0)) : this.m_limitState == n.e_atUpperLimit && (g = this.m_impulse.z + this.impulse3.z, g > 0 && (this.m_mass.Solve22(this.reduced, -y, -z), this.impulse3.x = this.reduced.x, this.impulse3.y = this.reduced.y, this.impulse3.z = -this.m_impulse.z, this.m_impulse.x += this.reduced.x, this.m_impulse.y += this.reduced.y, this.m_impulse.z = 0)), l.x -= q * this.impulse3.x, l.y -= q * this.impulse3.y, m -= s * (h * this.impulse3.y - i * this.impulse3.x + this.impulse3.z), o.x += r * this.impulse3.x, o.y += r * this.impulse3.y, p += t * (j * this.impulse3.y - k * this.impulse3.x + this.impulse3.z)
            } else {
                b = c.m_xf.R, h = this.m_localAnchor1.x - c.m_sweep.localCenter.x, i = this.m_localAnchor1.y - c.m_sweep.localCenter.y, f = b.col1.x * h + b.col2.x * i, i = b.col1.y * h + b.col2.y * i, h = f, b = e.m_xf.R, j = this.m_localAnchor2.x - e.m_sweep.localCenter.x, k = this.m_localAnchor2.y - e.m_sweep.localCenter.y, f = b.col1.x * j + b.col2.x * k, k = b.col1.y * j + b.col2.y * k, j = f;
                var B = o.x + -p * k - l.x - -m * i,
                    C = o.y + p * j - l.y - m * h;
                this.m_mass.Solve22(this.impulse2, -B, -C), this.m_impulse.x += this.impulse2.x, this.m_impulse.y += this.impulse2.y, l.x -= q * this.impulse2.x, l.y -= q * this.impulse2.y, m -= s * (h * this.impulse2.y - i * this.impulse2.x), o.x += r * this.impulse2.x, o.y += r * this.impulse2.y, p += t * (j * this.impulse2.y - k * this.impulse2.x)
            }
            c.m_linearVelocity.SetV(l), c.m_angularVelocity = m, e.m_linearVelocity.SetV(o), e.m_angularVelocity = p
        }, y.prototype.SolvePositionConstraints = function(b) {
            void 0 === b && (b = 0);
            var c, e = 0,
                f = this.m_bodyA,
                g = this.m_bodyB,
                h = 0,
                i = 0,
                j = 0,
                k = 0,
                l = 0;
            if (this.m_enableLimit && this.m_limitState != n.e_inactiveLimit) {
                var m = g.m_sweep.a - f.m_sweep.a - this.m_referenceAngle,
                    o = 0;
                this.m_limitState == n.e_equalLimits ? (e = d.Clamp(m - this.m_lowerAngle, -a.b2_maxAngularCorrection, a.b2_maxAngularCorrection), o = -this.m_motorMass * e, h = d.Abs(e)) : this.m_limitState == n.e_atLowerLimit ? (e = m - this.m_lowerAngle, h = -e, e = d.Clamp(e + a.b2_angularSlop, -a.b2_maxAngularCorrection, 0), o = -this.m_motorMass * e) : this.m_limitState == n.e_atUpperLimit && (e = m - this.m_upperAngle, h = e, e = d.Clamp(e - a.b2_angularSlop, 0, a.b2_maxAngularCorrection), o = -this.m_motorMass * e), f.m_sweep.a -= f.m_invI * o, g.m_sweep.a += g.m_invI * o, f.SynchronizeTransform(), g.SynchronizeTransform()
            }
            c = f.m_xf.R;
            var p = this.m_localAnchor1.x - f.m_sweep.localCenter.x,
                q = this.m_localAnchor1.y - f.m_sweep.localCenter.y;
            j = c.col1.x * p + c.col2.x * q, q = c.col1.y * p + c.col2.y * q, p = j, c = g.m_xf.R;
            var r = this.m_localAnchor2.x - g.m_sweep.localCenter.x,
                s = this.m_localAnchor2.y - g.m_sweep.localCenter.y;
            j = c.col1.x * r + c.col2.x * s, s = c.col1.y * r + c.col2.y * s, r = j;
            var t = g.m_sweep.c.x + r - f.m_sweep.c.x - p,
                u = g.m_sweep.c.y + s - f.m_sweep.c.y - q,
                v = t * t + u * u,
                w = Math.sqrt(v);
            i = w;
            var x = f.m_invMass,
                z = g.m_invMass,
                A = f.m_invI,
                B = g.m_invI,
                C = 10 * a.b2_linearSlop;
            if (v > C * C) {
                var D = x + z,
                    E = 1 / D;
                k = E * -t, l = E * -u;
                var F = .5;
                f.m_sweep.c.x -= F * x * k, f.m_sweep.c.y -= F * x * l, g.m_sweep.c.x += F * z * k, g.m_sweep.c.y += F * z * l, t = g.m_sweep.c.x + r - f.m_sweep.c.x - p, u = g.m_sweep.c.y + s - f.m_sweep.c.y - q
            }
            return this.K1.col1.x = x + z, this.K1.col2.x = 0, this.K1.col1.y = 0, this.K1.col2.y = x + z, this.K2.col1.x = A * q * q, this.K2.col2.x = -A * p * q, this.K2.col1.y = -A * p * q, this.K2.col2.y = A * p * p, this.K3.col1.x = B * s * s, this.K3.col2.x = -B * r * s, this.K3.col1.y = -B * r * s, this.K3.col2.y = B * r * r, this.K.SetM(this.K1), this.K.AddM(this.K2), this.K.AddM(this.K3), this.K.Solve(y.tImpulse, -t, -u), k = y.tImpulse.x, l = y.tImpulse.y, f.m_sweep.c.x -= f.m_invMass * k, f.m_sweep.c.y -= f.m_invMass * l, f.m_sweep.a -= f.m_invI * (p * l - q * k), g.m_sweep.c.x += g.m_invMass * k, g.m_sweep.c.y += g.m_invMass * l, g.m_sweep.a += g.m_invI * (r * l - s * k), f.SynchronizeTransform(), g.SynchronizeTransform(), i <= a.b2_linearSlop && h <= a.b2_angularSlop
        }, Box2D.postDefs.push(function() {
            Box2D.Dynamics.Joints.b2RevoluteJoint.tImpulse = new e
        }), Box2D.inherit(z, Box2D.Dynamics.Joints.b2JointDef), z.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype, z.b2RevoluteJointDef = function() {
            Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new e, this.localAnchorB = new e
        }, z.prototype.b2RevoluteJointDef = function() {
            this.__super.b2JointDef.call(this), this.type = n.e_revoluteJoint, this.localAnchorA.Set(0, 0), this.localAnchorB.Set(0, 0), this.referenceAngle = 0, this.lowerAngle = 0, this.upperAngle = 0, this.maxMotorTorque = 0, this.motorSpeed = 0, this.enableLimit = !1, this.enableMotor = !1
        }, z.prototype.Initialize = function(a, b, c) {
            this.bodyA = a, this.bodyB = b, this.localAnchorA = this.bodyA.GetLocalPoint(c), this.localAnchorB = this.bodyB.GetLocalPoint(c), this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()
        }, Box2D.inherit(A, Box2D.Dynamics.Joints.b2Joint), A.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype, A.b2WeldJoint = function() {
            Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_localAnchorA = new e, this.m_localAnchorB = new e, this.m_impulse = new f, this.m_mass = new c
        }, A.prototype.GetAnchorA = function() {
            return this.m_bodyA.GetWorldPoint(this.m_localAnchorA)
        }, A.prototype.GetAnchorB = function() {
            return this.m_bodyB.GetWorldPoint(this.m_localAnchorB)
        }, A.prototype.GetReactionForce = function(a) {
            return void 0 === a && (a = 0), new e(a * this.m_impulse.x, a * this.m_impulse.y)
        }, A.prototype.GetReactionTorque = function(a) {
            return void 0 === a && (a = 0), a * this.m_impulse.z
        }, A.prototype.b2WeldJoint = function(a) {
            this.__super.b2Joint.call(this, a), this.m_localAnchorA.SetV(a.localAnchorA), this.m_localAnchorB.SetV(a.localAnchorB), this.m_referenceAngle = a.referenceAngle, this.m_impulse.SetZero(), this.m_mass = new c
        }, A.prototype.InitVelocityConstraints = function(a) {
            var b, c = 0,
                d = this.m_bodyA,
                e = this.m_bodyB;
            b = d.m_xf.R;
            var f = this.m_localAnchorA.x - d.m_sweep.localCenter.x,
                g = this.m_localAnchorA.y - d.m_sweep.localCenter.y;
            c = b.col1.x * f + b.col2.x * g, g = b.col1.y * f + b.col2.y * g, f = c, b = e.m_xf.R;
            var h = this.m_localAnchorB.x - e.m_sweep.localCenter.x,
                i = this.m_localAnchorB.y - e.m_sweep.localCenter.y;
            c = b.col1.x * h + b.col2.x * i, i = b.col1.y * h + b.col2.y * i, h = c;
            var j = d.m_invMass,
                k = e.m_invMass,
                l = d.m_invI,
                m = e.m_invI;
            this.m_mass.col1.x = j + k + g * g * l + i * i * m, this.m_mass.col2.x = -g * f * l - i * h * m, this.m_mass.col3.x = -g * l - i * m, this.m_mass.col1.y = this.m_mass.col2.x, this.m_mass.col2.y = j + k + f * f * l + h * h * m, this.m_mass.col3.y = f * l + h * m, this.m_mass.col1.z = this.m_mass.col3.x, this.m_mass.col2.z = this.m_mass.col3.y, this.m_mass.col3.z = l + m, a.warmStarting ? (this.m_impulse.x *= a.dtRatio, this.m_impulse.y *= a.dtRatio, this.m_impulse.z *= a.dtRatio, d.m_linearVelocity.x -= j * this.m_impulse.x, d.m_linearVelocity.y -= j * this.m_impulse.y, d.m_angularVelocity -= l * (f * this.m_impulse.y - g * this.m_impulse.x + this.m_impulse.z), e.m_linearVelocity.x += k * this.m_impulse.x, e.m_linearVelocity.y += k * this.m_impulse.y, e.m_angularVelocity += m * (h * this.m_impulse.y - i * this.m_impulse.x + this.m_impulse.z)) : this.m_impulse.SetZero()
        }, A.prototype.SolveVelocityConstraints = function() {
            var a, b = 0,
                c = this.m_bodyA,
                d = this.m_bodyB,
                e = c.m_linearVelocity,
                g = c.m_angularVelocity,
                h = d.m_linearVelocity,
                i = d.m_angularVelocity,
                j = c.m_invMass,
                k = d.m_invMass,
                l = c.m_invI,
                m = d.m_invI;
            a = c.m_xf.R;
            var n = this.m_localAnchorA.x - c.m_sweep.localCenter.x,
                o = this.m_localAnchorA.y - c.m_sweep.localCenter.y;
            b = a.col1.x * n + a.col2.x * o, o = a.col1.y * n + a.col2.y * o, n = b, a = d.m_xf.R;
            var p = this.m_localAnchorB.x - d.m_sweep.localCenter.x,
                q = this.m_localAnchorB.y - d.m_sweep.localCenter.y;
            b = a.col1.x * p + a.col2.x * q, q = a.col1.y * p + a.col2.y * q, p = b;
            var r = h.x - i * q - e.x + g * o,
                s = h.y + i * p - e.y - g * n,
                t = i - g,
                u = new f;
            this.m_mass.Solve33(u, -r, -s, -t), this.m_impulse.Add(u), e.x -= j * u.x, e.y -= j * u.y, g -= l * (n * u.y - o * u.x + u.z), h.x += k * u.x, h.y += k * u.y, i += m * (p * u.y - q * u.x + u.z), c.m_angularVelocity = g, d.m_angularVelocity = i
        }, A.prototype.SolvePositionConstraints = function(b) {
            void 0 === b && (b = 0);
            var c, e = 0,
                g = this.m_bodyA,
                h = this.m_bodyB;
            c = g.m_xf.R;
            var i = this.m_localAnchorA.x - g.m_sweep.localCenter.x,
                j = this.m_localAnchorA.y - g.m_sweep.localCenter.y;
            e = c.col1.x * i + c.col2.x * j, j = c.col1.y * i + c.col2.y * j, i = e, c = h.m_xf.R;
            var k = this.m_localAnchorB.x - h.m_sweep.localCenter.x,
                l = this.m_localAnchorB.y - h.m_sweep.localCenter.y;
            e = c.col1.x * k + c.col2.x * l, l = c.col1.y * k + c.col2.y * l, k = e;
            var m = g.m_invMass,
                n = h.m_invMass,
                o = g.m_invI,
                p = h.m_invI,
                q = h.m_sweep.c.x + k - g.m_sweep.c.x - i,
                r = h.m_sweep.c.y + l - g.m_sweep.c.y - j,
                s = h.m_sweep.a - g.m_sweep.a - this.m_referenceAngle,
                t = 10 * a.b2_linearSlop,
                u = Math.sqrt(q * q + r * r),
                v = d.Abs(s);
            u > t && (o *= 1, p *= 1), this.m_mass.col1.x = m + n + j * j * o + l * l * p, this.m_mass.col2.x = -j * i * o - l * k * p, this.m_mass.col3.x = -j * o - l * p, this.m_mass.col1.y = this.m_mass.col2.x, this.m_mass.col2.y = m + n + i * i * o + k * k * p, this.m_mass.col3.y = i * o + k * p, this.m_mass.col1.z = this.m_mass.col3.x, this.m_mass.col2.z = this.m_mass.col3.y, this.m_mass.col3.z = o + p;
            var w = new f;
            return this.m_mass.Solve33(w, -q, -r, -s), g.m_sweep.c.x -= m * w.x, g.m_sweep.c.y -= m * w.y, g.m_sweep.a -= o * (i * w.y - j * w.x + w.z), h.m_sweep.c.x += n * w.x, h.m_sweep.c.y += n * w.y, h.m_sweep.a += p * (k * w.y - l * w.x + w.z), g.SynchronizeTransform(), h.SynchronizeTransform(), u <= a.b2_linearSlop && v <= a.b2_angularSlop
        }, Box2D.inherit(B, Box2D.Dynamics.Joints.b2JointDef), B.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype, B.b2WeldJointDef = function() {
            Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new e, this.localAnchorB = new e
        }, B.prototype.b2WeldJointDef = function() {
            this.__super.b2JointDef.call(this), this.type = n.e_weldJoint, this.referenceAngle = 0
        }, B.prototype.Initialize = function(a, b, c) {
            this.bodyA = a, this.bodyB = b, this.localAnchorA.SetV(this.bodyA.GetLocalPoint(c)), this.localAnchorB.SetV(this.bodyB.GetLocalPoint(c)), this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()
        }
    }(),
    function() {
        var a = Box2D.Dynamics.b2DebugDraw;
        a.b2DebugDraw = function() {
            this.m_drawScale = 1, this.m_lineThickness = 1, this.m_alpha = 1, this.m_fillAlpha = 1, this.m_xformScale = 1;
            var a = this;
            this.m_sprite = {
                graphics: {
                    clear: function() {
                        a.m_ctx.clearRect(0, 0, a.m_ctx.canvas.width, a.m_ctx.canvas.height)
                    }
                }
            }
        }, a.prototype._color = function(a, b) {
            return "rgba(" + ((16711680 & a) >> 16) + "," + ((65280 & a) >> 8) + "," + (255 & a) + "," + b + ")"
        }, a.prototype.b2DebugDraw = function() {
            this.m_drawFlags = 0
        }, a.prototype.SetFlags = function(a) {
            void 0 === a && (a = 0), this.m_drawFlags = a
        }, a.prototype.GetFlags = function() {
            return this.m_drawFlags
        }, a.prototype.AppendFlags = function(a) {
            void 0 === a && (a = 0), this.m_drawFlags |= a
        }, a.prototype.ClearFlags = function(a) {
            void 0 === a && (a = 0), this.m_drawFlags &= ~a
        }, a.prototype.SetSprite = function(a) {
            this.m_ctx = a
        }, a.prototype.GetSprite = function() {
            return this.m_ctx
        }, a.prototype.SetDrawScale = function(a) {
            void 0 === a && (a = 0), this.m_drawScale = a
        }, a.prototype.GetDrawScale = function() {
            return this.m_drawScale
        }, a.prototype.SetLineThickness = function(a) {
            void 0 === a && (a = 0), this.m_lineThickness = a, this.m_ctx.strokeWidth = a
        }, a.prototype.GetLineThickness = function() {
            return this.m_lineThickness
        }, a.prototype.SetAlpha = function(a) {
            void 0 === a && (a = 0), this.m_alpha = a
        }, a.prototype.GetAlpha = function() {
            return this.m_alpha
        }, a.prototype.SetFillAlpha = function(a) {
            void 0 === a && (a = 0), this.m_fillAlpha = a
        }, a.prototype.GetFillAlpha = function() {
            return this.m_fillAlpha
        }, a.prototype.SetXFormScale = function(a) {
            void 0 === a && (a = 0), this.m_xformScale = a
        }, a.prototype.GetXFormScale = function() {
            return this.m_xformScale
        }, a.prototype.DrawPolygon = function(a, b, c) {
            if (b) {
                var d = this.m_ctx,
                    e = this.m_drawScale;
                d.beginPath(), d.strokeStyle = this._color(c.color, this.m_alpha), d.moveTo(a[0].x * e, a[0].y * e);
                for (var f = 1; b > f; f++) d.lineTo(a[f].x * e, a[f].y * e);
                d.lineTo(a[0].x * e, a[0].y * e), d.closePath(), d.stroke()
            }
        }, a.prototype.DrawSolidPolygon = function(a, b, c) {
            if (b) {
                var d = this.m_ctx,
                    e = this.m_drawScale;
                d.beginPath(), d.strokeStyle = this._color(c.color, this.m_alpha), d.fillStyle = this._color(c.color, this.m_fillAlpha), d.moveTo(a[0].x * e, a[0].y * e);
                for (var f = 1; b > f; f++) d.lineTo(a[f].x * e, a[f].y * e);
                d.lineTo(a[0].x * e, a[0].y * e), d.closePath(), d.fill(), d.stroke()
            }
        }, a.prototype.DrawCircle = function(a, b, c) {
            if (b) {
                var d = this.m_ctx,
                    e = this.m_drawScale;
                d.beginPath(), d.strokeStyle = this._color(c.color, this.m_alpha), d.arc(a.x * e, a.y * e, b * e, 0, 2 * Math.PI, !0), d.closePath(), d.stroke()
            }
        }, a.prototype.DrawSolidCircle = function(a, b, c, d) {
            if (b) {
                var e = this.m_ctx,
                    f = this.m_drawScale,
                    g = a.x * f,
                    h = a.y * f;
                e.moveTo(0, 0), e.beginPath(), e.strokeStyle = this._color(d.color, this.m_alpha), e.fillStyle = this._color(d.color, this.m_fillAlpha), e.arc(g, h, b * f, 0, 2 * Math.PI, !0), e.moveTo(g, h), e.lineTo((a.x + c.x * b) * f, (a.y + c.y * b) * f), e.closePath(), e.fill(), e.stroke()
            }
        }, a.prototype.DrawSegment = function(a, b, c) {
            var d = this.m_ctx,
                e = this.m_drawScale;
            d.strokeStyle = this._color(c.color, this.m_alpha), d.beginPath(), d.moveTo(a.x * e, a.y * e), d.lineTo(b.x * e, b.y * e), d.closePath(), d.stroke()
        }, a.prototype.DrawTransform = function(a) {
            var b = this.m_ctx,
                c = this.m_drawScale;
            b.beginPath(), b.strokeStyle = this._color(16711680, this.m_alpha), b.moveTo(a.position.x * c, a.position.y * c), b.lineTo((a.position.x + this.m_xformScale * a.R.col1.x) * c, (a.position.y + this.m_xformScale * a.R.col1.y) * c), b.strokeStyle = this._color(65280, this.m_alpha), b.moveTo(a.position.x * c, a.position.y * c), b.lineTo((a.position.x + this.m_xformScale * a.R.col2.x) * c, (a.position.y + this.m_xformScale * a.R.col2.y) * c), b.closePath(), b.stroke()
        }
    }();
var i;
for (i = 0; i < Box2D.postDefs.length; ++i) Box2D.postDefs[i]();
delete Box2D.postDefs, "undefined" != typeof require && "undefined" != typeof module && (module.exports = Box2D);
! function() {
    Object.create = Object.create || function(a) {
        function b() {}
        return b.prototype = a, new b
    };
    var a;
    "undefined" == typeof exports ? (a = {}, "object" == typeof window && (window.cp = a)) : a = exports;
    var b, c, d = function(a, b) {
            if (!a) throw new Error("Assertion failed: " + b)
        },
        e = function(a, b) {
            !a && console && console.warn && (console.warn("ASSERTION FAILED: " + b), console.trace && console.trace())
        },
        f = function(a, b) {
            return b > a ? a : b
        },
        g = function(a, b) {
            return a > b ? a : b
        };
    "object" == typeof window && window.navigator.userAgent.indexOf("Firefox") > -1 ? (b = Math.min, c = Math.max) : (b = f, c = g);
    var h = function(a, b) {
            return b > a ? a + " " + b : b + " " + a
        },
        i = function(a, b) {
            for (var c = 0; c < a.length; c++)
                if (a[c] === b) return a[c] = a[a.length - 1], void a.length--
        },
        j = function(a, b, c) {
            var d = y(b, c),
                e = q(t(d, y(a, c)) / H(d));
            return x(c, A(d, e))
        },
        k = function(a, b, c, d, e, f) {
            var g = c - e,
                h = d - f,
                i = q(u(g, h, a - e, b - f) / I(g, h));
            return new r(e + g * i, f + h * i)
        };
    a.momentForCircle = function(a, b, c, d) {
        return a * (.5 * (b * b + c * c) + H(d))
    }, a.areaForCircle = function(a, b) {
        return Math.PI * Math.abs(a * a - b * b)
    }, a.momentForSegment = function(a, b, c) {
        var d = A(x(b, c), .5);
        return a * (O(c, b) / 12 + H(d))
    }, a.areaForSegment = function(a, b, c) {
        return c * (Math.PI * c + 2 * N(a, b))
    }, a.momentForPoly = function(a, b, c) {
        for (var d = 0, e = 0, f = b.length, g = 0; f > g; g += 2) {
            var h = b[g] + c.x,
                i = b[g + 1] + c.y,
                j = b[(g + 2) % f] + c.x,
                k = b[(g + 3) % f] + c.y,
                l = C(j, k, h, i),
                m = u(h, i, h, i) + u(h, i, j, k) + u(j, k, j, k);
            d += l * m, e += l
        }
        return a * d / (6 * e)
    }, a.areaForPoly = function(a) {
        for (var b = 0, c = 0, d = a.length; d > c; c += 2) b += B(new r(a[c], a[c + 1]), new r(a[(c + 2) % d], a[(c + 3) % d]));
        return -b / 2
    }, a.centroidForPoly = function(a) {
        for (var b = 0, c = new r(0, 0), d = 0, e = a.length; e > d; d += 2) {
            var f = new r(a[d], a[d + 1]),
                g = new r(a[(d + 2) % e], a[(d + 3) % e]),
                h = B(f, g);
            b += h, c = x(c, A(x(f, g), h))
        }
        return A(c, 1 / (3 * b))
    }, a.recenterPoly = function(b) {
        for (var c = a.centroidForPoly(b), d = 0; d < b.length; d += 2) b[d] -= c.x, b[d + 1] -= c.y
    }, a.momentForBox = function(a, b, c) {
        return a * (b * b + c * c) / 12
    }, a.momentForBox2 = function(b, c) {
        var d = c.r - c.l,
            e = c.t - c.b,
            f = A([c.l + c.r, c.b + c.t], .5);
        return a.momentForBox(b, d, e) + b * H(f)
    };
    var l = a.loopIndexes = function(a) {
            var b, c, d, e, f = 0,
                g = 0;
            b = d = a[0], c = e = a[1];
            for (var h = a.length >> 1, i = 1; h > i; i++) {
                var j = a[2 * i],
                    k = a[2 * i + 1];
                b > j || j == b && c > k ? (b = j, c = k, f = i) : (j > d || j == d && k > e) && (d = j, e = k, g = i)
            }
            return [f, g]
        },
        m = function(a, b, c) {
            var d = a[2 * b];
            a[2 * b] = a[2 * c], a[2 * c] = d, d = a[2 * b + 1], a[2 * b + 1] = a[2 * c + 1], a[2 * c + 1] = d
        },
        n = function(a, b, c, d, e, f) {
            if (0 === c) return 0;
            for (var g = 0, h = b, i = y(e, d), j = f * v(i), k = b, l = b + c - 1; l >= k;) {
                var n = new r(a[2 * k], a[2 * k + 1]),
                    o = B(i, y(n, d));
                o > j ? (o > g && (g = o, h = k), k++) : (m(a, k, l), l--)
            }
            return h != b && m(a, b, h), k - b
        },
        o = function(a, b, c, d, e, f, g, h) {
            if (0 > d) return 0;
            if (0 == d) return b[2 * h] = f.x, b[2 * h + 1] = f.y, 1;
            var i = n(b, c, d, e, f, a),
                j = new r(b[2 * c], b[2 * c + 1]),
                k = o(a, b, c + 1, i - 1, e, j, f, h),
                l = h + k++;
            b[2 * l] = f.x, b[2 * l + 1] = f.y;
            var m = n(b, c + i, d - i, f, g, a),
                p = new r(b[2 * (c + i)], b[2 * (c + i) + 1]);
            return k + o(a, b, c + i + 1, m - 1, f, p, g, h + k)
        };
    a.convexHull = function(a, b, c) {
        if (b)
            for (var d = 0; d < a.length; d++) b[d] = a[d];
        else b = a;
        var f = l(a),
            g = f[0],
            h = f[1];
        if (g == h) return b.length = 2, b;
        m(b, 0, g), m(b, 1, 0 == h ? g : h);
        var i = new r(b[0], b[1]),
            j = new r(b[2], b[3]),
            k = a.length >> 1,
            n = o(c, b, 2, k - 2, i, j, i, 1) + 1;
        return b.length = 2 * n, e(ab(b), "Internal error: cpConvexHull() and cpPolyValidate() did not agree.Please report this error with as much info as you can."), b
    };
    var p = function(a, d, e) {
            return b(c(a, d), e)
        },
        q = function(a) {
            return c(0, b(a, 1))
        },
        r = a.Vect = function(a, b) {
            this.x = a, this.y = b
        };
    a.v = function(a, b) {
        return new r(a, b)
    };
    var s = a.vzero = new r(0, 0),
        t = a.v.dot = function(a, b) {
            return a.x * b.x + a.y * b.y
        },
        u = function(a, b, c, d) {
            return a * c + b * d
        },
        v = a.v.len = function(a) {
            return Math.sqrt(t(a, a))
        },
        w = a.v.len2 = function(a, b) {
            return Math.sqrt(a * a + b * b)
        },
        x = (a.v.eql = function(a, b) {
            return a.x === b.x && a.y === b.y
        }, a.v.add = function(a, b) {
            return new r(a.x + b.x, a.y + b.y)
        });
    r.prototype.add = function(a) {
        return this.x += a.x, this.y += a.y, this
    };
    var y = a.v.sub = function(a, b) {
        return new r(a.x - b.x, a.y - b.y)
    };
    r.prototype.sub = function(a) {
        return this.x -= a.x, this.y -= a.y, this
    };
    var z = a.v.neg = function(a) {
        return new r(-a.x, -a.y)
    };
    r.prototype.neg = function() {
        return this.x = -this.x, this.y = -this.y, this
    };
    var A = a.v.mult = function(a, b) {
        return new r(a.x * b, a.y * b)
    };
    r.prototype.mult = function(a) {
        return this.x *= a, this.y *= a, this
    };
    var B = a.v.cross = function(a, b) {
            return a.x * b.y - a.y * b.x
        },
        C = function(a, b, c, d) {
            return a * d - b * c
        },
        D = a.v.perp = function(a) {
            return new r(-a.y, a.x)
        },
        E = (a.v.pvrperp = function(a) {
            return new r(a.y, -a.x)
        }, a.v.project = function(a, b) {
            return A(b, t(a, b) / H(b))
        });
    r.prototype.project = function(a) {
        return this.mult(t(this, a) / H(a)), this
    };
    var F = a.v.rotate = function(a, b) {
        return new r(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x)
    };
    r.prototype.rotate = function(a) {
        return this.x = this.x * a.x - this.y * a.y, this.y = this.x * a.y + this.y * a.x, this
    };
    var G = a.v.unrotate = function(a, b) {
            return new r(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y)
        },
        H = a.v.lengthsq = function(a) {
            return t(a, a)
        },
        I = a.v.lengthsq2 = function(a, b) {
            return a * a + b * b
        },
        J = a.v.lerp = function(a, b, c) {
            return x(A(a, 1 - c), A(b, c))
        },
        K = a.v.normalize = function(a) {
            return A(a, 1 / v(a))
        },
        L = a.v.normalize_safe = function(a) {
            return 0 === a.x && 0 === a.y ? s : K(a)
        },
        M = a.v.clamp = function(a, b) {
            return t(a, a) > b * b ? A(K(a), b) : a
        },
        N = (a.v.lerpconst = function(a, b, c) {
            return x(a, M(y(b, a), c))
        }, a.v.dist = function(a, b) {
            return v(y(a, b))
        }),
        O = a.v.distsq = function(a, b) {
            return H(y(a, b))
        },
        P = (a.v.near = function(a, b, c) {
            return O(a, b) < c * c
        }, a.v.slerp = function(a, b, c) {
            var d = Math.acos(t(a, b));
            if (d) {
                var e = 1 / Math.sin(d);
                return x(A(a, Math.sin((1 - c) * d) * e), A(b, Math.sin(c * d) * e))
            }
            return a
        }),
        Q = (a.v.slerpconst = function(a, c, d) {
            var e = Math.acos(t(a, c));
            return P(a, c, b(d, e) / e)
        }, a.v.forangle = function(a) {
            return new r(Math.cos(a), Math.sin(a))
        }, a.v.toangle = function(a) {
            return Math.atan2(a.y, a.x)
        }, a.v.str = function(a) {
            return "(" + a.x.toFixed(3) + ", " + a.y.toFixed(3) + ")"
        }, 0),
        R = a.BB = function(a, b, c, d) {
            this.l = a, this.b = b, this.r = c, this.t = d, Q++
        };
    a.bb = function(a, b, c, d) {
        return new R(a, b, c, d)
    };
    var S = function(a, b) {
            return new R(a.x - b, a.y - b, a.x + b, a.y + b)
        },
        T = function(a, b, c, d, e) {
            return a.l <= d && b <= a.r && a.b <= e && c <= a.t
        },
        U = 0,
        V = (a.NO_GROUP = 0, a.ALL_LAYERS = -1);
    a.resetShapeIdCounter = function() {
        U = 0
    };
    var W = a.Shape = function(a) {
        this.body = a, this.bb_l = this.bb_b = this.bb_r = this.bb_t = 0, this.hashid = U++, this.sensor = !1, this.e = 0, this.u = 0, this.surface_v = s, this.collision_type = 0, this.group = 0, this.layers = V, this.space = null, this.collisionCode = this.collisionCode
    };
    W.prototype.setElasticity = function(a) {
        this.e = a
    }, W.prototype.setFriction = function(a) {
        this.body.activate(), this.u = a
    }, W.prototype.setLayers = function(a) {
        this.body.activate(), this.layers = a
    }, W.prototype.setSensor = function(a) {
        this.body.activate(), this.sensor = a
    }, W.prototype.setCollisionType = function(a) {
        this.body.activate(), this.collision_type = a
    }, W.prototype.getBody = function() {
        return this.body
    }, W.prototype.active = function() {
        return this.body && -1 !== this.body.shapeList.indexOf(this)
    }, W.prototype.setBody = function(a) {
        d(!this.active(), "You cannot change the body on an active shape. You must remove the shape from the space before changing the body."), this.body = a
    }, W.prototype.cacheBB = function() {
        return this.update(this.body.p, this.body.rot)
    }, W.prototype.update = function(a, b) {
        d(!isNaN(b.x), "Rotation is NaN"), d(!isNaN(a.x), "Position is NaN"), this.cacheData(a, b)
    }, W.prototype.pointQuery = function(a) {
        var b = this.nearestPointQuery(a);
        return b.d < 0 ? b : void 0
    }, W.prototype.getBB = function() {
        return new R(this.bb_l, this.bb_b, this.bb_r, this.bb_t)
    };
    var X = function(a, b, c) {
            this.shape = a, this.p = b, this.d = c
        },
        Y = function(a, b, c) {
            this.shape = a, this.t = b, this.n = c
        };
    Y.prototype.hitPoint = function(a, b) {
        return J(a, b, this.t)
    }, Y.prototype.hitDist = function(a, b) {
        return N(a, b) * this.t
    };
    var Z = a.CircleShape = function(a, b, c) {
        this.c = this.tc = c, this.r = b, this.type = "circle", W.call(this, a)
    };
    Z.prototype = Object.create(W.prototype), Z.prototype.cacheData = function(a, b) {
        var c = this.tc = F(this.c, b).add(a),
            d = this.r;
        this.bb_l = c.x - d, this.bb_b = c.y - d, this.bb_r = c.x + d, this.bb_t = c.y + d
    }, Z.prototype.nearestPointQuery = function(a) {
        var b = a.x - this.tc.x,
            c = a.y - this.tc.y,
            d = w(b, c),
            e = this.r,
            f = new r(this.tc.x + b * e / d, this.tc.y + c * e / d);
        return new X(this, f, d - e)
    };
    var $ = function(a, b, c, d, e) {
        d = y(d, b), e = y(e, b);
        var f = t(d, d) - 2 * t(d, e) + t(e, e),
            g = -2 * t(d, d) + 2 * t(d, e),
            h = t(d, d) - c * c,
            i = g * g - 4 * f * h;
        if (i >= 0) {
            var j = (-g - Math.sqrt(i)) / (2 * f);
            if (j >= 0 && 1 >= j) return new Y(a, j, K(J(d, e, j)))
        }
    };
    Z.prototype.segmentQuery = function(a, b) {
        return $(this, this.tc, this.r, a, b)
    };
    var _ = a.SegmentShape = function(a, b, c, d) {
        this.a = b, this.b = c, this.n = D(K(y(c, b))), this.ta = this.tb = this.tn = null, this.r = d, this.a_tangent = s, this.b_tangent = s, this.type = "segment", W.call(this, a)
    };
    _.prototype = Object.create(W.prototype), _.prototype.cacheData = function(a, b) {
        this.ta = x(a, F(this.a, b)), this.tb = x(a, F(this.b, b)), this.tn = F(this.n, b);
        var c, d, e, f;
        this.ta.x < this.tb.x ? (c = this.ta.x, d = this.tb.x) : (c = this.tb.x, d = this.ta.x), this.ta.y < this.tb.y ? (e = this.ta.y, f = this.tb.y) : (e = this.tb.y, f = this.ta.y);
        var g = this.r;
        this.bb_l = c - g, this.bb_b = e - g, this.bb_r = d + g, this.bb_t = f + g
    }, _.prototype.nearestPointQuery = function(a) {
        var b = j(a, this.ta, this.tb),
            c = a.x - b.x,
            d = a.y - b.y,
            e = w(c, d),
            f = this.r,
            g = e ? x(b, A(new r(c, d), f / e)) : b;
        return new X(this, g, e - f)
    }, _.prototype.segmentQuery = function(a, b) {
        var c = this.tn,
            d = t(y(this.ta, a), c),
            e = this.r,
            f = d > 0 ? z(c) : c,
            g = y(A(f, e), a),
            h = x(this.ta, g),
            i = x(this.tb, g),
            j = y(b, a);
        if (B(j, h) * B(j, i) <= 0) {
            var k = d + (d > 0 ? -e : e),
                l = -k,
                m = t(j, c) - k;
            if (0 > l * m) return new Y(this, l / (l - m), f)
        } else if (0 !== e) {
            var n = $(this, this.ta, this.r, a, b),
                o = $(this, this.tb, this.r, a, b);
            return n ? o && o.t < n.t ? o : n : o
        }
    }, _.prototype.setNeighbors = function(a, b) {
        this.a_tangent = y(a, this.a), this.b_tangent = y(b, this.b)
    }, _.prototype.setEndpoints = function(a, b) {
        this.a = a, this.b = b, this.n = D(K(y(b, a)))
    };
    var ab = function(a) {
            for (var b = a.length, c = 0; b > c; c += 2) {
                var d = a[c],
                    e = a[c + 1],
                    f = a[(c + 2) % b],
                    g = a[(c + 3) % b],
                    h = a[(c + 4) % b],
                    i = a[(c + 5) % b];
                if (C(f - d, g - e, h - f, i - g) > 0) return !1
            }
            return !0
        },
        bb = a.PolyShape = function(a, b, c) {
            this.setVerts(b, c), this.type = "poly", W.call(this, a)
        };
    bb.prototype = Object.create(W.prototype);
    var cb = function(a, b) {
        this.n = a, this.d = b
    };
    cb.prototype.compare = function(a) {
        return t(this.n, a) - this.d
    }, bb.prototype.setVerts = function(a, b) {
        d(a.length >= 4, "Polygons require some verts"), d("number" == typeof a[0], "Polygon verticies should be specified in a flattened list (eg [x1,y1,x2,y2,x3,y3,...])"), d(ab(a), "Polygon is concave or has a reversed winding. Consider using cpConvexHull()");
        var c = a.length,
            e = c >> 1;
        this.verts = new Array(c), this.tVerts = new Array(c), this.planes = new Array(e), this.tPlanes = new Array(e);
        for (var f = 0; c > f; f += 2) {
            var g = a[f] + b.x,
                h = a[f + 1] + b.y,
                i = a[(f + 2) % c] + b.x,
                j = a[(f + 3) % c] + b.y,
                k = K(D(new r(i - g, j - h)));
            this.verts[f] = g, this.verts[f + 1] = h, this.planes[f >> 1] = new cb(k, u(k.x, k.y, g, h)), this.tPlanes[f >> 1] = new cb(new r(0, 0), 0)
        }
    };
    var db = (a.BoxShape = function(a, b, c) {
        var d = b / 2,
            e = c / 2;
        return db(a, new R(-d, -e, d, e))
    }, a.BoxShape2 = function(a, b) {
        var c = [b.l, b.b, b.l, b.t, b.r, b.t, b.r, b.b];
        return new bb(a, c, s)
    });
    bb.prototype.transformVerts = function(a, d) {
        for (var e = this.verts, f = this.tVerts, g = 1 / 0, h = -1 / 0, i = 1 / 0, j = -1 / 0, k = 0; k < e.length; k += 2) {
            var l = e[k],
                m = e[k + 1],
                n = a.x + l * d.x - m * d.y,
                o = a.y + l * d.y + m * d.x;
            f[k] = n, f[k + 1] = o, g = b(g, n), h = c(h, n), i = b(i, o), j = c(j, o)
        }
        this.bb_l = g, this.bb_b = i, this.bb_r = h, this.bb_t = j
    }, bb.prototype.transformAxes = function(a, b) {
        for (var c = this.planes, d = this.tPlanes, e = 0; e < c.length; e++) {
            var f = F(c[e].n, b);
            d[e].n = f, d[e].d = t(a, f) + c[e].d
        }
    }, bb.prototype.cacheData = function(a, b) {
        this.transformAxes(a, b), this.transformVerts(a, b)
    }, bb.prototype.nearestPointQuery = function(a) {
        for (var b = this.tPlanes, c = this.tVerts, d = c[c.length - 2], e = c[c.length - 1], f = 1 / 0, g = s, h = !1, i = 0; i < b.length; i++) {
            b[i].compare(a) > 0 && (h = !0);
            var j = c[2 * i],
                l = c[2 * i + 1],
                m = k(a.x, a.y, d, e, j, l),
                n = N(a, m);
            f > n && (f = n, g = m), d = j, e = l
        }
        return new X(this, g, h ? f : -f)
    }, bb.prototype.segmentQuery = function(a, b) {
        for (var c = this.tPlanes, d = this.tVerts, e = c.length, f = 2 * e, g = 0; e > g; g++) {
            var h = c[g].n,
                i = t(a, h);
            if (!(c[g].d > i)) {
                var j = t(b, h),
                    k = (c[g].d - i) / (j - i);
                if (!(0 > k || k > 1)) {
                    var l = J(a, b, k),
                        m = -B(h, l),
                        n = -C(h.x, h.y, d[2 * g], d[2 * g + 1]),
                        o = -C(h.x, h.y, d[(2 * g + 2) % f], d[(2 * g + 3) % f]);
                    if (m >= n && o >= m) return new Y(this, k, h)
                }
            }
        }
    }, bb.prototype.valueOnAxis = function(a, c) {
        for (var d = this.tVerts, e = u(a.x, a.y, d[0], d[1]), f = 2; f < d.length; f += 2) e = b(e, u(a.x, a.y, d[f], d[f + 1]));
        return e - c
    }, bb.prototype.containsVert = function(a, b) {
        for (var c = this.tPlanes, d = 0; d < c.length; d++) {
            var e = c[d].n,
                f = u(e.x, e.y, a, b) - c[d].d;
            if (f > 0) return !1
        }
        return !0
    }, bb.prototype.containsVertPartial = function(a, b, c) {
        for (var d = this.tPlanes, e = 0; e < d.length; e++) {
            var f = d[e].n;
            if (!(t(f, c) < 0)) {
                var g = u(f.x, f.y, a, b) - d[e].d;
                if (g > 0) return !1
            }
        }
        return !0
    }, bb.prototype.getNumVerts = function() {
        return this.verts.length / 2
    }, bb.prototype.getVert = function(a) {
        return new r(this.verts[2 * a], this.verts[2 * a + 1])
    };
    var eb = a.Body = function(a, b) {
            this.p = new r(0, 0), this.vx = this.vy = 0, this.f = new r(0, 0), this.w = 0, this.t = 0, this.v_limit = 1 / 0, this.w_limit = 1 / 0, this.v_biasx = this.v_biasy = 0, this.w_bias = 0, this.space = null, this.shapeList = [], this.arbiterList = null, this.constraintList = null, this.nodeRoot = null, this.nodeNext = null, this.nodeIdleTime = 0, this.setMass(a), this.setMoment(b), this.rot = new r(0, 0), this.setAngle(0)
        },
        fb = function(a, b) {
            d(a.x == a.x && a.y == a.y, b)
        },
        gb = function(a, b) {
            d(1 / 0 !== Math.abs(a.x) && 1 / 0 !== Math.abs(a.y), b)
        },
        hb = function(a, b) {
            fb(a, b), gb(a, b)
        };
    eb.prototype.sanityCheck = function() {
        d(this.m === this.m && this.m_inv === this.m_inv, "Body's mass is invalid."), d(this.i === this.i && this.i_inv === this.i_inv, "Body's moment is invalid."), hb(this.p, "Body's position is invalid."), hb(this.f, "Body's force is invalid."), d(this.vx === this.vx && 1 / 0 !== Math.abs(this.vx), "Body's velocity is invalid."), d(this.vy === this.vy && 1 / 0 !== Math.abs(this.vy), "Body's velocity is invalid."), d(this.a === this.a && 1 / 0 !== Math.abs(this.a), "Body's angle is invalid."), d(this.w === this.w && 1 / 0 !== Math.abs(this.w), "Body's angular velocity is invalid."), d(this.t === this.t && 1 / 0 !== Math.abs(this.t), "Body's torque is invalid."), hb(this.rot, "Body's rotation vector is invalid."), d(this.v_limit === this.v_limit, "Body's velocity limit is invalid."), d(this.w_limit === this.w_limit, "Body's angular velocity limit is invalid.")
    }, eb.prototype.getPos = function() {
        return this.p
    }, eb.prototype.getVel = function() {
        return new r(this.vx, this.vy)
    }, eb.prototype.getAngVel = function() {
        return this.w
    }, eb.prototype.isSleeping = function() {
        return null !== this.nodeRoot
    }, eb.prototype.isStatic = function() {
        return 1 / 0 === this.nodeIdleTime
    }, eb.prototype.isRogue = function() {
        return null === this.space
    }, eb.prototype.setMass = function(a) {
        d(a > 0, "Mass must be positive and non-zero."), this.activate(), this.m = a, this.m_inv = 1 / a
    }, eb.prototype.setMoment = function(a) {
        d(a > 0, "Moment of Inertia must be positive and non-zero."), this.activate(), this.i = a, this.i_inv = 1 / a
    }, eb.prototype.addShape = function(a) {
        this.shapeList.push(a)
    }, eb.prototype.removeShape = function(a) {
        i(this.shapeList, a)
    };
    var ib = function(a, b, c) {
        return a === c ? a.next(b) : (a.a === b ? a.next_a = ib(a.next_a, b, c) : a.next_b = ib(a.next_b, b, c), a)
    };
    eb.prototype.removeConstraint = function(a) {
        this.constraintList = ib(this.constraintList, this, a)
    }, eb.prototype.setPos = function(b) {
        this.activate(), this.sanityCheck(), b === s && (b = a.v(0, 0)), this.p = b
    }, eb.prototype.setVel = function(a) {
        this.activate(), this.vx = a.x, this.vy = a.y
    }, eb.prototype.setAngVel = function(a) {
        this.activate(), this.w = a
    }, eb.prototype.setAngleInternal = function(a) {
        d(!isNaN(a), "Internal Error: Attempting to set body's angle to NaN"), this.a = a, this.rot.x = Math.cos(a), this.rot.y = Math.sin(a)
    }, eb.prototype.setAngle = function(a) {
        this.activate(), this.sanityCheck(), this.setAngleInternal(a)
    }, eb.prototype.velocity_func = function(a, b, c) {
        var d = this.vx * b + (a.x + this.f.x * this.m_inv) * c,
            e = this.vy * b + (a.y + this.f.y * this.m_inv) * c,
            f = this.v_limit,
            g = d * d + e * e,
            h = g > f * f ? f / Math.sqrt(g) : 1;
        this.vx = d * h, this.vy = e * h;
        var i = this.w_limit;
        this.w = p(this.w * b + this.t * this.i_inv * c, -i, i), this.sanityCheck()
    }, eb.prototype.position_func = function(a) {
        this.p.x += (this.vx + this.v_biasx) * a, this.p.y += (this.vy + this.v_biasy) * a, this.setAngleInternal(this.a + (this.w + this.w_bias) * a), this.v_biasx = this.v_biasy = 0, this.w_bias = 0, this.sanityCheck()
    }, eb.prototype.resetForces = function() {
        this.activate(), this.f = new r(0, 0), this.t = 0
    }, eb.prototype.applyForce = function(a, b) {
        this.activate(), this.f = x(this.f, a), this.t += B(b, a)
    }, eb.prototype.applyImpulse = function(a, b) {
        this.activate(), kc(this, a.x, a.y, b)
    }, eb.prototype.getVelAtPoint = function(a) {
        return x(new r(this.vx, this.vy), A(D(a), this.w))
    }, eb.prototype.getVelAtWorldPoint = function(a) {
        return this.getVelAtPoint(y(a, this.p))
    }, eb.prototype.getVelAtLocalPoint = function(a) {
        return this.getVelAtPoint(F(a, this.rot))
    }, eb.prototype.eachShape = function(a) {
        for (var b = 0, c = this.shapeList.length; c > b; b++) a(this.shapeList[b])
    }, eb.prototype.eachConstraint = function(a) {
        for (var b = this.constraintList; b;) {
            var c = b.next(this);
            a(b), b = c
        }
    }, eb.prototype.eachArbiter = function(a) {
        for (var b = this.arbiterList; b;) {
            var c = b.next(this);
            b.swappedColl = this === b.body_b, a(b), b = c
        }
    }, eb.prototype.local2World = function(a) {
        return x(this.p, F(a, this.rot))
    }, eb.prototype.world2Local = function(a) {
        return G(y(a, this.p), this.rot)
    }, eb.prototype.kineticEnergy = function() {
        var a = this.vx * this.vx + this.vy * this.vy,
            b = this.w * this.w;
        return (a ? a * this.m : 0) + (b ? b * this.i : 0)
    };
    var jb = a.SpatialIndex = function(a) {
        if (this.staticIndex = a, a) {
            if (a.dynamicIndex) throw new Error("This static index is already associated with a dynamic index.");
            a.dynamicIndex = this
        }
    };
    jb.prototype.collideStatic = function(a, b) {
        if (a.count > 0) {
            var c = a.query;
            this.each(function(a) {
                c(a, new R(a.bb_l, a.bb_b, a.bb_r, a.bb_t), b)
            })
        }
    };
    var kb = a.BBTree = function(a) {
        jb.call(this, a), this.velocityFunc = null, this.leaves = {}, this.count = 0, this.root = null, this.pooledNodes = null, this.pooledPairs = null, this.stamp = 0
    };
    kb.prototype = Object.create(jb.prototype);
    var lb = 0,
        mb = function(a, d, e) {
            this.obj = null, this.bb_l = b(d.bb_l, e.bb_l), this.bb_b = b(d.bb_b, e.bb_b), this.bb_r = c(d.bb_r, e.bb_r), this.bb_t = c(d.bb_t, e.bb_t), this.parent = null, this.setA(d), this.setB(e)
        };
    kb.prototype.makeNode = function(a, b) {
        var c = this.pooledNodes;
        return c ? (this.pooledNodes = c.parent, c.constructor(this, a, b), c) : (lb++, new mb(this, a, b))
    };
    var nb = 0,
        ob = function(a, b) {
            this.obj = b, a.getBB(b, this), this.parent = null, this.stamp = 1, this.pairs = null, nb++
        };
    kb.prototype.getBB = function(a, d) {
        var e = this.velocityFunc;
        if (e) {
            var f = .1,
                g = (a.bb_r - a.bb_l) * f,
                h = (a.bb_t - a.bb_b) * f,
                i = A(e(a), .1);
            d.bb_l = a.bb_l + b(-g, i.x), d.bb_b = a.bb_b + b(-h, i.y), d.bb_r = a.bb_r + c(g, i.x), d.bb_t = a.bb_t + c(h, i.y)
        } else d.bb_l = a.bb_l, d.bb_b = a.bb_b, d.bb_r = a.bb_r, d.bb_t = a.bb_t
    }, kb.prototype.getStamp = function() {
        var a = this.dynamicIndex;
        return a && a.stamp ? a.stamp : this.stamp
    }, kb.prototype.incrementStamp = function() {
        this.dynamicIndex && this.dynamicIndex.stamp ? this.dynamicIndex.stamp++ : this.stamp++
    };
    var pb = 0,
        qb = function(a, b, c, d) {
            this.prevA = null, this.leafA = a, this.nextA = b, this.prevB = null, this.leafB = c, this.nextB = d
        };
    kb.prototype.makePair = function(a, b, c, d) {
        var e = this.pooledPairs;
        return e ? (this.pooledPairs = e.prevA, e.prevA = null, e.leafA = a, e.nextA = b, e.prevB = null, e.leafB = c, e.nextB = d, e) : (pb++, new qb(a, b, c, d))
    }, qb.prototype.recycle = function(a) {
        this.prevA = a.pooledPairs, a.pooledPairs = this
    };
    var rb = function(a, b, c) {
        c && (c.leafA === b ? c.prevA = a : c.prevB = a), a ? a.leafA === b ? a.nextA = c : a.nextB = c : b.pairs = c
    };
    ob.prototype.clearPairs = function(a) {
        var b, c = this.pairs;
        for (this.pairs = null; c;) c.leafA === this ? (b = c.nextA, rb(c.prevB, c.leafB, c.nextB)) : (b = c.nextB, rb(c.prevA, c.leafA, c.nextA)), c.recycle(a), c = b
    };
    var sb = function(a, b, c) {
        var d = a.pairs,
            e = b.pairs,
            f = c.makePair(a, d, b, e);
        a.pairs = b.pairs = f, d && (d.leafA === a ? d.prevA = f : d.prevB = f), e && (e.leafA === b ? e.prevA = f : e.prevB = f)
    };
    mb.prototype.recycle = function(a) {
        this.parent = a.pooledNodes, a.pooledNodes = this
    }, ob.prototype.recycle = function() {}, mb.prototype.setA = function(a) {
        this.A = a, a.parent = this
    }, mb.prototype.setB = function(a) {
        this.B = a, a.parent = this
    }, ob.prototype.isLeaf = !0, mb.prototype.isLeaf = !1, mb.prototype.otherChild = function(a) {
        return this.A == a ? this.B : this.A
    }, mb.prototype.replaceChild = function(a, d, f) {
        e(a == this.A || a == this.B, "Node is not a child of parent."), this.A == a ? (this.A.recycle(f), this.setA(d)) : (this.B.recycle(f), this.setB(d));
        for (var g = this; g; g = g.parent) {
            var h = g.A,
                i = g.B;
            g.bb_l = b(h.bb_l, i.bb_l), g.bb_b = b(h.bb_b, i.bb_b), g.bb_r = c(h.bb_r, i.bb_r), g.bb_t = c(h.bb_t, i.bb_t)
        }
    }, mb.prototype.bbArea = ob.prototype.bbArea = function() {
        return (this.bb_r - this.bb_l) * (this.bb_t - this.bb_b)
    };
    var tb = function(a, d) {
            return (c(a.bb_r, d.bb_r) - b(a.bb_l, d.bb_l)) * (c(a.bb_t, d.bb_t) - b(a.bb_b, d.bb_b))
        },
        ub = function(a, b) {
            return Math.abs(a.bb_l + a.bb_r - b.bb_l - b.bb_r) + Math.abs(a.bb_b + a.bb_t - b.bb_b - b.bb_t)
        },
        vb = function(a, d, e) {
            if (null == a) return d;
            if (a.isLeaf) return e.makeNode(d, a);
            var f = a.B.bbArea() + tb(a.A, d),
                g = a.A.bbArea() + tb(a.B, d);
            return f === g && (f = ub(a.A, d), g = ub(a.B, d)), f > g ? a.setB(vb(a.B, d, e)) : a.setA(vb(a.A, d, e)), a.bb_l = b(a.bb_l, d.bb_l), a.bb_b = b(a.bb_b, d.bb_b), a.bb_r = c(a.bb_r, d.bb_r), a.bb_t = c(a.bb_t, d.bb_t), a
        };
    mb.prototype.intersectsBB = ob.prototype.intersectsBB = function(a) {
        return this.bb_l <= a.r && a.l <= this.bb_r && this.bb_b <= a.t && a.b <= this.bb_t
    };
    var wb = function(a, b, c) {
            a.intersectsBB(b) && (a.isLeaf ? c(a.obj) : (wb(a.A, b, c), wb(a.B, b, c)))
        },
        xb = function(a, d, e) {
            var f = 1 / (e.x - d.x),
                g = a.bb_l == d.x ? -1 / 0 : (a.bb_l - d.x) * f,
                h = a.bb_r == d.x ? 1 / 0 : (a.bb_r - d.x) * f,
                i = b(g, h),
                j = c(g, h),
                k = 1 / (e.y - d.y),
                l = a.bb_b == d.y ? -1 / 0 : (a.bb_b - d.y) * k,
                m = a.bb_t == d.y ? 1 / 0 : (a.bb_t - d.y) * k,
                n = b(l, m),
                o = c(l, m);
            if (j >= n && o >= i) {
                var p = c(i, n),
                    q = b(j, o);
                if (q >= 0 && 1 >= p) return c(p, 0)
            }
            return 1 / 0
        },
        yb = function(a, c, d, e, f) {
            if (a.isLeaf) return f(a.obj);
            var g = xb(a.A, c, d),
                h = xb(a.B, c, d);
            return h > g ? (e > g && (e = b(e, yb(a.A, c, d, e, f))), e > h && (e = b(e, yb(a.B, c, d, e, f)))) : (e > h && (e = b(e, yb(a.B, c, d, e, f))), e > g && (e = b(e, yb(a.A, c, d, e, f)))), e
        };
    kb.prototype.subtreeRecycle = function(a) {
        a.isLeaf && (this.subtreeRecycle(a.A), this.subtreeRecycle(a.B), a.recycle(this))
    };
    var zb = function(a, b, c) {
            if (b == a) return null;
            var d = b.parent;
            if (d == a) {
                var e = a.otherChild(b);
                return e.parent = a.parent, a.recycle(c), e
            }
            return d.parent.replaceChild(d, d.otherChild(b), c), a
        },
        Ab = function(a, b) {
            return a.bb_l <= b.bb_r && b.bb_l <= a.bb_r && a.bb_b <= b.bb_t && b.bb_b <= a.bb_t
        };
    ob.prototype.markLeafQuery = function(a, b, c, d) {
        Ab(a, this) && (b ? sb(a, this, c) : (this.stamp < a.stamp && sb(this, a, c), d && d(a.obj, this.obj)))
    }, mb.prototype.markLeafQuery = function(a, b, c, d) {
        Ab(a, this) && (this.A.markLeafQuery(a, b, c, d), this.B.markLeafQuery(a, b, c, d))
    }, ob.prototype.markSubtree = function(a, b, c) {
        if (this.stamp == a.getStamp()) {
            b && b.markLeafQuery(this, !1, a, c);
            for (var d = this; d.parent; d = d.parent) d == d.parent.A ? d.parent.B.markLeafQuery(this, !0, a, c) : d.parent.A.markLeafQuery(this, !1, a, c)
        } else
            for (var e = this.pairs; e;) this === e.leafB ? (c && c(e.leafA.obj, this.obj), e = e.nextB) : e = e.nextA
    }, mb.prototype.markSubtree = function(a, b, c) {
        this.A.markSubtree(a, b, c), this.B.markSubtree(a, b, c)
    }, ob.prototype.containsObj = function(a) {
        return this.bb_l <= a.bb_l && this.bb_r >= a.bb_r && this.bb_b <= a.bb_b && this.bb_t >= a.bb_t
    }, ob.prototype.update = function(a) {
        var b = a.root,
            c = this.obj;
        return this.containsObj(c) ? !1 : (a.getBB(this.obj, this), b = zb(b, this, a), a.root = vb(b, this, a), this.clearPairs(a), this.stamp = a.getStamp(), !0)
    }, ob.prototype.addPairs = function(a) {
        var b = a.dynamicIndex;
        if (b) {
            var c = b.root;
            c && c.markLeafQuery(this, !0, b, null)
        } else {
            var d = a.staticIndex.root;
            this.markSubtree(a, d, null)
        }
    }, kb.prototype.insert = function(a, b) {
        var c = new ob(this, a);
        this.leaves[b] = c, this.root = vb(this.root, c, this), this.count++, c.stamp = this.getStamp(), c.addPairs(this), this.incrementStamp()
    }, kb.prototype.remove = function(a, b) {
        var c = this.leaves[b];
        delete this.leaves[b], this.root = zb(this.root, c, this), this.count--, c.clearPairs(this), c.recycle(this)
    }, kb.prototype.contains = function(a, b) {
        return null != this.leaves[b]
    };
    var Bb = function() {};
    kb.prototype.reindexQuery = function(a) {
        if (this.root) {
            var b, c = this.leaves;
            for (b in c) c[b].update(this);
            var d = this.staticIndex,
                e = d && d.root;
            this.root.markSubtree(this, e, a), d && !e && this.collideStatic(this, d, a), this.incrementStamp()
        }
    }, kb.prototype.reindex = function() {
        this.reindexQuery(Bb)
    }, kb.prototype.reindexObject = function(a, b) {
        var c = this.leaves[b];
        c && (c.update(this) && c.addPairs(this), this.incrementStamp())
    }, kb.prototype.pointQuery = function(a, b) {
        this.query(new R(a.x, a.y, a.x, a.y), b)
    }, kb.prototype.segmentQuery = function(a, b, c, d) {
        this.root && yb(this.root, a, b, c, d)
    }, kb.prototype.query = function(a, b) {
        this.root && wb(this.root, a, b)
    }, kb.prototype.count = function() {
        return this.count
    }, kb.prototype.each = function(a) {
        var b;
        for (b in this.leaves) a(this.leaves[b].obj)
    };
    var Cb = function(a, d, e, f, g) {
            return (c(a.bb_r, f) - b(a.bb_l, d)) * (c(a.bb_t, g) - b(a.bb_b, e))
        },
        Db = function(a, d, e, f) {
            if (1 == f) return d[e];
            if (2 == f) return a.makeNode(d[e], d[e + 1]);
            for (var g = d[e], h = g.bb_l, i = g.bb_b, j = g.bb_r, k = g.bb_t, l = e + f, m = e + 1; l > m; m++) g = d[m], h = b(h, g.bb_l), i = b(i, g.bb_b), j = c(j, g.bb_r), k = c(k, g.bb_t);
            var n = j - h > k - i,
                o = new Array(2 * f);
            if (n)
                for (var m = e; l > m; m++) o[2 * m + 0] = d[m].bb_l, o[2 * m + 1] = d[m].bb_r;
            else
                for (var m = e; l > m; m++) o[2 * m + 0] = d[m].bb_b, o[2 * m + 1] = d[m].bb_t;
            o.sort(function(a, b) {
                return a - b
            });
            var p = .5 * (o[f - 1] + o[f]),
                q = h,
                r = i,
                s = j,
                t = k,
                u = h,
                v = i,
                w = j,
                x = k;
            n ? s = u = p : t = v = p;
            for (var y = l, z = e; y > z;) {
                var g = d[z];
                Cb(g, u, v, w, x) < Cb(g, q, r, s, t) ? (y--, d[z] = d[y], d[y] = g) : z++
            }
            if (y == f) {
                for (var g = null, m = e; l > m; m++) g = vb(g, d[m], a);
                return g
            }
            return NodeNew(a, Db(a, d, e, y - e), Db(a, d, y, l - y))
        };
    kb.prototype.optimize = function() {
        var a = new Array(this.count),
            b = 0;
        for (var c in this.leaves) a[b++] = this.nodes[c];
        tree.subtreeRecycle(root), this.root = Db(tree, a, a.length)
    };
    var Eb = function(a, b) {
        !a.isLeaf && 10 >= b && (Eb(a.A, b + 1), Eb(a.B, b + 1));
        for (var c = "", d = 0; b > d; d++) c += " ";
        console.log(c + a.bb_b + " " + a.bb_t)
    };
    kb.prototype.log = function() {
        this.root && Eb(this.root, 0)
    };
    var Fb = a.CollisionHandler = function() {
        this.a = this.b = 0
    };
    Fb.prototype.begin = function() {
        return !0
    }, Fb.prototype.preSolve = function() {
        return !0
    }, Fb.prototype.postSolve = function() {}, Fb.prototype.separate = function() {};
    var Gb = function(a, b) {
        this.e = 0, this.u = 0, this.surface_vr = s, this.a = a, this.body_a = a.body, this.b = b, this.body_b = b.body, this.thread_a_next = this.thread_a_prev = null, this.thread_b_next = this.thread_b_prev = null, this.contacts = null, this.stamp = 0, this.handler = null, this.swappedColl = !1, this.state = "first coll"
    };
    Gb.prototype.getShapes = function() {
        return this.swappedColl ? [this.b, this.a] : [this.a, this.b]
    }, Gb.prototype.totalImpulse = function() {
        for (var a = this.contacts, b = new r(0, 0), c = 0, d = a.length; d > c; c++) {
            var e = a[c];
            b.add(A(e.n, e.jnAcc))
        }
        return this.swappedColl ? b : b.neg()
    }, Gb.prototype.totalImpulseWithFriction = function() {
        for (var a = this.contacts, b = new r(0, 0), c = 0, d = a.length; d > c; c++) {
            var e = a[c];
            b.add(new r(e.jnAcc, e.jtAcc).rotate(e.n))
        }
        return this.swappedColl ? b : b.neg()
    }, Gb.prototype.totalKE = function() {
        for (var a = (1 - this.e) / (1 + this.e), b = 0, c = this.contacts, d = 0, e = c.length; e > d; d++) {
            var f = c[d],
                g = f.jnAcc,
                h = f.jtAcc;
            b += a * g * g / f.nMass + h * h / f.tMass
        }
        return b
    }, Gb.prototype.ignore = function() {
        this.state = "ignore"
    }, Gb.prototype.getA = function() {
        return this.swappedColl ? this.b : this.a
    }, Gb.prototype.getB = function() {
        return this.swappedColl ? this.a : this.b
    }, Gb.prototype.isFirstContact = function() {
        return "first coll" === this.state
    };
    var Hb = function(a, b, c) {
        this.point = a, this.normal = b, this.dist = c
    };
    Gb.prototype.getContactPointSet = function() {
        var a, b = new Array(this.contacts.length);
        for (a = 0; a < b.length; a++) b[a] = new Hb(this.contacts[a].p, this.contacts[a].n, this.contacts[a].dist);
        return b
    }, Gb.prototype.getNormal = function(a) {
        var b = this.contacts[a].n;
        return this.swappedColl ? z(b) : b
    }, Gb.prototype.getPoint = function(a) {
        return this.contacts[a].p
    }, Gb.prototype.getDepth = function(a) {
        return this.contacts[a].dist
    };
    var Ib = function(a, b, c, d) {
        c ? c.body_a === b ? c.thread_a_next = d : c.thread_b_next = d : b.arbiterList = d, d && (d.body_a === b ? d.thread_a_prev = c : d.thread_b_prev = c)
    };
    Gb.prototype.unthread = function() {
        Ib(this, this.body_a, this.thread_a_prev, this.thread_a_next), Ib(this, this.body_b, this.thread_b_prev, this.thread_b_next), this.thread_a_prev = this.thread_a_next = null, this.thread_b_prev = this.thread_b_next = null
    }, Gb.prototype.update = function(a, b, c, d) {
        if (this.contacts)
            for (var e = 0; e < this.contacts.length; e++)
                for (var f = this.contacts[e], g = 0; g < a.length; g++) {
                    var h = a[g];
                    h.hash === f.hash && (h.jnAcc = f.jnAcc, h.jtAcc = f.jtAcc)
                }
        this.contacts = a, this.handler = b, this.swappedColl = c.collision_type !== b.a, this.e = c.e * d.e, this.u = c.u * d.u, this.surface_vr = y(c.surface_v, d.surface_v), this.a = c, this.body_a = c.body, this.b = d, this.body_b = d.body, "cached" == this.state && (this.state = "first coll")
    }, Gb.prototype.preStep = function(a, c, d) {
        for (var e = this.body_a, f = this.body_b, g = 0; g < this.contacts.length; g++) {
            var h = this.contacts[g];
            h.r1 = y(h.p, e.p), h.r2 = y(h.p, f.p), h.nMass = 1 / oc(e, f, h.r1, h.r2, h.n), h.tMass = 1 / oc(e, f, h.r1, h.r2, D(h.n)), h.bias = -d * b(0, h.dist + c) / a, h.jBias = 0, h.bounce = jc(e, f, h.r1, h.r2, h.n) * this.e
        }
    }, Gb.prototype.applyCachedImpulse = function(a) {
        if (!this.isFirstContact())
            for (var b = this.body_a, c = this.body_b, d = 0; d < this.contacts.length; d++) {
                var e = this.contacts[d],
                    f = e.n.x,
                    g = e.n.y,
                    h = f * e.jnAcc - g * e.jtAcc,
                    i = f * e.jtAcc + g * e.jnAcc;
                lc(b, c, e.r1, e.r2, h * a, i * a)
            }
    };
    var Jb = 0,
        Kb = 0;
    Gb.prototype.applyImpulse = function() {
        Jb++;
        for (var a = this.body_a, b = this.body_b, d = this.surface_vr, e = this.u, f = 0; f < this.contacts.length; f++) {
            Kb++;
            var g = this.contacts[f],
                h = g.nMass,
                i = g.n,
                j = g.r1,
                k = g.r2,
                l = b.vx - k.y * b.w - (a.vx - j.y * a.w),
                m = b.vy + k.x * b.w - (a.vy + j.x * a.w),
                n = i.x * (b.v_biasx - k.y * b.w_bias - a.v_biasx + j.y * a.w_bias) + i.y * (k.x * b.w_bias + b.v_biasy - j.x * a.w_bias - a.v_biasy),
                o = u(l, m, i.x, i.y),
                q = u(l + d.x, m + d.y, -i.y, i.x),
                r = (g.bias - n) * h,
                s = g.jBias;
            g.jBias = c(s + r, 0);
            var t = -(g.bounce + o) * h,
                v = g.jnAcc;
            g.jnAcc = c(v + t, 0);
            var w = e * g.jnAcc,
                x = -q * g.tMass,
                y = g.jtAcc;
            g.jtAcc = p(y + x, -w, w);
            var z = i.x * (g.jBias - s),
                A = i.y * (g.jBias - s);
            mc(a, -z, -A, j), mc(b, z, A, k);
            var B = g.jnAcc - v,
                C = g.jtAcc - y;
            lc(a, b, j, k, i.x * B - i.y * C, i.x * C + i.y * B)
        }
    }, Gb.prototype.callSeparate = function(a) {
        var b = a.lookupHandler(this.a.collision_type, this.b.collision_type);
        b.separate(this, a)
    }, Gb.prototype.next = function(a) {
        return this.body_a == a ? this.thread_a_next : this.thread_b_next
    };
    var Lb = 0,
        Mb = function(a, b, c, d) {
            this.p = a, this.n = b, this.dist = c, this.r1 = this.r2 = s, this.nMass = this.tMass = this.bounce = this.bias = 0, this.jnAcc = this.jtAcc = this.jBias = 0, this.hash = d, Lb++
        },
        Nb = [],
        Ob = function(a, b, c, d) {
            var e = c + d,
                f = y(b, a),
                g = H(f);
            if (!(g >= e * e)) {
                var h = Math.sqrt(g);
                return new Mb(x(a, A(f, .5 + (c - .5 * e) / (h ? h : 1 / 0))), h ? A(f, 1 / h) : new r(1, 0), h - e, 0)
            }
        },
        Pb = function(a, b) {
            var c = Ob(a.tc, b.tc, a.r, b.r);
            return c ? [c] : Nb
        },
        Qb = function(a, b) {
            var c = b.ta,
                d = b.tb,
                e = a.tc,
                f = y(d, c),
                g = q(t(f, y(e, c)) / H(f)),
                h = x(c, A(f, g)),
                i = Ob(e, h, a.r, b.r);
            if (i) {
                var j = i.n;
                return 0 === g && t(j, b.a_tangent) < 0 || 1 === g && t(j, b.b_tangent) < 0 ? Nb : [i]
            }
            return Nb
        },
        Rb = 0,
        Sb = function(a, b) {
            var c = 0,
                d = a.valueOnAxis(b[0].n, b[0].d);
            if (d > 0) return -1;
            for (var e = 1; e < b.length; e++) {
                var f = a.valueOnAxis(b[e].n, b[e].d);
                if (f > 0) return -1;
                f > d && (d = f, c = e)
            }
            return Rb = d, c
        },
        Tb = function(a, b, c, d) {
            for (var e = [], f = a.tVerts, g = 0; g < f.length; g += 2) {
                var i = f[g],
                    j = f[g + 1];
                b.containsVertPartial(i, j, z(c)) && e.push(new Mb(new r(i, j), c, d, h(a.hashid, g)))
            }
            for (var k = b.tVerts, g = 0; g < k.length; g += 2) {
                var i = k[g],
                    j = k[g + 1];
                a.containsVertPartial(i, j, c) && e.push(new Mb(new r(i, j), c, d, h(b.hashid, g)))
            }
            return e
        },
        Ub = function(a, b, c, d) {
            for (var e = [], f = a.tVerts, g = 0; g < f.length; g += 2) {
                var i = f[g],
                    j = f[g + 1];
                b.containsVert(i, j) && e.push(new Mb(new r(i, j), c, d, h(a.hashid, g >> 1)))
            }
            for (var k = b.tVerts, g = 0; g < k.length; g += 2) {
                var i = k[g],
                    j = k[g + 1];
                a.containsVert(i, j) && e.push(new Mb(new r(i, j), c, d, h(b.hashid, g >> 1)))
            }
            return e.length ? e : Tb(a, b, c, d)
        },
        Vb = function(a, b) {
            var c = Sb(b, a.tPlanes);
            if (-1 == c) return Nb;
            var d = Rb,
                e = Sb(a, b.tPlanes);
            if (-1 == e) return Nb;
            var f = Rb;
            return d > f ? Ub(a, b, a.tPlanes[c].n, d) : Ub(a, b, z(b.tPlanes[e].n), f)
        },
        Wb = function(a, c, d) {
            var e = t(c, a.ta) - a.r,
                f = t(c, a.tb) - a.r;
            return b(e, f) - d
        },
        Xb = function(a, b, c, d, e) {
            for (var f = B(b.tn, b.ta), g = B(b.tn, b.tb), i = A(b.tn, e), j = c.tVerts, k = 0; k < j.length; k += 2) {
                var l = j[k],
                    m = j[k + 1];
                if (u(l, m, i.x, i.y) < t(b.tn, b.ta) * e + b.r) {
                    var n = C(b.tn.x, b.tn.y, l, m);
                    f >= n && n >= g && a.push(new Mb(new r(l, m), i, d, h(c.hashid, k)))
                }
            }
        },
        Yb = function(a, b) {
            var c = [],
                d = b.tPlanes,
                e = d.length,
                f = t(a.tn, a.ta),
                g = b.valueOnAxis(a.tn, f) - a.r,
                i = b.valueOnAxis(z(a.tn), -f) - a.r;
            if (i > 0 || g > 0) return Nb;
            var j = 0,
                k = Wb(a, d[0].n, d[0].d);
            if (k > 0) return Nb;
            for (var l = 0; e > l; l++) {
                var m = Wb(a, d[l].n, d[l].d);
                if (m > 0) return Nb;
                m > k && (k = m, j = l)
            }
            var n = z(d[j].n),
                o = x(a.ta, A(n, a.r)),
                p = x(a.tb, A(n, a.r));
            if (b.containsVert(o.x, o.y) && c.push(new Mb(o, n, k, h(a.hashid, 0))), b.containsVert(p.x, p.y) && c.push(new Mb(p, n, k, h(a.hashid, 1))), (g >= k || i >= k) && (g > i ? Xb(c, a, b, g, 1) : Xb(c, a, b, i, -1)), 0 === c.length) {
                var q, s = 2 * j,
                    u = b.tVerts,
                    v = new r(u[s], u[s + 1]);
                if (q = Ob(a.ta, v, a.r, 0, c)) return [q];
                if (q = Ob(a.tb, v, a.r, 0, c)) return [q];
                var w = 2 * e,
                    y = new r(u[(s + 2) % w], u[(s + 3) % w]);
                if (q = Ob(a.ta, y, a.r, 0, c)) return [q];
                if (q = Ob(a.tb, y, a.r, 0, c)) return [q]
            }
            return c
        },
        Zb = function(a, b) {
            for (var c = b.tPlanes, d = 0, e = t(c[0].n, a.tc) - c[0].d - a.r, f = 0; f < c.length; f++) {
                var g = t(c[f].n, a.tc) - c[f].d - a.r;
                if (g > 0) return Nb;
                g > e && (e = g, d = f)
            }
            var h = c[d].n,
                i = b.tVerts,
                j = i.length,
                k = d << 1,
                l = i[k],
                m = i[k + 1],
                n = i[(k + 2) % j],
                o = i[(k + 3) % j],
                p = C(h.x, h.y, l, m),
                q = C(h.x, h.y, n, o),
                s = B(h, a.tc);
            if (q > s) {
                var u = Ob(a.tc, new r(n, o), a.r, 0, u);
                return u ? [u] : Nb
            }
            if (p > s) return [new Mb(y(a.tc, A(h, a.r + e / 2)), z(h), e, 0)];
            var u = Ob(a.tc, new r(l, m), a.r, 0, u);
            return u ? [u] : Nb
        };
    Z.prototype.collisionCode = 0, _.prototype.collisionCode = 1, bb.prototype.collisionCode = 2, Z.prototype.collisionTable = [Pb, Qb, Zb], _.prototype.collisionTable = [null,
        function() {
            return Nb
        },
        Yb
    ], bb.prototype.collisionTable = [null, null, Vb];
    var $b = a.collideShapes = function(a, b) {
            return d(a.collisionCode <= b.collisionCode, "Collided shapes must be sorted by type"), a.collisionTable[b.collisionCode](a, b)
        },
        _b = new Fb,
        ac = a.Space = function() {
            this.stamp = 0, this.curr_dt = 0, this.bodies = [], this.rousedBodies = [], this.sleepingComponents = [], this.staticShapes = new kb(null), this.activeShapes = new kb(this.staticShapes), this.arbiters = [], this.contactBuffersHead = null, this.cachedArbiters = {}, this.constraints = [], this.locked = 0, this.collisionHandlers = {}, this.defaultHandler = _b, this.postStepCallbacks = [], this.iterations = 10, this.gravity = s, this.damping = 1, this.idleSpeedThreshold = 0, this.sleepTimeThreshold = 1 / 0, this.collisionSlop = .1, this.collisionBias = Math.pow(.9, 60), this.collisionPersistence = 3, this.enableContactGraph = !1, this.staticBody = new eb(1 / 0, 1 / 0), this.staticBody.nodeIdleTime = 1 / 0, this.collideShapes = this.makeCollideShapes()
        };
    ac.prototype.getCurrentTimeStep = function() {
        return this.curr_dt
    }, ac.prototype.setIterations = function(a) {
        this.iterations = a
    }, ac.prototype.isLocked = function() {
        return this.locked
    };
    var bc = function(a) {
        d(!a.locked, "This addition/removal cannot be done safely during a call to cpSpaceStep()  or during a query. Put these calls into a post-step callback.")
    };
    ac.prototype.addCollisionHandler = function(a, b, c, d, e, f) {
        bc(this), this.removeCollisionHandler(a, b);
        var g = new Fb;
        g.a = a, g.b = b, c && (g.begin = c), d && (g.preSolve = d), e && (g.postSolve = e), f && (g.separate = f), this.collisionHandlers[h(a, b)] = g
    }, ac.prototype.removeCollisionHandler = function(a, b) {
        bc(this), delete this.collisionHandlers[h(a, b)]
    }, ac.prototype.setDefaultCollisionHandler = function(a, b, c, d) {
        bc(this);
        var e = new Fb;
        a && (e.begin = a), b && (e.preSolve = b), c && (e.postSolve = c), d && (e.separate = d), this.defaultHandler = e
    }, ac.prototype.lookupHandler = function(a, b) {
        return this.collisionHandlers[h(a, b)] || this.defaultHandler
    }, ac.prototype.addShape = function(a) {
        var b = a.body;
        return b.isStatic() ? this.addStaticShape(a) : (d(!a.space, "This shape is already added to a space and cannot be added to another."), bc(this), b.activate(), b.addShape(a), a.update(b.p, b.rot), this.activeShapes.insert(a, a.hashid), a.space = this, a)
    }, ac.prototype.addStaticShape = function(a) {
        d(!a.space, "This shape is already added to a space and cannot be added to another."), bc(this);
        var b = a.body;
        return b.addShape(a), a.update(b.p, b.rot), this.staticShapes.insert(a, a.hashid), a.space = this, a
    }, ac.prototype.addBody = function(a) {
        return d(!a.isStatic(), "Static bodies cannot be added to a space as they are not meant to be simulated."), d(!a.space, "This body is already added to a space and cannot be added to another."), bc(this), this.bodies.push(a), a.space = this, a
    }, ac.prototype.addConstraint = function(a) {
        d(!a.space, "This shape is already added to a space and cannot be added to another."), bc(this);
        var b = a.a,
            c = a.b;
        return b.activate(), c.activate(), this.constraints.push(a), a.next_a = b.constraintList, b.constraintList = a, a.next_b = c.constraintList, c.constraintList = a, a.space = this, a
    }, ac.prototype.filterArbiters = function(a, b) {
        for (var c in this.cachedArbiters) {
            var d = this.cachedArbiters[c];
            (a === d.body_a && (b === d.a || null === b) || a === d.body_b && (b === d.b || null === b)) && (b && "cached" !== d.state && d.callSeparate(this), d.unthread(), i(this.arbiters, d), delete this.cachedArbiters[c])
        }
    }, ac.prototype.removeShape = function(a) {
        var b = a.body;
        b.isStatic() ? this.removeStaticShape(a) : (d(this.containsShape(a), "Cannot remove a shape that was not added to the space. (Removed twice maybe?)"), bc(this), b.activate(), b.removeShape(a), this.filterArbiters(b, a), this.activeShapes.remove(a, a.hashid), a.space = null)
    }, ac.prototype.removeStaticShape = function(a) {
        d(this.containsShape(a), "Cannot remove a static or sleeping shape that was not added to the space. (Removed twice maybe?)"), bc(this);
        var b = a.body;
        b.isStatic() && b.activateStatic(a), b.removeShape(a), this.filterArbiters(b, a), this.staticShapes.remove(a, a.hashid), a.space = null
    }, ac.prototype.removeBody = function(a) {
        d(this.containsBody(a), "Cannot remove a body that was not added to the space. (Removed twice maybe?)"), bc(this), a.activate(), i(this.bodies, a), a.space = null
    }, ac.prototype.removeConstraint = function(a) {
        d(this.containsConstraint(a), "Cannot remove a constraint that was not added to the space. (Removed twice maybe?)"), bc(this), a.a.activate(), a.b.activate(), i(this.constraints, a), a.a.removeConstraint(a), a.b.removeConstraint(a), a.space = null
    }, ac.prototype.containsShape = function(a) {
        return a.space === this
    }, ac.prototype.containsBody = function(a) {
        return a.space == this
    }, ac.prototype.containsConstraint = function(a) {
        return a.space == this
    }, ac.prototype.uncacheArbiter = function(a) {
        delete this.cachedArbiters[h(a.a.hashid, a.b.hashid)], i(this.arbiters, a)
    }, ac.prototype.eachBody = function(a) {
        this.lock();
        for (var b = this.bodies, c = 0; c < b.length; c++) a(b[c]);
        for (var d = this.sleepingComponents, c = 0; c < d.length; c++)
            for (var e = d[c], f = e; f;) {
                var g = f.nodeNext;
                a(f), f = g
            }
        this.unlock(!0)
    }, ac.prototype.eachShape = function(a) {
        this.lock(), this.activeShapes.each(a), this.staticShapes.each(a), this.unlock(!0)
    }, ac.prototype.eachConstraint = function(a) {
        this.lock();
        for (var b = this.constraints, c = 0; c < b.length; c++) a(b[c]);
        this.unlock(!0)
    }, ac.prototype.reindexStatic = function() {
        d(!this.locked, "You cannot manually reindex objects while the space is locked. Wait until the current query or step is complete."), this.staticShapes.each(function(a) {
            var b = a.body;
            a.update(b.p, b.rot)
        }), this.staticShapes.reindex()
    }, ac.prototype.reindexShape = function(a) {
        d(!this.locked, "You cannot manually reindex objects while the space is locked. Wait until the current query or step is complete.");
        var b = a.body;
        a.update(b.p, b.rot), this.activeShapes.reindexObject(a, a.hashid), this.staticShapes.reindexObject(a, a.hashid)
    }, ac.prototype.reindexShapesForBody = function(a) {
        for (var b = a.shapeList; b; b = b.next) this.reindexShape(b)
    }, ac.prototype.useSpatialHash = function(a, b) {
        throw new Error("Spatial Hash not implemented.")
    }, ac.prototype.activateBody = function(a) {
        if (d(!a.isRogue(), "Internal error: Attempting to activate a rogue body."), this.locked) - 1 === this.rousedBodies.indexOf(a) && this.rousedBodies.push(a);
        else {
            this.bodies.push(a);
            for (var b = 0; b < a.shapeList.length; b++) {
                var c = a.shapeList[b];
                this.staticShapes.remove(c, c.hashid), this.activeShapes.insert(c, c.hashid)
            }
            for (var e = a.arbiterList; e; e = e.next(a)) {
                var f = e.body_a;
                if (a === f || f.isStatic()) {
                    var g = e.a,
                        i = e.b;
                    this.cachedArbiters[h(g.hashid, i.hashid)] = e, e.stamp = this.stamp, e.handler = this.lookupHandler(g.collision_type, i.collision_type), this.arbiters.push(e)
                }
            }
            for (var j = a.constraintList; j; j = j.nodeNext) {
                var f = j.a;
                (a === f || f.isStatic()) && this.constraints.push(j)
            }
        }
    }, ac.prototype.deactivateBody = function(a) {
        d(!a.isRogue(), "Internal error: Attempting to deactivate a rogue body."), i(this.bodies, a);
        for (var b = 0; b < a.shapeList.length; b++) {
            var c = a.shapeList[b];
            this.activeShapes.remove(c, c.hashid), this.staticShapes.insert(c, c.hashid)
        }
        for (var e = a.arbiterList; e; e = e.next(a)) {
            var f = e.body_a;
            (a === f || f.isStatic()) && this.uncacheArbiter(e)
        }
        for (var g = a.constraintList; g; g = g.nodeNext) {
            var f = g.a;
            (a === f || f.isStatic()) && i(this.constraints, g)
        }
    };
    var cc = function(a) {
            return a ? a.nodeRoot : null
        },
        dc = function(a) {
            if (a && a.isSleeping(a)) {
                d(!a.isRogue(), "Internal Error: componentActivate() called on a rogue body.");
                for (var b = a.space, c = a; c;) {
                    var e = c.nodeNext;
                    c.nodeIdleTime = 0, c.nodeRoot = null, c.nodeNext = null, b.activateBody(c), c = e
                }
                i(b.sleepingComponents, a)
            }
        };
    eb.prototype.activate = function() {
        this.isRogue() || (this.nodeIdleTime = 0, dc(cc(this)))
    }, eb.prototype.activateStatic = function(a) {
        d(this.isStatic(), "Body.activateStatic() called on a non-static body.");
        for (var b = this.arbiterList; b; b = b.next(this)) a && a != b.a && a != b.b || (b.body_a == this ? b.body_b : b.body_a).activate()
    }, eb.prototype.pushArbiter = function(a) {
        e(null === (a.body_a === this ? a.thread_a_next : a.thread_b_next), "Internal Error: Dangling contact graph pointers detected. (A)"), e(null === (a.body_a === this ? a.thread_a_prev : a.thread_b_prev), "Internal Error: Dangling contact graph pointers detected. (B)");
        var b = this.arbiterList;
        e(null === b || null === (b.body_a === this ? b.thread_a_prev : b.thread_b_prev), "Internal Error: Dangling contact graph pointers detected. (C)"), a.body_a === this ? a.thread_a_next = b : a.thread_b_next = b, b && (b.body_a === this ? b.thread_a_prev = a : b.thread_b_prev = a), this.arbiterList = a
    };
    var ec = function(a, b) {
            b.nodeRoot = a, b !== a && (b.nodeNext = a.nodeNext, a.nodeNext = b)
        },
        fc = function(a, b) {
            if (!b.isRogue()) {
                var c = cc(b);
                if (null == c) {
                    ec(a, b);
                    for (var d = b.arbiterList; d; d = d.next(b)) fc(a, b == d.body_a ? d.body_b : d.body_a);
                    for (var f = b.constraintList; f; f = f.next(b)) fc(a, b == f.a ? f.b : f.a)
                } else e(c === a, "Internal Error: Inconsistency detected in the contact graph.")
            }
        },
        gc = function(a, b) {
            for (var c = a; c; c = c.nodeNext)
                if (c.nodeIdleTime < b) return !0;
            return !1
        };
    ac.prototype.processComponents = function(a) {
        for (var b = 1 / 0 !== this.sleepTimeThreshold, c = this.bodies, d = 0; d < c.length; d++) {
            var f = c[d];
            e(null === f.nodeNext, "Internal Error: Dangling next pointer detected in contact graph."), e(null === f.nodeRoot, "Internal Error: Dangling root pointer detected in contact graph.")
        }
        if (b)
            for (var g = this.idleSpeedThreshold, h = g ? g * g : H(this.gravity) * a * a, d = 0; d < c.length; d++) {
                var f = c[d],
                    i = h ? f.m * h : 0;
                f.nodeIdleTime = f.kineticEnergy() > i ? 0 : f.nodeIdleTime + a
            }
        for (var j = this.arbiters, d = 0, k = j.length; k > d; d++) {
            var l = j[d],
                m = l.body_a,
                n = l.body_b;
            b && ((n.isRogue() && !n.isStatic() || m.isSleeping()) && m.activate(), (m.isRogue() && !m.isStatic() || n.isSleeping()) && n.activate()), m.pushArbiter(l), n.pushArbiter(l)
        }
        if (b) {
            for (var o = this.constraints, d = 0; d < o.length; d++) {
                var p = o[d],
                    m = p.a,
                    n = p.b;
                n.isRogue() && !n.isStatic() && m.activate(), m.isRogue() && !m.isStatic() && n.activate()
            }
            for (var d = 0; d < c.length;) {
                var f = c[d];
                if (null !== cc(f) || (fc(f, f), gc(f, this.sleepTimeThreshold))) d++, f.nodeRoot = null, f.nodeNext = null;
                else {
                    this.sleepingComponents.push(f);
                    for (var q = f; q; q = q.nodeNext) this.deactivateBody(q)
                }
            }
        }
    }, eb.prototype.sleep = function() {
        this.sleepWithGroup(null)
    }, eb.prototype.sleepWithGroup = function(a) {
        d(!this.isStatic() && !this.isRogue(), "Rogue and static bodies cannot be put to sleep.");
        var b = this.space;
        if (d(b, "Cannot put a rogue body to sleep."), d(!b.locked, "Bodies cannot be put to sleep during a query or a call to cpSpaceStep(). Put these calls into a post-step callback."), d(null === a || a.isSleeping(), "Cannot use a non-sleeping body as a group identifier."), this.isSleeping()) return void d(cc(this) === cc(a), "The body is already sleeping and it's group cannot be reassigned.");
        for (var c = 0; c < this.shapeList.length; c++) this.shapeList[c].update(this.p, this.rot);
        if (b.deactivateBody(this), a) {
            var e = cc(a);
            this.nodeRoot = e, this.nodeNext = e.nodeNext, this.nodeIdleTime = 0, e.nodeNext = this
        } else this.nodeRoot = this, this.nodeNext = null, this.nodeIdleTime = 0, b.sleepingComponents.push(this);
        i(b.bodies, this)
    }, ac.prototype.activateShapesTouchingShape = function(a) {
        1 / 0 !== this.sleepTimeThreshold && this.shapeQuery(a, function(a) {
            a.body.activate()
        })
    }, ac.prototype.pointQuery = function(a, b, c, d) {
        var e = function(e) {
                (!e.group || c !== e.group) && b & e.layers && e.pointQuery(a) && d(e)
            },
            f = new R(a.x, a.y, a.x, a.y);
        this.lock(), this.activeShapes.query(f, e), this.staticShapes.query(f, e), this.unlock(!0)
    }, ac.prototype.pointQueryFirst = function(a, b, c) {
        var d = null;
        return this.pointQuery(a, b, c, function(a) {
            a.sensor || (d = a)
        }), d
    }, ac.prototype.nearestPointQuery = function(a, b, c, d, e) {
        var f = function(f) {
                if ((!f.group || d !== f.group) && c & f.layers) {
                    var g = f.nearestPointQuery(a);
                    g.d < b && e(f, g.d, g.p)
                }
            },
            g = S(a, b);
        this.lock(), this.activeShapes.query(g, f), this.staticShapes.query(g, f), this.unlock(!0)
    }, ac.prototype.nearestPointQueryNearest = function(a, b, c, d) {
        var e, f = function(f) {
                if ((!f.group || d !== f.group) && c & f.layers && !f.sensor) {
                    var g = f.nearestPointQuery(a);
                    g.d < b && (!e || g.d < e.d) && (e = g)
                }
            },
            g = S(a, b);
        return this.activeShapes.query(g, f), this.staticShapes.query(g, f), e
    }, ac.prototype.segmentQuery = function(a, b, c, d, e) {
        var f = function(f) {
            var g;
            return (!f.group || d !== f.group) && c & f.layers && (g = f.segmentQuery(a, b)) && e(f, g.t, g.n), 1
        };
        this.lock(), this.staticShapes.segmentQuery(a, b, 1, f), this.activeShapes.segmentQuery(a, b, 1, f), this.unlock(!0)
    }, ac.prototype.segmentQueryFirst = function(a, b, c, d) {
        var e = null,
            f = function(f) {
                var g;
                return (!f.group || d !== f.group) && c & f.layers && !f.sensor && (g = f.segmentQuery(a, b)) && (null === e || g.t < e.t) && (e = g), e ? e.t : 1
            };
        return this.staticShapes.segmentQuery(a, b, 1, f), this.activeShapes.segmentQuery(a, b, e ? e.t : 1, f), e
    }, ac.prototype.bbQuery = function(a, b, c, d) {
        var e = function(e) {
            (!e.group || c !== e.group) && b & e.layers && T(a, e.bb_l, e.bb_b, e.bb_r, e.bb_t) && d(e)
        };
        this.lock(), this.activeShapes.query(a, e), this.staticShapes.query(a, e), this.unlock(!0)
    }, ac.prototype.shapeQuery = function(a, b) {
        var c = a.body;
        c && a.update(c.p, c.rot);
        var d = new R(a.bb_l, a.bb_b, a.bb_r, a.bb_t),
            e = !1,
            f = function(c) {
                var d = a;
                if ((!d.group || d.group !== c.group) && d.layers & c.layers && d !== c) {
                    var f;
                    if (d.collisionCode <= c.collisionCode) f = $b(d, c);
                    else {
                        f = $b(c, d);
                        for (var g = 0; g < f.length; g++) f[g].n = z(f[g].n)
                    } if (f.length && (e = !(d.sensor || c.sensor), b)) {
                        for (var h = new Array(f.length), g = 0; g < f.length; g++) h[g] = new Hb(f[g].p, f[g].n, f[g].dist);
                        b(c, h)
                    }
                }
            };
        return this.lock(), this.activeShapes.query(d, f), this.staticShapes.query(d, f), this.unlock(!0), e
    }, ac.prototype.addPostStepCallback = function(a) {
        e(this.locked, "Adding a post-step callback when the space is not locked is unnecessary. Post-step callbacks will not called until the end of the next call to cpSpaceStep() or the next query."), this.postStepCallbacks.push(a)
    }, ac.prototype.runPostStepCallbacks = function() {
        for (var a = 0; a < this.postStepCallbacks.length; a++) this.postStepCallbacks[a]();
        this.postStepCallbacks = []
    }, ac.prototype.lock = function() {
        this.locked++
    }, ac.prototype.unlock = function(a) {
        if (this.locked--, d(this.locked >= 0, "Internal Error: Space lock underflow."), 0 === this.locked && a) {
            for (var b = this.rousedBodies, c = 0; c < b.length; c++) this.activateBody(b[c]);
            b.length = 0, this.runPostStepCallbacks()
        }
    }, ac.prototype.makeCollideShapes = function() {
        var a = this;
        return function(b, c) {
            var d = a;
            if (b.bb_l <= c.bb_r && c.bb_l <= b.bb_r && b.bb_b <= c.bb_t && c.bb_b <= b.bb_t && b.body !== c.body && (!b.group || b.group !== c.group) && b.layers & c.layers) {
                var e = d.lookupHandler(b.collision_type, c.collision_type),
                    f = b.sensor || c.sensor;
                if (!f || e !== _b) {
                    if (b.collisionCode > c.collisionCode) {
                        var g = b;
                        b = c, c = g
                    }
                    var i = $b(b, c);
                    if (0 !== i.length) {
                        var j = h(b.hashid, c.hashid),
                            k = d.cachedArbiters[j];
                        k || (k = d.cachedArbiters[j] = new Gb(b, c)), k.update(i, e, b, c), "first coll" != k.state || e.begin(k, d) || k.ignore(), "ignore" !== k.state && e.preSolve(k, d) && !f ? d.arbiters.push(k) : (k.contacts = null, "ignore" !== k.state && (k.state = "normal")), k.stamp = d.stamp
                    }
                }
            }
        }
    }, ac.prototype.arbiterSetFilter = function(a) {
        var b = this.stamp - a.stamp,
            c = a.body_a,
            d = a.body_b;
        return (c.isStatic() || c.isSleeping()) && (d.isStatic() || d.isSleeping()) ? !0 : (b >= 1 && "cached" != a.state && (a.callSeparate(this), a.state = "cached"), b >= this.collisionPersistence ? (a.contacts = null, !1) : !0)
    };
    var hc = function(a) {
        var b = a.body;
        a.update(b.p, b.rot)
    };
    ac.prototype.step = function(a) {
        if (0 !== a) {
            d(0 === s.x && 0 === s.y, "vzero is invalid"), this.stamp++;
            var b = this.curr_dt;
            this.curr_dt = a;
            var c, e, f, g = this.bodies,
                h = this.constraints,
                i = this.arbiters;
            for (c = 0; c < i.length; c++) {
                var j = i[c];
                j.state = "normal", j.body_a.isSleeping() || j.body_b.isSleeping() || j.unthread()
            }
            for (i.length = 0, this.lock(), c = 0; c < g.length; c++) g[c].position_func(a);
            this.activeShapes.each(hc), this.activeShapes.reindexQuery(this.collideShapes), this.unlock(!1), this.processComponents(a), this.lock();
            for (f in this.cachedArbiters) this.arbiterSetFilter(this.cachedArbiters[f]) || delete this.cachedArbiters[f];
            var k = this.collisionSlop,
                l = 1 - Math.pow(this.collisionBias, a);
            for (c = 0; c < i.length; c++) i[c].preStep(a, k, l);
            for (c = 0; c < h.length; c++) {
                var m = h[c];
                m.preSolve(this), m.preStep(a)
            }
            var n = Math.pow(this.damping, a),
                o = this.gravity;
            for (c = 0; c < g.length; c++) g[c].velocity_func(o, n, a);
            var p = 0 === b ? 0 : a / b;
            for (c = 0; c < i.length; c++) i[c].applyCachedImpulse(p);
            for (c = 0; c < h.length; c++) h[c].applyCachedImpulse(p);
            for (c = 0; c < this.iterations; c++) {
                for (e = 0; e < i.length; e++) i[e].applyImpulse();
                for (e = 0; e < h.length; e++) h[e].applyImpulse()
            }
            for (c = 0; c < h.length; c++) h[c].postSolve(this);
            for (c = 0; c < i.length; c++) i[c].handler.postSolve(i[c], this);
            this.unlock(!0)
        }
    };
    var ic = function(a, b, c, d) {
            var e = a.vx + -c.y * a.w,
                f = a.vy + c.x * a.w,
                g = b.vx + -d.y * b.w,
                h = b.vy + d.x * b.w;
            return new r(g - e, h - f)
        },
        jc = function(a, b, c, d, e) {
            var f = a.vx + -c.y * a.w,
                g = a.vy + c.x * a.w,
                h = b.vx + -d.y * b.w,
                i = b.vy + d.x * b.w;
            return u(h - f, i - g, e.x, e.y)
        },
        kc = function(a, b, c, d) {
            a.vx += b * a.m_inv, a.vy += c * a.m_inv, a.w += a.i_inv * (d.x * c - d.y * b)
        },
        lc = function(a, b, c, d, e, f) {
            kc(a, -e, -f, c), kc(b, e, f, d)
        },
        mc = function(a, b, c, d) {
            a.v_biasx += b * a.m_inv, a.v_biasy += c * a.m_inv, a.w_bias += a.i_inv * C(d.x, d.y, b, c)
        },
        nc = function(a, b, c) {
            var d = B(b, c);
            return a.m_inv + a.i_inv * d * d
        },
        oc = function(a, b, c, d, f) {
            var g = nc(a, c, f) + nc(b, d, f);
            return e(0 !== g, "Unsolvable collision or constraint."), g
        },
        pc = function(a, b, c, d, f, g) {
            var h, i, j, k, l = a.m_inv + b.m_inv;
            h = l, i = 0, j = 0, k = l;
            var m = a.i_inv,
                n = c.x * c.x * m,
                o = c.y * c.y * m,
                p = -c.x * c.y * m;
            h += o, i += p, j += p, k += n;
            var q = b.i_inv,
                r = d.x * d.x * q,
                s = d.y * d.y * q,
                t = -d.x * d.y * q;
            h += s, i += t, j += t, k += r;
            var u = h * k - i * j;
            e(0 !== u, "Unsolvable constraint.");
            var v = 1 / u;
            f.x = k * v, f.y = -i * v, g.x = -j * v, g.y = h * v
        },
        qc = function(a, b, c) {
            return new r(t(a, b), t(a, c))
        },
        rc = function(a, b) {
            return 1 - Math.pow(a, b)
        },
        sc = a.Constraint = function(a, b) {
            this.a = a, this.b = b, this.space = null, this.next_a = null, this.next_b = null, this.maxForce = 1 / 0, this.errorBias = Math.pow(.9, 60), this.maxBias = 1 / 0
        };
    sc.prototype.activateBodies = function() {
        this.a && this.a.activate(), this.b && this.b.activate()
    }, sc.prototype.preStep = function() {}, sc.prototype.applyCachedImpulse = function() {}, sc.prototype.applyImpulse = function() {}, sc.prototype.getImpulse = function() {
        return 0
    }, sc.prototype.preSolve = function() {}, sc.prototype.postSolve = function() {}, sc.prototype.next = function(a) {
        return this.a === a ? this.next_a : this.next_b
    };
    var tc = a.PinJoint = function(a, b, c, d) {
        sc.call(this, a, b), this.anchr1 = c, this.anchr2 = d;
        var f = a ? x(a.p, F(c, a.rot)) : c,
            g = b ? x(b.p, F(d, b.rot)) : d;
        this.dist = v(y(g, f)), e(this.dist > 0, "You created a 0 length pin joint. A pivot joint will be much more stable."), this.r1 = this.r2 = null, this.n = null, this.nMass = 0, this.jnAcc = this.jnMax = 0, this.bias = 0
    };
    tc.prototype = Object.create(sc.prototype), tc.prototype.preStep = function(a) {
        var b = this.a,
            c = this.b;
        this.r1 = F(this.anchr1, b.rot), this.r2 = F(this.anchr2, c.rot);
        var d = y(x(c.p, this.r2), x(b.p, this.r1)),
            e = v(d);
        this.n = A(d, 1 / (e ? e : 1 / 0)), this.nMass = 1 / oc(b, c, this.r1, this.r2, this.n);
        var f = this.maxBias;
        this.bias = p(-rc(this.errorBias, a) * (e - this.dist) / a, -f, f), this.jnMax = this.maxForce * a
    }, tc.prototype.applyCachedImpulse = function(a) {
        var b = A(this.n, this.jnAcc * a);
        lc(this.a, this.b, this.r1, this.r2, b.x, b.y)
    }, tc.prototype.applyImpulse = function() {
        var a = this.a,
            b = this.b,
            c = this.n,
            d = jc(a, b, this.r1, this.r2, c),
            e = (this.bias - d) * this.nMass,
            f = this.jnAcc;
        this.jnAcc = p(f + e, -this.jnMax, this.jnMax), e = this.jnAcc - f, lc(a, b, this.r1, this.r2, c.x * e, c.y * e)
    }, tc.prototype.getImpulse = function() {
        return Math.abs(this.jnAcc)
    };
    var uc = a.SlideJoint = function(a, b, c, d, e, f) {
        sc.call(this, a, b), this.anchr1 = c, this.anchr2 = d, this.min = e, this.max = f, this.r1 = this.r2 = this.n = null, this.nMass = 0, this.jnAcc = this.jnMax = 0, this.bias = 0
    };
    uc.prototype = Object.create(sc.prototype), uc.prototype.preStep = function(a) {
        var b = this.a,
            c = this.b;
        this.r1 = F(this.anchr1, b.rot), this.r2 = F(this.anchr2, c.rot);
        var d = y(x(c.p, this.r2), x(b.p, this.r1)),
            e = v(d),
            f = 0;
        e > this.max ? (f = e - this.max, this.n = L(d)) : e < this.min ? (f = this.min - e, this.n = z(L(d))) : (this.n = s, this.jnAcc = 0), this.nMass = 1 / oc(b, c, this.r1, this.r2, this.n);
        var g = this.maxBias;
        this.bias = p(-rc(this.errorBias, a) * f / a, -g, g), this.jnMax = this.maxForce * a
    }, uc.prototype.applyCachedImpulse = function(a) {
        var b = this.jnAcc * a;
        lc(this.a, this.b, this.r1, this.r2, this.n.x * b, this.n.y * b)
    }, uc.prototype.applyImpulse = function() {
        if (0 !== this.n.x || 0 !== this.n.y) {
            var a = this.a,
                b = this.b,
                c = this.n,
                d = this.r1,
                e = this.r2,
                f = ic(a, b, d, e),
                g = t(f, c),
                h = (this.bias - g) * this.nMass,
                i = this.jnAcc;
            this.jnAcc = p(i + h, -this.jnMax, 0), h = this.jnAcc - i, lc(a, b, this.r1, this.r2, c.x * h, c.y * h)
        }
    }, uc.prototype.getImpulse = function() {
        return Math.abs(this.jnAcc)
    };
    var vc = a.PivotJoint = function(a, b, c, d) {
        if (sc.call(this, a, b), "undefined" == typeof d) {
            var e = c;
            c = a ? a.world2Local(e) : e, d = b ? b.world2Local(e) : e
        }
        this.anchr1 = c, this.anchr2 = d, this.r1 = this.r2 = s, this.k1 = new r(0, 0), this.k2 = new r(0, 0), this.jAcc = s, this.jMaxLen = 0, this.bias = s
    };
    vc.prototype = Object.create(sc.prototype), vc.prototype.preStep = function(a) {
        var b = this.a,
            c = this.b;
        this.r1 = F(this.anchr1, b.rot), this.r2 = F(this.anchr2, c.rot), pc(b, c, this.r1, this.r2, this.k1, this.k2), this.jMaxLen = this.maxForce * a;
        var d = y(x(c.p, this.r2), x(b.p, this.r1));
        this.bias = M(A(d, -rc(this.errorBias, a) / a), this.maxBias)
    }, vc.prototype.applyCachedImpulse = function(a) {
        lc(this.a, this.b, this.r1, this.r2, this.jAcc.x * a, this.jAcc.y * a)
    }, vc.prototype.applyImpulse = function() {
        var a = this.a,
            b = this.b,
            c = this.r1,
            d = this.r2,
            e = ic(a, b, c, d),
            f = qc(y(this.bias, e), this.k1, this.k2),
            g = this.jAcc;
        this.jAcc = M(x(this.jAcc, f), this.jMaxLen), lc(a, b, this.r1, this.r2, this.jAcc.x - g.x, this.jAcc.y - g.y)
    }, vc.prototype.getImpulse = function() {
        return v(this.jAcc)
    };
    var wc = a.GrooveJoint = function(a, b, c, d, e) {
        sc.call(this, a, b), this.grv_a = c, this.grv_b = d, this.grv_n = D(K(y(d, c))), this.anchr2 = e, this.grv_tn = null, this.clamp = 0, this.r1 = this.r2 = null, this.k1 = new r(0, 0), this.k2 = new r(0, 0), this.jAcc = s, this.jMaxLen = 0, this.bias = null
    };
    wc.prototype = Object.create(sc.prototype), wc.prototype.preStep = function(a) {
        var b = this.a,
            c = this.b,
            d = b.local2World(this.grv_a),
            e = b.local2World(this.grv_b),
            f = F(this.grv_n, b.rot),
            g = t(d, f);
        this.grv_tn = f, this.r2 = F(this.anchr2, c.rot);
        var h = B(x(c.p, this.r2), f);
        h <= B(d, f) ? (this.clamp = 1, this.r1 = y(d, b.p)) : h >= B(e, f) ? (this.clamp = -1, this.r1 = y(e, b.p)) : (this.clamp = 0, this.r1 = y(x(A(D(f), -h), A(f, g)), b.p)), pc(b, c, this.r1, this.r2, this.k1, this.k2), this.jMaxLen = this.maxForce * a;
        var i = y(x(c.p, this.r2), x(b.p, this.r1));
        this.bias = M(A(i, -rc(this.errorBias, a) / a), this.maxBias)
    }, wc.prototype.applyCachedImpulse = function(a) {
        lc(this.a, this.b, this.r1, this.r2, this.jAcc.x * a, this.jAcc.y * a)
    }, wc.prototype.grooveConstrain = function(a) {
        var b = this.grv_tn,
            c = this.clamp * B(a, b) > 0 ? a : E(a, b);
        return M(c, this.jMaxLen)
    }, wc.prototype.applyImpulse = function() {
        var a = this.a,
            b = this.b,
            c = this.r1,
            d = this.r2,
            e = ic(a, b, c, d),
            f = qc(y(this.bias, e), this.k1, this.k2),
            g = this.jAcc;
        this.jAcc = this.grooveConstrain(x(g, f)), lc(a, b, this.r1, this.r2, this.jAcc.x - g.x, this.jAcc.y - g.y)
    }, wc.prototype.getImpulse = function() {
        return v(this.jAcc)
    }, wc.prototype.setGrooveA = function(a) {
        this.grv_a = a, this.grv_n = D(K(y(this.grv_b, a))), this.activateBodies()
    }, wc.prototype.setGrooveB = function(a) {
        this.grv_b = a, this.grv_n = D(K(y(a, this.grv_a))), this.activateBodies()
    };
    var xc = function(a, b) {
            return (a.restLength - b) * a.stiffness
        },
        yc = a.DampedSpring = function(a, b, c, d, e, f, g) {
            sc.call(this, a, b), this.anchr1 = c, this.anchr2 = d, this.restLength = e, this.stiffness = f, this.damping = g, this.springForceFunc = xc, this.target_vrn = this.v_coef = 0, this.r1 = this.r2 = null, this.nMass = 0, this.n = null
        };
    yc.prototype = Object.create(sc.prototype), yc.prototype.preStep = function(a) {
        var b = this.a,
            c = this.b;
        this.r1 = F(this.anchr1, b.rot), this.r2 = F(this.anchr2, c.rot);
        var d = y(x(c.p, this.r2), x(b.p, this.r1)),
            f = v(d);
        this.n = A(d, 1 / (f ? f : 1 / 0));
        var g = oc(b, c, this.r1, this.r2, this.n);
        e(0 !== g, "Unsolvable this."), this.nMass = 1 / g, this.target_vrn = 0, this.v_coef = 1 - Math.exp(-this.damping * a * g);
        var h = this.springForceFunc(this, f);
        lc(b, c, this.r1, this.r2, this.n.x * h * a, this.n.y * h * a)
    }, yc.prototype.applyCachedImpulse = function() {}, yc.prototype.applyImpulse = function() {
        var a = this.a,
            b = this.b,
            c = this.n,
            d = this.r1,
            e = this.r2,
            f = jc(a, b, d, e, c),
            g = (this.target_vrn - f) * this.v_coef;
        this.target_vrn = f + g, g *= this.nMass, lc(a, b, this.r1, this.r2, this.n.x * g, this.n.y * g)
    }, yc.prototype.getImpulse = function() {
        return 0
    };
    var zc = function(a, b) {
            return (b - a.restAngle) * a.stiffness
        },
        Ac = a.DampedRotarySpring = function(a, b, c, d, e) {
            sc.call(this, a, b), this.restAngle = c, this.stiffness = d, this.damping = e, this.springTorqueFunc = zc, this.target_wrn = 0, this.w_coef = 0, this.iSum = 0
        };
    Ac.prototype = Object.create(sc.prototype), Ac.prototype.preStep = function(a) {
        var b = this.a,
            c = this.b,
            d = b.i_inv + c.i_inv;
        e(0 !== d, "Unsolvable spring."), this.iSum = 1 / d, this.w_coef = 1 - Math.exp(-this.damping * a * d), this.target_wrn = 0;
        var f = this.springTorqueFunc(this, b.a - c.a) * a;
        b.w -= f * b.i_inv, c.w += f * c.i_inv
    }, Ac.prototype.applyImpulse = function() {
        var a = this.a,
            b = this.b,
            c = a.w - b.w,
            d = (this.target_wrn - c) * this.w_coef;
        this.target_wrn = c + d;
        var e = d * this.iSum;
        a.w += e * a.i_inv, b.w -= e * b.i_inv
    };
    var Bc = a.RotaryLimitJoint = function(a, b, c, d) {
        sc.call(this, a, b), this.min = c, this.max = d, this.jAcc = 0, this.iSum = this.bias = this.jMax = 0
    };
    Bc.prototype = Object.create(sc.prototype), Bc.prototype.preStep = function(a) {
        var b = this.a,
            c = this.b,
            d = c.a - b.a,
            e = 0;
        d > this.max ? e = this.max - d : d < this.min && (e = this.min - d), this.iSum = 1 / (1 / b.i + 1 / c.i);
        var f = this.maxBias;
        this.bias = p(-rc(this.errorBias, a) * e / a, -f, f), this.jMax = this.maxForce * a, this.bias || (this.jAcc = 0)
    }, Bc.prototype.applyCachedImpulse = function(a) {
        var b = this.a,
            c = this.b,
            d = this.jAcc * a;
        b.w -= d * b.i_inv, c.w += d * c.i_inv
    }, Bc.prototype.applyImpulse = function() {
        if (this.bias) {
            var a = this.a,
                b = this.b,
                c = b.w - a.w,
                d = -(this.bias + c) * this.iSum,
                e = this.jAcc;
            this.jAcc = this.bias < 0 ? p(e + d, 0, this.jMax) : p(e + d, -this.jMax, 0), d = this.jAcc - e, a.w -= d * a.i_inv, b.w += d * b.i_inv
        }
    }, Bc.prototype.getImpulse = function() {
        return Math.abs(joint.jAcc)
    };
    var Cc = a.RatchetJoint = function(a, b, c, d) {
        sc.call(this, a, b), this.angle = 0, this.phase = c, this.ratchet = d, this.angle = (b ? b.a : 0) - (a ? a.a : 0), this.iSum = this.bias = this.jAcc = this.jMax = 0
    };
    Cc.prototype = Object.create(sc.prototype), Cc.prototype.preStep = function(a) {
        var b = this.a,
            c = this.b,
            d = this.angle,
            e = this.phase,
            f = this.ratchet,
            g = c.a - b.a,
            h = d - g,
            i = 0;
        h * f > 0 ? i = h : this.angle = Math.floor((g - e) / f) * f + e, this.iSum = 1 / (b.i_inv + c.i_inv);
        var j = this.maxBias;
        this.bias = p(-rc(this.errorBias, a) * i / a, -j, j), this.jMax = this.maxForce * a, this.bias || (this.jAcc = 0)
    }, Cc.prototype.applyCachedImpulse = function(a) {
        var b = this.a,
            c = this.b,
            d = this.jAcc * a;
        b.w -= d * b.i_inv, c.w += d * c.i_inv
    }, Cc.prototype.applyImpulse = function() {
        if (this.bias) {
            var a = this.a,
                b = this.b,
                c = b.w - a.w,
                d = this.ratchet,
                e = -(this.bias + c) * this.iSum,
                f = this.jAcc;
            this.jAcc = p((f + e) * d, 0, this.jMax * Math.abs(d)) / d, e = this.jAcc - f, a.w -= e * a.i_inv, b.w += e * b.i_inv
        }
    }, Cc.prototype.getImpulse = function(a) {
        return Math.abs(a.jAcc)
    };
    var Dc = a.GearJoint = function(a, b, c, d) {
        sc.call(this, a, b), this.phase = c, this.ratio = d, this.ratio_inv = 1 / d, this.jAcc = 0, this.iSum = this.bias = this.jMax = 0
    };
    Dc.prototype = Object.create(sc.prototype), Dc.prototype.preStep = function(a) {
        var b = this.a,
            c = this.b;
        this.iSum = 1 / (b.i_inv * this.ratio_inv + this.ratio * c.i_inv);
        var d = this.maxBias;
        this.bias = p(-rc(this.errorBias, a) * (c.a * this.ratio - b.a - this.phase) / a, -d, d), this.jMax = this.maxForce * a
    }, Dc.prototype.applyCachedImpulse = function(a) {
        var b = this.a,
            c = this.b,
            d = this.jAcc * a;
        b.w -= d * b.i_inv * this.ratio_inv, c.w += d * c.i_inv
    }, Dc.prototype.applyImpulse = function() {
        var a = this.a,
            b = this.b,
            c = b.w * this.ratio - a.w,
            d = (this.bias - c) * this.iSum,
            e = this.jAcc;
        this.jAcc = p(e + d, -this.jMax, this.jMax), d = this.jAcc - e, a.w -= d * a.i_inv * this.ratio_inv, b.w += d * b.i_inv
    }, Dc.prototype.getImpulse = function() {
        return Math.abs(this.jAcc)
    }, Dc.prototype.setRatio = function(a) {
        this.ratio = a, this.ratio_inv = 1 / a, this.activateBodies()
    };
    var Ec = a.SimpleMotor = function(a, b, c) {
        sc.call(this, a, b), this.rate = c, this.jAcc = 0, this.iSum = this.jMax = 0
    };
    Ec.prototype = Object.create(sc.prototype), Ec.prototype.preStep = function(a) {
        this.iSum = 1 / (this.a.i_inv + this.b.i_inv), this.jMax = this.maxForce * a
    }, Ec.prototype.applyCachedImpulse = function(a) {
        var b = this.a,
            c = this.b,
            d = this.jAcc * a;
        b.w -= d * b.i_inv, c.w += d * c.i_inv
    }, Ec.prototype.applyImpulse = function() {
        var a = this.a,
            b = this.b,
            c = b.w - a.w + this.rate,
            d = -c * this.iSum,
            e = this.jAcc;
        this.jAcc = p(e + d, -this.jMax, this.jMax), d = this.jAcc - e, a.w -= d * a.i_inv, b.w += d * b.i_inv
    }, Ec.prototype.getImpulse = function() {
        return Math.abs(this.jAcc)
    }
}();
var sp = sp || {};
sp.VERTEX_INDEX = {
    X1: 0,
    Y1: 1,
    X2: 2,
    Y2: 3,
    X3: 4,
    Y3: 5,
    X4: 6,
    Y4: 7
}, sp.ATTACHMENT_TYPE = {
    REGION: 0,
    BOUNDING_BOX: 1,
    REGION_SEQUENCE: 2
}, sp.Skeleton = cc.Node.extend({
    _skeleton: null,
    _rootBone: null,
    _timeScale: 1,
    _debugSlots: !1,
    _debugBones: !1,
    _premultipliedAlpha: !1,
    _ownsSkeletonData: null,
    _atlas: null,
    _blendFunc: null,
    ctor: function(a, b, c) {
        cc.Node.prototype.ctor.call(this), this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        }, 0 === arguments.length ? this.init() : this.initWithArgs(a, b, c)
    },
    _createRenderCmd: function() {
        return cc._renderType === cc._RENDER_TYPE_CANVAS ? new sp.Skeleton.CanvasRenderCmd(this) : new sp.Skeleton.WebGLRenderCmd(this)
    },
    init: function() {
        cc.Node.prototype.init.call(this), this.setOpacityModifyRGB(!0), this._blendFunc.src = cc.ONE, this._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA, this.scheduleUpdate()
    },
    setDebugSolots: function(a) {
        this._debugSlots = a
    },
    setDebugBones: function(a) {
        this._debugBones = a
    },
    setTimeScale: function(a) {
        this._timeScale = a
    },
    initWithArgs: function(a, b, c) {
        var d, e, f, g = a,
            h = b;
        if (cc.isString(g)) {
            if (cc.isString(h)) {
                var i = cc.loader.getRes(h);
                sp._atlasLoader.setAtlasFile(h), e = new spine.Atlas(i, sp._atlasLoader)
            } else e = b;
            c = c || 1 / cc.director.getContentScaleFactor();
            var j = new spine.AtlasAttachmentLoader(e),
                k = new spine.SkeletonJson(j);
            k.scale = c;
            var l = cc.loader.getRes(g);
            d = k.readSkeletonData(l), e.dispose(k), f = !0
        } else d = a, f = b;
        this.setSkeletonData(d, f), this.init()
    },
    getBoundingBox: function() {
        for (var a = cc.FLT_MAX, b = cc.FLT_MAX, c = cc.FLT_MIN, d = cc.FLT_MIN, e = this.getScaleX(), f = this.getScaleY(), g = [], h = this._skeleton.slots, i = sp.VERTEX_INDEX, j = 0, k = h.length; k > j; ++j) {
            var l = h[j];
            if (l.attachment && l.attachment.type == sp.ATTACHMENT_TYPE.REGION) {
                var m = l.attachment;
                sp._regionAttachment_computeWorldVertices(m, l.skeleton.x, l.skeleton.y, l.bone, g), a = Math.min(a, g[i.X1] * e, g[i.X4] * e, g[i.X2] * e, g[i.X3] * e), b = Math.min(b, g[i.Y1] * f, g[i.Y4] * f, g[i.Y2] * f, g[i.Y3] * f), c = Math.max(c, g[i.X1] * e, g[i.X4] * e, g[i.X2] * e, g[i.X3] * e), d = Math.max(d, g[i.Y1] * f, g[i.Y4] * f, g[i.Y2] * f, g[i.Y3] * f)
            }
        }
        var n = this.getPosition();
        return cc.rect(n.x + a, n.y + b, c - a, d - b)
    },
    updateWorldTransform: function() {
        this._skeleton.updateWorldTransform()
    },
    setToSetupPose: function() {
        this._skeleton.setToSetupPose()
    },
    setBonesToSetupPose: function() {
        this._skeleton.setBonesToSetupPose()
    },
    setSlotsToSetupPose: function() {
        this._skeleton.setSlotsToSetupPose()
    },
    findBone: function(a) {
        return this._skeleton.findBone(a)
    },
    findSlot: function(a) {
        return this._skeleton.findSlot(a)
    },
    setSkin: function(a) {
        return this._skeleton.setSkinByName(a)
    },
    getAttachment: function(a, b) {
        return this._skeleton.getAttachmentBySlotName(a, b)
    },
    setAttachment: function(a, b) {
        this._skeleton.setAttachment(a, b)
    },
    setOpacityModifyRGB: function(a) {
        this._premultipliedAlpha = a
    },
    isOpacityModifyRGB: function() {
        return this._premultipliedAlpha
    },
    setSkeletonData: function(a, b) {
        this._skeleton = new spine.Skeleton(a), this._rootBone = this._skeleton.getRootBone(), this._ownsSkeletonData = b, this._renderCmd._createChildFormSkeletonData()
    },
    getTextureAtlas: function(a) {
        return a.rendererObject.page.rendererObject
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    setBlendFunc: function(a, b) {
        var c = this._blendFunc;
        void 0 === b ? (c.src = a.src, c.dst = a.dst) : (c.src = a, c.dst = b)
    },
    update: function(a) {
        this._skeleton.update(a), this._renderCmd._updateChild()
    }
}), sp.Skeleton.create = function(a, b, c) {
    return new sp.Skeleton(a, b, c)
};
var spine = spine || {};
spine.BoneData = function(a, b) {
        this.name = a, this.parent = b
    }, spine.BoneData.prototype = {
        length: 0,
        x: 0,
        y: 0,
        rotation: 0,
        scaleX: 1,
        scaleY: 1,
        inheritScale: !0,
        inheritRotation: !0
    }, spine.SlotData = function(a, b) {
        this.name = a, this.boneData = b, this.r = this.g = this.b = this.a = 1
    }, spine.SlotData.prototype = {
        r: 1,
        g: 1,
        b: 1,
        a: 1,
        attachmentName: null,
        additiveBlending: !1
    }, spine.Bone = function(a, b) {
        this.data = a, this.parent = b, this.setToSetupPose()
    }, spine.Bone.yDown = !1, spine.Bone.prototype = {
        x: 0,
        y: 0,
        rotation: 0,
        scaleX: 1,
        scaleY: 1,
        m00: 0,
        m01: 0,
        worldX: 0,
        m10: 0,
        m11: 0,
        worldY: 0,
        worldRotation: 0,
        worldScaleX: 1,
        worldScaleY: 1,
        updateWorldTransform: function(a, b) {
            var c = this.parent;
            null != c ? (this.worldX = this.x * c.m00 + this.y * c.m01 + c.worldX, this.worldY = this.x * c.m10 + this.y * c.m11 + c.worldY, this.data.inheritScale ? (this.worldScaleX = c.worldScaleX * this.scaleX, this.worldScaleY = c.worldScaleY * this.scaleY) : (this.worldScaleX = this.scaleX, this.worldScaleY = this.scaleY), this.worldRotation = this.data.inheritRotation ? c.worldRotation + this.rotation : this.rotation) : (this.worldX = a ? -this.x : this.x, this.worldY = b != spine.Bone.yDown ? -this.y : this.y, this.worldScaleX = this.scaleX, this.worldScaleY = this.scaleY, this.worldRotation = this.rotation);
            var d = this.worldRotation * Math.PI / 180,
                e = Math.cos(d),
                f = Math.sin(d);
            this.m00 = e * this.worldScaleX, this.m10 = f * this.worldScaleX, this.m01 = -f * this.worldScaleY, this.m11 = e * this.worldScaleY, a && (this.m00 = -this.m00, this.m01 = -this.m01), b != spine.Bone.yDown && (this.m10 = -this.m10, this.m11 = -this.m11)
        },
        setToSetupPose: function() {
            var a = this.data;
            this.x = a.x, this.y = a.y, this.rotation = a.rotation, this.scaleX = a.scaleX, this.scaleY = a.scaleY
        }
    }, spine.Slot = function(a, b, c) {
        this.data = a, this.skeleton = b, this.bone = c, this.setToSetupPose()
    }, spine.Slot.prototype = {
        r: 1,
        g: 1,
        b: 1,
        a: 1,
        _attachmentTime: 0,
        attachment: null,
        setAttachment: function(a) {
            this.attachment = a, this._attachmentTime = this.skeleton.time
        },
        setAttachmentTime: function(a) {
            this._attachmentTime = this.skeleton.time - a
        },
        getAttachmentTime: function() {
            return this.skeleton.time - this._attachmentTime
        },
        setToSetupPose: function() {
            var a = this.data;
            this.r = a.r, this.g = a.g, this.b = a.b, this.a = a.a;
            for (var b = this.skeleton.data.slots, c = 0, d = b.length; d > c; c++)
                if (b[c] == a) {
                    this.setAttachment(a.attachmentName ? this.skeleton.getAttachmentBySlotIndex(c, a.attachmentName) : null);
                    break
                }
        }
    }, spine.Skin = function(a) {
        this.name = a, this.attachments = {}
    }, spine.Skin.prototype = {
        addAttachment: function(a, b, c) {
            this.attachments[a + ":" + b] = c
        },
        getAttachment: function(a, b) {
            return this.attachments[a + ":" + b]
        },
        _attachAll: function(a, b) {
            console.log(b.attachments);
            for (var c in b.attachments) {
                var d = c.indexOf(":"),
                    e = parseInt(c.substring(0, d)),
                    f = c.substring(d + 1),
                    g = a.slots[e];
                if (g.attachment && g.attachment.name == f) {
                    var h = this.getAttachment(e, f);
                    h && g.setAttachment(h)
                }
            }
        }
    }, spine.Animation = function(a, b, c) {
        this.name = a, this.timelines = b, this.duration = c
    }, spine.Animation.prototype = {
        apply: function(a, b, c, d, e) {
            d && 0 != this.duration && (c %= this.duration, b %= this.duration);
            for (var f = this.timelines, g = 0, h = f.length; h > g; g++) f[g].apply(a, b, c, e, 1)
        },
        mix: function(a, b, c, d, e, f) {
            d && 0 != this.duration && (c %= this.duration, b %= this.duration);
            for (var g = this.timelines, h = 0, i = g.length; i > h; h++) g[h].apply(a, b, c, e, f)
        }
    }, spine.binarySearch = function(a, b, c) {
        var d = 0,
            e = Math.floor(a.length / c) - 2;
        if (0 == e) return c;
        for (var f = e >>> 1;;) {
            if (a[(f + 1) * c] <= b ? d = f + 1 : e = f, d == e) return (d + 1) * c;
            f = d + e >>> 1
        }
    }, spine.linearSearch = function(a, b, c) {
        for (var d = 0, e = a.length - c; e >= d; d += c)
            if (a[d] > b) return d;
        return -1
    }, spine.Curves = function(a) {
        this.curves = [], this.curves.length = 6 * (a - 1)
    }, spine.Curves.prototype = {
        setLinear: function(a) {
            this.curves[6 * a] = 0
        },
        setStepped: function(a) {
            this.curves[6 * a] = -1
        },
        setCurve: function(a, b, c, d, e) {
            var f = .1,
                g = f * f,
                h = g * f,
                i = 3 * f,
                j = 3 * g,
                k = 6 * g,
                l = 6 * h,
                m = 2 * -b + d,
                n = 2 * -c + e,
                o = 3 * (b - d) + 1,
                p = 3 * (c - e) + 1,
                q = 6 * a,
                r = this.curves;
            r[q] = b * i + m * j + o * h, r[q + 1] = c * i + n * j + p * h, r[q + 2] = m * k + o * l, r[q + 3] = n * k + p * l, r[q + 4] = o * l, r[q + 5] = p * l
        },
        getCurvePercent: function(a, b) {
            b = 0 > b ? 0 : b > 1 ? 1 : b;
            var c = 6 * a,
                d = this.curves,
                e = d[c];
            if (!e) return b;
            if (-1 == e) return 0;
            for (var f = d[c + 1], g = d[c + 2], h = d[c + 3], i = d[c + 4], j = d[c + 5], k = e, l = f, m = 8;;) {
                if (k >= b) {
                    var n = k - e,
                        o = l - f;
                    return o + (l - o) * (b - n) / (k - n)
                }
                if (0 == m) break;
                m--, e += g, f += h, g += i, h += j, k += e, l += f
            }
            return l + (1 - l) * (b - k) / (1 - k)
        }
    }, spine.RotateTimeline = function(a) {
        this.curves = new spine.Curves(a), this.frames = [], this.frames.length = 2 * a
    }, spine.RotateTimeline.prototype = {
        boneIndex: 0,
        getFrameCount: function() {
            return this.frames.length / 2
        },
        setFrame: function(a, b, c) {
            a *= 2, this.frames[a] = b, this.frames[a + 1] = c
        },
        apply: function(a, b, c, d, e) {
            var f = this.frames;
            if (!(c < f[0])) {
                var g = a.bones[this.boneIndex];
                if (c >= f[f.length - 2]) {
                    for (var h = g.data.rotation + f[f.length - 1] - g.rotation; h > 180;) h -= 360;
                    for (; - 180 > h;) h += 360;
                    return void(g.rotation += h * e)
                }
                var i = spine.binarySearch(f, c, 2),
                    j = f[i - 1],
                    k = f[i],
                    l = 1 - (c - k) / (f[i - 2] - k);
                l = this.curves.getCurvePercent(i / 2 - 1, l);
                for (var h = f[i + 1] - j; h > 180;) h -= 360;
                for (; - 180 > h;) h += 360;
                for (h = g.data.rotation + (j + h * l) - g.rotation; h > 180;) h -= 360;
                for (; - 180 > h;) h += 360;
                g.rotation += h * e
            }
        }
    }, spine.TranslateTimeline = function(a) {
        this.curves = new spine.Curves(a), this.frames = [], this.frames.length = 3 * a
    }, spine.TranslateTimeline.prototype = {
        boneIndex: 0,
        getFrameCount: function() {
            return this.frames.length / 3
        },
        setFrame: function(a, b, c, d) {
            a *= 3, this.frames[a] = b, this.frames[a + 1] = c, this.frames[a + 2] = d
        },
        apply: function(a, b, c, d, e) {
            var f = this.frames;
            if (!(c < f[0])) {
                var g = a.bones[this.boneIndex];
                if (c >= f[f.length - 3]) return g.x += (g.data.x + f[f.length - 2] - g.x) * e, void(g.y += (g.data.y + f[f.length - 1] - g.y) * e);
                var h = spine.binarySearch(f, c, 3),
                    i = f[h - 2],
                    j = f[h - 1],
                    k = f[h],
                    l = 1 - (c - k) / (f[h + -3] - k);
                l = this.curves.getCurvePercent(h / 3 - 1, l), g.x += (g.data.x + i + (f[h + 1] - i) * l - g.x) * e, g.y += (g.data.y + j + (f[h + 2] - j) * l - g.y) * e
            }
        }
    }, spine.ScaleTimeline = function(a) {
        this.curves = new spine.Curves(a), this.frames = [], this.frames.length = 3 * a
    }, spine.ScaleTimeline.prototype = {
        boneIndex: 0,
        getFrameCount: function() {
            return this.frames.length / 3
        },
        setFrame: function(a, b, c, d) {
            a *= 3, this.frames[a] = b, this.frames[a + 1] = c, this.frames[a + 2] = d
        },
        apply: function(a, b, c, d, e) {
            var f = this.frames;
            if (!(c < f[0])) {
                var g = a.bones[this.boneIndex];
                if (c >= f[f.length - 3]) return g.scaleX += (g.data.scaleX - 1 + f[f.length - 2] - g.scaleX) * e, void(g.scaleY += (g.data.scaleY - 1 + f[f.length - 1] - g.scaleY) * e);
                var h = spine.binarySearch(f, c, 3),
                    i = f[h - 2],
                    j = f[h - 1],
                    k = f[h],
                    l = 1 - (c - k) / (f[h + -3] - k);
                l = this.curves.getCurvePercent(h / 3 - 1, l), g.scaleX += (g.data.scaleX - 1 + i + (f[h + 1] - i) * l - g.scaleX) * e, g.scaleY += (g.data.scaleY - 1 + j + (f[h + 2] - j) * l - g.scaleY) * e
            }
        }
    }, spine.ColorTimeline = function(a) {
        this.curves = new spine.Curves(a), this.frames = [], this.frames.length = 5 * a
    }, spine.ColorTimeline.prototype = {
        slotIndex: 0,
        getFrameCount: function() {
            return this.frames.length / 5
        },
        setFrame: function(a, b, c, d, e, f) {
            a *= 5, this.frames[a] = b, this.frames[a + 1] = c, this.frames[a + 2] = d, this.frames[a + 3] = e, this.frames[a + 4] = f
        },
        apply: function(a, b, c, d, e) {
            var f = this.frames;
            if (!(c < f[0])) {
                var g = a.slots[this.slotIndex];
                if (c >= f[f.length - 5]) {
                    var h = f.length - 1;
                    return g.r = f[h - 3], g.g = f[h - 2], g.b = f[h - 1], void(g.a = f[h])
                }
                var i = spine.binarySearch(f, c, 5),
                    j = f[i - 4],
                    k = f[i - 3],
                    l = f[i - 2],
                    m = f[i - 1],
                    n = f[i],
                    o = 1 - (c - n) / (f[i - 5] - n);
                o = this.curves.getCurvePercent(i / 5 - 1, o);
                var p = j + (f[i + 1] - j) * o,
                    q = k + (f[i + 2] - k) * o,
                    r = l + (f[i + 3] - l) * o,
                    s = m + (f[i + 4] - m) * o;
                1 > e ? (g.r += (p - g.r) * e, g.g += (q - g.g) * e, g.b += (r - g.b) * e, g.a += (s - g.a) * e) : (g.r = p, g.g = q, g.b = r, g.a = s)
            }
        }
    }, spine.AttachmentTimeline = function(a) {
        this.curves = new spine.Curves(a), this.frames = [], this.frames.length = a, this.attachmentNames = [], this.attachmentNames.length = a
    }, spine.AttachmentTimeline.prototype = {
        slotIndex: 0,
        getFrameCount: function() {
            return this.frames.length
        },
        setFrame: function(a, b, c) {
            this.frames[a] = b, this.attachmentNames[a] = c
        },
        apply: function(a, b, c) {
            var d = this.frames;
            if (!(c < d[0])) {
                var e;
                e = c >= d[d.length - 1] ? d.length - 1 : spine.binarySearch(d, c, 1) - 1;
                var f = this.attachmentNames[e];
                a.slots[this.slotIndex].setAttachment(f ? a.getAttachmentBySlotIndex(this.slotIndex, f) : null)
            }
        }
    }, spine.EventTimeline = function(a) {
        this.frames = [], this.frames.length = a, this.events = [], this.events.length = a
    }, spine.EventTimeline.prototype = {
        getFrameCount: function() {
            return this.frames.length
        },
        setFrame: function(a, b, c) {
            this.frames[a] = b, this.events[a] = c
        },
        apply: function(a, b, c, d, e) {
            if (d) {
                var f = this.frames,
                    g = f.length;
                if (b > c) this.apply(a, b, Number.MAX_VALUE, d, e), b = -1;
                else if (b >= f[g - 1]) return;
                if (!(c < f[0])) {
                    var h;
                    if (b < f[0]) h = 0;
                    else {
                        h = spine.binarySearch(f, b, 1);
                        for (var i = f[h]; h > 0 && f[h - 1] == i;) h--
                    }
                    for (var j = this.events; g > h && c >= f[h]; h++) d.push(j[h])
                }
            }
        }
    }, spine.DrawOrderTimeline = function(a) {
        this.frames = [], this.frames.length = a, this.drawOrders = [], this.drawOrders.length = a
    }, spine.DrawOrderTimeline.prototype = {
        getFrameCount: function() {
            return this.frames.length
        },
        setFrame: function(a, b, c) {
            this.frames[a] = b, this.drawOrders[a] = c
        },
        apply: function(a, b, c) {
            var d = this.frames;
            if (!(c < d[0])) {
                var e;
                e = c >= d[d.length - 1] ? d.length - 1 : spine.binarySearch(d, c, 1) - 1;
                var f = a.drawOrder,
                    g = a.slots,
                    h = this.drawOrders[e];
                if (h)
                    for (var i = 0, j = h.length; j > i; i++) f[i] = a.slots[h[i]];
                else
                    for (var i = 0, j = g.length; j > i; i++) f[i] = g[i]
            }
        }
    }, spine.SkeletonData = function() {
        this.bones = [], this.slots = [], this.skins = [], this.events = [], this.animations = []
    }, spine.SkeletonData.prototype = {
        defaultSkin: null,
        findBone: function(a) {
            for (var b = this.bones, c = 0, d = b.length; d > c; c++)
                if (b[c].name == a) return b[c];
            return null
        },
        findBoneIndex: function(a) {
            for (var b = this.bones, c = 0, d = b.length; d > c; c++)
                if (b[c].name == a) return c;
            return -1
        },
        findSlot: function(a) {
            for (var b = this.slots, c = 0, d = b.length; d > c; c++)
                if (b[c].name == a) return b[c];
            return null
        },
        findSlotIndex: function(a) {
            for (var b = this.slots, c = 0, d = b.length; d > c; c++)
                if (b[c].name == a) return c;
            return -1
        },
        findSkin: function(a) {
            for (var b = this.skins, c = 0, d = b.length; d > c; c++)
                if (b[c].name == a) return b[c];
            return null
        },
        findEvent: function(a) {
            for (var b = this.events, c = 0, d = b.length; d > c; c++)
                if (b[c].name == a) return b[c];
            return null
        },
        findAnimation: function(a) {
            for (var b = this.animations, c = 0, d = b.length; d > c; c++)
                if (b[c].name == a) return b[c];
            return null
        }
    }, spine.Skeleton = function(a) {
        this.data = a, this.bones = [];
        for (var b = 0, c = a.bones.length; c > b; b++) {
            var d = a.bones[b],
                e = d.parent ? this.bones[a.bones.indexOf(d.parent)] : null;
            this.bones.push(new spine.Bone(d, e))
        }
        this.slots = [], this.drawOrder = [];
        for (var b = 0, c = a.slots.length; c > b; b++) {
            var f = a.slots[b],
                g = this.bones[a.bones.indexOf(f.boneData)],
                h = new spine.Slot(f, this, g);
            this.slots.push(h), this.drawOrder.push(h)
        }
    }, spine.Skeleton.prototype = {
        x: 0,
        y: 0,
        skin: null,
        r: 1,
        g: 1,
        b: 1,
        a: 1,
        time: 0,
        flipX: !1,
        flipY: !1,
        updateWorldTransform: function() {
            for (var a = this.flipX, b = this.flipY, c = this.bones, d = 0, e = c.length; e > d; d++) c[d].updateWorldTransform(a, b)
        },
        setToSetupPose: function() {
            this.setBonesToSetupPose(), this.setSlotsToSetupPose()
        },
        setBonesToSetupPose: function() {
            for (var a = this.bones, b = 0, c = a.length; c > b; b++) a[b].setToSetupPose()
        },
        setSlotsToSetupPose: function() {
            for (var a = this.slots, b = 0, c = a.length; c > b; b++) a[b].setToSetupPose(b)
        },
        getRootBone: function() {
            return 0 == this.bones.length ? null : this.bones[0]
        },
        findBone: function(a) {
            for (var b = this.bones, c = 0, d = b.length; d > c; c++)
                if (b[c].data.name == a) return b[c];
            return null
        },
        findBoneIndex: function(a) {
            for (var b = this.bones, c = 0, d = b.length; d > c; c++)
                if (b[c].data.name == a) return c;
            return -1
        },
        findSlot: function(a) {
            for (var b = this.slots, c = 0, d = b.length; d > c; c++)
                if (b[c].data.name == a) return b[c];
            return null
        },
        findSlotIndex: function(a) {
            for (var b = this.slots, c = 0, d = b.length; d > c; c++)
                if (b[c].data.name == a) return c;
            return -1
        },
        setSkinByName: function(a) {
            var b = this.data.findSkin(a);
            if (!b) throw "Skin not found: " + a;
            this.setSkin(b)
        },
        setSkin: function(a) {
            this.skin && a && a._attachAll(this, this.skin), this.skin = a
        },
        getAttachmentBySlotName: function(a, b) {
            return this.getAttachmentBySlotIndex(this.data.findSlotIndex(a), b)
        },
        getAttachmentBySlotIndex: function(a, b) {
            if (this.skin) {
                var c = this.skin.getAttachment(a, b);
                if (c) return c
            }
            return this.data.defaultSkin ? this.data.defaultSkin.getAttachment(a, b) : null
        },
        setAttachment: function(a, b) {
            for (var c = this.slots, d = 0, e = c.length; e > d; d++) {
                var f = c[d];
                if (f.data.name == a) {
                    var g = null;
                    if (b && (g = this.getAttachment(d, b), !g)) throw "Attachment not found: " + b + ", for slot: " + a;
                    return void f.setAttachment(g)
                }
            }
            throw "Slot not found: " + a
        },
        update: function(a) {
            this.time += a
        }
    }, spine.EventData = function(a) {
        this.name = a
    }, spine.EventData.prototype = {
        intValue: 0,
        floatValue: 0,
        stringValue: null
    }, spine.Event = function(a) {
        this.data = a
    }, spine.Event.prototype = {
        intValue: 0,
        floatValue: 0,
        stringValue: null
    }, spine.AttachmentType = {
        region: 0,
        boundingbox: 1
    }, spine.RegionAttachment = function(a) {
        this.name = a, this.offset = [], this.offset.length = 8, this.uvs = [], this.uvs.length = 8, this.type = spine.AttachmentType.region
    }, spine.RegionAttachment.prototype = {
        type: spine.AttachmentType.region,
        x: 0,
        y: 0,
        rotation: 0,
        scaleX: 1,
        scaleY: 1,
        width: 0,
        height: 0,
        rendererObject: null,
        regionOffsetX: 0,
        regionOffsetY: 0,
        regionWidth: 0,
        regionHeight: 0,
        regionOriginalWidth: 0,
        regionOriginalHeight: 0,
        setUVs: function(a, b, c, d, e) {
            var f = this.uvs;
            e ? (f[2] = a, f[3] = d, f[4] = a, f[5] = b, f[6] = c, f[7] = b, f[0] = c, f[1] = d) : (f[0] = a, f[1] = d, f[2] = a, f[3] = b, f[4] = c, f[5] = b, f[6] = c, f[7] = d)
        },
        updateOffset: function() {
            var a = this.width / this.regionOriginalWidth * this.scaleX,
                b = this.height / this.regionOriginalHeight * this.scaleY,
                c = -this.width / 2 * this.scaleX + this.regionOffsetX * a,
                d = -this.height / 2 * this.scaleY + this.regionOffsetY * b,
                e = c + this.regionWidth * a,
                f = d + this.regionHeight * b,
                g = this.rotation * Math.PI / 180,
                h = Math.cos(g),
                i = Math.sin(g),
                j = c * h + this.x,
                k = c * i,
                l = d * h + this.y,
                m = d * i,
                n = e * h + this.x,
                o = e * i,
                p = f * h + this.y,
                q = f * i,
                r = this.offset;
            r[0] = j - m, r[1] = l + k, r[2] = j - q, r[3] = p + k, r[4] = n - q, r[5] = p + o, r[6] = n - m, r[7] = l + o
        },
        computeVertices: function(a, b, c, d) {
            a += c.worldX, b += c.worldY;
            var e = c.m00,
                f = c.m01,
                g = c.m10,
                h = c.m11,
                i = this.offset;
            d[0] = i[0] * e + i[1] * f + a, d[1] = i[0] * g + i[1] * h + b, d[2] = i[2] * e + i[3] * f + a, d[3] = i[2] * g + i[3] * h + b, d[4] = i[4] * e + i[5] * f + a, d[5] = i[4] * g + i[5] * h + b, d[6] = i[6] * e + i[7] * f + a, d[7] = i[6] * g + i[7] * h + b
        }
    }, spine.BoundingBoxAttachment = function(a) {
        this.name = a, this.vertices = [], this.type = spine.AttachmentType.boundingBox
    }, spine.BoundingBoxAttachment.prototype = {
        type: spine.AttachmentType.boundingBox,
        computeWorldVertices: function(a, b, c, d) {
            a += c.worldX, b += c.worldY;
            for (var e = c.m00, f = c.m01, g = c.m10, h = c.m11, i = this.vertices, j = 0, k = i.length; k > j; j += 2) {
                var l = i[j],
                    m = i[j + 1];
                d[j] = l * e + m * f + a, d[j + 1] = l * g + m * h + b
            }
        }
    }, spine.AnimationStateData = function(a) {
        this.skeletonData = a, this.animationToMixTime = {}
    }, spine.AnimationStateData.prototype = {
        defaultMix: 0,
        setMixByName: function(a, b, c) {
            var d = this.skeletonData.findAnimation(a);
            if (!d) throw "Animation not found: " + a;
            var e = this.skeletonData.findAnimation(b);
            if (!e) throw "Animation not found: " + b;
            this.setMix(d, e, c)
        },
        setMix: function(a, b, c) {
            this.animationToMixTime[a.name + ":" + b.name] = c
        },
        getMix: function(a, b) {
            var c = this.animationToMixTime[a.name + ":" + b.name];
            return c ? c : this.defaultMix
        }
    }, spine.TrackEntry = function() {}, spine.TrackEntry.prototype = {
        next: null,
        previous: null,
        animation: null,
        loop: !1,
        delay: 0,
        time: 0,
        lastTime: -1,
        endTime: 0,
        timeScale: 1,
        mixTime: 0,
        mixDuration: 0,
        onStart: null,
        onEnd: null,
        onComplete: null,
        onEvent: null
    }, spine.AnimationState = function(a) {
        this.data = a, this.tracks = [], this.events = []
    }, spine.AnimationState.prototype = {
        onStart: null,
        onEnd: null,
        onComplete: null,
        onEvent: null,
        timeScale: 1,
        update: function(a) {
            a *= this.timeScale;
            for (var b = 0; b < this.tracks.length; b++) {
                var c = this.tracks[b];
                if (c) {
                    var d = a * c.timeScale;
                    c.time += d, c.previous && (c.previous.time += d, c.mixTime += d);
                    var e = c.next;
                    e ? c.lastTime >= e.delay && this.setCurrent(b, e) : !c.loop && c.lastTime >= c.endTime && this.clearTrack(b)
                }
            }
        },
        apply: function(a) {
            for (var b = 0; b < this.tracks.length; b++) {
                var c = this.tracks[b];
                if (c) {
                    this.events.length = 0;
                    var d = c.time,
                        e = c.lastTime,
                        f = c.endTime,
                        g = c.loop;
                    !g && d > f && (d = f);
                    var h = c.previous;
                    if (h) {
                        var i = h.time;
                        !h.loop && i > h.endTime && (i = h.endTime), h.animation.apply(a, i, i, h.loop, null);
                        var j = c.mixTime / c.mixDuration;
                        j >= 1 && (j = 1, c.previous = null), c.animation.mix(a, c.lastTime, d, g, this.events, j)
                    } else c.animation.apply(a, c.lastTime, d, g, this.events);
                    for (var k = 0, l = this.events.length; l > k; k++) {
                        var m = this.events[k];
                        null != c.onEvent && c.onEvent(b, m), null != this.onEvent && this.onEvent(b, m)
                    }
                    if (g ? e % f > d % f : f > e && d >= f) {
                        var n = Math.floor(d / f);
                        c.onComplete && c.onComplete(b, n), this.onComplete && this.onComplete(b, n)
                    }
                    c.lastTime = c.time
                }
            }
        },
        clearTracks: function() {
            for (var a = 0, b = this.tracks.length; b > a; a++) this.clearTrack(a);
            this.tracks.length = 0
        },
        clearTrack: function(a) {
            if (!(a >= this.tracks.length)) {
                var b = this.tracks[a];
                b && (null != b.onEnd && b.onEnd(a), null != this.onEnd && this.onEnd(a), this.tracks[a] = null)
            }
        },
        _expandToIndex: function(a) {
            if (a < this.tracks.length) return this.tracks[a];
            for (; a >= this.tracks.length;) this.tracks.push(null);
            return null
        },
        setCurrent: function(a, b) {
            var c = this._expandToIndex(a);
            if (c) {
                var d = c.previous;
                c.previous = null, null != c.onEnd && c.onEnd(a), null != this.onEnd && this.onEnd(a), b.mixDuration = this.data.getMix(c.animation, b.animation), b.mixDuration > 0 && (b.mixTime = 0, b.previous = d && c.mixTime / c.mixDuration < .5 ? d : c)
            }
            this.tracks[a] = b, null != b.onStart && b.onStart(a), null != this.onStart && this.onStart(a)
        },
        setAnimationByName: function(a, b, c) {
            var d = this.data.skeletonData.findAnimation(b);
            if (!d) throw "Animation not found: " + b;
            return this.setAnimation(a, d, c)
        },
        setAnimation: function(a, b, c) {
            var d = new spine.TrackEntry;
            return d.animation = b, d.loop = c, d.endTime = b.duration, this.setCurrent(a, d), d
        },
        addAnimationByName: function(a, b, c, d) {
            var e = this.data.skeletonData.findAnimation(b);
            if (!e) throw "Animation not found: " + b;
            return this.addAnimation(a, e, c, d)
        },
        addAnimation: function(a, b, c, d) {
            var e = new spine.TrackEntry;
            e.animation = b, e.loop = c, e.endTime = b.duration;
            var f = this._expandToIndex(a);
            if (f) {
                for (; f.next;) f = f.next;
                f.next = e
            } else this.tracks[a] = e;
            return 0 >= d && (f ? d += f.endTime - this.data.getMix(f.animation, b) : d = 0), e.delay = d, e
        },
        getCurrent: function(a) {
            return a >= this.tracks.length ? null : this.tracks[a]
        }
    }, spine.SkeletonJson = function(a) {
        this.attachmentLoader = a
    }, spine.SkeletonJson.prototype = {
        scale: 1,
        readSkeletonData: function(a) {
            for (var b = new spine.SkeletonData, c = a.bones, d = 0, e = c.length; e > d; d++) {
                var f = c[d],
                    g = null;
                if (f.parent && (g = b.findBone(f.parent), !g)) throw "Parent bone not found: " + f.parent;
                var h = new spine.BoneData(f.name, g);
                h.length = (f.length || 0) * this.scale, h.x = (f.x || 0) * this.scale, h.y = (f.y || 0) * this.scale, h.rotation = f.rotation || 0, h.scaleX = f.scaleX || 1, h.scaleY = f.scaleY || 1, h.inheritScale = !f.inheritScale || "true" == f.inheritScale, h.inheritRotation = !f.inheritRotation || "true" == f.inheritRotation, b.bones.push(h)
            }
            for (var i = a.slots, d = 0, e = i.length; e > d; d++) {
                var j = i[d],
                    h = b.findBone(j.bone);
                if (!h) throw "Slot bone not found: " + j.bone;
                var k = new spine.SlotData(j.name, h),
                    l = j.color;
                l && (k.r = spine.SkeletonJson.toColor(l, 0), k.g = spine.SkeletonJson.toColor(l, 1), k.b = spine.SkeletonJson.toColor(l, 2), k.a = spine.SkeletonJson.toColor(l, 3)), k.attachmentName = j.attachment, k.additiveBlending = j.additive && "true" == j.additive, b.slots.push(k)
            }
            var m = a.skins;
            for (var n in m)
                if (m.hasOwnProperty(n)) {
                    var o = m[n],
                        p = new spine.Skin(n);
                    for (var q in o)
                        if (o.hasOwnProperty(q)) {
                            var r = b.findSlotIndex(q),
                                s = o[q];
                            for (var t in s)
                                if (s.hasOwnProperty(t)) {
                                    var u = this.readAttachment(p, t, s[t]);
                                    null != u && p.addAttachment(r, t, u)
                                }
                        }
                    b.skins.push(p), "default" == p.name && (b.defaultSkin = p)
                }
            var v = a.events;
            for (var w in v)
                if (v.hasOwnProperty(w)) {
                    var x = v[w],
                        y = new spine.EventData(w);
                    y.intValue = x["int"] || 0, y.floatValue = x["float"] || 0, y.stringValue = x.string || null, b.events.push(y)
                }
            var z = a.animations;
            for (var A in z) z.hasOwnProperty(A) && this.readAnimation(A, z[A], b);
            return b
        },
        readAttachment: function(a, b, c) {
            b = c.name || b;
            var d = spine.AttachmentType[c.type || "region"],
                e = this.attachmentLoader.newAttachment(a, d, b);
            if (d == spine.AttachmentType.region) e.x = (c.x || 0) * this.scale, e.y = (c.y || 0) * this.scale, e.scaleX = c.scaleX || 1, e.scaleY = c.scaleY || 1, e.rotation = c.rotation || 0, e.width = (c.width || 32) * this.scale, e.height = (c.height || 32) * this.scale, e.updateOffset();
            else if (d == spine.AttachmentType.boundingBox)
                for (var f = c.vertices, g = 0, h = f.length; h > g; g++) e.vertices.push(f[g] * this.scale);
            return e
        },
        readAnimation: function(a, b, c) {
            var d = [],
                e = 0,
                f = b.bones;
            for (var g in f)
                if (f.hasOwnProperty(g)) {
                    var h = c.findBoneIndex(g);
                    if (-1 == h) throw "Bone not found: " + g;
                    var i = f[g];
                    for (var j in i)
                        if (i.hasOwnProperty(j)) {
                            var k = i[j];
                            if ("rotate" == j) {
                                var l = new spine.RotateTimeline(k.length);
                                l.boneIndex = h;
                                for (var m = 0, n = 0, o = k.length; o > n; n++) {
                                    var p = k[n];
                                    l.setFrame(m, p.time, p.angle), spine.SkeletonJson.readCurve(l, m, p), m++
                                }
                                d.push(l), e = Math.max(e, l.frames[2 * l.getFrameCount() - 2])
                            } else {
                                if ("translate" != j && "scale" != j) throw "Invalid timeline type for a bone: " + j + " (" + g + ")";
                                var l, q = 1;
                                "scale" == j ? l = new spine.ScaleTimeline(k.length) : (l = new spine.TranslateTimeline(k.length), q = this.scale), l.boneIndex = h;
                                for (var m = 0, n = 0, o = k.length; o > n; n++) {
                                    var p = k[n],
                                        r = (p.x || 0) * q,
                                        s = (p.y || 0) * q;
                                    l.setFrame(m, p.time, r, s), spine.SkeletonJson.readCurve(l, m, p), m++
                                }
                                d.push(l), e = Math.max(e, l.frames[3 * l.getFrameCount() - 3])
                            }
                        }
                }
            var t = b.slots;
            for (var u in t)
                if (t.hasOwnProperty(u)) {
                    var v = t[u],
                        w = c.findSlotIndex(u);
                    for (var j in v)
                        if (v.hasOwnProperty(j)) {
                            var k = v[j];
                            if ("color" == j) {
                                var l = new spine.ColorTimeline(k.length);
                                l.slotIndex = w;
                                for (var m = 0, n = 0, o = k.length; o > n; n++) {
                                    var p = k[n],
                                        x = p.color,
                                        y = spine.SkeletonJson.toColor(x, 0),
                                        z = spine.SkeletonJson.toColor(x, 1),
                                        A = spine.SkeletonJson.toColor(x, 2),
                                        B = spine.SkeletonJson.toColor(x, 3);
                                    l.setFrame(m, p.time, y, z, A, B), spine.SkeletonJson.readCurve(l, m, p), m++
                                }
                                d.push(l), e = Math.max(e, l.frames[5 * l.getFrameCount() - 5])
                            } else {
                                if ("attachment" != j) throw "Invalid timeline type for a slot: " + j + " (" + u + ")";
                                var l = new spine.AttachmentTimeline(k.length);
                                l.slotIndex = w;
                                for (var m = 0, n = 0, o = k.length; o > n; n++) {
                                    var p = k[n];
                                    l.setFrame(m++, p.time, p.name)
                                }
                                d.push(l), e = Math.max(e, l.frames[l.getFrameCount() - 1])
                            }
                        }
                }
            var C = b.events;
            if (C) {
                for (var l = new spine.EventTimeline(C.length), m = 0, n = 0, o = C.length; o > n; n++) {
                    var D = C[n],
                        E = c.findEvent(D.name);
                    if (!E) throw "Event not found: " + D.name;
                    var F = new spine.Event(E);
                    F.intValue = D.hasOwnProperty("int") ? D["int"] : E.intValue, F.floatValue = D.hasOwnProperty("float") ? D["float"] : E.floatValue, F.stringValue = D.hasOwnProperty("string") ? D.string : E.stringValue, l.setFrame(m++, D.time, F)
                }
                d.push(l), e = Math.max(e, l.frames[l.getFrameCount() - 1])
            }
            var G = b.draworder;
            if (G) {
                for (var l = new spine.DrawOrderTimeline(G.length), H = c.slots.length, m = 0, n = 0, o = G.length; o > n; n++) {
                    var I = G[n],
                        J = null;
                    if (I.offsets) {
                        J = [], J.length = H;
                        for (var K = H - 1; K >= 0; K--) J[K] = -1;
                        var L = I.offsets,
                            M = [];
                        M.length = H - L.length;
                        for (var N = 0, O = 0, K = 0, P = L.length; P > K; K++) {
                            var Q = L[K],
                                w = c.findSlotIndex(Q.slot);
                            if (-1 == w) throw "Slot not found: " + Q.slot;
                            for (; N != w;) M[O++] = N++;
                            J[N + Q.offset] = N++
                        }
                        for (; H > N;) M[O++] = N++;
                        for (var K = H - 1; K >= 0; K--) - 1 == J[K] && (J[K] = M[--O])
                    }
                    l.setFrame(m++, I.time, J)
                }
                d.push(l), e = Math.max(e, l.frames[l.getFrameCount() - 1])
            }
            c.animations.push(new spine.Animation(a, d, e))
        }
    }, spine.SkeletonJson.readCurve = function(a, b, c) {
        var d = c.curve;
        d && ("stepped" == d ? a.curves.setStepped(b) : d instanceof Array && a.curves.setCurve(b, d[0], d[1], d[2], d[3]))
    }, spine.SkeletonJson.toColor = function(a, b) {
        if (8 != a.length) throw "Color hexidecimal length must be 8, recieved: " + a;
        return parseInt(a.substring(2 * b, 2 * b + 2), 16) / 255
    }, spine.Atlas = function(a, b) {
        this.textureLoader = b, this.pages = [], this.regions = [];
        var c = new spine.AtlasReader(a),
            d = [];
        d.length = 4;
        for (var e = null;;) {
            var f = c.readLine();
            if (null == f) break;
            if (f = c.trim(f), 0 == f.length) e = null;
            else if (e) {
                var g = new spine.AtlasRegion;
                g.name = f, g.page = e, g.rotate = "true" == c.readValue(), c.readTuple(d);
                var h = parseInt(d[0]),
                    i = parseInt(d[1]);
                c.readTuple(d);
                var j = parseInt(d[0]),
                    k = parseInt(d[1]);
                g.u = h / e.width, g.v = i / e.height, g.rotate ? (g.u2 = (h + k) / e.width, g.v2 = (i + j) / e.height) : (g.u2 = (h + j) / e.width, g.v2 = (i + k) / e.height), g.x = h, g.y = i, g.width = Math.abs(j), g.height = Math.abs(k), 4 == c.readTuple(d) && (g.splits = [parseInt(d[0]), parseInt(d[1]), parseInt(d[2]), parseInt(d[3])], 4 == c.readTuple(d) && (g.pads = [parseInt(d[0]), parseInt(d[1]), parseInt(d[2]), parseInt(d[3])], c.readTuple(d))), g.originalWidth = parseInt(d[0]), g.originalHeight = parseInt(d[1]), c.readTuple(d), g.offsetX = parseInt(d[0]), g.offsetY = parseInt(d[1]), g.index = parseInt(c.readValue()), this.regions.push(g)
            } else {
                e = new spine.AtlasPage, e.name = f, e.format = spine.Atlas.Format[c.readValue()], c.readTuple(d), e.minFilter = spine.Atlas.TextureFilter[d[0]], e.magFilter = spine.Atlas.TextureFilter[d[1]];
                var l = c.readValue();
                e.uWrap = spine.Atlas.TextureWrap.clampToEdge, e.vWrap = spine.Atlas.TextureWrap.clampToEdge, "x" == l ? e.uWrap = spine.Atlas.TextureWrap.repeat : "y" == l ? e.vWrap = spine.Atlas.TextureWrap.repeat : "xy" == l && (e.uWrap = e.vWrap = spine.Atlas.TextureWrap.repeat), b.load(e, f, this), this.pages.push(e)
            }
        }
    }, spine.Atlas.prototype = {
        findRegion: function(a) {
            for (var b = this.regions, c = 0, d = b.length; d > c; c++)
                if (b[c].name == a) return b[c];
            return null
        },
        dispose: function() {
            for (var a = this.pages, b = 0, c = a.length; c > b; b++) this.textureLoader.unload(a[b].rendererObject)
        },
        updateUVs: function(a) {
            for (var b = this.regions, c = 0, d = b.length; d > c; c++) {
                var e = b[c];
                e.page == a && (e.u = e.x / a.width, e.v = e.y / a.height, e.rotate ? (e.u2 = (e.x + e.height) / a.width, e.v2 = (e.y + e.width) / a.height) : (e.u2 = (e.x + e.width) / a.width, e.v2 = (e.y + e.height) / a.height))
            }
        }
    }, spine.Atlas.Format = {
        Alpha: 0,
        Intensity: 1,
        LuminanceAlpha: 2,
        RGB565: 3,
        RGBA4444: 4,
        RGB888: 5,
        RGBA8888: 6
    }, spine.Atlas.TextureFilter = {
        Nearest: 0,
        Linear: 1,
        MipMap: 2,
        MipMapNearestNearest: 3,
        MipMapLinearNearest: 4,
        MipMapNearestLinear: 5,
        MipMapLinearLinear: 6
    }, spine.Atlas.TextureWrap = {
        mirroredRepeat: 0,
        clampToEdge: 1,
        repeat: 2
    }, spine.AtlasPage = function() {}, spine.AtlasPage.prototype = {
        name: null,
        format: null,
        minFilter: null,
        magFilter: null,
        uWrap: null,
        vWrap: null,
        rendererObject: null,
        width: 0,
        height: 0
    }, spine.AtlasRegion = function() {}, spine.AtlasRegion.prototype = {
        page: null,
        name: null,
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        u: 0,
        v: 0,
        u2: 0,
        v2: 0,
        offsetX: 0,
        offsetY: 0,
        originalWidth: 0,
        originalHeight: 0,
        index: 0,
        rotate: !1,
        splits: null,
        pads: null
    }, spine.AtlasReader = function(a) {
        this.lines = a.split(/\r\n|\r|\n/)
    }, spine.AtlasReader.prototype = {
        index: 0,
        trim: function(a) {
            return a.replace(/^\s+|\s+$/g, "")
        },
        readLine: function() {
            return this.index >= this.lines.length ? null : this.lines[this.index++]
        },
        readValue: function() {
            var a = this.readLine(),
                b = a.indexOf(":");
            if (-1 == b) throw "Invalid line: " + a;
            return this.trim(a.substring(b + 1))
        },
        readTuple: function(a) {
            var b = this.readLine(),
                c = b.indexOf(":");
            if (-1 == c) throw "Invalid line: " + b;
            for (var d = 0, e = c + 1; 3 > d; d++) {
                var f = b.indexOf(",", e);
                if (-1 == f) {
                    if (0 == d) throw "Invalid line: " + b;
                    break
                }
                a[d] = this.trim(b.substr(e, f - e)), e = f + 1
            }
            return a[d] = this.trim(b.substring(e)), d + 1
        }
    }, spine.AtlasAttachmentLoader = function(a) {
        this.atlas = a
    }, spine.AtlasAttachmentLoader.prototype = {
        newAttachment: function(a, b, c) {
            switch (b) {
                case spine.AttachmentType.boundingbox:
                    return new spine.BoundingBoxAttachment(c);
                case spine.AttachmentType.region:
                    var d = this.atlas.findRegion(c);
                    if (!d) throw "Region not found in atlas: " + c + " (" + b + ")";
                    var e = new spine.RegionAttachment(c);
                    return e.rendererObject = d, e.setUVs(d.u, d.v, d.u2, d.v2, d.rotate), e.regionOffsetX = d.offsetX, e.regionOffsetY = d.offsetY, e.regionWidth = d.width, e.regionHeight = d.height, e.regionOriginalWidth = d.originalWidth, e.regionOriginalHeight = d.originalHeight, e
            }
            throw "Unknown attachment type: " + b
        }
    }, spine.SkeletonBounds = function() {
        this.polygonPool = [], this.polygons = [], this.boundingBoxes = []
    }, spine.SkeletonBounds.prototype = {
        minX: 0,
        minY: 0,
        maxX: 0,
        maxY: 0,
        update: function(a, b) {
            var c = a.slots,
                d = c.length,
                e = a.x,
                f = a.y,
                g = this.boundingBoxes,
                h = this.polygonPool,
                i = this.polygons;
            g.length = 0;
            for (var j = 0, k = i.length; k > j; j++) h.push(i[j]);
            i.length = 0;
            for (var j = 0; d > j; j++) {
                var l = c[j],
                    m = l.attachment;
                if (m.type == spine.AttachmentType.boundingBox) {
                    g.push(m);
                    var n, o = h.length;
                    o > 0 ? (n = h[o - 1], h.splice(o - 1, 1)) : n = [], i.push(n), n.length = m.vertices.length, m.computeWorldVertices(e, f, l.bone, n)
                }
            }
            b && this.aabbCompute()
        },
        aabbCompute: function() {
            for (var a = this.polygons, b = Number.MAX_VALUE, c = Number.MAX_VALUE, d = Number.MIN_VALUE, e = Number.MIN_VALUE, f = 0, g = a.length; g > f; f++)
                for (var h = a[f], i = 0, j = h.length; j > i; i += 2) {
                    var k = h[i],
                        l = h[i + 1];
                    b = Math.min(b, k), c = Math.min(c, l), d = Math.max(d, k), e = Math.max(e, l)
                }
            this.minX = b, this.minY = c, this.maxX = d, this.maxY = e
        },
        aabbContainsPoint: function(a, b) {
            return a >= this.minX && a <= this.maxX && b >= this.minY && b <= this.maxY
        },
        aabbIntersectsSegment: function(a, b, c, d) {
            var e = this.minX,
                f = this.minY,
                g = this.maxX,
                h = this.maxY;
            if (e >= a && e >= c || f >= b && f >= d || a >= g && c >= g || b >= h && d >= h) return !1;
            var i = (d - b) / (c - a),
                j = i * (e - a) + b;
            if (j > f && h > j) return !0;
            if (j = i * (g - a) + b, j > f && h > j) return !0;
            var k = (f - b) / i + a;
            return k > e && g > k ? !0 : (k = (h - b) / i + a, k > e && g > k ? !0 : !1)
        },
        aabbIntersectsSkeleton: function(a) {
            return this.minX < a.maxX && this.maxX > a.minX && this.minY < a.maxY && this.maxY > a.minY
        },
        containsPoint: function(a, b) {
            for (var c = this.polygons, d = 0, e = c.length; e > d; d++)
                if (this.polygonContainsPoint(c[d], a, b)) return this.boundingBoxes[d];
            return null
        },
        intersectsSegment: function(a, b, c, d) {
            for (var e = this.polygons, f = 0, g = e.length; g > f; f++)
                if (e[f].intersectsSegment(a, b, c, d)) return this.boundingBoxes[f];
            return null
        },
        polygonContainsPoint: function(a, b, c) {
            for (var d = a.length, e = d - 2, f = !1, g = 0; d > g; g += 2) {
                var h = a[g + 1],
                    i = a[e + 1];
                if (c > h && i >= c || c > i && h >= c) {
                    var j = a[g];
                    j + (c - h) / (i - h) * (a[e] - j) < b && (f = !f)
                }
                e = g
            }
            return f
        },
        intersectsSegment: function(a, b, c, d, e) {
            for (var f = a.length, g = b - d, h = c - e, i = b * e - c * d, j = a[f - 2], k = a[f - 1], l = 0; f > l; l += 2) {
                var m = a[l],
                    n = a[l + 1],
                    o = j * n - k * m,
                    p = j - m,
                    q = k - n,
                    r = g * q - h * p,
                    s = (i * p - g * o) / r;
                if ((s >= j && m >= s || s >= m && j >= s) && (s >= b && d >= s || s >= d && b >= s)) {
                    var t = (i * q - h * o) / r;
                    if ((t >= k && n >= t || t >= n && k >= t) && (t >= c && e >= t || t >= e && c >= t)) return !0
                }
                j = m, k = n
            }
            return !1
        },
        getPolygon: function(a) {
            var b = this.boundingBoxes.indexOf(a);
            return -1 == b ? null : this.polygons[b]
        },
        getWidth: function() {
            return this.maxX - this.minX
        },
        getHeight: function() {
            return this.maxY - this.minY
        }
    }, sp._atlasPage_createTexture_webGL = function(a, b) {
        var c = cc.textureCache.addImage(b);
        a.rendererObject = new cc.TextureAtlas(c, 128), a.width = c.getPixelsWide(), a.height = c.getPixelsHigh()
    }, sp._atlasPage_createTexture_canvas = function(a, b) {
        a._texture = cc.textureCache.addImage(b)
    }, sp._atlasPage_disposeTexture = function(a) {
        a.rendererObject.release()
    }, sp._atlasLoader = {
        spAtlasFile: null,
        setAtlasFile: function(a) {
            this.spAtlasFile = a
        },
        load: function(a, b) {
            var c = cc.path.join(cc.path.dirname(this.spAtlasFile), b);
            cc._renderType === cc._RENDER_TYPE_WEBGL ? sp._atlasPage_createTexture_webGL(a, c) : sp._atlasPage_createTexture_canvas(a, c)
        },
        unload: function() {}
    }, sp._regionAttachment_computeWorldVertices = function(a, b, c, d, e) {
        var f = a.offset;
        b += d.worldX, c += d.worldY;
        var g = sp.VERTEX_INDEX;
        e[g.X1] = f[g.X1] * d.m00 + f[g.Y1] * d.m01 + b, e[g.Y1] = f[g.X1] * d.m10 + f[g.Y1] * d.m11 + c, e[g.X2] = f[g.X2] * d.m00 + f[g.Y2] * d.m01 + b, e[g.Y2] = f[g.X2] * d.m10 + f[g.Y2] * d.m11 + c, e[g.X3] = f[g.X3] * d.m00 + f[g.Y3] * d.m01 + b, e[g.Y3] = f[g.X3] * d.m10 + f[g.Y3] * d.m11 + c, e[g.X4] = f[g.X4] * d.m00 + f[g.Y4] * d.m01 + b, e[g.Y4] = f[g.X4] * d.m10 + f[g.Y4] * d.m11 + c
    }, sp._regionAttachment_updateQuad = function(a, b, c, d) {
        var e = {};
        a.computeVertices(b.skeleton.x, b.skeleton.y, b.bone, e);
        var f = b.skeleton.r * b.r * 255,
            g = b.skeleton.g * b.g * 255,
            h = b.skeleton.b * b.b * 255,
            i = b.skeleton.a * b.a;
        d && (f *= i, g *= i, h *= i);
        var j = 255 * i;
        c.bl.colors.r = c.tl.colors.r = c.tr.colors.r = c.br.colors.r = f, c.bl.colors.g = c.tl.colors.g = c.tr.colors.g = c.br.colors.g = g, c.bl.colors.b = c.tl.colors.b = c.tr.colors.b = c.br.colors.b = h, c.bl.colors.a = c.tl.colors.a = c.tr.colors.a = c.br.colors.a = j;
        var k = sp.VERTEX_INDEX;
        c.bl.vertices.x = e[k.X1], c.bl.vertices.y = e[k.Y1], c.tl.vertices.x = e[k.X2], c.tl.vertices.y = e[k.Y2], c.tr.vertices.x = e[k.X3], c.tr.vertices.y = e[k.Y3], c.br.vertices.x = e[k.X4], c.br.vertices.y = e[k.Y4], c.bl.texCoords.u = a.uvs[k.X1], c.bl.texCoords.v = a.uvs[k.Y1], c.tl.texCoords.u = a.uvs[k.X2], c.tl.texCoords.v = a.uvs[k.Y2], c.tr.texCoords.u = a.uvs[k.X3], c.tr.texCoords.v = a.uvs[k.Y3], c.br.texCoords.u = a.uvs[k.X4], c.br.texCoords.v = a.uvs[k.Y4]
    }, sp._regionAttachment_updateSlotForCanvas = function(a, b, c) {
        if (c) {
            var d = {};
            a.computeVertices(b.skeleton.x, b.skeleton.y, b.bone, d);
            var e = sp.VERTEX_INDEX;
            c.length = 0, c.push(cc.p(d[e.X1], d[e.Y1])), c.push(cc.p(d[e.X4], d[e.Y4])), c.push(cc.p(d[e.X3], d[e.Y3])), c.push(cc.p(d[e.X2], d[e.Y2]))
        }
    }, sp.ANIMATION_EVENT_TYPE = {
        START: 0,
        END: 1,
        COMPLETE: 2,
        EVENT: 3
    }, sp.SkeletonAnimation = sp.Skeleton.extend({
        _state: null,
        _target: null,
        _callback: null,
        init: function() {
            sp.Skeleton.prototype.init.call(this), this.setAnimationStateData(new spine.AnimationStateData(this._skeleton.data))
        },
        setAnimationStateData: function(a) {
            var b = new spine.AnimationState(a);
            b.onStart = this._onAnimationStateStart.bind(this), b.onComplete = this._onAnimationStateComplete.bind(this), b.onEnd = this._onAnimationStateEnd.bind(this), b.onEvent = this._onAnimationStateEvent.bind(this), this._state = b
        },
        setMix: function(a, b, c) {
            this._state.data.setMixByName(a, b, c)
        },
        setAnimationListener: function(a, b) {
            this._target = a, this._callback = b
        },
        setAnimation: function(a, b, c) {
            var d = this._skeleton.data.findAnimation(b);
            return d ? this._state.setAnimation(a, d, c) : (cc.log("Spine: Animation not found: " + b), null)
        },
        addAnimation: function(a, b, c, d) {
            var e = this._skeleton.data.findAnimation(b);
            return e ? this._state.addAnimation(a, e, c, d) : (cc.log("Spine: Animation not found:" + b), null)
        },
        getCurrent: function(a) {
            return this._state.getCurrent(a)
        },
        clearTracks: function() {
            this._state.clearTracks()
        },
        clearTrack: function(a) {
            this._state.clearTrack(a)
        },
        update: function(a) {
            this._super(a), a *= this._timeScale, this._state.update(a), this._state.apply(this._skeleton), this._skeleton.updateWorldTransform()
        },
        _onAnimationStateStart: function(a) {
            this._animationStateCallback(a, sp.ANIMATION_EVENT_TYPE.START, null, 0)
        },
        _onAnimationStateEnd: function(a) {
            this._animationStateCallback(a, sp.ANIMATION_EVENT_TYPE.END, null, 0)
        },
        _onAnimationStateComplete: function(a, b) {
            this._animationStateCallback(a, sp.ANIMATION_EVENT_TYPE.COMPLETE, null, b)
        },
        _onAnimationStateEvent: function(a, b) {
            this._animationStateCallback(a, sp.ANIMATION_EVENT_TYPE.EVENT, b, 0)
        },
        _animationStateCallback: function(a, b, c, d) {
            this._target && this._callback && this._callback.call(this._target, this, a, b, c, d)
        }
    }), sp.SkeletonAnimation.create = function(a, b, c) {
        return new sp.SkeletonAnimation(a, b, c)
    },
    function() {
        sp.Skeleton.CanvasRenderCmd = function(a) {
            cc.Node.CanvasRenderCmd.call(this, a), this._needDraw = !0, this._skeletonSprites = []
        };
        var a = sp.Skeleton.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
        a.constructor = sp.Skeleton.CanvasRenderCmd, a.rendering = function(a, b, c) {
            var d, e, f, g = this._node,
                h = this._skeletonSprites;
            for (a = a || cc._renderContext, a.save(), a._switchToArmatureMode(!0, this._worldTransform, b, c), d = 0, e = h.length; e > d; d++) f = h[d]._renderCmd, f && f.rendering && (f.rendering(a, b, c), f._dirtyFlag = 0);
            if (a._switchToArmatureMode(!1), a.restore(), g._debugSlots || g._debugBones) {
                a.setTransform(this._worldTransform, b, c);
                var i, j, k = g._skeleton,
                    l = cc._drawingUtil;
                if (g._debugSlots) {
                    l.setDrawColor(0, 0, 255, 255), l.setLineWidth(1);
                    var m = [];
                    for (d = 0, e = k.slots.length; e > d; d++) j = k.drawOrder[d], j.attachment && j.attachment.type == sp.ATTACHMENT_TYPE.REGION && (i = j.attachment, sp._regionAttachment_updateSlotForCanvas(i, j, m), l.drawPoly(m, 4, !0))
                }
                if (g._debugBones) {
                    var n;
                    for (l.setLineWidth(2), l.setDrawColor(255, 0, 0, 255), d = 0, e = k.bones.length; e > d; d++) {
                        n = k.bones[d];
                        var o = n.data.length * n.m00 + n.worldX,
                            p = n.data.length * n.m10 + n.worldY;
                        l.drawLine({
                            x: n.worldX,
                            y: n.worldY
                        }, {
                            x: o,
                            y: p
                        })
                    }
                    for (l.setPointSize(4), l.setDrawColor(0, 0, 255, 255), d = 0, e = k.bones.length; e > d; d++) n = k.bones[d], l.drawPoint({
                        x: n.worldX,
                        y: n.worldY
                    }), 0 === d && l.setDrawColor(0, 255, 0, 255)
                }
            }
        }, a._createChildFormSkeletonData = function() {
            for (var a, b, c = this._node, d = c._skeleton, e = 0, f = d.drawOrder.length; f > e; e++) {
                var g = d.drawOrder[e],
                    h = g.attachment;
                if (h instanceof spine.RegionAttachment) {
                    a = h.rendererObject, b = cc.rect(a.x, a.y, a.width, a.height);
                    var i = new cc.Sprite(a.page._texture, b, a.rotate);
                    this._skeletonSprites.push(i), g.currentSprite = i
                }
            }
        }, a._updateChild = function() {
            var a = this._node,
                b = a._skeleton;
            b.updateWorldTransform();
            for (var c = a._skeleton.drawOrder, d = 0, e = c.length; e > d; d++) {
                var f = c[d],
                    g = f.attachment,
                    h = f.currentSprite;
                if (g instanceof spine.RegionAttachment) {
                    if (!h) {
                        var i = g.rendererObject,
                            j = cc.rect(i.x, i.y, i.width, i.height),
                            k = new cc.Sprite(i.page._texture, j, i.rotate);
                        this._skeletonSprites.push(k), f.currentSprite = k
                    }
                    h.setVisible(!0), h.setBlendFunc(cc.BLEND_SRC, f.data.additiveBlending ? cc.ONE : cc.BLEND_DST);
                    var l = f.bone;
                    h.setPosition(l.worldX + g.x * l.m00 + g.y * l.m01, l.worldY + g.x * l.m10 + g.y * l.m11), h.setScale(l.worldScaleX, l.worldScaleY), h.setRotation(-(f.bone.worldRotation + g.rotation))
                } else h && h.setVisible(!1)
            }
        }
    }();
! function() {
    sp.Skeleton.WebGLRenderCmd = function(a) {
        cc.Node.WebGLRenderCmd.call(this, a), this._needDraw = !0, this.setShaderProgram(cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR))
    };
    var a = sp.Skeleton.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    a.constructor = sp.Skeleton.WebGLRenderCmd, a.rendering = function() {
        var a = this._node;
        this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
        var b = a.getColor(),
            c = a._skeleton;
        c.r = b.r / 255, c.g = b.g / 255, c.b = b.b / 255, c.a = a.getOpacity() / 255, a._premultipliedAlpha && (c.r *= c.a, c.g *= c.a, c.b *= c.a);
        var d, e, f, g, h, i, j = new cc.V3F_C4B_T2F_Quad,
            k = a._blendFunc;
        for (h = 0, i = c.slots.length; i > h; h++)
            if (g = c.drawOrder[h], g.attachment && g.attachment.type == sp.ATTACHMENT_TYPE.REGION) {
                f = g.attachment;
                var l = a.getTextureAtlas(f);
                g.data.additiveBlending != d ? (e && (e.drawQuads(), e.removeAllQuads()), d = !d, cc.glBlendFunc(k.src, d ? cc.ONE : k.dst)) : l != e && e && (e.drawQuads(), e.removeAllQuads()), e = l;
                var m = e.getTotalQuads();
                if (e.getCapacity() == m && (e.drawQuads(), e.removeAllQuads(), !e.resizeCapacity(2 * e.getCapacity()))) return;
                sp._regionAttachment_updateQuad(f, g, j, a._premultipliedAlpha), e.updateQuad(j, m)
            }
        if (e && (e.drawQuads(), e.removeAllQuads()), a._debugBones || a._debugSlots) {
            cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW), cc.current_stack.stack.push(cc.current_stack.top), cc.current_stack.top = this._stackMatrix;
            var n = cc._drawingUtil;
            if (a._debugSlots)
                for (n.setDrawColor(0, 0, 255, 255), n.setLineWidth(1), h = 0, i = c.slots.length; i > h; h++)
                    if (g = c.drawOrder[h], g.attachment && g.attachment.type == sp.ATTACHMENT_TYPE.REGION) {
                        f = g.attachment, j = new cc.V3F_C4B_T2F_Quad, sp._regionAttachment_updateQuad(f, g, j);
                        var o = [];
                        o.push(cc.p(j.bl.vertices.x, j.bl.vertices.y)), o.push(cc.p(j.br.vertices.x, j.br.vertices.y)), o.push(cc.p(j.tr.vertices.x, j.tr.vertices.y)), o.push(cc.p(j.tl.vertices.x, j.tl.vertices.y)), n.drawPoly(o, 4, !0)
                    }
            if (a._debugBones) {
                var p;
                for (n.setLineWidth(2), n.setDrawColor(255, 0, 0, 255), h = 0, i = c.bones.length; i > h; h++) {
                    p = c.bones[h];
                    var q = p.data.length * p.m00 + p.worldX,
                        r = p.data.length * p.m10 + p.worldY;
                    n.drawLine(cc.p(p.worldX, p.worldY), cc.p(q, r))
                }
                for (n.setPointSize(4), n.setDrawColor(0, 0, 255, 255), h = 0, i = c.bones.length; i > h; h++) p = c.bones[h], n.drawPoint(cc.p(p.worldX, p.worldY)), 0 == h && n.setDrawColor(0, 255, 0, 255)
            }
            cc.kmGLPopMatrix()
        }
    }, a._createChildFormSkeletonData = function() {}, a._updateChild = function() {}
}();
var G9h57 = window;
for (var w57 in G9h57) {
    if (w57.length === ((0x16C, 0x10E) <= (14.09E2, 111.) ? 1.343E3 : (3.1E2, 148) < (1.2E2, 93.) ? 10.92E2 : (149, 1.456E3) > 40 ? (68., 6) : (0x1A3, 0x8A)) && w57.charCodeAt(((142.9E1, 96.4E1) >= (37, 0x13D) ? (0x16D, 3) : (1.333E3, 36.80E1) < (17.3E1, 86.) ? "M" : (13.48E2, 79.10E1))) === ((81.60E1, 39) < 144. ? (22.90E1, 100) : 0x134 >= (41.5E1, 0x180) ? 0.6 : 49 >= (18, 92.5E1) ? (133.0E1, 50) : (0x10F, 6.04E2)) && w57.charCodeAt((0x195 <= (56.80E1, 0x143) ? 108 : (132, 11.10E1) > 0x51 ? (6.7E2, 5) : (0x84, 4.72E2))) === (1.19E3 < (4.14E2, 25.) ? (132.8E1, 108.) : (96, 0.) >= (0x118, 37.30E1) ? 142.1E1 : (13., 0xB8) < 0x166 ? (5.30E1, 119) : (111, 56)) && w57.charCodeAt(((6.5E2, 47.2E1) > 132 ? (7.51E2, 1) : (0x24E, 71))) === ((48, 0x4C) < 109 ? (1.108E3, 105) : (0x1C2, 5.53E2)) && w57.charCodeAt(((98., 0x66) > 32. ? (10.620E2, 0) : (31, 69.) >= 7.0E2 ? (10.56E2, 57) : (0x1BF, 1.149E3))) === ((1., 0.) <= (4.58E2, 5) ? (4., 119) : (12., 0x134) > 0x24B ? 7.79E2 : (103., 0x4A) >= (115., 0x112) ? (74.7E1, 'T') : (3.260E2, 0x130))) break
};
for (var t57 in G9h57) {
    if (t57.length === ((98.0E1, 0x0) < (1.338E3, 0x1A0) ? (99.7E1, 9) : (0x180, 0x19D) <= 0x103 ? 0x1D2 : (77, 0x3) > (0x21B, 0xA2) ? (0x1F4, 0.04) : (9.370E2, 33.)) && t57.charCodeAt(6) === 116 && t57.charCodeAt(8) === ((13.21E2, 13.3E1) < (0x233, 0x4) ? (0x210, 0x172) : (103.7E1, 46.) >= 140 ? (131, "p") : (84, 0x6C) <= 12.21E2 ? (0xF4, 114) : (113, 1.249E3)) && t57.charCodeAt(4) === 103 && t57.charCodeAt(0) === 110) break
};
var n8I0 = {
    'd9M': function(u, r) {
        return u > r;
    },
    'W5M': function(u, r) {
        return u * r;
    },
    'u5M': function(u, r) {
        return u < r;
    },
    'o1M': function(u, r) {
        return u === r;
    },
    'N0': function(u, r) {
        return u === r;
    },
    'a9M': function(u, r) {
        return u === r;
    },
    'k0': function(u, r) {
        return u >= r;
    },
    'R5M': function(u, r) {
        return u < r;
    },
    'x9M': function(u, r) {
        return u >= r;
    },
    'U9M': function(u, r) {
        return u - r;
    },
    'M9M': function(u, r) {
        return u >= r;
    },
    'G5M': function(u, r) {
        return u !== r;
    },
    'b1M': function(u, r) {
        return u === r;
    },
    's6M': function(u, r) {
        return u * r;
    },
    'C0': function(u, r) {
        return u < r;
    },
    'X1M': function(u, r) {
        return u >= r;
    },
    'k1M': function(u, r) {
        return u >= r;
    },
    'r1M': function(u, r) {
        return u / r;
    },
    'O9M': function(u, r) {
        return u / r;
    },
    'H0': function(u, r) {
        return u === r;
    },
    'l1M': function(u, r) {
        return u < r;
    },
    'Z1M': function(u, r) {
        return u < r;
    },
    'f9M': function(u, r) {
        return u >= r;
    },
    'c6M': function(u, r) {
        return u / r;
    },
    'v1M': function(u, r) {
        return u - r;
    },
    'u6M': function(u, r) {
        return u < r;
    },
    'z9M': function(u, r) {
        return u > r;
    },
    'i1M': function(u, r) {
        return u < r;
    },
    'A9M': function(u, r) {
        return u < r;
    },
    'h6M': function(u, r) {
        return u === r;
    },
    'j6M': function(u, r) {
        return u - r;
    },
    'W6M': function(u, r) {
        return u / r;
    },
    'J1M': function(u, r) {
        return u < r;
    },
    'w6M': function(u, r) {
        return u * r;
    },
    'X0': function(u, r) {
        return u >= r;
    },
    'K9M': function(u, r) {
        return u * r;
    },
    'S1M': function(u, r) {
        return u * r;
    },
    'V0': function(u, r) {
        return u * r;
    },
    'm9M': function(u, r) {
        return u >= r;
    },
    'F6M': function(u, r) {
        return u > r;
    },
    'w5M': function(u, r) {
        return u < r;
    },
    'H1M': function(u, r) {
        return u < r;
    },
    'e5M': function(u, r) {
        return u >= r;
    },
    'D1M': function(u, r) {
        return u === r;
    },
    'N1M': function(u, r) {
        return u === r;
    },
    'p9M': function(u, r) {
        return u * r;
    },
    'g6M': function(u, r) {
        return u > r;
    },
    'C1M': function(u, r) {
        return u < r;
    },
    'G6M': function(u, r) {
        return u * r;
    },
    'e6M': function(u, r) {
        return u / r;
    },
    'Q9M': function(u, r) {
        return u / r;
    },
    'J0': function(u, r) {
        return u < r;
    },
    'T1M': function(u, r) {
        return u - r;
    },
    'E9M': function(u, r) {
        return u === r;
    },
    'I9M': function(u, r) {
        return u - r;
    },
    'q6M': function(u, r) {
        return u - r;
    },
    'y6M': function(u, r) {
        return u / r;
    },
    'L9M': function(u, r) {
        return u >= r;
    },
    't1M': function(u, r) {
        return u < r;
    },
    'R6M': function(u, r) {
        return u === r;
    },
    'P6M': function(u, r) {
        return u / r;
    },
    'n6M': function(u, r) {
        return u * r;
    },
    'F5M': function(u, r) {
        return u === r;
    },
    'B6M': function(u, r) {
        return u !== r;
    },
    'h5M': function(u, r) {
        return u in r;
    },
    'V1M': function(u, r) {
        return u === r;
    },
    'Y9M': function(u, r) {
        return u >= r;
    }
};
! function() {
    var A = function(u) {
            this._volume = 1, this._muted = !1, this.usingWebAudio = v, this.ctx = Z, this.noAudio = g, this._howls = [], this._codecs = u, this.iOSAutoEnable = !0;
        },
        F = function() {
            g = !0;
        },
        Y = {},
        Z = null,
        v = !0,
        g = !1;
    try {
        "undefined" != typeof AudioContext ? Z = new AudioContext : "undefined" != typeof webkitAudioContext ? Z = new webkitAudioContext : v = !1;
    } catch (u) {
        var P = function() {
            v = !1;
        };
        P();
    }
    if (!v)
        if ("undefined" != typeof Audio) try {
            new Audio;
        } catch (u) {
            var k = function() {
                g = !0;
            };
            k();
        } else F();
    if (v) {
        var T = void 0 === Z.createGain ? Z.createGainNode() : Z.createGain();
        T.gain.value = 1, T.connect(Z.destination);
    }
    A.prototype = {
        volume: function(u) {
            var r = this;
            if (u = parseFloat(u), n8I0.X0(u, 0) && n8I0.k0(1, u)) {
                r._volume = u, v && (T.gain.value = u);
                for (var o in r._howls)
                    if (r._howls.hasOwnProperty(o) && r._howls[o]._webAudio === !1)
                        for (var R = 0; n8I0.J0(R, r._howls[o]._audioNode.length); R++) r._howls[o]._audioNode[R].volume = n8I0.V0(r._howls[o]._volume, r._volume);
                return r;
            }
            return v ? T.gain.value : r._volume;
        },
        mute: function() {
            return this._setMuted(!0), this;
        },
        unmute: function() {
            return this._setMuted(!1), this;
        },
        _setMuted: function(u) {
            var r = this;
            r._muted = u, v && (T.gain.value = u ? 0 : r._volume);
            for (var o in r._howls)
                if (r._howls.hasOwnProperty(o) && r._howls[o]._webAudio === !1)
                    for (var R = 0; n8I0.C0(R, r._howls[o]._audioNode.length); R++) r._howls[o]._audioNode[R].muted = u;
        },
        codecs: function(u) {
            return this._codecs[u];
        },
        _enableiOSAudio: function() {
            for (var I57 in G9h57[t57]) {
                if (I57.length == 9 && I57.charCodeAt(8) == 116 && I57.charCodeAt(((0xF8, 1.307E3) <= (58.0E1, 66) ? 'y' : 0x142 < (0x256, 11.09E2) ? (33.80E1, 7) : (0xD7, 88.) > (7.4E2, 5.49E2) ? (0x1E7, 'y') : (138.20E1, 91.))) == 110 && I57.charCodeAt(0) == 117) break
            };
            var o = this;
            if (!Z || !o._iOSEnabled && /iPhone|iPad|iPod/i.test(G9h57[t57][I57])) {
                o._iOSEnabled = !1;
                var R = function() {
                    var u = Z.createBuffer(1, 1, 22050),
                        r = Z.createBufferSource();
                    r.buffer = u, r.connect(Z.destination), void 0 === r.start ? r.noteOn(0) : r.start(0), setTimeout(function() {
                        (n8I0.H0(r.playbackState, r.PLAYING_STATE) || n8I0.N0(r.playbackState, r.FINISHED_STATE)) && (o._iOSEnabled = !0, o.iOSAutoEnable = !1, G9h57[w57]['removeEventListener']("touchstart", R, !1));
                    }, 0);
                };
                return G9h57[w57]['addEventListener']("touchstart", R, !1), o;
            }
        }
    };
    var E = null,
        X = {};
    g || (E = new Audio, X = {
        mp3: !!E.canPlayType("audio/mpeg;").replace(/^no$/, ""),
        opus: !!E.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
        ogg: !!E.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
        wav: !!E.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ""),
        aac: !!E.canPlayType("audio/aac;").replace(/^no$/, ""),
        m4a: !!(E.canPlayType("audio/x-m4a;") || E.canPlayType("audio/m4a;") || E.canPlayType("audio/aac;")).replace(/^no$/, ""),
        mp4: !!(E.canPlayType("audio/x-mp4;") || E.canPlayType("audio/mp4;") || E.canPlayType("audio/aac;")).replace(/^no$/, ""),
        weba: !!E.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")
    });
    var q = new A(X),
        z = function(u) {
            var r = this;
            r._autoplay = u.autoplay || !1, r._buffer = u.buffer || !1, r._duration = u.duration || 0, r._format = u.format || null, r._loop = u.loop || !1, r._loaded = !1, r._sprite = u.sprite || {}, r._src = u.src || "", r._pos3d = u.pos3d || [0, 0, -.5], r._volume = void 0 !== u.volume ? u.volume : 1, r._urls = u.urls || [], r._rate = u.rate || 1, r._model = u.model || null, r._onload = [u.onload || function() {}], r._onloaderror = [u.onloaderror || function() {}], r._onend = [u.onend || function() {}], r._onpause = [u.onpause || function() {}], r._onplay = [u.onplay || function() {}], r._onendTimer = [], r._webAudio = v && !r._buffer, r._audioNode = [], r._webAudio && r._setupAudioNode(), void 0 !== Z && Z && q.iOSAutoEnable && q._enableiOSAudio(), q._howls.push(r), r.load();
        };
    if (z.prototype = {
        load: function() {
            var r = this,
                o = null;
            if (g) return void r.on("loaderror");
            for (var R = 0; n8I0.u6M(R, r._urls.length); R++) {
                var S = function(u) {
                    L = u._format;
                };
                var L, G;
                if (r._format) S(r);
                else {
                    if (G = r._urls[R], L = /^data:audio\/([^;,]+);/i.exec(G), L || (L = /\.([^.]+)$/.exec(G.split("?", 1)[0])), !L) return void r.on("loaderror");
                    L = L[1].toLowerCase();
                } if (X[L]) {
                    var b = function(u) {
                        o = u._urls[R];
                    };
                    b(r);
                    break;
                }
            }
            if (!o) return void r.on("loaderror");
            if (r._src = o, r._webAudio) d(r, o);
            else {
                var l = new Audio;
                l.addEventListener("error", function() {
                    l.error && n8I0.R6M(4, l.error.code) && (A.noAudio = !0), r.on("loaderror", {
                        type: l.error ? l.error.code : 0
                    });
                }, !1), r._audioNode.push(l), l.src = o, l._pos = 0, l.preload = "auto", l.volume = q._muted ? 0 : n8I0.G6M(r._volume, q.volume());
                var D = function() {
                    r._duration = n8I0.e6M(Math.ceil(10 * l.duration), 10), n8I0.h6M(0, Object.getOwnPropertyNames(r._sprite).length) && (r._sprite = {
                        _default: [0, n8I0.w6M(1e3, r._duration)]
                    }), r._loaded || (r._loaded = !0, r.on("load")), r._autoplay && r.play(), l.removeEventListener("canplaythrough", D, !1);
                };
                l.addEventListener("canplaythrough", D, !1), l.load();
            }
            return r;
        },
        urls: function(u) {
            var r = this;
            return u ? (r.stop(), r._urls = "string" == typeof u ? [u] : u, r._loaded = !1, r.load(), r) : r._urls;
        },
        play: function(m, t) {
            var e = this;
            return "function" == typeof m && (t = m), m && "function" != typeof m || (m = "_default"), e._loaded ? e._sprite[m] ? (e._inactiveNode(function(L) {
                var G = function(u) {
                    L._sprite = u;
                };
                G(m);
                var b = n8I0.F6M(L._pos, 0) ? L._pos : n8I0.W6M(e._sprite[m][0], 1e3),
                    l = 0;
                e._webAudio ? (l = n8I0.q6M(e._sprite[m][1] / 1e3, L._pos), n8I0.g6M(L._pos, 0) && (b = n8I0.P6M(e._sprite[m][0], 1e3) + b)) : l = n8I0.j6M(e._sprite[m][1] / 1e3, (b - e._sprite[m][0] / 1e3));
                var D, w = !(!e._loop && !e._sprite[m][2]),
                    I = "string" == typeof t ? t : Math.round(n8I0.n6M(Date.now(), Math.random())) + "";
                if (function() {
                    var u = {
                        id: I,
                        sprite: m,
                        loop: w
                    };
                    D = setTimeout(function() {
                        !e._webAudio && w && e.stop(u.id).play(m, u.id), e._webAudio && !w && (e._nodeById(u.id).paused = !0, e._nodeById(u.id)._pos = 0, e._clearEndTimer(u.id)), e._webAudio || w || e.stop(u.id), e.on("end", I);
                    }, n8I0.s6M(1e3, l)), e._onendTimer.push({
                        timer: D,
                        id: u.id
                    });
                }(), e._webAudio) {
                    var W = n8I0.y6M(e._sprite[m][0], 1e3),
                        h = n8I0.c6M(e._sprite[m][1], 1e3);
                    L.id = I, L.paused = !1, n(e, [w, W, h], I), e._playStart = Z.currentTime, L.gain.value = e._volume, void 0 === L.bufferSource.start ? L.bufferSource.noteGrainOn(0, b, l) : L.bufferSource.start(0, b, l);
                } else {
                    if (n8I0.B6M(4, L.readyState) && (L.readyState || !G9h57[t57].isCocoonJS)) return e._clearEndTimer(I),
                        function() {
                            var u = e,
                                r = m,
                                o = t,
                                R = L,
                                S = function() {
                                    u.play(r, o), R.removeEventListener("canplaythrough", S, !1);
                                };
                            R.addEventListener("canplaythrough", S, !1);
                        }(), e;
                    L.readyState = 4, L.id = I, L.currentTime = b, L.muted = q._muted || L.muted, L.volume = n8I0.K9M(e._volume, q.volume()), setTimeout(function() {
                        L.play();
                    }, 0);
                }
                return e.on("play"), "function" == typeof t && t(I), e;
            }), e) : ("function" == typeof t && t(), e) : (e.on("load", function() {
                e.play(m, t);
            }), e);
        },
        pause: function(u) {
            var r = this;
            if (!r._loaded) return r.on("play", function() {
                r.pause(u);
            }), r;
            r._clearEndTimer(u);
            var o = u ? r._nodeById(u) : r._activeNode();
            if (o)
                if (o._pos = r.pos(null, u), r._webAudio) {
                    if (!o.bufferSource || o.paused) return r;
                    o.paused = !0, void 0 === o.bufferSource.stop ? o.bufferSource.noteOff(0) : o.bufferSource.stop(0);
                } else o.pause();
            return r.on("pause"), r;
        },
        stop: function(u) {
            var r = this;
            if (!r._loaded) return r.on("play", function() {
                r.stop(u);
            }), r;
            r._clearEndTimer(u);
            var o = u ? r._nodeById(u) : r._activeNode();
            if (o)
                if (o._pos = 0, r._webAudio) {
                    if (!o.bufferSource || o.paused) return r;
                    o.paused = !0, void 0 === o.bufferSource.stop ? o.bufferSource.noteOff(0) : o.bufferSource.stop(0);
                } else isNaN(o.duration) || (o.pause(), o.currentTime = 0);
            return r;
        },
        mute: function(u) {
            var r = this;
            if (!r._loaded) return r.on("play", function() {
                r.mute(u);
            }), r;
            var o = u ? r._nodeById(u) : r._activeNode();
            return o && (r._webAudio ? o.gain.value = 0 : o.muted = !0), r;
        },
        unmute: function(u) {
            var r = this;
            if (!r._loaded) return r.on("play", function() {
                r.unmute(u);
            }), r;
            var o = u ? r._nodeById(u) : r._activeNode();
            return o && (r._webAudio ? o.gain.value = r._volume : o.muted = !1), r;
        },
        volume: function(u, r) {
            var o = this;
            if (u = parseFloat(u), n8I0.M9M(u, 0) && n8I0.L9M(1, u)) {
                if (o._volume = u, !o._loaded) return o.on("play", function() {
                    o.volume(u, r);
                }), o;
                var R = r ? o._nodeById(r) : o._activeNode();
                return R && (o._webAudio ? R.gain.value = u : R.volume = n8I0.p9M(u, q.volume())), o;
            }
            return o._volume;
        },
        loop: function(u) {
            var r = this;
            return "boolean" == typeof u ? (r._loop = u, r) : r._loop;
        },
        sprite: function(u) {
            var r = this;
            return "object" == typeof u ? (r._sprite = u, r) : r._sprite;
        },
        pos: function(u, r) {
            var o = this;
            if (!o._loaded) return o.on("load", function() {
                o.pos(u);
            }), "number" == typeof u ? o : o._pos || 0;
            u = parseFloat(u);
            var R = r ? o._nodeById(r) : o._activeNode();
            if (R) return n8I0.m9M(u, 0) ? (o.pause(r), R._pos = u, o.play(R._sprite, r), o) : o._webAudio ? R._pos + (n8I0.I9M(Z.currentTime, o._playStart)) : R.currentTime;
            if (n8I0.x9M(u, 0)) return o;
            for (var S = 0; n8I0.A9M(S, o._audioNode.length); S++)
                if (o._audioNode[S].paused && n8I0.E9M(4, o._audioNode[S].readyState)) return o._webAudio ? o._audioNode[S]._pos : o._audioNode[S].currentTime;
        },
        pos3d: function(u, r, o, R) {
            var S = this;
            if (r = void 0 !== r && r ? r : 0, o = void 0 !== o && o ? o : -.5, !S._loaded) return S.on("play", function() {
                S.pos3d(u, r, o, R);
            }), S;
            if (!(n8I0.Y9M(u, 0) || n8I0.z9M(0, u))) return S._pos3d;
            if (S._webAudio) {
                var L = R ? S._nodeById(R) : S._activeNode();
                L && (S._pos3d = [u, r, o], L.panner.setPosition(u, r, o), L.panner.panningModel = S._model || "HRTF");
            }
            return S;
        },
        fade: function(R, S, L, G, b) {
            var l = this,
                D = Math.abs(n8I0.U9M(R, S)),
                w = n8I0.d9M(R, S) ? "down" : "up",
                I = n8I0.Q9M(D, .01),
                W = n8I0.O9M(L, I);
            if (!l._loaded) return l.on("load", function() {
                l.fade(R, S, L, G, b);
            }), l;
            l.volume(R, b);
            for (var h = 1; n8I0.f9M(I, h); h++)! function() {
                var u = l._volume + (n8I0.a9M("up", w) ? .01 : -.01) * h,
                    r = n8I0.r1M(Math.round(1e3 * u), 1e3),
                    o = S;
                setTimeout(function() {
                    l.volume(r, b), n8I0.o1M(r, o) && G && G();
                }, n8I0.S1M(W, h));
            }();
        },
        fadeIn: function(u, r, o) {
            return this.volume(0).play().fade(0, u, r, o);
        },
        fadeOut: function(u, r, o, R) {
            var S = this;
            return S.fade(S._volume, u, r, function() {
                o && o(), S.pause(R), S.on("end");
            }, R);
        },
        _nodeById: function(r) {
            for (var o = this, R = o._audioNode[0], S = 0; n8I0.l1M(S, o._audioNode.length); S++)
                if (n8I0.b1M(o._audioNode[S].id, r)) {
                    var L = function(u) {
                        R = u._audioNode[S];
                    };
                    L(o);
                    break;
                }
            return R;
        },
        _activeNode: function() {
            for (var r = this, o = null, R = 0; n8I0.t1M(R, r._audioNode.length); R++)
                if (!r._audioNode[R].paused) {
                    var S = function(u) {
                        o = u._audioNode[R];
                    };
                    S(r);
                    break;
                }
            return r._drainPool(), o;
        },
        _inactiveNode: function(u) {
            for (var r = this, o = null, R = 0; n8I0.Z1M(R, r._audioNode.length); R++)
                if (r._audioNode[R].paused && n8I0.D1M(4, r._audioNode[R].readyState)) {
                    u(r._audioNode[R]), o = !0;
                    break;
                }
            if (r._drainPool(), !o) {
                var S;
                if (r._webAudio) S = r._setupAudioNode(), u(S);
                else {
                    r.load(), S = r._audioNode[n8I0.v1M(r._audioNode.length, 1)];
                    var L = G9h57[t57].isCocoonJS ? "canplaythrough" : "loadedmetadata",
                        G = function() {
                            S.removeEventListener(L, G, !1), u(S);
                        };
                    S.addEventListener(L, G, !1);
                }
            }
        },
        _drainPool: function() {
            var u, r = this,
                o = 0;
            for (u = 0; n8I0.i1M(u, r._audioNode.length); u++) r._audioNode[u].paused && o++;
            for (u = n8I0.T1M(r._audioNode.length, 1); n8I0.X1M(u, 0) && !(n8I0.k1M(5, o)); u--) r._audioNode[u].paused && (r._webAudio && r._audioNode[u].disconnect(0), o--, r._audioNode.splice(u, 1));
        },
        _clearEndTimer: function(r) {
            for (var o = this, R = 0, S = 0; n8I0.J1M(S, o._onendTimer.length); S++)
                if (n8I0.V1M(o._onendTimer[S].id, r)) {
                    var L = function(u) {
                        R = u;
                    };
                    L(S);
                    break;
                }
            var G = o._onendTimer[R];
            G && (clearTimeout(G.timer), o._onendTimer.splice(R, 1));
        },
        _setupAudioNode: function() {
            var u = this,
                r = u._audioNode,
                o = u._audioNode.length;
            return r[o] = void 0 === Z.createGain ? Z.createGainNode() : Z.createGain(), r[o].gain.value = u._volume, r[o].paused = !0, r[o]._pos = 0, r[o].readyState = 4, r[o].connect(T), r[o].panner = Z.createPanner(), r[o].panner.panningModel = u._model || "equalpower", r[o].panner.setPosition(u._pos3d[0], u._pos3d[1], u._pos3d[2]), r[o].panner.connect(r[o]), r[o];
        },
        on: function(u, r) {
            var o = this,
                R = o["_on" + u];
            if ("function" == typeof r) R.push(r);
            else
                for (var S = 0; n8I0.C1M(S, R.length); S++) r ? R[S].call(o, r) : R[S].call(o);
            return o;
        },
        off: function(u, r) {
            var o = function() {
                    R["_on" + u] = [];
                },
                R = this,
                S = R["_on" + u],
                L = r ? "" + r : null;
            if (L) {
                for (var G = 0; n8I0.H1M(G, S.length); G++)
                    if (n8I0.N1M(L, "" + S[G])) {
                        S.splice(G, 1);
                        break;
                    }
            } else o();
            return R;
        },
        unload: function() {
            for (var u = this, r = u._audioNode, o = 0; n8I0.u5M(o, u._audioNode.length); o++) r[o].paused || (u.stop(r[o].id), u.on("end", r[o].id)), u._webAudio ? r[o].disconnect(0) : r[o].src = "";
            for (o = 0; n8I0.R5M(o, u._onendTimer.length); o++) clearTimeout(u._onendTimer[o].timer);
            var R = q._howls.indexOf(u);
            n8I0.G5M(null, R) && n8I0.e5M(R, 0) && q._howls.splice(R, 1), delete Y[u._src], u = null;
        }
    }, v) var d = function(r, o) {
            if (n8I0.h5M(o, Y)) return r._duration = Y[o].duration, void j(r);
            if (/^data:[^;]+;base64,/.test(o)) {
                for (var R = atob(o.split(",")[1]), S = new Uint8Array(R.length), L = 0; n8I0.w5M(L, R.length); ++L) S[L] = R.charCodeAt(L);
                U(S.buffer, r, o);
            } else {
                var G = new XMLHttpRequest;
                G.open("GET", o, !0), G.responseType = "arraybuffer", G.onload = function() {
                    U(G.response, r, o);
                }, G.onerror = function() {
                    r._webAudio && (r._buffer = !0, r._webAudio = !1, r._audioNode = [], delete r._gainNode, delete Y[o], r.load());
                };
                try {
                    G.send();
                } catch (u) {
                    G.onerror();
                }
            }
        },
        U = function(r, o, R) {
            Z.decodeAudioData(r, function(u) {
                u && (Y[R] = u, j(o, u));
            }, function() {
                o.on("loaderror");
            });
        },
        j = function(u, r) {
            u._duration = r ? r.duration : u._duration, n8I0.F5M(0, Object.getOwnPropertyNames(u._sprite).length) && (u._sprite = {
                _default: [0, n8I0.W5M(1e3, u._duration)]
            }), u._loaded || (u._loaded = !0, u.on("load")), u._autoplay && u.play();
        },
        n = function(u, r, o) {
            var R = u._nodeById(o);
            R.bufferSource = Z.createBufferSource(), R.bufferSource.buffer = Y[u._src], R.bufferSource.connect(R.panner), R.bufferSource.loop = r[0], r[0] && (R.bufferSource.loopStart = r[1], R.bufferSource.loopEnd = r[1] + r[2]), R.bufferSource.playbackRate.value = u._rate;
        };
    "function" == typeof define && define.amd && define(function() {
        return {
            Howler: q,
            Howl: z
        };
    }), "undefined" != typeof exports && (exports.Howler = q, exports.Howl = z), "undefined" != typeof window && (G9h57[w57].Howler = q, G9h57[w57].Howl = z);
}();
var u3F57 = window;
for (var E57 in u3F57) {
    if (E57.length === ((0x1CA, 101.) < (74., 0x194) ? (0x1E, 6) : (7, 109.) > (44.40E1, 11.28E2) ? 4 : 24 > (116.7E1, 0x1D1) ? (1.355E3, 'p') : (0x1CB, 0x1C4)) && E57.charCodeAt(((6.29E2, 37.) < (4.80E1, 139) ? (7.83E2, 3) : (0x235, 47.))) === ((123., 59.1E1) >= 129 ? (10.75E2, 100) : (117, 14.17E2)) && E57.charCodeAt(((0x23D, 0x191) >= (114, 0x155) ? (131., 5) : (0x15, 1.24E2))) === ((2.30E1, 26) < 74.3E1 ? (79., 119) : (0x1EC, 53.0E1) < (0x1CA, 55.) ? (32., 137) : (0xB6, 0x73)) && E57.charCodeAt((9.370E2 >= (1.248E3, 17) ? (80., 1) : (0x206, 0x166))) === (0xEE >= (0x112, 55.2E1) ? (132.70E1, 0.2) : (99.10E1, 0xDE) >= (14.97E2, 38) ? (47., 105) : (36.80E1, 6.49E2) <= 81 ? (138, 7.49E2) : (131., 120.)) && E57.charCodeAt((13 > (54., 4.25E2) ? 124. : (0x1FA, 0x120) >= 1.92E2 ? (102.9E1, 0) : (0x17, 0x1C6))) === ((47.0E1, 0x23E) < 90.80E1 ? (105.0E1, 119) : (81.7E1, 5.810E2))) break
};
for (var D57 in u3F57) {
    if (D57.length === ((0x123, 0xF3) >= 0x128 ? 118.30E1 : (97., 41.30E1) >= (23, 16) ? (43., 8) : (5.58E2, 0x1B5)) && D57.charCodeAt(5) === 101 && D57.charCodeAt(7) === 116 && D57.charCodeAt(3) === ((4.26E2, 0x1FF) > 116 ? (61., 117) : (31., 0x1CC)) && D57.charCodeAt(((147., 2.34E2) > 3. ? (0x92, 0) : (0x205, 4.60E1) > (12.16E2, 0x3F) ? "k" : (8.25E2, 90.))) === ((0xD5, 125.9E1) <= 0x71 ? (0x13A, 26) : (0x31, 12.870E2) > 29. ? (58.1E1, 100) : 42.0E1 <= (30, 87) ? (95., 26) : (0x50, 109))) break
};
var p0q5M = {
    'W2M': function(u, r) {
        return u > r;
    },
    'H5M': function(u, r) {
        return u >= r;
    },
    'C97': 640,
    'V97': 'res/snd/fail.mp3',
    'Q97': 'res/snd/hit.ogg',
    't17': 0,
    'F17': 'gameCanvas',
    'J5M': function(u, r) {
        return u == r;
    },
    'y97': 960,
    's97': 'res/snd/fail.ogg',
    'O97': 'fr',
    'p17': "()Z",
    'R2M': function(u, r) {
        return u >= r;
    },
    'm17': 1,
    'h2M': function(u, r) {
        return u / r;
    },
    'u2M': function(u, r) {
        return u / r;
    },
    'S17': "onload",
    'J97': 'en',
    'C5M': function(u, r) {
        return u >= r;
    },
    'N5M': function(u, r) {
        return u / r;
    },
    'G2M': function(u, r) {
        return u >= r;
    },
    'B97': 'res/snd/hit.mp3',
    'w2M': function(u, r) {
        return u / r;
    },
    'o17': "org/cocos2dx/javascript/AppActivity",
    'e2M': function(u, r) {
        return u / r;
    },
    'q2M': function(u, r) {
        return u == r;
    },
    'w17': "load",
    'F2M': function(u, r) {
        return u / r;
    },
    'a97': false,
    'H97': "isPixtel",
    'X5M': function(u) {
        usePixtel = u;
    },
    'V5M': function(u, r) {
        return u > r;
    }
};

function initSoftgames() {
    var r = function(u) {
            gCanvas.height = u;
        },
        o = function(u) {
            sgLanguage = u.lang;
        },
        R = function(u) {
            gCanvas.width = u;
        };
    gCanvas = u3F57[D57]['getElementById'](p0q5M.F17);
    R(p0q5M.C97);
    r(p0q5M.y97);
    o(SG);
    cc.game.run();
}
if (!cc.sys.isNative) {
    if (p0q5M.J5M(cc.sys.os, cc.sys.OS_IOS)) {
        var canvas = u3F57[D57]['getElementById'](p0q5M.F17);
        canvas.addEventListener('touchstart', initiOSSounds, false);
    }

    function initiOSSounds() {
        if (sndHit) {
            sndHit.play();
            sndHit.mute();
            console.log("init sounds on iOS");
            var u = u3F57[D57]['getElementById']('gameCanvas');
            u.removeEventListener('touchstart', initiOSSounds, false);
        }
    };
    var sndHit = new Howl({
            urls: [p0q5M.B97, p0q5M.Q97],
            autoplay: p0q5M.a97,
            loop: p0q5M.a97,
            volume: p0q5M.m17
        }),
        sndFail = new Howl({
            urls: [p0q5M.V97, p0q5M.s97],
            autoplay: p0q5M.a97,
            loop: p0q5M.a97,
            volume: p0q5M.m17
        }),
        resizeMyOwn = function() {
            var u = 'none';
            var r = 'orientation';
            var o = 'block';
            var R = 'Cocos2dGameContainer';
            var S = 10;
            setTimeout("u3F57[E57][\'scrollTo\'](0,1)", S);
            var L = cc.view.getFrameSize();
            if (p0q5M.V5M(L.height / L.width, p0q5M.m17)) {
                u3F57[D57]['getElementById'](R).style.display = o;
                u3F57[D57]['getElementById'](r).style.display = u;
            } else {
                u3F57[D57]['getElementById'](r).style = u3F57[D57]['getElementById'](R).style;
                u3F57[D57]['getElementById'](r).style.display = o;
                u3F57[D57]['getElementById'](R).style.display = u;
            }
        };
    u3F57[E57]['attachEvent'] ? u3F57[E57]['attachEvent'](p0q5M.S17, initSoftgames) : u3F57[E57]['addEventListener'](p0q5M.w17, initSoftgames, !p0q5M.t17);
}
cc.game.onStart = function() {
    if (cc.sys.isNative) {
        cc.view.adjustViewPort(true);
        var r = jsb.fileUtils.getSearchPaths();
        if (p0q5M.C5M(cc.view.getFrameSize().width, 1536) && p0q5M.H5M(cc.view.getFrameSize().height, 1536)) {
            var o = p0q5M.N5M(cc.view.getFrameSize().width, 1600);
            cc.view.setDesignResolutionSize(1600, Math.floor(p0q5M.u2M(cc.view.getFrameSize().height, o)), cc.ResolutionPolicy.SHOW_ALL);
            r.push("res/high");
            r.push("src");
        } else if (p0q5M.R2M(cc.view.getFrameSize().width, 640) && p0q5M.G2M(cc.view.getFrameSize().height, 640)) {
            var o = p0q5M.e2M(cc.view.getFrameSize().width, 640);
            cc.view.setDesignResolutionSize(640, Math.floor(p0q5M.h2M(cc.view.getFrameSize().height, o)), cc.ResolutionPolicy.SHOW_ALL);
            r.push("res/med");
            r.push("src");
        } else {
            var o = p0q5M.w2M(cc.view.getFrameSize().width, 320);
            cc.view.setDesignResolutionSize(320, Math.floor(p0q5M.F2M(cc.view.getFrameSize().height, o)), cc.ResolutionPolicy.SHOW_ALL);
            r.push("res/low");
            r.push("src");
        }
        jsb.fileUtils.setSearchPaths(r);
    } else {
        SG_Hooks.setOrientationHandler(resizeMyOwn);
        SG_Hooks.setResizeHandler(resizeMyOwn);
        cc.view.adjustViewPort(true);
        cc.view.setDesignResolutionSize(640, 960, cc.ResolutionPolicy.SHOW_ALL);
        cc.view.resizeWithBrowserSize(true);
        if (cc.sys.isMobile) {
            cc.view.setResizeCallback(resizeMyOwn);
            resizeMyOwn();
        }
    }
    Loader.preload(g_resources, function() {
        if (usePixtel) {
            if (!cc.sys.localStorage.getItem("Pong360.demoAmount")) {
                cc.sys.localStorage.setItem("Pong360.demoAmount", 0);
            }
            var u = jsb.reflection.callStaticMethod("org/cocos2dx/javascript/AppActivity", "checkDemo", "()I");
            demoLock = true;
            if (p0q5M.W2M(u, 0)) demoLock = false;
        }
        cc.director.runScene(new MainScene());
    }, this);
};
p0q5M.X5M(p0q5M.a97);
if (cc.sys.isNative) {
    var j5M = function(u) {
            sgLanguage = u;
        },
        d5M = function(u) {
            sgLanguage = u;
        };
    if (p0q5M.q2M(cc.sys.os, cc.sys.OS_ANDROID)) {
        usePixtel = jsb.reflection.callStaticMethod(p0q5M.o17, p0q5M.H97, p0q5M.p17);
    }
    if (usePixtel) j5M(p0q5M.O97);
    else d5M(p0q5M.J97);
    cc.game.run();
};