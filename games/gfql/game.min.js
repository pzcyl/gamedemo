var cc = cc || {};
cc._tmp = cc._tmp || {};
cc._LogInfos = {};
_p = window;
_p = Object.prototype;
delete window._p;
cc.newElement = function(a) {
    return document.createElement(a)
};
cc._addEventListener = function(a, b, c, d) {
    a.addEventListener(b, c, d)
};
cc._isNodeJs = "undefined" !== typeof require && require("fs");
cc.each = function(a, b, c) {
    if (a)
        if (a instanceof Array)
            for (var d = 0, e = a.length; d < e && !1 !== b.call(c, a[d], d); d++);
        else
            for (d in a)
                if (!1 === b.call(c, a[d], d)) break
};
cc.extend = function(a) {
    var b = 2 <= arguments.length ? Array.prototype.slice.call(arguments, 1) : [];
    cc.each(b, function(b) {
        for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d])
    });
    return a
};
cc.isFunction = function(a) {
    return "function" == typeof a
};
cc.isNumber = function(a) {
    return "number" == typeof a || "[object Number]" == Object.prototype.toString.call(a)
};
cc.isString = function(a) {
    return "string" == typeof a || "[object String]" == Object.prototype.toString.call(a)
};
cc.isArray = function(a) {
    return "[object Array]" == Object.prototype.toString.call(a)
};
cc.isUndefined = function(a) {
    return "undefined" == typeof a
};
cc.isObject = function(a) {
    var b = typeof a;
    return "function" == b || a && "object" == b
};
cc.isCrossOrigin = function(a) {
    if (!a) return cc.log("invalid URL"), !1;
    var b = a.indexOf("://");
    if (-1 == b) return !1;
    b = a.indexOf("/", b + 3);
    return (-1 == b ? a : a.substring(0, b)) != location.origin
};
cc.AsyncPool = function(a, b, c, d, e) {
    var f = this;
    f._srcObj = a;
    f._limit = b;
    f._pool = [];
    f._iterator = c;
    f._iteratorTarget = e;
    f._onEnd = d;
    f._onEndTarget = e;
    f._results = a instanceof Array ? [] : {};
    f._isErr = !1;
    cc.each(a, function(a, b) {
        f._pool.push({
            index: b,
            value: a
        })
    });
    f.size = f._pool.length;
    f.finishedSize = 0;
    f._workingSize = 0;
    f._limit = f._limit || f.size;
    f.onIterator = function(a, b) {
        f._iterator = a;
        f._iteratorTarget = b
    };
    f.onEnd = function(a, b) {
        f._onEnd = a;
        f._onEndTarget = b
    };
    f._handleItem = function() {
        var a = this;
        if (0 != a._pool.length && !(a._workingSize >=
            a._limit)) {
            var b = a._pool.shift(),
                c = b.value,
                d = b.index;
            a._workingSize++;
            a._iterator.call(a._iteratorTarget, c, d, function(b) {
                if (!a._isErr)
                    if (a.finishedSize++, a._workingSize--, b) a._isErr = !0, a._onEnd && a._onEnd.call(a._onEndTarget, b);
                    else {
                        var c = Array.prototype.slice.call(arguments, 1);
                        a._results[this.index] = c[0];
                        a.finishedSize == a.size ? a._onEnd && a._onEnd.call(a._onEndTarget, null, a._results) : a._handleItem()
                    }
            }.bind(b), a)
        }
    };
    f.flow = function() {
        if (0 == this._pool.length) this._onEnd && this._onEnd.call(this._onEndTarget,
            null, []);
        else
            for (var a = 0; a < this._limit; a++) this._handleItem()
    }
};
cc.async = {
    series: function(a, b, c) {
        a = new cc.AsyncPool(a, 1, function(a, b, f) {
            a.call(c, f)
        }, b, c);
        a.flow();
        return a
    },
    parallel: function(a, b, c) {
        a = new cc.AsyncPool(a, 0, function(a, b, f) {
            a.call(c, f)
        }, b, c);
        a.flow();
        return a
    },
    waterfall: function(a, b, c) {
        var d = [],
            e = [null],
            f = new cc.AsyncPool(a, 1, function(b, f, k) {
                d.push(function(b) {
                    d = Array.prototype.slice.call(arguments, 1);
                    a.length - 1 == f && (e = e.concat(d));
                    k.apply(null, arguments)
                });
                b.apply(c, d)
            }, function(a) {
                if (b) {
                    if (a) return b.call(c, a);
                    b.apply(c, e)
                }
            });
        f.flow();
        return f
    },
    map: function(a, b, c, d) {
        var e = b;
        "object" == typeof b && (c = b.cb, d = b.iteratorTarget, e = b.iterator);
        a = new cc.AsyncPool(a, 0, e, c, d);
        a.flow();
        return a
    },
    mapLimit: function(a, b, c, d, e) {
        a = new cc.AsyncPool(a, b, c, d, e);
        a.flow();
        return a
    }
};
cc.path = {
    join: function() {
        for (var a = arguments.length, b = "", c = 0; c < a; c++) b = (b + ("" == b ? "" : "/") + arguments[c]).replace(/(\/|\\\\)$/, "");
        return b
    },
    extname: function(a) {
        return (a = /(\.[^\.\/\?\\]*)(\?.*)?$/.exec(a)) ? a[1] : null
    },
    mainFileName: function(a) {
        if (a) {
            var b = a.lastIndexOf(".");
            if (-1 !== b) return a.substring(0, b)
        }
        return a
    },
    basename: function(a, b) {
        var c = a.indexOf("?");
        0 < c && (a = a.substring(0, c));
        c = /(\/|\\\\)([^(\/|\\\\)]+)$/g.exec(a.replace(/(\/|\\\\)$/, ""));
        if (!c) return null;
        c = c[2];
        return b && a.substring(a.length -
            b.length).toLowerCase() == b.toLowerCase() ? c.substring(0, c.length - b.length) : c
    },
    dirname: function(a) {
        return a.replace(/((.*)(\/|\\|\\\\))?(.*?\..*$)?/, "$2")
    },
    changeExtname: function(a, b) {
        b = b || "";
        var c = a.indexOf("?"),
            d = "";
        0 < c && (d = a.substring(c), a = a.substring(0, c));
        c = a.lastIndexOf(".");
        return 0 > c ? a + b + d : a.substring(0, c) + b + d
    },
    changeBasename: function(a, b, c) {
        if (0 == b.indexOf(".")) return this.changeExtname(a, b);
        var d = a.indexOf("?"),
            e = "";
        c = c ? this.extname(a) : "";
        0 < d && (e = a.substring(d), a = a.substring(0, d));
        d = a.lastIndexOf("/");
        return a.substring(0, 0 >= d ? 0 : d + 1) + b + c + e
    }
};
cc.loader = {
    _jsCache: {},
    _register: {},
    _langPathCache: {},
    _aliases: {},
    resPath: "",
    audioPath: "",
    cache: {},
    getXMLHttpRequest: function() {
        return window.XMLHttpRequest ? new window.XMLHttpRequest : new ActiveXObject("MSXML2.XMLHTTP")
    },
    _getArgs4Js: function(a) {
        var b = a[0],
            c = a[1],
            d = a[2],
            e = ["", null, null];
        if (1 === a.length) e[1] = b instanceof Array ? b : [b];
        else if (2 === a.length) "function" == typeof c ? (e[1] = b instanceof Array ? b : [b], e[2] = c) : (e[0] = b || "", e[1] = c instanceof Array ? c : [c]);
        else if (3 === a.length) e[0] = b || "", e[1] = c instanceof
        Array ? c : [c], e[2] = d;
        else throw "arguments error to load js!";
        return e
    },
    loadJs: function(a, b, c) {
        var d = this,
            e = d._jsCache,
            f = d._getArgs4Js(arguments),
            g = f[0],
            h = f[1],
            f = f[2]; - 1 < navigator.userAgent.indexOf("Trident/5") ? d._loadJs4Dependency(g, h, 0, f) : cc.async.map(h, function(a, b, c) {
            a = cc.path.join(g, a);
            if (e[a]) return c(null);
            d._createScript(a, !1, c)
        }, f)
    },
    loadJsWithImg: function(a, b, c) {
        var d = this._loadJsImg(),
            e = this._getArgs4Js(arguments);
        this.loadJs(e[0], e[1], function(a) {
            if (a) throw a;
            d.parentNode.removeChild(d);
            if (e[2]) e[2]()
        })
    },
    _createScript: function(a, b, c) {
        var d = document,
            e = cc.newElement("script");
        e.async = b;
        e.src = a;
        this._jsCache[a] = !0;
        cc._addEventListener(e, "load", function() {
            e.parentNode.removeChild(e);
            this.removeEventListener("load", arguments.callee, !1);
            c()
        }, !1);
        cc._addEventListener(e, "error", function() {
            e.parentNode.removeChild(e);
            c("Load " + a + " failed!")
        }, !1);
        d.body.appendChild(e)
    },
    _loadJs4Dependency: function(a, b, c, d) {
        if (c >= b.length) d && d();
        else {
            var e = this;
            e._createScript(cc.path.join(a, b[c]), !1, function(f) {
                if (f) return d(f);
                e._loadJs4Dependency(a, b, c + 1, d)
            })
        }
    },
    _loadJsImg: function() {
        var a = document,
            b = a.getElementById("cocos2d_loadJsImg");
        if (!b) {
            b = cc.newElement("img");
            cc._loadingImage && (b.src = cc._loadingImage);
            a = a.getElementById(cc.game.config.id);
            a.style.backgroundColor = "black";
            a.parentNode.appendChild(b);
            var c = getComputedStyle ? getComputedStyle(a) : a.currentStyle;
            c || (c = {
                width: a.width,
                height: a.height
            });
            b.style.left = a.offsetLeft + (parseFloat(c.width) - b.width) / 2 + "px";
            b.style.top = a.offsetTop + (parseFloat(c.height) - b.height) / 2 +
                "px";
            b.style.position = "absolute"
        }
        return b
    },
    loadTxt: function(a, b) {
        if (cc._isNodeJs) require("fs").readFile(a, function(a, c) {
            a ? b(a) : b(null, c.toString())
        });
        else {
            var c = this.getXMLHttpRequest(),
                d = "load " + a + " failed!";
            c.open("GET", a, !0);
            /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? (c.setRequestHeader("Accept-Charset", "utf-8"), c.onreadystatechange = function() {
                4 == c.readyState && (200 == c.status ? b(null, c.responseText) : b(d))
            }) : (c.overrideMimeType && c.overrideMimeType("text/plain; charset\x3dutf-8"),
                c.onload = function() {
                    4 == c.readyState && (200 == c.status ? b(null, c.responseText) : b(d))
                });
            c.send(null)
        }
    },
    _loadTxtSync: function(a) {
        if (cc._isNodeJs) return require("fs").readFileSync(a).toString();
        var b = this.getXMLHttpRequest();
        b.open("GET", a, !1);
        /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? b.setRequestHeader("Accept-Charset", "utf-8") : b.overrideMimeType && b.overrideMimeType("text/plain; charset\x3dutf-8");
        b.send(null);
        return 4 == !b.readyState || 200 != b.status ? null : b.responseText
    },
    loadCsb: function(a,
        b) {
        var c = new XMLHttpRequest;
        c.open("GET", a, !0);
        c.responseType = "arraybuffer";
        c.onload = function() {
            var d = c.response;
            d && (window.msg = d);
            4 == c.readyState && (200 == c.status ? b(null, c.response) : b("load " + a + " failed!"))
        };
        c.send(null)
    },
    loadJson: function(a, b) {
        this.loadTxt(a, function(c, d) {
            try {
                c ? b(c) : b(null, JSON.parse(d))
            } catch (e) {
                throw "load json [" + a + "] failed : " + e;
            }
        })
    },
    _checkIsImageURL: function(a) {
        return null != /(\.png)|(\.jpg)|(\.bmp)|(\.jpeg)|(\.gif)/.exec(a)
    },
    loadImg: function(a, b, c) {
        var d = {
            isCrossOrigin: !0
        };
        void 0 !== c ? d.isCrossOrigin = null == b.isCrossOrigin ? d.isCrossOrigin : b.isCrossOrigin : void 0 !== b && (c = b);
        var e = new Image;
        d.isCrossOrigin && "file://" != location.origin && (e.crossOrigin = "Anonymous");
        var f = function() {
                this.removeEventListener("load", f, !1);
                this.removeEventListener("error", g, !1);
                c && c(null, e)
            },
            g = function() {
                this.removeEventListener("error", g, !1);
                e.crossOrigin && "anonymous" == e.crossOrigin.toLowerCase() ? (d.isCrossOrigin = !1, cc.loader.loadImg(a, d, c)) : "function" == typeof c && c("load image failed")
            };
        cc._addEventListener(e,
            "load", f);
        cc._addEventListener(e, "error", g);
        e.src = a;
        return e
    },
    _loadResIterator: function(a, b, c) {
        var d = this,
            e = null,
            f = a.type;
        f ? (f = "." + f.toLowerCase(), e = a.src ? a.src : a.name + f) : (e = a, f = cc.path.extname(e));
        if (b = d.cache[e]) return c(null, b);
        b = null;
        f && (b = d._register[f.toLowerCase()]);
        if (!b) return cc.error("loader for [" + f + "] not exists!"), c();
        f = b.getBasePath ? b.getBasePath() : d.resPath;
        f = d.getUrl(f, e);
        b.load(f, e, a, function(a, b) {
            a ? (cc.log(a), d.cache[e] = null, delete d.cache[e], c()) : (d.cache[e] = b, c(null, b))
        })
    },
    getUrl: function(a,
        b) {
        var c = this._langPathCache,
            d = cc.path;
        if (void 0 !== a && void 0 === b) {
            b = a;
            var e = d.extname(b),
                e = e ? e.toLowerCase() : "";
            a = (e = this._register[e]) ? e.getBasePath ? e.getBasePath() : this.resPath : this.resPath
        }
        b = cc.path.join(a || "", b);
        if (b.match(/[\/(\\\\)]lang[\/(\\\\)]/i)) {
            if (c[b]) return c[b];
            d = d.extname(b) || "";
            b = c[b] = b.substring(0, b.length - d.length) + "_" + cc.sys.language + d
        }
        return b
    },
    load: function(a, b, c) {
        var d = this,
            e = arguments.length;
        if (0 == e) throw "arguments error!";
        3 == e ? "function" == typeof b && (b = "function" == typeof c ? {
            trigger: b,
            cb: c
        } : {
            cb: b,
            cbTarget: c
        }) : 2 == e ? "function" == typeof b && (b = {
            cb: b
        }) : 1 == e && (b = {});
        a instanceof Array || (a = [a]);
        e = new cc.AsyncPool(a, 0, function(a, c, e, k) {
            d._loadResIterator(a, c, function(a) {
                if (a) return e(a);
                var c = Array.prototype.slice.call(arguments, 1);
                b.trigger && b.trigger.call(b.triggerTarget, c[0], k.size, k.finishedSize);
                e(null, c[0])
            })
        }, b.cb, b.cbTarget);
        e.flow();
        return e
    },
    _handleAliases: function(a, b) {
        var c = this._aliases,
            d = [],
            e;
        for (e in a) {
            var f = a[e];
            c[e] = f;
            d.push(f)
        }
        this.load(d, b)
    },
    loadAliases: function(a,
        b) {
        var c = this,
            d = c.getRes(a);
        d ? c._handleAliases(d.filenames, b) : c.load(a, function(a, d) {
            c._handleAliases(d[0].filenames, b)
        })
    },
    register: function(a, b) {
        if (a && b) {
            if ("string" == typeof a) return this._register[a.trim().toLowerCase()] = b;
            for (var c = 0, d = a.length; c < d; c++) this._register["." + a[c].trim().toLowerCase()] = b
        }
    },
    getRes: function(a) {
        return this.cache[a] || this.cache[this._aliases[a]]
    },
    release: function(a) {
        var b = this.cache,
            c = this._aliases;
        delete b[a];
        delete b[c[a]];
        delete c[a]
    },
    releaseAll: function() {
        var a = this.cache,
            b = this._aliases,
            c;
        for (c in a) delete a[c];
        for (c in b) delete b[c]
    }
};
cc.formatStr = function() {
    var a = arguments,
        b = a.length;
    if (1 > b) return "";
    var c = a[0],
        d = !0;
    "object" == typeof c && (d = !1);
    for (var e = 1; e < b; ++e) {
        var f = a[e];
        if (d)
            for (;;) {
                var g = null;
                if ("number" == typeof f && (g = c.match(/(%d)|(%s)/))) {
                    c = c.replace(/(%d)|(%s)/, f);
                    break
                }
                c = (g = c.match(/%s/)) ? c.replace(/%s/, f) : c + ("    " + f);
                break
            } else c += "    " + f
    }
    return c
};
(function() {
    var a = window,
        b, c;
    cc.isUndefined(document.hidden) ? cc.isUndefined(document.mozHidden) ? cc.isUndefined(document.msHidden) ? cc.isUndefined(document.webkitHidden) || (b = "webkitHidden", c = "webkitvisibilitychange") : (b = "msHidden", c = "msvisibilitychange") : (b = "mozHidden", c = "mozvisibilitychange") : (b = "hidden", c = "visibilitychange");
    var d = function() {
            cc.eventManager && cc.game._eventHide && cc.eventManager.dispatchEvent(cc.game._eventHide)
        },
        e = function() {
            cc.eventManager && cc.game._eventShow && cc.eventManager.dispatchEvent(cc.game._eventShow);
            cc.game._intervalId && (window.cancelAnimationFrame(cc.game._intervalId), cc.game._runMainLoop())
        };
    b ? cc._addEventListener(document, c, function() {
        document[b] ? d() : e()
    }, !1) : (cc._addEventListener(a, "blur", d, !1), cc._addEventListener(a, "focus", e, !1)); - 1 < navigator.userAgent.indexOf("MicroMessenger") && (a.onfocus = function() {
        e()
    });
    "onpageshow" in window && "onpagehide" in window && (cc._addEventListener(a, "pagehide", d, !1), cc._addEventListener(a, "pageshow", e, !1));
    c = a = null
})();
cc.log = cc.warn = cc.error = cc.assert = function() {};
cc.create3DContext = function(a, b) {
    for (var c = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"], d = null, e = 0; e < c.length; ++e) {
        try {
            d = a.getContext(c[e], b)
        } catch (f) {}
        if (d) break
    }
    return d
};
cc._initSys = function(a, b) {
    cc._RENDER_TYPE_CANVAS = 0;
    cc._RENDER_TYPE_WEBGL = 1;
    cc.sys = {};
    var c = cc.sys;
    c.LANGUAGE_ENGLISH = "en";
    c.LANGUAGE_CHINESE = "zh";
    c.LANGUAGE_FRENCH = "fr";
    c.LANGUAGE_ITALIAN = "it";
    c.LANGUAGE_GERMAN = "de";
    c.LANGUAGE_SPANISH = "es";
    c.LANGUAGE_DUTCH = "du";
    c.LANGUAGE_RUSSIAN = "ru";
    c.LANGUAGE_KOREAN = "ko";
    c.LANGUAGE_JAPANESE = "ja";
    c.LANGUAGE_HUNGARIAN = "hu";
    c.LANGUAGE_PORTUGUESE = "pt";
    c.LANGUAGE_ARABIC = "ar";
    c.LANGUAGE_NORWEGIAN = "no";
    c.LANGUAGE_POLISH = "pl";
    c.OS_WINDOWS = "Windows";
    c.OS_IOS = "iOS";
    c.OS_OSX =
        "OS X";
    c.OS_UNIX = "UNIX";
    c.OS_LINUX = "Linux";
    c.OS_ANDROID = "Android";
    c.OS_UNKNOWN = "Unknown";
    c.WINDOWS = 0;
    c.LINUX = 1;
    c.MACOS = 2;
    c.ANDROID = 3;
    c.IPHONE = 4;
    c.IPAD = 5;
    c.BLACKBERRY = 6;
    c.NACL = 7;
    c.EMSCRIPTEN = 8;
    c.TIZEN = 9;
    c.WINRT = 10;
    c.WP8 = 11;
    c.MOBILE_BROWSER = 100;
    c.DESKTOP_BROWSER = 101;
    c.BROWSER_TYPE_WECHAT = "wechat";
    c.BROWSER_TYPE_ANDROID = "androidbrowser";
    c.BROWSER_TYPE_IE = "ie";
    c.BROWSER_TYPE_QQ = "qqbrowser";
    c.BROWSER_TYPE_MOBILE_QQ = "mqqbrowser";
    c.BROWSER_TYPE_UC = "ucbrowser";
    c.BROWSER_TYPE_360 = "360browser";
    c.BROWSER_TYPE_BAIDU_APP =
        "baiduboxapp";
    c.BROWSER_TYPE_BAIDU = "baidubrowser";
    c.BROWSER_TYPE_MAXTHON = "maxthon";
    c.BROWSER_TYPE_OPERA = "opera";
    c.BROWSER_TYPE_OUPENG = "oupeng";
    c.BROWSER_TYPE_MIUI = "miuibrowser";
    c.BROWSER_TYPE_FIREFOX = "firefox";
    c.BROWSER_TYPE_SAFARI = "safari";
    c.BROWSER_TYPE_CHROME = "chrome";
    c.BROWSER_TYPE_UNKNOWN = "unknown";
    c.isNative = !1;
    var d = [c.BROWSER_TYPE_BAIDU, c.BROWSER_TYPE_OPERA, c.BROWSER_TYPE_FIREFOX, c.BROWSER_TYPE_CHROME, c.BROWSER_TYPE_SAFARI],
        e = [c.OS_IOS, c.OS_WINDOWS, c.OS_OSX, c.OS_LINUX],
        f = [c.BROWSER_TYPE_BAIDU,
            c.BROWSER_TYPE_OPERA, c.BROWSER_TYPE_FIREFOX, c.BROWSER_TYPE_CHROME, c.BROWSER_TYPE_BAIDU_APP, c.BROWSER_TYPE_SAFARI, c.BROWSER_TYPE_UC, c.BROWSER_TYPE_QQ, c.BROWSER_TYPE_MOBILE_QQ, c.BROWSER_TYPE_IE
        ],
        g = window,
        h = g.navigator,
        k = document.documentElement,
        m = h.userAgent.toLowerCase();
    c.isMobile = -1 != m.indexOf("mobile") || -1 != m.indexOf("android");
    c.platform = c.isMobile ? c.MOBILE_BROWSER : c.DESKTOP_BROWSER;
    var n = h.language,
        n = (n = n ? n : h.browserLanguage) ? n.split("-")[0] : c.LANGUAGE_ENGLISH;
    c.language = n;
    var n = c.BROWSER_TYPE_UNKNOWN,
        q = m.match(/micromessenger|qqbrowser|mqqbrowser|ucbrowser|360browser|baiduboxapp|baidubrowser|maxthon|trident|oupeng|opera|miuibrowser|firefox/i) || m.match(/chrome|safari/i);
    q && 0 < q.length && (n = q[0].toLowerCase(), "micromessenger" == n ? n = c.BROWSER_TYPE_WECHAT : "safari" === n && m.match(/android.*applewebkit/) ? n = c.BROWSER_TYPE_ANDROID : "trident" == n && (n = c.BROWSER_TYPE_IE));
    c.browserType = n;
    n = m.match(/(iPad|iPhone|iPod)/i) ? !0 : !1;
    m = m.match(/android/i) || h.platform.match(/android/i) ? !0 : !1;
    q = c.OS_UNKNOWN; - 1 != h.appVersion.indexOf("Win") ?
        q = c.OS_WINDOWS : n ? q = c.OS_IOS : -1 != h.appVersion.indexOf("Mac") ? q = c.OS_OSX : -1 != h.appVersion.indexOf("X11") ? q = c.OS_UNIX : m ? q = c.OS_ANDROID : -1 != h.appVersion.indexOf("Linux") && (q = c.OS_LINUX);
    c.os = q;
    c._supportMultipleAudio = -1 < f.indexOf(c.browserType);
    f = parseInt(a[b.renderMode]);
    m = cc._RENDER_TYPE_WEBGL;
    n = cc.newElement("Canvas");
    cc._supportRender = !0;
    d = !window.WebGLRenderingContext || -1 == d.indexOf(c.browserType) || -1 == e.indexOf(c.os);
    if (1 === f || 0 === f && d || "file://" == location.origin) m = cc._RENDER_TYPE_CANVAS;
    c._canUseCanvasNewBlendModes =
        function() {
            var a = document.createElement("canvas");
            a.width = 1;
            a.height = 1;
            a = a.getContext("2d");
            a.fillStyle = "#000";
            a.fillRect(0, 0, 1, 1);
            a.globalCompositeOperation = "multiply";
            var b = document.createElement("canvas");
            b.width = 1;
            b.height = 1;
            var c = b.getContext("2d");
            c.fillStyle = "#fff";
            c.fillRect(0, 0, 1, 1);
            a.drawImage(b, 0, 0, 1, 1);
            return 0 === a.getImageData(0, 0, 1, 1).data[0]
        };
    c._supportCanvasNewBlendModes = c._canUseCanvasNewBlendModes();
    if (m == cc._RENDER_TYPE_WEBGL && (!g.WebGLRenderingContext || !cc.create3DContext(n, {
        stencil: !0,
        preserveDrawingBuffer: !0
    }))) 0 == f ? m = cc._RENDER_TYPE_CANVAS : cc._supportRender = !1;
    if (m == cc._RENDER_TYPE_CANVAS) try {
        n.getContext("2d")
    } catch (r) {
        cc._supportRender = !1
    }
    cc._renderType = m;
    try {
        c._supportWebAudio = !!new(g.AudioContext || g.webkitAudioContext || g.mozAudioContext)
    } catch (s) {
        c._supportWebAudio = !1
    }
    try {
        var t = c.localStorage = g.localStorage;
        t.setItem("storage", "");
        t.removeItem("storage");
        t = null
    } catch (u) {
        ("SECURITY_ERR" === u.name || "QuotaExceededError" === u.name) && cc.warn("Warning: localStorage isn't enabled. Please confirm browser cookie or privacy option"),
            c.localStorage = function() {}
    }
    t = c.capabilities = {
        canvas: !0
    };
    cc._renderType == cc._RENDER_TYPE_WEBGL && (t.opengl = !0);
    if (void 0 !== k.ontouchstart || h.msPointerEnabled) t.touches = !0;
    void 0 !== k.onmouseup && (t.mouse = !0);
    void 0 !== k.onkeyup && (t.keyboard = !0);
    if (g.DeviceMotionEvent || g.DeviceOrientationEvent) t.accelerometer = !0;
    c.garbageCollect = function() {};
    c.dumpRoot = function() {};
    c.restartVM = function() {};
    c.dump = function() {
        var a;
        a = "" + ("isMobile : " + this.isMobile + "\r\n");
        a += "language : " + this.language + "\r\n";
        a += "browserType : " +
            this.browserType + "\r\n";
        a += "capabilities : " + JSON.stringify(this.capabilities) + "\r\n";
        a += "os : " + this.os + "\r\n";
        a += "platform : " + this.platform + "\r\n";
        cc.log(a)
    }
};
cc.ORIENTATION_PORTRAIT = 0;
cc.ORIENTATION_PORTRAIT_UPSIDE_DOWN = 1;
cc.ORIENTATION_LANDSCAPE_LEFT = 2;
cc.ORIENTATION_LANDSCAPE_RIGHT = 3;
cc._drawingUtil = null;
cc._renderContext = null;
cc._canvas = null;
cc._gameDiv = null;
cc._rendererInitialized = !1;
cc._setupCalled = !1;
cc._setup = function(a, b, c) {
    if (!cc._setupCalled) {
        cc._setupCalled = !0;
        var d = window,
            e = new Date,
            f = 1E3 / cc.game.config[cc.game.CONFIG_KEY.frameRate],
            g = function(a) {
                var b = (new Date).getTime(),
                    c = Math.max(0, f - (b - e)),
                    d = window.setTimeout(function() {
                        a()
                    }, c);
                e = b + c;
                return d
            },
            h = function(a) {
                clearTimeout(a)
            };
        cc.sys.os === cc.sys.OS_IOS && cc.sys.browserType === cc.sys.BROWSER_TYPE_WECHAT ? (d.requestAnimFrame = g, d.cancelAnimationFrame = h) : 60 != cc.game.config[cc.game.CONFIG_KEY.frameRate] ? (d.requestAnimFrame = g, d.cancelAnimationFrame =
            h) : (d.requestAnimFrame = d.requestAnimationFrame || d.webkitRequestAnimationFrame || d.mozRequestAnimationFrame || d.oRequestAnimationFrame || d.msRequestAnimationFrame || g, d.cancelAnimationFrame = window.cancelAnimationFrame || window.cancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame ||
            window.oCancelAnimationFrame || h);
        h = cc.$(a) || cc.$("#" + a);
        "CANVAS" == h.tagName ? (b = b || h.width, c = c || h.height, g = cc.container = cc.newElement("DIV"), a = cc._canvas = h, a.parentNode.insertBefore(g, a), a.appendTo(g), g.setAttribute("id", "Cocos2dGameContainer")) : ("DIV" != h.tagName && cc.log("Warning: target element is not a DIV or CANVAS"), b = b || h.clientWidth, c = c || h.clientHeight, g = cc.container = h, a = cc._canvas = cc.$(cc.newElement("CANVAS")), h.appendChild(a));
        a.addClass("gameCanvas");
        a.setAttribute("width", b || 480);
        a.setAttribute("height",
            c || 320);
        a.setAttribute("tabindex", 99);
        a.style.outline = "none";
        h = g.style;
        h.width = (b || 480) + "px";
        h.height = (c || 320) + "px";
        h.margin = "0 auto";
        h.position = "relative";
        h.overflow = "hidden";
        g.top = "100%";
        cc._renderType == cc._RENDER_TYPE_WEBGL && (cc._renderContext = cc.webglContext = cc.create3DContext(a, {
            stencil: !0,
            preserveDrawingBuffer: !0,
            antialias: !cc.sys.isMobile,
            alpha: !1
        }));
        cc._renderContext ? (d.gl = cc._renderContext, cc._drawingUtil = new cc.DrawingPrimitiveWebGL(cc._renderContext), cc._rendererInitialized = !0, cc.textureCache._initializingRenderer(),
            cc.shaderCache._init()) : (cc._renderContext = a.getContext("2d"), cc._mainRenderContextBackup = cc._renderContext, cc._renderContext.translate(0, a.height), cc._drawingUtil = cc.DrawingPrimitiveCanvas ? new cc.DrawingPrimitiveCanvas(cc._renderContext) : null);
        cc._gameDiv = g;
        cc.log(cc.ENGINE_VERSION);
        cc._setContextMenuEnable(!1);
        cc.sys.isMobile && (b = cc.newElement("style"), b.type = "text/css", document.body.appendChild(b), b.textContent = "body,canvas,div{ -moz-user-select: none;-webkit-user-select: none;-ms-user-select: none;-khtml-user-select: none;-webkit-tap-highlight-color:rgba(0,0,0,0);}");
        cc.view = cc.EGLView._getInstance();
        cc.inputManager.registerSystemEvent(cc._canvas);
        cc.director = cc.Director._getInstance();
        cc.director.setOpenGLView && cc.director.setOpenGLView(cc.view);
        cc.winSize = cc.director.getWinSize();
        cc.saxParser = new cc.SAXParser;
        cc.plistParser = new cc.PlistParser
    }
};
cc._checkWebGLRenderMode = function() {
    if (cc._renderType !== cc._RENDER_TYPE_WEBGL) throw "This feature supports WebGL render mode only.";
};
cc._isContextMenuEnable = !1;
cc._setContextMenuEnable = function(a) {
    cc._isContextMenuEnable = a;
    cc._canvas.oncontextmenu = function() {
        if (!cc._isContextMenuEnable) return !1
    }
};
cc.game = {
    DEBUG_MODE_NONE: 0,
    DEBUG_MODE_INFO: 1,
    DEBUG_MODE_WARN: 2,
    DEBUG_MODE_ERROR: 3,
    DEBUG_MODE_INFO_FOR_WEB_PAGE: 4,
    DEBUG_MODE_WARN_FOR_WEB_PAGE: 5,
    DEBUG_MODE_ERROR_FOR_WEB_PAGE: 6,
    EVENT_HIDE: "game_on_hide",
    EVENT_SHOW: "game_on_show",
    _eventHide: null,
    _eventShow: null,
    _onBeforeStartArr: [],
    CONFIG_KEY: {
        engineDir: "engineDir",
        dependencies: "dependencies",
        debugMode: "debugMode",
        showFPS: "showFPS",
        frameRate: "frameRate",
        id: "id",
        renderMode: "renderMode",
        jsList: "jsList",
        classReleaseMode: "classReleaseMode"
    },
    _prepareCalled: !1,
    _prepared: !1,
    _paused: !0,
    _intervalId: null,
    config: null,
    onStart: null,
    onStop: null,
    setFrameRate: function(a) {
        this.config[this.CONFIG_KEY.frameRate] = a;
        this._intervalId && window.cancelAnimationFrame(this._intervalId);
        this._paused = !0;
        this._runMainLoop()
    },
    _runMainLoop: function() {
        var a = this,
            b, c = cc.director;
        c.setDisplayStats(a.config[a.CONFIG_KEY.showFPS]);
        b = function() {
            a._paused || (c.mainLoop(), a._intervalId && window.cancelAnimationFrame(a._intervalId), a._intervalId = window.requestAnimFrame(b))
        };
        window.requestAnimFrame(b);
        a._paused = !1
    },
    run: function(a) {
        var b = this,
            c = function() {
                a && (b.config[b.CONFIG_KEY.id] = a);
                b._prepareCalled || b.prepare(function() {
                    b._prepared = !0
                });
                cc._supportRender && (b._checkPrepare = setInterval(function() {
                    b._prepared && (cc._setup(b.config[b.CONFIG_KEY.id]), b._runMainLoop(), b._eventHide = b._eventHide || new cc.EventCustom(b.EVENT_HIDE), b._eventHide.setUserData(b), b._eventShow = b._eventShow || new cc.EventCustom(b.EVENT_SHOW), b._eventShow.setUserData(b), b.onStart(), clearInterval(b._checkPrepare))
                }, 10))
            };
        document.body ?
            c() : cc._addEventListener(window, "load", function() {
                this.removeEventListener("load", arguments.callee, !1);
                c()
            }, !1)
    },
    _initConfig: function() {
        var a = this.CONFIG_KEY,
            b = function(b) {
                b[a.engineDir] = b[a.engineDir] || "frameworks/cocos2d-html5";
                null == b[a.debugMode] && (b[a.debugMode] = 0);
                b[a.frameRate] = b[a.frameRate] || 60;
                null == b[a.renderMode] && (b[a.renderMode] = 1);
                return b
            };
        if (document.ccConfig) this.config = b(document.ccConfig);
        else try {
            for (var c = document.getElementsByTagName("script"), d = 0; d < c.length; d++) {
                var e = c[d].getAttribute("cocos");
                if ("" == e || e) break
            }
            var f, g, h;
            if (d < c.length) {
                if (f = c[d].src) h = /(.*)\//.exec(f)[0], cc.loader.resPath = h, f = cc.path.join(h, "project.json");
                g = cc.loader._loadTxtSync(f)
            }
            g || (g = cc.loader._loadTxtSync("project.json"));
            var k = JSON.parse(g);
            this.config = b(k || {})
        } catch (m) {
            cc.log("Failed to read or parse project.json"), this.config = b({})
        }
        cc._initSys(this.config, a)
    },
    _jsAddedCache: {},
    _getJsListOfModule: function(a, b, c) {
        var d = this._jsAddedCache;
        if (d[b]) return null;
        c = c || "";
        var e = [],
            f = a[b];
        if (!f) throw "can not find module [" +
            b + "]";
        b = cc.path;
        for (var g = 0, h = f.length; g < h; g++) {
            var k = f[g];
            if (!d[k]) {
                var m = b.extname(k);
                m ? ".js" == m.toLowerCase() && e.push(b.join(c, k)) : (m = this._getJsListOfModule(a, k, c)) && (e = e.concat(m));
                d[k] = 1
            }
        }
        return e
    },
    prepare: function(a) {
        var b = this,
            c = b.config,
            d = b.CONFIG_KEY,
            e = c[d.engineDir],
            f = cc.loader;
        if (!cc._supportRender) throw "The renderer doesn't support the renderMode " + c[d.renderMode];
        b._prepareCalled = !0;
        var g = c[d.jsList] || [];
        cc.Class ? f.loadJsWithImg("", g, function(c) {
                if (c) throw c;
                b._prepared = !0;
                a && a()
            }) :
            (d = cc.path.join(e, "moduleConfig.json"), f.loadJson(d, function(d, f) {
                if (d) throw d;
                var m = c.modules || [],
                    n = f.module,
                    q = [];
                cc._renderType == cc._RENDER_TYPE_WEBGL ? m.splice(0, 0, "shaders") : 0 > m.indexOf("core") && m.splice(0, 0, "core");
                for (var r = 0, s = m.length; r < s; r++) {
                    var t = b._getJsListOfModule(n, m[r], e);
                    t && (q = q.concat(t))
                }
                q = q.concat(g);
                cc.loader.loadJsWithImg(q, function(c) {
                    if (c) throw c;
                    b._prepared = !0;
                    a && a()
                })
            }))
    }
};
cc.game._initConfig();
Function.prototype.bind = Function.prototype.bind || function(a) {
    if (!cc.isFunction(this)) throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
    var b = Array.prototype.slice.call(arguments, 1),
        c = this,
        d = function() {},
        e = function() {
            return c.apply(this instanceof d && a ? this : a, b.concat(Array.prototype.slice.call(arguments)))
        };
    d.prototype = this.prototype;
    e.prototype = new d;
    return e
};
cc._LogInfos = {
    ActionManager_addAction: "cc.ActionManager.addAction(): action must be non-null",
    ActionManager_removeAction: "cocos2d: removeAction: Target not found",
    ActionManager_removeActionByTag: "cc.ActionManager.removeActionByTag(): an invalid tag",
    ActionManager_removeActionByTag_2: "cc.ActionManager.removeActionByTag(): target must be non-null",
    ActionManager_getActionByTag: "cc.ActionManager.getActionByTag(): an invalid tag",
    ActionManager_getActionByTag_2: "cocos2d : getActionByTag(tag \x3d %s): Action not found",
    configuration_dumpInfo: "cocos2d: **** WARNING **** CC_ENABLE_PROFILERS is defined. Disable it when you finish profiling (from ccConfig.js)",
    configuration_loadConfigFile: "Expected 'data' dict, but not found. Config file: %s",
    configuration_loadConfigFile_2: "Please load the resource first : %s",
    Director_resume: "cocos2d: Director: Error in gettimeofday",
    Director_setProjection: "cocos2d: Director: unrecognized projection",
    Director_popToSceneStackLevel: "cocos2d: Director: unrecognized projection",
    Director_popToSceneStackLevel_2: "cocos2d: Director: Error in gettimeofday",
    Director_popScene: "running scene should not null",
    Director_pushScene: "the scene should not null",
    arrayVerifyType: "element type is wrong!",
    Scheduler_scheduleCallbackForTarget: "CCSheduler#scheduleCallback. Callback already scheduled. Updating interval from:%s to %s",
    Scheduler_scheduleCallbackForTarget_2: "cc.scheduler.scheduleCallbackForTarget(): callback_fn should be non-null.",
    Scheduler_scheduleCallbackForTarget_3: "cc.scheduler.scheduleCallbackForTarget(): target should be non-null.",
    Scheduler_pauseTarget: "cc.Scheduler.pauseTarget():target should be non-null",
    Scheduler_resumeTarget: "cc.Scheduler.resumeTarget():target should be non-null",
    Scheduler_isTargetPaused: "cc.Scheduler.isTargetPaused():target should be non-null",
    Node_getZOrder: "getZOrder is deprecated. Please use getLocalZOrder instead.",
    Node_setZOrder: "setZOrder is deprecated. Please use setLocalZOrder instead.",
    Node_getRotation: "RotationX !\x3d RotationY. Don't know which one to return",
    Node_getScale: "ScaleX !\x3d ScaleY. Don't know which one to return",
    Node_addChild: "An Node can't be added as a child of itself.",
    Node_addChild_2: "child already added. It can't be added again",
    Node_addChild_3: "child must be non-null",
    Node_removeFromParentAndCleanup: "removeFromParentAndCleanup is deprecated. Use removeFromParent instead",
    Node_boundingBox: "boundingBox is deprecated. Use getBoundingBox instead",
    Node_removeChildByTag: "argument tag is an invalid tag",
    Node_removeChildByTag_2: "cocos2d: removeChildByTag(tag \x3d %s): child not found!",
    Node_removeAllChildrenWithCleanup: "removeAllChildrenWithCleanup is deprecated. Use removeAllChildren instead",
    Node_stopActionByTag: "cc.Node.stopActionBy(): argument tag an invalid tag",
    Node_getActionByTag: "cc.Node.getActionByTag(): argument tag is an invalid tag",
    Node_resumeSchedulerAndActions: "resumeSchedulerAndActions is deprecated, please use resume instead.",
    Node_pauseSchedulerAndActions: "pauseSchedulerAndActions is deprecated, please use pause instead.",
    Node__arrayMakeObjectsPerformSelector: "Unknown callback function",
    Node_reorderChild: "child must be non-null",
    Node_runAction: "cc.Node.runAction(): action must be non-null",
    Node_schedule: "callback function must be non-null",
    Node_schedule_2: "interval must be positive",
    Node_initWithTexture: "cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.",
    AtlasNode_updateAtlasValues: "cc.AtlasNode.updateAtlasValues(): Shall be overridden in subclasses",
    AtlasNode_initWithTileFile: "",
    AtlasNode__initWithTexture: "cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.",
    _EventListenerKeyboard_checkAvailable: "cc._EventListenerKeyboard.checkAvailable(): Invalid EventListenerKeyboard!",
    _EventListenerTouchOneByOne_checkAvailable: "cc._EventListenerTouchOneByOne.checkAvailable(): Invalid EventListenerTouchOneByOne!",
    _EventListenerTouchAllAtOnce_checkAvailable: "cc._EventListenerTouchAllAtOnce.checkAvailable(): Invalid EventListenerTouchAllAtOnce!",
    _EventListenerAcceleration_checkAvailable: "cc._EventListenerAcceleration.checkAvailable(): _onAccelerationEvent must be non-nil",
    EventListener_create: "Invalid parameter.",
    __getListenerID: "Don't call this method if the event is for touch.",
    eventManager__forceAddEventListener: "Invalid scene graph priority!",
    eventManager_addListener: "0 priority is forbidden for fixed priority since it's used for scene graph based priority.",
    eventManager_removeListeners: "Invalid listener type!",
    eventManager_setPriority: "Can't set fixed priority with scene graph based listener.",
    eventManager_addListener_2: "Invalid parameters.",
    eventManager_addListener_3: "listener must be a cc.EventListener object when adding a fixed priority listener",
    eventManager_addListener_4: "The listener has been registered, please don't register it again.",
    LayerMultiplex_initWithLayers: "parameters should not be ending with null in Javascript",
    LayerMultiplex_switchTo: "Invalid index in MultiplexLayer switchTo message",
    LayerMultiplex_switchToAndReleaseMe: "Invalid index in MultiplexLayer switchTo message",
    LayerMultiplex_addLayer: "cc.Layer.addLayer(): layer should be non-null",
    EGLView_setDesignResolutionSize: "Resolution not valid",
    EGLView_setDesignResolutionSize_2: "should set resolutionPolicy",
    inputManager_handleTouchesBegin: "The touches is more than MAX_TOUCHES, nUnusedIndex \x3d %s",
    swap: "cc.swap is being modified from original macro, please check usage",
    checkGLErrorDebug: "WebGL error %s",
    animationCache__addAnimationsWithDictionary: "cocos2d: cc.AnimationCache: No animations were found in provided dictionary.",
    animationCache__addAnimationsWithDictionary_2: "cc.AnimationCache. Invalid animation format",
    animationCache_addAnimations: "cc.AnimationCache.addAnimations(): File could not be found",
    animationCache__parseVersion1: "cocos2d: cc.AnimationCache: Animation '%s' found in dictionary without any frames - cannot add to animation cache.",
    animationCache__parseVersion1_2: "cocos2d: cc.AnimationCache: Animation '%s' refers to frame '%s' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.",
    animationCache__parseVersion1_3: "cocos2d: cc.AnimationCache: None of the frames for animation '%s' were found in the cc.SpriteFrameCache. Animation is not being added to the Animation Cache.",
    animationCache__parseVersion1_4: "cocos2d: cc.AnimationCache: An animation in your dictionary refers to a frame which is not in the cc.SpriteFrameCache. Some or all of the frames for the animation '%s' may be missing.",
    animationCache__parseVersion2: "cocos2d: CCAnimationCache: Animation '%s' found in dictionary without any frames - cannot add to animation cache.",
    animationCache__parseVersion2_2: "cocos2d: cc.AnimationCache: Animation '%s' refers to frame '%s' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.",
    animationCache_addAnimations_2: "cc.AnimationCache.addAnimations(): Invalid texture file name",
    Sprite_reorderChild: "cc.Sprite.reorderChild(): this child is not in children list",
    Sprite_ignoreAnchorPointForPosition: "cc.Sprite.ignoreAnchorPointForPosition(): it is invalid in cc.Sprite when using SpriteBatchNode",
    Sprite_setDisplayFrameWithAnimationName: "cc.Sprite.setDisplayFrameWithAnimationName(): Frame not found",
    Sprite_setDisplayFrameWithAnimationName_2: "cc.Sprite.setDisplayFrameWithAnimationName(): Invalid frame index",
    Sprite_setDisplayFrame: "setDisplayFrame is deprecated, please use setSpriteFrame instead.",
    Sprite__updateBlendFunc: "cc.Sprite._updateBlendFunc(): _updateBlendFunc doesn't work when the sprite is rendered using a cc.CCSpriteBatchNode",
    Sprite_initWithSpriteFrame: "cc.Sprite.initWithSpriteFrame(): spriteFrame should be non-null",
    Sprite_initWithSpriteFrameName: "cc.Sprite.initWithSpriteFrameName(): spriteFrameName should be non-null",
    Sprite_initWithSpriteFrameName1: " is null, please check.",
    Sprite_initWithFile: "cc.Sprite.initWithFile(): filename should be non-null",
    Sprite_setDisplayFrameWithAnimationName_3: "cc.Sprite.setDisplayFrameWithAnimationName(): animationName must be non-null",
    Sprite_reorderChild_2: "cc.Sprite.reorderChild(): child should be non-null",
    Sprite_addChild: "cc.Sprite.addChild(): cc.Sprite only supports cc.Sprites as children when using cc.SpriteBatchNode",
    Sprite_addChild_2: "cc.Sprite.addChild(): cc.Sprite only supports a sprite using same texture as children when using cc.SpriteBatchNode",
    Sprite_addChild_3: "cc.Sprite.addChild(): child should be non-null",
    Sprite_setTexture: "cc.Sprite.texture setter: Batched sprites should use the same texture as the batchnode",
    Sprite_updateQuadFromSprite: "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    Sprite_insertQuadFromSprite: "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    Sprite_addChild_4: "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children",
    Sprite_addChild_5: "cc.SpriteBatchNode.addChild(): cc.Sprite is not using the same texture",
    Sprite_initWithTexture: "Sprite.initWithTexture(): Argument must be non-nil ",
    Sprite_setSpriteFrame: "Invalid spriteFrameName",
    Sprite_setTexture_2: "Invalid argument: cc.Sprite.texture setter expects a CCTexture2D.",
    Sprite_updateQuadFromSprite_2: "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
    Sprite_insertQuadFromSprite_2: "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null",
    Sprite_addChild_6: "cc.SpriteBatchNode.addChild(): child should be non-null",
    SpriteBatchNode_addSpriteWithoutQuad: "cc.SpriteBatchNode.addQuadFromSprite(): SpriteBatchNode only supports cc.Sprites as children",
    SpriteBatchNode_increaseAtlasCapacity: "cocos2d: CCSpriteBatchNode: resizing TextureAtlas capacity from %s to %s.",
    SpriteBatchNode_increaseAtlasCapacity_2: "cocos2d: WARNING: Not enough memory to resize the atlas",
    SpriteBatchNode_reorderChild: "cc.SpriteBatchNode.addChild(): Child doesn't belong to Sprite",
    SpriteBatchNode_removeChild: "cc.SpriteBatchNode.addChild(): sprite batch node should contain the child",
    SpriteBatchNode_addSpriteWithoutQuad_2: "cc.SpriteBatchNode.addQuadFromSprite(): child should be non-null",
    SpriteBatchNode_reorderChild_2: "cc.SpriteBatchNode.addChild():child should be non-null",
    spriteFrameCache__getFrameConfig: "cocos2d: WARNING: originalWidth/Height not found on the cc.SpriteFrame. AnchorPoint won't work as expected. Regenrate the .plist",
    spriteFrameCache_addSpriteFrames: "cocos2d: WARNING: an alias with name %s already exists",
    spriteFrameCache__checkConflict: "cocos2d: WARNING: Sprite frame: %s has already been added by another source, please fix name conflit",
    spriteFrameCache_getSpriteFrame: "cocos2d: cc.SpriteFrameCahce: Frame %s not found",
    spriteFrameCache__getFrameConfig_2: "Please load the resource first : %s",
    spriteFrameCache_addSpriteFrames_2: "cc.SpriteFrameCache.addSpriteFrames(): plist should be non-null",
    spriteFrameCache_addSpriteFrames_3: "Argument must be non-nil",
    CCSpriteBatchNode_updateQuadFromSprite: "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    CCSpriteBatchNode_insertQuadFromSprite: "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    CCSpriteBatchNode_addChild: "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children",
    CCSpriteBatchNode_initWithTexture: "Sprite.initWithTexture(): Argument must be non-nil ",
    CCSpriteBatchNode_addChild_2: "cc.Sprite.addChild(): child should be non-null",
    CCSpriteBatchNode_setSpriteFrame: "Invalid spriteFrameName",
    CCSpriteBatchNode_setTexture: "Invalid argument: cc.Sprite texture setter expects a CCTexture2D.",
    CCSpriteBatchNode_updateQuadFromSprite_2: "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
    CCSpriteBatchNode_insertQuadFromSprite_2: "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null",
    CCSpriteBatchNode_addChild_3: "cc.SpriteBatchNode.addChild(): child should be non-null",
    TextureAtlas_initWithFile: "cocos2d: Could not open file: %s",
    TextureAtlas_insertQuad: "cc.TextureAtlas.insertQuad(): invalid totalQuads",
    TextureAtlas_initWithTexture: "cc.TextureAtlas.initWithTexture():texture should be non-null",
    TextureAtlas_updateQuad: "cc.TextureAtlas.updateQuad(): quad should be non-null",
    TextureAtlas_updateQuad_2: "cc.TextureAtlas.updateQuad(): Invalid index",
    TextureAtlas_insertQuad_2: "cc.TextureAtlas.insertQuad(): Invalid index",
    TextureAtlas_insertQuads: "cc.TextureAtlas.insertQuad(): Invalid index + amount",
    TextureAtlas_insertQuadFromIndex: "cc.TextureAtlas.insertQuadFromIndex(): Invalid newIndex",
    TextureAtlas_insertQuadFromIndex_2: "cc.TextureAtlas.insertQuadFromIndex(): Invalid fromIndex",
    TextureAtlas_removeQuadAtIndex: "cc.TextureAtlas.removeQuadAtIndex(): Invalid index",
    TextureAtlas_removeQuadsAtIndex: "cc.TextureAtlas.removeQuadsAtIndex(): index + amount out of bounds",
    TextureAtlas_moveQuadsFromIndex: "cc.TextureAtlas.moveQuadsFromIndex(): move is out of bounds",
    TextureAtlas_moveQuadsFromIndex_2: "cc.TextureAtlas.moveQuadsFromIndex(): Invalid newIndex",
    TextureAtlas_moveQuadsFromIndex_3: "cc.TextureAtlas.moveQuadsFromIndex(): Invalid oldIndex",
    textureCache_addPVRTCImage: "TextureCache:addPVRTCImage does not support on HTML5",
    textureCache_addETCImage: "TextureCache:addPVRTCImage does not support on HTML5",
    textureCache_textureForKey: "textureForKey is deprecated. Please use getTextureForKey instead.",
    textureCache_addPVRImage: "addPVRImage does not support on HTML5",
    textureCache_addUIImage: "cocos2d: Couldn't add UIImage in TextureCache",
    textureCache_dumpCachedTextureInfo: "cocos2d: '%s' id\x3d%s %s x %s",
    textureCache_dumpCachedTextureInfo_2: "cocos2d: '%s' id\x3d HTMLCanvasElement %s x %s",
    textureCache_dumpCachedTextureInfo_3: "cocos2d: TextureCache dumpDebugInfo: %s textures, HTMLCanvasElement for %s KB (%s MB)",
    textureCache_addUIImage_2: "cc.Texture.addUIImage(): image should be non-null",
    Texture2D_initWithETCFile: "initWithETCFile does not support on HTML5",
    Texture2D_initWithPVRFile: "initWithPVRFile does not support on HTML5",
    Texture2D_initWithPVRTCData: "initWithPVRTCData does not support on HTML5",
    Texture2D_addImage: "cc.Texture.addImage(): path should be non-null",
    Texture2D_initWithImage: "cocos2d: cc.Texture2D. Can't create Texture. UIImage is nil",
    Texture2D_initWithImage_2: "cocos2d: WARNING: Image (%s x %s) is bigger than the supported %s x %s",
    Texture2D_initWithString: "initWithString isn't supported on cocos2d-html5",
    Texture2D_initWithETCFile_2: "initWithETCFile does not support on HTML5",
    Texture2D_initWithPVRFile_2: "initWithPVRFile does not support on HTML5",
    Texture2D_initWithPVRTCData_2: "initWithPVRTCData does not support on HTML5",
    Texture2D_bitsPerPixelForFormat: "bitsPerPixelForFormat: %s, cannot give useful result, it's a illegal pixel format",
    Texture2D__initPremultipliedATextureWithImage: "cocos2d: cc.Texture2D: Using RGB565 texture since image has no alpha",
    Texture2D_addImage_2: "cc.Texture.addImage(): path should be non-null",
    Texture2D_initWithData: "NSInternalInconsistencyException",
    MissingFile: "Missing file: %s",
    radiansToDegress: "cc.radiansToDegress() should be called cc.radiansToDegrees()",
    RectWidth: "Rect width exceeds maximum margin: %s",
    RectHeight: "Rect height exceeds maximum margin: %s",
    EventManager__updateListeners: "If program goes here, there should be event in dispatch.",
    EventManager__updateListeners_2: "_inDispatch should be 1 here."
};
cc._logToWebPage = function(a) {
    if (cc._canvas) {
        var b = cc._logList,
            c = document;
        if (!b) {
            var d = c.createElement("Div"),
                b = d.style;
            d.setAttribute("id", "logInfoDiv");
            cc._canvas.parentNode.appendChild(d);
            d.setAttribute("width", "200");
            d.setAttribute("height", cc._canvas.height);
            b.zIndex = "99999";
            b.position = "absolute";
            b.top = "0";
            b.left = "0";
            b = cc._logList = c.createElement("textarea");
            c = b.style;
            b.setAttribute("rows", "20");
            b.setAttribute("cols", "30");
            b.setAttribute("disabled", !0);
            d.appendChild(b);
            c.backgroundColor = "transparent";
            c.borderBottom = "1px solid #cccccc";
            c.borderRightWidth = "0px";
            c.borderLeftWidth = "0px";
            c.borderTopWidth = "0px";
            c.borderTopStyle = "none";
            c.borderRightStyle = "none";
            c.borderLeftStyle = "none";
            c.padding = "0px";
            c.margin = 0
        }
        b.value = b.value + a + "\r\n";
        b.scrollTop = b.scrollHeight
    }
};
cc._formatString = function(a) {
    if (cc.isObject(a)) try {
        return JSON.stringify(a)
    } catch (b) {
        return ""
    } else return a
};
cc._initDebugSetting = function(a) {
    var b = cc.game;
    if (a != b.DEBUG_MODE_NONE) {
        var c;
        a > b.DEBUG_MODE_ERROR ? (c = cc._logToWebPage.bind(cc), cc.error = function() {
            c("ERROR :  " + cc.formatStr.apply(cc, arguments))
        }, cc.assert = function(a, b) {
            if (!a && b) {
                for (var f = 2; f < arguments.length; f++) b = b.replace(/(%s)|(%d)/, cc._formatString(arguments[f]));
                c("Assert: " + b)
            }
        }, a != b.DEBUG_MODE_ERROR_FOR_WEB_PAGE && (cc.warn = function() {
            c("WARN :  " + cc.formatStr.apply(cc, arguments))
        }), a == b.DEBUG_MODE_INFO_FOR_WEB_PAGE && (cc.log = function() {
            c(cc.formatStr.apply(cc,
                arguments))
        })) : console && (cc.error = function() {
            return console.error.apply(console, arguments)
        }, cc.assert = function(a, b) {
            if (!a && b) {
                for (var c = 2; c < arguments.length; c++) b = b.replace(/(%s)|(%d)/, cc._formatString(arguments[c]));
                throw b;
            }
        }, a != b.DEBUG_MODE_ERROR && (cc.warn = function() {
            return console.warn.apply(console, arguments)
        }), a == b.DEBUG_MODE_INFO && (cc.log = function() {
            return console.log.apply(console, arguments)
        }))
    }
};
cc._initDebugSetting(cc.game.config[cc.game.CONFIG_KEY.debugMode]);
cc.loader.loadBinary = function(a, b) {
    var c = this,
        d = this.getXMLHttpRequest(),
        e = "load " + a + " failed!";
    d.open("GET", a, !0);
    /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? (d.setRequestHeader("Accept-Charset", "x-user-defined"), d.onreadystatechange = function() {
        if (4 == d.readyState && 200 == d.status) {
            var a = cc._convertResponseBodyToText(d.responseBody);
            b(null, c._str2Uint8Array(a))
        } else b(e)
    }) : (d.overrideMimeType && d.overrideMimeType("text/plain; charset\x3dx-user-defined"), d.onload = function() {
        4 ==
            d.readyState && 200 == d.status ? b(null, c._str2Uint8Array(d.responseText)) : b(e)
    });
    d.send(null)
};
cc.loader._str2Uint8Array = function(a) {
    if (!a) return null;
    for (var b = new Uint8Array(a.length), c = 0; c < a.length; c++) b[c] = a.charCodeAt(c) & 255;
    return b
};
cc.loader.loadBinarySync = function(a) {
    var b = this.getXMLHttpRequest(),
        c = "load " + a + " failed!";
    b.open("GET", a, !1);
    a = null;
    if (/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
        b.setRequestHeader("Accept-Charset", "x-user-defined");
        b.send(null);
        if (200 != b.status) return cc.log(c), null;
        (b = cc._convertResponseBodyToText(b.responseBody)) && (a = this._str2Uint8Array(b))
    } else {
        b.overrideMimeType && b.overrideMimeType("text/plain; charset\x3dx-user-defined");
        b.send(null);
        if (200 != b.status) return cc.log(c),
            null;
        a = this._str2Uint8Array(b.responseText)
    }
    return a
};
var Uint8Array = Uint8Array || Array;
if (/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
    var IEBinaryToArray_ByteStr_Script = '\x3c!-- IEBinaryToArray_ByteStr --\x3e\r\nFunction IEBinaryToArray_ByteStr(Binary)\r\n   IEBinaryToArray_ByteStr \x3d CStr(Binary)\r\nEnd Function\r\nFunction IEBinaryToArray_ByteStr_Last(Binary)\r\n   Dim lastIndex\r\n   lastIndex \x3d LenB(Binary)\r\n   if lastIndex mod 2 Then\r\n       IEBinaryToArray_ByteStr_Last \x3d Chr( AscB( MidB( Binary, lastIndex, 1 ) ) )\r\n   Else\r\n       IEBinaryToArray_ByteStr_Last \x3d ""\r\n   End If\r\nEnd Function\r\n',
        myVBScript =
        cc.newElement("script");
    myVBScript.type = "text/vbscript";
    myVBScript.textContent = IEBinaryToArray_ByteStr_Script;
    document.body.appendChild(myVBScript);
    cc._convertResponseBodyToText = function(a) {
        for (var b = {}, c = 0; 256 > c; c++)
            for (var d = 0; 256 > d; d++) b[String.fromCharCode(c + 256 * d)] = String.fromCharCode(c) + String.fromCharCode(d);
        c = IEBinaryToArray_ByteStr(a);
        a = IEBinaryToArray_ByteStr_Last(a);
        return c.replace(/[\s\S]/g, function(a) {
            return b[a]
        }) + a
    }
};
cc = cc || {};
cc._loadingImage = "data:image/gif;base64,R0lGODlhEAAQALMNAD8/P7+/vyoqKlVVVX9/fxUVFUBAQGBgYMDAwC8vL5CQkP///wAAAP///wAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFAAANACwAAAAAEAAQAAAEO5DJSau9OOvNex0IMnDIsiCkiW6g6BmKYlBFkhSUEgQKlQCARG6nEBwOgl+QApMdCIRD7YZ5RjlGpCUCACH5BAUAAA0ALAAAAgAOAA4AAAQ6kLGB0JA4M7QW0hrngRllkYyhKAYqKUGguAws0ypLS8JxCLQDgXAIDg+FRKIA6v0SAECCBpXSkstMBAAh+QQFAAANACwAAAAACgAQAAAEOJDJORAac6K1kDSKYmydpASBUl0mqmRfaGTCcQgwcxDEke+9XO2WkxQSiUIuAQAkls0n7JgsWq8RACH5BAUAAA0ALAAAAAAOAA4AAAQ6kMlplDIzTxWC0oxwHALnDQgySAdBHNWFLAvCukc215JIZihVIZEogDIJACBxnCSXTcmwGK1ar1hrBAAh+QQFAAANACwAAAAAEAAKAAAEN5DJKc4RM+tDyNFTkSQF5xmKYmQJACTVpQSBwrpJNteZSGYoFWjIGCAQA2IGsVgglBOmEyoxIiMAIfkEBQAADQAsAgAAAA4ADgAABDmQSVZSKjPPBEDSGucJxyGA1XUQxAFma/tOpDlnhqIYN6MEAUXvF+zldrMBAjHoIRYLhBMqvSmZkggAIfkEBQAADQAsBgAAAAoAEAAABDeQyUmrnSWlYhMASfeFVbZdjHAcgnUQxOHCcqWylKEohqUEAYVkgEAMfkEJYrFA6HhKJsJCNFoiACH5BAUAAA0ALAIAAgAOAA4AAAQ3kMlJq704611SKloCAEk4lln3DQgyUMJxCBKyLAh1EMRR3wiDQmHY9SQslyIQUMRmlmVTIyRaIgA7";
cc._fpsImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAAgCAYAAAD9qabkAAAKQ2lDQ1BJQ0MgcHJvZmlsZQAAeNqdU3dYk/cWPt/3ZQ9WQtjwsZdsgQAiI6wIyBBZohCSAGGEEBJAxYWIClYUFRGcSFXEgtUKSJ2I4qAouGdBiohai1VcOO4f3Ke1fXrv7e371/u855zn/M55zw+AERImkeaiagA5UoU8Otgfj09IxMm9gAIVSOAEIBDmy8JnBcUAAPADeXh+dLA//AGvbwACAHDVLiQSx+H/g7pQJlcAIJEA4CIS5wsBkFIAyC5UyBQAyBgAsFOzZAoAlAAAbHl8QiIAqg0A7PRJPgUA2KmT3BcA2KIcqQgAjQEAmShHJAJAuwBgVYFSLALAwgCgrEAiLgTArgGAWbYyRwKAvQUAdo5YkA9AYACAmUIszAAgOAIAQx4TzQMgTAOgMNK/4KlfcIW4SAEAwMuVzZdL0jMUuJXQGnfy8ODiIeLCbLFCYRcpEGYJ5CKcl5sjE0jnA0zODAAAGvnRwf44P5Dn5uTh5mbnbO/0xaL+a/BvIj4h8d/+vIwCBAAQTs/v2l/l5dYDcMcBsHW/a6lbANpWAGjf+V0z2wmgWgrQevmLeTj8QB6eoVDIPB0cCgsL7SViob0w44s+/zPhb+CLfvb8QB7+23rwAHGaQJmtwKOD/XFhbnauUo7nywRCMW735yP+x4V//Y4p0eI0sVwsFYrxWIm4UCJNx3m5UpFEIcmV4hLpfzLxH5b9CZN3DQCshk/ATrYHtctswH7uAQKLDljSdgBAfvMtjBoLkQAQZzQyefcAAJO/+Y9AKwEAzZek4wAAvOgYXKiUF0zGCAAARKCBKrBBBwzBFKzADpzBHbzAFwJhBkRADCTAPBBCBuSAHAqhGJZBGVTAOtgEtbADGqARmuEQtMExOA3n4BJcgetwFwZgGJ7CGLyGCQRByAgTYSE6iBFijtgizggXmY4EImFINJKApCDpiBRRIsXIcqQCqUJqkV1II/ItchQ5jVxA+pDbyCAyivyKvEcxlIGyUQPUAnVAuagfGorGoHPRdDQPXYCWomvRGrQePYC2oqfRS+h1dAB9io5jgNExDmaM2WFcjIdFYIlYGibHFmPlWDVWjzVjHVg3dhUbwJ5h7wgkAouAE+wIXoQQwmyCkJBHWExYQ6gl7CO0EroIVwmDhDHCJyKTqE+0JXoS+cR4YjqxkFhGrCbuIR4hniVeJw4TX5NIJA7JkuROCiElkDJJC0lrSNtILaRTpD7SEGmcTCbrkG3J3uQIsoCsIJeRt5APkE+S+8nD5LcUOsWI4kwJoiRSpJQSSjVlP+UEpZ8yQpmgqlHNqZ7UCKqIOp9aSW2gdlAvU4epEzR1miXNmxZDy6Qto9XQmmlnafdoL+l0ugndgx5Fl9CX0mvoB+nn6YP0dwwNhg2Dx0hiKBlrGXsZpxi3GS+ZTKYF05eZyFQw1zIbmWeYD5hvVVgq9ip8FZHKEpU6lVaVfpXnqlRVc1U/1XmqC1SrVQ+rXlZ9pkZVs1DjqQnUFqvVqR1Vu6k2rs5Sd1KPUM9RX6O+X/2C+mMNsoaFRqCGSKNUY7fGGY0hFsYyZfFYQtZyVgPrLGuYTWJbsvnsTHYF+xt2L3tMU0NzqmasZpFmneZxzQEOxrHg8DnZnErOIc4NznstAy0/LbHWaq1mrX6tN9p62r7aYu1y7Rbt69rvdXCdQJ0snfU6bTr3dQm6NrpRuoW623XP6j7TY+t56Qn1yvUO6d3RR/Vt9KP1F+rv1u/RHzcwNAg2kBlsMThj8MyQY+hrmGm40fCE4agRy2i6kcRoo9FJoye4Ju6HZ+M1eBc+ZqxvHGKsNN5l3Gs8YWJpMtukxKTF5L4pzZRrmma60bTTdMzMyCzcrNisyeyOOdWca55hvtm82/yNhaVFnMVKizaLx5balnzLBZZNlvesmFY+VnlW9VbXrEnWXOss623WV2xQG1ebDJs6m8u2qK2brcR2m23fFOIUjynSKfVTbtox7PzsCuya7AbtOfZh9iX2bfbPHcwcEh3WO3Q7fHJ0dcx2bHC866ThNMOpxKnD6VdnG2ehc53zNRemS5DLEpd2lxdTbaeKp26fesuV5RruutK10/Wjm7ub3K3ZbdTdzD3Ffav7TS6bG8ldwz3vQfTw91jicczjnaebp8LzkOcvXnZeWV77vR5Ps5wmntYwbcjbxFvgvct7YDo+PWX6zukDPsY+Ap96n4e+pr4i3z2+I37Wfpl+B/ye+zv6y/2P+L/hefIW8U4FYAHBAeUBvYEagbMDawMfBJkEpQc1BY0FuwYvDD4VQgwJDVkfcpNvwBfyG/ljM9xnLJrRFcoInRVaG/owzCZMHtYRjobPCN8Qfm+m+UzpzLYIiOBHbIi4H2kZmRf5fRQpKjKqLupRtFN0cXT3LNas5Fn7Z72O8Y+pjLk722q2cnZnrGpsUmxj7Ju4gLiquIF4h/hF8ZcSdBMkCe2J5MTYxD2J43MC52yaM5zkmlSWdGOu5dyiuRfm6c7Lnnc8WTVZkHw4hZgSl7I/5YMgQlAvGE/lp25NHRPyhJuFT0W+oo2iUbG3uEo8kuadVpX2ON07fUP6aIZPRnXGMwlPUit5kRmSuSPzTVZE1t6sz9lx2S05lJyUnKNSDWmWtCvXMLcot09mKyuTDeR55m3KG5OHyvfkI/lz89sVbIVM0aO0Uq5QDhZML6greFsYW3i4SL1IWtQz32b+6vkjC4IWfL2QsFC4sLPYuHhZ8eAiv0W7FiOLUxd3LjFdUrpkeGnw0n3LaMuylv1Q4lhSVfJqedzyjlKD0qWlQyuCVzSVqZTJy26u9Fq5YxVhlWRV72qX1VtWfyoXlV+scKyorviwRrjm4ldOX9V89Xlt2treSrfK7etI66Trbqz3Wb+vSr1qQdXQhvANrRvxjeUbX21K3nShemr1js20zcrNAzVhNe1bzLas2/KhNqP2ep1/XctW/a2rt77ZJtrWv913e/MOgx0VO97vlOy8tSt4V2u9RX31btLugt2PGmIbur/mft24R3dPxZ6Pe6V7B/ZF7+tqdG9s3K+/v7IJbVI2jR5IOnDlm4Bv2pvtmne1cFoqDsJB5cEn36Z8e+NQ6KHOw9zDzd+Zf7f1COtIeSvSOr91rC2jbaA9ob3v6IyjnR1eHUe+t/9+7zHjY3XHNY9XnqCdKD3x+eSCk+OnZKeenU4/PdSZ3Hn3TPyZa11RXb1nQ8+ePxd07ky3X/fJ897nj13wvHD0Ivdi2yW3S609rj1HfnD94UivW2/rZffL7Vc8rnT0Tes70e/Tf/pqwNVz1/jXLl2feb3vxuwbt24m3Ry4Jbr1+Hb27Rd3Cu5M3F16j3iv/L7a/eoH+g/qf7T+sWXAbeD4YMBgz8NZD+8OCYee/pT/04fh0kfMR9UjRiONj50fHxsNGr3yZM6T4aeypxPPyn5W/3nrc6vn3/3i+0vPWPzY8Av5i8+/rnmp83Lvq6mvOscjxx+8znk98ab8rc7bfe+477rfx70fmSj8QP5Q89H6Y8en0E/3Pud8/vwv94Tz+4A5JREAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfcAgcQLxxUBNp/AAAQZ0lEQVR42u2be3QVVZbGv1N17829eRLyIKAEOiISEtPhJTJAYuyBDmhWjAEx4iAGBhxA4wABbVAMWUAeykMCM+HRTcBRWkNH2l5moS0LCCrQTkYeQWBQSCAIgYRXEpKbW/XNH5zS4noR7faPEeu31l0h4dSpvc+t/Z199jkFWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhY/H9D/MR9qfKnLj/00U71aqfJn9+HCkCR/Wk36ddsgyJ/1wF4fkDfqqm9/gPsUeTnVr6a2xlQfnxdI7zs0W7irzD17Ytb2WT7EeNv/r4ox1O3Quf2QP2pgt9utwfout4FQE8AVBSlnaRmfvAURQkg2RlAbwB9AThlW5L0GaiKojhJhgOIBqDa7XaPrusdPtr5kQwF0BVAAoBIABRCKDd5aFUhRDAAw57eAOwAhKIoupft3zoqhB1AqLwuHIBut9uFt02qqvqRDJR2dAEQJj/BAOjn56dqmma+xiaECAEQAWAggLsB6A6HQ2iaZggBhBAqgEAAnQB0kzaEmT4hAITT6VQ8Ho/HJAKKECJQtr8LwD1y/A1/vcdfEUIEyfZ9AcQbYvZ942Px88L2UwlJR0dH0EMPPbRj5syZPUeNGrXR7Xb/641xIwJ1XY9NSUlZm52dfW+XLl1w8uRJzJ8//+OGhoYJqqqe1TSt1Wsm9NN1PSIqKmr12rVrR5WUlHy1bdu2AQCumWc3IYRD1/UwVVXnFRQUTIuNjUVzczN2797dWFJSkq8oymZd15sAGAEnFEUJ1nX9nzIzM1dnZmZGh4SE4OTJk5g5c+Zf29vbp9pstrMej6fVOyhIhgAYU1hY+B+hoaGoqKg4XVlZea+XTULTNFdCQsLGiRMnPuR2u3UhBOV9eeDAAWXTpk095DUe6WsoyRE5OTlr0tLSAux2O/bs2cO5c+e+pijKUpIXSHaQVAGkvPLKK++6XK4OksJLCFlXV2cvKSlJBFAjhU+x2WwhHo9nUHp6+urMzMy7wsLCUF9fjxdffPHjxsbGiTab7WuPx9NiEutOuq4PyMjI+M+srKyYqKgoHD58GDNmzNjq8XhyVFU9b/q+LH7hBAEYu3PnTlZVVRFAGgCX6f/tAHoOHDjwa0p27txp/JO9e/f+QM7cipw9nfL3kQBKt2zZQpJ87rnn6mQmoHilw2EACs+cOUOSrK+vZ1NTE0nyo48+IoBpxswoBcMJ4Ndjx471kOTFixe5d+9ekqTH42H//v13A4jyzpAURfEH0H/OnDnthu1z5sw558MmFUCPWbNmnaMP3nrrLZoyDmP8Hl68eDFJ8siRI9/Yc+zYMQKYKdtAztrTrl27xptRXV1NAKMAOAyBBBA/Y8aMdpLs6Ojgxx9//E37+++//29yvFXppwvAwMcee8xjtDHsuXLlCqOjo//ia3wsfpkoALqFhoZuIckJEyackimm3dQmEMDUmpoakmRISMhhAHOHDx/eQJIbN24kgKEyMAHAFRMTs2XXrl1saWkhSZ0kp0+ffhrAr3wEW/S8efOukORLL72kA1gKYMPWrVtJkk899dRJAHeYrgsEsIQkjx8/TgDvAPjd448/3kaSb7zxBmUa7vC6z53BwcFbSHL9+vU6Sc6aNes8gF5ewWAH0PfVV18lSQL4DMBGIcQ6AKtcLleBFC2jXtFt8ODBe0iyoqKCAJYByC8qKmJDQwOzsrK+MAmqo1OnTveHhoa+GRkZ+XZkZOSWiIiIvzgcjk9mzpypkWRmZuZpmbYbGV4AgPnNzc1sa2sjgN0A5iQmJtaSZHl5OQHcb/K3s81mW0uSTU1NBFAFYFbfvn1Pk+Tbb79NAA8IIVzW42/hByA+Pz/fLR/2ZXIda05NI/z9/TeR5J49ewhgqlxTrtI0jY2NjQQw3zTLuWJiYjaUlJToS5Ys6fjkk080kwDEeAmADcA9GzZsIElGRUW9CyAWwLApU6Y0kOSKFSsog9QICGdERMTGsrIyZmVlEcC9AB4IDw/fTpLbtm0jgN94CUAnAJmVlZVcs2aNZ/LkyRdJcvbs2b4EwAkgZfPmzTxw4AABFAN4BkC6vFeUSewcAO5duXIlSTIhIaEawGMAxgKYAmAGgCS73e5vrKVk/yGythANYEhCQsIhkly+fDkBpKqqGmL6DgIALDKN/3yZpVWQZGVlJQE8aPI3KiMjo5okV61aRQAjAPQBMPfIkSN0u90EUCBtsPiFEwpgbn19PdetW2fM5N4zQ9ekpKQqkty0aRMBpMjiWM6JEydIkoqirJUFJ6iq6pAPVy8A6cZMehMBUACEuVyuFwG8HBwcPEIWx367ZMkSjSQXLVrUJouTRorrkAHdA8BdQogsAOsKCwtJkmPGjDkvMw2bDDo/ADEjRoz4XylyFbm5uY0mAbjLyyZ/AOOrq6tZVlbWsWDBgo69e/eyoqKCgwcPPg4gSQaoIRbp27dvN7KF+tLSUr28vJwFBQXtMpvpYRIM7+wrAkDeqVOnePbsWQIoNKfzpiXPg8uXLydJJicnNwF4f+nSpW6STEtLq5fjYwhk1wkTJtSQ5Ouvv04AqTKj+N2xY8dIkgEBAW/Ie1v8wncRegwZMmQvSfbr12+3Ua33WqPfOWbMmP0kWVpaSgCDZAqcfejQIWNZsEGKgvnh9gfQb9myZd8nAEJVVZtMkUNk8CcNHTq0liR1XWdYWNhmH1mJIme80OnTp18x1rp5eXkEsNJms92Fb7e/IgEsvHz5Mp999tkmAI/l5uZeMC0B7vEqqAYAyL106RJJsra2lpWVld+sucePH38ZQG+5NncBeOrgwYMkqbe3t/Po0aOsra011wAWyl0H7x0JJ4DE+fPnu0kyPT29DsDdUrBuyNKEEAkAdpw/f/6GeoEM8GUmfwEgPCIiopwkGxsbabPZPgOw6L777vvm4p49e26VGYjFLxUhhD+ApLKyMp44ccIoVnXybgbgzkcfffRzklyzZg0BDJYCMMmoCwQFBXkLgLGWvvcWAgBToSsKwNPTp09vMR7UuLi4rwH0lgU8c/Db5ezbeeTIkRWzZ8++aMxu+fn5BPCADBwHgP4LFy701NXVEUAJgAnPP/98kyxMNgHo53A4zH77BQQETMvPz7+Um5vbBuAlAFMSExPPmdbVL0qh8Acw8fDhw5SCchVAEYAVb775JknyhRdeaJYztHfxMwLAaqNwCGC2FArv8x0hAHKNLGPKlCme5OTk/Zs3bzb7O0wKiiG8KXl5ed8IxenTp0mSR48e1UmyW7duWywBuD2xyQcgFECgoih+8H1gyJgZV5Lkyy+/3CbTRIePtl2HDBmyw1QBHyGDdXZdXR1JUghRKkXBjOMHCoBdpr0L3nvvPZLkF198wejo6O0A4lVVDTb74HQ6AwD8Wq7Jh8rgGgDgQ13XjVR8qaxJuADMbmlpYXl5uV5UVNRWUFDgfv/993Vj/ZydnU1c37eHXML4S3viAcQqitJD2l104cIFY8lTKsXSBWBMVVWVcd9yed2A1NTUQ6Zl00CvLMMOoHdubm6zFIlWOf5+PsY/Kj09vdrU11QAwwGsv3jxIk21m2DZr10I0RXAuAcffPBgaWkpV69eTYfDcdiwUxY0w6xw+flX8L1xApjevXv3lREREaW6rofB93aPDUDQpEmTMgHgtddeqwBwEd/utZvpqK6uPgEAcXFxkA94NwB9unfvjrNnz4LklwDcf08iIqv66Zs2bXrl4YcfxooVKxAbG7uqrq5uAYA2TdOEqqpGYIi2tjbl6aeffu/YsWPv5uTk7JaC1wHg4Pnz542MwoVvTx+21dbWYvjw4WLixIl+2dnZ9lGjRgmSTE1NRUpKCkwFTGiaxtTU1OXTpk3707Bhw/6g67pDipnT4biuj7qut+Lbk3Vf1tTUXI9qu91Pjq1QFEUBgJaWFgBo8yGOQ8eNGxcAAOvXr/8QwBUfYygAKL169eoCABcuXACAWtn2hOGv0+kMNO1KiPDw8F4A4rZv3/7R1KlTR0+bNu1ht9u9r1+/fqitrQXJgwDarRC6/QjPzs4+QJIffPCB9/aQmSAA43ft2mW0e1QGoi8CAPyLsZccExNTC2BlRkbGRdOyYJCP2csBIN6UAZzCd7cBbQCijYp/dXU1ExMTz6SmptaMHj36f9LS0vYlJCRsl6mxIWSdu3fv/g5J7t+/nwC2AShMTk6+SJKff/45AWRLYbD7+fndAeDf5BJnLoCCyZMnt5JkdnZ2C4B/F0KEm1Pu+Pj4rST55ZdfEsBWAK+mpaVdMo3raDn7KwDuSEpK+m+S3LBhAwG8DuCtHTt2UBbpjgC408vvcFVV15HkuXPnjMp+p5uMf0RcXNyHJNnQ0EBVVfcCWBQXF3fG+Jv0yxABPwB5LS0tRmFxN4BlTzzxxGWSXLx4sS5F3GGFy+1Hp5SUlJq6ujoWFxdTpsZ2H+0iIyMj/0iSWVlZX5mr5jfJFroPGzasxlhTnjp1iiTZ3NxMl8tlrCd9pfa9SkpKSJI5OTmnZOageLUZZqxvfVFWVkZcPwdgNwnSCKPqb17jkmR8fPzfZMDZ5CRsFBmNI7h95s2b1yhT7/MAYmStwCx4vy0uLqa3v5qmEcCfvSr1QQAeXb16NY3Cm3HQ55133iGAp+SxZTNhKSkpfzUddkrFjYevzAQCeGjp0qXfsYckY2NjTwD4leGDLCL2HTdunNtoY+zWSHFcIHdsFCtcfuZ1vO9Eqs3m7/F47sb1k2qX/f3997W2tl7BjWfpBYDOzzzzzIVJkyZh0KBBCwEsB3AJvl9AETabLcDj8dwRFRW1ctasWb8JCgpSzp07d62wsPC/Wltb8xRFadR1/ZqPXYbgAQMGbI2Pjw/+6quv9ldVVT0r01ezuPRJSUn5Y9euXXVd11WzDaqq6kePHm3+7LPPRgO4KlNuxWazhXo8nuTk5OSXMjIyEl0uFxoaGtqKior+dPXq1VdUVT0jj7r68ieoT58+vx8yZMjdx48fP1JVVTVF9m20VW02WyfZf97YsWPjXS4X6urqWvPy8jYCWCyEuEDS8FdVFKWzruv//OSTTy5OTk7uqWkaPv3007qysrJ8RVH+LI8ym8/rB3Tu3HnRI488knLo0KG2ffv2ZQI4C98vP6mqqoZqmpaclpa2cOTIkX39/f3R0NDQUVxc/G5TU9PLqqrWa5rWLH1QVFUN0TStX1JSUvH48eP7BwYG4uDBg1cKCgpeBbBe2u+2Qug2EwD5N5sMPuNtMe8XP4TT6Qxoa2sbIGeXvUKIK7d4IISiKC5d1wPljOfA9bPwzYqiXNV13dd6Uqiq6qdpml2mpe02m63d4/G4vcTF5fF47LJf71nJA6BZVVW3pmntuPHlmAD5wk6Q9NnbHp9vHaqq6tA0zU/64PZhk1FfCZB9G/23ALiqKEqzD39tpvbGUqoFwFUhRLP3yzpCCDtJpxyXDulfG27+pqRR3DXsUWVd4Yq0x/taVQjhIhksC8L+ABpM9ljBf5sKwI8pIBr75L5E4vvu+UNeG/a+hv+AL7yFH8qPtOfHjtOP6V/Bja8D6z/B2Nys/1u9Xv33tLf4GfF/LC4GCJwByWIAAAAASUVORK5CYII\x3d";
cc._loaderImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAACACAYAAACLDX5LAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAALLpJREFUeNrsfQmYHNV17rlVt6p6X2YfzSJptIGEBEggsQlhIwEm4AVbGBs/f96CgkM228/i2Y5fEif5kJ04cRLbkbCxE+MYI8dLYrwhcNhsMBKbkNDCaKTZ157el1rufedWV0ulnp6ZnkVCfE/FV2i6a7t17rn/+c9yb5Nd16+GN2JjMoH6kQw8T8JwKByA0XY/SIUCeF6OQfriRm/XrZ4r5KXGUdChd9p7qRwiR/1gHBuCPKSBEGle2kgYwMU/yoCalCE7nAMikZPHZCBwiOYhRziQsutM04K2lgbw1dXCs3t/B7lsBiica5vBgNeq7w37Pf9Lzxm3E2saoeHLW5yBZHLgBF+Zwzm5nVOClnSLZtdEPjp2W8PX1SH9saY9vjGmkUnP5yhkmiqALjHILVYgR1HKxnlBTzFGUch5pmVWhj+Xfkv95xQvNqtnrDf5XDdwH53sEjAVCcJHR8DXHoTMKoTAJJyzGz0XhCynLZq70vM3iS2Nn1Q4AZLnnOX04bGBYSABtaKQGSIKVSk0pi1gomM4h3N5o2+0kNWkCbHN4c+nr6v7BLXQsDDEWsb1HCGD5KbF2MKJGC2ErGQ4dDyXh4gxBsPk3BbyGypoVFzwpEwYXBv6g87bWj8dVJEsFNAQUqHRVn5hT76XhwKVNVXGhqPh82HHmIjPb4aNkjdIkwMZE57Y0HzjU+9Z8lcejWgo3KK24q6YLL+M8l7DNCpey7IMEr+KgeUPgQRvjo3+fFA76w+VcwxiF9cvPHbnos9oXlqvoZBLeivjH5bJ9QOeUIwpFdQANVnSC1CfNbG34E2z0YJ09nVCJlwq1NIP0ah6rZKyTqO+DAVJ82ahfv/AuOWRJ0KOaPTecYQYBd5MG83Uq2cXNdCxIAvVS/IbIx+RLSIMH7hdK9vnYCSdMNQkk+WJDCWrQ4jDm26jkmGdRQuIu8VpZkn0g8kL69rVuA4T/Fc0fsSABA/4C7zMWSHIQIIvj1Q0kOguKwxYyJKscUI4m4+2Ejp/o52Cbp1Fbcb/BeQV2auidyrIMGzBk4l9ISf0cX8qw5l+uqpzw9F+fkrDCbrsctoMFkJwry8b/I0/Q38B0txNPMHnkQQqAmTnR9Ch5NkTNJI3uf8S71ZjUaSOVtJmUoxd0FQuU/NCP5g++eTXhohp6BwYlU9eJ+Us0OsDteM3tO7ilC+MpkLfVMywxecgZ+xO5Oky8HwetBMZIHxsfgQdSJhnJ46BWKz75Wj+ioYPSMYUI9vi3PLRzIkPLcFuKQaJzKgC0f/uB+145qRGi3sYfrmp//0rvpm6ru7mlvt7fj+4P33M8kkwF31m2EuhXAYGVofBUOeP/NKxpWfJZ0FBM69yjbUkukQWnJlMep7Ah2zqgrAtUQvd68ivh0DtzhYhA+8jDKoZIfW9H235Vu6a6E3S4fR++XD613Q4D5I6e1wVhhmZEISGEjC8PIBO1fzJhmq5syNoLoHU947W22xfND8VbeBi7Oal0jmmBVKDD/R3tANTZKCHhsEIKP7RK5r+Jb8udJPA8TXP9D5+6eHjXYYfKZ8+B2FYDI4pjWBoSpH+zKtnyM+Sb8hJVG/WrpGmNQkSUN2Q7BcVyIG4TDQJWESzw6LYUZLe7P1s+rrG21V0HFmqkPOM5J6VPOiLa2TWyCxbFsSaQ5Cs8UN4cP7DgDTZ4T07cuawVm/wtlNzahJM8MSMV5aEURTBo1ASWQWyDRNdRtniUKj13DHwniX3qgVhGDl4hvNdR5saXz38/uZZYTN3uL2B2N44noaaw7kzw6MNVjgrgrZqPRuIigLU2XQQQ5SCRUUcWkceG0hkYVlXAuJeFcZD3lXdH1r6ZVXDXhCZGILaP2IcCXRmDzOfPNNwS5HWIxx5R/OQj0rAm8+cl0z50fSZ589oZLJ3Nq1H8UyrdERCd0OYzVdjEEarf8sTnXD5wR7YH4jS7/7plV8gQU8jQVpnwwhqOB0zDqrDujFTQQtRS8yCQCEF8UAQ8f/M2iqqRP1nXtAW9xoLPMuFwKfngSjoPPeRH56ADXoGrs2MQwqBuXdl/btGrm76PQEjvKj5IGWMpJrNvWIsUezw6sxMBgFPxoDW53pg4PKVKHS3J3QmBH0WguboBLSBT6mDKl5GkDuvT/Yur1NhxCBwv2WCFvTVPH/nRX9EQooqZYq8nyEKaQljJNSXOWSElRnLSAiaIIyZMrWz3Wc81hFvpqesgm3zuR0UtocmOgzE4HPvaZMvQ0fCI0+n0bzo2KTrPMH9GxcAnEgAOT4OuVsW3snW1F2hucIFwoODlBXjXbybBGbu3QoDKAUYwFkiXbQ2IaP1Ru3QcEhyBgOaH5SQBL4Yup+deUiviwDzoIWai6fOeAvI6NdW0WFMuOAWtK74nxOBrBZK80uWLxx6a9OdKY0okOanWTIpURhk2XR8xo4FXpu8ugHqOuNnL3qn5tD0KEiThAkSXhdqsYTcWkH6RJKW7SQsPpKBzg11xXxelQEbfjpGN4owc3Uwg8/3gC8DckC2atJja/23ZpZHL0cmUkZjmOiVXqOthgtFqJrKYfuz+QxYEToT7Cum2MDh9kXsoYRKXrQo6YnVJHyCw0OFv+LeT2GYaJRzEgo4ZOUgneGQuL4RpHxl9RaxCTquQ/RAEkpxeWECsh65FiRJqiZTbTOUsFeJXdfuubY3Hdm7KvKOgl+R/Cnj1NuIl7CYKcX1PtNPgSvVdb4scpKISGxAXF89xOiNPhj4/RXQcnQE0mEfZLFnidf6nF/19AUY+ZYAx1KHUJNBrkkF+YUY8FezrjDpzC3bpLjGFQnkwTxc961DcJXPhBye6MFO+eaHLtRelQlRzekFzbFnZCJ5G47km3s1aBteFrxSE5zZFVK1FcJgeeaRB9KXVseaLE2G5ucHwMrKkJ6Ney0VtVlAKPOSDyQ21f/f9p1dd3q7sqboaKFQSsEE2TSh75YWYJpcFo+e7ygdPjGuKXAwpIGBL6RqFmR96GLMwOwQlXh4iF+aag76s/U+v09oMzmdmiBTMBWLxrhJpsULmwqiVy/cf2u2PgkpRgzxn9tHb2r4x0C8MLz1t689XTeYAvFtnsrQvygKo5RCF5ojtWzIzLugNdTaE/U+eH5xGLRR3R56Seznqt0J0T5FUoa2NN4sUUUTbveEBAG+CNEN3ftS3yjzyNNqIkUHhwU9yKBE1HB2rywh7OR96kfGrm38ohTVoi3/dnB7d87qHwp4gOompJc2wcMfWw/NncNoYHTEkmK7TMPO5JN5F7RIIkk4mtXFPuBRL5ioepJF8nYlIkxfHSBiHShTJXFBZKMwyqrIkE9IEIh0FxLseCYF3qlfgeFhb3cWeH0IeMMsErrYyTRtgOGnnxrc3PoX6eURf+uzYwcanup5qEtiZlp09CXNUK96IZjMY3tN0H3FPCxDz7O1fRF0H++coUYLG4I3FnFbuTBRAFyYJYspUsbKWkEN9AUesGQLSNbs5swyCZGqzQQTqtIQd+LPE9/dfjALqlAQJbtT00UcxooKObmIozONhKHRDYxsbvqCvir8cTmIDlOywAaf6v6HeMbq1tHiX1cbgr6OOpC7kuVGXWOcK83t7emuE8d41YIWtE54Us3/3QvEr0Hs+laQsmaZMZRVvd36cGx1fBAt/A+0EcQvCR0Dv9KJimkAJWrVzo/FJwV1ofXYyZwHqcWngA67NKGAowsdnSyZuW+Cg3F5z0dWfjl3WcPvKfj+JsJgw9Hx7410jn7v9YIOje9dDeHDCRjQzZOKiFRWwMzbU/X+jaFk+qtS/3j6Em/jDDUaW66NFkB7LQVZE2XmeGrEwVDE45zRqFg9H1j0QLDTvCT49PiOBr+VSr3SuRdWr01Ds98P5vy4/OhC80zAZ5Zbd7c2mqjyPOSD4MEjM4+dWvydI+9s3MEWBpaLmsAsMqr2Z/ufXfq7oc/06jxb85ZFoK9pAP5avEibOVA5Z10fW193d64t8NYV33j+c1bfaF9C9UFY9szcGAoKR9CZ0YMEVv+8F4ZW1kGixWdnuGXh80jsVYVTT+5S/71ST2Z9dDTzRyvbWw5LR8ae6mnxv2c+yl5sTbW4FI4XPNYkGi0y5uNxCdg6WvUgEhxeKlih7htaPzFy04I/42FPSBbxEOxM5XjqWMvPej6VWhbtLgznwOehiFtcNSlpzoW12363ecF7C23BNSyoeHlC3+0by34jYzFDIAGS01myjpKnhLinHRuF+NqFkOv1Q5sVBzlPj3tO5Pfqq7Qr9bc0bDmo0p+Ffjbw8bYn+v+pe8OCG4kqBznj86HRYFmSbFXgaxa+nEyKlalVlfMKd15nFGnaZT031H9x8OqGjaplF8YX4z0jmd7InoE/7qmpfSbTFPaGu+MNZkBZJ8nkjkfuWf0WKULrxFQLolJg+0df0Q6N/7XJpSyTJDsmQ2Yt6ErGSZD1fd3A17X3SEnppyRjXCnJMtI9s+O3G6M/aRzI/rmvJ/eMvjxwo8TmFsqx66M1iaZawn5elowVYo2kdIAafLXj+ekZBdoZJkML1NKPdF/fsJ3Uan5PBg296CC8NcubmciT41/lHu8B3cdu4R64deAjF91kRdV2CZVNFXEpfJzIvmsD2bGF9x/+jLG375UxhC3woSHmhfnl0ZzhQ8dyUPfdIzByZfNL+YtDFkNHUcZG+AKqFr+z/Ys0YR5BHLfm+lxhEyyZyMMh5gdlotFedywJx8LRqRHDxmHwj1zcuCV1bd2n9MuiVysIfyRlnmJT3I5vWNkVgS3o9v9BfolvIfhlkJEaqyIurhc5voXumJ41zavvf+3zC/f2PvLTqAd8ZUFPOvuhi2QXtUGW2QKkQBfQBXxx+poF7bou8WxHaCWXCSMmk+1GI9mXEdtZrbocBc3mHJoktrIpvqFMDddOFdkwOwkuofymiBMIo40ODNGtjcMbG+4+tn7VVhQe1TIoYOv0OkDbA1WlUGF16K0CQmgOj6fZqTCALUFi+1i1P+j7Uu1Tw1/LiULvCj08Yx4t3FCaNpvUhLGp861N6/K12galybtCDdDG9NqlRXfXxHMMfvpYNx26RuahpNke1kQpNPrDoMpOQAsg1GeC6UdElHIV2y4j5rIEX1G4om4bLAltNdp9rbIw4knHxSeVNV+UGZ/0TslpaTfIe2UI/6DngdBLyb80QwrIqcpwRWdi6mnCWJ9YEnp37PK6640F/mXDUSVENCrKbO0sBTedBp3hpI0T7lRoUItkg8XsiopqpB7OgqSwicqB7VJjhZrhDS3b8ksDd1qLw6tEZFLJFY1lVRUXZecUhUyg9ue9D6kvxT/JfMjYp3jvqgSNzseFLEg/PXbLghvkkLpAxBdEJkQRnDhtTIg/n/ENH1ZQJemi0bTnfd8/buPIT9e3wqtUVBedLmg5a5L4ypoPH3/XonuMxYHVsiJTWZSkzYX5iCS8h0DkpyPfCx1K/nFOk+IwTZUCnVJtOLqRlHx83+8v+iSv97TIwjsU7nfegjd6Y7JEZYXWd/SnbAPozxjAnAQtKY4qWTL4jfFlof89vqluA3hVryJGXGFubSeyBIbCwfvU2Pe8R7N/whQyOnXl1RSCLmar+eLR21v+IbOx7lZJkiVJZDTMc6MCXLjgKrbx9YU19G9uWgtJNFTJRgq+bhMKPq4WPPJavV77xNCtbe9UfLIi3GJSmLtyCCppoO2L/GTgAWVQ346fx6tNINBKGQUw4eq+ra3/arUHLqLoGdnYe05tgvIgXgzGQ/KPXwF2VQfwhhrFCsorICp/eM872rfJdZpfFUZMn5+2I28XwbFczS8Hv+I9mP7LfKs/L+erV7zTBC0y3iwk3ZjYGL7f6gi2yVl2zs6TFIMOjXBaXR2B7FtbLtV14z3ZayMfY62+Bp8osMlY85PhFngsQrFjhbHW73b9ReB46l/GW0Izvs1JQQsDgX77ptit9Tu1Nq1NTjE4Z2ewF6kaNztCrX0X8r9LrkrexSI0qOTGUYMTeNCD1N6LTpQMs5Y2L3LkAvL00MHxg75fxz/rO5z9sVVLZyUWW9AyQkPBT1cNbKnbSRb5Fspx/cyKWKBTTsRKCqBEBoEGxyHf34EHPCK9AhIt51V8gjoLlzO33ngb8uZbqZoAig6nyIbbQxz9ZKkQAFaIgKnPvIjTpqpeCQoShwW/7v9F+EDi//DDxktWANnWLKfHoF+BHoQKNcduaf4qWxZc4U3opyVCz8RmCffV0oH64qD6Y0D9CTB9MbD0ILBcGHtecqXrJ3a5EurH6wYJ9aaoCNugUywmRNj9JArGuPMCpu4HM1ML+UQrand1LoPwpvLIzXlK5/7HR77a/vLgX4+1BoeIZhXTR7Pc6MU8RR+/pO3ThZXBTf6kaCQp6jkpRshORutc+kVKIMlO0sDqFFlQbikGobYToHoKIFPTuZsMWns3MJNiJ1AoZMOQ6VoBNDLxvp5oJ6iRPrSFQnNpUbD24iRSMS5czPQUO0TJgBxNg+wbhcLYMjDy4amhAtlLFrW25vB4b+v3+7eP5cgPzTDNz4dy0RqNXdO3uf4TIUOQDWdyZc5iXLeSkglx5KIMWUfWjriJIhiZKESVvUwlQRymAVFgg26Z7SmJLLOd87MmCp+QcfDV9oO3LgayCHkxMcewVOpB7Gy+pFhANQO0YAa8gQSMHLgQtffU9FjVGwMlXBQyuARqZ7orBBgIkW2dkbQsQP1BgNGVYOTCk7AKkaIzwfvz0Z+EEtk/j/Rm9481zN/UXPpfCxs76g8lH5PHrCM51TpYN5p+vf55Iz7UEYynA4UkjeNo3lhrauMWNDyeIAkrK7M6j0dpCPj4mN6o1UMzk3lrNqCsyrX5L2B+upyFlQhokiyKZsREetV/AsKtXdgZki1gZtCK0T/HEylqeCALzVc9B/1Pb0INLp6vhHtBpJQqGhBeWU3FAJW4yBuawGsPARtejRDlO3UGajFDqsgT+ljbQz07rOOFr1tXBdLWjAokqhD0oV+88u1FF278lkgXiIZJSOwpUiNJlIRpqMb6qWSb/R0aTiE8SceXyLGjjz/4L/ax9X/wZ0QdzEvN/3a0vrDEvyJ5ecvG/PLCbepFA2v8kbTMOeLeDCaAWQUF5KAO4eYuSI2sBFo7BsSTQoCQTmnyJLaygrhxxEigqogCNZ2QHb4Qv1FsVsHzLO95cejJ1l/2fyZywtrX3eJH/Zh/A0XtykbiAt9KO5QBtGsnctFAPH//l/FtTItGYoP8qHewbukvFy7buHORosiylZ/FNGhRC5jzgL/jOKR7OxDTETYIg5Mp27KJnRWF7fpeGEiJUFAQr2kgCYVcHZCe3OtNj/d+Obh/6H5jQcS0i0rOEAmYW+BfxGj9BWfoyzZNC7/9OxBee/RdzZd3/5NE5LCV0wBmW4NtSYjnqImhAfw3gdDDTwWC+VSQUfkYsZMmMiieLsP8VfY/gs8af8sWSkc4PfMLD8zqCXbCUZXBSuRPVkeKl2A6DkfDszZ6Qe+XFG8hjINy9kIuyQkNJgmm8D75Ym0XTDHSKoU0STmEIF4HUnLkfV3flL7Se8TQpLPil0kzHM02pfOksuDvS4HZkwQrGbJ3Mx4RZr62+cbn/zbYlFliJIKiqnzurraJhjGYBaoap2RWHvOu9HkyI1lkOaIQ7+2KTOjC/Wm79sQqFd4LiojGkfJiCbFQdmkelo+pCjpMr4JkwYI8NkCvD0A0lwYFhRxHVKu/e6fDkRVJC2c+WHPp6zea47UwL/MVcKTI/iwY3Q3g9eSLPc0nCchzFyaXf+cSeMkwWszchCzI19SpJ8dXhqEuaQIb0cFYGACrMw3HPQTy6FT1iOL3Qh7CIutezNcWJ+SjU0UE5xWjmRQ7RRUJBnu1iInFP7Sa8bv0P16F3MXt0ETSMByqwZvoyMLyxSV7rn3SmTosr2js6P8cT4VOZwVzCWlIRS8vO9CAjCMH/tr0yWLwCVpLynB7cscS6R4KmpAVOjFbdU0+CBoa3XgK0mnTjmnrsQIUFFGQb0IBWZecN0DXimxH9LWZyiHjKti6pCOXYGL+Iyric0si+F0QRIFreiaCFp5h++EToBjoyqxqBa/gZ2W1EmNfuweu5N9u7H832+m5WK+xsr454bJbmyVvHpKozan+epACafBG0rZ3XhEaeBW82qXx2MQAt9gW/HzQnhXtrKxge5f2rAdbdQWa2JDizlOJpSvAsJxEelGjRSfEAoodqxGegDkpRpMieRcaJNYyatzbCSv/5wh40jl7eoVt89wDQghcJmpb4Ot3dN3Y+qS2ZnQj07X5EXLxHXFnMHJoMZj48NxYDViWXDF/N2V+j0xiFLHLSJ/6bkshfpEYqCJgeMrmkpMNBFeUAsRkKHtCFCsW77h3W9C2G40fPCkd1KMx8PV1gsqzxYVMKlTHi2QnNrZFf1fb14wPLv2u1UCXe2vjwK35okliHkseEicaITfQaGt3djgEuSEFCC3zDEkFYU6m8a6/hbAz0ZaNv/tw26/AI18vFyy5GoHP2hhaKDRffxJ8B8Zgwe+6wPSpYGqTI4qkM9ApvSr2vrqvpNc3XCbH0Mfy9tse23zlYYgkQp456H/mslPMBWlZZrgFgu2dIJ2unpX/ntJjLI5cOW7FEpdHL8+tCe3x/6v+BThu/j2+XwLOwLpY8oqAH1buHwLfCNI1n3IqYuemWCqFwpJ6iPSkoS/qu2H87c0PZFdFV2lpxKksgLduCDT0tk7y3LnF9FGmFvQ+uwpyschpQ97M+8DXNAiKxiqvXjMZl54AS6LwkHEay3+JPq08rKRZoeuy2tsKNdoKKWu+wHQzAeXFNHPl0WvDXjAEfVOmngYolg2WFLIpfmP9N3iHb7Fql04h3YvXAssrRa9tzgYQxwU6J7H+MKS62ifgvaWrMH5kCcrABMIrLMZUiYlMRgXRvZIWWb9E3d65aPeJ99Q/l3iH0eZN8gbPVkKk8Hzn8GiBVTclLafRFYduadmlLvG3yRlRESSDIXij2d0rSRnEDbJgzrisIS4fXQiDv7kUZV45vZzua4R08zCEFozaUTkO/HT+PBXPdhlD/HhAlulrka4smCEKeoP2rNaXe9ZzKLMqrQGf75gHnXJ9I0fIlpf5hlYFv8wW+5arjIGJAvbsS/9qcVf/gz3RYFemVb05TK17ReXhrEQs1o7wZiHRH4W+JzcAVyevRhEx7NEDy+2sjC9kQbEwlldH8RxvzwQD+IGahP8zSG8v4JD3KLDgwS7ILwqjh8AP2LUf8jyvQDN4RcvUQhA1EaP0rcYi38128czzI4/W/HrkHxloz0cgPfJkeAOQx/hQ7eK+uzQvq2UzZB5i0QjJn4ITj10OuURoSiGXNiPjhbH9q0G+7GXwaNyGkdM0e5LonsBmcZ5e8EImcuF1+ocz/9X43PinTEJ+Ez6aBJKSwKinwKLzv9KB3HrtUnuBqMl2NJDayPUL7keG7F30454/Mvcn/1Iby7/KVCUb8Jrwen0b6GOBGM/68pE1nW8jFgWocvkgiVr2ZK3uJy+FzGADMLN6c29kveihBUGtHbEzNoL1TKB57oJE/I8hL9cNGfSRlWCZAWK0+doyC303h16MD6vd2VcMVUHCwcFPKPhzBPz5+dvp4J0rp/PAL/W8EoMVD/S8JdcsHRAFNvb0ChHBo8WXE3QsOBTclf/O5bfS21/YTGWlqEQiXeUSum0wRXxAvHBBhuTxBogdXGoLrcKgn7a30kO1YDy7DmouOgTemqRdWCp+SKFox8oMKbeggKxFH7sAzEKgWImPI9Ro9DSf2Lb46w1hrTny05Evg9cuLAaY55ohahWmyT1avKfu+/23Q4D2i/CoYHDCTHkDGsSXnIKdDqXwlv2rfJu0A5uQ7h0DD2IoRRdaECk7ZsFkYBYBIxG2advI4QZ84bA9+2oa327KrZAMwOBvLwdf2zDUtnWCHCoAlYs+tih4FM8VCV8z2wh6ssWp9TjVnWKiJvGp/uGPLvoC+mdSzRNjgksbwtzwecy0VBO96+OOYbAT5HkLPEkDKEUCTccBFtfDJv2lutcuqfl7r1dT7EnqiWWQGxR8OA0eMbTxpcXyirnhBvwyCGasAHnUYkUqIwMTkbU6VogqnBpqBGuQQviCLKgobELEckB5JHG1yL9D2MnqpJAmhA0eSR39UNtfSZqc9b+W+WfNtLgvU5g3qK4+wyKgIkhBi+lQezwLVi8arRdRmh9fDno+eQ8JN18o6afaJSMaMCOAhgutvMh2y6g51AcSOiO6WPPTg1Q1b8LUUYkZOAQGutRSFEIxBfJ8Zmti2ys55BjQAFVib2/669yC5Inle0d/smRkCOZjPdmqA//2EEqb4HlqFPwjBXvmrL08MULBpv98snXk1raPUi5NCI9Kokac+RE8vMAtv12BZKpIuRPMmZ/AJ4u/8YnRiekSVsUQpp6rQgUF+yhf8RE/yqJeL6oEMxf4v8QYXyqCWSZi/nzsUrXdQdBJ8T47AoH+HJCsBXLaACVRgPj66IfMNn8rMYuJTbGkQkVss4sFZZCOpo7muHdYBKaK6/VMGq4nFY5V8gWLx1iRWeSYPL2Q0QqayULCFO0p02xR2Kkv9i+LXRb+C1QdRQTyRV31XPdpocN+UzRYGaRFZHnTaa8sZa1Aem30NtkpgrFE+fC4flyWpRoWoLUno2GI8cK41D7c/bBxJP6doS1rHqKMV4KJcqFOxT5I+QddkiCSQvcc2yqYUaVL7MqwVzPfXvbTgW8P31j3xdEr6zcEUpY96bI0yHyo2Sc2Nd5Rc3B4t5FgP2HkLKSyuJMr5PXYmMay03PkEqvF02bDmJhz15U4XPfrob8fuG3hl+xUD2q5XbzNmBn+zxNf6I+Tx3Lt9TXoj/orcLBKkQoyhZE8bRTY62ojIuVkCqLSTKpAycUkVKYbetP3O79Wc8Lce/HLPe9/+lOXfK33ivobfTlWrNmz53MjL9ck+eCtHZ+NPtL3GExMmMxc0NPGYFGI2csjkKu0CrnB1jCv7Lcz4BbTVz7R/5UhizxvUklVRALBi8IezMdqHxn9QymV251b0PB7nEptzupEwCfXXlKFkSRlHVJMMwkeXemdeDGxIcetYTxxZMhvwIXd+jFfb+5j9MXEN4w1oRsVo7jibnGyPodCe2BdOJV856VPdD3I5kj1aM1vx6YHD98kZMAgdWIamsiz+Y8kX9vQNfrAP3z6yrV+xiVRPgsjuZHWf+76sCXRRwpNKAC/GsKXLU5RJqSS9kKV9K7CZLTi/BKWtAzTV1DkQHASrCEUIZqKlRryYpknlfSqA/mPSYTfr68K3SSLsjWzWL0pIQYmrm3/oPn48f9gVJ4T/aCSb/Y1NMQkPhQYFfhWt2fwGwmxyP5oPglhOmLFDKn5n4/c7TuSeyR5ca09NBjnUbwqKsmTaF0VIfspO8ESs/7lOFPUWjvVXWmtD4n4vTGuqSMcXgyHwcqi5rZpvYFe42OynvmGuT5wExUJRLGWtMFgeGXNhqeuWH0JpAsvzGVJe5qsm/1qu6gZWWQZTB7KD4aeef2hfUENOv799Z7Bq2uepFbQrDmY+888dcp7Bf3KoCuoyCGheWBZUwQyJ2UZZKrz7HmjEiToocQRY7H/aiVnnUoki4OIvUSl/kSbVkNVViyA/M0ALFuZBjnP+/zPZT/ebbZ9Z+SaBVerGaM4czai+qylyrsDDxx8YS5T52lwKDN7QRvsxfF2j66+nvl5bM2CUc1QoRAI55RB+REq5dOZFagxYhiGqV3aJclElP1SVlzOZ6oKjGrZxmkwYwvOAj87XvixcjQdZUv9K+XsqZVyRHkAU4nEmuhi4vU8zTQKkdE03Prg0xAHFdm+3vWMwe/uWt6wO1Qrr1DQCxbrcGQvimyS1rcQrsmz9hNp469GZh/6y7P/SS/wH/Iczz0Va6qDwX3doMTGwd+nPhX2eyEj1qPT0PCNJYCMohBUlXEV5SyRqahdtd9XuAcXwS5f1quxq3a9cvdLn1//I/DLNbawpWLmXky/MNa2XJc4MPB9i3A9pnjgN821cMlADrJ4OyMv77/lwaN3vfje9h+m6z21YtHZ/OJgi/auFS1cnv7XQicVtJmd/Q/e4EhM1f4yfh/LpHq5aRGNZXn3q0NQFwkN+urqwbROz5Lk24MFQnjBLiTnltthmcoQkirSrieDMThYDMTSbPOBwScHvtf/ybE7Gu9nfoWSfDHPKHRSr1PeljgyUMeyer9JZXhkSQ1elIANA+P23O4NR2NPDj+U+9TLf7j6fj+VKVFIiGt0DQ8ovbNNcVGQ52BKUV7qqPmDQme3VzIN3oD2p9ejgKxQ+8diSFnOT+poTuKXQZ7T7SB8FVrKq6B63H1UVG0bppk0VQp1L8T+zSulmzu3rfxbn72uBrOn+Om13ua6G/wXE672i4tyAQrxZwygu0eLK0/68B0G0v++5Bf9i3ve1vJ56lF8mcGhDmvPCQAPnaWg55pPVYgFmUIaCrr9O1dT/QgB8XsEl/QKjJYrV+6TKlOrpCKfFvfM6yPpoz29TjiAR15I/l34R2Ph3A3B7TJicjEsSsCjtr/f9+TQLwWgRPDchN4MrzUW7KosezqMKrPAcP4+rTt7hbE0cIOUN5ZZneP4DuobI+hSHKO4pCSZMmBOLGkQVUaBU2VdvHLS6TTNrSYJQEruISvoB9Wo53DJOFoqNRqeGv2cOTya6Xt/x2dBle1FC9NLIm/z/mJ0KTpsR4j9ey8cXr5mJbCwH36EBtwqrsiVCz2buWc0ID/ljwaXrlTa7KU33zhBV7kxynug+AObMElmb7ZhUo5QZKdG1Hj+aeS/Q+4nZHzUfM/PDn/hUFbv/dkHlv9fX1hZCA2e2sw1jfd4ewp/nL8sZEMKF7MtegwgPU45g8TBM2QeXfXFrj85+r6mO2JXRCj3SOY5L2gUxwCKNc8If0GisPZ0dJ3SA5zKYyyGY8RPPDErccmhE88E4xMpK0N66eszvxV6IbUv4rH+PL40eG3q0sA9yJyeAEp+xIuLeYG52AO5hoTAErvQUazQa9YWfmXUp73ZtXW1nLo68ZwVNJFFbmsASda3LLDWUkKdyZfTuth8Ciixf38hRwlRRvL/ngqHXi9oHlgw2FvBKwTxs0+vXLz7xNaXETrSl0VvztfL1wZeST2Gx+xVu2VDhuSFYzBwRwosb3E2A1NYPDigPaTKCy2L6uc+dEipYhCMM2s30qWbWUh9m2Ra7qqMajD5dOGjXdAViUS7R5/yDGS/NNLclBfavebl3knHiOkRMQ5pT+BI/iVeKCxU92ek0o8xiP+3PItSX6lAdpH4YXfxozs4YCySt2ekzTK3RfhZXL6g6U/f7TKMcKlRF3yQ1AZX2ivCnGpINRhd7AxFtkvZcv0jj178u6679XCkcyzktVfHOfrNH8K5tJ3d30EVjorYZRn9FetFb/fY+6XhxKNihTbUwlL0FEjl+LSb5RAmkgnJTKe2r/PPPK/1vc8A6LTLH87RBRneuN8FF6stWuxlbSh1e4HDDdyrvJcp9HqQSdieI1IsK3KmHzuhkeKcU8YM61WezHyXHBn6rsLZoFnQLS6fu0J+YwUNzm+hcIgjL3uYW/y/qa63mJJ8kWWZFzCLLQYvjcgqDSp5K86p1GkoUi/h7BXO+EH07zNQMEzu14Ab+rwXvMw7D+D8TfhLuW/CTTovgvOCPi/o89t5QZ8X9P/v27T0bnx8vPRnJ+67cN+B+31lp3U4u9h2O+dMtW0Xt8b9GO5R3NdVerRzfPcM3ke0Ya9zzTbX9zudf7fNUk47nXtvKWu/kAdEo9F549FR50FRZ98+zflTCXpzhY6asq9xv7f0Ui6BPoz7HudZJW045vx9l+u6zc7nfbhvdc7b47qm/D2hwrF1LkUC534dzvfbzhR0jLt6VjS+xtn3Ofu9zgttdTW8vNGla3c559/u0tzS59ud41FHozaXtWHc6fBO55y7nA485hLaOuf70nMfdvbOCiNMjISYs++cpBNK73O76znz6hlGXdq42RESVOh98TKPlh27rKxRmydp7DqXVu52wdAxR4B3OZro7uytruvKhVPSus3OdbsmafPDzn1Kz11XNiJgEpjc5mrP3D1DxOj7KkDF7U4Dx13C6nA+lwRYEvqusuEVczpuR1njS8Nzn3P9DufvDkcD9zmdNhU+73TuvcUl7Pscge2Ywl644W6do93HnHbf54LN8pFdM58Yvc9pxFbn5jvKNMut9cdc2r7H+Ts6yfCbDOfXOXsJisarVJpjrs4eL4OYrY7QoxUM5Y4K93Fr7jqX0Xa3ac98Q8duZ9/s+hx1/V0aXnudfx91NWJd2YuUXjzqaP64q2O2O/vtZcaqkrrc53y/y3V9yWC7n7fLJbBSR9zlGjGlNm52fY6W2ZDdrpGxY4YsaMbGMOp6ka2THIu6Pm93GranQsP2ubB6vEwDyzG0w6X5e8qO3+V07vYy7C9RvJ1lxvXeSTC31NbS+VvL2umGx3Vl13XMJ0ZHHS1dVyasdZNo/7iLTq2rgI8l7I6WvVDUhdHlBnKPawS4j213tG6P88ydZUO//Nk7neu2uO7lbs8up8M6HHuwz3Uvt53Y6TxP3PveajC6GkE/6tK+Y86+2WnYHhduPex6qe2OoSjRspoKhmu7C48nsw37JhkVMAmclJ4bdTlY21zsQjxrySR24dEySLy97Jy9LttR+tfusPkyhiXSv9XlHZUaVuLN0QrQ0OEyItEybTzmEkB0GoyeiVe4r4LWb3UxmpKjU6Jy+1xt3uYcg0kM3Z4yQ71lJm2slnXsK3NA9s3Abd1dgZ2UhBAtExRMoeXj03icHVN8v9l1j60uCrmvAr8vjY7dZQbZfXzbTBVhtqmsza5/91bAb7dgdlUY3tPFQabq9D1l2lp6TkfZs9z0bYer8++qoI3bXWykpFT3OQJd58L2cZcXuu1MCXq8gjBKw2i3y1qPl/Hv8nvsK3NwdpfRrHudFy658btd2rWnzJsDl5teaXTsmURBKtmLEkzuce5VgsSHXZ24w1Gsu2YapJpJrGNfGW5f5hieyyZ5YHQS7XKfv89Fu/aVueD3uoZ6tExox1zXbitz390CPebSzr0unj0+CSff7XLvx8uEvM253xYXs+qsQHfnNR69ZwqvrcSL102D3zAJr3ULc4tL2FCho3e4zt1TFjvZ43JY3G72vRUo6Y5JlOXeCiGEEsXbM988GlxEft0UwrnPBSPbpwmXbq6AqaX776oQbDo2CxZSPrrmcv1UtmrPvPDo89v8bOdTWecFfV7Q57fzgj4v6POCPi+C84I+L+jz23lBn7Pb/xNgACSTMI8OOhyLAAAAAElFTkSuQmCC";
var cc = cc || {},
    ClassManager = {
        id: 0 | 998 * Math.random(),
        instanceId: 0 | 998 * Math.random(),
        compileSuper: function(a, b, c) {
            a = a.toString();
            var d = a.indexOf("("),
                e = a.indexOf(")"),
                d = a.substring(d + 1, e),
                d = d.trim(),
                e = a.indexOf("{"),
                f = a.lastIndexOf("}");
            for (a = a.substring(e + 1, f); - 1 != a.indexOf("this._super");) {
                var e = a.indexOf("this._super"),
                    f = a.indexOf("(", e),
                    g = a.indexOf(")", f),
                    g = a.substring(f + 1, g),
                    g = (g = g.trim()) ? "," : "";
                a = a.substring(0, e) + "ClassManager[" + c + "]." + b + ".call(this" + g + a.substring(f + 1)
            }
            return Function(d, a)
        },
        getNewID: function() {
            return this.id++
        },
        getNewInstanceId: function() {
            return this.instanceId++
        }
    };
ClassManager.compileSuper.ClassManager = ClassManager;
(function() {
    var a = /\b_super\b/,
        b = cc.game.config[cc.game.CONFIG_KEY.classReleaseMode];
    b && console.log("release Mode");
    cc.Class = function() {};
    cc.Class.extend = function(c) {
        function d() {
            this.__instanceId = ClassManager.getNewInstanceId();
            this.ctor && this.ctor.apply(this, arguments)
        }
        var e = this.prototype,
            f = Object.create(e),
            g = ClassManager.getNewID();
        ClassManager[g] = e;
        var h = {
            writable: !0,
            enumerable: !1,
            configurable: !0
        };
        f.__instanceId = null;
        d.id = g;
        h.value = g;
        Object.defineProperty(f, "__pid", h);
        d.prototype = f;
        h.value = d;
        Object.defineProperty(d.prototype, "constructor", h);
        this.__getters__ && (d.__getters__ = cc.clone(this.__getters__));
        this.__setters__ && (d.__setters__ = cc.clone(this.__setters__));
        for (var k = 0, m = arguments.length; k < m; ++k) {
            var n = arguments[k],
                q;
            for (q in n) {
                var r = "function" === typeof n[q],
                    s = "function" === typeof e[q],
                    t = a.test(n[q]);
                b && r && s && t ? (h.value = ClassManager.compileSuper(n[q], q, g), Object.defineProperty(f, q, h)) : r && s && t ? (h.value = function(a, b) {
                    return function() {
                        var c = this._super;
                        this._super = e[a];
                        var d = b.apply(this,
                            arguments);
                        this._super = c;
                        return d
                    }
                }(q, n[q]), Object.defineProperty(f, q, h)) : r ? (h.value = n[q], Object.defineProperty(f, q, h)) : f[q] = n[q];
                if (r) {
                    var u, w;
                    if (this.__getters__ && this.__getters__[q]) {
                        var r = this.__getters__[q],
                            v;
                        for (v in this.__setters__)
                            if (this.__setters__[v] == r) {
                                w = v;
                                break
                            }
                        cc.defineGetterSetter(f, r, n[q], n[w] ? n[w] : f[w], q, w)
                    }
                    if (this.__setters__ && this.__setters__[q]) {
                        r = this.__setters__[q];
                        for (v in this.__getters__)
                            if (this.__getters__[v] == r) {
                                u = v;
                                break
                            }
                        cc.defineGetterSetter(f, r, n[u] ? n[u] : f[u], n[q],
                            u, q)
                    }
                }
            }
        }
        d.extend = cc.Class.extend;
        d.implement = function(a) {
            for (var b in a) f[b] = a[b]
        };
        return d
    }
})();
cc.defineGetterSetter = function(a, b, c, d, e, f) {
    if (a.__defineGetter__) c && a.__defineGetter__(b, c), d && a.__defineSetter__(b, d);
    else if (Object.defineProperty) {
        var g = {
            enumerable: !1,
            configurable: !0
        };
        c && (g.get = c);
        d && (g.set = d);
        Object.defineProperty(a, b, g)
    } else throw Error("browser does not support getters"); if (!e && !f)
        for (var g = null != c, h = void 0 != d, k = Object.getOwnPropertyNames(a), m = 0; m < k.length; m++) {
            var n = k[m];
            if (!((a.__lookupGetter__ ? a.__lookupGetter__(n) : Object.getOwnPropertyDescriptor(a, n)) || "function" !== typeof a[n])) {
                var q =
                    a[n];
                if (g && q === c && (e = n, !h || f)) break;
                if (h && q === d && (f = n, !g || e)) break
            }
        }
    a = a.constructor;
    e && (a.__getters__ || (a.__getters__ = {}), a.__getters__[e] = b);
    f && (a.__setters__ || (a.__setters__ = {}), a.__setters__[f] = b)
};
cc.clone = function(a) {
    var b = a.constructor ? new a.constructor : {},
        c;
    for (c in a) {
        var d = a[c];
        b[c] = "object" == typeof d && d && !(d instanceof cc.Node) && !(d instanceof HTMLElement) ? cc.clone(d) : d
    }
    return b
};
cc = cc || {};
cc._tmp = cc._tmp || {};
cc.associateWithNative = function(a, b) {};
cc.KEY = {
    backspace: 8,
    tab: 9,
    enter: 13,
    shift: 16,
    ctrl: 17,
    alt: 18,
    pause: 19,
    capslock: 20,
    escape: 27,
    pageup: 33,
    pagedown: 34,
    end: 35,
    home: 36,
    left: 37,
    up: 38,
    right: 39,
    down: 40,
    insert: 45,
    Delete: 46,
    "0": 48,
    1: 49,
    2: 50,
    3: 51,
    4: 52,
    5: 53,
    6: 54,
    7: 55,
    8: 56,
    9: 57,
    a: 65,
    b: 66,
    c: 67,
    d: 68,
    e: 69,
    f: 70,
    g: 71,
    h: 72,
    i: 73,
    j: 74,
    k: 75,
    l: 76,
    m: 77,
    n: 78,
    o: 79,
    p: 80,
    q: 81,
    r: 82,
    s: 83,
    t: 84,
    u: 85,
    v: 86,
    w: 87,
    x: 88,
    y: 89,
    z: 90,
    num0: 96,
    num1: 97,
    num2: 98,
    num3: 99,
    num4: 100,
    num5: 101,
    num6: 102,
    num7: 103,
    num8: 104,
    num9: 105,
    "*": 106,
    "+": 107,
    "-": 109,
    numdel: 110,
    "/": 111,
    f1: 112,
    f2: 113,
    f3: 114,
    f4: 115,
    f5: 116,
    f6: 117,
    f7: 118,
    f8: 119,
    f9: 120,
    f10: 121,
    f11: 122,
    f12: 123,
    numlock: 144,
    scrolllock: 145,
    semicolon: 186,
    ",": 186,
    equal: 187,
    "\x3d": 187,
    ";": 188,
    comma: 188,
    dash: 189,
    ".": 190,
    period: 190,
    forwardslash: 191,
    grave: 192,
    "[": 219,
    openbracket: 219,
    "]": 221,
    closebracket: 221,
    backslash: 220,
    quote: 222,
    space: 32
};
cc.FMT_JPG = 0;
cc.FMT_PNG = 1;
cc.FMT_TIFF = 2;
cc.FMT_RAWDATA = 3;
cc.FMT_WEBP = 4;
cc.FMT_UNKNOWN = 5;
cc.getImageFormatByData = function(a) {
    return 8 < a.length && 137 == a[0] && 80 == a[1] && 78 == a[2] && 71 == a[3] && 13 == a[4] && 10 == a[5] && 26 == a[6] && 10 == a[7] ? cc.FMT_PNG : 2 < a.length && (73 == a[0] && 73 == a[1] || 77 == a[0] && 77 == a[1] || 255 == a[0] && 216 == a[1]) ? cc.FMT_TIFF : cc.FMT_UNKNOWN
};
cc.inherits = function(a, b) {
    function c() {}
    c.prototype = b.prototype;
    a.superClass_ = b.prototype;
    a.prototype = new c;
    a.prototype.constructor = a
};
cc.base = function(a, b, c) {
    var d = arguments.callee.caller;
    if (d.superClass_) return ret = d.superClass_.constructor.apply(a, Array.prototype.slice.call(arguments, 1));
    for (var e = Array.prototype.slice.call(arguments, 2), f = !1, g = a.constructor; g; g = g.superClass_ && g.superClass_.constructor)
        if (g.prototype[b] === d) f = !0;
        else if (f) return g.prototype[b].apply(a, e);
    if (a[b] === d) return a.constructor.prototype[b].apply(a, e);
    throw Error("cc.base called from a method of one name to a method of a different name");
};
cc.Point = function(a, b) {
    this.x = a || 0;
    this.y = b || 0
};
cc.p = function(a, b) {
    return void 0 == a ? {
        x: 0,
        y: 0
    } : void 0 == b ? {
        x: a.x,
        y: a.y
    } : {
        x: a,
        y: b
    }
};
cc.pointEqualToPoint = function(a, b) {
    return a && b && a.x === b.x && a.y === b.y
};
cc.Size = function(a, b) {
    this.width = a || 0;
    this.height = b || 0
};
cc.size = function(a, b) {
    return void 0 === a ? {
        width: 0,
        height: 0
    } : void 0 === b ? {
        width: a.width,
        height: a.height
    } : {
        width: a,
        height: b
    }
};
cc.sizeEqualToSize = function(a, b) {
    return a && b && a.width == b.width && a.height == b.height
};
cc.Rect = function(a, b, c, d) {
    this.x = a || 0;
    this.y = b || 0;
    this.width = c || 0;
    this.height = d || 0
};
cc.rect = function(a, b, c, d) {
    return void 0 === a ? {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    } : void 0 === b ? {
        x: a.x,
        y: a.y,
        width: a.width,
        height: a.height
    } : {
        x: a,
        y: b,
        width: c,
        height: d
    }
};
cc.rectEqualToRect = function(a, b) {
    return a && b && a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height
};
cc._rectEqualToZero = function(a) {
    return a && 0 === a.x && 0 === a.y && 0 === a.width && 0 === a.height
};
cc.rectContainsRect = function(a, b) {
    return !a || !b ? !1 : !(a.x >= b.x || a.y >= b.y || a.x + a.width <= b.x + b.width || a.y + a.height <= b.y + b.height)
};
cc.rectGetMaxX = function(a) {
    return a.x + a.width
};
cc.rectGetMidX = function(a) {
    return a.x + a.width / 2
};
cc.rectGetMinX = function(a) {
    return a.x
};
cc.rectGetMaxY = function(a) {
    return a.y + a.height
};
cc.rectGetMidY = function(a) {
    return a.y + a.height / 2
};
cc.rectGetMinY = function(a) {
    return a.y
};
cc.rectContainsPoint = function(a, b) {
    return b.x >= cc.rectGetMinX(a) && b.x <= cc.rectGetMaxX(a) && b.y >= cc.rectGetMinY(a) && b.y <= cc.rectGetMaxY(a)
};
cc.rectIntersectsRect = function(a, b) {
    var c = a.y + a.height,
        d = b.x + b.width,
        e = b.y + b.height;
    return !(a.x + a.width < b.x || d < a.x || c < b.y || e < a.y)
};
cc.rectOverlapsRect = function(a, b) {
    return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y)
};
cc.rectUnion = function(a, b) {
    var c = cc.rect(0, 0, 0, 0);
    c.x = Math.min(a.x, b.x);
    c.y = Math.min(a.y, b.y);
    c.width = Math.max(a.x + a.width, b.x + b.width) - c.x;
    c.height = Math.max(a.y + a.height, b.y + b.height) - c.y;
    return c
};
cc.rectIntersection = function(a, b) {
    var c = cc.rect(Math.max(cc.rectGetMinX(a), cc.rectGetMinX(b)), Math.max(cc.rectGetMinY(a), cc.rectGetMinY(b)), 0, 0);
    c.width = Math.min(cc.rectGetMaxX(a), cc.rectGetMaxX(b)) - cc.rectGetMinX(c);
    c.height = Math.min(cc.rectGetMaxY(a), cc.rectGetMaxY(b)) - cc.rectGetMinY(c);
    return c
};
cc.SAXParser = cc.Class.extend({
    _parser: null,
    _isSupportDOMParser: null,
    ctor: function() {
        window.DOMParser ? (this._isSupportDOMParser = !0, this._parser = new DOMParser) : this._isSupportDOMParser = !1
    },
    parse: function(a) {
        return this._parseXML(a)
    },
    _parseXML: function(a) {
        var b;
        this._isSupportDOMParser ? b = this._parser.parseFromString(a, "text/xml") : (b = new ActiveXObject("Microsoft.XMLDOM"), b.async = "false", b.loadXML(a));
        return b
    }
});
cc.PlistParser = cc.SAXParser.extend({
    parse: function(a) {
        a = this._parseXML(a).documentElement;
        if ("plist" != a.tagName) throw "Not a plist file!";
        for (var b = null, c = 0, d = a.childNodes.length; c < d && !(b = a.childNodes[c], 1 == b.nodeType); c++);
        return this._parseNode(b)
    },
    _parseNode: function(a) {
        var b = null,
            c = a.tagName;
        if ("dict" == c) b = this._parseDict(a);
        else if ("array" == c) b = this._parseArray(a);
        else if ("string" == c)
            if (1 == a.childNodes.length) b = a.firstChild.nodeValue;
            else {
                b = "";
                for (c = 0; c < a.childNodes.length; c++) b += a.childNodes[c].nodeValue
            } else "false" ==
            c ? b = !1 : "true" == c ? b = !0 : "real" == c ? b = parseFloat(a.firstChild.nodeValue) : "integer" == c && (b = parseInt(a.firstChild.nodeValue, 10));
        return b
    },
    _parseArray: function(a) {
        for (var b = [], c = 0, d = a.childNodes.length; c < d; c++) {
            var e = a.childNodes[c];
            1 == e.nodeType && b.push(this._parseNode(e))
        }
        return b
    },
    _parseDict: function(a) {
        for (var b = {}, c = null, d = 0, e = a.childNodes.length; d < e; d++) {
            var f = a.childNodes[d];
            1 == f.nodeType && ("key" == f.tagName ? c = f.firstChild.nodeValue : b[c] = this._parseNode(f))
        }
        return b
    }
});
cc._txtLoader = {
    load: function(a, b, c, d) {
        cc.loader.loadTxt(a, d)
    }
};
cc.loader.register(["txt", "xml", "vsh", "fsh", "atlas"], cc._txtLoader);
cc._jsonLoader = {
    load: function(a, b, c, d) {
        cc.loader.loadJson(a, d)
    }
};
cc.loader.register(["json", "ExportJson"], cc._jsonLoader);
cc._imgLoader = {
    load: function(a, b, c, d) {
        cc.loader.cache[b] = cc.loader.loadImg(a, function(a, c) {
            if (a) return d(a);
            cc.textureCache.handleLoadedTexture(b);
            d(null, c)
        })
    }
};
cc.loader.register("png jpg bmp jpeg gif ico".split(" "), cc._imgLoader);
cc._serverImgLoader = {
    load: function(a, b, c, d) {
        cc.loader.cache[b] = cc.loader.loadImg(c.src, function(a, c) {
            if (a) return d(a);
            cc.textureCache.handleLoadedTexture(b);
            d(null, c)
        })
    }
};
cc.loader.register(["serverImg"], cc._serverImgLoader);
cc._plistLoader = {
    load: function(a, b, c, d) {
        cc.loader.loadTxt(a, function(a, b) {
            if (a) return d(a);
            d(null, cc.plistParser.parse(b))
        })
    }
};
cc.loader.register(["plist"], cc._plistLoader);
cc._fontLoader = {
    TYPE: {
        ".eot": "embedded-opentype",
        ".ttf": "truetype",
        ".woff": "woff",
        ".svg": "svg"
    },
    _loadFont: function(a, b, c) {
        var d = document,
            e = cc.path,
            f = this.TYPE,
            g = cc.newElement("style");
        g.type = "text/css";
        d.body.appendChild(g);
        var h = "@font-face { font-family:" + a + "; src:";
        if (b instanceof Array)
            for (var k = 0, m = b.length; k < m; k++) c = e.extname(b[k]).toLowerCase(), h += "url('" + b[k] + "') format('" + f[c] + "')", h += k == m - 1 ? ";" : ",";
        else h += "url('" + b + "') format('" + f[c] + "');";
        g.textContent += h + "};";
        b = cc.newElement("div");
        c =
            b.style;
        c.fontFamily = a;
        b.innerHTML = ".";
        c.position = "absolute";
        c.left = "-100px";
        c.top = "-100px";
        d.body.appendChild(b)
    },
    load: function(a, b, c, d) {
        b = c.type;
        a = c.name;
        b = c.srcs;
        cc.isString(c) ? (b = cc.path.extname(c), a = cc.path.basename(c, b), this._loadFont(a, c, b)) : this._loadFont(a, b);
        d(null, !0)
    }
};
cc.loader.register(["font", "eot", "ttf", "woff", "svg"], cc._fontLoader);
cc._binaryLoader = {
    load: function(a, b, c, d) {
        cc.loader.loadBinary(a, d)
    }
};
cc._csbLoader = {
    load: function(a, b, c, d) {
        cc.loader.loadCsb(a, d)
    }
};
cc.loader.register(["csb"], cc._csbLoader);
window.CocosEngine = cc.ENGINE_VERSION = "Cocos2d-JS v3.1";
cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL = 0;
cc.DIRECTOR_STATS_POSITION = cc.p(0, 0);
cc.DIRECTOR_FPS_INTERVAL = 0.5;
cc.COCOSNODE_RENDER_SUBPIXEL = 1;
cc.SPRITEBATCHNODE_RENDER_SUBPIXEL = 1;
cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA = 0;
cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP = 0;
cc.TEXTURE_ATLAS_USE_VAO = 0;
cc.TEXTURE_NPOT_SUPPORT = 0;
cc.RETINA_DISPLAY_SUPPORT = 1;
cc.RETINA_DISPLAY_FILENAME_SUFFIX = "-hd";
cc.USE_LA88_LABELS = 1;
cc.SPRITE_DEBUG_DRAW = 0;
cc.SPRITEBATCHNODE_DEBUG_DRAW = 0;
cc.LABELBMFONT_DEBUG_DRAW = 0;
cc.LABELATLAS_DEBUG_DRAW = 0;
cc.IS_RETINA_DISPLAY_SUPPORTED = 1;
cc.DEFAULT_ENGINE = cc.ENGINE_VERSION + "-canvas";
cc.ENABLE_STACKABLE_ACTIONS = 1;
cc.ENABLE_GL_STATE_CACHE = 1;
cc.$ = function(a) {
    var b = this == cc ? document : this;
    if (a = a instanceof HTMLElement ? a : b.querySelector(a)) a.find = a.find || cc.$, a.hasClass = a.hasClass || function(a) {
            return this.className.match(RegExp("(\\s|^)" + a + "(\\s|$)"))
        }, a.addClass = a.addClass || function(a) {
            this.hasClass(a) || (this.className && (this.className += " "), this.className += a);
            return this
        }, a.removeClass = a.removeClass || function(a) {
            this.hasClass(a) && (this.className = this.className.replace(a, ""));
            return this
        }, a.remove = a.remove || function() {
            this.parentNode &&
                this.parentNode.removeChild(this);
            return this
        }, a.appendTo = a.appendTo || function(a) {
            a.appendChild(this);
            return this
        }, a.prependTo = a.prependTo || function(a) {
            a.childNodes[0] ? a.insertBefore(this, a.childNodes[0]) : a.appendChild(this);
            return this
        }, a.transforms = a.transforms || function() {
            this.style[cc.$.trans] = cc.$.translate(this.position) + cc.$.rotate(this.rotation) + cc.$.scale(this.scale) + cc.$.skew(this.skew);
            return this
        }, a.position = a.position || {
            x: 0,
            y: 0
        }, a.rotation = a.rotation || 0, a.scale = a.scale || {
            x: 1,
            y: 1
        }, a.skew =
        a.skew || {
            x: 0,
            y: 0
        }, a.translates = function(a, b) {
            this.position.x = a;
            this.position.y = b;
            this.transforms();
            return this
        }, a.rotate = function(a) {
            this.rotation = a;
            this.transforms();
            return this
        }, a.resize = function(a, b) {
            this.scale.x = a;
            this.scale.y = b;
            this.transforms();
            return this
        }, a.setSkew = function(a, b) {
            this.skew.x = a;
            this.skew.y = b;
            this.transforms();
            return this
        };
    return a
};
switch (cc.sys.browserType) {
    case cc.sys.BROWSER_TYPE_FIREFOX:
        cc.$.pfx = "Moz";
        cc.$.hd = !0;
        break;
    case cc.sys.BROWSER_TYPE_CHROME:
    case cc.sys.BROWSER_TYPE_SAFARI:
        cc.$.pfx = "webkit";
        cc.$.hd = !0;
        break;
    case cc.sys.BROWSER_TYPE_OPERA:
        cc.$.pfx = "O";
        cc.$.hd = !1;
        break;
    case cc.sys.BROWSER_TYPE_IE:
        cc.$.pfx = "ms";
        cc.$.hd = !1;
        break;
    default:
        cc.$.pfx = "webkit", cc.$.hd = !0
}
cc.$.trans = cc.$.pfx + "Transform";
cc.$.translate = cc.$.hd ? function(a) {
    return "translate3d(" + a.x + "px, " + a.y + "px, 0) "
} : function(a) {
    return "translate(" + a.x + "px, " + a.y + "px) "
};
cc.$.rotate = cc.$.hd ? function(a) {
    return "rotateZ(" + a + "deg) "
} : function(a) {
    return "rotate(" + a + "deg) "
};
cc.$.scale = function(a) {
    return "scale(" + a.x + ", " + a.y + ") "
};
cc.$.skew = function(a) {
    return "skewX(" + -a.x + "deg) skewY(" + a.y + "deg)"
};
cc.$new = function(a) {
    return cc.$(document.createElement(a))
};
cc.$.findpos = function(a) {
    var b = 0,
        c = 0;
    do b += a.offsetLeft, c += a.offsetTop; while (a = a.offsetParent);
    return {
        x: b,
        y: c
    }
};
cc.INVALID_INDEX = -1;
cc.PI = Math.PI;
cc.FLT_MAX = parseFloat("3.402823466e+38F");
cc.FLT_MIN = parseFloat("1.175494351e-38F");
cc.RAD = cc.PI / 180;
cc.DEG = 180 / cc.PI;
cc.UINT_MAX = 4294967295;
cc.swap = function(a, b, c) {
    if (cc.isObject(c) && !cc.isUndefined(c.x) && !cc.isUndefined(c.y)) {
        var d = c[a];
        c[a] = c[b];
        c[b] = d
    } else cc.log(cc._LogInfos.swap)
};
cc.lerp = function(a, b, c) {
    return a + (b - a) * c
};
cc.rand = function() {
    return 16777215 * Math.random()
};
cc.randomMinus1To1 = function() {
    return 2 * (Math.random() - 0.5)
};
cc.random0To1 = Math.random;
cc.degreesToRadians = function(a) {
    return a * cc.RAD
};
cc.radiansToDegrees = function(a) {
    return a * cc.DEG
};
cc.radiansToDegress = function(a) {
    cc.log(cc._LogInfos.radiansToDegress);
    return a * cc.DEG
};
cc.REPEAT_FOREVER = Number.MAX_VALUE - 1;
cc.BLEND_SRC = cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA ? 1 : 770;
cc.BLEND_DST = 771;
cc.nodeDrawSetup = function(a) {
    a._shaderProgram && (a._shaderProgram.use(), a._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4())
};
cc.enableDefaultGLStates = function() {};
cc.disableDefaultGLStates = function() {};
cc.incrementGLDraws = function(a) {
    cc.g_NumberOfDraws += a
};
cc.FLT_EPSILON = 1.192092896E-7;
cc.contentScaleFactor = cc.IS_RETINA_DISPLAY_SUPPORTED ? function() {
    return cc.director.getContentScaleFactor()
} : function() {
    return 1
};
cc.pointPointsToPixels = function(a) {
    var b = cc.contentScaleFactor();
    return cc.p(a.x * b, a.y * b)
};
cc.pointPixelsToPoints = function(a) {
    var b = cc.contentScaleFactor();
    return cc.p(a.x / b, a.y / b)
};
cc._pointPixelsToPointsOut = function(a, b) {
    var c = cc.contentScaleFactor();
    b.x = a.x / c;
    b.y = a.y / c
};
cc.sizePointsToPixels = function(a) {
    var b = cc.contentScaleFactor();
    return cc.size(a.width * b, a.height * b)
};
cc.sizePixelsToPoints = function(a) {
    var b = cc.contentScaleFactor();
    return cc.size(a.width / b, a.height / b)
};
cc._sizePixelsToPointsOut = function(a, b) {
    var c = cc.contentScaleFactor();
    b.width = a.width / c;
    b.height = a.height / c
};
cc.rectPixelsToPoints = cc.IS_RETINA_DISPLAY_SUPPORTED ? function(a) {
    var b = cc.contentScaleFactor();
    return cc.rect(a.x / b, a.y / b, a.width / b, a.height / b)
} : function(a) {
    return a
};
cc.rectPointsToPixels = cc.IS_RETINA_DISPLAY_SUPPORTED ? function(a) {
    var b = cc.contentScaleFactor();
    return cc.rect(a.x * b, a.y * b, a.width * b, a.height * b)
} : function(a) {
    return a
};
cc.ONE = 1;
cc.ZERO = 0;
cc.SRC_ALPHA = 770;
cc.SRC_ALPHA_SATURATE = 776;
cc.SRC_COLOR = 768;
cc.DST_ALPHA = 772;
cc.DST_COLOR = 774;
cc.ONE_MINUS_SRC_ALPHA = 771;
cc.ONE_MINUS_SRC_COLOR = 769;
cc.ONE_MINUS_DST_ALPHA = 773;
cc.ONE_MINUS_DST_COLOR = 775;
cc.ONE_MINUS_CONSTANT_ALPHA = 32772;
cc.ONE_MINUS_CONSTANT_COLOR = 32770;
cc.checkGLErrorDebug = function() {
    if (cc.renderMode == cc._RENDER_TYPE_WEBGL) {
        var a = cc._renderContext.getError();
        a && cc.log(cc._LogInfos.checkGLErrorDebug, a)
    }
};
cc.DEVICE_ORIENTATION_PORTRAIT = 0;
cc.DEVICE_ORIENTATION_LANDSCAPE_LEFT = 1;
cc.DEVICE_ORIENTATION_PORTRAIT_UPSIDE_DOWN = 2;
cc.DEVICE_ORIENTATION_LANDSCAPE_RIGHT = 3;
cc.DEVICE_MAX_ORIENTATIONS = 2;
cc.VERTEX_ATTRIB_FLAG_NONE = 0;
cc.VERTEX_ATTRIB_FLAG_POSITION = 1;
cc.VERTEX_ATTRIB_FLAG_COLOR = 2;
cc.VERTEX_ATTRIB_FLAG_TEX_COORDS = 4;
cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX = cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS;
cc.GL_ALL = 0;
cc.VERTEX_ATTRIB_POSITION = 0;
cc.VERTEX_ATTRIB_COLOR = 1;
cc.VERTEX_ATTRIB_TEX_COORDS = 2;
cc.VERTEX_ATTRIB_MAX = 3;
cc.UNIFORM_PMATRIX = 0;
cc.UNIFORM_MVMATRIX = 1;
cc.UNIFORM_MVPMATRIX = 2;
cc.UNIFORM_TIME = 3;
cc.UNIFORM_SINTIME = 4;
cc.UNIFORM_COSTIME = 5;
cc.UNIFORM_RANDOM01 = 6;
cc.UNIFORM_SAMPLER = 7;
cc.UNIFORM_MAX = 8;
cc.SHADER_POSITION_TEXTURECOLOR = "ShaderPositionTextureColor";
cc.SHADER_POSITION_TEXTURECOLORALPHATEST = "ShaderPositionTextureColorAlphaTest";
cc.SHADER_POSITION_COLOR = "ShaderPositionColor";
cc.SHADER_POSITION_TEXTURE = "ShaderPositionTexture";
cc.SHADER_POSITION_TEXTURE_UCOLOR = "ShaderPositionTexture_uColor";
cc.SHADER_POSITION_TEXTUREA8COLOR = "ShaderPositionTextureA8Color";
cc.SHADER_POSITION_UCOLOR = "ShaderPosition_uColor";
cc.SHADER_POSITION_LENGTHTEXTURECOLOR = "ShaderPositionLengthTextureColor";
cc.UNIFORM_PMATRIX_S = "CC_PMatrix";
cc.UNIFORM_MVMATRIX_S = "CC_MVMatrix";
cc.UNIFORM_MVPMATRIX_S = "CC_MVPMatrix";
cc.UNIFORM_TIME_S = "CC_Time";
cc.UNIFORM_SINTIME_S = "CC_SinTime";
cc.UNIFORM_COSTIME_S = "CC_CosTime";
cc.UNIFORM_RANDOM01_S = "CC_Random01";
cc.UNIFORM_SAMPLER_S = "CC_Texture0";
cc.UNIFORM_ALPHA_TEST_VALUE_S = "CC_alpha_value";
cc.ATTRIBUTE_NAME_COLOR = "a_color";
cc.ATTRIBUTE_NAME_POSITION = "a_position";
cc.ATTRIBUTE_NAME_TEX_COORD = "a_texCoord";
cc.ITEM_SIZE = 32;
cc.CURRENT_ITEM = 3233828865;
cc.ZOOM_ACTION_TAG = 3233828866;
cc.NORMAL_TAG = 8801;
cc.SELECTED_TAG = 8802;
cc.DISABLE_TAG = 8803;
cc.arrayVerifyType = function(a, b) {
    if (a && 0 < a.length)
        for (var c = 0; c < a.length; c++)
            if (!(a[c] instanceof b)) return cc.log("element type is wrong!"), !1;
    return !0
};
cc.arrayRemoveObject = function(a, b) {
    for (var c = 0, d = a.length; c < d; c++)
        if (a[c] == b) {
            a.splice(c, 1);
            break
        }
};
cc.arrayRemoveArray = function(a, b) {
    for (var c = 0, d = b.length; c < d; c++) cc.arrayRemoveObject(a, b[c])
};
cc.arrayAppendObjectsToIndex = function(a, b, c) {
    a.splice.apply(a, [c, 0].concat(b));
    return a
};
cc.copyArray = function(a) {
    var b, c = a.length,
        d = Array(c);
    for (b = 0; b < c; b += 1) d[b] = a[b];
    return d
};
cc = cc || {};
cc._tmp = cc._tmp || {};
cc._tmp.WebGLColor = function() {
    cc.color = function(a, c, d, e, f, g) {
        return void 0 === a ? new cc.Color(0, 0, 0, 255, f, g) : cc.isString(a) ? (a = cc.hexToColor(a), new cc.Color(a.r, a.g, a.b, a.a)) : cc.isObject(a) ? new cc.Color(a.r, a.g, a.b, a.a, a.arrayBuffer, a.offset) : new cc.Color(a, c, d, e, f, g)
    };
    cc.Color = function(a, c, d, e, f, g) {
        this._arrayBuffer = f || new ArrayBuffer(cc.Color.BYTES_PER_ELEMENT);
        this._offset = g || 0;
        f = this._arrayBuffer;
        g = this._offset;
        var h = Uint8Array.BYTES_PER_ELEMENT;
        this._rU8 = new Uint8Array(f, g, 1);
        this._gU8 = new Uint8Array(f,
            g + h, 1);
        this._bU8 = new Uint8Array(f, g + 2 * h, 1);
        this._aU8 = new Uint8Array(f, g + 3 * h, 1);
        this._rU8[0] = a || 0;
        this._gU8[0] = c || 0;
        this._bU8[0] = d || 0;
        this._aU8[0] = null == e ? 255 : e;
        void 0 === e && (this.a_undefined = !0)
    };
    cc.Color.BYTES_PER_ELEMENT = 4;
    var a = cc.Color.prototype;
    a._getR = function() {
        return this._rU8[0]
    };
    a._setR = function(a) {
        this._rU8[0] = 0 > a ? 0 : a
    };
    a._getG = function() {
        return this._gU8[0]
    };
    a._setG = function(a) {
        this._gU8[0] = 0 > a ? 0 : a
    };
    a._getB = function() {
        return this._bU8[0]
    };
    a._setB = function(a) {
        this._bU8[0] = 0 > a ? 0 : a
    };
    a._getA =
        function() {
            return this._aU8[0]
        };
    a._setA = function(a) {
        this._aU8[0] = 0 > a ? 0 : a
    };
    cc.defineGetterSetter(a, "r", a._getR, a._setR);
    cc.defineGetterSetter(a, "g", a._getG, a._setG);
    cc.defineGetterSetter(a, "b", a._getB, a._setB);
    cc.defineGetterSetter(a, "a", a._getA, a._setA);
    cc.Vertex2F = function(a, c, d, e) {
        this._arrayBuffer = d || new ArrayBuffer(cc.Vertex2F.BYTES_PER_ELEMENT);
        this._offset = e || 0;
        this._xF32 = new Float32Array(this._arrayBuffer, this._offset, 1);
        this._yF32 = new Float32Array(this._arrayBuffer, this._offset + 4, 1);
        this._xF32[0] =
            a || 0;
        this._yF32[0] = c || 0
    };
    cc.Vertex2F.BYTES_PER_ELEMENT = 8;
    Object.defineProperties(cc.Vertex2F.prototype, {
        x: {
            get: function() {
                return this._xF32[0]
            },
            set: function(a) {
                this._xF32[0] = a
            },
            enumerable: !0
        },
        y: {
            get: function() {
                return this._yF32[0]
            },
            set: function(a) {
                this._yF32[0] = a
            },
            enumerable: !0
        }
    });
    cc.Vertex3F = function(a, c, d, e, f) {
        this._arrayBuffer = e || new ArrayBuffer(cc.Vertex3F.BYTES_PER_ELEMENT);
        this._offset = f || 0;
        e = this._arrayBuffer;
        f = this._offset;
        this._xF32 = new Float32Array(e, f, 1);
        this._xF32[0] = a || 0;
        this._yF32 = new Float32Array(e,
            f + Float32Array.BYTES_PER_ELEMENT, 1);
        this._yF32[0] = c || 0;
        this._zF32 = new Float32Array(e, f + 2 * Float32Array.BYTES_PER_ELEMENT, 1);
        this._zF32[0] = d || 0
    };
    cc.Vertex3F.BYTES_PER_ELEMENT = 12;
    Object.defineProperties(cc.Vertex3F.prototype, {
        x: {
            get: function() {
                return this._xF32[0]
            },
            set: function(a) {
                this._xF32[0] = a
            },
            enumerable: !0
        },
        y: {
            get: function() {
                return this._yF32[0]
            },
            set: function(a) {
                this._yF32[0] = a
            },
            enumerable: !0
        },
        z: {
            get: function() {
                return this._zF32[0]
            },
            set: function(a) {
                this._zF32[0] = a
            },
            enumerable: !0
        }
    });
    cc.Tex2F = function(a,
        c, d, e) {
        this._arrayBuffer = d || new ArrayBuffer(cc.Tex2F.BYTES_PER_ELEMENT);
        this._offset = e || 0;
        this._uF32 = new Float32Array(this._arrayBuffer, this._offset, 1);
        this._vF32 = new Float32Array(this._arrayBuffer, this._offset + 4, 1);
        this._uF32[0] = a || 0;
        this._vF32[0] = c || 0
    };
    cc.Tex2F.BYTES_PER_ELEMENT = 8;
    Object.defineProperties(cc.Tex2F.prototype, {
        u: {
            get: function() {
                return this._uF32[0]
            },
            set: function(a) {
                this._uF32[0] = a
            },
            enumerable: !0
        },
        v: {
            get: function() {
                return this._vF32[0]
            },
            set: function(a) {
                this._vF32[0] = a
            },
            enumerable: !0
        }
    });
    cc.Quad2 = function(a, c, d, e, f, g) {
        this._arrayBuffer = f || new ArrayBuffer(cc.Quad2.BYTES_PER_ELEMENT);
        this._offset = g || 0;
        f = this._arrayBuffer;
        g = cc.Vertex2F.BYTES_PER_ELEMENT;
        this._tl = a ? new cc.Vertex2F(a.x, a.y, f, 0) : new cc.Vertex2F(0, 0, f, 0);
        this._tr = c ? new cc.Vertex2F(c.x, c.y, f, g) : new cc.Vertex2F(0, 0, f, g);
        this._bl = d ? new cc.Vertex2F(d.x, d.y, f, 2 * g) : new cc.Vertex2F(0, 0, f, 2 * g);
        this._br = e ? new cc.Vertex2F(e.x, e.y, f, 3 * g) : new cc.Vertex2F(0, 0, f, 3 * g)
    };
    cc.Quad2.BYTES_PER_ELEMENT = 32;
    cc.Quad3 = function(a, c, d, e) {
        this.bl = a ||
            new cc.Vertex3F(0, 0, 0);
        this.br = c || new cc.Vertex3F(0, 0, 0);
        this.tl = d || new cc.Vertex3F(0, 0, 0);
        this.tr = e || new cc.Vertex3F(0, 0, 0)
    };
    Object.defineProperties(cc.Quad2.prototype, {
        tl: {
            get: function() {
                return this._tl
            },
            set: function(a) {
                this._tl.x = a.x;
                this._tl.y = a.y
            },
            enumerable: !0
        },
        tr: {
            get: function() {
                return this._tr
            },
            set: function(a) {
                this._tr.x = a.x;
                this._tr.y = a.y
            },
            enumerable: !0
        },
        bl: {
            get: function() {
                return this._bl
            },
            set: function(a) {
                this._bl.x = a.x;
                this._bl.y = a.y
            },
            enumerable: !0
        },
        br: {
            get: function() {
                return this._br
            },
            set: function(a) {
                this._br.x =
                    a.x;
                this._br.y = a.y
            },
            enumerable: !0
        }
    });
    cc.V3F_C4B_T2F = function(a, c, d, e, f) {
        this._arrayBuffer = e || new ArrayBuffer(cc.V3F_C4B_T2F.BYTES_PER_ELEMENT);
        this._offset = f || 0;
        e = this._arrayBuffer;
        f = this._offset;
        var g = cc.Vertex3F.BYTES_PER_ELEMENT;
        this._vertices = a ? new cc.Vertex3F(a.x, a.y, a.z, e, f) : new cc.Vertex3F(0, 0, 0, e, f);
        this._colors = c ? cc.color(c.r, c.g, c.b, c.a, e, f + g) : cc.color(0, 0, 0, 0, e, f + g);
        this._texCoords = d ? new cc.Tex2F(d.u, d.v, e, f + g + cc.Color.BYTES_PER_ELEMENT) : new cc.Tex2F(0, 0, e, f + g + cc.Color.BYTES_PER_ELEMENT)
    };
    cc.V3F_C4B_T2F.BYTES_PER_ELEMENT = 24;
    Object.defineProperties(cc.V3F_C4B_T2F.prototype, {
        vertices: {
            get: function() {
                return this._vertices
            },
            set: function(a) {
                var c = this._vertices;
                c.x = a.x;
                c.y = a.y;
                c.z = a.z
            },
            enumerable: !0
        },
        colors: {
            get: function() {
                return this._colors
            },
            set: function(a) {
                var c = this._colors;
                c.r = a.r;
                c.g = a.g;
                c.b = a.b;
                c.a = a.a
            },
            enumerable: !0
        },
        texCoords: {
            get: function() {
                return this._texCoords
            },
            set: function(a) {
                this._texCoords.u = a.u;
                this._texCoords.v = a.v
            },
            enumerable: !0
        }
    });
    cc.V3F_C4B_T2F_Quad = function(a, c, d,
        e, f, g) {
        this._arrayBuffer = f || new ArrayBuffer(cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT);
        this._offset = g || 0;
        f = this._arrayBuffer;
        g = this._offset;
        var h = cc.V3F_C4B_T2F.BYTES_PER_ELEMENT;
        this._tl = a ? new cc.V3F_C4B_T2F(a.vertices, a.colors, a.texCoords, f, g) : new cc.V3F_C4B_T2F(null, null, null, f, g);
        this._bl = c ? new cc.V3F_C4B_T2F(c.vertices, c.colors, c.texCoords, f, g + h) : new cc.V3F_C4B_T2F(null, null, null, f, g + h);
        this._tr = d ? new cc.V3F_C4B_T2F(d.vertices, d.colors, d.texCoords, f, g + 2 * h) : new cc.V3F_C4B_T2F(null, null, null, f, g + 2 *
            h);
        this._br = e ? new cc.V3F_C4B_T2F(e.vertices, e.colors, e.texCoords, f, g + 3 * h) : new cc.V3F_C4B_T2F(null, null, null, f, g + 3 * h)
    };
    cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT = 96;
    Object.defineProperties(cc.V3F_C4B_T2F_Quad.prototype, {
        tl: {
            get: function() {
                return this._tl
            },
            set: function(a) {
                var c = this._tl;
                c.vertices = a.vertices;
                c.colors = a.colors;
                c.texCoords = a.texCoords
            },
            enumerable: !0
        },
        bl: {
            get: function() {
                return this._bl
            },
            set: function(a) {
                var c = this._bl;
                c.vertices = a.vertices;
                c.colors = a.colors;
                c.texCoords = a.texCoords
            },
            enumerable: !0
        },
        tr: {
            get: function() {
                return this._tr
            },
            set: function(a) {
                var c = this._tr;
                c.vertices = a.vertices;
                c.colors = a.colors;
                c.texCoords = a.texCoords
            },
            enumerable: !0
        },
        br: {
            get: function() {
                return this._br
            },
            set: function(a) {
                var c = this._br;
                c.vertices = a.vertices;
                c.colors = a.colors;
                c.texCoords = a.texCoords
            },
            enumerable: !0
        },
        arrayBuffer: {
            get: function() {
                return this._arrayBuffer
            },
            enumerable: !0
        }
    });
    cc.V3F_C4B_T2F_QuadZero = function() {
        return new cc.V3F_C4B_T2F_Quad
    };
    cc.V3F_C4B_T2F_QuadCopy = function(a) {
        if (!a) return cc.V3F_C4B_T2F_QuadZero();
        var c = a.tl,
            d = a.bl,
            e = a.tr;
        a = a.br;
        return {
            tl: {
                vertices: {
                    x: c.vertices.x,
                    y: c.vertices.y,
                    z: c.vertices.z
                },
                colors: {
                    r: c.colors.r,
                    g: c.colors.g,
                    b: c.colors.b,
                    a: c.colors.a
                },
                texCoords: {
                    u: c.texCoords.u,
                    v: c.texCoords.v
                }
            },
            bl: {
                vertices: {
                    x: d.vertices.x,
                    y: d.vertices.y,
                    z: d.vertices.z
                },
                colors: {
                    r: d.colors.r,
                    g: d.colors.g,
                    b: d.colors.b,
                    a: d.colors.a
                },
                texCoords: {
                    u: d.texCoords.u,
                    v: d.texCoords.v
                }
            },
            tr: {
                vertices: {
                    x: e.vertices.x,
                    y: e.vertices.y,
                    z: e.vertices.z
                },
                colors: {
                    r: e.colors.r,
                    g: e.colors.g,
                    b: e.colors.b,
                    a: e.colors.a
                },
                texCoords: {
                    u: e.texCoords.u,
                    v: e.texCoords.v
                }
            },
            br: {
                vertices: {
                    x: a.vertices.x,
                    y: a.vertices.y,
                    z: a.vertices.z
                },
                colors: {
                    r: a.colors.r,
                    g: a.colors.g,
                    b: a.colors.b,
                    a: a.colors.a
                },
                texCoords: {
                    u: a.texCoords.u,
                    v: a.texCoords.v
                }
            }
        }
    };
    cc.V3F_C4B_T2F_QuadsCopy = function(a) {
        if (!a) return [];
        for (var c = [], d = 0; d < a.length; d++) c.push(cc.V3F_C4B_T2F_QuadCopy(a[d]));
        return c
    };
    cc.V2F_C4B_T2F = function(a, c, d, e, f) {
        this._arrayBuffer = e || new ArrayBuffer(cc.V2F_C4B_T2F.BYTES_PER_ELEMENT);
        this._offset = f || 0;
        e = this._arrayBuffer;
        f = this._offset;
        var g = cc.Vertex2F.BYTES_PER_ELEMENT;
        this._vertices = a ? new cc.Vertex2F(a.x, a.y, e, f) : new cc.Vertex2F(0, 0, e, f);
        this._colors = c ? cc.color(c.r, c.g, c.b, c.a, e, f + g) : cc.color(0, 0, 0, 0, e, f + g);
        this._texCoords = d ? new cc.Tex2F(d.u, d.v, e, f + g + cc.Color.BYTES_PER_ELEMENT) : new cc.Tex2F(0, 0, e, f + g + cc.Color.BYTES_PER_ELEMENT)
    };
    cc.V2F_C4B_T2F.BYTES_PER_ELEMENT = 20;
    Object.defineProperties(cc.V2F_C4B_T2F.prototype, {
        vertices: {
            get: function() {
                return this._vertices
            },
            set: function(a) {
                this._vertices.x = a.x;
                this._vertices.y = a.y
            },
            enumerable: !0
        },
        colors: {
            get: function() {
                return this._colors
            },
            set: function(a) {
                var c = this._colors;
                c.r = a.r;
                c.g = a.g;
                c.b = a.b;
                c.a = a.a
            },
            enumerable: !0
        },
        texCoords: {
            get: function() {
                return this._texCoords
            },
            set: function(a) {
                this._texCoords.u = a.u;
                this._texCoords.v = a.v
            },
            enumerable: !0
        }
    });
    cc.V2F_C4B_T2F_Triangle = function(a, c, d, e, f) {
        this._arrayBuffer = e || new ArrayBuffer(cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT);
        this._offset = f || 0;
        e = this._arrayBuffer;
        f = this._offset;
        var g = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
        this._a = a ? new cc.V2F_C4B_T2F(a.vertices, a.colors, a.texCoords, e, f) : new cc.V2F_C4B_T2F(null,
            null, null, e, f);
        this._b = c ? new cc.V2F_C4B_T2F(c.vertices, c.colors, c.texCoords, e, f + g) : new cc.V2F_C4B_T2F(null, null, null, e, f + g);
        this._c = d ? new cc.V2F_C4B_T2F(d.vertices, d.colors, d.texCoords, e, f + 2 * g) : new cc.V2F_C4B_T2F(null, null, null, e, f + 2 * g)
    };
    cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT = 60;
    Object.defineProperties(cc.V2F_C4B_T2F_Triangle.prototype, {
        a: {
            get: function() {
                return this._a
            },
            set: function(a) {
                var c = this._a;
                c.vertices = a.vertices;
                c.colors = a.colors;
                c.texCoords = a.texCoords
            },
            enumerable: !0
        },
        b: {
            get: function() {
                return this._b
            },
            set: function(a) {
                var c = this._b;
                c.vertices = a.vertices;
                c.colors = a.colors;
                c.texCoords = a.texCoords
            },
            enumerable: !0
        },
        c: {
            get: function() {
                return this._c
            },
            set: function(a) {
                var c = this._c;
                c.vertices = a.vertices;
                c.colors = a.colors;
                c.texCoords = a.texCoords
            },
            enumerable: !0
        }
    })
};
cc._tmp.PrototypeColor = function() {
    var a = cc.color;
    a._getWhite = function() {
        return a(255, 255, 255)
    };
    a._getYellow = function() {
        return a(255, 255, 0)
    };
    a._getBlue = function() {
        return a(0, 0, 255)
    };
    a._getGreen = function() {
        return a(0, 255, 0)
    };
    a._getRed = function() {
        return a(255, 0, 0)
    };
    a._getMagenta = function() {
        return a(255, 0, 255)
    };
    a._getBlack = function() {
        return a(0, 0, 0)
    };
    a._getOrange = function() {
        return a(255, 127, 0)
    };
    a._getGray = function() {
        return a(166, 166, 166)
    };
    cc.defineGetterSetter(a, "WHITE", a._getWhite);
    cc.defineGetterSetter(a,
        "YELLOW", a._getYellow);
    cc.defineGetterSetter(a, "BLUE", a._getBlue);
    cc.defineGetterSetter(a, "GREEN", a._getGreen);
    cc.defineGetterSetter(a, "RED", a._getRed);
    cc.defineGetterSetter(a, "MAGENTA", a._getMagenta);
    cc.defineGetterSetter(a, "BLACK", a._getBlack);
    cc.defineGetterSetter(a, "ORANGE", a._getOrange);
    cc.defineGetterSetter(a, "GRAY", a._getGray);
    cc.BlendFunc._disable = function() {
        return new cc.BlendFunc(cc.ONE, cc.ZERO)
    };
    cc.BlendFunc._alphaPremultiplied = function() {
        return new cc.BlendFunc(cc.ONE, cc.ONE_MINUS_SRC_ALPHA)
    };
    cc.BlendFunc._alphaNonPremultiplied = function() {
        return new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA)
    };
    cc.BlendFunc._additive = function() {
        return new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE)
    };
    cc.defineGetterSetter(cc.BlendFunc, "DISABLE", cc.BlendFunc._disable);
    cc.defineGetterSetter(cc.BlendFunc, "ALPHA_PREMULTIPLIED", cc.BlendFunc._alphaPremultiplied);
    cc.defineGetterSetter(cc.BlendFunc, "ALPHA_NON_PREMULTIPLIED", cc.BlendFunc._alphaNonPremultiplied);
    cc.defineGetterSetter(cc.BlendFunc, "ADDITIVE", cc.BlendFunc._additive)
};
cc.Color = function(a, b, c, d) {
    this.r = a || 0;
    this.g = b || 0;
    this.b = c || 0;
    this.a = null == d ? 255 : d
};
cc.color = function(a, b, c, d) {
    return void 0 === a ? {
        r: 0,
        g: 0,
        b: 0,
        a: 255
    } : cc.isString(a) ? cc.hexToColor(a) : cc.isObject(a) ? {
        r: a.r,
        g: a.g,
        b: a.b,
        a: null == a.a ? 255 : a.a
    } : {
        r: a,
        g: b,
        b: c,
        a: null == d ? 255 : d
    }
};
cc.colorEqual = function(a, b) {
    return a.r === b.r && a.g === b.g && a.b === b.b
};
cc.Acceleration = function(a, b, c, d) {
    this.x = a || 0;
    this.y = b || 0;
    this.z = c || 0;
    this.timestamp = d || 0
};
cc.Vertex2F = function(a, b) {
    this.x = a || 0;
    this.y = b || 0
};
cc.vertex2 = function(a, b) {
    return new cc.Vertex2F(a, b)
};
cc.Vertex3F = function(a, b, c) {
    this.x = a || 0;
    this.y = b || 0;
    this.z = c || 0
};
cc.vertex3 = function(a, b, c) {
    return new cc.Vertex3F(a, b, c)
};
cc.Tex2F = function(a, b) {
    this.u = a || 0;
    this.v = b || 0
};
cc.tex2 = function(a, b) {
    return new cc.Tex2F(a, b)
};
cc.BlendFunc = function(a, b) {
    this.src = a;
    this.dst = b
};
cc.blendFuncDisable = function() {
    return new cc.BlendFunc(cc.ONE, cc.ZERO)
};
cc.hexToColor = function(a) {
    a = a.replace(/^#?/, "0x");
    a = parseInt(a);
    return cc.color(a >> 16, (a >> 8) % 256, a % 256)
};
cc.colorToHex = function(a) {
    var b = a.r.toString(16),
        c = a.g.toString(16),
        d = a.b.toString(16);
    return "#" + (16 > a.r ? "0" + b : b) + (16 > a.g ? "0" + c : c) + (16 > a.b ? "0" + d : d)
};
cc.TEXT_ALIGNMENT_LEFT = 0;
cc.TEXT_ALIGNMENT_CENTER = 1;
cc.TEXT_ALIGNMENT_RIGHT = 2;
cc.VERTICAL_TEXT_ALIGNMENT_TOP = 0;
cc.VERTICAL_TEXT_ALIGNMENT_CENTER = 1;
cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM = 2;
cc._Dictionary = cc.Class.extend({
    _keyMapTb: null,
    _valueMapTb: null,
    __currId: 0,
    ctor: function() {
        this._keyMapTb = {};
        this._valueMapTb = {};
        this.__currId = 2 << (0 | 10 * Math.random())
    },
    __getKey: function() {
        this.__currId++;
        return "key_" + this.__currId
    },
    setObject: function(a, b) {
        if (null != b) {
            var c = this.__getKey();
            this._keyMapTb[c] = b;
            this._valueMapTb[c] = a
        }
    },
    objectForKey: function(a) {
        if (null == a) return null;
        var b = this._keyMapTb,
            c;
        for (c in b)
            if (b[c] === a) return this._valueMapTb[c];
        return null
    },
    valueForKey: function(a) {
        return this.objectForKey(a)
    },
    removeObjectForKey: function(a) {
        if (null != a) {
            var b = this._keyMapTb,
                c;
            for (c in b)
                if (b[c] === a) {
                    delete this._valueMapTb[c];
                    delete b[c];
                    break
                }
        }
    },
    removeObjectsForKeys: function(a) {
        if (null != a)
            for (var b = 0; b < a.length; b++) this.removeObjectForKey(a[b])
    },
    allKeys: function() {
        var a = [],
            b = this._keyMapTb,
            c;
        for (c in b) a.push(b[c]);
        return a
    },
    removeAllObjects: function() {
        this._keyMapTb = {};
        this._valueMapTb = {}
    },
    count: function() {
        return this.allKeys().length
    }
});
cc.FontDefinition = function() {
    this.fontName = "Arial";
    this.fontSize = 12;
    this.textAlign = cc.TEXT_ALIGNMENT_CENTER;
    this.verticalAlign = cc.VERTICAL_TEXT_ALIGNMENT_TOP;
    this.fillStyle = cc.color(255, 255, 255, 255);
    this.boundingHeight = this.boundingWidth = 0;
    this.strokeEnabled = !1;
    this.strokeStyle = cc.color(255, 255, 255, 255);
    this.lineWidth = 1;
    this.shadowEnabled = !1;
    this.shadowBlur = this.shadowOffsetY = this.shadowOffsetX = 0;
    this.shadowOpacity = 1
};
cc._renderType === cc._RENDER_TYPE_WEBGL && (cc.assert(cc.isFunction(cc._tmp.WebGLColor), cc._LogInfos.MissingFile, "CCTypesWebGL.js"), cc._tmp.WebGLColor(), delete cc._tmp.WebGLColor);
cc.assert(cc.isFunction(cc._tmp.PrototypeColor), cc._LogInfos.MissingFile, "CCTypesPropertyDefine.js");
cc._tmp.PrototypeColor();
delete cc._tmp.PrototypeColor;
cc.Touches = [];
cc.TouchesIntergerDict = {};
cc.DENSITYDPI_DEVICE = "device-dpi";
cc.DENSITYDPI_HIGH = "high-dpi";
cc.DENSITYDPI_MEDIUM = "medium-dpi";
cc.DENSITYDPI_LOW = "low-dpi";
cc.EGLView = cc.Class.extend({
    _delegate: null,
    _frameSize: null,
    _designResolutionSize: null,
    _originalDesignResolutionSize: null,
    _viewPortRect: null,
    _visibleRect: null,
    _retinaEnabled: !1,
    _autoFullScreen: !0,
    _devicePixelRatio: 1,
    _viewName: "",
    _resizeCallback: null,
    _scaleX: 1,
    _originalScaleX: 1,
    _scaleY: 1,
    _originalScaleY: 1,
    _indexBitsUsed: 0,
    _maxTouches: 5,
    _resolutionPolicy: null,
    _rpExactFit: null,
    _rpShowAll: null,
    _rpNoBorder: null,
    _rpFixedHeight: null,
    _rpFixedWidth: null,
    _initialized: !1,
    _captured: !1,
    _wnd: null,
    _hDC: null,
    _hRC: null,
    _supportTouch: !1,
    _contentTranslateLeftTop: null,
    _frame: null,
    _frameZoomFactor: 1,
    __resizeWithBrowserSize: !1,
    _isAdjustViewPort: !0,
    _targetDensityDPI: null,
    ctor: function() {
        var a = document,
            b = cc.ContainerStrategy,
            c = cc.ContentStrategy;
        this._frame = cc.container.parentNode === a.body ? a.documentElement : cc.container.parentNode;
        this._frameSize = cc.size(0, 0);
        this._initFrameSize();
        var a = cc._canvas.width,
            d = cc._canvas.height;
        this._designResolutionSize = cc.size(a, d);
        this._originalDesignResolutionSize = cc.size(a, d);
        this._viewPortRect =
            cc.rect(0, 0, a, d);
        this._visibleRect = cc.rect(0, 0, a, d);
        this._contentTranslateLeftTop = {
            left: 0,
            top: 0
        };
        this._viewName = "Cocos2dHTML5";
        a = cc.sys;
        this.enableRetina(a.os == a.OS_IOS || a.os == a.OS_OSX);
        cc.visibleRect && cc.visibleRect.init(this._visibleRect);
        this._rpExactFit = new cc.ResolutionPolicy(b.EQUAL_TO_FRAME, c.EXACT_FIT);
        this._rpShowAll = new cc.ResolutionPolicy(b.PROPORTION_TO_FRAME, c.SHOW_ALL);
        this._rpNoBorder = new cc.ResolutionPolicy(b.EQUAL_TO_FRAME, c.NO_BORDER);
        this._rpFixedHeight = new cc.ResolutionPolicy(b.EQUAL_TO_FRAME,
            c.FIXED_HEIGHT);
        this._rpFixedWidth = new cc.ResolutionPolicy(b.EQUAL_TO_FRAME, c.FIXED_WIDTH);
        this._hDC = cc._canvas;
        this._hRC = cc._renderContext;
        this._targetDensityDPI = cc.DENSITYDPI_HIGH
    },
    _resizeEvent: function() {
        var a = this._originalDesignResolutionSize.width,
            b = this._originalDesignResolutionSize.height;
        this._resizeCallback && (this._initFrameSize(), this._resizeCallback.call());
        0 < a && this.setDesignResolutionSize(a, b, this._resolutionPolicy)
    },
    setTargetDensityDPI: function(a) {
        this._targetDensityDPI = a;
        this._setViewPortMeta()
    },
    getTargetDensityDPI: function() {
        return this._targetDensityDPI
    },
    resizeWithBrowserSize: function(a) {
        a ? this.__resizeWithBrowserSize || (this.__resizeWithBrowserSize = !0, a = this._resizeEvent.bind(this), cc._addEventListener(window, "resize", a, !1)) : this.__resizeWithBrowserSize && (this.__resizeWithBrowserSize = !0, a = this._resizeEvent.bind(this), window.removeEventListener("resize", a, !1))
    },
    setResizeCallback: function(a) {
        if (cc.isFunction(a) || null == a) this._resizeCallback = a
    },
    _initFrameSize: function() {
        var a = this._frameSize;
        a.width = this._frame.clientWidth;
        a.height = this._frame.clientHeight
    },
    _adjustSizeKeepCanvasSize: function() {
        var a = this._originalDesignResolutionSize.width,
            b = this._originalDesignResolutionSize.height;
        0 < a && this.setDesignResolutionSize(a, b, this._resolutionPolicy)
    },
    _setViewPortMeta: function() {
        if (this._isAdjustViewPort) {
            var a = document.getElementById("cocosMetaElement");
            a && document.head.removeChild(a);
            var b, c = (a = document.getElementsByName("viewport")) ? a[0] : null,
                d, a = cc.newElement("meta");
            a.id = "cocosMetaElement";
            a.name = "viewport";
            a.content = "";
            b = cc.sys.isMobile && cc.sys.browserType == cc.sys.BROWSER_TYPE_FIREFOX ? {
                width: "device-width",
                "initial-scale": "1.0"
            } : {
                width: "device-width",
                "user-scalable": "no",
                "maximum-scale": "1.0",
                "initial-scale": "1.0"
            };
            cc.sys.isMobile && (b["target-densitydpi"] = this._targetDensityDPI);
            d = c ? c.content : "";
            for (var e in b) RegExp(e).test(d) || (d += "," + e + "\x3d" + b[e]);
            "" != d && (d = d.substr(1));
            a.content = d;
            c && (c.content = d);
            document.head.appendChild(a)
        }
    },
    _setScaleXYForRenderTexture: function() {
        var a = cc.contentScaleFactor();
        this._scaleY = this._scaleX = a
    },
    _resetScale: function() {
        this._scaleX = this._originalScaleX;
        this._scaleY = this._originalScaleY
    },
    _adjustSizeToBrowser: function() {},
    initialize: function() {
        this._initialized = !0
    },
    adjustViewPort: function(a) {
        this._isAdjustViewPort = a
    },
    enableRetina: function(a) {
        this._retinaEnabled = a ? !0 : !1
    },
    isRetinaEnabled: function() {
        return this._retinaEnabled
    },
    enableAutoFullScreen: function(a) {
        this._autoFullScreen = a ? !0 : !1
    },
    isAutoFullScreenEnabled: function() {
        return this._autoFullScreen
    },
    end: function() {},
    isOpenGLReady: function() {
        return null != this._hDC && null != this._hRC
    },
    setFrameZoomFactor: function(a) {
        this._frameZoomFactor = a;
        this.centerWindow();
        cc.director.setProjection(cc.director.getProjection())
    },
    swapBuffers: function() {},
    setIMEKeyboardState: function(a) {},
    setContentTranslateLeftTop: function(a, b) {
        this._contentTranslateLeftTop = {
            left: a,
            top: b
        }
    },
    getContentTranslateLeftTop: function() {
        return this._contentTranslateLeftTop
    },
    getFrameSize: function() {
        return cc.size(this._frameSize.width, this._frameSize.height)
    },
    setFrameSize: function(a, b) {
        this._frameSize.width = a;
        this._frameSize.height = b;
        this._frame.style.width = a + "px";
        this._frame.style.height = b + "px";
        this._resizeEvent();
        cc.director.setProjection(cc.director.getProjection())
    },
    centerWindow: function() {},
    getVisibleSize: function() {
        return cc.size(this._visibleRect.width, this._visibleRect.height)
    },
    getVisibleOrigin: function() {
        return cc.p(this._visibleRect.x, this._visibleRect.y)
    },
    canSetContentScaleFactor: function() {
        return !0
    },
    getResolutionPolicy: function() {
        return this._resolutionPolicy
    },
    setResolutionPolicy: function(a) {
        if (a instanceof cc.ResolutionPolicy) this._resolutionPolicy = a;
        else {
            var b = cc.ResolutionPolicy;
            a === b.EXACT_FIT && (this._resolutionPolicy = this._rpExactFit);
            a === b.SHOW_ALL && (this._resolutionPolicy = this._rpShowAll);
            a === b.NO_BORDER && (this._resolutionPolicy = this._rpNoBorder);
            a === b.FIXED_HEIGHT && (this._resolutionPolicy = this._rpFixedHeight);
            a === b.FIXED_WIDTH && (this._resolutionPolicy = this._rpFixedWidth)
        }
    },
    setDesignResolutionSize: function(a, b, c) {
        isNaN(a) || 0 == a || isNaN(b) || 0 == b ? cc.log(cc._LogInfos.EGLView_setDesignResolutionSize) :
            (this.setResolutionPolicy(c), (c = this._resolutionPolicy) ? (c.preApply(this), cc.sys.isMobile && this._setViewPortMeta(), this._initFrameSize(), this._designResolutionSize = cc.size(a, b), this._originalDesignResolutionSize = cc.size(a, b), a = c.apply(this, this._designResolutionSize), a.scale && 2 == a.scale.length && (this._scaleX = a.scale[0], this._scaleY = a.scale[1]), a.viewport && (a = this._viewPortRect = a.viewport, b = this._visibleRect, b.width = cc._canvas.width / this._scaleX, b.height = cc._canvas.height / this._scaleY, b.x = -a.x / this._scaleX,
                    b.y = -a.y / this._scaleY), a = cc.director, a._winSizeInPoints.width = this._designResolutionSize.width, a._winSizeInPoints.height = this._designResolutionSize.height, c.postApply(this), cc.winSize.width = a._winSizeInPoints.width, cc.winSize.height = a._winSizeInPoints.height, cc._renderType == cc._RENDER_TYPE_WEBGL && (a._createStatsLabel(), a.setGLDefaultValues()), this._originalScaleX = this._scaleX, this._originalScaleY = this._scaleY, cc.DOM && cc.DOM._resetEGLViewDiv(), cc.visibleRect && cc.visibleRect.init(this._visibleRect)) :
                cc.log(cc._LogInfos.EGLView_setDesignResolutionSize_2))
    },
    getDesignResolutionSize: function() {
        return cc.size(this._designResolutionSize.width, this._designResolutionSize.height)
    },
    setViewPortInPoints: function(a, b, c, d) {
        var e = this._frameZoomFactor,
            f = this._scaleX,
            g = this._scaleY;
        cc._renderContext.viewport(a * f * e + this._viewPortRect.x * e, b * g * e + this._viewPortRect.y * e, c * f * e, d * g * e)
    },
    setScissorInPoints: function(a, b, c, d) {
        var e = this._frameZoomFactor,
            f = this._scaleX,
            g = this._scaleY;
        cc._renderContext.scissor(a * f * e + this._viewPortRect.x *
            e, b * g * e + this._viewPortRect.y * e, c * f * e, d * g * e)
    },
    isScissorEnabled: function() {
        var a = cc._renderContext;
        return a.isEnabled(a.SCISSOR_TEST)
    },
    getScissorRect: function() {
        var a = cc._renderContext,
            b = this._scaleX,
            c = this._scaleY,
            a = a.getParameter(a.SCISSOR_BOX);
        return cc.rect((a[0] - this._viewPortRect.x) / b, (a[1] - this._viewPortRect.y) / c, a[2] / b, a[3] / c)
    },
    setViewName: function(a) {
        null != a && 0 < a.length && (this._viewName = a)
    },
    getViewName: function() {
        return this._viewName
    },
    getViewPortRect: function() {
        return this._viewPortRect
    },
    getScaleX: function() {
        return this._scaleX
    },
    getScaleY: function() {
        return this._scaleY
    },
    getDevicePixelRatio: function() {
        return this._devicePixelRatio
    },
    convertToLocationInView: function(a, b, c) {
        return {
            x: this._devicePixelRatio * (a - c.left),
            y: this._devicePixelRatio * (c.top + c.height - b)
        }
    },
    _convertMouseToLocationInView: function(a, b) {
        var c = this._viewPortRect;
        a.x = (this._devicePixelRatio * (a.x - b.left) - c.x) / this._scaleX;
        a.y = (this._devicePixelRatio * (b.top + b.height - a.y) - c.y) / this._scaleY
    },
    _convertTouchesWithScale: function(a) {
        for (var b =
            this._viewPortRect, c = this._scaleX, d = this._scaleY, e, f, g, h = 0; h < a.length; h++) e = a[h], f = e._point, g = e._prevPoint, e._setPoint((f.x - b.x) / c, (f.y - b.y) / d), e._setPrevPoint((g.x - b.x) / c, (g.y - b.y) / d)
    }
});
cc.EGLView._getInstance = function() {
    this._instance || (this._instance = this._instance || new cc.EGLView, this._instance.initialize());
    return this._instance
};
cc.ContainerStrategy = cc.Class.extend({
    preApply: function(a) {},
    apply: function(a, b) {},
    postApply: function(a) {},
    _setupContainer: function(a, b, c) {
        var d = a._frame;
        cc.view._autoFullScreen && (cc.sys.isMobile && d == document.documentElement) && cc.screen.autoFullScreen(d);
        var d = cc._canvas,
            e = cc.container;
        e.style.width = d.style.width = b + "px";
        e.style.height = d.style.height = c + "px";
        e = a._devicePixelRatio = 1;
        a.isRetinaEnabled() && (e = a._devicePixelRatio = window.devicePixelRatio || 1);
        d.width = b * e;
        d.height = c * e;
        a = document.body;
        var f;
        if (a && (f = a.style)) f.paddingTop = f.paddingTop || "0px", f.paddingRight = f.paddingRight || "0px", f.paddingBottom = f.paddingBottom || "0px", f.paddingLeft = f.paddingLeft || "0px", f.borderTop = f.borderTop || "0px", f.borderRight = f.borderRight || "0px", f.borderBottom = f.borderBottom || "0px", f.borderLeft = f.borderLeft || "0px", f.marginTop = f.marginTop || "0px", f.marginRight = f.marginRight || "0px", f.marginBottom = f.marginBottom || "0px", f.marginLeft = f.marginLeft || "0px"
    },
    _fixContainer: function() {
        document.body.insertBefore(cc.container, document.body.firstChild);
        var a = document.body.style;
        a.width = window.innerWidth + "px";
        a.height = window.innerHeight + "px";
        a.overflow = "hidden";
        a = cc.container.style;
        a.position = "fixed";
        a.left = a.top = "0px";
        document.body.scrollTop = 0
    }
});
cc.ContentStrategy = cc.Class.extend({
    _result: {
        scale: [1, 1],
        viewport: null
    },
    _buildResult: function(a, b, c, d, e, f) {
        2 > Math.abs(a - c) && (c = a);
        2 > Math.abs(b - d) && (d = b);
        a = cc.rect(Math.round((a - c) / 2), Math.round((b - d) / 2), c, d);
        cc._renderType == cc._RENDER_TYPE_CANVAS && cc._renderContext.translate(a.x, a.y + d);
        this._result.scale = [e, f];
        this._result.viewport = a;
        return this._result
    },
    preApply: function(a) {},
    apply: function(a, b) {
        return {
            scale: [1, 1]
        }
    },
    postApply: function(a) {}
});
(function() {
    var a = cc.ContainerStrategy.extend({
            apply: function(a) {
                this._setupContainer(a, a._frameSize.width, a._frameSize.height)
            }
        }),
        b = cc.ContainerStrategy.extend({
            apply: function(a, b) {
                var c = a._frameSize.width,
                    d = a._frameSize.height,
                    e = cc.container.style,
                    n = b.width,
                    q = b.height,
                    r = c / n,
                    s = d / q,
                    t, u;
                r < s ? (t = c, u = q * r) : (t = n * s, u = d);
                n = Math.round((c - t) / 2);
                u = Math.round((d - u) / 2);
                this._setupContainer(a, c - 2 * n, d - 2 * u);
                e.marginLeft = n + "px";
                e.marginRight = n + "px";
                e.marginTop = u + "px";
                e.marginBottom = u + "px"
            }
        });
    a.extend({
        preApply: function(a) {
            this._super(a);
            a._frame = document.documentElement
        },
        apply: function(a) {
            this._super(a);
            this._fixContainer()
        }
    });
    b.extend({
        preApply: function(a) {
            this._super(a);
            a._frame = document.documentElement
        },
        apply: function(a, b) {
            this._super(a, b);
            this._fixContainer()
        }
    });
    var c = cc.ContainerStrategy.extend({
        apply: function(a) {
            this._setupContainer(a, cc._canvas.width, cc._canvas.height)
        }
    });
    cc.ContainerStrategy.EQUAL_TO_FRAME = new a;
    cc.ContainerStrategy.PROPORTION_TO_FRAME = new b;
    cc.ContainerStrategy.ORIGINAL_CONTAINER = new c;
    var a = cc.ContentStrategy.extend({
            apply: function(a,
                b) {
                var c = cc._canvas.width,
                    d = cc._canvas.height;
                return this._buildResult(c, d, c, d, c / b.width, d / b.height)
            }
        }),
        b = cc.ContentStrategy.extend({
            apply: function(a, b) {
                var c = cc._canvas.width,
                    d = cc._canvas.height,
                    e = b.width,
                    n = b.height,
                    q = c / e,
                    r = d / n,
                    s = 0,
                    t, u;
                q < r ? (s = q, t = c, u = n * s) : (s = r, t = e * s, u = d);
                return this._buildResult(c, d, t, u, s, s)
            }
        }),
        c = cc.ContentStrategy.extend({
            apply: function(a, b) {
                var c = cc._canvas.width,
                    d = cc._canvas.height,
                    e = c / b.width,
                    n = d / b.height,
                    q;
                e < n ? q = n : q = e;
                return this._buildResult(c, d, c, d, q, q)
            }
        }),
        d = cc.ContentStrategy.extend({
            apply: function(a,
                b) {
                var c = cc._canvas.width,
                    d = cc._canvas.height,
                    e = d / b.height;
                return this._buildResult(c, d, c, d, e, e)
            },
            postApply: function(a) {
                cc.director._winSizeInPoints = a.getVisibleSize()
            }
        }),
        e = cc.ContentStrategy.extend({
            apply: function(a, b) {
                var c = cc._canvas.width,
                    d = cc._canvas.height,
                    e = c / b.width;
                return this._buildResult(c, d, c, d, e, e)
            },
            postApply: function(a) {
                cc.director._winSizeInPoints = a.getVisibleSize()
            }
        });
    cc.ContentStrategy.EXACT_FIT = new a;
    cc.ContentStrategy.SHOW_ALL = new b;
    cc.ContentStrategy.NO_BORDER = new c;
    cc.ContentStrategy.FIXED_HEIGHT =
        new d;
    cc.ContentStrategy.FIXED_WIDTH = new e
})();
cc.ResolutionPolicy = cc.Class.extend({
    _containerStrategy: null,
    _contentStrategy: null,
    ctor: function(a, b) {
        this.setContainerStrategy(a);
        this.setContentStrategy(b)
    },
    preApply: function(a) {
        this._containerStrategy.preApply(a);
        this._contentStrategy.preApply(a)
    },
    apply: function(a, b) {
        this._containerStrategy.apply(a, b);
        return this._contentStrategy.apply(a, b)
    },
    postApply: function(a) {
        this._containerStrategy.postApply(a);
        this._contentStrategy.postApply(a)
    },
    setContainerStrategy: function(a) {
        a instanceof cc.ContainerStrategy &&
            (this._containerStrategy = a)
    },
    setContentStrategy: function(a) {
        a instanceof cc.ContentStrategy && (this._contentStrategy = a)
    }
});
cc.ResolutionPolicy.EXACT_FIT = 0;
cc.ResolutionPolicy.NO_BORDER = 1;
cc.ResolutionPolicy.SHOW_ALL = 2;
cc.ResolutionPolicy.FIXED_HEIGHT = 3;
cc.ResolutionPolicy.FIXED_WIDTH = 4;
cc.ResolutionPolicy.UNKNOWN = 5;
cc.screen = {
    _supportsFullScreen: !1,
    _preOnFullScreenChange: null,
    _touchEvent: "",
    _fn: null,
    _fnMap: [
        ["requestFullscreen", "exitFullscreen", "fullscreenchange", "fullscreenEnabled", "fullscreenElement"],
        ["requestFullScreen", "exitFullScreen", "fullScreenchange", "fullScreenEnabled", "fullScreenElement"],
        ["webkitRequestFullScreen", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitIsFullScreen", "webkitCurrentFullScreenElement"],
        ["mozRequestFullScreen", "mozCancelFullScreen", "mozfullscreenchange", "mozFullScreen",
            "mozFullScreenElement"
        ],
        ["msRequestFullscreen", "msExitFullscreen", "MSFullscreenChange", "msFullscreenEnabled", "msFullscreenElement"]
    ],
    init: function() {
        // updateShare(0);
        this._fn = {};
        var a, b, c = this._fnMap,
            d;
        a = 0;
        for (l = c.length; a < l; a++)
            if ((b = c[a]) && b[1] in document) {
                a = 0;
                for (d = b.length; a < d; a++) this._fn[c[0][a]] = b[a];
                break
            }
        this._supportsFullScreen = void 0 != this._fn.requestFullscreen;
        this._touchEvent = "ontouchstart" in window ? "touchstart" : "mousedown"
    },
    fullScreen: function() {
        return this._supportsFullScreen && document[this._fn.fullscreenEnabled]
    },
    requestFullScreen: function(a, b) {
        if (this._supportsFullScreen) {
            a = a || document.documentElement;
            a[this._fn.requestFullscreen]();
            if (b) {
                var c = this._fn.fullscreenchange;
                this._preOnFullScreenChange && document.removeEventListener(c, this._preOnFullScreenChange);
                this._preOnFullScreenChange = b;
                cc._addEventListener(document, c, b, !1)
            }
            return a[this._fn.requestFullscreen]()
        }
    },
    exitFullScreen: function() {
        return this._supportsFullScreen ? document[this._fn.exitFullscreen]() : !0
    },
    autoFullScreen: function(a, b) {
        function c() {
            e.requestFullScreen(a,
                b);
            d.removeEventListener(e._touchEvent, c)
        }
        a = a || document.body;
        var d = cc._canvas || a,
            e = this;
        this.requestFullScreen(a, b);
        cc._addEventListener(d, this._touchEvent, c)
    }
};
cc.screen.init();
cc.visibleRect = {
    topLeft: cc.p(0, 0),
    topRight: cc.p(0, 0),
    top: cc.p(0, 0),
    bottomLeft: cc.p(0, 0),
    bottomRight: cc.p(0, 0),
    bottom: cc.p(0, 0),
    center: cc.p(0, 0),
    left: cc.p(0, 0),
    right: cc.p(0, 0),
    width: 0,
    height: 0,
    init: function(a) {
        var b = this.width = a.width,
            c = this.height = a.height,
            d = a.x;
        a = a.y;
        var e = a + c,
            f = d + b;
        this.topLeft.x = d;
        this.topLeft.y = e;
        this.topRight.x = f;
        this.topRight.y = e;
        this.top.x = d + b / 2;
        this.top.y = e;
        this.bottomLeft.x = d;
        this.bottomLeft.y = a;
        this.bottomRight.x = f;
        this.bottomRight.y = a;
        this.bottom.x = d + b / 2;
        this.bottom.y =
            a;
        this.center.x = d + b / 2;
        this.center.y = a + c / 2;
        this.left.x = d;
        this.left.y = a + c / 2;
        this.right.x = f;
        this.right.y = a + c / 2
    }
};
cc.UIInterfaceOrientationLandscapeLeft = -90;
cc.UIInterfaceOrientationLandscapeRight = 90;
cc.UIInterfaceOrientationPortraitUpsideDown = 180;
cc.UIInterfaceOrientationPortrait = 0;
cc.inputManager = {
    _mousePressed: !1,
    _isRegisterEvent: !1,
    _preTouchPoint: cc.p(0, 0),
    _prevMousePoint: cc.p(0, 0),
    _preTouchPool: [],
    _preTouchPoolPointer: 0,
    _touches: [],
    _touchesIntegerDict: {},
    _indexBitsUsed: 0,
    _maxTouches: 5,
    _accelEnabled: !1,
    _accelInterval: 1 / 30,
    _accelMinus: 1,
    _accelCurTime: 0,
    _acceleration: null,
    _accelDeviceEvent: null,
    _getUnUsedIndex: function() {
        for (var a = this._indexBitsUsed, b = 0; b < this._maxTouches; b++) {
            if (!(a & 1)) return this._indexBitsUsed |= 1 << b, b;
            a >>= 1
        }
        return -1
    },
    _removeUsedIndexBit: function(a) {
        0 > a ||
            a >= this._maxTouches || (a = ~(1 << a), this._indexBitsUsed &= a)
    },
    _glView: null,
    handleTouchesBegin: function(a) {
        for (var b, c, d, e = [], f = this._touchesIntegerDict, g = 0, h = a.length; g < h; g++)
            if (b = a[g], d = b.getID(), c = f[d], null == c) {
                var k = this._getUnUsedIndex(); - 1 == k ? cc.log(cc._LogInfos.inputManager_handleTouchesBegin, k) : (c = this._touches[k] = new cc.Touch(b._point.x, b._point.y, b.getID()), c._setPrevPoint(b._prevPoint), f[d] = k, e.push(c))
            }
        0 < e.length && (this._glView._convertTouchesWithScale(e), a = new cc.EventTouch(e), a._eventCode =
            cc.EventTouch.EventCode.BEGAN, cc.eventManager.dispatchEvent(a))
    },
    handleTouchesMove: function(a) {
        for (var b, c, d = [], e = this._touches, f = 0, g = a.length; f < g; f++) b = a[f], c = b.getID(), c = this._touchesIntegerDict[c], null != c && e[c] && (e[c]._setPoint(b._point), e[c]._setPrevPoint(b._prevPoint), d.push(e[c]));
        0 < d.length && (this._glView._convertTouchesWithScale(d), a = new cc.EventTouch(d), a._eventCode = cc.EventTouch.EventCode.MOVED, cc.eventManager.dispatchEvent(a))
    },
    handleTouchesEnd: function(a) {
        a = this.getSetOfTouchesEndOrCancel(a);
        0 < a.length && (this._glView._convertTouchesWithScale(a), a = new cc.EventTouch(a), a._eventCode = cc.EventTouch.EventCode.ENDED, cc.eventManager.dispatchEvent(a))
    },
    handleTouchesCancel: function(a) {
        a = this.getSetOfTouchesEndOrCancel(a);
        0 < a.length && (this._glView._convertTouchesWithScale(a), a = new cc.EventTouch(a), a._eventCode = cc.EventTouch.EventCode.CANCELLED, cc.eventManager.dispatchEvent(a))
    },
    getSetOfTouchesEndOrCancel: function(a) {
        for (var b, c, d, e = [], f = this._touches, g = this._touchesIntegerDict, h = 0, k = a.length; h <
            k; h++) b = a[h], d = b.getID(), c = g[d], null != c && f[c] && (f[c]._setPoint(b._point), f[c]._setPrevPoint(b._prevPoint), e.push(f[c]), this._removeUsedIndexBit(c), delete g[d]);
        return e
    },
    getHTMLElementPosition: function(a) {
        var b = document.documentElement,
            c = window,
            d = null,
            d = cc.isFunction(a.getBoundingClientRect) ? a.getBoundingClientRect() : a instanceof HTMLCanvasElement ? {
                left: 0,
                top: 0,
                width: a.width,
                height: a.height
            } : {
                left: 0,
                top: 0,
                width: parseInt(a.style.width),
                height: parseInt(a.style.height)
            };
        return {
            left: d.left + c.pageXOffset -
                b.clientLeft,
            top: d.top + c.pageYOffset - b.clientTop,
            width: d.width,
            height: d.height
        }
    },
    getPreTouch: function(a) {
        for (var b = null, c = this._preTouchPool, d = a.getID(), e = c.length - 1; 0 <= e; e--)
            if (c[e].getID() == d) {
                b = c[e];
                break
            }
        b || (b = a);
        return b
    },
    setPreTouch: function(a) {
        for (var b = !1, c = this._preTouchPool, d = a.getID(), e = c.length - 1; 0 <= e; e--)
            if (c[e].getID() == d) {
                c[e] = a;
                b = !0;
                break
            }
        b || (50 >= c.length ? c.push(a) : (c[this._preTouchPoolPointer] = a, this._preTouchPoolPointer = (this._preTouchPoolPointer + 1) % 50))
    },
    getTouchByXY: function(a,
        b, c) {
        var d = this._preTouchPoint;
        a = this._glView.convertToLocationInView(a, b, c);
        b = new cc.Touch(a.x, a.y);
        b._setPrevPoint(d.x, d.y);
        d.x = a.x;
        d.y = a.y;
        return b
    },
    getMouseEvent: function(a, b, c) {
        var d = this._prevMousePoint;
        this._glView._convertMouseToLocationInView(a, b);
        b = new cc.EventMouse(c);
        b.setLocation(a.x, a.y);
        b._setPrevCursor(d.x, d.y);
        d.x = a.x;
        d.y = a.y;
        return b
    },
    getPointByEvent: function(a, b) {
        if (null != a.pageX) return {
            x: a.pageX,
            y: a.pageY
        };
        b.left -= document.body.scrollLeft;
        b.top -= document.body.scrollTop;
        return {
            x: a.clientX,
            y: a.clientY
        }
    },
    getTouchesByEvent: function(a, b) {
        for (var c = [], d = this._glView, e, f, g = this._preTouchPoint, h = a.changedTouches.length, k = 0; k < h; k++)
            if (e = a.changedTouches[k]) {
                var m;
                m = cc.sys.BROWSER_TYPE_FIREFOX === cc.sys.browserType ? d.convertToLocationInView(e.pageX, e.pageY, b) : d.convertToLocationInView(e.clientX, e.clientY, b);
                null != e.identifier ? (e = new cc.Touch(m.x, m.y, e.identifier), f = this.getPreTouch(e).getLocation(), e._setPrevPoint(f.x, f.y), this.setPreTouch(e)) : (e = new cc.Touch(m.x, m.y), e._setPrevPoint(g.x, g.y));
                g.x = m.x;
                g.y = m.y;
                c.push(e)
            }
        return c
    },
    registerSystemEvent: function(a) {
        if (!this._isRegisterEvent) {
            this._glView = cc.view;
            var b = this,
                c = "touches" in cc.sys.capabilities;
            "mouse" in cc.sys.capabilities && (cc._addEventListener(window, "mousedown", function() {
                b._mousePressed = !0
            }, !1), cc._addEventListener(window, "mouseup", function(d) {
                var e = b._mousePressed;
                b._mousePressed = !1;
                if (e) {
                    var e = b.getHTMLElementPosition(a),
                        h = b.getPointByEvent(d, e);
                    cc.rectContainsPoint(new cc.Rect(e.left, e.top, e.width, e.height), h) || (c || b.handleTouchesEnd([b.getTouchByXY(h.x,
                        h.y, e)]), e = b.getMouseEvent(h, e, cc.EventMouse.UP), e.setButton(d.button), cc.eventManager.dispatchEvent(e))
                }
            }, !1), cc._addEventListener(a, "mousedown", function(d) {
                b._mousePressed = !0;
                var e = b.getHTMLElementPosition(a),
                    h = b.getPointByEvent(d, e);
                c || b.handleTouchesBegin([b.getTouchByXY(h.x, h.y, e)]);
                e = b.getMouseEvent(h, e, cc.EventMouse.DOWN);
                e.setButton(d.button);
                cc.eventManager.dispatchEvent(e);
                d.stopPropagation();
                d.preventDefault();
                a.focus()
            }, !1), cc._addEventListener(a, "mouseup", function(d) {
                b._mousePressed = !1;
                var e = b.getHTMLElementPosition(a),
                    h = b.getPointByEvent(d, e);
                c || b.handleTouchesEnd([b.getTouchByXY(h.x, h.y, e)]);
                e = b.getMouseEvent(h, e, cc.EventMouse.UP);
                e.setButton(d.button);
                cc.eventManager.dispatchEvent(e);
                d.stopPropagation();
                d.preventDefault()
            }, !1), cc._addEventListener(a, "mousemove", function(d) {
                var e = b.getHTMLElementPosition(a),
                    h = b.getPointByEvent(d, e);
                c || b.handleTouchesMove([b.getTouchByXY(h.x, h.y, e)]);
                e = b.getMouseEvent(h, e, cc.EventMouse.MOVE);
                b._mousePressed ? e.setButton(d.button) : e.setButton(null);
                cc.eventManager.dispatchEvent(e);
                d.stopPropagation();
                d.preventDefault()
            }, !1), cc._addEventListener(a, "mousewheel", function(c) {
                var d = b.getHTMLElementPosition(a),
                    e = b.getPointByEvent(c, d),
                    d = b.getMouseEvent(e, d, cc.EventMouse.SCROLL);
                d.setButton(c.button);
                d.setScrollData(0, c.wheelDelta);
                cc.eventManager.dispatchEvent(d);
                c.stopPropagation();
                c.preventDefault()
            }, !1), cc._addEventListener(a, "DOMMouseScroll", function(c) {
                var d = b.getHTMLElementPosition(a),
                    e = b.getPointByEvent(c, d),
                    d = b.getMouseEvent(e, d, cc.EventMouse.SCROLL);
                d.setButton(c.button);
                d.setScrollData(0, -120 * c.detail);
                cc.eventManager.dispatchEvent(d);
                c.stopPropagation();
                c.preventDefault()
            }, !1));
            if (window.navigator.msPointerEnabled) {
                var d = {
                        MSPointerDown: b.handleTouchesBegin,
                        MSPointerMove: b.handleTouchesMove,
                        MSPointerUp: b.handleTouchesEnd,
                        MSPointerCancel: b.handleTouchesCancel
                    },
                    e;
                for (e in d)(function(c, d) {
                    cc._addEventListener(a, c, function(c) {
                        var e = b.getHTMLElementPosition(a);
                        e.left -= document.documentElement.scrollLeft;
                        e.top -= document.documentElement.scrollTop;
                        d.call(b, [b.getTouchByXY(c.clientX, c.clientY, e)]);
                        c.stopPropagation()
                    }, !1)
                })(e, d[e])
            }
            c && (cc._addEventListener(a, "touchstart", function(c) {
                if (c.changedTouches) {
                    var d = b.getHTMLElementPosition(a);
                    d.left -= document.body.scrollLeft;
                    d.top -= document.body.scrollTop;
                    b.handleTouchesBegin(b.getTouchesByEvent(c, d));
                    c.stopPropagation();
                    c.preventDefault();
                    a.focus()
                }
            }, !1), cc._addEventListener(a, "touchmove", function(c) {
                if (c.changedTouches) {
                    var d = b.getHTMLElementPosition(a);
                    d.left -= document.body.scrollLeft;
                    d.top -= document.body.scrollTop;
                    b.handleTouchesMove(b.getTouchesByEvent(c, d));
                    c.stopPropagation();
                    c.preventDefault()
                }
            }, !1), cc._addEventListener(a, "touchend", function(c) {
                if (c.changedTouches) {
                    var d = b.getHTMLElementPosition(a);
                    d.left -= document.body.scrollLeft;
                    d.top -= document.body.scrollTop;
                    b.handleTouchesEnd(b.getTouchesByEvent(c, d));
                    c.stopPropagation();
                    c.preventDefault()
                }
            }, !1), cc._addEventListener(a, "touchcancel", function(c) {
                if (c.changedTouches) {
                    var d = b.getHTMLElementPosition(a);
                    d.left -= document.body.scrollLeft;
                    d.top -= document.body.scrollTop;
                    b.handleTouchesCancel(b.getTouchesByEvent(c, d));
                    c.stopPropagation();
                    c.preventDefault()
                }
            }, !1));
            this._registerKeyboardEvent();
            this._registerAccelerometerEvent();
            this._isRegisterEvent = !0
        }
    },
    _registerKeyboardEvent: function() {},
    _registerAccelerometerEvent: function() {},
    update: function(a) {
        this._accelCurTime > this._accelInterval && (this._accelCurTime -= this._accelInterval, cc.eventManager.dispatchEvent(new cc.EventAcceleration(this._acceleration)));
        this._accelCurTime += a
    }
};
var _p = cc.inputManager;
_p.setAccelerometerEnabled = function(a) {
    this._accelEnabled !== a && (this._accelEnabled = a, a = cc.director.getScheduler(), this._accelEnabled ? (this._accelCurTime = 0, a.scheduleUpdateForTarget(this)) : (this._accelCurTime = 0, a.unscheduleUpdateForTarget(this)))
};
_p.setAccelerometerInterval = function(a) {
    this._accelInterval !== a && (this._accelInterval = a)
};
_p._registerKeyboardEvent = function() {
    cc._addEventListener(cc._canvas, "keydown", function(a) {
        cc.eventManager.dispatchEvent(new cc.EventKeyboard(a.keyCode, !0));
        a.stopPropagation();
        a.preventDefault()
    }, !1);
    cc._addEventListener(cc._canvas, "keyup", function(a) {
        cc.eventManager.dispatchEvent(new cc.EventKeyboard(a.keyCode, !1));
        a.stopPropagation();
        a.preventDefault()
    }, !1)
};
_p._registerAccelerometerEvent = function() {
    var a = window;
    this._acceleration = new cc.Acceleration;
    this._accelDeviceEvent = a.DeviceMotionEvent || a.DeviceOrientationEvent;
    cc.sys.browserType == cc.sys.BROWSER_TYPE_MOBILE_QQ && (this._accelDeviceEvent = window.DeviceOrientationEvent);
    var b = this._accelDeviceEvent == a.DeviceMotionEvent ? "devicemotion" : "deviceorientation",
        c = navigator.userAgent;
    if (/Android/.test(c) || /Adr/.test(c) && cc.sys.browserType == cc.BROWSER_TYPE_UC) this._minus = -1;
    cc._addEventListener(a, b, this.didAccelerate.bind(this), !1)
};
_p.didAccelerate = function(a) {
    var b = window;
    if (this._accelEnabled) {
        var c = this._acceleration,
            d, e, f;
        this._accelDeviceEvent == window.DeviceMotionEvent ? (f = a.accelerationIncludingGravity, d = 0.1 * this._accelMinus * f.x, e = 0.1 * this._accelMinus * f.y, f = 0.1 * f.z) : (d = 0.981 * (a.gamma / 90), e = 0.981 * -(a.beta / 90), f = 0.981 * (a.alpha / 90));
        cc.sys.os === cc.sys.OS_ANDROID ? (c.x = -d, c.y = -e) : (c.x = d, c.y = e);
        c.z = f;
        c.timestamp = a.timeStamp || Date.now();
        a = c.x;
        b.orientation === cc.UIInterfaceOrientationLandscapeRight ? (c.x = -c.y, c.y = a) : b.orientation === cc.UIInterfaceOrientationLandscapeLeft ?
            (c.x = c.y, c.y = -a) : b.orientation === cc.UIInterfaceOrientationPortraitUpsideDown && (c.x = -c.x, c.y = -c.y)
    }
};
delete _p;
cc.AffineTransform = function(a, b, c, d, e, f) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.tx = e;
    this.ty = f
};
cc.affineTransformMake = function(a, b, c, d, e, f) {
    return {
        a: a,
        b: b,
        c: c,
        d: d,
        tx: e,
        ty: f
    }
};
cc.pointApplyAffineTransform = function(a, b) {
    return {
        x: b.a * a.x + b.c * a.y + b.tx,
        y: b.b * a.x + b.d * a.y + b.ty
    }
};
cc._pointApplyAffineTransform = function(a, b, c) {
    return {
        x: c.a * a + c.c * b + c.tx,
        y: c.b * a + c.d * b + c.ty
    }
};
cc.sizeApplyAffineTransform = function(a, b) {
    return {
        width: b.a * a.width + b.c * a.height,
        height: b.b * a.width + b.d * a.height
    }
};
cc.affineTransformMakeIdentity = function() {
    return {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
    }
};
cc.affineTransformIdentity = function() {
    return {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
    }
};
cc.rectApplyAffineTransform = function(a, b) {
    var c = cc.rectGetMinY(a),
        d = cc.rectGetMinX(a),
        e = cc.rectGetMaxX(a),
        f = cc.rectGetMaxY(a),
        g = cc._pointApplyAffineTransform(d, c, b),
        c = cc._pointApplyAffineTransform(e, c, b),
        d = cc._pointApplyAffineTransform(d, f, b),
        h = cc._pointApplyAffineTransform(e, f, b),
        e = Math.min(g.x, c.x, d.x, h.x),
        f = Math.max(g.x, c.x, d.x, h.x),
        k = Math.min(g.y, c.y, d.y, h.y),
        g = Math.max(g.y, c.y, d.y, h.y);
    return cc.rect(e, k, f - e, g - k)
};
cc._rectApplyAffineTransformIn = function(a, b) {
    var c = cc.rectGetMinY(a),
        d = cc.rectGetMinX(a),
        e = cc.rectGetMaxX(a),
        f = cc.rectGetMaxY(a),
        g = cc._pointApplyAffineTransform(d, c, b),
        c = cc._pointApplyAffineTransform(e, c, b),
        d = cc._pointApplyAffineTransform(d, f, b),
        h = cc._pointApplyAffineTransform(e, f, b),
        e = Math.min(g.x, c.x, d.x, h.x),
        f = Math.max(g.x, c.x, d.x, h.x),
        k = Math.min(g.y, c.y, d.y, h.y),
        g = Math.max(g.y, c.y, d.y, h.y);
    a.x = e;
    a.y = k;
    a.width = f - e;
    a.height = g - k;
    return a
};
cc.affineTransformTranslate = function(a, b, c) {
    return {
        a: a.a,
        b: a.b,
        c: a.c,
        d: a.d,
        tx: a.tx + a.a * b + a.c * c,
        ty: a.ty + a.b * b + a.d * c
    }
};
cc.affineTransformScale = function(a, b, c) {
    return {
        a: a.a * b,
        b: a.b * b,
        c: a.c * c,
        d: a.d * c,
        tx: a.tx,
        ty: a.ty
    }
};
cc.affineTransformRotate = function(a, b) {
    var c = Math.sin(b),
        d = Math.cos(b);
    return {
        a: a.a * d + a.c * c,
        b: a.b * d + a.d * c,
        c: a.c * d - a.a * c,
        d: a.d * d - a.b * c,
        tx: a.tx,
        ty: a.ty
    }
};
cc.affineTransformConcat = function(a, b) {
    return {
        a: a.a * b.a + a.b * b.c,
        b: a.a * b.b + a.b * b.d,
        c: a.c * b.a + a.d * b.c,
        d: a.c * b.b + a.d * b.d,
        tx: a.tx * b.a + a.ty * b.c + b.tx,
        ty: a.tx * b.b + a.ty * b.d + b.ty
    }
};
cc.affineTransformEqualToTransform = function(a, b) {
    return a.a === b.a && a.b === b.b && a.c === b.c && a.d === b.d && a.tx === b.tx && a.ty === b.ty
};
cc.affineTransformInvert = function(a) {
    var b = 1 / (a.a * a.d - a.b * a.c);
    return {
        a: b * a.d,
        b: -b * a.b,
        c: -b * a.c,
        d: b * a.a,
        tx: b * (a.c * a.ty - a.d * a.tx),
        ty: b * (a.b * a.tx - a.a * a.ty)
    }
};
cc.POINT_EPSILON = parseFloat("1.192092896e-07F");
cc.pNeg = function(a) {
    return cc.p(-a.x, -a.y)
};
cc.pAdd = function(a, b) {
    return cc.p(a.x + b.x, a.y + b.y)
};
cc.pSub = function(a, b) {
    return cc.p(a.x - b.x, a.y - b.y)
};
cc.pMult = function(a, b) {
    return cc.p(a.x * b, a.y * b)
};
cc.pMidpoint = function(a, b) {
    return cc.pMult(cc.pAdd(a, b), 0.5)
};
cc.pDot = function(a, b) {
    return a.x * b.x + a.y * b.y
};
cc.pCross = function(a, b) {
    return a.x * b.y - a.y * b.x
};
cc.pPerp = function(a) {
    return cc.p(-a.y, a.x)
};
cc.pRPerp = function(a) {
    return cc.p(a.y, -a.x)
};
cc.pProject = function(a, b) {
    return cc.pMult(b, cc.pDot(a, b) / cc.pDot(b, b))
};
cc.pRotate = function(a, b) {
    return cc.p(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x)
};
cc.pUnrotate = function(a, b) {
    return cc.p(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y)
};
cc.pLengthSQ = function(a) {
    return cc.pDot(a, a)
};
cc.pDistanceSQ = function(a, b) {
    return cc.pLengthSQ(cc.pSub(a, b))
};
cc.pLength = function(a) {
    return Math.sqrt(cc.pLengthSQ(a))
};
cc.pDistance = function(a, b) {
    return cc.pLength(cc.pSub(a, b))
};
cc.pNormalize = function(a) {
    return cc.pMult(a, 1 / cc.pLength(a))
};
cc.pForAngle = function(a) {
    return cc.p(Math.cos(a), Math.sin(a))
};
cc.pToAngle = function(a) {
    return Math.atan2(a.y, a.x)
};
cc.clampf = function(a, b, c) {
    if (b > c) {
        var d = b;
        b = c;
        c = d
    }
    return a < b ? b : a < c ? a : c
};
cc.pClamp = function(a, b, c) {
    return cc.p(cc.clampf(a.x, b.x, c.x), cc.clampf(a.y, b.y, c.y))
};
cc.pFromSize = function(a) {
    return cc.p(a.width, a.height)
};
cc.pCompOp = function(a, b) {
    return cc.p(b(a.x), b(a.y))
};
cc.pLerp = function(a, b, c) {
    return cc.pAdd(cc.pMult(a, 1 - c), cc.pMult(b, c))
};
cc.pFuzzyEqual = function(a, b, c) {
    return a.x - c <= b.x && b.x <= a.x + c && a.y - c <= b.y && b.y <= a.y + c ? !0 : !1
};
cc.pCompMult = function(a, b) {
    return cc.p(a.x * b.x, a.y * b.y)
};
cc.pAngleSigned = function(a, b) {
    var c = cc.pNormalize(a),
        d = cc.pNormalize(b),
        c = Math.atan2(c.x * d.y - c.y * d.x, cc.pDot(c, d));
    return Math.abs(c) < cc.POINT_EPSILON ? 0 : c
};
cc.pAngle = function(a, b) {
    var c = Math.acos(cc.pDot(cc.pNormalize(a), cc.pNormalize(b)));
    return Math.abs(c) < cc.POINT_EPSILON ? 0 : c
};
cc.pRotateByAngle = function(a, b, c) {
    a = cc.pSub(a, b);
    var d = Math.cos(c);
    c = Math.sin(c);
    var e = a.x;
    a.x = e * d - a.y * c + b.x;
    a.y = e * c + a.y * d + b.y;
    return a
};
cc.pLineIntersect = function(a, b, c, d, e) {
    if (a.x == b.x && a.y == b.y || c.x == d.x && c.y == d.y) return !1;
    var f = b.x - a.x;
    b = b.y - a.y;
    var g = d.x - c.x;
    d = d.y - c.y;
    var h = a.x - c.x;
    a = a.y - c.y;
    c = d * f - g * b;
    e.x = g * a - d * h;
    e.y = f * a - b * h;
    if (0 == c) return 0 == e.x || 0 == e.y ? !0 : !1;
    e.x /= c;
    e.y /= c;
    return !0
};
cc.pSegmentIntersect = function(a, b, c, d) {
    var e = cc.p(0, 0);
    return cc.pLineIntersect(a, b, c, d, e) && 0 <= e.x && 1 >= e.x && 0 <= e.y && 1 >= e.y ? !0 : !1
};
cc.pIntersectPoint = function(a, b, c, d) {
    var e = cc.p(0, 0);
    return cc.pLineIntersect(a, b, c, d, e) ? (c = cc.p(0, 0), c.x = a.x + e.x * (b.x - a.x), c.y = a.y + e.x * (b.y - a.y), c) : cc.p(0, 0)
};
cc.pSameAs = function(a, b) {
    return null != a && null != b ? a.x == b.x && a.y == b.y : !1
};
cc.pZeroIn = function(a) {
    a.x = 0;
    a.y = 0
};
cc.pIn = function(a, b) {
    a.x = b.x;
    a.y = b.y
};
cc.pMultIn = function(a, b) {
    a.x *= b;
    a.y *= b
};
cc.pSubIn = function(a, b) {
    a.x -= b.x;
    a.y -= b.y
};
cc.pAddIn = function(a, b) {
    a.x += b.x;
    a.y += b.y
};
cc.pNormalizeIn = function(a) {
    cc.pMultIn(a, 1 / Math.sqrt(a.x * a.x + a.y * a.y))
};
cc.vertexLineToPolygon = function(a, b, c, d, e) {
    e += d;
    if (!(1 >= e)) {
        b *= 0.5;
        for (var f, g = e - 1, h = d; h < e; h++) {
            f = 2 * h;
            var k = cc.p(a[2 * h], a[2 * h + 1]),
                m;
            if (0 === h) m = cc.pPerp(cc.pNormalize(cc.pSub(k, cc.p(a[2 * (h + 1)], a[2 * (h + 1) + 1]))));
            else if (h === g) m = cc.pPerp(cc.pNormalize(cc.pSub(cc.p(a[2 * (h - 1)], a[2 * (h - 1) + 1]), k)));
            else {
                m = cc.p(a[2 * (h - 1)], a[2 * (h - 1) + 1]);
                var n = cc.p(a[2 * (h + 1)], a[2 * (h + 1) + 1]),
                    q = cc.pNormalize(cc.pSub(n, k)),
                    r = cc.pNormalize(cc.pSub(m, k)),
                    s = Math.acos(cc.pDot(q, r));
                m = s < cc.degreesToRadians(70) ? cc.pPerp(cc.pNormalize(cc.pMidpoint(q,
                    r))) : s < cc.degreesToRadians(170) ? cc.pNormalize(cc.pMidpoint(q, r)) : cc.pPerp(cc.pNormalize(cc.pSub(n, m)))
            }
            m = cc.pMult(m, b);
            c[2 * f] = k.x + m.x;
            c[2 * f + 1] = k.y + m.y;
            c[2 * (f + 1)] = k.x - m.x;
            c[2 * (f + 1) + 1] = k.y - m.y
        }
        for (h = 0 == d ? 0 : d - 1; h < g; h++) {
            f = 2 * h;
            a = f + 2;
            b = cc.vertex2(c[2 * f], c[2 * f + 1]);
            e = cc.vertex2(c[2 * (f + 1)], c[2 * (f + 1) + 1]);
            f = cc.vertex2(c[2 * a], c[2 * a]);
            d = cc.vertex2(c[2 * (a + 1)], c[2 * (a + 1) + 1]);
            b = !cc.vertexLineIntersect(b.x, b.y, d.x, d.y, e.x, e.y, f.x, f.y);
            if (!b.isSuccess && (0 > b.value || 1 < b.value)) b.isSuccess = !0;
            b.isSuccess && (c[2 * a] = d.x,
                c[2 * a + 1] = d.y, c[2 * (a + 1)] = f.x, c[2 * (a + 1) + 1] = f.y)
        }
    }
};
cc.vertexLineIntersect = function(a, b, c, d, e, f, g, h) {
    if (a == c && b == d || e == g && f == h) return {
        isSuccess: !1,
        value: 0
    };
    c -= a;
    d -= b;
    e -= a;
    f -= b;
    g -= a;
    h -= b;
    a = Math.sqrt(c * c + d * d);
    c /= a;
    d /= a;
    b = e * c + f * d;
    f = f * c - e * d;
    e = b;
    b = g * c + h * d;
    h = h * c - g * d;
    g = b;
    return f == h ? {
        isSuccess: !1,
        value: 0
    } : {
        isSuccess: !0,
        value: (g + (e - g) * h / (h - f)) / a
    }
};
cc.vertexListIsClockwise = function(a) {
    for (var b = 0, c = a.length; b < c; b++) {
        var d = a[(b + 1) % c],
            e = a[(b + 2) % c];
        if (0 < cc.pCross(cc.pSub(d, a[b]), cc.pSub(e, d))) return !1
    }
    return !0
};
cc.CGAffineToGL = function(a, b) {
    b[2] = b[3] = b[6] = b[7] = b[8] = b[9] = b[11] = b[14] = 0;
    b[10] = b[15] = 1;
    b[0] = a.a;
    b[4] = a.c;
    b[12] = a.tx;
    b[1] = a.b;
    b[5] = a.d;
    b[13] = a.ty
};
cc.GLToCGAffine = function(a, b) {
    b.a = a[0];
    b.c = a[4];
    b.tx = a[12];
    b.b = a[1];
    b.d = a[5];
    b.ty = a[13]
};
cc.Touch = cc.Class.extend({
    _point: null,
    _prevPoint: null,
    _id: 0,
    _startPointCaptured: !1,
    _startPoint: null,
    ctor: function(a, b, c) {
        this._point = cc.p(a || 0, b || 0);
        this._id = c || 0
    },
    getLocation: function() {
        return {
            x: this._point.x,
            y: this._point.y
        }
    },
    getLocationX: function() {
        return this._point.x
    },
    getLocationY: function() {
        return this._point.y
    },
    getPreviousLocation: function() {
        return {
            x: this._prevPoint.x,
            y: this._prevPoint.y
        }
    },
    getStartLocation: function() {
        return {
            x: this._startPoint.x,
            y: this._startPoint.y
        }
    },
    getDelta: function() {
        return cc.pSub(this._point,
            this._prevPoint)
    },
    getLocationInView: function() {
        return {
            x: this._point.x,
            y: this._point.y
        }
    },
    getPreviousLocationInView: function() {
        return {
            x: this._prevPoint.x,
            y: this._prevPoint.y
        }
    },
    getStartLocationInView: function() {
        return {
            x: this._startPoint.x,
            y: this._startPoint.y
        }
    },
    getID: function() {
        return this._id
    },
    getId: function() {
        cc.log("getId is deprecated. Please use getID instead.");
        return this._id
    },
    setTouchInfo: function(a, b, c) {
        this._prevPoint = this._point;
        this._point = cc.p(b || 0, c || 0);
        this._id = a;
        this._startPointCaptured ||
            (this._startPoint = cc.p(this._point), this._startPointCaptured = !0)
    },
    _setPoint: function(a, b) {
        void 0 === b ? (this._point.x = a.x, this._point.y = a.y) : (this._point.x = a, this._point.y = b)
    },
    _setPrevPoint: function(a, b) {
        this._prevPoint = void 0 === b ? cc.p(a.x, a.y) : cc.p(a || 0, b || 0)
    }
});
cc.Event = cc.Class.extend({
    _type: 0,
    _isStopped: !1,
    _currentTarget: null,
    _setCurrentTarget: function(a) {
        this._currentTarget = a
    },
    ctor: function(a) {
        this._type = a
    },
    getType: function() {
        return this._type
    },
    stopPropagation: function() {
        this._isStopped = !0
    },
    isStopped: function() {
        return this._isStopped
    },
    getCurrentTarget: function() {
        return this._currentTarget
    }
});
cc.Event.TOUCH = 0;
cc.Event.KEYBOARD = 1;
cc.Event.ACCELERATION = 2;
cc.Event.MOUSE = 3;
cc.Event.CUSTOM = 4;
cc.EventCustom = cc.Event.extend({
    _eventName: null,
    _userData: null,
    ctor: function(a) {
        cc.Event.prototype.ctor.call(this, cc.Event.CUSTOM);
        this._eventName = a
    },
    setUserData: function(a) {
        this._userData = a
    },
    getUserData: function() {
        return this._userData
    },
    getEventName: function() {
        return this._eventName
    }
});
cc.EventMouse = cc.Event.extend({
    _eventType: 0,
    _button: 0,
    _x: 0,
    _y: 0,
    _prevX: 0,
    _prevY: 0,
    _scrollX: 0,
    _scrollY: 0,
    ctor: function(a) {
        cc.Event.prototype.ctor.call(this, cc.Event.MOUSE);
        this._eventType = a
    },
    setScrollData: function(a, b) {
        this._scrollX = a;
        this._scrollY = b
    },
    getScrollX: function() {
        return this._scrollX
    },
    getScrollY: function() {
        return this._scrollY
    },
    setLocation: function(a, b) {
        this._x = a;
        this._y = b
    },
    getLocation: function() {
        return {
            x: this._x,
            y: this._y
        }
    },
    getLocationInView: function() {
        return {
            x: this._x,
            y: cc.view._designResolutionSize.height -
                this._y
        }
    },
    _setPrevCursor: function(a, b) {
        this._prevX = a;
        this._prevY = b
    },
    getDelta: function() {
        return {
            x: this._x - this._prevX,
            y: this._y - this._prevY
        }
    },
    getDeltaX: function() {
        return this._x - this._prevX
    },
    getDeltaY: function() {
        return this._y - this._prevY
    },
    setButton: function(a) {
        this._button = a
    },
    getButton: function() {
        return this._button
    },
    getLocationX: function() {
        return this._x
    },
    getLocationY: function() {
        return this._y
    }
});
cc.EventMouse.NONE = 0;
cc.EventMouse.DOWN = 1;
cc.EventMouse.UP = 2;
cc.EventMouse.MOVE = 3;
cc.EventMouse.SCROLL = 4;
cc.EventMouse.BUTTON_LEFT = 0;
cc.EventMouse.BUTTON_RIGHT = 2;
cc.EventMouse.BUTTON_MIDDLE = 1;
cc.EventMouse.BUTTON_4 = 3;
cc.EventMouse.BUTTON_5 = 4;
cc.EventMouse.BUTTON_6 = 5;
cc.EventMouse.BUTTON_7 = 6;
cc.EventMouse.BUTTON_8 = 7;
cc.EventTouch = cc.Event.extend({
    _eventCode: 0,
    _touches: null,
    ctor: function(a) {
        cc.Event.prototype.ctor.call(this, cc.Event.TOUCH);
        this._touches = a || []
    },
    getEventCode: function() {
        return this._eventCode
    },
    getTouches: function() {
        return this._touches
    },
    _setEventCode: function(a) {
        this._eventCode = a
    },
    _setTouches: function(a) {
        this._touches = a
    }
});
cc.EventTouch.MAX_TOUCHES = 5;
cc.EventTouch.EventCode = {
    BEGAN: 0,
    MOVED: 1,
    ENDED: 2,
    CANCELLED: 3
};
cc.EventListener = cc.Class.extend({
    _onEvent: null,
    _type: 0,
    _listenerID: null,
    _registered: !1,
    _fixedPriority: 0,
    _node: null,
    _paused: !0,
    _isEnabled: !0,
    ctor: function(a, b, c) {
        this._onEvent = c;
        this._type = a || 0;
        this._listenerID = b || ""
    },
    _setPaused: function(a) {
        this._paused = a
    },
    _isPaused: function() {
        return this._paused
    },
    _setRegistered: function(a) {
        this._registered = a
    },
    _isRegistered: function() {
        return this._registered
    },
    _getType: function() {
        return this._type
    },
    _getListenerID: function() {
        return this._listenerID
    },
    _setFixedPriority: function(a) {
        this._fixedPriority =
            a
    },
    _getFixedPriority: function() {
        return this._fixedPriority
    },
    _setSceneGraphPriority: function(a) {
        this._node = a
    },
    _getSceneGraphPriority: function() {
        return this._node
    },
    checkAvailable: function() {
        return null != this._onEvent
    },
    clone: function() {
        return null
    },
    setEnabled: function(a) {
        this._isEnabled = a
    },
    isEnabled: function() {
        return this._isEnabled
    },
    retain: function() {},
    release: function() {}
});
cc.EventListener.UNKNOWN = 0;
cc.EventListener.TOUCH_ONE_BY_ONE = 1;
cc.EventListener.TOUCH_ALL_AT_ONCE = 2;
cc.EventListener.KEYBOARD = 3;
cc.EventListener.MOUSE = 4;
cc.EventListener.ACCELERATION = 5;
cc.EventListener.CUSTOM = 6;
cc._EventListenerCustom = cc.EventListener.extend({
    _onCustomEvent: null,
    ctor: function(a, b) {
        this._onCustomEvent = b;
        var c = this;
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.CUSTOM, a, function(a) {
            null != c._onCustomEvent && c._onCustomEvent(a)
        })
    },
    checkAvailable: function() {
        return cc.EventListener.prototype.checkAvailable.call(this) && null != this._onCustomEvent
    },
    clone: function() {
        return new cc._EventListenerCustom(this._listenerID, this._onCustomEvent)
    }
});
cc._EventListenerCustom.create = function(a, b) {
    return new cc._EventListenerCustom(a, b)
};
cc._EventListenerMouse = cc.EventListener.extend({
    onMouseDown: null,
    onMouseUp: null,
    onMouseMove: null,
    onMouseScroll: null,
    ctor: function() {
        var a = this;
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.MOUSE, cc._EventListenerMouse.LISTENER_ID, function(b) {
            var c = cc.EventMouse;
            switch (b._eventType) {
                case c.DOWN:
                    if (a.onMouseDown) a.onMouseDown(b);
                    break;
                case c.UP:
                    if (a.onMouseUp) a.onMouseUp(b);
                    break;
                case c.MOVE:
                    if (a.onMouseMove) a.onMouseMove(b);
                    break;
                case c.SCROLL:
                    if (a.onMouseScroll) a.onMouseScroll(b)
            }
        })
    },
    clone: function() {
        var a = new cc._EventListenerMouse;
        a.onMouseDown = this.onMouseDown;
        a.onMouseUp = this.onMouseUp;
        a.onMouseMove = this.onMouseMove;
        a.onMouseScroll = this.onMouseScroll;
        return a
    },
    checkAvailable: function() {
        return !0
    }
});
cc._EventListenerMouse.LISTENER_ID = "__cc_mouse";
cc._EventListenerMouse.create = function() {
    return new cc._EventListenerMouse
};
cc._EventListenerTouchOneByOne = cc.EventListener.extend({
    _claimedTouches: null,
    swallowTouches: !1,
    onTouchBegan: null,
    onTouchMoved: null,
    onTouchEnded: null,
    onTouchCancelled: null,
    ctor: function() {
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ONE_BY_ONE, cc._EventListenerTouchOneByOne.LISTENER_ID, null);
        this._claimedTouches = []
    },
    setSwallowTouches: function(a) {
        this.swallowTouches = a
    },
    clone: function() {
        var a = new cc._EventListenerTouchOneByOne;
        a.onTouchBegan = this.onTouchBegan;
        a.onTouchMoved = this.onTouchMoved;
        a.onTouchEnded = this.onTouchEnded;
        a.onTouchCancelled = this.onTouchCancelled;
        a.swallowTouches = this.swallowTouches;
        return a
    },
    checkAvailable: function() {
        return !this.onTouchBegan ? (cc.log(cc._LogInfos._EventListenerTouchOneByOne_checkAvailable), !1) : !0
    }
});
cc._EventListenerTouchOneByOne.LISTENER_ID = "__cc_touch_one_by_one";
cc._EventListenerTouchOneByOne.create = function() {
    return new cc._EventListenerTouchOneByOne
};
cc._EventListenerTouchAllAtOnce = cc.EventListener.extend({
    onTouchesBegan: null,
    onTouchesMoved: null,
    onTouchesEnded: null,
    onTouchesCancelled: null,
    ctor: function() {
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ALL_AT_ONCE, cc._EventListenerTouchAllAtOnce.LISTENER_ID, null)
    },
    clone: function() {
        var a = new cc._EventListenerTouchAllAtOnce;
        a.onTouchesBegan = this.onTouchesBegan;
        a.onTouchesMoved = this.onTouchesMoved;
        a.onTouchesEnded = this.onTouchesEnded;
        a.onTouchesCancelled = this.onTouchesCancelled;
        return a
    },
    checkAvailable: function() {
        return null == this.onTouchesBegan && null == this.onTouchesMoved && null == this.onTouchesEnded && null == this.onTouchesCancelled ? (cc.log(cc._LogInfos._EventListenerTouchAllAtOnce_checkAvailable), !1) : !0
    }
});
cc._EventListenerTouchAllAtOnce.LISTENER_ID = "__cc_touch_all_at_once";
cc._EventListenerTouchAllAtOnce.create = function() {
    return new cc._EventListenerTouchAllAtOnce
};
cc.EventListener.create = function(a) {
    cc.assert(a && a.event, cc._LogInfos.EventListener_create);
    var b = a.event;
    delete a.event;
    var c = null;
    b === cc.EventListener.TOUCH_ONE_BY_ONE ? c = new cc._EventListenerTouchOneByOne : b === cc.EventListener.TOUCH_ALL_AT_ONCE ? c = new cc._EventListenerTouchAllAtOnce : b === cc.EventListener.MOUSE ? c = new cc._EventListenerMouse : b === cc.EventListener.CUSTOM ? (c = new cc._EventListenerCustom(a.eventName, a.callback), delete a.eventName, delete a.callback) : b === cc.EventListener.KEYBOARD ? c = new cc._EventListenerKeyboard :
        b === cc.EventListener.ACCELERATION && (c = new cc._EventListenerAcceleration(a.callback), delete a.callback);
    for (var d in a) c[d] = a[d];
    return c
};
cc._EventListenerVector = cc.Class.extend({
    _fixedListeners: null,
    _sceneGraphListeners: null,
    gt0Index: 0,
    ctor: function() {
        this._fixedListeners = [];
        this._sceneGraphListeners = []
    },
    size: function() {
        return this._fixedListeners.length + this._sceneGraphListeners.length
    },
    empty: function() {
        return 0 === this._fixedListeners.length && 0 === this._sceneGraphListeners.length
    },
    push: function(a) {
        0 == a._getFixedPriority() ? this._sceneGraphListeners.push(a) : this._fixedListeners.push(a)
    },
    clearSceneGraphListeners: function() {
        this._sceneGraphListeners.length =
            0
    },
    clearFixedListeners: function() {
        this._fixedListeners.length = 0
    },
    clear: function() {
        this._sceneGraphListeners.length = 0;
        this._fixedListeners.length = 0
    },
    getFixedPriorityListeners: function() {
        return this._fixedListeners
    },
    getSceneGraphPriorityListeners: function() {
        return this._sceneGraphListeners
    }
});
cc.__getListenerID = function(a) {
    var b = cc.Event,
        c = a.getType();
    if (c === b.ACCELERATION) return cc._EventListenerAcceleration.LISTENER_ID;
    if (c === b.CUSTOM) return a.getEventName();
    if (c === b.KEYBOARD) return cc._EventListenerKeyboard.LISTENER_ID;
    if (c === b.MOUSE) return cc._EventListenerMouse.LISTENER_ID;
    c === b.TOUCH && cc.log(cc._LogInfos.__getListenerID);
    return ""
};
cc.eventManager = {
    DIRTY_NONE: 0,
    DIRTY_FIXED_PRIORITY: 1,
    DIRTY_SCENE_GRAPH_PRIORITY: 2,
    DIRTY_ALL: 3,
    _listenersMap: {},
    _priorityDirtyFlagMap: {},
    _nodeListenersMap: {},
    _nodePriorityMap: {},
    _globalZOrderNodeMap: {},
    _toAddedListeners: [],
    _dirtyNodes: [],
    _inDispatch: 0,
    _isEnabled: !1,
    _nodePriorityIndex: 0,
    _internalCustomListenerIDs: [cc.game.EVENT_HIDE, cc.game.EVENT_SHOW],
    _setDirtyForNode: function(a) {
        null != this._nodeListenersMap[a.__instanceId] && this._dirtyNodes.push(a);
        a = a.getChildren();
        for (var b = 0, c = a.length; b < c; b++) this._setDirtyForNode(a[b])
    },
    pauseTarget: function(a, b) {
        var c = this._nodeListenersMap[a.__instanceId],
            d, e;
        if (c) {
            d = 0;
            for (e = c.length; d < e; d++) c[d]._setPaused(!0)
        }
        if (!0 === b) {
            c = a.getChildren();
            d = 0;
            for (e = c.length; d < e; d++) this.pauseTarget(c[d], !0)
        }
    },
    resumeTarget: function(a, b) {
        var c = this._nodeListenersMap[a.__instanceId],
            d, e;
        if (c) {
            d = 0;
            for (e = c.length; d < e; d++) c[d]._setPaused(!1)
        }
        this._setDirtyForNode(a);
        if (!0 === b) {
            c = a.getChildren();
            d = 0;
            for (e = c.length; d < e; d++) this.resumeTarget(c[d], !0)
        }
    },
    _addListener: function(a) {
        0 === this._inDispatch ? this._forceAddEventListener(a) :
            this._toAddedListeners.push(a)
    },
    _forceAddEventListener: function(a) {
        var b = a._getListenerID(),
            c = this._listenersMap[b];
        c || (c = new cc._EventListenerVector, this._listenersMap[b] = c);
        c.push(a);
        0 == a._getFixedPriority() ? (this._setDirty(b, this.DIRTY_SCENE_GRAPH_PRIORITY), b = a._getSceneGraphPriority(), null == b && cc.log(cc._LogInfos.eventManager__forceAddEventListener), this._associateNodeAndEventListener(b, a), b.isRunning() && this.resumeTarget(b)) : this._setDirty(b, this.DIRTY_FIXED_PRIORITY)
    },
    _getListeners: function(a) {
        return this._listenersMap[a]
    },
    _updateDirtyFlagForSceneGraph: function() {
        if (0 != this._dirtyNodes.length) {
            for (var a = this._dirtyNodes, b, c, d = this._nodeListenersMap, e = 0, f = a.length; e < f; e++)
                if (b = d[a[e].__instanceId])
                    for (var g = 0, h = b.length; g < h; g++)(c = b[g]) && this._setDirty(c._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY);
            this._dirtyNodes.length = 0
        }
    },
    _removeAllListenersInVector: function(a) {
        if (a)
            for (var b, c = 0; c < a.length;) b = a[c], b._setRegistered(!1), null != b._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(b._getSceneGraphPriority(),
                b), b._setSceneGraphPriority(null)), 0 === this._inDispatch ? cc.arrayRemoveObject(a, b) : ++c
    },
    _removeListenersForListenerID: function(a) {
        var b = this._listenersMap[a];
        if (b) {
            var c = b.getFixedPriorityListeners(),
                d = b.getSceneGraphPriorityListeners();
            this._removeAllListenersInVector(d);
            this._removeAllListenersInVector(c);
            delete this._priorityDirtyFlagMap[a];
            this._inDispatch || (b.clear(), delete this._listenersMap[a])
        }
        c = this._toAddedListeners;
        for (b = 0; b < c.length;)(d = c[b]) && d._getListenerID() == a ? cc.arrayRemoveObject(c,
            d) : ++b
    },
    _sortEventListeners: function(a) {
        var b = this.DIRTY_NONE,
            c = this._priorityDirtyFlagMap;
        c[a] && (b = c[a]);
        b != this.DIRTY_NONE && (c[a] = this.DIRTY_NONE, b & this.DIRTY_FIXED_PRIORITY && this._sortListenersOfFixedPriority(a), b & this.DIRTY_SCENE_GRAPH_PRIORITY && ((b = cc.director.getRunningScene()) ? this._sortListenersOfSceneGraphPriority(a, b) : c[a] = this.DIRTY_SCENE_GRAPH_PRIORITY))
    },
    _sortListenersOfSceneGraphPriority: function(a, b) {
        var c = this._getListeners(a);
        if (c) {
            var d = c.getSceneGraphPriorityListeners();
            d && 0 !==
                d.length && (this._nodePriorityIndex = 0, this._nodePriorityMap = {}, this._visitTarget(b, !0), c.getSceneGraphPriorityListeners().sort(this._sortEventListenersOfSceneGraphPriorityDes))
        }
    },
    _sortEventListenersOfSceneGraphPriorityDes: function(a, b) {
        var c = cc.eventManager._nodePriorityMap;
        return !a || !b || !a._getSceneGraphPriority() || !b._getSceneGraphPriority() ? -1 : c[b._getSceneGraphPriority().__instanceId] - c[a._getSceneGraphPriority().__instanceId]
    },
    _sortListenersOfFixedPriority: function(a) {
        if (a = this._listenersMap[a]) {
            var b =
                a.getFixedPriorityListeners();
            if (b && 0 !== b.length) {
                b.sort(this._sortListenersOfFixedPriorityAsc);
                for (var c = 0, d = b.length; c < d && !(0 <= b[c]._getFixedPriority());)++c;
                a.gt0Index = c
            }
        }
    },
    _sortListenersOfFixedPriorityAsc: function(a, b) {
        return a._getFixedPriority() - b._getFixedPriority()
    },
    _onUpdateListeners: function(a) {
        if (a = this._listenersMap[a]) {
            var b = a.getFixedPriorityListeners(),
                c = a.getSceneGraphPriorityListeners(),
                d, e;
            if (c)
                for (d = 0; d < c.length;) e = c[d], e._isRegistered() ? ++d : cc.arrayRemoveObject(c, e);
            if (b)
                for (d =
                    0; d < b.length;) e = b[d], e._isRegistered() ? ++d : cc.arrayRemoveObject(b, e);
            c && 0 === c.length && a.clearSceneGraphListeners();
            b && 0 === b.length && a.clearFixedListeners()
        }
    },
    _updateListeners: function(a) {
        var b = this._inDispatch;
        cc.assert(0 < b, cc._LogInfos.EventManager__updateListeners);
        a.getType() == cc.Event.TOUCH ? (this._onUpdateListeners(cc._EventListenerTouchOneByOne.LISTENER_ID), this._onUpdateListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID)) : this._onUpdateListeners(cc.__getListenerID(a));
        if (!(1 < b)) {
            cc.assert(1 ==
                b, cc._LogInfos.EventManager__updateListeners_2);
            a = this._listenersMap;
            var b = this._priorityDirtyFlagMap,
                c;
            for (c in a) a[c].empty() && (delete b[c], delete a[c]);
            c = this._toAddedListeners;
            if (0 !== c.length) {
                a = 0;
                for (b = c.length; a < b; a++) this._forceAddEventListener(c[a]);
                this._toAddedListeners.length = 0
            }
        }
    },
    _onTouchEventCallback: function(a, b) {
        if (!a._isRegistered) return !1;
        var c = b.event,
            d = b.selTouch;
        c._setCurrentTarget(a._node);
        var e = !1,
            f, g = c.getEventCode(),
            h = cc.EventTouch.EventCode;
        if (g == h.BEGAN) a.onTouchBegan && (e =
            a.onTouchBegan(d, c)) && a._registered && a._claimedTouches.push(d);
        else if (0 < a._claimedTouches.length && -1 != (f = a._claimedTouches.indexOf(d)))
            if (e = !0, g === h.MOVED && a.onTouchMoved) a.onTouchMoved(d, c);
            else if (g === h.ENDED) {
            if (a.onTouchEnded) a.onTouchEnded(d, c);
            a._registered && a._claimedTouches.splice(f, 1)
        } else if (g === h.CANCELLED) {
            if (a.onTouchCancelled) a.onTouchCancelled(d, c);
            a._registered && a._claimedTouches.splice(f, 1)
        }
        return c.isStopped() ? (cc.eventManager._updateListeners(c), !0) : e && a._registered && a.swallowTouches ?
            (b.needsMutableSet && b.touches.splice(d, 1), !0) : !1
    },
    _dispatchTouchEvent: function(a) {
        this._sortEventListeners(cc._EventListenerTouchOneByOne.LISTENER_ID);
        this._sortEventListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
        var b = this._getListeners(cc._EventListenerTouchOneByOne.LISTENER_ID),
            c = this._getListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
        if (!(null == b && null == c)) {
            var d = a.getTouches(),
                e = cc.copyArray(d),
                f = {
                    event: a,
                    needsMutableSet: b && c,
                    touches: e,
                    selTouch: null
                };
            if (b)
                for (var g = 0; g < d.length; g++)
                    if (f.selTouch =
                        d[g], this._dispatchEventToListeners(b, this._onTouchEventCallback, f), a.isStopped()) return;
            if (c && 0 < e.length && (this._dispatchEventToListeners(c, this._onTouchesEventCallback, {
                event: a,
                touches: e
            }), a.isStopped())) return;
            this._updateListeners(a)
        }
    },
    _onTouchesEventCallback: function(a, b) {
        if (!a._registered) return !1;
        var c = cc.EventTouch.EventCode,
            d = b.event,
            e = b.touches,
            f = d.getEventCode();
        d._setCurrentTarget(a._node);
        if (f == c.BEGAN && a.onTouchesBegan) a.onTouchesBegan(e, d);
        else if (f == c.MOVED && a.onTouchesMoved) a.onTouchesMoved(e,
            d);
        else if (f == c.ENDED && a.onTouchesEnded) a.onTouchesEnded(e, d);
        else if (f == c.CANCELLED && a.onTouchesCancelled) a.onTouchesCancelled(e, d);
        return d.isStopped() ? (cc.eventManager._updateListeners(d), !0) : !1
    },
    _associateNodeAndEventListener: function(a, b) {
        var c = this._nodeListenersMap[a.__instanceId];
        c || (c = [], this._nodeListenersMap[a.__instanceId] = c);
        c.push(b)
    },
    _dissociateNodeAndEventListener: function(a, b) {
        var c = this._nodeListenersMap[a.__instanceId];
        c && (cc.arrayRemoveObject(c, b), 0 === c.length && delete this._nodeListenersMap[a.__instanceId])
    },
    _dispatchEventToListeners: function(a, b, c) {
        var d = !1,
            e = a.getFixedPriorityListeners(),
            f = a.getSceneGraphPriorityListeners(),
            g = 0,
            h;
        if (e && 0 !== e.length)
            for (; g < a.gt0Index; ++g)
                if (h = e[g], h.isEnabled() && !h._isPaused() && h._isRegistered() && b(h, c)) {
                    d = !0;
                    break
                }
        if (f && !d)
            for (a = 0; a < f.length; a++)
                if (h = f[a], h.isEnabled() && !h._isPaused() && h._isRegistered() && b(h, c)) {
                    d = !0;
                    break
                }
        if (e && !d)
            for (; g < e.length && !(h = e[g], h.isEnabled() && !h._isPaused() && h._isRegistered() && b(h, c)); ++g);
    },
    _setDirty: function(a, b) {
        var c = this._priorityDirtyFlagMap;
        c[a] = null == c[a] ? b : b | c[a]
    },
    _visitTarget: function(a, b) {
        var c = a.getChildren(),
            d = 0,
            e = c.length,
            f = this._globalZOrderNodeMap,
            g = this._nodeListenersMap;
        if (0 < e) {
            for (var h; d < e; d++)
                if ((h = c[d]) && 0 > h.getLocalZOrder()) this._visitTarget(h, !1);
                else break;
            null != g[a.__instanceId] && (f[a.getGlobalZOrder()] || (f[a.getGlobalZOrder()] = []), f[a.getGlobalZOrder()].push(a.__instanceId));
            for (; d < e; d++)(h = c[d]) && this._visitTarget(h, !1)
        } else null != g[a.__instanceId] && (f[a.getGlobalZOrder()] || (f[a.getGlobalZOrder()] = []), f[a.getGlobalZOrder()].push(a.__instanceId));
        if (b) {
            var c = [],
                k;
            for (k in f) c.push(k);
            c.sort(this._sortNumberAsc);
            k = c.length;
            h = this._nodePriorityMap;
            for (d = 0; d < k; d++) {
                e = f[c[d]];
                for (g = 0; g < e.length; g++) h[e[g]] = ++this._nodePriorityIndex
            }
            this._globalZOrderNodeMap = {}
        }
    },
    _sortNumberAsc: function(a, b) {
        return a - b
    },
    addListener: function(a, b) {
        cc.assert(a && b, cc._LogInfos.eventManager_addListener_2);
        if (a instanceof cc.EventListener) {
            if (a._isRegistered()) {
                cc.log(cc._LogInfos.eventManager_addListener_4);
                return
            }
        } else cc.assert(!cc.isNumber(b), cc._LogInfos.eventManager_addListener_3),
            a = cc.EventListener.create(a); if (a.checkAvailable()) {
            if (cc.isNumber(b)) {
                if (0 == b) {
                    cc.log(cc._LogInfos.eventManager_addListener);
                    return
                }
                a._setSceneGraphPriority(null);
                a._setFixedPriority(b);
                a._setRegistered(!0);
                a._setPaused(!1)
            } else a._setSceneGraphPriority(b), a._setFixedPriority(0), a._setRegistered(!0);
            this._addListener(a);
            return a
        }
    },
    addCustomListener: function(a, b) {
        var c = new cc._EventListenerCustom(a, b);
        this.addListener(c, 1);
        return c
    },
    removeListener: function(a) {
        if (null != a) {
            var b, c = this._listenersMap,
                d;
            for (d in c) {
                var e = c[d],
                    f = e.getFixedPriorityListeners();
                b = e.getSceneGraphPriorityListeners();
                (b = this._removeListenerInVector(b, a)) ? this._setDirty(a._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY): (b = this._removeListenerInVector(f, a)) && this._setDirty(a._getListenerID(), this.DIRTY_FIXED_PRIORITY);
                e.empty() && (delete this._priorityDirtyFlagMap[a._getListenerID()], delete c[d]);
                if (b) break
            }
            if (!b) {
                c = this._toAddedListeners;
                d = 0;
                for (e = c.length; d < e; d++)
                    if (f = c[d], f == a) {
                        cc.arrayRemoveObject(c, f);
                        break
                    }
            }
        }
    },
    _removeListenerInVector: function(a,
        b) {
        if (null == a) return !1;
        for (var c = 0, d = a.length; c < d; c++) {
            var e = a[c];
            if (e == b) return e._setRegistered(!1), null != e._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(e._getSceneGraphPriority(), e), e._setSceneGraphPriority(null)), 0 == this._inDispatch && cc.arrayRemoveObject(a, e), !0
        }
        return !1
    },
    removeListeners: function(a, b) {
        if (a instanceof cc.Node) {
            delete this._nodePriorityMap[a.__instanceId];
            cc.arrayRemoveObject(this._dirtyNodes, a);
            var c = this._nodeListenersMap[a.__instanceId];
            if (c) {
                for (var d = cc.copyArray(c),
                    c = 0; c < d.length; c++) this.removeListener(d[c]);
                d.length = 0
            }
            d = this._toAddedListeners;
            for (c = 0; c < d.length;) {
                var e = d[c];
                e._getSceneGraphPriority() == a ? (e._setSceneGraphPriority(null), e._setRegistered(!1), d.splice(c, 1)) : ++c
            }
            if (!0 === b) {
                d = a.getChildren();
                c = 0;
                for (e = d.length; c < e; c++) this.removeListeners(d[c], !0)
            }
        } else a == cc.EventListener.TOUCH_ONE_BY_ONE ? this._removeListenersForListenerID(cc._EventListenerTouchOneByOne.LISTENER_ID) : a == cc.EventListener.TOUCH_ALL_AT_ONCE ? this._removeListenersForListenerID(cc._EventListenerTouchAllAtOnce.LISTENER_ID) :
            a == cc.EventListener.MOUSE ? this._removeListenersForListenerID(cc._EventListenerMouse.LISTENER_ID) : a == cc.EventListener.ACCELERATION ? this._removeListenersForListenerID(cc._EventListenerAcceleration.LISTENER_ID) : a == cc.EventListener.KEYBOARD ? this._removeListenersForListenerID(cc._EventListenerKeyboard.LISTENER_ID) : cc.log(cc._LogInfos.eventManager_removeListeners)
    },
    removeCustomListeners: function(a) {
        this._removeListenersForListenerID(a)
    },
    removeAllListeners: function() {
        var a = this._listenersMap,
            b = this._internalCustomListenerIDs,
            c;
        for (c in a) - 1 === b.indexOf(c) && this._removeListenersForListenerID(c)
    },
    setPriority: function(a, b) {
        if (null != a) {
            var c = this._listenersMap,
                d;
            for (d in c) {
                var e = c[d].getFixedPriorityListeners();
                if (e && -1 != e.indexOf(a)) {
                    null != a._getSceneGraphPriority() && cc.log(cc._LogInfos.eventManager_setPriority);
                    a._getFixedPriority() !== b && (a._setFixedPriority(b), this._setDirty(a._getListenerID(), this.DIRTY_FIXED_PRIORITY));
                    break
                }
            }
        }
    },
    setEnabled: function(a) {
        this._isEnabled = a
    },
    isEnabled: function() {
        return this._isEnabled
    },
    dispatchEvent: function(a) {
        if (this._isEnabled) {
            this._updateDirtyFlagForSceneGraph();
            this._inDispatch++;
            if (!a || !a.getType) throw "event is undefined";
            if (a.getType() == cc.Event.TOUCH) this._dispatchTouchEvent(a);
            else {
                var b = cc.__getListenerID(a);
                this._sortEventListeners(b);
                b = this._listenersMap[b];
                null != b && this._dispatchEventToListeners(b, this._onListenerCallback, a);
                this._updateListeners(a)
            }
            this._inDispatch--
        }
    },
    _onListenerCallback: function(a, b) {
        b._setCurrentTarget(a._getSceneGraphPriority());
        a._onEvent(b);
        return b.isStopped()
    },
    dispatchCustomEvent: function(a, b) {
        var c = new cc.EventCustom(a);
        c.setUserData(b);
        this.dispatchEvent(c)
    }
};
cc.EventHelper = function() {};
cc.EventHelper.prototype = {
    constructor: cc.EventHelper,
    apply: function(a) {
        a.addEventListener = cc.EventHelper.prototype.addEventListener;
        a.hasEventListener = cc.EventHelper.prototype.hasEventListener;
        a.removeEventListener = cc.EventHelper.prototype.removeEventListener;
        a.dispatchEvent = cc.EventHelper.prototype.dispatchEvent
    },
    addEventListener: function(a, b, c) {
        void 0 === this._listeners && (this._listeners = {});
        var d = this._listeners;
        void 0 === d[a] && (d[a] = []);
        this.hasEventListener(a, b, c) || d[a].push({
            callback: b,
            eventTarget: c
        })
    },
    hasEventListener: function(a, b, c) {
        if (void 0 === this._listeners) return !1;
        var d = this._listeners;
        if (void 0 !== d[a]) {
            a = 0;
            for (var e = d.length; a < e; a++) {
                var f = d[a];
                if (f.callback == b && f.eventTarget == c) return !0
            }
        }
        return !1
    },
    removeEventListener: function(a, b) {
        if (void 0 !== this._listeners) {
            var c = this._listeners[a];
            if (void 0 !== c)
                for (var d = 0; d < c.length;) c[d].eventTarget == b ? c.splice(d, 1) : d++
        }
    },
    dispatchEvent: function(a, b) {
        if (void 0 !== this._listeners) {
            null == b && (b = !0);
            var c = this._listeners[a];
            if (void 0 !== c) {
                for (var d = [], e =
                    c.length, f = 0; f < e; f++) d[f] = c[f];
                for (f = 0; f < e; f++) d[f].callback.call(d[f].eventTarget, this);
                b && (c.length = 0)
            }
        }
    }
};
cc.EventAcceleration = cc.Event.extend({
    _acc: null,
    ctor: function(a) {
        cc.Event.prototype.ctor.call(this, cc.Event.ACCELERATION);
        this._acc = a
    }
});
cc.EventKeyboard = cc.Event.extend({
    _keyCode: 0,
    _isPressed: !1,
    ctor: function(a, b) {
        cc.Event.prototype.ctor.call(this, cc.Event.KEYBOARD);
        this._keyCode = a;
        this._isPressed = b
    }
});
cc._EventListenerAcceleration = cc.EventListener.extend({
    _onAccelerationEvent: null,
    ctor: function(a) {
        this._onAccelerationEvent = a;
        var b = this;
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.ACCELERATION, cc._EventListenerAcceleration.LISTENER_ID, function(a) {
            b._onAccelerationEvent(a._acc, a)
        })
    },
    checkAvailable: function() {
        cc.assert(this._onAccelerationEvent, cc._LogInfos._EventListenerAcceleration_checkAvailable);
        return !0
    },
    clone: function() {
        return new cc._EventListenerAcceleration(this._onAccelerationEvent)
    }
});
cc._EventListenerAcceleration.LISTENER_ID = "__cc_acceleration";
cc._EventListenerAcceleration.create = function(a) {
    return new cc._EventListenerAcceleration(a)
};
cc._EventListenerKeyboard = cc.EventListener.extend({
    onKeyPressed: null,
    onKeyReleased: null,
    ctor: function() {
        var a = this;
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.KEYBOARD, cc._EventListenerKeyboard.LISTENER_ID, function(b) {
            if (b._isPressed) {
                if (a.onKeyPressed) a.onKeyPressed(b._keyCode, b)
            } else if (a.onKeyReleased) a.onKeyReleased(b._keyCode, b)
        })
    },
    clone: function() {
        var a = new cc._EventListenerKeyboard;
        a.onKeyPressed = this.onKeyPressed;
        a.onKeyReleased = this.onKeyReleased;
        return a
    },
    checkAvailable: function() {
        return null ==
            this.onKeyPressed && null == this.onKeyReleased ? (cc.log(cc._LogInfos._EventListenerKeyboard_checkAvailable), !1) : !0
    }
});
cc._EventListenerKeyboard.LISTENER_ID = "__cc_keyboard";
cc._EventListenerKeyboard.create = function() {
    return new cc._EventListenerKeyboard
};
cc._renderType === cc._RENDER_TYPE_CANVAS && (cc.rendererCanvas = {
        childrenOrderDirty: !0,
        _transformNodePool: [],
        _renderCmds: [],
        _isCacheToCanvasOn: !1,
        _cacheToCanvasCmds: {},
        _cacheInstanceIds: [],
        _currentID: 0,
        rendering: function(a) {
            var b = this._renderCmds,
                c, d = cc.view.getScaleX(),
                e = cc.view.getScaleY(),
                f = a || cc._renderContext;
            a = 0;
            for (c = b.length; a < c; a++) b[a].rendering(f, d, e)
        },
        _renderingToCacheCanvas: function(a, b) {
            a || cc.log("The context of RenderTexture is invalid.");
            b = b || this._currentID;
            var c = this._cacheToCanvasCmds[b],
                d, e;
            d = 0;
            for (e = c.length; d < e; d++) c[d].rendering(a, 1, 1);
            c.length = 0;
            c = this._cacheInstanceIds;
            delete this._cacheToCanvasCmds[b];
            cc.arrayRemoveObject(c, b);
            0 === c.length ? this._isCacheToCanvasOn = !1 : this._currentID = c[c.length - 1]
        },
        _turnToCacheMode: function(a) {
            this._isCacheToCanvasOn = !0;
            a = a || 0;
            this._cacheToCanvasCmds[a] = [];
            this._cacheInstanceIds.push(a);
            this._currentID = a
        },
        _turnToNormalMode: function() {
            this._isCacheToCanvasOn = !1
        },
        resetFlag: function() {
            this.childrenOrderDirty = !1;
            this._transformNodePool.length = 0
        },
        transform: function() {
            var a = this._transformNodePool;
            a.sort(this._sortNodeByLevelAsc);
            for (var b = 0, c = a.length; b < c; b++) a[b]._renderCmdDiry && a[b]._transformForRenderer();
            a.length = 0
        },
        transformDirty: function() {
            return 0 < this._transformNodePool.length
        },
        _sortNodeByLevelAsc: function(a, b) {
            return a._curLevel - b._curLevel
        },
        pushDirtyNode: function(a) {
            this._transformNodePool.push(a)
        },
        clearRenderCommands: function() {
            this._renderCmds.length = 0
        },
        pushRenderCommand: function(a) {
            if (this._isCacheToCanvasOn) {
                var b = this._cacheToCanvasCmds[this._currentID]; - 1 === b.indexOf(a) && b.push(a)
            } else -1 === this._renderCmds.indexOf(a) && this._renderCmds.push(a)
        }
    }, cc.renderer = cc.rendererCanvas, cc.TextureRenderCmdCanvas = function(a) {
        this._node = a;
        this._textureCoord = {
            renderX: 0,
            renderY: 0,
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            validRect: !1
        }
    }, cc.TextureRenderCmdCanvas.prototype.rendering = function(a, b, c) {
        var d = this._node;
        a = a || cc._renderContext;
        var e = this._textureCoord;
        if (!d._texture || !(0 === e.width || 0 === e.height))
            if (e.validRect || 0 !== d._displayedOpacity)
                if (!d._texture || d._texture._isLoaded) {
                    var f =
                        d._transformWorld,
                        g = d._offsetPosition.x,
                        h = -d._offsetPosition.y - d._rect.height,
                        k = d._rect.width,
                        m = d._rect.height,
                        n, q = "source" !== d._blendFuncStr;
                    n = d._displayedOpacity / 255;
                    1 !== f.a || 0 !== f.b || 0 !== f.c || 1 !== f.d || d._flippedX || d._flippedY ? (a.save(), a.globalAlpha = n, a.transform(f.a, f.c, f.b, f.d, f.tx * b, -f.ty * c), q && (a.globalCompositeOperation = d._blendFuncStr), d._flippedX && (g = -g - k, a.scale(-1, 1)), d._flippedY && (h = d._offsetPosition.y, a.scale(1, -1)), d._texture ? (n = d._texture._htmlElementObj, d._colorized ? a.drawImage(n,
                        0, 0, e.width, e.height, g * b, h * c, k * b, m * c) : a.drawImage(n, e.renderX, e.renderY, e.width, e.height, g * b, h * c, k * b, m * c)) : (k = d._contentSize, 0 !== k.width && 0 !== k.height && (e = d._displayedColor, a.fillStyle = "rgba(" + e.r + "," + e.g + "," + e.b + "," + (d._displayedOpacity / 255).toFixed(4) + ")", a.fillRect(g * b, h * c, k.width * b, k.height * c))), a.restore()) : (q && (a.save(), a.globalCompositeOperation = d._blendFuncStr), a.globalAlpha = n, d._texture ? (n = d._texture.getHtmlElementObj(), d._colorized ? a.drawImage(n, 0, 0, e.width, e.height, (f.tx + g) * b, (-f.ty + h) *
                        c, k * b, m * c) : a.drawImage(n, e.renderX, e.renderY, e.width, e.height, (f.tx + g) * b, (-f.ty + h) * c, k * b, m * c)) : (k = d._contentSize, 0 !== k.width && 0 !== k.height && (e = d._displayedColor, a.fillStyle = "rgba(" + e.r + "," + e.g + "," + e.b + "," + (d._displayedOpacity / 255).toFixed(4) + ")", a.fillRect((f.tx + g) * b, (-f.ty + h) * c, k.width * b, k.height * c))), q && a.restore());
                    cc.g_NumberOfDraws++
                }
    }, cc.RectRenderCmdCanvas = function(a) {
        this._node = a
    }, cc.RectRenderCmdCanvas.prototype.rendering = function(a, b, c) {
        a = a || cc._renderContext;
        var d = this._node,
            e = d._transformWorld,
            f = d._displayedColor,
            g = d._displayedOpacity / 255,
            h = d._contentSize.width,
            k = d._contentSize.height;
        if (0 !== g) {
            var m = 1 !== e.a || 0 !== e.b || 0 !== e.c || 1 !== e.d,
                n = "source" !== d._blendFuncStr || m;
            n && (a.save(), a.globalCompositeOperation = d._blendFuncStr);
            a.globalAlpha = g;
            a.fillStyle = "rgba(" + (0 | f.r) + "," + (0 | f.g) + "," + (0 | f.b) + ", 1)";
            m ? (a.transform(e.a, e.c, e.b, e.d, e.tx * b, -e.ty * c), a.fillRect(0, 0, h * b, -k * c)) : a.fillRect(e.tx * b, -e.ty * c, h * b, -k * c);
            n && a.restore();
            cc.g_NumberOfDraws++
        }
    }, cc.GradientRectRenderCmdCanvas = function(a) {
        this._node =
            a;
        this._startPoint = cc.p(0, 0);
        this._endPoint = cc.p(0, 0);
        this._endStopStr = this._startStopStr = null
    }, cc.GradientRectRenderCmdCanvas.prototype.rendering = function(a, b, c) {
        a = a || cc._renderContext;
        var d = this._node,
            e = d._displayedOpacity / 255,
            f = d._transformWorld;
        if (0 !== e) {
            var g = 1 !== f.a || 0 !== f.b || 0 !== f.c || 1 !== f.d,
                h = "source" !== d._blendFuncStr || g;
            h && (a.save(), a.globalCompositeOperation = d._blendFuncStr);
            a.globalAlpha = e;
            var e = d._contentSize.width,
                d = d._contentSize.height,
                k = a.createLinearGradient(this._startPoint.x, this._startPoint.y,
                    this._endPoint.x, this._endPoint.y);
            k.addColorStop(0, this._startStopStr);
            k.addColorStop(1, this._endStopStr);
            a.fillStyle = k;
            g ? (a.transform(f.a, f.c, f.b, f.d, f.tx * b, -f.ty * c), a.fillRect(0, 0, e * b, -d * c)) : a.fillRect(f.tx * b, -f.ty * c, e * b, -d * c);
            h && a.restore();
            cc.g_NumberOfDraws++
        }
    }, cc.ParticleRenderCmdCanvas = function(a) {
        this._node = a
    }, cc.ParticleRenderCmdCanvas.prototype.rendering = function(a, b, c) {
        a = a || cc._renderContext;
        var d = this._node,
            e = d._transformWorld,
            f = d._pointRect;
        a.save();
        a.transform(e.a, e.c, e.b, e.d, e.tx *
            b, -e.ty * c);
        d.isBlendAdditive() ? a.globalCompositeOperation = "lighter" : a.globalCompositeOperation = "source-over";
        var g;
        b = this._node.particleCount;
        c = this._node._particles;
        if (cc.ParticleSystem.SHAPE_MODE == cc.ParticleSystem.TEXTURE_MODE) {
            if (!d._texture || !d._texture._isLoaded) {
                a.restore();
                return
            }
            var h = d._texture.getHtmlElementObj();
            if (!h.width || !h.height) {
                a.restore();
                return
            }
            for (var k = cc.textureCache, m = h, d = 0; d < b; d++)
                if (e = c[d], g = e.color.a / 255, 0 !== g) {
                    a.globalAlpha = g;
                    a.save();
                    a.translate(0 | e.drawPos.x, -(0 | e.drawPos.y));
                    var n = 4 * Math.floor(e.size / 4);
                    g = f.width;
                    var q = f.height;
                    a.scale(Math.max(1 / g * n, 1E-6), Math.max(1 / q * n, 1E-6));
                    e.rotation && a.rotate(cc.degreesToRadians(e.rotation));
                    if (e.isChangeColor && (n = k.getTextureColors(h))) n.tintCache || (n.tintCache = cc.newElement("canvas"), n.tintCache.width = h.width, n.tintCache.height = h.height), cc.generateTintImage(h, n, e.color, this._pointRect, n.tintCache), m = n.tintCache;
                    a.drawImage(m, -(0 | g / 2), -(0 | q / 2));
                    a.restore()
                }
        } else {
            h = cc._drawingUtil;
            for (d = 0; d < b; d++) e = c[d], f = 0 | 0.5 * e.size, g = e.color.a /
                255, 0 !== g && (a.globalAlpha = g, a.save(), a.translate(0 | e.drawPos.x, -(0 | e.drawPos.y)), cc.ParticleSystem.BALL_SHAPE == cc.ParticleSystem.STAR_SHAPE ? (e.rotation && a.rotate(cc.degreesToRadians(e.rotation)), h.drawStar(a, f, e.color)) : h.drawColorBall(a, f, e.color), a.restore())
        }
        a.restore();
        cc.g_NumberOfDraws++
    }, cc.ProgressRenderCmdCanvas = function(a) {
        this._PI180 = Math.PI / 180;
        this._node = a;
        this._sprite = null;
        this._type = cc.ProgressTimer.TYPE_RADIAL;
        this._barRect = cc.rect(0, 0, 0, 0);
        this._origin = cc.p(0, 0);
        this._radius = 0;
        this._endAngle =
            this._startAngle = 270;
        this._counterClockWise = !1
    }, cc.ProgressRenderCmdCanvas.prototype.rendering = function(a, b, c) {
        a = a || cc._renderContext;
        var d = this._node,
            e = this._sprite,
            f = e._rendererCmd._textureCoord,
            g = e._displayedOpacity / 255;
        if (!(0 === f.width || 0 === f.height) && e._texture && f.validRect && 0 !== g) {
            d = d._transformWorld;
            a.save();
            a.transform(d.a, d.c, d.b, d.d, d.tx * b, -d.ty * c);
            "source" != e._blendFuncStr && (a.globalCompositeOperation = e._blendFuncStr);
            a.globalAlpha = g;
            var h = e._rect,
                k = e._offsetPosition,
                g = e._drawSize_Canvas,
                d = 0 | k.x,
                m = -k.y - h.height;
            g.width = h.width * b;
            g.height = h.height * c;
            e._flippedX && (d = -k.x - h.width, a.scale(-1, 1));
            e._flippedY && (m = k.y, a.scale(1, -1));
            d *= b;
            m *= c;
            this._type == cc.ProgressTimer.TYPE_BAR ? (h = this._barRect, a.beginPath(), a.rect(h.x * b, h.y * c, h.width * b, h.height * c), a.clip(), a.closePath()) : this._type == cc.ProgressTimer.TYPE_RADIAL && (b *= this._origin.x, h = this._origin.y * c, a.beginPath(), a.arc(b, h, this._radius * c, this._PI180 * this._startAngle, this._PI180 * this._endAngle, this._counterClockWise), a.lineTo(b, h), a.clip(),
                a.closePath());
            c = e._texture.getHtmlElementObj();
            a.drawImage(c, f.renderX, f.renderY, f.width, f.height, d, m, g.width, g.height);
            a.restore();
            cc.g_NumberOfDraws++
        }
    }, cc.DrawNodeRenderCmdCanvas = function(a) {
        this._node = a;
        this._blendFunc = this._drawColor = this._buffer = null
    }, cc.DrawNodeRenderCmdCanvas.prototype.rendering = function(a, b, c) {
        var d = a || cc._renderContext,
            e = this._node,
            f = e._displayedOpacity / 255;
        if (0 !== f) {
            d.globalAlpha = f;
            e = e._transformWorld;
            d.save();
            a.transform(e.a, e.c, e.b, e.d, e.tx * b, -e.ty * c);
            this._blendFunc &&
                (this._blendFunc.src == cc.SRC_ALPHA && this._blendFunc.dst == cc.ONE) && (d.globalCompositeOperation = "lighter");
            a = this._buffer;
            e = 0;
            for (f = a.length; e < f; e++) {
                var g = a[e];
                switch (g.type) {
                    case cc.DrawNode.TYPE_DOT:
                        this._drawDot(d, g, b, c);
                        break;
                    case cc.DrawNode.TYPE_SEGMENT:
                        this._drawSegment(d, g, b, c);
                        break;
                    case cc.DrawNode.TYPE_POLY:
                        this._drawPoly(d, g, b, c)
                }
            }
            d.restore()
        }
    }, cc.DrawNodeRenderCmdCanvas.prototype._drawDot = function(a, b, c, d) {
        var e = b.fillColor,
            f = b.verts[0];
        b = b.lineWidth;
        a.fillStyle = "rgba(" + (0 | e.r) + "," + (0 |
            e.g) + "," + (0 | e.b) + "," + e.a / 255 + ")";
        a.beginPath();
        a.arc(f.x * c, -f.y * d, b * c, 0, 2 * Math.PI, !1);
        a.closePath();
        a.fill()
    }, cc.DrawNodeRenderCmdCanvas.prototype._drawSegment = function(a, b, c, d) {
        var e = b.lineColor,
            f = b.verts[0],
            g = b.verts[1],
            h = b.lineWidth;
        b = b.lineCap;
        a.strokeStyle = "rgba(" + (0 | e.r) + "," + (0 | e.g) + "," + (0 | e.b) + "," + e.a / 255 + ")";
        a.lineWidth = h * c;
        a.beginPath();
        a.lineCap = b;
        a.moveTo(f.x * c, -f.y * d);
        a.lineTo(g.x * c, -g.y * d);
        a.stroke()
    }, cc.DrawNodeRenderCmdCanvas.prototype._drawPoly = function(a, b, c, d) {
        var e = b.verts,
            f = b.lineCap,
            g = b.fillColor,
            h = b.lineWidth,
            k = b.lineColor,
            m = b.isClosePolygon,
            n = b.isFill;
        b = b.isStroke;
        if (null != e) {
            var q = e[0];
            a.lineCap = f;
            g && (a.fillStyle = "rgba(" + (0 | g.r) + "," + (0 | g.g) + "," + (0 | g.b) + "," + g.a / 255 + ")");
            h && (a.lineWidth = h * c);
            k && (a.strokeStyle = "rgba(" + (0 | k.r) + "," + (0 | k.g) + "," + (0 | k.b) + "," + k.a / 255 + ")");
            a.beginPath();
            a.moveTo(q.x * c, -q.y * d);
            f = 1;
            for (g = e.length; f < g; f++) a.lineTo(e[f].x * c, -e[f].y * d);
            m && a.closePath();
            n && a.fill();
            b && a.stroke()
        }
    }, cc.ClippingNodeSaveRenderCmdCanvas = function(a) {
        this._node = a
    }, cc.ClippingNodeSaveRenderCmdCanvas.prototype.rendering =
    function(a, b, c) {
        var d = this._node;
        a = a || cc._renderContext;
        d._clipElemType ? (b = cc.ClippingNode._getSharedCache(), c = a.canvas, b.width = c.width, b.height = c.height, b.getContext("2d").drawImage(c, 0, 0), a.save()) : (d.transform(), d = d._transformWorld, a.save(), a.save(), a.transform(d.a, d.c, d.b, d.d, d.tx * b, -d.ty * c))
    }, cc.ClippingNodeClipRenderCmdCanvas = function(a) {
        this._node = a
    }, cc.ClippingNodeClipRenderCmdCanvas.prototype.rendering = function(a, b, c) {
        var d = this._node;
        a = a || cc._renderContext;
        d._clipElemType ? (a.globalCompositeOperation =
            d.inverted ? "destination-out" : "destination-in", d = d._transformWorld, a.transform(d.a, d.c, d.b, d.d, d.tx * b, -d.ty * c)) : (a.restore(), d.inverted && (b = a.canvas, a.save(), a.setTransform(1, 0, 0, 1, 0, 0), a.moveTo(0, 0), a.lineTo(0, b.height), a.lineTo(b.width, b.height), a.lineTo(b.width, 0), a.lineTo(0, 0), a.restore()), a.clip())
    }, cc.ClippingNodeRestoreRenderCmdCanvas = function(a) {
        this._node = a
    }, cc.ClippingNodeRestoreRenderCmdCanvas.prototype.rendering = function(a, b, c) {
        b = this._node;
        c = cc.ClippingNode._getSharedCache();
        a = a || cc._renderContext;
        b._clipElemType && (a.restore(), a.save(), a.setTransform(1, 0, 0, 1, 0, 0), a.globalCompositeOperation = "destination-over", a.drawImage(c, 0, 0));
        a.restore()
    }, cc.PhysicsDebugNodeRenderCmdCanvas = function(a) {
        this._node = a;
        this._buffer = a._buffer
    }, cc.PhysicsDebugNodeRenderCmdCanvas.prototype.rendering = function(a, b, c) {
        var d = this._node;
        d._space && (d._space.eachShape(cc.DrawShape.bind(d)), d._space.eachConstraint(cc.DrawConstraint.bind(d)), cc.DrawNodeRenderCmdCanvas.prototype.rendering.call(this, a, b, c), d.clear())
    }, cc.PhysicsDebugNodeRenderCmdCanvas.prototype._drawDot =
    cc.DrawNodeRenderCmdCanvas.prototype._drawDot, cc.PhysicsDebugNodeRenderCmdCanvas.prototype._drawSegment = cc.DrawNodeRenderCmdCanvas.prototype._drawSegment, cc.PhysicsDebugNodeRenderCmdCanvas.prototype._drawPoly = cc.DrawNodeRenderCmdCanvas.prototype._drawPoly, cc.TMXLayerRenderCmdCanvas = function(a) {
        this._node = a;
        this._childrenRenderCmds = []
    }, cc.TMXLayerRenderCmdCanvas.prototype._copyRendererCmds = function(a) {
        if (a)
            for (var b = this._childrenRenderCmds, c = b.length = 0, d = a.length; c < d; c++) b[c] = a[c]
    }, cc.TMXLayerRenderCmdCanvas.prototype._renderingChildToCache =
    function(a, b) {
        var c = this._node;
        if (c._cacheDirty) {
            var d = this._childrenRenderCmds,
                e = c._cacheContext,
                f = c._cacheCanvas;
            e.save();
            e.clearRect(0, 0, f.width, -f.height);
            f = cc.affineTransformInvert(c._transformWorld);
            e.transform(f.a, f.c, f.b, f.d, f.tx * a, -f.ty * b);
            for (var f = 0, g = d.length; f < g; f++) d[f].rendering(e, a, b), d[f]._node && (d[f]._node._cacheDirty = !1);
            e.restore();
            c._cacheDirty = !1
        }
    }, cc.TMXLayerRenderCmdCanvas.prototype.rendering = function(a, b, c) {
        var d = this._node,
            e = d._displayedOpacity / 255;
        if (!(0 >= e)) {
            this._renderingChildToCache(b,
                c);
            a = a || cc._renderContext;
            a.globalAlpha = e;
            var e = 0 | -d._anchorPointInPoints.x,
                f = 0 | -d._anchorPointInPoints.y,
                g = d._cacheCanvas,
                h = d._transformWorld;
            g && (0 !== g.width && 0 !== g.height) && (a.save(), a.transform(h.a, h.c, h.b, h.d, h.tx * b, -h.ty * c), h = g.height * c, d.layerOrientation === cc.TMX_ORIENTATION_HEX ? a.drawImage(g, 0, 0, g.width, g.height, e, -(f + h) + 0.5 * d._mapTileSize.height * c, g.width * b, h) : a.drawImage(g, 0, 0, g.width, g.height, e, -(f + h), g.width * b, h), a.restore());
            cc.g_NumberOfDraws++
        }
    }, cc.CustomRenderCmdCanvas = function(a, b) {
        this._node =
            a;
        this._callback = b
    }, cc.CustomRenderCmdCanvas.prototype.rendering = function(a, b, c) {
        this._callback && this._callback.call(this._node, a, b, c)
    }, cc.SkeletonRenderCmdCanvas = function(a) {
        this._node = a
    }, cc.SkeletonRenderCmdCanvas.prototype.rendering = function(a, b, c) {
        var d = this._node;
        a = a || cc._renderContext;
        if (d._debugSlots || d._debugBones) {
            var e = d._transformWorld;
            a.save();
            a.transform(e.a, e.c, e.b, e.d, e.tx * b, -e.ty * c);
            b = d._skeleton;
            var f, g, h = cc._drawingUtil;
            if (d._debugSlots) {
                h.setDrawColor(0, 0, 255, 255);
                h.setLineWidth(1);
                var k = [];
                c = 0;
                for (e = b.slots.length; c < e; c++) g = b.drawOrder[c], g.attachment && g.attachment.type == sp.ATTACHMENT_TYPE.REGION && (f = g.attachment, sp._regionAttachment_updateSlotForCanvas(f, g, k), h.drawPoly(k, 4, !0))
            }
            if (d._debugBones) {
                h.setLineWidth(2);
                h.setDrawColor(255, 0, 0, 255);
                c = 0;
                for (e = b.bones.length; c < e; c++) d = b.bones[c], h.drawLine({
                    x: d.worldX,
                    y: d.worldY
                }, {
                    x: d.data.length * d.m00 + d.worldX,
                    y: d.data.length * d.m10 + d.worldY
                });
                h.setPointSize(4);
                h.setDrawColor(0, 0, 255, 255);
                c = 0;
                for (e = b.bones.length; c < e; c++) d = b.bones[c],
                    h.drawPoint({
                        x: d.worldX,
                        y: d.worldY
                    }), 0 === c && h.setDrawColor(0, 255, 0, 255)
            }
            a.restore()
        }
    });
cc._renderType === cc._RENDER_TYPE_WEBGL && (cc.rendererWebGL = {
        childrenOrderDirty: !0,
        _transformNodePool: [],
        _renderCmds: [],
        _isCacheToBufferOn: !1,
        _cacheToBufferCmds: {},
        _cacheInstanceIds: [],
        _currentID: 0,
        rendering: function(a) {
            var b = this._renderCmds,
                c, d = a || cc._renderContext;
            a = 0;
            for (c = b.length; a < c; a++) b[a].rendering(d)
        },
        _turnToCacheMode: function(a) {
            this._isCacheToBufferOn = !0;
            a = a || 0;
            this._cacheToBufferCmds[a] = [];
            this._cacheInstanceIds.push(a);
            this._currentID = a
        },
        _turnToNormalMode: function() {
            this._isCacheToBufferOn = !1
        },
        _renderingToBuffer: function(a) {
            a = a || this._currentID;
            var b = this._cacheToBufferCmds[a],
                c, d, e = cc._renderContext,
                f = this._cacheInstanceIds;
            c = 0;
            for (d = b.length; c < d; c++) b[c].rendering(e);
            b.length = 0;
            delete this._cacheToBufferCmds[a];
            cc.arrayRemoveObject(f, a);
            0 === f.length ? this._isCacheToBufferOn = !1 : this._currentID = f[f.length - 1]
        },
        resetFlag: function() {
            this.childrenOrderDirty = !1;
            this._transformNodePool.length = 0
        },
        transform: function() {
            var a = this._transformNodePool;
            a.sort(this._sortNodeByLevelAsc);
            for (var b =
                0, c = a.length; b < c; b++) a[b]._renderCmdDiry && a[b]._transformForRenderer();
            a.length = 0
        },
        transformDirty: function() {
            return 0 < this._transformNodePool.length
        },
        _sortNodeByLevelAsc: function(a, b) {
            return a._curLevel - b._curLevel
        },
        pushDirtyNode: function(a) {
            this._transformNodePool.push(a)
        },
        clearRenderCommands: function() {
            this._renderCmds.length = 0
        },
        pushRenderCommand: function(a) {
            if (this._isCacheToBufferOn) {
                var b = this._cacheToBufferCmds[this._currentID]; - 1 === b.indexOf(a) && b.push(a)
            } else -1 === this._renderCmds.indexOf(a) &&
                this._renderCmds.push(a)
        }
    }, cc.renderer = cc.rendererWebGL, cc.TextureRenderCmdWebGL = function(a) {
        this._node = a
    }, cc.TextureRenderCmdWebGL.prototype.rendering = function(a) {
        var b = this._node;
        if (b._textureLoaded && 0 !== b._displayedOpacity) {
            a = a || cc._renderContext;
            var c = b._texture;
            c ? c._isLoaded && (b._shaderProgram.use(), b._shaderProgram._setUniformForMVPMatrixWithMat4(b._stackMatrix), cc.glBlendFunc(b._blendFunc.src, b._blendFunc.dst), cc.glBindTexture2DN(0, c), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX),
                a.bindBuffer(a.ARRAY_BUFFER, b._quadWebBuffer), b._quadDirty && (a.bufferData(a.ARRAY_BUFFER, b._quad.arrayBuffer, a.DYNAMIC_DRAW), b._quadDirty = !1), a.vertexAttribPointer(0, 3, a.FLOAT, !1, 24, 0), a.vertexAttribPointer(1, 4, a.UNSIGNED_BYTE, !0, 24, 12), a.vertexAttribPointer(2, 2, a.FLOAT, !1, 24, 16), a.drawArrays(a.TRIANGLE_STRIP, 0, 4)) : (b._shaderProgram.use(), b._shaderProgram._setUniformForMVPMatrixWithMat4(b._stackMatrix), cc.glBlendFunc(b._blendFunc.src, b._blendFunc.dst), cc.glBindTexture2D(null), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION |
                cc.VERTEX_ATTRIB_FLAG_COLOR), a.bindBuffer(a.ARRAY_BUFFER, b._quadWebBuffer), b._quadDirty && (a.bufferData(a.ARRAY_BUFFER, b._quad.arrayBuffer, a.STATIC_DRAW), b._quadDirty = !1), a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, a.FLOAT, !1, 24, 0), a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 24, 12), a.drawArrays(a.TRIANGLE_STRIP, 0, 4));
            cc.g_NumberOfDraws++
        }
    }, cc.RectRenderCmdWebGL = function(a) {
        this._node = a
    }, cc.RectRenderCmdWebGL.prototype.rendering = function(a) {
        a = a || cc._renderContext;
        var b = this._node;
        b._shaderProgram.use();
        b._shaderProgram._setUniformForMVPMatrixWithMat4(b._stackMatrix);
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR);
        a.bindBuffer(a.ARRAY_BUFFER, b._verticesFloat32Buffer);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
        a.bindBuffer(a.ARRAY_BUFFER, b._colorsUint8Buffer);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 0, 0);
        cc.glBlendFunc(b._blendFunc.src, b._blendFunc.dst);
        a.drawArrays(a.TRIANGLE_STRIP, 0, 4)
    }, cc.DrawNodeRenderCmdWebGL =
    function(a) {
        this._node = a
    }, cc.DrawNodeRenderCmdWebGL.prototype.rendering = function(a) {
        a = this._node;
        cc.glBlendFunc(a._blendFunc.src, a._blendFunc.dst);
        a._shaderProgram.use();
        a._shaderProgram._setUniformForMVPMatrixWithMat4(a._stackMatrix);
        a._render()
    }, cc.MotionStreakCmdWebGL = function(a) {
        this._node = a
    }, cc.MotionStreakCmdWebGL.prototype.rendering = function(a) {
        var b = this._node;
        !(1 >= b._nuPoints) && (b.texture && b.texture.isLoaded()) && (a = a || cc._renderContext, b._shaderProgram.use(), b._shaderProgram._setUniformForMVPMatrixWithMat4(b._stackMatrix),
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), cc.glBlendFunc(b._blendFunc.src, b._blendFunc.dst), cc.glBindTexture2D(b.texture), a.bindBuffer(a.ARRAY_BUFFER, b._verticesBuffer), a.bufferData(a.ARRAY_BUFFER, b._vertices, a.DYNAMIC_DRAW), a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0), a.bindBuffer(a.ARRAY_BUFFER, b._texCoordsBuffer), a.bufferData(a.ARRAY_BUFFER, b._texCoords, a.DYNAMIC_DRAW), a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, 0, 0), a.bindBuffer(a.ARRAY_BUFFER,
                b._colorPointerBuffer), a.bufferData(a.ARRAY_BUFFER, b._colorPointer, a.DYNAMIC_DRAW), a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 0, 0), a.drawArrays(a.TRIANGLE_STRIP, 0, 2 * b._nuPoints), cc.g_NumberOfDraws++)
    }, cc.ProgressRenderCmdWebGL = function(a) {
        this._node = a
    }, cc.ProgressRenderCmdWebGL.prototype.rendering = function(a) {
        var b = this._node;
        a = a || cc._renderContext;
        if (b._vertexData && b._sprite) {
            b._shaderProgram.use();
            b._shaderProgram._setUniformForMVPMatrixWithMat4(b._stackMatrix);
            var c = b._sprite.getBlendFunc();
            cc.glBlendFunc(c.src, c.dst);
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
            cc.glBindTexture2D(b._sprite.texture);
            a.bindBuffer(a.ARRAY_BUFFER, b._vertexWebGLBuffer);
            b._vertexDataDirty && (a.bufferData(a.ARRAY_BUFFER, b._vertexArrayBuffer, a.DYNAMIC_DRAW), b._vertexDataDirty = !1);
            c = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
            a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, c, 0);
            a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, c, 8);
            a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS,
                2, a.FLOAT, !1, c, 12);
            b._type === cc.ProgressTimer.TYPE_RADIAL ? a.drawArrays(a.TRIANGLE_FAN, 0, b._vertexDataCount) : b._type == cc.ProgressTimer.TYPE_BAR && (b._reverseDirection ? (a.drawArrays(a.TRIANGLE_STRIP, 0, b._vertexDataCount / 2), a.drawArrays(a.TRIANGLE_STRIP, 4, b._vertexDataCount / 2), cc.g_NumberOfDraws++) : a.drawArrays(a.TRIANGLE_STRIP, 0, b._vertexDataCount));
            cc.g_NumberOfDraws++
        }
    }, cc.ParticleRenderCmdWebGL = function(a) {
        this._node = a
    }, cc.ParticleRenderCmdWebGL.prototype.rendering = function(a) {
        var b = this._node;
        b._texture &&
            (a = a || cc._renderContext, b._shaderProgram.use(), b._shaderProgram._setUniformForMVPMatrixWithMat4(b._stackMatrix), cc.glBindTexture2D(b._texture), cc.glBlendFuncForParticle(b._blendFunc.src, b._blendFunc.dst), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), a.bindBuffer(a.ARRAY_BUFFER, b._buffersVBO[0]), a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, a.FLOAT, !1, 24, 0), a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 24, 12), a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS,
                2, a.FLOAT, !1, 24, 16), a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, b._buffersVBO[1]), a.drawElements(a.TRIANGLES, 6 * b._particleIdx, a.UNSIGNED_SHORT, 0))
    }, cc.ParticleBatchNodeRenderCmdWebGL = function(a) {
        this._node = a
    }, cc.ParticleBatchNodeRenderCmdWebGL.prototype.rendering = function(a) {
        a = this._node;
        0 != a.textureAtlas.totalQuads && (a._shaderProgram.use(), a._shaderProgram._setUniformForMVPMatrixWithMat4(a._stackMatrix), cc.glBlendFuncForParticle(a._blendFunc.src, a._blendFunc.dst), a.textureAtlas.drawQuads())
    }, cc.RenderTextureRenderCmdWebGL =
    function(a) {
        this._node = a
    }, cc.RenderTextureRenderCmdWebGL.prototype.rendering = function(a) {
        var b = a || cc._renderContext;
        a = this._node;
        if (a.autoDraw) {
            a.begin();
            var c = a.clearFlags;
            if (c) {
                var d = [0, 0, 0, 0],
                    e = 0,
                    f = 0;
                c & b.COLOR_BUFFER_BIT && (d = b.getParameter(b.COLOR_CLEAR_VALUE), b.clearColor(a._clearColor.r / 255, a._clearColor.g / 255, a._clearColor.b / 255, a._clearColor.a / 255));
                c & b.DEPTH_BUFFER_BIT && (e = b.getParameter(b.DEPTH_CLEAR_VALUE), b.clearDepth(a.clearDepthVal));
                c & b.STENCIL_BUFFER_BIT && (f = b.getParameter(b.STENCIL_CLEAR_VALUE),
                    b.clearStencil(a.clearStencilVal));
                b.clear(c);
                c & b.COLOR_BUFFER_BIT && b.clearColor(d[0], d[1], d[2], d[3]);
                c & b.DEPTH_BUFFER_BIT && b.clearDepth(e);
                c & b.STENCIL_BUFFER_BIT && b.clearStencil(f)
            }
            a.sortAllChildren();
            b = a._children;
            for (c = 0; c < b.length; c++) d = b[c], d != a.sprite && d.visit();
            a.end()
        }
    }, cc.SpriteBatchNodeRenderCmdWebGL = function(a) {
        this._node = a
    }, cc.SpriteBatchNodeRenderCmdWebGL.prototype.rendering = function(a) {
        a = this._node;
        0 !== a.textureAtlas.totalQuads && (a._shaderProgram.use(), a._shaderProgram._setUniformForMVPMatrixWithMat4(a._stackMatrix),
            a._arrayMakeObjectsPerformSelector(a._children, cc.Node._StateCallbackType.updateTransform), cc.glBlendFunc(a._blendFunc.src, a._blendFunc.dst), a.textureAtlas.drawQuads())
    }, cc.AtlasNodeRenderCmdWebGL = function(a) {
        this._node = a
    }, cc.AtlasNodeRenderCmdWebGL.prototype.rendering = function(a) {
        a = a || cc._renderContext;
        var b = this._node;
        b._shaderProgram.use();
        b._shaderProgram._setUniformForMVPMatrixWithMat4(b._stackMatrix);
        cc.glBlendFunc(b._blendFunc.src, b._blendFunc.dst);
        b._uniformColor && b._colorF32Array && (a.uniform4fv(b._uniformColor,
            b._colorF32Array), b.textureAtlas.drawNumberOfQuads(b.quadsToDraw, 0))
    }, cc.CustomRenderCmdWebGL = function(a, b) {
        this._node = a;
        this._callback = b
    }, cc.CustomRenderCmdWebGL.prototype.rendering = function(a) {
        this._callback && this._callback.call(this._node, a)
    }, cc.TMXLayerRenderCmdWebGL = function(a) {
        this._node = a
    }, cc.TMXLayerRenderCmdWebGL.prototype.rendering = cc.SpriteBatchNodeRenderCmdWebGL.prototype.rendering, cc.PhysicsDebugNodeRenderCmdWebGL = function(a) {
        this._node = a
    }, cc.PhysicsDebugNodeRenderCmdWebGL.prototype.rendering =
    function(a) {
        a = this._node;
        a._space && (a._space.eachShape(cc.DrawShape.bind(a)), a._space.eachConstraint(cc.DrawConstraint.bind(a)), cc.DrawNode.prototype.draw.call(a), a.clear())
    }, cc.SkeletonRenderCmdWebGL = function(a) {
        this._node = a
    }, cc.SkeletonRenderCmdWebGL.prototype.rendering = function(a) {
        var b = this._node;
        b._shaderProgram.use();
        b._shaderProgram._setUniformForMVPMatrixWithMat4(b._stackMatrix);
        var c = b.getColor();
        a = b._skeleton;
        a.r = c.r / 255;
        a.g = c.g / 255;
        a.b = c.b / 255;
        a.a = b.getOpacity() / 255;
        b._premultipliedAlpha &&
            (a.r *= a.a, a.g *= a.a, a.b *= a.a);
        var d, e, f, g, h, k = new cc.V3F_C4B_T2F_Quad,
            m = b._blendFunc,
            c = 0;
        for (h = a.slots.length; c < h; c++)
            if (g = a.drawOrder[c], g.attachment && g.attachment.type == sp.ATTACHMENT_TYPE.REGION) {
                f = g.attachment;
                var n = b.getTextureAtlas(f);
                g.data.additiveBlending != d ? (e && (e.drawQuads(), e.removeAllQuads()), d = !d, cc.glBlendFunc(m.src, d ? cc.ONE : m.dst)) : n != e && e && (e.drawQuads(), e.removeAllQuads());
                e = n;
                n = e.getTotalQuads();
                if (e.getCapacity() == n && (e.drawQuads(), e.removeAllQuads(), !e.resizeCapacity(2 * e.getCapacity()))) return;
                sp._regionAttachment_updateQuad(f, g, k, b._premultipliedAlpha);
                e.updateQuad(k, n)
            }
        e && (e.drawQuads(), e.removeAllQuads());
        if (b._debugBones || b._debugSlots) {
            cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
            cc.current_stack.stack.push(cc.current_stack.top);
            cc.current_stack.top = b._stackMatrix;
            d = cc._drawingUtil;
            if (b._debugSlots) {
                d.setDrawColor(0, 0, 255, 255);
                d.setLineWidth(1);
                c = 0;
                for (h = a.slots.length; c < h; c++) g = a.drawOrder[c], g.attachment && g.attachment.type == sp.ATTACHMENT_TYPE.REGION && (f = g.attachment, k = new cc.V3F_C4B_T2F_Quad,
                    sp._regionAttachment_updateQuad(f, g, k), e = [], e.push(cc.p(k.bl.vertices.x, k.bl.vertices.y)), e.push(cc.p(k.br.vertices.x, k.br.vertices.y)), e.push(cc.p(k.tr.vertices.x, k.tr.vertices.y)), e.push(cc.p(k.tl.vertices.x, k.tl.vertices.y)), d.drawPoly(e, 4, !0))
            }
            if (b._debugBones) {
                d.setLineWidth(2);
                d.setDrawColor(255, 0, 0, 255);
                c = 0;
                for (h = a.bones.length; c < h; c++) b = a.bones[c], e = b.data.length * b.m00 + b.worldX, k = b.data.length * b.m10 + b.worldY, d.drawLine(cc.p(b.worldX, b.worldY), cc.p(e, k));
                d.setPointSize(4);
                d.setDrawColor(0,
                    0, 255, 255);
                c = 0;
                for (h = a.bones.length; c < h; c++) b = a.bones[c], d.drawPoint(cc.p(b.worldX, b.worldY)), 0 == c && d.setDrawColor(0, 255, 0, 255)
            }
            cc.kmGLPopMatrix()
        }
    }, cc.ArmatureRenderCmdWebGL = function(a) {
        this._node = a
    }, cc.ArmatureRenderCmdWebGL.prototype.rendering = function(a) {
        var b = this._node;
        cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
        cc.kmGLPushMatrix();
        cc.kmGLLoadMatrix(b._stackMatrix);
        for (var c = b._children, d = cc.BlendFunc.ALPHA_PREMULTIPLIED, e = cc.BlendFunc.ALPHA_NON_PREMULTIPLIED, f = 0, g = c.length; f < g; f++) {
            var h = c[f];
            if (h &&
                h.getDisplayRenderNode) {
                var k = h.getDisplayRenderNode();
                if (null != k) switch (k.setShaderProgram(b._shaderProgram), h.getDisplayRenderNodeType()) {
                    case ccs.DISPLAY_TYPE_SPRITE:
                        if (k instanceof ccs.Skin) {
                            k.updateTransform();
                            var m = h.getBlendFunc();
                            m.src != d.src || m.dst != d.dst ? k.setBlendFunc(h.getBlendFunc()) : b._blendFunc.src == d.src && b._blendFunc.dst == d.dst && !k.getTexture().hasPremultipliedAlpha() ? k.setBlendFunc(e) : k.setBlendFunc(b._blendFunc);
                            k.draw(a)
                        }
                        break;
                    case ccs.DISPLAY_TYPE_ARMATURE:
                        k.draw(a);
                        break;
                    default:
                        k.visit(a)
                }
            } else h instanceof
            cc.Node && (h.setShaderProgram(b._shaderProgram), h.visit(a))
        }
        cc.kmGLPopMatrix()
    });
cc._tmp.WebGLCCNode = function() {
    var a = cc.Node.prototype;
    a._transform4x4 = null;
    a._stackMatrix = null;
    a._glServerState = null;
    a._camera = null;
    a.ctor = function() {
        this._initNode();
        var a = new cc.kmMat4;
        a.mat[2] = a.mat[3] = a.mat[6] = a.mat[7] = a.mat[8] = a.mat[9] = a.mat[11] = a.mat[14] = 0;
        a.mat[10] = a.mat[15] = 1;
        this._transform4x4 = a;
        this._glServerState = 0;
        this._stackMatrix = new cc.kmMat4;
        this._initRendererCmd()
    };
    a.setNodeDirty = function() {
        !1 === this._transformDirty && (this._setNodeDirtyForCache(), this._renderCmdDiry = this._transformDirty =
            this._inverseDirty = !0, cc.renderer.pushDirtyNode(this))
    };
    a.visit = function() {
        if (this._visible) {
            this._parent && (this._curLevel = this._parent._curLevel + 1);
            var a, c = cc.current_stack;
            c.stack.push(c.top);
            cc.kmMat4Assign(this._stackMatrix, c.top);
            c.top = this._stackMatrix;
            this.transform();
            var d = this._children;
            if (d && 0 < d.length) {
                var e = d.length;
                this.sortAllChildren();
                for (a = 0; a < e; a++)
                    if (d[a] && 0 > d[a]._localZOrder) d[a].visit();
                    else break;
                for (this._rendererCmd && cc.renderer.pushRenderCommand(this._rendererCmd); a < e; a++) d[a] &&
                    d[a].visit()
            } else this._rendererCmd && cc.renderer.pushRenderCommand(this._rendererCmd);
            c.top = c.stack.pop()
        }
    };
    a._transformForRenderer = function(a) {
        var c = this._transform4x4,
            d = this._stackMatrix;
        a = a || (this._parent ? this._parent._stackMatrix : cc.current_stack.top);
        var e = this.nodeToParentTransform(),
            f = c.mat;
        f[0] = e.a;
        f[4] = e.c;
        f[12] = e.tx;
        f[1] = e.b;
        f[5] = e.d;
        f[13] = e.ty;
        f[14] = this._vertexZ;
        cc.kmMat4Multiply(d, a, c);
        null != this._camera && !(null != this.grid && this.grid.isActive()) && (c = this._anchorPointInPoints.x, a = this._anchorPointInPoints.y,
            0 !== c || 0 !== a ? (cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (c |= 0, a |= 0), e = new cc.kmMat4, cc.kmMat4Translation(e, c, a, 0), cc.kmMat4Multiply(d, d, e), this._camera._locateForRenderer(d), cc.kmMat4Translation(e, -c, -a, 0), cc.kmMat4Multiply(d, d, e)) : this._camera._locateForRenderer(d));
        this._renderCmdDiry = !1;
        if (this._children && 0 !== this._children.length) {
            e = this._children;
            c = 0;
            for (a = e.length; c < a; c++) e[c]._transformForRenderer(d)
        }
    };
    a.transform = function() {
        var a = this._transform4x4,
            c = cc.current_stack.top,
            d = this.nodeToParentTransform(),
            e = a.mat;
        e[0] = d.a;
        e[4] = d.c;
        e[12] = d.tx;
        e[1] = d.b;
        e[5] = d.d;
        e[13] = d.ty;
        e[14] = this._vertexZ;
        cc.kmMat4Multiply(c, c, a);
        null != this._camera && !(null != this.grid && this.grid.isActive()) && (a = this._anchorPointInPoints.x, c = this._anchorPointInPoints.y, 0 !== a || 0 !== c ? (cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (a |= 0, c |= 0), cc.kmGLTranslatef(a, c, 0), this._camera.locate(), cc.kmGLTranslatef(-a, -c, 0)) : this._camera.locate())
    };
    a.getNodeToParentTransform = a._getNodeToParentTransformForWebGL
};
cc._tmp.PrototypeCCNode = function() {
    var a = cc.Node.prototype;
    cc.defineGetterSetter(a, "x", a.getPositionX, a.setPositionX);
    cc.defineGetterSetter(a, "y", a.getPositionY, a.setPositionY);
    cc.defineGetterSetter(a, "width", a._getWidth, a._setWidth);
    cc.defineGetterSetter(a, "height", a._getHeight, a._setHeight);
    cc.defineGetterSetter(a, "anchorX", a._getAnchorX, a._setAnchorX);
    cc.defineGetterSetter(a, "anchorY", a._getAnchorY, a._setAnchorY);
    cc.defineGetterSetter(a, "skewX", a.getSkewX, a.setSkewX);
    cc.defineGetterSetter(a, "skewY",
        a.getSkewY, a.setSkewY);
    cc.defineGetterSetter(a, "zIndex", a.getLocalZOrder, a.setLocalZOrder);
    cc.defineGetterSetter(a, "vertexZ", a.getVertexZ, a.setVertexZ);
    cc.defineGetterSetter(a, "rotation", a.getRotation, a.setRotation);
    cc.defineGetterSetter(a, "rotationX", a.getRotationX, a.setRotationX);
    cc.defineGetterSetter(a, "rotationY", a.getRotationY, a.setRotationY);
    cc.defineGetterSetter(a, "scale", a.getScale, a.setScale);
    cc.defineGetterSetter(a, "scaleX", a.getScaleX, a.setScaleX);
    cc.defineGetterSetter(a, "scaleY", a.getScaleY,
        a.setScaleY);
    cc.defineGetterSetter(a, "children", a.getChildren);
    cc.defineGetterSetter(a, "childrenCount", a.getChildrenCount);
    cc.defineGetterSetter(a, "parent", a.getParent, a.setParent);
    cc.defineGetterSetter(a, "visible", a.isVisible, a.setVisible);
    cc.defineGetterSetter(a, "running", a.isRunning);
    cc.defineGetterSetter(a, "ignoreAnchor", a.isIgnoreAnchorPointForPosition, a.ignoreAnchorPointForPosition);
    cc.defineGetterSetter(a, "actionManager", a.getActionManager, a.setActionManager);
    cc.defineGetterSetter(a, "scheduler",
        a.getScheduler, a.setScheduler);
    cc.defineGetterSetter(a, "shaderProgram", a.getShaderProgram, a.setShaderProgram);
    cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity);
    cc.defineGetterSetter(a, "opacityModifyRGB", a.isOpacityModifyRGB);
    cc.defineGetterSetter(a, "cascadeOpacity", a.isCascadeOpacityEnabled, a.setCascadeOpacityEnabled);
    cc.defineGetterSetter(a, "color", a.getColor, a.setColor);
    cc.defineGetterSetter(a, "cascadeColor", a.isCascadeColorEnabled, a.setCascadeColorEnabled)
};
cc.NODE_TAG_INVALID = -1;
cc.s_globalOrderOfArrival = 1;
cc.Node = cc.Class.extend({
    _localZOrder: 0,
    _globalZOrder: 0,
    _vertexZ: 0,
    _rotationX: 0,
    _rotationY: 0,
    _scaleX: 1,
    _scaleY: 1,
    _position: null,
    _normalizedPosition: null,
    _usingNormalizedPosition: !1,
    _normalizedPositionDirty: !1,
    _skewX: 0,
    _skewY: 0,
    _children: null,
    _visible: !0,
    _anchorPoint: null,
    _anchorPointInPoints: null,
    _contentSize: null,
    _running: !1,
    _parent: null,
    _ignoreAnchorPointForPosition: !1,
    tag: cc.NODE_TAG_INVALID,
    userData: null,
    userObject: null,
    _transformDirty: !0,
    _inverseDirty: !0,
    _cacheDirty: !1,
    _cachedParent: null,
    _transformGLDirty: null,
    _transform: null,
    _transformWorld: null,
    _inverse: null,
    _reorderChildDirty: !1,
    _shaderProgram: null,
    arrivalOrder: 0,
    _actionManager: null,
    _scheduler: null,
    _eventDispatcher: null,
    _initializedNode: !1,
    _additionalTransformDirty: !1,
    _additionalTransform: null,
    _componentContainer: null,
    _isTransitionFinished: !1,
    _rotationRadiansX: 0,
    _rotationRadiansY: 0,
    _className: "Node",
    _showNode: !1,
    _name: "",
    _displayedOpacity: 255,
    _realOpacity: 255,
    _displayedColor: null,
    _realColor: null,
    _cascadeColorEnabled: !1,
    _cascadeOpacityEnabled: !1,
    _hashOfName: 0,
    _curLevel: -1,
    _rendererCmd: null,
    _renderCmdDirty: !1,
    _initNode: function() {
        this._anchorPoint = cc.p(0, 0);
        this._anchorPointInPoints = cc.p(0, 0);
        this._contentSize = cc.size(0, 0);
        this._position = cc.p(0, 0);
        this._normalizedPosition = cc.p(0, 0);
        this._children = [];
        this._transform = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            tx: 0,
            ty: 0
        };
        this._transformWorld = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            tx: 0,
            ty: 0
        };
        var a = cc.director;
        this._actionManager = a.getActionManager();
        this._scheduler = a.getScheduler();
        this._initializedNode = !0;
        this._additionalTransform = cc.affineTransformMakeIdentity();
        cc.ComponentContainer && (this._componentContainer = new cc.ComponentContainer(this));
        this._realOpacity = this._displayedOpacity = 255;
        this._displayedColor = cc.color(255, 255, 255, 255);
        this._realColor = cc.color(255, 255, 255, 255);
        this._cascadeOpacityEnabled = this._cascadeColorEnabled = !1
    },
    init: function() {
        !1 === this._initializedNode && this._initNode();
        return !0
    },
    _arrayMakeObjectsPerformSelector: function(a, b) {
        if (a && 0 !== a.length) {
            var c, d = a.length,
                e;
            c = cc.Node._StateCallbackType;
            switch (b) {
                case c.onEnter:
                    for (c = 0; c < d; c++)
                        if (e =
                            a[c]) e.onEnter();
                    break;
                case c.onExit:
                    for (c = 0; c < d; c++)
                        if (e = a[c]) e.onExit();
                    break;
                case c.onEnterTransitionDidFinish:
                    for (c = 0; c < d; c++)
                        if (e = a[c]) e.onEnterTransitionDidFinish();
                    break;
                case c.cleanup:
                    for (c = 0; c < d; c++)(e = a[c]) && e.cleanup();
                    break;
                case c.updateTransform:
                    for (c = 0; c < d; c++)(e = a[c]) && e.updateTransform();
                    break;
                case c.onExitTransitionDidStart:
                    for (c = 0; c < d; c++)
                        if (e = a[c]) e.onExitTransitionDidStart();
                    break;
                case c.sortAllChildren:
                    for (c = 0; c < d; c++)(e = a[c]) && e.sortAllChildren();
                    break;
                default:
                    cc.assert(0, cc._LogInfos.Node__arrayMakeObjectsPerformSelector)
            }
        }
    },
    setNodeDirty: null,
    attr: function(a) {
        for (var b in a) this[b] = a[b]
    },
    getSkewX: function() {
        return this._skewX
    },
    setSkewX: function(a) {
        this._skewX = a;
        this.setNodeDirty()
    },
    getSkewY: function() {
        return this._skewY
    },
    setSkewY: function(a) {
        this._skewY = a;
        this.setNodeDirty()
    },
    setLocalZOrder: function(a) {
        this._localZOrder = a;
        this._parent && this._parent.reorderChild(this, a);
        cc.eventManager._setDirtyForNode(this)
    },
    _setLocalZOrder: function(a) {
        this._localZOrder = a
    },
    getLocalZOrder: function() {
        return this._localZOrder
    },
    getZOrder: function() {
        cc.log(cc._LogInfos.Node_getZOrder);
        return this.getLocalZOrder()
    },
    setZOrder: function(a) {
        cc.log(cc._LogInfos.Node_setZOrder);
        this.setLocalZOrder(a)
    },
    setGlobalZOrder: function(a) {
        this._globalZOrder != a && (this._globalZOrder = a, cc.eventManager._setDirtyForNode(this))
    },
    getGlobalZOrder: function() {
        return this._globalZOrder
    },
    getVertexZ: function() {
        return this._vertexZ
    },
    setVertexZ: function(a) {
        this._vertexZ = a
    },
    getRotation: function() {
        this._rotationX !== this._rotationY && cc.log(cc._LogInfos.Node_getRotation);
        return this._rotationX
    },
    setRotation: function(a) {
        this._rotationX =
            this._rotationY = a;
        this._rotationRadiansX = 0.017453292519943295 * this._rotationX;
        this._rotationRadiansY = 0.017453292519943295 * this._rotationY;
        this.setNodeDirty()
    },
    getRotationX: function() {
        return this._rotationX
    },
    setRotationX: function(a) {
        this._rotationX = a;
        this._rotationRadiansX = 0.017453292519943295 * this._rotationX;
        this.setNodeDirty()
    },
    getRotationY: function() {
        return this._rotationY
    },
    setRotationY: function(a) {
        this._rotationY = a;
        this._rotationRadiansY = 0.017453292519943295 * this._rotationY;
        this.setNodeDirty()
    },
    getScale: function() {
        this._scaleX !== this._scaleY && cc.log(cc._LogInfos.Node_getScale);
        return this._scaleX
    },
    setScale: function(a, b) {
        this._scaleX = a;
        this._scaleY = b || 0 === b ? b : a;
        this.setNodeDirty()
    },
    getScaleX: function() {
        return this._scaleX
    },
    setScaleX: function(a) {
        this._scaleX = a;
        this.setNodeDirty()
    },
    getScaleY: function() {
        return this._scaleY
    },
    setScaleY: function(a) {
        this._scaleY = a;
        this.setNodeDirty()
    },
    setPosition: function(a, b) {
        var c = this._position;
        void 0 === b ? (c.x = a.x, c.y = a.y) : (c.x = a, c.y = b);
        this.setNodeDirty();
        this._usingNormalizedPosition = !1
    },
    setNormalizedPosition: function(a, b) {
        var c = this._normalizedPosition;
        void 0 === b ? (c.x = a.x, c.y = a.y) : (c.x = a, c.y = b);
        this.setNodeDirty();
        this._normalizedPositionDirty = this._usingNormalizedPosition = !0
    },
    getPosition: function() {
        return cc.p(this._position)
    },
    getNormalizedPosition: function() {
        return cc.p(this._normalizedPosition)
    },
    getPositionX: function() {
        return this._position.x
    },
    setPositionX: function(a) {
        this._position.x = a;
        this.setNodeDirty()
    },
    getPositionY: function() {
        return this._position.y
    },
    setPositionY: function(a) {
        this._position.y =
            a;
        this.setNodeDirty()
    },
    getChildrenCount: function() {
        return this._children.length
    },
    getChildren: function() {
        return this._children
    },
    isVisible: function() {
        return this._visible
    },
    setVisible: function(a) {
        this._visible != a && ((this._visible = a) && this.setNodeDirty(), cc.renderer.childrenOrderDirty = !0)
    },
    getAnchorPoint: function() {
        return cc.p(this._anchorPoint)
    },
    setAnchorPoint: function(a, b) {
        var c = this._anchorPoint;
        if (void 0 === b) {
            if (a.x === c.x && a.y === c.y) return;
            c.x = a.x;
            c.y = a.y
        } else {
            if (a === c.x && b === c.y) return;
            c.x = a;
            c.y =
                b
        }
        var d = this._anchorPointInPoints,
            e = this._contentSize;
        d.x = e.width * c.x;
        d.y = e.height * c.y;
        this.setNodeDirty()
    },
    _getAnchor: function() {
        return this._anchorPoint
    },
    _setAnchor: function(a) {
        var b = a.x;
        a = a.y;
        this._anchorPoint.x !== b && (this._anchorPoint.x = b, this._anchorPointInPoints.x = this._contentSize.width * b);
        this._anchorPoint.y !== a && (this._anchorPoint.y = a, this._anchorPointInPoints.y = this._contentSize.height * a);
        this.setNodeDirty()
    },
    _getAnchorX: function() {
        return this._anchorPoint.x
    },
    _setAnchorX: function(a) {
        this._anchorPoint.x !==
            a && (this._anchorPoint.x = a, this._anchorPointInPoints.x = this._contentSize.width * a, this.setNodeDirty())
    },
    _getAnchorY: function() {
        return this._anchorPoint.y
    },
    _setAnchorY: function(a) {
        this._anchorPoint.y !== a && (this._anchorPoint.y = a, this._anchorPointInPoints.y = this._contentSize.height * a, this.setNodeDirty())
    },
    getAnchorPointInPoints: function() {
        return cc.p(this._anchorPointInPoints)
    },
    _getWidth: function() {
        return this._contentSize.width
    },
    _setWidth: function(a) {
        this._contentSize.width = a;
        this._anchorPointInPoints.x =
            a * this._anchorPoint.x;
        this.setNodeDirty()
    },
    _getHeight: function() {
        return this._contentSize.height
    },
    _setHeight: function(a) {
        this._contentSize.height = a;
        this._anchorPointInPoints.y = a * this._anchorPoint.y;
        this.setNodeDirty()
    },
    getContentSize: function() {
        return cc.size(this._contentSize)
    },
    setContentSize: function(a, b) {
        var c = this._contentSize;
        if (void 0 === b) {
            if (a.width === c.width && a.height === c.height) return;
            c.width = a.width;
            c.height = a.height
        } else {
            if (a === c.width && b === c.height) return;
            c.width = a;
            c.height = b
        }
        var d = this._anchorPointInPoints,
            e = this._anchorPoint;
        d.x = c.width * e.x;
        d.y = c.height * e.y;
        this.setNodeDirty()
    },
    isRunning: function() {
        return this._running
    },
    getParent: function() {
        return this._parent
    },
    setParent: function(a) {
        this._parent = a
    },
    isIgnoreAnchorPointForPosition: function() {
        return this._ignoreAnchorPointForPosition
    },
    ignoreAnchorPointForPosition: function(a) {
        a != this._ignoreAnchorPointForPosition && (this._ignoreAnchorPointForPosition = a, this.setNodeDirty())
    },
    getTag: function() {
        return this.tag
    },
    setTag: function(a) {
        this.tag = a
    },
    setName: function(a) {
        this._name =
            a
    },
    getName: function() {
        return this._name
    },
    getUserData: function() {
        return this.userData
    },
    setUserData: function(a) {
        this.userData = a
    },
    getUserObject: function() {
        return this.userObject
    },
    setUserObject: function(a) {
        this.userObject != a && (this.userObject = a)
    },
    getOrderOfArrival: function() {
        return this.arrivalOrder
    },
    setOrderOfArrival: function(a) {
        this.arrivalOrder = a
    },
    getActionManager: function() {
        this._actionManager || (this._actionManager = cc.director.getActionManager());
        return this._actionManager
    },
    setActionManager: function(a) {
        this._actionManager !=
            a && (this.stopAllActions(), this._actionManager = a)
    },
    getScheduler: function() {
        this._scheduler || (this._scheduler = cc.director.getScheduler());
        return this._scheduler
    },
    setScheduler: function(a) {
        this._scheduler != a && (this.unscheduleAllCallbacks(), this._scheduler = a)
    },
    boundingBox: function() {
        cc.log(cc._LogInfos.Node_boundingBox);
        return this.getBoundingBox()
    },
    getBoundingBox: function() {
        var a = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        return cc._rectApplyAffineTransformIn(a, this.getNodeToParentTransform())
    },
    cleanup: function() {
        this.stopAllActions();
        this.unscheduleAllCallbacks();
        cc.eventManager.removeListeners(this);
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._StateCallbackType.cleanup)
    },
    getChildByTag: function(a) {
        var b = this._children;
        if (null != b)
            for (var c = 0; c < b.length; c++) {
                var d = b[c];
                if (d && d.tag == a) return d
            }
        return null
    },
    getChildByName: function(a) {
        if (!a) return cc.log("Invalid name"), null;
        for (var b = this._children, c = 0, d = b.length; c < d; c++)
            if (b[c]._name == a) return b[c];
        return null
    },
    addChild: function(a,
        b, c) {
        b = void 0 === b ? a._localZOrder : b;
        var d, e = !1;
        cc.isUndefined(c) ? (c = void 0, d = a._name) : cc.isString(c) ? (d = c, c = void 0) : cc.isNumber(c) && (e = !0, d = "");
        cc.assert(a, cc._LogInfos.Node_addChild_3);
        cc.assert(null === a._parent, "child already added. It can't be added again");
        this._addChildHelper(a, b, c, d, e)
    },
    _addChildHelper: function(a, b, c, d, e) {
        this._children || (this._children = []);
        this._insertChild(a, b);
        e ? a.setTag(c) : a.setName(d);
        a.setParent(this);
        a.setOrderOfArrival(cc.s_globalOrderOfArrival++);
        if (this._running && (a.onEnter(),
            this._isTransitionFinished)) a.onEnterTransitionDidFinish();
        this._cascadeColorEnabled && this._enableCascadeColor();
        this._cascadeOpacityEnabled && this._enableCascadeOpacity()
    },
    removeFromParent: function(a) {
        this._parent && (null == a && (a = !0), this._parent.removeChild(this, a))
    },
    removeFromParentAndCleanup: function(a) {
        cc.log(cc._LogInfos.Node_removeFromParentAndCleanup);
        this.removeFromParent(a)
    },
    removeChild: function(a, b) {
        0 !== this._children.length && (null == b && (b = !0), -1 < this._children.indexOf(a) && this._detachChild(a,
            b), this.setNodeDirty(), cc.renderer.childrenOrderDirty = !0)
    },
    removeChildByTag: function(a, b) {
        a === cc.NODE_TAG_INVALID && cc.log(cc._LogInfos.Node_removeChildByTag);
        var c = this.getChildByTag(a);
        null == c ? cc.log(cc._LogInfos.Node_removeChildByTag_2, a) : this.removeChild(c, b)
    },
    removeAllChildrenWithCleanup: function(a) {
        this.removeAllChildren(a)
    },
    removeAllChildren: function(a) {
        var b = this._children;
        if (null != b) {
            null == a && (a = !0);
            for (var c = 0; c < b.length; c++) {
                var d = b[c];
                d && (this._running && (d.onExitTransitionDidStart(), d.onExit()),
                    a && d.cleanup(), d.parent = null)
            }
            this._children.length = 0
        }
    },
    _detachChild: function(a, b) {
        this._running && (a.onExitTransitionDidStart(), a.onExit());
        b && a.cleanup();
        a.parent = null;
        a._cachedParent = null;
        cc.arrayRemoveObject(this._children, a)
    },
    _insertChild: function(a, b) {
        cc.renderer.childrenOrderDirty = this._reorderChildDirty = !0;
        this._children.push(a);
        a._setLocalZOrder(b)
    },
    reorderChild: function(a, b) {
        cc.assert(a, cc._LogInfos.Node_reorderChild);
        cc.renderer.childrenOrderDirty = this._reorderChildDirty = !0;
        a.arrivalOrder =
            cc.s_globalOrderOfArrival;
        cc.s_globalOrderOfArrival++;
        a._setLocalZOrder(b);
        this.setNodeDirty()
    },
    sortAllChildren: function() {
        if (this._reorderChildDirty) {
            var a = this._children,
                b = a.length,
                c, d, e;
            for (c = 1; c < b; c++) {
                e = a[c];
                for (d = c - 1; 0 <= d;) {
                    if (e._localZOrder < a[d]._localZOrder) a[d + 1] = a[d];
                    else if (e._localZOrder === a[d]._localZOrder && e.arrivalOrder < a[d].arrivalOrder) a[d + 1] = a[d];
                    else break;
                    d--
                }
                a[d + 1] = e
            }
            this._reorderChildDirty = !1
        }
    },
    draw: function(a) {},
    transformAncestors: function() {
        null != this._parent && (this._parent.transformAncestors(),
            this._parent.transform())
    },
    onEnter: function() {
        this._isTransitionFinished = !1;
        this._running = !0;
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._StateCallbackType.onEnter);
        this.resume()
    },
    onEnterTransitionDidFinish: function() {
        this._isTransitionFinished = !0;
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._StateCallbackType.onEnterTransitionDidFinish)
    },
    onExitTransitionDidStart: function() {
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._StateCallbackType.onExitTransitionDidStart)
    },
    onExit: function() {
        this._running = !1;
        this.pause();
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._StateCallbackType.onExit);
        this.removeAllComponents()
    },
    runAction: function(a) {
        cc.assert(a, cc._LogInfos.Node_runAction);
        this.actionManager.addAction(a, this, !this._running);
        return a
    },
    stopAllActions: function() {
        this.actionManager && this.actionManager.removeAllActionsFromTarget(this)
    },
    stopAction: function(a) {
        this.actionManager.removeAction(a)
    },
    stopActionByTag: function(a) {
        a === cc.ACTION_TAG_INVALID ?
            cc.log(cc._LogInfos.Node_stopActionByTag) : this.actionManager.removeActionByTag(a, this)
    },
    getActionByTag: function(a) {
        return a === cc.ACTION_TAG_INVALID ? (cc.log(cc._LogInfos.Node_getActionByTag), null) : this.actionManager.getActionByTag(a, this)
    },
    getNumberOfRunningActions: function() {
        return this.actionManager.numberOfRunningActionsInTarget(this)
    },
    scheduleUpdate: function() {
        this.scheduleUpdateWithPriority(0)
    },
    scheduleUpdateWithPriority: function(a) {
        this.scheduler.scheduleUpdateForTarget(this, a, !this._running)
    },
    unscheduleUpdate: function() {
        this.scheduler.unscheduleUpdateForTarget(this)
    },
    schedule: function(a, b, c, d) {
        b = b || 0;
        cc.assert(a, cc._LogInfos.Node_schedule);
        cc.assert(0 <= b, cc._LogInfos.Node_schedule_2);
        c = null == c ? cc.REPEAT_FOREVER : c;
        this.scheduler.scheduleCallbackForTarget(this, a, b, c, d || 0, !this._running)
    },
    scheduleOnce: function(a, b) {
        this.schedule(a, 0, 0, b)
    },
    unschedule: function(a) {
        a && this.scheduler.unscheduleCallbackForTarget(this, a)
    },
    unscheduleAllCallbacks: function() {
        this.scheduler.unscheduleAllCallbacksForTarget(this)
    },
    resumeSchedulerAndActions: function() {
        cc.log(cc._LogInfos.Node_resumeSchedulerAndActions);
        this.resume()
    },
    resume: function() {
        this.scheduler.resumeTarget(this);
        this.actionManager && this.actionManager.resumeTarget(this);
        cc.eventManager.resumeTarget(this)
    },
    pauseSchedulerAndActions: function() {
        cc.log(cc._LogInfos.Node_pauseSchedulerAndActions);
        this.pause()
    },
    pause: function() {
        this.scheduler.pauseTarget(this);
        this.actionManager && this.actionManager.pauseTarget(this);
        cc.eventManager.pauseTarget(this)
    },
    setAdditionalTransform: function(a) {
        this._additionalTransform =
            a;
        this._additionalTransformDirty = this._transformDirty = !0
    },
    getParentToNodeTransform: function() {
        this._inverseDirty && (this._inverse = cc.affineTransformInvert(this.getNodeToParentTransform()), this._inverseDirty = !1);
        return this._inverse
    },
    parentToNodeTransform: function() {
        return this.getParentToNodeTransform()
    },
    getNodeToWorldTransform: function() {
        for (var a = this.getNodeToParentTransform(), b = this._parent; null != b; b = b.parent) a = cc.affineTransformConcat(a, b.getNodeToParentTransform());
        return a
    },
    nodeToWorldTransform: function() {
        return this.getNodeToWorldTransform()
    },
    getWorldToNodeTransform: function() {
        return cc.affineTransformInvert(this.getNodeToWorldTransform())
    },
    worldToNodeTransform: function() {
        return this.getWorldToNodeTransform()
    },
    convertToNodeSpace: function(a) {
        return cc.pointApplyAffineTransform(a, this.getWorldToNodeTransform())
    },
    convertToWorldSpace: function(a) {
        a = a || cc.p(0, 0);
        return cc.pointApplyAffineTransform(a, this.getNodeToWorldTransform())
    },
    convertToNodeSpaceAR: function(a) {
        return cc.pSub(this.convertToNodeSpace(a), this._anchorPointInPoints)
    },
    convertToWorldSpaceAR: function(a) {
        a =
            a || cc.p(0, 0);
        a = cc.pAdd(a, this._anchorPointInPoints);
        return this.convertToWorldSpace(a)
    },
    _convertToWindowSpace: function(a) {
        a = this.convertToWorldSpace(a);
        return cc.director.convertToUI(a)
    },
    convertTouchToNodeSpace: function(a) {
        a = a.getLocation();
        return this.convertToNodeSpace(a)
    },
    convertTouchToNodeSpaceAR: function(a) {
        a = a.getLocation();
        a = cc.director.convertToGL(a);
        return this.convertToNodeSpaceAR(a)
    },
    update: function(a) {
        this._componentContainer && !this._componentContainer.isEmpty() && this._componentContainer.visit(a)
    },
    updateTransform: function() {
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._StateCallbackType.updateTransform)
    },
    retain: function() {},
    release: function() {},
    getComponent: function(a) {
        return this._componentContainer ? this._componentContainer.getComponent(a) : null
    },
    addComponent: function(a) {
        this._componentContainer && this._componentContainer.add(a)
    },
    removeComponent: function(a) {
        return this._componentContainer ? this._componentContainer.remove(a) : !1
    },
    removeAllComponents: function() {
        this._componentContainer &&
            this._componentContainer.removeAll()
    },
    grid: null,
    ctor: null,
    visit: null,
    transform: null,
    nodeToParentTransform: function() {
        return this.getNodeToParentTransform()
    },
    getNodeToParentTransform: null,
    _setNodeDirtyForCache: function() {
        if (!1 === this._cacheDirty) {
            this._cacheDirty = !0;
            var a = this._cachedParent;
            a && a != this && a._setNodeDirtyForCache()
        }
    },
    _setCachedParent: function(a) {
        if (this._cachedParent != a) {
            this._cachedParent = a;
            for (var b = this._children, c = 0, d = b.length; c < d; c++) b[c]._setCachedParent(a)
        }
    },
    getCamera: function() {
        this._camera ||
            (this._camera = new cc.Camera);
        return this._camera
    },
    getGrid: function() {
        return this.grid
    },
    setGrid: function(a) {
        this.grid = a
    },
    getShaderProgram: function() {
        return this._shaderProgram
    },
    setShaderProgram: function(a) {
        this._shaderProgram = a
    },
    getGLServerState: function() {
        return this._glServerState
    },
    setGLServerState: function(a) {
        this._glServerState = a
    },
    getBoundingBoxToWorld: function() {
        var a = cc.rect(0, 0, this._contentSize.width, this._contentSize.height),
            b = this.getNodeToWorldTransform(),
            a = cc.rectApplyAffineTransform(a,
                this.getNodeToWorldTransform());
        if (!this._children) return a;
        for (var c = this._children, d = 0; d < c.length; d++) {
            var e = c[d];
            e && e._visible && (e = e._getBoundingBoxToCurrentNode(b)) && (a = cc.rectUnion(a, e))
        }
        return a
    },
    _getBoundingBoxToCurrentNode: function(a) {
        var b = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        a = null == a ? this.getNodeToParentTransform() : cc.affineTransformConcat(this.getNodeToParentTransform(), a);
        b = cc.rectApplyAffineTransform(b, a);
        if (!this._children) return b;
        for (var c = this._children,
            d = 0; d < c.length; d++) {
            var e = c[d];
            e && e._visible && (e = e._getBoundingBoxToCurrentNode(a)) && (b = cc.rectUnion(b, e))
        }
        return b
    },
    _getNodeToParentTransformForWebGL: function() {
        if (this._usingNormalizedPosition && this._parent) {
            var a = this._parent._contentSize;
            this._position.x = this._normalizedPosition.x * a.width;
            this._position.y = this._normalizedPosition.y * a.height;
            this._normalizedPositionDirty = !1
        }
        if (this._transformDirty) {
            var a = this._position.x,
                b = this._position.y,
                c = this._anchorPointInPoints.x,
                d = -c,
                e = this._anchorPointInPoints.y,
                f = -e,
                g = this._scaleX,
                h = this._scaleY;
            this._ignoreAnchorPointForPosition && (a += c, b += e);
            var k = 1,
                m = 0,
                n = 1,
                q = 0;
            if (0 !== this._rotationX || 0 !== this._rotationY) k = Math.cos(-this._rotationRadiansX), m = Math.sin(-this._rotationRadiansX), n = Math.cos(-this._rotationRadiansY), q = Math.sin(-this._rotationRadiansY);
            var r = this._skewX || this._skewY;
            if (!r && (0 !== c || 0 !== e)) a += n * d * g + -m * f * h, b += q * d * g + k * f * h;
            var s = this._transform;
            s.a = n * g;
            s.b = q * g;
            s.c = -m * h;
            s.d = k * h;
            s.tx = a;
            s.ty = b;
            if (r && (s = cc.affineTransformConcat({
                a: 1,
                b: Math.tan(cc.degreesToRadians(this._skewY)),
                c: Math.tan(cc.degreesToRadians(this._skewX)),
                d: 1,
                tx: 0,
                ty: 0
            }, s), 0 !== c || 0 !== e)) s = cc.affineTransformTranslate(s, d, f);
            this._additionalTransformDirty && (s = cc.affineTransformConcat(s, this._additionalTransform), this._additionalTransformDirty = !1);
            this._transform = s;
            this._transformDirty = !1
        }
        return this._transform
    },
    _updateColor: function() {},
    getOpacity: function() {
        return this._realOpacity
    },
    getDisplayedOpacity: function() {
        return this._displayedOpacity
    },
    setOpacity: function(a) {
        this._displayedOpacity = this._realOpacity =
            a;
        var b = 255,
            c = this._parent;
        c && c.cascadeOpacity && (b = c.getDisplayedOpacity());
        this.updateDisplayedOpacity(b);
        this._displayedColor.a = this._realColor.a = a
    },
    updateDisplayedOpacity: function(a) {
        this._displayedOpacity = this._realOpacity * a / 255;
        this._rendererCmd && void 0 !== this._rendererCmd._opacity && (this._rendererCmd._opacity = this._displayedOpacity / 255);
        if (this._cascadeOpacityEnabled) {
            a = this._children;
            for (var b = 0; b < a.length; b++) {
                var c = a[b];
                c && c.updateDisplayedOpacity(this._displayedOpacity)
            }
        }
    },
    isCascadeOpacityEnabled: function() {
        return this._cascadeOpacityEnabled
    },
    setCascadeOpacityEnabled: function(a) {
        this._cascadeOpacityEnabled !== a && ((this._cascadeOpacityEnabled = a) ? this._enableCascadeOpacity() : this._disableCascadeOpacity())
    },
    _enableCascadeOpacity: function() {
        var a = 255,
            b = this._parent;
        b && b.cascadeOpacity && (a = b.getDisplayedOpacity());
        this.updateDisplayedOpacity(a)
    },
    _disableCascadeOpacity: function() {
        this._displayedOpacity = this._realOpacity;
        for (var a = this._children, b = 0; b < a.length; b++) {
            var c = a[b];
            c && c.updateDisplayedOpacity(255)
        }
    },
    getColor: function() {
        var a = this._realColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    getDisplayedColor: function() {
        var a = this._displayedColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    setColor: function(a) {
        var b = this._displayedColor,
            c = this._realColor;
        b.r = c.r = a.r;
        b.g = c.g = a.g;
        b.b = c.b = a.b;
        a = (a = this._parent) && a.cascadeColor ? a.getDisplayedColor() : cc.color.WHITE;
        this.updateDisplayedColor(a)
    },
    updateDisplayedColor: function(a) {
        var b = this._displayedColor,
            c = this._realColor;
        b.r = 0 | c.r * a.r / 255;
        b.g = 0 | c.g * a.g / 255;
        b.b = 0 | c.b * a.b / 255;
        if (this._cascadeColorEnabled) {
            a = this._children;
            for (c = 0; c < a.length; c++) {
                var d = a[c];
                d && d.updateDisplayedColor(b)
            }
        }
    },
    isCascadeColorEnabled: function() {
        return this._cascadeColorEnabled
    },
    setCascadeColorEnabled: function(a) {
        this._cascadeColorEnabled !== a && ((this._cascadeColorEnabled = a) ? this._enableCascadeColor() : this._disableCascadeColor())
    },
    _enableCascadeColor: function() {
        var a;
        a = (a = this._parent) && a.cascadeColor ? a.getDisplayedColor() : cc.color.WHITE;
        this.updateDisplayedColor(a)
    },
    _disableCascadeColor: function() {
        var a = this._displayedColor,
            b = this._realColor;
        a.r = b.r;
        a.g = b.g;
        a.b = b.b;
        for (var a = this._children, b = cc.color.WHITE, c = 0; c < a.length; c++) {
            var d = a[c];
            d && d.updateDisplayedColor(b)
        }
    },
    setOpacityModifyRGB: function(a) {},
    isOpacityModifyRGB: function() {
        return !1
    },
    _initRendererCmd: function() {},
    _transformForRenderer: null
});
cc.Node.create = function() {
    return new cc.Node
};
cc.Node._StateCallbackType = {
    onEnter: 1,
    onExit: 2,
    cleanup: 3,
    onEnterTransitionDidFinish: 4,
    updateTransform: 5,
    onExitTransitionDidStart: 6,
    sortAllChildren: 7
};
cc._renderType === cc._RENDER_TYPE_CANVAS ? (_p = cc.Node.prototype, _p.ctor = function() {
    this._initNode();
    this._initRendererCmd()
}, _p.setNodeDirty = function() {
    !1 === this._transformDirty && (this._setNodeDirtyForCache(), this._renderCmdDiry = this._transformDirty = this._inverseDirty = !0, cc.renderer.pushDirtyNode(this))
}, _p.visit = function(a) {
    if (this._visible) {
        this._parent && (this._curLevel = this._parent._curLevel + 1);
        var b = this._children,
            c;
        this.transform();
        var d = b.length;
        if (0 < d) {
            this.sortAllChildren();
            for (a = 0; a < d; a++)
                if (c =
                    b[a], 0 > c._localZOrder) c.visit();
                else break;
            for (this._rendererCmd && cc.renderer.pushRenderCommand(this._rendererCmd); a < d; a++) b[a].visit()
        } else this._rendererCmd && cc.renderer.pushRenderCommand(this._rendererCmd);
        this._cacheDirty = !1
    }
}, _p._transformForRenderer = function() {
    var a = this.nodeToParentTransform(),
        b = this._transformWorld;
    if (this._parent) {
        var c = this._parent._transformWorld;
        b.a = a.a * c.a + a.b * c.c;
        b.b = a.a * c.b + a.b * c.d;
        b.c = a.c * c.a + a.d * c.c;
        b.d = a.c * c.b + a.d * c.d;
        if (!this._skewX || this._skewY) {
            var d = this._parent._transform,
                e = -(d.b + d.c) * a.tx;
            b.tx = a.tx * c.a + a.ty * c.c + c.tx + -(d.b + d.c) * a.ty;
            b.ty = a.tx * c.b + a.ty * c.d + c.ty + e
        } else b.tx = a.tx * c.a + a.ty * c.c + c.tx, b.ty = a.tx * c.b + a.ty * c.d + c.ty
    } else b.a = a.a, b.b = a.b, b.c = a.c, b.d = a.d, b.tx = a.tx, b.ty = a.ty;
    this._renderCmdDiry = !1;
    if (this._children && 0 !== this._children.length) {
        c = this._children;
        a = 0;
        for (b = c.length; a < b; a++) c[a]._transformForRenderer()
    }
}, _p.transform = function(a) {
    a = this.getNodeToParentTransform();
    var b = this._transformWorld;
    if (this._parent) {
        var c = this._parent._transformWorld;
        b.a = a.a * c.a +
            a.b * c.c;
        b.b = a.a * c.b + a.b * c.d;
        b.c = a.c * c.a + a.d * c.c;
        b.d = a.c * c.b + a.d * c.d;
        var d = this._parent._transform,
            e = -(d.b + d.c) * a.tx;
        b.tx = a.tx * c.a + a.ty * c.c + c.tx + -(d.b + d.c) * a.ty;
        b.ty = a.tx * c.b + a.ty * c.d + c.ty + e
    } else b.a = a.a, b.b = a.b, b.c = a.c, b.d = a.d, b.tx = a.tx, b.ty = a.ty
}, _p.getNodeToParentTransform = function() {
    if (this._usingNormalizedPosition && this._parent) {
        var a = this._parent._contentSize;
        this._position.x = this._normalizedPosition.x * a.width;
        this._position.y = this._normalizedPosition.y * a.height;
        this._normalizedPositionDirty = !1
    }
    if (this._transformDirty) {
        a = this._transform;
        a.tx = this._position.x;
        a.ty = this._position.y;
        var b = 1,
            c = 0;
        this._rotationX && (b = Math.cos(this._rotationRadiansX), c = Math.sin(this._rotationRadiansX));
        a.a = a.d = b;
        a.b = -c;
        a.c = c;
        var d = this._scaleX,
            e = this._scaleY,
            f = this._anchorPointInPoints.x,
            g = this._anchorPointInPoints.y,
            h = 1E-6 > d && -1E-6 < d ? 1E-6 : d,
            k = 1E-6 > e && -1E-6 < e ? 1E-6 : e;
        if (this._skewX || this._skewY) {
            var m = Math.tan(-this._skewX * Math.PI / 180),
                n = Math.tan(-this._skewY * Math.PI / 180);
            Infinity === m && (m = 99999999);
            Infinity ===
                n && (n = 99999999);
            var q = g * m * h,
                r = f * n * k;
            a.a = b + -c * n;
            a.b = b * m + -c;
            a.c = c + b * n;
            a.d = c * m + b;
            a.tx += b * q + -c * r;
            a.ty += c * q + b * r
        }
        if (1 !== d || 1 !== e) a.a *= h, a.c *= h, a.b *= k, a.d *= k;
        a.tx += b * -f * h + -c * g * k;
        a.ty -= c * -f * h + b * g * k;
        this._ignoreAnchorPointForPosition && (a.tx += f, a.ty += g);
        this._additionalTransformDirty && (this._transform = cc.affineTransformConcat(a, this._additionalTransform), this._additionalTransformDirty = !1);
        this._transformDirty = !1
    }
    return this._transform
}, _p = null) : (cc.assert(cc.isFunction(cc._tmp.WebGLCCNode), cc._LogInfos.MissingFile,
    "BaseNodesWebGL.js"), cc._tmp.WebGLCCNode(), delete cc._tmp.WebGLCCNode);
cc.assert(cc.isFunction(cc._tmp.PrototypeCCNode), cc._LogInfos.MissingFile, "BaseNodesPropertyDefine.js");
cc._tmp.PrototypeCCNode();
delete cc._tmp.PrototypeCCNode;
cc.AtlasNode = cc.Node.extend({
    textureAtlas: null,
    quadsToDraw: 0,
    _itemsPerRow: 0,
    _itemsPerColumn: 0,
    _itemWidth: 0,
    _itemHeight: 0,
    _colorUnmodified: null,
    _opacityModifyRGB: !1,
    _blendFunc: null,
    _ignoreContentScaleFactor: !1,
    _className: "AtlasNode",
    ctor: function(a, b, c, d) {
        cc.Node.prototype.ctor.call(this);
        this._colorUnmodified = cc.color.WHITE;
        this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        };
        this._ignoreContentScaleFactor = !1;
        void 0 !== d && this.initWithTileFile(a, b, c, d)
    },
    _initRendererCmd: function() {
        cc._renderType ===
            cc._RENDER_TYPE_WEBGL && (this._rendererCmd = new cc.AtlasNodeRenderCmdWebGL(this))
    },
    updateAtlasValues: function() {
        cc.log(cc._LogInfos.AtlasNode_updateAtlasValues)
    },
    getColor: function() {
        return this._opacityModifyRGB ? this._colorUnmodified : cc.Node.prototype.getColor.call(this)
    },
    setOpacityModifyRGB: function(a) {
        var b = this.color;
        this._opacityModifyRGB = a;
        this.color = b
    },
    isOpacityModifyRGB: function() {
        return this._opacityModifyRGB
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    setBlendFunc: function(a, b) {
        this._blendFunc =
            void 0 === b ? a : {
                src: a,
                dst: b
            }
    },
    setTextureAtlas: function(a) {
        this.textureAtlas = a
    },
    getTextureAtlas: function() {
        return this.textureAtlas
    },
    getQuadsToDraw: function() {
        return this.quadsToDraw
    },
    setQuadsToDraw: function(a) {
        this.quadsToDraw = a
    },
    _textureForCanvas: null,
    _originalTexture: null,
    _uniformColor: null,
    _colorF32Array: null,
    initWithTileFile: function(a, b, c, d) {
        if (!a) throw "cc.AtlasNode.initWithTileFile(): title should not be null";
        a = cc.textureCache.addImage(a);
        return this.initWithTexture(a, b, c, d)
    },
    initWithTexture: null,
    _initWithTextureForCanvas: function(a, b, c, d) {
        this._itemWidth = b;
        this._itemHeight = c;
        this._opacityModifyRGB = !0;
        this._originalTexture = a;
        if (!this._originalTexture) return cc.log(cc._LogInfos.AtlasNode__initWithTexture), !1;
        this._textureForCanvas = this._originalTexture;
        this._calculateMaxItems();
        this.quadsToDraw = d;
        return !0
    },
    _initWithTextureForWebGL: function(a, b, c, d) {
        this._itemWidth = b;
        this._itemHeight = c;
        this._colorUnmodified = cc.color.WHITE;
        this._opacityModifyRGB = !0;
        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst =
            cc.BLEND_DST;
        b = this._realColor;
        this._colorF32Array = new Float32Array([b.r / 255, b.g / 255, b.b / 255, this._realOpacity / 255]);
        this.textureAtlas = new cc.TextureAtlas;
        this.textureAtlas.initWithTexture(a, d);
        if (!this.textureAtlas) return cc.log(cc._LogInfos.AtlasNode__initWithTexture), !1;
        this._updateBlendFunc();
        this._updateOpacityModifyRGB();
        this._calculateMaxItems();
        this.quadsToDraw = d;
        this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE_UCOLOR);
        this._uniformColor = cc._renderContext.getUniformLocation(this.shaderProgram.getProgram(),
            "u_color");
        return !0
    },
    draw: null,
    _drawForWebGL: function(a) {
        a = a || cc._renderContext;
        cc.nodeDrawSetup(this);
        cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst);
        this._uniformColor && this._colorF32Array && (a.uniform4fv(this._uniformColor, this._colorF32Array), this.textureAtlas.drawNumberOfQuads(this.quadsToDraw, 0))
    },
    setColor: null,
    _setColorForCanvas: function(a) {
        var b = this._realColor;
        b.r == a.r && b.g == a.g && b.b == a.b || (b = cc.color(a.r, a.g, a.b), this._colorUnmodified = a, this._opacityModifyRGB && (a = this._displayedOpacity,
            b.r = b.r * a / 255, b.g = b.g * a / 255, b.b = b.b * a / 255), this._changeTextureColor())
    },
    _changeTextureColor: function() {
        var a = this.getTexture();
        if (a && this._originalTexture) {
            var b = this._originalTexture.getHtmlElementObj();
            if (b) {
                var c = a.getHtmlElementObj(),
                    a = cc.rect(0, 0, b.width, b.height);
                c instanceof HTMLCanvasElement ? cc.generateTintImageWithMultiply(b, this._colorUnmodified, a, c) : (c = cc.generateTintImageWithMultiply(b, this._colorUnmodified, a), a = new cc.Texture2D, a.initWithElement(c), a.handleLoadedTexture(), this.setTexture(a))
            }
        }
    },
    _setColorForWebGL: function(a) {
        var b = cc.color(a.r, a.g, a.b);
        this._colorUnmodified = a;
        var c = this._displayedOpacity;
        this._opacityModifyRGB && (b.r = b.r * c / 255, b.g = b.g * c / 255, b.b = b.b * c / 255);
        cc.Node.prototype.setColor.call(this, a);
        a = this._displayedColor;
        this._colorF32Array = new Float32Array([a.r / 255, a.g / 255, a.b / 255, c / 255])
    },
    setOpacity: function(a) {},
    _setOpacityForCanvas: function(a) {
        cc.Node.prototype.setOpacity.call(this, a);
        this._opacityModifyRGB && (this.color = this._colorUnmodified)
    },
    _setOpacityForWebGL: function(a) {
        cc.Node.prototype.setOpacity.call(this,
            a);
        this._opacityModifyRGB ? this.color = this._colorUnmodified : (a = this._displayedColor, this._colorF32Array = new Float32Array([a.r / 255, a.g / 255, a.b / 255, this._displayedOpacity / 255]))
    },
    getTexture: null,
    _getTextureForCanvas: function() {
        return this._textureForCanvas
    },
    _getTextureForWebGL: function() {
        return this.textureAtlas.texture
    },
    setTexture: null,
    _setTextureForCanvas: function(a) {
        this._textureForCanvas = a
    },
    _setTextureForWebGL: function(a) {
        this.textureAtlas.texture = a;
        this._updateBlendFunc();
        this._updateOpacityModifyRGB()
    },
    _calculateMaxItems: null,
    _calculateMaxItemsForCanvas: function() {
        var a = this.texture.getContentSize();
        this._itemsPerColumn = 0 | a.height / this._itemHeight;
        this._itemsPerRow = 0 | a.width / this._itemWidth
    },
    _calculateMaxItemsForWebGL: function() {
        var a = this.texture,
            b = a.getContentSize();
        this._ignoreContentScaleFactor && (b = a.getContentSizeInPixels());
        this._itemsPerColumn = 0 | b.height / this._itemHeight;
        this._itemsPerRow = 0 | b.width / this._itemWidth
    },
    _updateBlendFunc: function() {
        this.textureAtlas.texture.hasPremultipliedAlpha() ||
            (this._blendFunc.src = cc.SRC_ALPHA, this._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA)
    },
    _updateOpacityModifyRGB: function() {
        this._opacityModifyRGB = this.textureAtlas.texture.hasPremultipliedAlpha()
    },
    _setIgnoreContentScaleFactor: function(a) {
        this._ignoreContentScaleFactor = a
    }
});
_p = cc.AtlasNode.prototype;
cc._renderType === cc._RENDER_TYPE_WEBGL ? (_p.initWithTexture = _p._initWithTextureForWebGL, _p.draw = _p._drawForWebGL, _p.setColor = _p._setColorForWebGL, _p.setOpacity = _p._setOpacityForWebGL, _p.getTexture = _p._getTextureForWebGL, _p.setTexture = _p._setTextureForWebGL, _p._calculateMaxItems = _p._calculateMaxItemsForWebGL) : (_p.initWithTexture = _p._initWithTextureForCanvas, _p.draw = cc.Node.prototype.draw, _p.setColor = _p._setColorForCanvas, _p.setOpacity = _p._setOpacityForCanvas, _p.getTexture = _p._getTextureForCanvas, _p.setTexture =
    _p._setTextureForCanvas, _p._calculateMaxItems = _p._calculateMaxItemsForCanvas, cc.sys._supportCanvasNewBlendModes || (_p._changeTextureColor = function() {
        var a, b = this.getTexture();
        if (b && this._originalTexture && (a = b.getHtmlElementObj())) {
            var c = this._originalTexture.getHtmlElementObj();
            if (b = cc.textureCache.getTextureColors(c)) c = cc.rect(0, 0, c.width, c.height), a instanceof HTMLCanvasElement ? cc.generateTintImage(a, b, this._displayedColor, c, a) : (a = cc.generateTintImage(a, b, this._displayedColor, c), b = new cc.Texture2D,
                b.initWithElement(a), b.handleLoadedTexture(), this.setTexture(b))
        }
    }));
cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
cc.defineGetterSetter(_p, "color", _p.getColor, _p.setColor);
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.AtlasNode.create = function(a, b, c, d) {
    return new cc.AtlasNode(a, b, c, d)
};
cc._tmp.WebGLTexture2D = function() {
    cc.Texture2D = cc.Class.extend({
        _pVRHaveAlphaPremultiplied: !0,
        _pixelFormat: null,
        _pixelsWide: 0,
        _pixelsHigh: 0,
        _name: "",
        _contentSize: null,
        maxS: 0,
        maxT: 0,
        _hasPremultipliedAlpha: !1,
        _hasMipmaps: !1,
        shaderProgram: null,
        _isLoaded: !1,
        _htmlElementObj: null,
        _webTextureObj: null,
        url: null,
        ctor: function() {
            this._contentSize = cc.size(0, 0);
            this._pixelFormat = cc.Texture2D.defaultPixelFormat
        },
        releaseTexture: function() {
            this._webTextureObj && cc._renderContext.deleteTexture(this._webTextureObj);
            cc.loader.release(this.url)
        },
        getPixelFormat: function() {
            return this._pixelFormat
        },
        getPixelsWide: function() {
            return this._pixelsWide
        },
        getPixelsHigh: function() {
            return this._pixelsHigh
        },
        getName: function() {
            return this._webTextureObj
        },
        getContentSize: function() {
            return cc.size(this._contentSize.width / cc.contentScaleFactor(), this._contentSize.height / cc.contentScaleFactor())
        },
        _getWidth: function() {
            return this._contentSize.width / cc.contentScaleFactor()
        },
        _getHeight: function() {
            return this._contentSize.height / cc.contentScaleFactor()
        },
        getContentSizeInPixels: function() {
            return this._contentSize
        },
        getMaxS: function() {
            return this.maxS
        },
        setMaxS: function(a) {
            this.maxS = a
        },
        getMaxT: function() {
            return this.maxT
        },
        setMaxT: function(a) {
            this.maxT = a
        },
        getShaderProgram: function() {
            return this.shaderProgram
        },
        setShaderProgram: function(a) {
            this.shaderProgram = a
        },
        hasPremultipliedAlpha: function() {
            return this._hasPremultipliedAlpha
        },
        hasMipmaps: function() {
            return this._hasMipmaps
        },
        description: function() {
            return "\x3ccc.Texture2D | Name \x3d " + this._name + " | Dimensions \x3d " +
                this._pixelsWide + " x " + this._pixelsHigh + " | Coordinates \x3d (" + this.maxS + ", " + this.maxT + ")\x3e"
        },
        releaseData: function(a) {},
        keepData: function(a, b) {
            return a
        },
        initWithData: function(a, b, c, d, e) {
            var f = cc.Texture2D,
                g = cc._renderContext,
                h = g.RGBA,
                k = g.UNSIGNED_BYTE,
                m = c * cc.Texture2D._B[b] / 8;
            0 === m % 8 ? g.pixelStorei(g.UNPACK_ALIGNMENT, 8) : 0 === m % 4 ? g.pixelStorei(g.UNPACK_ALIGNMENT, 4) : 0 === m % 2 ? g.pixelStorei(g.UNPACK_ALIGNMENT, 2) : g.pixelStorei(g.UNPACK_ALIGNMENT, 1);
            this._webTextureObj = g.createTexture();
            cc.glBindTexture2D(this);
            g.texParameteri(g.TEXTURE_2D, g.TEXTURE_MIN_FILTER, g.LINEAR);
            g.texParameteri(g.TEXTURE_2D, g.TEXTURE_MAG_FILTER, g.LINEAR);
            g.texParameteri(g.TEXTURE_2D, g.TEXTURE_WRAP_S, g.CLAMP_TO_EDGE);
            g.texParameteri(g.TEXTURE_2D, g.TEXTURE_WRAP_T, g.CLAMP_TO_EDGE);
            switch (b) {
                case f.PIXEL_FORMAT_RGBA8888:
                    h = g.RGBA;
                    break;
                case f.PIXEL_FORMAT_RGB888:
                    h = g.RGB;
                    break;
                case f.PIXEL_FORMAT_RGBA4444:
                    k = g.UNSIGNED_SHORT_4_4_4_4;
                    break;
                case f.PIXEL_FORMAT_RGB5A1:
                    k = g.UNSIGNED_SHORT_5_5_5_1;
                    break;
                case f.PIXEL_FORMAT_RGB565:
                    k = g.UNSIGNED_SHORT_5_6_5;
                    break;
                case f.PIXEL_FORMAT_AI88:
                    h = g.LUMINANCE_ALPHA;
                    break;
                case f.PIXEL_FORMAT_A8:
                    h = g.ALPHA;
                    break;
                case f.PIXEL_FORMAT_I8:
                    h = g.LUMINANCE;
                    break;
                default:
                    cc.assert(0, cc._LogInfos.Texture2D_initWithData)
            }
            g.texImage2D(g.TEXTURE_2D, 0, h, c, d, 0, h, k, a);
            this._contentSize.width = e.width;
            this._contentSize.height = e.height;
            this._pixelsWide = c;
            this._pixelsHigh = d;
            this._pixelFormat = b;
            this.maxS = e.width / c;
            this.maxT = e.height / d;
            this._hasMipmaps = this._hasPremultipliedAlpha = !1;
            this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE);
            return this._isLoaded = !0
        },
        drawAtPoint: function(a) {
            var b = [0, this.maxT, this.maxS, this.maxT, 0, 0, this.maxS, 0],
                c = this._pixelsWide * this.maxS,
                d = this._pixelsHigh * this.maxT;
            a = [a.x, a.y, 0, c + a.x, a.y, 0, a.x, d + a.y, 0, c + a.x, d + a.y, 0];
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS);
            this._shaderProgram.use();
            this._shaderProgram.setUniformsForBuiltins();
            cc.glBindTexture2D(this);
            c = cc._renderContext;
            c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, c.FLOAT, !1, 0, a);
            c.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS,
                2, c.FLOAT, !1, 0, b);
            c.drawArrays(c.TRIANGLE_STRIP, 0, 4)
        },
        drawInRect: function(a) {
            var b = [0, this.maxT, this.maxS, this.maxT, 0, 0, this.maxS, 0];
            a = [a.x, a.y, a.x + a.width, a.y, a.x, a.y + a.height, a.x + a.width, a.y + a.height];
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS);
            this._shaderProgram.use();
            this._shaderProgram.setUniformsForBuiltins();
            cc.glBindTexture2D(this);
            var c = cc._renderContext;
            c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, c.FLOAT, !1, 0, a);
            c.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS,
                2, c.FLOAT, !1, 0, b);
            c.drawArrays(c.TRIANGLE_STRIP, 0, 4)
        },
        initWithImage: function(a) {
            if (null == a) return cc.log(cc._LogInfos.Texture2D_initWithImage), !1;
            var b = a.getWidth(),
                c = a.getHeight(),
                d = cc.configuration.getMaxTextureSize();
            if (b > d || c > d) return cc.log(cc._LogInfos.Texture2D_initWithImage_2, b, c, d, d), !1;
            this._isLoaded = !0;
            return this._initPremultipliedATextureWithImage(a, b, c)
        },
        initWithElement: function(a) {
            a && (this._webTextureObj = cc._renderContext.createTexture(), this._htmlElementObj = a)
        },
        getHtmlElementObj: function() {
            return this._htmlElementObj
        },
        isLoaded: function() {
            return this._isLoaded
        },
        handleLoadedTexture: function() {
            if (cc._rendererInitialized) {
                if (!this._htmlElementObj) {
                    var a = cc.loader.getRes(this.url);
                    if (!a) return;
                    this.initWithElement(a)
                }
                this._htmlElementObj.width && this._htmlElementObj.height && (this._isLoaded = !0, a = cc._renderContext, cc.glBindTexture2D(this), a.pixelStorei(a.UNPACK_ALIGNMENT, 4), a.texImage2D(a.TEXTURE_2D, 0, a.RGBA, a.RGBA, a.UNSIGNED_BYTE, this._htmlElementObj), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR), a.texParameteri(a.TEXTURE_2D,
                    a.TEXTURE_MAG_FILTER, a.LINEAR), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE), this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE), cc.glBindTexture2D(null), a = this._htmlElementObj.height, this._pixelsWide = this._contentSize.width = this._htmlElementObj.width, this._pixelsHigh = this._contentSize.height = a, this._pixelFormat = cc.Texture2D.PIXEL_FORMAT_RGBA8888, this.maxT = this.maxS = 1, this._hasMipmaps = this._hasPremultipliedAlpha = !1, this.dispatchEvent("load"))
            }
        },
        initWithString: function(a, b, c, d, e, f) {
            cc.log(cc._LogInfos.Texture2D_initWithString);
            return null
        },
        initWithETCFile: function(a) {
            cc.log(cc._LogInfos.Texture2D_initWithETCFile_2);
            return !1
        },
        initWithPVRFile: function(a) {
            cc.log(cc._LogInfos.Texture2D_initWithPVRFile_2);
            return !1
        },
        initWithPVRTCData: function(a, b, c, d, e, f) {
            cc.log(cc._LogInfos.Texture2D_initWithPVRTCData_2);
            return !1
        },
        setTexParameters: function(a, b, c, d) {
            var e = cc._renderContext;
            void 0 !== b && (a = {
                minFilter: a,
                magFilter: b,
                wrapS: c,
                wrapT: d
            });
            cc.assert(this._pixelsWide == cc.NextPOT(this._pixelsWide) && this._pixelsHigh == cc.NextPOT(this._pixelsHigh) || a.wrapS == e.CLAMP_TO_EDGE && a.wrapT == e.CLAMP_TO_EDGE, "WebGLRenderingContext.CLAMP_TO_EDGE should be used in NPOT textures");
            cc.glBindTexture2D(this);
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, a.minFilter);
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, a.magFilter);
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, a.wrapS);
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, a.wrapT)
        },
        setAntiAliasTexParameters: function() {
            var a = cc._renderContext;
            cc.glBindTexture2D(this);
            this._hasMipmaps ? a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR_MIPMAP_NEAREST) : a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR);
            a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.LINEAR)
        },
        setAliasTexParameters: function() {
            var a = cc._renderContext;
            cc.glBindTexture2D(this);
            this._hasMipmaps ? a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.NEAREST_MIPMAP_NEAREST) : a.texParameteri(a.TEXTURE_2D,
                a.TEXTURE_MIN_FILTER, a.NEAREST);
            a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.NEAREST)
        },
        generateMipmap: function() {
            cc.assert(this._pixelsWide == cc.NextPOT(this._pixelsWide) && this._pixelsHigh == cc.NextPOT(this._pixelsHigh), "Mimpap texture only works in POT textures");
            cc.glBindTexture2D(this);
            cc._renderContext.generateMipmap(cc._renderContext.TEXTURE_2D);
            this._hasMipmaps = !0
        },
        stringForFormat: function() {
            return cc.Texture2D._M[this._pixelFormat]
        },
        bitsPerPixelForFormat: function(a) {
            a = a || this._pixelFormat;
            var b = cc.Texture2D._B[a];
            if (null != b) return b;
            cc.log(cc._LogInfos.Texture2D_bitsPerPixelForFormat, a);
            return -1
        },
        _initPremultipliedATextureWithImage: function(a, b, c) {
            var d = cc.Texture2D,
                e = a.getData(),
                f = null,
                f = null,
                g = a.hasAlpha(),
                h = cc.size(a.getWidth(), a.getHeight()),
                k = d.defaultPixelFormat,
                m = a.getBitsPerComponent();
            g || (8 <= m ? k = d.PIXEL_FORMAT_RGB888 : (cc.log(cc._LogInfos.Texture2D__initPremultipliedATextureWithImage), k = d.PIXEL_FORMAT_RGB565));
            var n = b * c;
            if (k == d.PIXEL_FORMAT_RGB565)
                if (g) {
                    e = new Uint16Array(b *
                        c);
                    f = a.getData();
                    for (m = 0; m < n; ++m) e[m] = (f[m] >> 0 & 255) >> 3 << 11 | (f[m] >> 8 & 255) >> 2 << 5 | (f[m] >> 16 & 255) >> 3 << 0
                } else {
                    e = new Uint16Array(b * c);
                    f = a.getData();
                    for (m = 0; m < n; ++m) e[m] = (f[m] & 255) >> 3 << 11 | (f[m] & 255) >> 2 << 5 | (f[m] & 255) >> 3 << 0
                } else if (k == d.PIXEL_FORMAT_RGBA4444) {
                e = new Uint16Array(b * c);
                f = a.getData();
                for (m = 0; m < n; ++m) e[m] = (f[m] >> 0 & 255) >> 4 << 12 | (f[m] >> 8 & 255) >> 4 << 8 | (f[m] >> 16 & 255) >> 4 << 4 | (f[m] >> 24 & 255) >> 4 << 0
            } else if (k == d.PIXEL_FORMAT_RGB5A1) {
                e = new Uint16Array(b * c);
                f = a.getData();
                for (m = 0; m < n; ++m) e[m] = (f[m] >> 0 & 255) >> 3 <<
                    11 | (f[m] >> 8 & 255) >> 3 << 6 | (f[m] >> 16 & 255) >> 3 << 1 | (f[m] >> 24 & 255) >> 7 << 0
            } else if (k == d.PIXEL_FORMAT_A8) {
                e = new Uint8Array(b * c);
                f = a.getData();
                for (m = 0; m < n; ++m) e[m] = f >> 24 & 255
            }
            if (g && k == d.PIXEL_FORMAT_RGB888) {
                f = a.getData();
                e = new Uint8Array(3 * b * c);
                for (m = 0; m < n; ++m) e[3 * m] = f >> 0 & 255, e[3 * m + 1] = f >> 8 & 255, e[3 * m + 2] = f >> 16 & 255
            }
            this.initWithData(e, k, b, c, h);
            a.getData();
            this._hasPremultipliedAlpha = a.isPremultipliedAlpha();
            return !0
        },
        addLoadedEventListener: function(a, b) {
            this.addEventListener("load", a, b)
        },
        removeLoadedEventListener: function(a) {
            this.removeEventListener("load",
                a)
        }
    })
};
cc._tmp.WebGLTextureAtlas = function() {
    var a = cc.TextureAtlas.prototype;
    a._setupVBO = function() {
        var a = cc._renderContext;
        this._buffersVBO[0] = a.createBuffer();
        this._buffersVBO[1] = a.createBuffer();
        this._quadsWebBuffer = a.createBuffer();
        this._mapBuffers()
    };
    a._mapBuffers = function() {
        var a = cc._renderContext;
        a.bindBuffer(a.ARRAY_BUFFER, this._quadsWebBuffer);
        a.bufferData(a.ARRAY_BUFFER, this._quadsArrayBuffer, a.DYNAMIC_DRAW);
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
        a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indices,
            a.STATIC_DRAW)
    };
    a.drawNumberOfQuads = function(a, c) {
        c = c || 0;
        if (!(0 === a || !this.texture || !this.texture.isLoaded())) {
            var d = cc._renderContext;
            cc.glBindTexture2D(this.texture);
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
            d.bindBuffer(d.ARRAY_BUFFER, this._quadsWebBuffer);
            this.dirty && d.bufferData(d.ARRAY_BUFFER, this._quadsArrayBuffer, d.DYNAMIC_DRAW);
            d.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, d.FLOAT, !1, 24, 0);
            d.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, d.UNSIGNED_BYTE, !0, 24, 12);
            d.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS,
                2, d.FLOAT, !1, 24, 16);
            this.dirty && (this.dirty = !1);
            d.bindBuffer(d.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
            cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP ? d.drawElements(d.TRIANGLE_STRIP, 6 * a, d.UNSIGNED_SHORT, 6 * c * this._indices.BYTES_PER_ELEMENT) : d.drawElements(d.TRIANGLES, 6 * a, d.UNSIGNED_SHORT, 6 * c * this._indices.BYTES_PER_ELEMENT);
            cc.g_NumberOfDraws++
        }
    }
};
cc._tmp.WebGLTextureCache = function() {
    var a = cc.textureCache;
    a.handleLoadedTexture = function(a) {
        var c = this._textures;
        cc._rendererInitialized || (c = this._loadedTexturesBefore);
        var d = c[a];
        d || (d = c[a] = new cc.Texture2D, d.url = a);
        d.handleLoadedTexture()
    };
    a.addImage = function(a, c, d) {
        cc.assert(a, cc._LogInfos.Texture2D_addImage_2);
        var e = this._textures;
        cc._rendererInitialized || (e = this._loadedTexturesBefore);
        var f = e[a] || e[cc.loader._aliases[a]];
        if (f) return c && c.call(d, f), f;
        cc.loader.getRes(a) || (cc.loader._checkIsImageURL(a) ?
            cc.loader.load(a, function(a) {
                c && c.call(d)
            }) : cc.loader.loadImg(a, function(e, h) {
                if (e) return c ? c(e) : e;
                cc.loader.cache[a] = h;
                cc.textureCache.handleLoadedTexture(a);
                c && c.call(d, f)
            }));
        f = e[a] = new cc.Texture2D;
        f.url = a;
        return f
    };
    a = null
};
cc._tmp.PrototypeTexture2D = function() {
    var a = cc.Texture2D;
    a.PVRImagesHavePremultipliedAlpha = function(a) {
        cc.PVRHaveAlphaPremultiplied_ = a
    };
    a.PIXEL_FORMAT_RGBA8888 = 2;
    a.PIXEL_FORMAT_RGB888 = 3;
    a.PIXEL_FORMAT_RGB565 = 4;
    a.PIXEL_FORMAT_A8 = 5;
    a.PIXEL_FORMAT_I8 = 6;
    a.PIXEL_FORMAT_AI88 = 7;
    a.PIXEL_FORMAT_RGBA4444 = 8;
    a.PIXEL_FORMAT_RGB5A1 = 7;
    a.PIXEL_FORMAT_PVRTC4 = 9;
    a.PIXEL_FORMAT_PVRTC2 = 10;
    a.PIXEL_FORMAT_DEFAULT = a.PIXEL_FORMAT_RGBA8888;
    var b = cc.Texture2D._M = {};
    b[a.PIXEL_FORMAT_RGBA8888] = "RGBA8888";
    b[a.PIXEL_FORMAT_RGB888] =
        "RGB888";
    b[a.PIXEL_FORMAT_RGB565] = "RGB565";
    b[a.PIXEL_FORMAT_A8] = "A8";
    b[a.PIXEL_FORMAT_I8] = "I8";
    b[a.PIXEL_FORMAT_AI88] = "AI88";
    b[a.PIXEL_FORMAT_RGBA4444] = "RGBA4444";
    b[a.PIXEL_FORMAT_RGB5A1] = "RGB5A1";
    b[a.PIXEL_FORMAT_PVRTC4] = "PVRTC4";
    b[a.PIXEL_FORMAT_PVRTC2] = "PVRTC2";
    b = cc.Texture2D._B = {};
    b[a.PIXEL_FORMAT_RGBA8888] = 32;
    b[a.PIXEL_FORMAT_RGB888] = 24;
    b[a.PIXEL_FORMAT_RGB565] = 16;
    b[a.PIXEL_FORMAT_A8] = 8;
    b[a.PIXEL_FORMAT_I8] = 8;
    b[a.PIXEL_FORMAT_AI88] = 16;
    b[a.PIXEL_FORMAT_RGBA4444] = 16;
    b[a.PIXEL_FORMAT_RGB5A1] = 16;
    b[a.PIXEL_FORMAT_PVRTC4] = 4;
    b[a.PIXEL_FORMAT_PVRTC2] = 3;
    b = cc.Texture2D.prototype;
    cc.defineGetterSetter(b, "name", b.getName);
    cc.defineGetterSetter(b, "pixelFormat", b.getPixelFormat);
    cc.defineGetterSetter(b, "pixelsWidth", b.getPixelsWide);
    cc.defineGetterSetter(b, "pixelsHeight", b.getPixelsHigh);
    cc.defineGetterSetter(b, "width", b._getWidth);
    cc.defineGetterSetter(b, "height", b._getHeight);
    a.defaultPixelFormat = a.PIXEL_FORMAT_DEFAULT
};
cc._tmp.PrototypeTextureAtlas = function() {
    var a = cc.TextureAtlas.prototype;
    cc.defineGetterSetter(a, "totalQuads", a.getTotalQuads);
    cc.defineGetterSetter(a, "capacity", a.getCapacity);
    cc.defineGetterSetter(a, "quads", a.getQuads, a.setQuads)
};
cc.ALIGN_CENTER = 51;
cc.ALIGN_TOP = 19;
cc.ALIGN_TOP_RIGHT = 18;
cc.ALIGN_RIGHT = 50;
cc.ALIGN_BOTTOM_RIGHT = 34;
cc.ALIGN_BOTTOM = 35;
cc.ALIGN_BOTTOM_LEFT = 33;
cc.ALIGN_LEFT = 49;
cc.ALIGN_TOP_LEFT = 17;
cc.PVRHaveAlphaPremultiplied_ = !1;
cc._renderType === cc._RENDER_TYPE_CANVAS ? cc.Texture2D = cc.Class.extend({
    _contentSize: null,
    _isLoaded: !1,
    _htmlElementObj: null,
    url: null,
    ctor: function() {
        this._contentSize = cc.size(0, 0);
        this._isLoaded = !1;
        this._htmlElementObj = null
    },
    getPixelsWide: function() {
        return this._contentSize.width
    },
    getPixelsHigh: function() {
        return this._contentSize.height
    },
    getContentSize: function() {
        var a = cc.contentScaleFactor();
        return cc.size(this._contentSize.width / a, this._contentSize.height / a)
    },
    _getWidth: function() {
        return this._contentSize.width /
            cc.contentScaleFactor()
    },
    _getHeight: function() {
        return this._contentSize.height / cc.contentScaleFactor()
    },
    getContentSizeInPixels: function() {
        return this._contentSize
    },
    initWithElement: function(a) {
        a && (this._htmlElementObj = a)
    },
    getHtmlElementObj: function() {
        return this._htmlElementObj
    },
    isLoaded: function() {
        return this._isLoaded
    },
    handleLoadedTexture: function() {
        if (!this._isLoaded) {
            if (!this._htmlElementObj) {
                var a = cc.loader.getRes(this.url);
                if (!a) return;
                this.initWithElement(a)
            }
            this._isLoaded = !0;
            a = this._htmlElementObj;
            this._contentSize.width = a.width;
            this._contentSize.height = a.height;
            this.dispatchEvent("load")
        }
    },
    description: function() {
        return "\x3ccc.Texture2D | width \x3d " + this._contentSize.width + " height " + this._contentSize.height + "\x3e"
    },
    initWithData: function(a, b, c, d, e) {
        return !1
    },
    initWithImage: function(a) {
        return !1
    },
    initWithString: function(a, b, c, d, e, f) {
        return !1
    },
    releaseTexture: function() {},
    getName: function() {
        return null
    },
    getMaxS: function() {
        return 1
    },
    setMaxS: function(a) {},
    getMaxT: function() {
        return 1
    },
    setMaxT: function(a) {},
    getPixelFormat: function() {
        return null
    },
    getShaderProgram: function() {
        return null
    },
    setShaderProgram: function(a) {},
    hasPremultipliedAlpha: function() {
        return !1
    },
    hasMipmaps: function() {
        return !1
    },
    releaseData: function(a) {},
    keepData: function(a, b) {
        return a
    },
    drawAtPoint: function(a) {},
    drawInRect: function(a) {},
    initWithETCFile: function(a) {
        cc.log(cc._LogInfos.Texture2D_initWithETCFile);
        return !1
    },
    initWithPVRFile: function(a) {
        cc.log(cc._LogInfos.Texture2D_initWithPVRFile);
        return !1
    },
    initWithPVRTCData: function(a, b, c, d,
        e, f) {
        cc.log(cc._LogInfos.Texture2D_initWithPVRTCData);
        return !1
    },
    setTexParameters: function(a) {},
    setAntiAliasTexParameters: function() {},
    setAliasTexParameters: function() {},
    generateMipmap: function() {},
    stringForFormat: function() {
        return ""
    },
    bitsPerPixelForFormat: function(a) {
        return -1
    },
    addLoadedEventListener: function(a, b) {
        this.addEventListener("load", a, b)
    },
    removeLoadedEventListener: function(a) {
        this.removeEventListener("load", a)
    }
}) : (cc.assert(cc.isFunction(cc._tmp.WebGLTexture2D), cc._LogInfos.MissingFile, "TexturesWebGL.js"),
    cc._tmp.WebGLTexture2D(), delete cc._tmp.WebGLTexture2D);
cc.EventHelper.prototype.apply(cc.Texture2D.prototype);
cc.assert(cc.isFunction(cc._tmp.PrototypeTexture2D), cc._LogInfos.MissingFile, "TexturesPropertyDefine.js");
cc._tmp.PrototypeTexture2D();
delete cc._tmp.PrototypeTexture2D;
cc.textureCache = {
    _textures: {},
    _textureColorsCache: {},
    _textureKeySeq: 0 | 1E3 * Math.random(),
    _loadedTexturesBefore: {},
    _initializingRenderer: function() {
        var a, b = this._loadedTexturesBefore,
            c = this._textures;
        for (a in b) {
            var d = b[a];
            d.handleLoadedTexture();
            c[a] = d
        }
        this._loadedTexturesBefore = {}
    },
    addPVRTCImage: function(a) {
        cc.log(cc._LogInfos.textureCache_addPVRTCImage)
    },
    addETCImage: function(a) {
        cc.log(cc._LogInfos.textureCache_addETCImage)
    },
    description: function() {
        return "\x3cTextureCache | Number of textures \x3d " +
            this._textures.length + "\x3e"
    },
    textureForKey: function(a) {
        cc.log(cc._LogInfos.textureCache_textureForKey);
        return this.getTextureForKey(a)
    },
    getTextureForKey: function(a) {
        return this._textures[a] || this._textures[cc.loader._aliases[a]]
    },
    getKeyByTexture: function(a) {
        for (var b in this._textures)
            if (this._textures[b] == a) return b;
        return null
    },
    _generalTextureKey: function() {
        this._textureKeySeq++;
        return "_textureKey_" + this._textureKeySeq
    },
    getTextureColors: function(a) {
        var b = this.getKeyByTexture(a);
        b || (b = a instanceof HTMLImageElement ? a.src : this._generalTextureKey());
        this._textureColorsCache[b] || (this._textureColorsCache[b] = cc.generateTextureCacheForColor(a));
        return this._textureColorsCache[b]
    },
    addPVRImage: function(a) {
        cc.log(cc._LogInfos.textureCache_addPVRImage)
    },
    removeAllTextures: function() {
        var a = this._textures,
            b;
        for (b in a) a[b] && a[b].releaseTexture();
        this._textures = {}
    },
    removeTexture: function(a) {
        if (a) {
            var b = this._textures,
                c;
            for (c in b) b[c] == a && (b[c].releaseTexture(), delete b[c])
        }
    },
    removeTextureForKey: function(a) {
        null !=
            a && this._textures[a] && delete this._textures[a]
    },
    cacheImage: function(a, b) {
        if (b instanceof cc.Texture2D) this._textures[a] = b;
        else {
            var c = new cc.Texture2D;
            c.initWithElement(b);
            c.handleLoadedTexture();
            this._textures[a] = c
        }
    },
    addUIImage: function(a, b) {
        cc.assert(a, cc._LogInfos.textureCache_addUIImage_2);
        if (b && this._textures[b]) return this._textures[b];
        var c = new cc.Texture2D;
        c.initWithImage(a);
        null != b && null != c ? this._textures[b] = c : cc.log(cc._LogInfos.textureCache_addUIImage);
        return c
    },
    dumpCachedTextureInfo: function() {
        var a =
            0,
            b = 0,
            c = this._textures,
            d;
        for (d in c) {
            var e = c[d];
            a++;
            e.getHtmlElementObj() instanceof HTMLImageElement ? cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo, d, e.getHtmlElementObj().src, e.pixelsWidth, e.pixelsHeight) : cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_2, d, e.pixelsWidth, e.pixelsHeight);
            b += 4 * e.pixelsWidth * e.pixelsHeight
        }
        c = this._textureColorsCache;
        for (d in c) {
            var e = c[d],
                f;
            for (f in e) {
                var g = e[f];
                a++;
                cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_2, d, g.width, g.height);
                b += 4 * g.width *
                    g.height
            }
        }
        cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_3, a, b / 1024, (b / 1048576).toFixed(2))
    },
    _clear: function() {
        this._textures = {};
        this._textureColorsCache = {};
        this._textureKeySeq = 0 | 1E3 * Math.random();
        this._loadedTexturesBefore = {}
    }
};
cc._renderType === cc._RENDER_TYPE_CANVAS ? (_p = cc.textureCache, _p.handleLoadedTexture = function(a) {
    var b = this._textures,
        c = b[a];
    c || (c = b[a] = new cc.Texture2D, c.url = a);
    c.handleLoadedTexture()
}, _p.addImage = function(a, b, c) {
    cc.assert(a, cc._LogInfos.Texture2D_addImage);
    var d = this._textures,
        e = d[a] || d[cc.loader._aliases[a]];
    if (e) return b && b.call(c, e), e;
    e = d[a] = new cc.Texture2D;
    e.url = a;
    cc.loader.getRes(a) ? e.handleLoadedTexture() : cc.loader._checkIsImageURL(a) ? cc.loader.load(a, function(a) {
        b && b.call(c)
    }) : cc.loader.loadImg(a,
        function(d, g) {
            if (d) return b ? b(d) : d;
            cc.loader.cache[a] = g;
            cc.textureCache.handleLoadedTexture(a);
            b && b.call(c, e)
        });
    return e
}, _p = null) : (cc.assert(cc.isFunction(cc._tmp.WebGLTextureCache), cc._LogInfos.MissingFile, "TexturesWebGL.js"), cc._tmp.WebGLTextureCache(), delete cc._tmp.WebGLTextureCache);
cc.TextureAtlas = cc.Class.extend({
    dirty: !1,
    texture: null,
    _indices: null,
    _buffersVBO: null,
    _capacity: 0,
    _quads: null,
    _quadsArrayBuffer: null,
    _quadsWebBuffer: null,
    _quadsReader: null,
    ctor: function(a, b) {
        this._buffersVBO = [];
        cc.isString(a) ? this.initWithFile(a, b) : a instanceof cc.Texture2D && this.initWithTexture(a, b)
    },
    getTotalQuads: function() {
        return this._totalQuads
    },
    getCapacity: function() {
        return this._capacity
    },
    getTexture: function() {
        return this.texture
    },
    setTexture: function(a) {
        this.texture = a
    },
    setDirty: function(a) {
        this.dirty =
            a
    },
    isDirty: function() {
        return this.dirty
    },
    getQuads: function() {
        return this._quads
    },
    setQuads: function(a) {
        this._quads = a
    },
    _copyQuadsToTextureAtlas: function(a, b) {
        if (a)
            for (var c = 0; c < a.length; c++) this._setQuadToArray(a[c], b + c)
    },
    _setQuadToArray: function(a, b) {
        var c = this._quads;
        c[b] ? (c[b].bl = a.bl, c[b].br = a.br, c[b].tl = a.tl, c[b].tr = a.tr) : c[b] = new cc.V3F_C4B_T2F_Quad(a.tl, a.bl, a.tr, a.br, this._quadsArrayBuffer, b * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT)
    },
    description: function() {
        return "\x3ccc.TextureAtlas | totalQuads \x3d" +
            this._totalQuads + "\x3e"
    },
    _setupIndices: function() {
        if (0 !== this._capacity)
            for (var a = this._indices, b = this._capacity, c = 0; c < b; c++) cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP ? (a[6 * c + 0] = 4 * c + 0, a[6 * c + 1] = 4 * c + 0, a[6 * c + 2] = 4 * c + 2, a[6 * c + 3] = 4 * c + 1, a[6 * c + 4] = 4 * c + 3, a[6 * c + 5] = 4 * c + 3) : (a[6 * c + 0] = 4 * c + 0, a[6 * c + 1] = 4 * c + 1, a[6 * c + 2] = 4 * c + 2, a[6 * c + 3] = 4 * c + 3, a[6 * c + 4] = 4 * c + 2, a[6 * c + 5] = 4 * c + 1)
    },
    _setupVBO: function() {
        var a = cc._renderContext;
        this._buffersVBO[0] = a.createBuffer();
        this._buffersVBO[1] = a.createBuffer();
        this._quadsWebBuffer = a.createBuffer();
        this._mapBuffers()
    },
    _mapBuffers: function() {
        var a = cc._renderContext;
        a.bindBuffer(a.ARRAY_BUFFER, this._quadsWebBuffer);
        a.bufferData(a.ARRAY_BUFFER, this._quadsArrayBuffer, a.DYNAMIC_DRAW);
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
        a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indices, a.STATIC_DRAW)
    },
    initWithFile: function(a, b) {
        var c = cc.textureCache.addImage(a);
        if (c) return this.initWithTexture(c, b);
        cc.log(cc._LogInfos.TextureAtlas_initWithFile, a);
        return !1
    },
    initWithTexture: function(a, b) {
        cc.assert(a,
            cc._LogInfos.TextureAtlas_initWithTexture);
        this._capacity = b |= 0;
        this._totalQuads = 0;
        this.texture = a;
        this._quads = [];
        this._indices = new Uint16Array(6 * b);
        var c = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
        this._quadsArrayBuffer = new ArrayBuffer(c * b);
        this._quadsReader = new Uint8Array(this._quadsArrayBuffer);
        if ((!this._quads || !this._indices) && 0 < b) return !1;
        for (var d = this._quads, e = 0; e < b; e++) d[e] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, e * c);
        this._setupIndices();
        this._setupVBO();
        return this.dirty = !0
    },
    updateQuad: function(a, b) {
        cc.assert(a, cc._LogInfos.TextureAtlas_updateQuad);
        cc.assert(0 <= b && b < this._capacity, cc._LogInfos.TextureAtlas_updateQuad_2);
        this._totalQuads = Math.max(b + 1, this._totalQuads);
        this._setQuadToArray(a, b);
        this.dirty = !0
    },
    insertQuad: function(a, b) {
        cc.assert(b < this._capacity, cc._LogInfos.TextureAtlas_insertQuad_2);
        this._totalQuads++;
        if (this._totalQuads > this._capacity) cc.log(cc._LogInfos.TextureAtlas_insertQuad);
        else {
            var c = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
                d = b * c,
                e = (this._totalQuads -
                    1 - b) * c;
            this._quads[this._totalQuads - 1] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, (this._totalQuads - 1) * c);
            this._quadsReader.set(this._quadsReader.subarray(d, d + e), d + c);
            this._setQuadToArray(a, b);
            this.dirty = !0
        }
    },
    insertQuads: function(a, b, c) {
        c = c || a.length;
        cc.assert(b + c <= this._capacity, cc._LogInfos.TextureAtlas_insertQuads);
        var d = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
        this._totalQuads += c;
        if (this._totalQuads > this._capacity) cc.log(cc._LogInfos.TextureAtlas_insertQuad);
        else {
            var e = b *
                d,
                f = (this._totalQuads - 1 - b - c) * d,
                g = this._totalQuads - 1 - c,
                h;
            for (h = 0; h < c; h++) this._quads[g + h] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, (this._totalQuads - 1) * d);
            this._quadsReader.set(this._quadsReader.subarray(e, e + f), e + d * c);
            for (h = 0; h < c; h++) this._setQuadToArray(a[h], b + h);
            this.dirty = !0
        }
    },
    insertQuadFromIndex: function(a, b) {
        if (a !== b) {
            cc.assert(0 <= b || b < this._totalQuads, cc._LogInfos.TextureAtlas_insertQuadFromIndex);
            cc.assert(0 <= a || a < this._totalQuads, cc._LogInfos.TextureAtlas_insertQuadFromIndex_2);
            var c = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
                d = this._quadsReader,
                e = d.subarray(a * c, c),
                f;
            a > b ? (f = b * c, d.set(d.subarray(f, f + (a - b) * c), f + c), d.set(e, f)) : (f = (a + 1) * c, d.set(d.subarray(f, f + (b - a) * c), f - c), d.set(e, b * c));
            this.dirty = !0
        }
    },
    removeQuadAtIndex: function(a) {
        cc.assert(a < this._totalQuads, cc._LogInfos.TextureAtlas_removeQuadAtIndex);
        var b = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
        this._totalQuads--;
        this._quads.length = this._totalQuads;
        if (a !== this._totalQuads) {
            var c = (a + 1) * b;
            this._quadsReader.set(this._quadsReader.subarray(c,
                c + (this._totalQuads - a) * b), c - b)
        }
        this.dirty = !0
    },
    removeQuadsAtIndex: function(a, b) {
        cc.assert(a + b <= this._totalQuads, cc._LogInfos.TextureAtlas_removeQuadsAtIndex);
        this._totalQuads -= b;
        if (a !== this._totalQuads) {
            var c = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
                d = (a + b) * c;
            this._quadsReader.set(this._quadsReader.subarray(d, d + (this._totalQuads - a) * c), a * c)
        }
        this.dirty = !0
    },
    removeAllQuads: function() {
        this._totalQuads = this._quads.length = 0
    },
    _setDirty: function(a) {
        this.dirty = a
    },
    resizeCapacity: function(a) {
        if (a == this._capacity) return !0;
        var b = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
            c = this._capacity;
        this._totalQuads = Math.min(this._totalQuads, a);
        var d = this._capacity = 0 | a,
            e = this._totalQuads;
        if (null == this._quads) {
            this._quads = [];
            this._quadsArrayBuffer = new ArrayBuffer(b * d);
            this._quadsReader = new Uint8Array(this._quadsArrayBuffer);
            for (a = 0; a < d; a++) this._quads = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, a * b)
        } else {
            var f, g, h = this._quads;
            if (d > c) {
                f = [];
                g = new ArrayBuffer(b * d);
                for (a = 0; a < e; a++) f[a] = new cc.V3F_C4B_T2F_Quad(h[a].tl,
                    h[a].bl, h[a].tr, h[a].br, g, a * b);
                for (; a < d; a++) f[a] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, g, a * b)
            } else {
                e = Math.max(e, d);
                f = [];
                g = new ArrayBuffer(b * d);
                for (a = 0; a < e; a++) f[a] = new cc.V3F_C4B_T2F_Quad(h[a].tl, h[a].bl, h[a].tr, h[a].br, g, a * b)
            }
            this._quadsReader = new Uint8Array(g);
            this._quads = f;
            this._quadsArrayBuffer = g
        }
        null == this._indices ? this._indices = new Uint16Array(6 * d) : d > c ? (b = new Uint16Array(6 * d), b.set(this._indices, 0), this._indices = b) : this._indices = this._indices.subarray(0, 6 * d);
        this._setupIndices();
        this._mapBuffers();
        return this.dirty = !0
    },
    increaseTotalQuadsWith: function(a) {
        this._totalQuads += a
    },
    moveQuadsFromIndex: function(a, b, c) {
        if (void 0 === c) {
            if (c = b, b = this._totalQuads - a, cc.assert(c + (this._totalQuads - a) <= this._capacity, cc._LogInfos.TextureAtlas_moveQuadsFromIndex), 0 === b) return
        } else if (cc.assert(c + b <= this._totalQuads, cc._LogInfos.TextureAtlas_moveQuadsFromIndex_2), cc.assert(a < this._totalQuads, cc._LogInfos.TextureAtlas_moveQuadsFromIndex_3), a == c) return;
        var d = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
            e = a * d,
            f = b * d,
            g = this._quadsReader,
            h = g.subarray(e, e + f),
            k = c * d;
        c < a ? (b = c * d, g.set(g.subarray(b, b + (a - c) * d), b + f)) : (b = (a + b) * d, g.set(g.subarray(b, b + (c - a) * d), e));
        g.set(h, k);
        this.dirty = !0
    },
    fillWithEmptyQuadsFromIndex: function(a, b) {
        for (var c = b * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, d = new Uint8Array(this._quadsArrayBuffer, a * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, c), e = 0; e < c; e++) d[e] = 0
    },
    drawQuads: function() {
        this.drawNumberOfQuads(this._totalQuads, 0)
    },
    _releaseBuffer: function() {
        var a = cc._renderContext;
        this._buffersVBO && (this._buffersVBO[0] && a.deleteBuffer(this._buffersVBO[0]),
            this._buffersVBO[1] && a.deleteBuffer(this._buffersVBO[1]));
        this._quadsWebBuffer && a.deleteBuffer(this._quadsWebBuffer)
    }
});
_p = cc.TextureAtlas.prototype;
cc.defineGetterSetter(_p, "totalQuads", _p.getTotalQuads);
cc.defineGetterSetter(_p, "capacity", _p.getCapacity);
cc.defineGetterSetter(_p, "quads", _p.getQuads, _p.setQuads);
cc.TextureAtlas.create = function(a, b) {
    return new cc.TextureAtlas(a, b)
};
cc.TextureAtlas.createWithTexture = cc.TextureAtlas.create;
cc._renderType === cc._RENDER_TYPE_WEBGL && (cc.assert(cc.isFunction(cc._tmp.WebGLTextureAtlas), cc._LogInfos.MissingFile, "TexturesWebGL.js"), cc._tmp.WebGLTextureAtlas(), delete cc._tmp.WebGLTextureAtlas);
cc.assert(cc.isFunction(cc._tmp.PrototypeTextureAtlas), cc._LogInfos.MissingFile, "TexturesPropertyDefine.js");
cc._tmp.PrototypeTextureAtlas();
delete cc._tmp.PrototypeTextureAtlas;
cc.Scene = cc.Node.extend({
    _className: "Scene",
    ctor: function() {
        cc.Node.prototype.ctor.call(this);
        this._ignoreAnchorPointForPosition = !0;
        this.setAnchorPoint(0.5, 0.5);
        this.setContentSize(cc.director.getWinSize())
    }
});
cc.Scene.create = function() {
    return new cc.Scene
};
cc.LoaderScene = cc.Scene.extend({
    _interval: null,
    _label: null,
    _className: "LoaderScene",
    init: function() {
        var a = this,
            b = 200,
            c = a._bgLayer = new cc.LayerColor(cc.color(32, 32, 32, 255));
        c.setPosition(cc.visibleRect.bottomLeft);
        a.addChild(c, 0);
        var d = 24,
            e = -b / 2 + 100;
        cc._loaderImage && (cc.loader.loadImg(cc._loaderImage, {
            isCrossOrigin: !1
        }, function(c, d) {
            b = d.height;
            a._initStage(d, cc.visibleRect.center)
        }), d = 14, e = -b / 2 - 10);
        d = a._label = new cc.LabelTTF("Loading... 0%", "Arial", d);
        d.setPosition(cc.pAdd(cc.visibleRect.center, cc.p(0,
            e)));
        d.setColor(cc.color(180, 180, 180));
        c.addChild(this._label, 10);
        return !0
    },
    _initStage: function(a, b) {
        var c = this._texture2d = new cc.Texture2D;
        c.initWithElement(a);
        c.handleLoadedTexture();
        c = this._logo = new cc.Sprite(c);
        c.setScale(cc.contentScaleFactor());
        c.x = b.x;
        c.y = b.y;
        this._bgLayer.addChild(c, 10)
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this);
        this.schedule(this._startLoading, 0.3)
    },
    onExit: function() {
        cc.Node.prototype.onExit.call(this);
        this._label.setString("Loading... 0%")
    },
    initWithResources: function(a,
        b) {
        cc.isString(a) && (a = [a]);
        this.resources = a || [];
        this.cb = b
    },
    _startLoading: function() {
        var a = this;
        a.unschedule(a._startLoading);
        cc.loader.load(a.resources, function(b, c, d) {
            b = Math.min(100 * (d / c) | 0, 100);
            a._label.setString("Loading... " + b + "%")
        }, function() {
            a.cb && a.cb()
        })
    }
});
cc.LoaderScene.preload = function(a, b) {
    var c = cc;
    c.loaderScene || (c.loaderScene = new cc.LoaderScene, c.loaderScene.init());
    c.loaderScene.initWithResources(a, b);
    cc.director.runScene(c.loaderScene);
    return c.loaderScene
};
cc._tmp.LayerDefineForWebGL = function() {
    var a = cc.Layer.prototype;
    a.bake = function() {};
    a.unbake = function() {};
    a.visit = cc.Node.prototype.visit
};
cc._tmp.WebGLLayerColor = function() {
    var a = cc.LayerColor.prototype;
    a._squareVertices = null;
    a._squareColors = null;
    a._verticesFloat32Buffer = null;
    a._colorsUint8Buffer = null;
    a._squareVerticesAB = null;
    a._squareColorsAB = null;
    a.ctor = function(a, c, d) {
        this._squareVerticesAB = new ArrayBuffer(32);
        this._squareColorsAB = new ArrayBuffer(16);
        var e = this._squareVerticesAB,
            f = this._squareColorsAB,
            g = cc.Vertex2F.BYTES_PER_ELEMENT,
            h = cc.Color.BYTES_PER_ELEMENT;
        this._squareVertices = [new cc.Vertex2F(0, 0, e, 0), new cc.Vertex2F(0, 0, e,
            g), new cc.Vertex2F(0, 0, e, 2 * g), new cc.Vertex2F(0, 0, e, 3 * g)];
        this._squareColors = [cc.color(0, 0, 0, 255, f, 0), cc.color(0, 0, 0, 255, f, h), cc.color(0, 0, 0, 255, f, 2 * h), cc.color(0, 0, 0, 255, f, 3 * h)];
        this._verticesFloat32Buffer = cc._renderContext.createBuffer();
        this._colorsUint8Buffer = cc._renderContext.createBuffer();
        cc.Layer.prototype.ctor.call(this);
        this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
        cc.LayerColor.prototype.init.call(this, a, c, d)
    };
    a._initRendererCmd = function() {
        this._rendererCmd = new cc.RectRenderCmdWebGL(this)
    };
    a.setContentSize = function(a, c) {
        var d = this._squareVertices;
        void 0 === c ? (d[1].x = a.width, d[2].y = a.height, d[3].x = a.width, d[3].y = a.height) : (d[1].x = a, d[2].y = c, d[3].x = a, d[3].y = c);
        this._bindLayerVerticesBufferData();
        cc.Layer.prototype.setContentSize.call(this, a, c)
    };
    a._setWidth = function(a) {
        var c = this._squareVertices;
        c[1].x = a;
        c[3].x = a;
        this._bindLayerVerticesBufferData();
        cc.Layer.prototype._setWidth.call(this, a)
    };
    a._setHeight = function(a) {
        var c = this._squareVertices;
        c[2].y = a;
        c[3].y = a;
        this._bindLayerVerticesBufferData();
        cc.Layer.prototype._setHeight.call(this, a)
    };
    a._updateColor = function() {
        for (var a = this._displayedColor, c = this._displayedOpacity, d = this._squareColors, e = 0; 4 > e; e++) d[e].r = a.r, d[e].g = a.g, d[e].b = a.b, d[e].a = c;
        this._bindLayerColorsBufferData()
    };
    a.draw = function(a) {
        a = a || cc._renderContext;
        cc.nodeDrawSetup(this);
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR);
        a.bindBuffer(a.ARRAY_BUFFER, this._verticesFloat32Buffer);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
        a.bindBuffer(a.ARRAY_BUFFER, this._colorsUint8Buffer);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 0, 0);
        cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst);
        a.drawArrays(a.TRIANGLE_STRIP, 0, 4)
    };
    a._bindLayerVerticesBufferData = function() {
        var a = cc._renderContext;
        a.bindBuffer(a.ARRAY_BUFFER, this._verticesFloat32Buffer);
        a.bufferData(a.ARRAY_BUFFER, this._squareVerticesAB, a.STATIC_DRAW)
    };
    a._bindLayerColorsBufferData = function() {
        var a = cc._renderContext;
        a.bindBuffer(a.ARRAY_BUFFER,
            this._colorsUint8Buffer);
        a.bufferData(a.ARRAY_BUFFER, this._squareColorsAB, a.STATIC_DRAW)
    }
};
cc._tmp.WebGLLayerGradient = function() {
    var a = cc.LayerGradient.prototype;
    a._initRendererCmd = function() {
        this._rendererCmd = new cc.RectRenderCmdWebGL(this)
    };
    a.draw = cc.LayerColor.prototype.draw;
    a._updateColor = function() {
        var a = this._alongVector,
            c = cc.pLength(a);
        if (0 !== c) {
            var d = Math.sqrt(2),
                a = cc.p(a.x / c, a.y / c);
            this._compressedInterpolation && (c = 1 / (Math.abs(a.x) + Math.abs(a.y)), a = cc.pMult(a, c * d));
            var e = this._displayedOpacity / 255,
                c = this._displayedColor,
                f = this._endColor,
                c = {
                    r: c.r,
                    g: c.g,
                    b: c.b,
                    a: this._startOpacity *
                        e
                },
                e = {
                    r: f.r,
                    g: f.g,
                    b: f.b,
                    a: this._endOpacity * e
                },
                g = this._squareColors,
                f = g[0],
                h = g[1],
                k = g[2],
                g = g[3];
            f.r = e.r + (c.r - e.r) * ((d + a.x + a.y) / (2 * d));
            f.g = e.g + (c.g - e.g) * ((d + a.x + a.y) / (2 * d));
            f.b = e.b + (c.b - e.b) * ((d + a.x + a.y) / (2 * d));
            f.a = e.a + (c.a - e.a) * ((d + a.x + a.y) / (2 * d));
            h.r = e.r + (c.r - e.r) * ((d - a.x + a.y) / (2 * d));
            h.g = e.g + (c.g - e.g) * ((d - a.x + a.y) / (2 * d));
            h.b = e.b + (c.b - e.b) * ((d - a.x + a.y) / (2 * d));
            h.a = e.a + (c.a - e.a) * ((d - a.x + a.y) / (2 * d));
            k.r = e.r + (c.r - e.r) * ((d + a.x - a.y) / (2 * d));
            k.g = e.g + (c.g - e.g) * ((d + a.x - a.y) / (2 * d));
            k.b = e.b + (c.b - e.b) * ((d + a.x -
                a.y) / (2 * d));
            k.a = e.a + (c.a - e.a) * ((d + a.x - a.y) / (2 * d));
            g.r = e.r + (c.r - e.r) * ((d - a.x - a.y) / (2 * d));
            g.g = e.g + (c.g - e.g) * ((d - a.x - a.y) / (2 * d));
            g.b = e.b + (c.b - e.b) * ((d - a.x - a.y) / (2 * d));
            g.a = e.a + (c.a - e.a) * ((d - a.x - a.y) / (2 * d));
            this._bindLayerColorsBufferData()
        }
    }
};
cc._tmp.PrototypeLayerColor = function() {
    var a = cc.LayerColor.prototype;
    cc.defineGetterSetter(a, "width", a._getWidth, a._setWidth);
    cc.defineGetterSetter(a, "height", a._getHeight, a._setHeight)
};
cc._tmp.PrototypeLayerGradient = function() {
    var a = cc.LayerGradient.prototype;
    cc.defineGetterSetter(a, "startColor", a.getStartColor, a.setStartColor);
    cc.defineGetterSetter(a, "endColor", a.getEndColor, a.setEndColor);
    cc.defineGetterSetter(a, "startOpacity", a.getStartOpacity, a.setStartOpacity);
    cc.defineGetterSetter(a, "endOpacity", a.getEndOpacity, a.setEndOpacity);
    cc.defineGetterSetter(a, "vector", a.getVector, a.setVector)
};
cc.Layer = cc.Node.extend({
    _isBaked: !1,
    _bakeSprite: null,
    _bakeRenderCmd: null,
    _className: "Layer",
    ctor: function() {
        var a = cc.Node.prototype;
        a.ctor.call(this);
        this._ignoreAnchorPointForPosition = !0;
        a.setAnchorPoint.call(this, 0.5, 0.5);
        a.setContentSize.call(this, cc.winSize)
    },
    init: function() {
        this._ignoreAnchorPointForPosition = !0;
        this.setAnchorPoint(0.5, 0.5);
        this.setContentSize(cc.winSize);
        this.cascadeColor = this.cascadeOpacity = !1;
        return !0
    },
    bake: null,
    unbake: null,
    _bakeRendering: null,
    isBaked: function() {
        return this._isBaked
    },
    visit: null
});
cc.Layer.create = function() {
    return new cc.Layer
};
if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
    var p = cc.Layer.prototype;
    p.bake = function() {
        if (!this._isBaked) {
            this._isBaked = this._cacheDirty = cc.renderer.childrenOrderDirty = !0;
            !this._bakeRenderCmd && this._bakeRendering && (this._bakeRenderCmd = new cc.CustomRenderCmdCanvas(this, this._bakeRendering));
            this._cachedParent = this;
            for (var a = this._children, b = 0, c = a.length; b < c; b++) a[b]._setCachedParent(this);
            this._bakeSprite || (this._bakeSprite = new cc.BakeSprite, this._bakeSprite._parent = this)
        }
    };
    p.unbake = function() {
        if (this._isBaked) {
            cc.renderer.childrenOrderDirty = !0;
            this._isBaked = !1;
            this._cacheDirty = !0;
            this._cachedParent = null;
            for (var a = this._children, b = 0, c = a.length; b < c; b++) a[b]._setCachedParent(null)
        }
    };
    p.addChild = function(a, b, c) {
        cc.Node.prototype.addChild.call(this, a, b, c);
        a._parent == this && this._isBaked && a._setCachedParent(this)
    };
    p._bakeRendering = function() {
        if (this._cacheDirty) {
            var a = this._children,
                b = this._bakeSprite,
                c = this._getBoundingBoxForBake();
            c.width |= 0;
            c.height |= 0;
            var d = b.getCacheContext();
            b.resetCanvasSize(c.width, c.height);
            d.translate(0 - c.x, c.height +
                c.y);
            var e = cc.affineTransformInvert(this._transformWorld),
                f = cc.view.getScaleX(),
                g = cc.view.getScaleY();
            d.transform(e.a, e.c, e.b, e.d, e.tx * f, -e.ty * g);
            e = b.getAnchorPointInPoints();
            b.setPosition(e.x + c.x, e.y + c.y);
            this.sortAllChildren();
            cc.renderer._turnToCacheMode(this.__instanceId);
            b = 0;
            for (c = a.length; b < c; b++) a[b].visit(d);
            cc.renderer._renderingToCacheCanvas(d, this.__instanceId);
            this._cacheDirty = !1
        }
    };
    p.visit = function(a) {
        if (this._isBaked) {
            a = a || cc._renderContext;
            var b = this._children.length;
            this._visible &&
                0 !== b && (this.transform(a), this._bakeRenderCmd && cc.renderer.pushRenderCommand(this._bakeRenderCmd), this._bakeSprite.visit(a))
        } else cc.Node.prototype.visit.call(this, a)
    };
    p._getBoundingBoxForBake = function() {
        var a = null;
        if (!this._children || 0 === this._children.length) return cc.rect(0, 0, 10, 10);
        for (var b = this._children, c = 0; c < b.length; c++) {
            var d = b[c];
            d && d._visible && (a ? (d = d._getBoundingBoxToCurrentNode()) && (a = cc.rectUnion(a, d)) : a = d._getBoundingBoxToCurrentNode())
        }
        return a
    };
    p = null
} else cc.assert(cc.isFunction(cc._tmp.LayerDefineForWebGL),
    cc._LogInfos.MissingFile, "CCLayerWebGL.js"), cc._tmp.LayerDefineForWebGL(), delete cc._tmp.LayerDefineForWebGL;
cc.LayerColor = cc.Layer.extend({
    _blendFunc: null,
    _className: "LayerColor",
    getBlendFunc: function() {
        return this._blendFunc
    },
    changeWidthAndHeight: function(a, b) {
        this.width = a;
        this.height = b
    },
    changeWidth: function(a) {
        this.width = a
    },
    changeHeight: function(a) {
        this.height = a
    },
    setOpacityModifyRGB: function(a) {},
    isOpacityModifyRGB: function() {
        return !1
    },
    setColor: function(a) {
        cc.Layer.prototype.setColor.call(this, a);
        this._updateColor()
    },
    setOpacity: function(a) {
        cc.Layer.prototype.setOpacity.call(this, a);
        this._updateColor()
    },
    _blendFuncStr: "source",
    ctor: null,
    init: function(a, b, c) {
        cc._renderType !== cc._RENDER_TYPE_CANVAS && (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_COLOR));
        var d = cc.director.getWinSize();
        a = a || cc.color(0, 0, 0, 255);
        b = void 0 === b ? d.width : b;
        c = void 0 === c ? d.height : c;
        d = this._displayedColor;
        d.r = a.r;
        d.g = a.g;
        d.b = a.b;
        d = this._realColor;
        d.r = a.r;
        d.g = a.g;
        d.b = a.b;
        this._realOpacity = this._displayedOpacity = a.a;
        a = cc.LayerColor.prototype;
        a.setContentSize.call(this, b, c);
        a._updateColor.call(this);
        return !0
    },
    setBlendFunc: function(a, b) {
        var c = this._blendFunc;
        void 0 === b ? (c.src = a.src, c.dst = a.dst) : (c.src = a, c.dst = b);
        cc._renderType === cc._RENDER_TYPE_CANVAS && (this._blendFuncStr = cc._getCompositeOperationByBlendFunc(c))
    },
    _setWidth: null,
    _setHeight: null,
    _updateColor: null,
    updateDisplayedColor: function(a) {
        cc.Layer.prototype.updateDisplayedColor.call(this, a);
        this._updateColor()
    },
    updateDisplayedOpacity: function(a) {
        cc.Layer.prototype.updateDisplayedOpacity.call(this, a);
        this._updateColor()
    },
    draw: null
});
cc.LayerColor.create = function(a, b, c) {
    return new cc.LayerColor(a, b, c)
};
cc._renderType === cc._RENDER_TYPE_CANVAS ? (_p = cc.LayerColor.prototype, _p.ctor = function(a, b, c) {
    cc.Layer.prototype.ctor.call(this);
    this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
    cc.LayerColor.prototype.init.call(this, a, b, c)
}, _p._initRendererCmd = function() {
    this._rendererCmd = new cc.RectRenderCmdCanvas(this)
}, _p._setWidth = function(a) {
    cc.Node.prototype._setWidth.call(this, a)
}, _p._setHeight = function(a) {
    cc.Node.prototype._setHeight.call(this, a)
}, _p._updateColor = function() {
    var a = this._rendererCmd;
    if (a && a._color) {
        var b = this._displayedColor;
        a._color.r = b.r;
        a._color.g = b.g;
        a._color.b = b.b;
        a._color.a = this._displayedOpacity / 255
    }
}, _p.draw = function(a) {
    a = a || cc._renderContext;
    var b = cc.view,
        c = this._displayedColor;
    a.fillStyle = "rgba(" + (0 | c.r) + "," + (0 | c.g) + "," + (0 | c.b) + "," + this._displayedOpacity / 255 + ")";
    a.fillRect(0, 0, this.width * b.getScaleX(), -this.height * b.getScaleY());
    cc.g_NumberOfDraws++
}, _p._bakeRendering = function() {
    if (this._cacheDirty) {
        var a = this._bakeSprite,
            b = this._children,
            c = b.length,
            d = this._getBoundingBoxForBake();
        d.width |= 0;
        d.height |= 0;
        var e = a.getCacheContext();
        a.resetCanvasSize(d.width, d.height);
        var f = a.getAnchorPointInPoints(),
            g = this._position;
        if (this._ignoreAnchorPointForPosition) e.translate(0 - d.x + g.x, d.height + d.y - g.y), a.setPosition(f.x + d.x - g.x, f.y + d.y - g.y);
        else {
            var h = this.getAnchorPointInPoints(),
                k = g.x - h.x,
                g = g.y - h.y;
            e.translate(0 - d.x + k, d.height + d.y - g);
            a.setPosition(f.x + d.x - k, f.y + d.y - g)
        }
        a = cc.affineTransformInvert(this._transformWorld);
        d = cc.view.getScaleX();
        f = cc.view.getScaleY();
        e.transform(a.a, a.c, a.b,
            a.d, a.tx * d, -a.ty * f);
        cc.renderer._turnToCacheMode(this.__instanceId);
        if (0 < c) {
            this.sortAllChildren();
            for (a = 0; a < c; a++)
                if (d = b[a], 0 > d._localZOrder) d.visit(e);
                else break;
            for (this._rendererCmd && cc.renderer.pushRenderCommand(this._rendererCmd); a < c; a++) b[a].visit(e)
        } else this._rendererCmd && cc.renderer.pushRenderCommand(this._rendererCmd);
        cc.renderer._renderingToCacheCanvas(e, this.__instanceId);
        this._cacheDirty = !1
    }
}, _p.visit = function(a) {
    this._isBaked ? (a = a || cc._renderContext, this._visible && (this.transform(a),
        this._bakeRenderCmd && cc.renderer.pushRenderCommand(this._bakeRenderCmd), this._bakeSprite.visit(a))) : cc.Node.prototype.visit.call(this, a)
}, _p._getBoundingBoxForBake = function() {
    var a = cc.rect(0, 0, this._contentSize.width, this._contentSize.height),
        b = this.nodeToWorldTransform(),
        a = cc.rectApplyAffineTransform(a, this.nodeToWorldTransform());
    if (!this._children || 0 === this._children.length) return a;
    for (var c = this._children, d = 0; d < c.length; d++) {
        var e = c[d];
        e && e._visible && (e = e._getBoundingBoxToCurrentNode(b), a = cc.rectUnion(a,
            e))
    }
    return a
}, _p = null) : (cc.assert(cc.isFunction(cc._tmp.WebGLLayerColor), cc._LogInfos.MissingFile, "CCLayerWebGL.js"), cc._tmp.WebGLLayerColor(), delete cc._tmp.WebGLLayerColor);
cc.assert(cc.isFunction(cc._tmp.PrototypeLayerColor), cc._LogInfos.MissingFile, "CCLayerPropertyDefine.js");
cc._tmp.PrototypeLayerColor();
delete cc._tmp.PrototypeLayerColor;
cc.LayerGradient = cc.LayerColor.extend({
    _endColor: null,
    _startOpacity: 255,
    _endOpacity: 255,
    _alongVector: null,
    _compressedInterpolation: !1,
    _className: "LayerGradient",
    ctor: function(a, b, c) {
        cc.LayerColor.prototype.ctor.call(this);
        this._endColor = cc.color(0, 0, 0, 255);
        this._alongVector = cc.p(0, -1);
        this._endOpacity = this._startOpacity = 255;
        cc.LayerGradient.prototype.init.call(this, a, b, c)
    },
    _initRendererCmd: function() {
        this._rendererCmd = new cc.GradientRectRenderCmdCanvas(this)
    },
    init: function(a, b, c) {
        a = a || cc.color(0,
            0, 0, 255);
        b = b || cc.color(0, 0, 0, 255);
        c = c || cc.p(0, -1);
        var d = this._endColor;
        this._startOpacity = a.a;
        d.r = b.r;
        d.g = b.g;
        d.b = b.b;
        this._endOpacity = b.a;
        this._alongVector = c;
        this._compressedInterpolation = !0;
        cc.LayerColor.prototype.init.call(this, cc.color(a.r, a.g, a.b, 255));
        cc.LayerGradient.prototype._updateColor.call(this);
        return !0
    },
    setContentSize: function(a, b) {
        cc.LayerColor.prototype.setContentSize.call(this, a, b);
        this._updateColor()
    },
    _setWidth: function(a) {
        cc.LayerColor.prototype._setWidth.call(this, a);
        this._updateColor()
    },
    _setHeight: function(a) {
        cc.LayerColor.prototype._setHeight.call(this, a);
        this._updateColor()
    },
    getStartColor: function() {
        return this._realColor
    },
    setStartColor: function(a) {
        this.color = a
    },
    setEndColor: function(a) {
        this._endColor = a;
        this._updateColor()
    },
    getEndColor: function() {
        return this._endColor
    },
    setStartOpacity: function(a) {
        this._startOpacity = a;
        this._updateColor()
    },
    getStartOpacity: function() {
        return this._startOpacity
    },
    setEndOpacity: function(a) {
        this._endOpacity = a;
        this._updateColor()
    },
    getEndOpacity: function() {
        return this._endOpacity
    },
    setVector: function(a) {
        this._alongVector.x = a.x;
        this._alongVector.y = a.y;
        this._updateColor()
    },
    getVector: function() {
        return cc.p(this._alongVector.x, this._alongVector.y)
    },
    isCompressedInterpolation: function() {
        return this._compressedInterpolation
    },
    setCompressedInterpolation: function(a) {
        this._compressedInterpolation = a;
        this._updateColor()
    },
    _draw: null,
    _updateColor: null
});
cc.LayerGradient.create = function(a, b, c) {
    return new cc.LayerGradient(a, b, c)
};
cc._renderType === cc._RENDER_TYPE_CANVAS ? (_p = cc.LayerGradient.prototype, _p._updateColor = function() {
    var a = this._alongVector,
        b = 0.5 * this.width,
        c = 0.5 * this.height,
        d = this._rendererCmd;
    d._startPoint.x = b * -a.x + b;
    d._startPoint.y = c * a.y - c;
    d._endPoint.x = b * a.x + b;
    d._endPoint.y = c * -a.y - c;
    var a = this._displayedColor,
        b = this._endColor,
        c = this._startOpacity,
        e = this._endOpacity;
    d._startStopStr = "rgba(" + Math.round(a.r) + "," + Math.round(a.g) + "," + Math.round(a.b) + "," + c.toFixed(4) + ")";
    d._endStopStr = "rgba(" + Math.round(b.r) + "," + Math.round(b.g) +
        "," + Math.round(b.b) + "," + e.toFixed(4) + ")"
}, _p = null) : (cc.assert(cc.isFunction(cc._tmp.WebGLLayerGradient), cc._LogInfos.MissingFile, "CCLayerWebGL.js"), cc._tmp.WebGLLayerGradient(), delete cc._tmp.WebGLLayerGradient);
cc.assert(cc.isFunction(cc._tmp.PrototypeLayerGradient), cc._LogInfos.MissingFile, "CCLayerPropertyDefine.js");
cc._tmp.PrototypeLayerGradient();
delete cc._tmp.PrototypeLayerGradient;
cc.LayerMultiplex = cc.Layer.extend({
    _enabledLayer: 0,
    _layers: null,
    _className: "LayerMultiplex",
    ctor: function(a) {
        cc.Layer.prototype.ctor.call(this);
        a instanceof Array ? cc.LayerMultiplex.prototype.initWithLayers.call(this, a) : cc.LayerMultiplex.prototype.initWithLayers.call(this, Array.prototype.slice.call(arguments))
    },
    initWithLayers: function(a) {
        0 < a.length && null == a[a.length - 1] && cc.log(cc._LogInfos.LayerMultiplex_initWithLayers);
        this._layers = a;
        this._enabledLayer = 0;
        this.addChild(this._layers[this._enabledLayer]);
        return !0
    },
    switchTo: function(a) {
        a >= this._layers.length ? cc.log(cc._LogInfos.LayerMultiplex_switchTo) : (this.removeChild(this._layers[this._enabledLayer], !0), this._enabledLayer = a, this.addChild(this._layers[a]))
    },
    switchToAndReleaseMe: function(a) {
        a >= this._layers.length ? cc.log(cc._LogInfos.LayerMultiplex_switchToAndReleaseMe) : (this.removeChild(this._layers[this._enabledLayer], !0), this._layers[this._enabledLayer] = null, this._enabledLayer = a, this.addChild(this._layers[a]))
    },
    addLayer: function(a) {
        a ? this._layers.push(a) :
            cc.log(cc._LogInfos.LayerMultiplex_addLayer)
    }
});
cc.LayerMultiplex.create = function() {
    return new cc.LayerMultiplex(Array.prototype.slice.call(arguments))
};
cc._tmp.WebGLSprite = function() {
    var a = cc.Sprite.prototype;
    a._spriteFrameLoadedCallback = function(a) {
        this.setNodeDirty(!0);
        this.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize());
        this.dispatchEvent("load")
    };
    a.setOpacityModifyRGB = function(a) {
        this._opacityModifyRGB !== a && (this._opacityModifyRGB = a, this.updateColor())
    };
    a.updateDisplayedOpacity = function(a) {
        cc.Node.prototype.updateDisplayedOpacity.call(this, a);
        this.updateColor()
    };
    a.ctor = function(a, c, d) {
        cc.Node.prototype.ctor.call(this);
        this._shouldBeHidden = !1;
        this._offsetPosition = cc.p(0, 0);
        this._unflippedOffsetPositionFromCenter = cc.p(0, 0);
        this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        };
        this._rect = cc.rect(0, 0, 0, 0);
        this._quad = new cc.V3F_C4B_T2F_Quad;
        this._quadWebBuffer = cc._renderContext.createBuffer();
        this._textureLoaded = this._quadDirty = !0;
        this._softInit(a, c, d)
    };
    a._initRendererCmd = function() {
        this._rendererCmd = new cc.TextureRenderCmdWebGL(this)
    };
    a.setBlendFunc = function(a, c) {
        var d = this._blendFunc;
        void 0 === c ? (d.src = a.src, d.dst = a.dst) : (d.src = a, d.dst =
            c)
    };
    a.init = function() {
        if (0 < arguments.length) return this.initWithFile(arguments[0], arguments[1]);
        cc.Node.prototype.init.call(this);
        this.dirty = this._recursiveDirty = !1;
        this._opacityModifyRGB = !0;
        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;
        this.texture = null;
        this._textureLoaded = !0;
        this._flippedX = this._flippedY = !1;
        this.anchorY = this.anchorX = 0.5;
        this._offsetPosition.x = 0;
        this._offsetPosition.y = 0;
        this._hasChildren = !1;
        var a = {
            r: 255,
            g: 255,
            b: 255,
            a: 255
        };
        this._quad.bl.colors = a;
        this._quad.br.colors =
            a;
        this._quad.tl.colors = a;
        this._quad.tr.colors = a;
        this._quadDirty = !0;
        this.setTextureRect(cc.rect(0, 0, 0, 0), !1, cc.size(0, 0));
        return !0
    };
    a.initWithTexture = function(a, c, d) {
        cc.assert(0 != arguments.length, cc._LogInfos.Sprite_initWithTexture);
        d = d || !1;
        if (!cc.Node.prototype.init.call(this)) return !1;
        this._batchNode = null;
        this.dirty = this._recursiveDirty = !1;
        this._opacityModifyRGB = !0;
        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;
        this._flippedX = this._flippedY = !1;
        this.anchorY = this.anchorX = 0.5;
        this._offsetPosition.x =
            0;
        this._offsetPosition.y = 0;
        this._hasChildren = !1;
        var e = cc.color(255, 255, 255, 255),
            f = this._quad;
        f.bl.colors = e;
        f.br.colors = e;
        f.tl.colors = e;
        f.tr.colors = e;
        this._textureLoaded = e = a.isLoaded();
        if (!e) return this._rectRotated = d || !1, c && (e = this._rect, e.x = c.x, e.y = c.y, e.width = c.width, e.height = c.height), a.addEventListener("load", this._textureLoadedCallback, this), !0;
        c || (c = cc.rect(0, 0, a.width, a.height));
        a && a.url && (d ? (e = c.x + c.height, f = c.y + c.width) : (e = c.x + c.width, f = c.y + c.height), e > a.width && cc.error(cc._LogInfos.RectWidth,
            a.url), f > a.height && cc.error(cc._LogInfos.RectHeight, a.url));
        this.texture = a;
        this.setTextureRect(c, d);
        this.batchNode = null;
        return this._quadDirty = !0
    };
    a._textureLoadedCallback = function(a) {
        if (!this._textureLoaded) {
            this._textureLoaded = !0;
            var c = this._rect;
            c ? cc._rectEqualToZero(c) && (c.width = a.width, c.height = a.height) : c = cc.rect(0, 0, a.width, a.height);
            this.texture = a;
            this.setTextureRect(c, this._rectRotated);
            this.batchNode = this._batchNode;
            this._quadDirty = !0;
            this.dispatchEvent("load")
        }
    };
    a.setTextureRect = function(a,
        c, d) {
        this._rectRotated = c || !1;
        this.setContentSize(d || a);
        this.setVertexRect(a);
        this._setTextureCoords(a);
        a = this._unflippedOffsetPositionFromCenter;
        this._flippedX && (a.x = -a.x);
        this._flippedY && (a.y = -a.y);
        var e = this._rect;
        this._offsetPosition.x = a.x + (this._contentSize.width - e.width) / 2;
        this._offsetPosition.y = a.y + (this._contentSize.height - e.height) / 2;
        if (this._batchNode) this.dirty = !0;
        else {
            a = this._offsetPosition.x;
            c = this._offsetPosition.y;
            d = a + e.width;
            var e = c + e.height,
                f = this._quad;
            f.bl.vertices = {
                x: a,
                y: c,
                z: 0
            };
            f.br.vertices = {
                x: d,
                y: c,
                z: 0
            };
            f.tl.vertices = {
                x: a,
                y: e,
                z: 0
            };
            f.tr.vertices = {
                x: d,
                y: e,
                z: 0
            };
            this._quadDirty = !0
        }
    };
    a.updateTransform = function() {
        if (this.dirty) {
            var a = this._quad,
                c = this._parent;
            if (!this._visible || c && c != this._batchNode && c._shouldBeHidden) a.br.vertices = a.tl.vertices = a.tr.vertices = a.bl.vertices = {
                x: 0,
                y: 0,
                z: 0
            }, this._shouldBeHidden = !0;
            else {
                this._shouldBeHidden = !1;
                var d = this._transformToBatch = !c || c == this._batchNode ? this.nodeToParentTransform() : cc.affineTransformConcat(this.nodeToParentTransform(), c._transformToBatch),
                    e = this._rect,
                    c = this._offsetPosition.x,
                    f = this._offsetPosition.y,
                    g = c + e.width,
                    h = f + e.height,
                    k = d.tx,
                    m = d.ty,
                    n = d.a,
                    q = d.b,
                    r = d.d,
                    s = -d.c,
                    d = c * n - f * s + k,
                    e = c * q + f * r + m,
                    t = g * n - f * s + k,
                    f = g * q + f * r + m,
                    u = g * n - h * s + k,
                    g = g * q + h * r + m,
                    k = c * n - h * s + k,
                    c = c * q + h * r + m,
                    h = this._vertexZ;
                cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (d |= 0, e |= 0, t |= 0, f |= 0, u |= 0, g |= 0, k |= 0, c |= 0);
                a.bl.vertices = {
                    x: d,
                    y: e,
                    z: h
                };
                a.br.vertices = {
                    x: t,
                    y: f,
                    z: h
                };
                a.tl.vertices = {
                    x: k,
                    y: c,
                    z: h
                };
                a.tr.vertices = {
                    x: u,
                    y: g,
                    z: h
                }
            }
            this.textureAtlas.updateQuad(a, this.atlasIndex);
            this.dirty = this._recursiveDirty = !1
        }
        this._hasChildren && this._arrayMakeObjectsPerformSelector(this._children, cc.Node._StateCallbackType.updateTransform);
        cc.SPRITE_DEBUG_DRAW && (a = [cc.p(this._quad.bl.vertices.x, this._quad.bl.vertices.y), cc.p(this._quad.br.vertices.x, this._quad.br.vertices.y), cc.p(this._quad.tr.vertices.x, this._quad.tr.vertices.y), cc.p(this._quad.tl.vertices.x, this._quad.tl.vertices.y)], cc._drawingUtil.drawPoly(a, 4, !0))
    };
    a.addChild = function(a, c, d) {
        cc.assert(a, cc._LogInfos.Sprite_addChild_3);
        null == c && (c = a._localZOrder);
        null == d && (d = a.tag);
        if (this._batchNode) {
            if (!(a instanceof cc.Sprite)) {
                cc.log(cc._LogInfos.Sprite_addChild);
                return
            }
            a.texture._webTextureObj !== this.textureAtlas.texture._webTextureObj && cc.log(cc._LogInfos.Sprite_addChild_2);
            this._batchNode.appendChild(a);
            this._reorderChildDirty || this._setReorderChildDirtyRecursively()
        }
        cc.Node.prototype.addChild.call(this, a, c, d);
        this._hasChildren = !0
    };
    a.setOpacity = function(a) {
        cc.Node.prototype.setOpacity.call(this, a);
        this.updateColor()
    };
    a.setColor = function(a) {
        cc.Node.prototype.setColor.call(this,
            a);
        this.updateColor()
    };
    a.updateDisplayedColor = function(a) {
        cc.Node.prototype.updateDisplayedColor.call(this, a);
        this.updateColor()
    };
    a.setSpriteFrame = function(a) {
        var c = this;
        cc.isString(a) && (a = cc.spriteFrameCache.getSpriteFrame(a), cc.assert(a, cc._LogInfos.Sprite_setSpriteFrame));
        c.setNodeDirty(!0);
        var d = a.getOffset();
        c._unflippedOffsetPositionFromCenter.x = d.x;
        c._unflippedOffsetPositionFromCenter.y = d.y;
        d = a.getTexture();
        a.textureLoaded() || (c._textureLoaded = !1, a.addEventListener("load", function(a) {
            c._textureLoaded = !0;
            var b = a.getTexture();
            b != c._texture && (c.texture = b);
            c.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize());
            c.dispatchEvent("load")
        }, c));
        d != c._texture && (c.texture = d);
        c._rectRotated = a.isRotated();
        c.setTextureRect(a.getRect(), c._rectRotated, a.getOriginalSize())
    };
    a.isFrameDisplayed = function(a) {
        return cc.rectEqualToRect(a.getRect(), this._rect) && a.getTexture().getName() == this._texture.getName() && cc.pointEqualToPoint(a.getOffset(), this._unflippedOffsetPositionFromCenter)
    };
    a.setBatchNode = function(a) {
        if (this._batchNode =
            a) this._transformToBatch = cc.affineTransformIdentity(), this.textureAtlas = this._batchNode.textureAtlas;
        else {
            this.atlasIndex = cc.Sprite.INDEX_NOT_INITIALIZED;
            this.textureAtlas = null;
            this.dirty = this._recursiveDirty = !1;
            a = this._offsetPosition.x;
            var c = this._offsetPosition.y,
                d = a + this._rect.width,
                e = c + this._rect.height,
                f = this._quad;
            f.bl.vertices = {
                x: a,
                y: c,
                z: 0
            };
            f.br.vertices = {
                x: d,
                y: c,
                z: 0
            };
            f.tl.vertices = {
                x: a,
                y: e,
                z: 0
            };
            f.tr.vertices = {
                x: d,
                y: e,
                z: 0
            };
            this._quadDirty = !0
        }
    };
    a.setTexture = function(a) {
        var c = this;
        if (a && cc.isString(a)) {
            a =
                cc.textureCache.addImage(a);
            c.setTexture(a);
            var d = a.getContentSize();
            c.setTextureRect(cc.rect(0, 0, d.width, d.height));
            a._isLoaded || a.addEventListener("load", function() {
                var d = a.getContentSize();
                c.setTextureRect(cc.rect(0, 0, d.width, d.height))
            }, this)
        } else cc.assert(!a || a instanceof cc.Texture2D, cc._LogInfos.Sprite_setTexture_2), c._batchNode && c._batchNode.texture != a ? cc.log(cc._LogInfos.Sprite_setTexture) : (c.shaderProgram = a ? cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR) : cc.shaderCache.programForKey(cc.SHADER_POSITION_COLOR), !c._batchNode && c._texture != a && (c._texture = a, c._updateBlendFunc()))
    };
    a.draw = function() {
        if (this._textureLoaded) {
            var a = cc._renderContext,
                c = this._texture;
            c ? c._isLoaded && (this._shaderProgram.use(), this._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst), cc.glBindTexture2DN(0, c), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), a.bindBuffer(a.ARRAY_BUFFER, this._quadWebBuffer), this._quadDirty && (a.bufferData(a.ARRAY_BUFFER,
                this._quad.arrayBuffer, a.DYNAMIC_DRAW), this._quadDirty = !1), a.vertexAttribPointer(0, 3, a.FLOAT, !1, 24, 0), a.vertexAttribPointer(1, 4, a.UNSIGNED_BYTE, !0, 24, 12), a.vertexAttribPointer(2, 2, a.FLOAT, !1, 24, 16), a.drawArrays(a.TRIANGLE_STRIP, 0, 4)) : (this._shaderProgram.use(), this._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst), cc.glBindTexture2D(null), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR), a.bindBuffer(a.ARRAY_BUFFER,
                this._quadWebBuffer), this._quadDirty && (cc._renderContext.bufferData(cc._renderContext.ARRAY_BUFFER, this._quad.arrayBuffer, cc._renderContext.STATIC_DRAW), this._quadDirty = !1), a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, a.FLOAT, !1, 24, 0), a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 24, 12), a.drawArrays(a.TRIANGLE_STRIP, 0, 4));
            cc.g_NumberOfDraws++;
            if (0 !== cc.SPRITE_DEBUG_DRAW || this._showNode) 1 === cc.SPRITE_DEBUG_DRAW || this._showNode ? (a = this._quad, a = [cc.p(a.tl.vertices.x, a.tl.vertices.y),
                cc.p(a.bl.vertices.x, a.bl.vertices.y), cc.p(a.br.vertices.x, a.br.vertices.y), cc.p(a.tr.vertices.x, a.tr.vertices.y)
            ], cc._drawingUtil.drawPoly(a, 4, !0)) : 2 === cc.SPRITE_DEBUG_DRAW && (a = this.getTextureRect(), c = this.getOffsetPosition(), a = [cc.p(c.x, c.y), cc.p(c.x + a.width, c.y), cc.p(c.x + a.width, c.y + a.height), cc.p(c.x, c.y + a.height)], cc._drawingUtil.drawPoly(a, 4, !0))
        }
    };
    delete a
};
cc._tmp.PrototypeSprite = function() {
    var a = cc.Sprite.prototype;
    cc.defineGetterSetter(a, "opacityModifyRGB", a.isOpacityModifyRGB, a.setOpacityModifyRGB);
    cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity);
    cc.defineGetterSetter(a, "color", a.getColor, a.setColor);
    cc.defineGetterSetter(a, "flippedX", a.isFlippedX, a.setFlippedX);
    cc.defineGetterSetter(a, "flippedY", a.isFlippedY, a.setFlippedY);
    cc.defineGetterSetter(a, "offsetX", a._getOffsetX);
    cc.defineGetterSetter(a, "offsetY", a._getOffsetY);
    cc.defineGetterSetter(a,
        "texture", a.getTexture, a.setTexture);
    cc.defineGetterSetter(a, "textureRectRotated", a.isTextureRectRotated);
    cc.defineGetterSetter(a, "batchNode", a.getBatchNode, a.setBatchNode);
    cc.defineGetterSetter(a, "quad", a.getQuad)
};
cc.generateTintImageWithMultiply = function(a, b, c, d) {
    d = d || cc.newElement("canvas");
    c = c || cc.rect(0, 0, a.width, a.height);
    var e = d.getContext("2d");
    d.width != c.width || d.height != c.height ? (d.width = c.width, d.height = c.height) : e.globalCompositeOperation = "source-over";
    e.fillStyle = "rgb(" + (0 | b.r) + "," + (0 | b.g) + "," + (0 | b.b) + ")";
    e.fillRect(0, 0, c.width, c.height);
    e.globalCompositeOperation = "multiply";
    e.drawImage(a, c.x, c.y, c.width, c.height, 0, 0, c.width, c.height);
    e.globalCompositeOperation = "destination-atop";
    e.drawImage(a,
        c.x, c.y, c.width, c.height, 0, 0, c.width, c.height);
    return d
};
cc.generateTintImage = function(a, b, c, d, e) {
    d || (d = cc.rect(0, 0, a.width, a.height));
    a = c.r / 255;
    var f = c.g / 255;
    c = c.b / 255;
    var g = Math.min(d.width, b[0].width),
        h = Math.min(d.height, b[0].height),
        k;
    e ? (k = e.getContext("2d"), k.clearRect(0, 0, g, h)) : (e = cc.newElement("canvas"), e.width = g, e.height = h, k = e.getContext("2d"));
    k.save();
    k.globalCompositeOperation = "lighter";
    var m = k.globalAlpha;
    0 < a && (k.globalAlpha = a * m, k.drawImage(b[0], d.x, d.y, g, h, 0, 0, g, h));
    0 < f && (k.globalAlpha = f * m, k.drawImage(b[1], d.x, d.y, g, h, 0, 0, g, h));
    0 < c && (k.globalAlpha =
        c * m, k.drawImage(b[2], d.x, d.y, g, h, 0, 0, g, h));
    1 > a + f + c && (k.globalAlpha = m, k.drawImage(b[3], d.x, d.y, g, h, 0, 0, g, h));
    k.restore();
    return e
};
cc.generateTextureCacheForColor = function(a) {
    function b() {
        var b = cc.generateTextureCacheForColor,
            d = a.width,
            g = a.height;
        c[0].width = d;
        c[0].height = g;
        c[1].width = d;
        c[1].height = g;
        c[2].width = d;
        c[2].height = g;
        c[3].width = d;
        c[3].height = g;
        b.canvas.width = d;
        b.canvas.height = g;
        var h = b.canvas.getContext("2d");
        h.drawImage(a, 0, 0);
        b.tempCanvas.width = d;
        b.tempCanvas.height = g;
        for (var h = h.getImageData(0, 0, d, g).data, k = 0; 4 > k; k++) {
            var m = c[k].getContext("2d");
            m.getImageData(0, 0, d, g).data;
            b.tempCtx.drawImage(a, 0, 0);
            for (var n = b.tempCtx.getImageData(0,
                0, d, g), q = n.data, r = 0; r < h.length; r += 4) q[r] = 0 === k ? h[r] : 0, q[r + 1] = 1 === k ? h[r + 1] : 0, q[r + 2] = 2 === k ? h[r + 2] : 0, q[r + 3] = h[r + 3];
            m.putImageData(n, 0, 0)
        }
        a.onload = null
    }
    if (a.channelCache) return a.channelCache;
    var c = [cc.newElement("canvas"), cc.newElement("canvas"), cc.newElement("canvas"), cc.newElement("canvas")];
    try {
        b()
    } catch (d) {
        a.onload = b
    }
    return a.channelCache = c
};
cc.generateTextureCacheForColor.canvas = cc.newElement("canvas");
cc.generateTextureCacheForColor.tempCanvas = cc.newElement("canvas");
cc.generateTextureCacheForColor.tempCtx = cc.generateTextureCacheForColor.tempCanvas.getContext("2d");
cc.cutRotateImageToCanvas = function(a, b) {
    if (!a) return null;
    if (!b) return a;
    var c = cc.newElement("canvas");
    c.width = b.width;
    c.height = b.height;
    var d = c.getContext("2d");
    d.translate(c.width / 2, c.height / 2);
    d.rotate(-1.5707963267948966);
    d.drawImage(a, b.x, b.y, b.height, b.width, -b.height / 2, -b.width / 2, b.height, b.width);
    return c
};
cc._getCompositeOperationByBlendFunc = function(a) {
    return a ? a.src == cc.SRC_ALPHA && a.dst == cc.ONE || a.src == cc.ONE && a.dst == cc.ONE ? "lighter" : a.src == cc.ZERO && a.dst == cc.SRC_ALPHA ? "destination-in" : a.src == cc.ZERO && a.dst == cc.ONE_MINUS_SRC_ALPHA ? "destination-out" : "source" : "source"
};
cc.Sprite = cc.Node.extend({
    dirty: !1,
    atlasIndex: 0,
    textureAtlas: null,
    _batchNode: null,
    _recursiveDirty: null,
    _hasChildren: null,
    _shouldBeHidden: !1,
    _transformToBatch: null,
    _blendFunc: null,
    _texture: null,
    _rect: null,
    _rectRotated: !1,
    _offsetPosition: null,
    _unflippedOffsetPositionFromCenter: null,
    _opacityModifyRGB: !1,
    _flippedX: !1,
    _flippedY: !1,
    _textureLoaded: !1,
    _newTextureWhenChangeColor: null,
    _className: "Sprite",
    _oldDisplayColor: cc.color.WHITE,
    textureLoaded: function() {
        return this._textureLoaded
    },
    addLoadedEventListener: function(a,
        b) {
        this.addEventListener("load", a, b)
    },
    isDirty: function() {
        return this.dirty
    },
    setDirty: function(a) {
        this.dirty = a
    },
    isTextureRectRotated: function() {
        return this._rectRotated
    },
    getAtlasIndex: function() {
        return this.atlasIndex
    },
    setAtlasIndex: function(a) {
        this.atlasIndex = a
    },
    getTextureRect: function() {
        return cc.rect(this._rect)
    },
    getTextureAtlas: function() {
        return this.textureAtlas
    },
    setTextureAtlas: function(a) {
        this.textureAtlas = a
    },
    getOffsetPosition: function() {
        return cc.p(this._offsetPosition)
    },
    _getOffsetX: function() {
        return this._offsetPosition.x
    },
    _getOffsetY: function() {
        return this._offsetPosition.y
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    initWithSpriteFrame: function(a) {
        cc.assert(a, cc._LogInfos.Sprite_initWithSpriteFrame);
        a.textureLoaded() || (this._textureLoaded = !1, a.addEventListener("load", this._spriteFrameLoadedCallback, this));
        var b = cc._renderType === cc._RENDER_TYPE_CANVAS ? !1 : a._rotated,
            b = this.initWithTexture(a.getTexture(), a.getRect(), b);
        this.setSpriteFrame(a);
        return b
    },
    _spriteFrameLoadedCallback: null,
    initWithSpriteFrameName: function(a) {
        cc.assert(a,
            cc._LogInfos.Sprite_initWithSpriteFrameName);
        var b = cc.spriteFrameCache.getSpriteFrame(a);
        cc.assert(b, a + cc._LogInfos.Sprite_initWithSpriteFrameName1);
        return this.initWithSpriteFrame(b)
    },
    useBatchNode: function(a) {
        this.textureAtlas = a.textureAtlas;
        this._batchNode = a
    },
    setVertexRect: function(a) {
        var b = this._rect;
        b.x = a.x;
        b.y = a.y;
        b.width = a.width;
        b.height = a.height
    },
    sortAllChildren: function() {
        if (this._reorderChildDirty) {
            var a = this._children,
                b = a.length,
                c, d, e;
            for (c = 1; c < b; c++) {
                e = a[c];
                for (d = c - 1; 0 <= d;) {
                    if (e._localZOrder <
                        a[d]._localZOrder) a[d + 1] = a[d];
                    else if (e._localZOrder === a[d]._localZOrder && e.arrivalOrder < a[d].arrivalOrder) a[d + 1] = a[d];
                    else break;
                    d--
                }
                a[d + 1] = e
            }
            this._batchNode && this._arrayMakeObjectsPerformSelector(a, cc.Node._StateCallbackType.sortAllChildren);
            this._reorderChildDirty = !1
        }
    },
    reorderChild: function(a, b) {
        cc.assert(a, cc._LogInfos.Sprite_reorderChild_2); - 1 === this._children.indexOf(a) ? cc.log(cc._LogInfos.Sprite_reorderChild) : b !== a.zIndex && (this._batchNode && !this._reorderChildDirty && (this._setReorderChildDirtyRecursively(),
            this._batchNode.reorderBatch(!0)), cc.Node.prototype.reorderChild.call(this, a, b))
    },
    removeChild: function(a, b) {
        this._batchNode && this._batchNode.removeSpriteFromAtlas(a);
        cc.Node.prototype.removeChild.call(this, a, b)
    },
    setVisible: function(a) {
        cc.Node.prototype.setVisible.call(this, a);
        this.setDirtyRecursively(!0)
    },
    removeAllChildren: function(a) {
        var b = this._children,
            c = this._batchNode;
        if (c && null != b)
            for (var d = 0, e = b.length; d < e; d++) c.removeSpriteFromAtlas(b[d]);
        cc.Node.prototype.removeAllChildren.call(this, a);
        this._hasChildren = !1
    },
    setDirtyRecursively: function(a) {
        this.dirty = this._recursiveDirty = a;
        a = this._children;
        for (var b, c = a ? a.length : 0, d = 0; d < c; d++) b = a[d], b instanceof cc.Sprite && b.setDirtyRecursively(!0)
    },
    setNodeDirty: function(a) {
        cc.Node.prototype.setNodeDirty.call(this);
        !a && (this._batchNode && !this._recursiveDirty) && (this._hasChildren ? this.setDirtyRecursively(!0) : this.dirty = this._recursiveDirty = !0)
    },
    ignoreAnchorPointForPosition: function(a) {
        this._batchNode ? cc.log(cc._LogInfos.Sprite_ignoreAnchorPointForPosition) : cc.Node.prototype.ignoreAnchorPointForPosition.call(this,
            a)
    },
    setFlippedX: function(a) {
        this._flippedX != a && (this._flippedX = a, this.setTextureRect(this._rect, this._rectRotated, this._contentSize), this.setNodeDirty(!0))
    },
    setFlippedY: function(a) {
        this._flippedY != a && (this._flippedY = a, this.setTextureRect(this._rect, this._rectRotated, this._contentSize), this.setNodeDirty(!0))
    },
    isFlippedX: function() {
        return this._flippedX
    },
    isFlippedY: function() {
        return this._flippedY
    },
    setOpacityModifyRGB: null,
    isOpacityModifyRGB: function() {
        return this._opacityModifyRGB
    },
    updateDisplayedOpacity: null,
    setDisplayFrameWithAnimationName: function(a, b) {
        cc.assert(a, cc._LogInfos.Sprite_setDisplayFrameWithAnimationName_3);
        var c = cc.animationCache.getAnimation(a);
        c ? (c = c.getFrames()[b]) ? this.setSpriteFrame(c.getSpriteFrame()) : cc.log(cc._LogInfos.Sprite_setDisplayFrameWithAnimationName_2) : cc.log(cc._LogInfos.Sprite_setDisplayFrameWithAnimationName)
    },
    getBatchNode: function() {
        return this._batchNode
    },
    _setReorderChildDirtyRecursively: function() {
        if (!this._reorderChildDirty) {
            this._reorderChildDirty = !0;
            for (var a =
                this._parent; a && a != this._batchNode;) a._setReorderChildDirtyRecursively(), a = a.parent
        }
    },
    getTexture: function() {
        return this._texture
    },
    _quad: null,
    _quadWebBuffer: null,
    _quadDirty: !1,
    _colorized: !1,
    _blendFuncStr: "source",
    _originalTexture: null,
    _drawSize_Canvas: null,
    ctor: null,
    _softInit: function(a, b, c) {
        if (void 0 === a) cc.Sprite.prototype.init.call(this);
        else if (cc.isString(a)) "#" === a[0] ? (a = a.substr(1, a.length - 1), a = cc.spriteFrameCache.getSpriteFrame(a), this.initWithSpriteFrame(a)) : cc.Sprite.prototype.init.call(this,
            a, b);
        else if (cc.isObject(a))
            if (a instanceof cc.Texture2D) this.initWithTexture(a, b, c);
            else if (a instanceof cc.SpriteFrame) this.initWithSpriteFrame(a);
        else if (a instanceof HTMLImageElement || a instanceof HTMLCanvasElement) b = new cc.Texture2D, b.initWithElement(a), b.handleLoadedTexture(), this.initWithTexture(b)
    },
    getQuad: function() {
        return this._quad
    },
    setBlendFunc: null,
    init: null,
    initWithFile: function(a, b) {
        cc.assert(a, cc._LogInfos.Sprite_initWithFile);
        var c = cc.textureCache.getTextureForKey(a);
        if (c) {
            if (!b) {
                var d =
                    c.getContentSize();
                b = cc.rect(0, 0, d.width, d.height)
            }
            return this.initWithTexture(c, b)
        }
        c = cc.textureCache.addImage(a);
        return this.initWithTexture(c, b || cc.rect(0, 0, c._contentSize.width, c._contentSize.height))
    },
    initWithTexture: null,
    _textureLoadedCallback: null,
    setTextureRect: null,
    updateTransform: null,
    addChild: null,
    updateColor: function() {
        var a = this._displayedColor,
            b = this._displayedOpacity,
            a = {
                r: a.r,
                g: a.g,
                b: a.b,
                a: b
            };
        this._opacityModifyRGB && (a.r *= b / 255, a.g *= b / 255, a.b *= b / 255);
        b = this._quad;
        b.bl.colors = a;
        b.br.colors =
            a;
        b.tl.colors = a;
        b.tr.colors = a;
        this._batchNode && (this.atlasIndex != cc.Sprite.INDEX_NOT_INITIALIZED ? this.textureAtlas.updateQuad(b, this.atlasIndex) : this.dirty = !0);
        this._quadDirty = !0
    },
    setOpacity: null,
    setColor: null,
    updateDisplayedColor: null,
    setSpriteFrame: null,
    setDisplayFrame: function(a) {
        cc.log(cc._LogInfos.Sprite_setDisplayFrame);
        this.setSpriteFrame(a)
    },
    isFrameDisplayed: null,
    displayFrame: function() {
        return new cc.SpriteFrame(this._texture, cc.rectPointsToPixels(this._rect), this._rectRotated, cc.pointPointsToPixels(this._unflippedOffsetPositionFromCenter),
            cc.sizePointsToPixels(this._contentSize))
    },
    setBatchNode: null,
    setTexture: null,
    _updateBlendFunc: function() {
        this._batchNode ? cc.log(cc._LogInfos.Sprite__updateBlendFunc) : !this._texture || !this._texture.hasPremultipliedAlpha() ? (this._blendFunc.src = cc.SRC_ALPHA, this._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA, this.opacityModifyRGB = !1) : (this._blendFunc.src = cc.BLEND_SRC, this._blendFunc.dst = cc.BLEND_DST, this.opacityModifyRGB = !0)
    },
    _changeTextureColor: function() {
        var a, b = this._texture,
            c = this._rendererCmd._textureCoord;
        if (b && (c.validRect && this._originalTexture) && (a = b.getHtmlElementObj())) this._colorized = !0, a instanceof HTMLCanvasElement && !this._rectRotated && !this._newTextureWhenChangeColor && this._originalTexture._htmlElementObj != a ? cc.generateTintImageWithMultiply(this._originalTexture._htmlElementObj, this._displayedColor, c, a) : (a = cc.generateTintImageWithMultiply(this._originalTexture._htmlElementObj, this._displayedColor, c), b = new cc.Texture2D, b.initWithElement(a), b.handleLoadedTexture(), this.texture = b)
    },
    _setTextureCoords: function(a) {
        a =
            cc.rectPointsToPixels(a);
        var b = this._batchNode ? this.textureAtlas.texture : this._texture;
        if (b) {
            var c = b.pixelsWidth,
                d = b.pixelsHeight,
                e, f = this._quad;
            this._rectRotated ? (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (b = (2 * a.x + 1) / (2 * c), c = b + (2 * a.height - 2) / (2 * c), e = (2 * a.y + 1) / (2 * d), a = e + (2 * a.width - 2) / (2 * d)) : (b = a.x / c, c = (a.x + a.height) / c, e = a.y / d, a = (a.y + a.width) / d), this._flippedX && (d = e, e = a, a = d), this._flippedY && (d = b, b = c, c = d), f.bl.texCoords.u = b, f.bl.texCoords.v = e, f.br.texCoords.u = b, f.br.texCoords.v = a, f.tl.texCoords.u = c, f.tl.texCoords.v =
                e, f.tr.texCoords.u = c, f.tr.texCoords.v = a) : (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (b = (2 * a.x + 1) / (2 * c), c = b + (2 * a.width - 2) / (2 * c), e = (2 * a.y + 1) / (2 * d), a = e + (2 * a.height - 2) / (2 * d)) : (b = a.x / c, c = (a.x + a.width) / c, e = a.y / d, a = (a.y + a.height) / d), this._flippedX && (d = b, b = c, c = d), this._flippedY && (d = e, e = a, a = d), f.bl.texCoords.u = b, f.bl.texCoords.v = a, f.br.texCoords.u = c, f.br.texCoords.v = a, f.tl.texCoords.u = b, f.tl.texCoords.v = e, f.tr.texCoords.u = c, f.tr.texCoords.v = e);
            this._quadDirty = !0
        }
    }
});
cc.Sprite.create = function(a, b, c) {
    return new cc.Sprite(a, b, c)
};
cc.Sprite.createWithTexture = cc.Sprite.create;
cc.Sprite.createWithSpriteFrameName = cc.Sprite.create;
cc.Sprite.createWithSpriteFrame = cc.Sprite.create;
cc.Sprite.INDEX_NOT_INITIALIZED = -1;
cc._renderType === cc._RENDER_TYPE_CANVAS ? (_p = cc.Sprite.prototype, _p._spriteFrameLoadedCallback = function(a) {
        this.setNodeDirty(!0);
        this.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize());
        a = this.color;
        (255 !== a.r || 255 !== a.g || 255 !== a.b) && this._changeTextureColor();
        this.dispatchEvent("load")
    }, _p.setOpacityModifyRGB = function(a) {
        this._opacityModifyRGB !== a && (this._opacityModifyRGB = a, this.setNodeDirty(!0))
    }, _p.updateDisplayedOpacity = function(a) {
        cc.Node.prototype.updateDisplayedOpacity.call(this, a);
        this._setNodeDirtyForCache()
    }, _p.ctor = function(a, b, c) {
        cc.Node.prototype.ctor.call(this);
        this._shouldBeHidden = !1;
        this._offsetPosition = cc.p(0, 0);
        this._unflippedOffsetPositionFromCenter = cc.p(0, 0);
        this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        };
        this._rect = cc.rect(0, 0, 0, 0);
        this._newTextureWhenChangeColor = !1;
        this._textureLoaded = !0;
        this._drawSize_Canvas = cc.size(0, 0);
        this._softInit(a, b, c)
    }, _p._initRendererCmd = function() {
        this._rendererCmd = new cc.TextureRenderCmdCanvas(this)
    }, _p.setBlendFunc = function(a,
        b) {
        var c = this._blendFunc;
        void 0 === b ? (c.src = a.src, c.dst = a.dst) : (c.src = a, c.dst = b);
        cc._renderType === cc._RENDER_TYPE_CANVAS && (this._blendFuncStr = cc._getCompositeOperationByBlendFunc(c))
    }, _p.init = function() {
        if (0 < arguments.length) return this.initWithFile(arguments[0], arguments[1]);
        cc.Node.prototype.init.call(this);
        this.dirty = this._recursiveDirty = !1;
        this._opacityModifyRGB = !0;
        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;
        this.texture = null;
        this._textureLoaded = !0;
        this._flippedX = this._flippedY = !1;
        this.anchorY = this.anchorX = 0.5;
        this._offsetPosition.x = 0;
        this._offsetPosition.y = 0;
        this._hasChildren = !1;
        this.setTextureRect(cc.rect(0, 0, 0, 0), !1, cc.size(0, 0));
        return !0
    }, _p.initWithTexture = function(a, b, c) {
        cc.assert(0 != arguments.length, cc._LogInfos.CCSpriteBatchNode_initWithTexture);
        if ((c = c || !1) && a.isLoaded()) {
            var d = a.getHtmlElementObj(),
                d = cc.cutRotateImageToCanvas(d, b),
                e = new cc.Texture2D;
            e.initWithElement(d);
            e.handleLoadedTexture();
            a = e;
            this._rect = cc.rect(0, 0, b.width, b.height)
        }
        if (!cc.Node.prototype.init.call(this)) return !1;
        this._batchNode = null;
        this.dirty = this._recursiveDirty = !1;
        this._opacityModifyRGB = !0;
        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;
        this._flippedX = this._flippedY = !1;
        this.anchorY = this.anchorX = 0.5;
        this._offsetPosition.x = 0;
        this._offsetPosition.y = 0;
        this._hasChildren = !1;
        this._textureLoaded = d = a.isLoaded();
        if (!d) return this._rectRotated = c, b && (this._rect.x = b.x, this._rect.y = b.y, this._rect.width = b.width, this._rect.height = b.height), this.texture && this.texture.removeEventListener("load", this),
            a.addEventListener("load", this._textureLoadedCallback, this), this.texture = a, !0;
        b || (b = cc.rect(0, 0, a.width, a.height));
        a && a.url && (d = b.y + b.height, b.x + b.width > a.width && cc.error(cc._LogInfos.RectWidth, a.url), d > a.height && cc.error(cc._LogInfos.RectHeight, a.url));
        this.texture = this._originalTexture = a;
        this.setTextureRect(b, c);
        this.batchNode = null;
        return !0
    }, _p._textureLoadedCallback = function(a) {
        if (!this._textureLoaded) {
            this._textureLoaded = !0;
            var b = this._rect;
            b ? cc._rectEqualToZero(b) && (b.width = a.width, b.height =
                a.height) : b = cc.rect(0, 0, a.width, a.height);
            this.texture = this._originalTexture = a;
            this.setTextureRect(b, this._rectRotated);
            a = this._displayedColor;
            (255 != a.r || 255 != a.g || 255 != a.b) && this._changeTextureColor();
            this.batchNode = this._batchNode;
            this.dispatchEvent("load")
        }
    }, _p.setTextureRect = function(a, b, c) {
        this._rectRotated = b || !1;
        this.setContentSize(c || a);
        this.setVertexRect(a);
        b = this._rendererCmd._textureCoord;
        c = cc.contentScaleFactor();
        b.renderX = b.x = 0 | a.x * c;
        b.renderY = b.y = 0 | a.y * c;
        b.width = 0 | a.width * c;
        b.height =
            0 | a.height * c;
        b.validRect = !(0 === b.width || 0 === b.height || 0 > b.x || 0 > b.y);
        a = this._unflippedOffsetPositionFromCenter;
        this._flippedX && (a.x = -a.x);
        this._flippedY && (a.y = -a.y);
        this._offsetPosition.x = a.x + (this._contentSize.width - this._rect.width) / 2;
        this._offsetPosition.y = a.y + (this._contentSize.height - this._rect.height) / 2;
        this._batchNode && (this.dirty = !0)
    }, _p.updateTransform = function() {
        if (this.dirty) {
            var a = this._parent;
            !this._visible || a && a != this._batchNode && a._shouldBeHidden ? this._shouldBeHidden = !0 : (this._shouldBeHidden = !1, this._transformToBatch = !a || a == this._batchNode ? this.nodeToParentTransform() : cc.affineTransformConcat(this.nodeToParentTransform(), a._transformToBatch));
            this.dirty = this._recursiveDirty = !1
        }
        this._hasChildren && this._arrayMakeObjectsPerformSelector(this._children, cc.Node._StateCallbackType.updateTransform)
    }, _p.addChild = function(a, b, c) {
        cc.assert(a, cc._LogInfos.CCSpriteBatchNode_addChild_2);
        null == b && (b = a._localZOrder);
        null == c && (c = a.tag);
        cc.Node.prototype.addChild.call(this, a, b, c);
        this._hasChildren = !0
    },
    _p.setOpacity = function(a) {
        cc.Node.prototype.setOpacity.call(this, a);
        this._setNodeDirtyForCache()
    }, _p.setColor = function(a) {
        var b = this.color;
        this._oldDisplayColor = b;
        b.r === a.r && b.g === a.g && b.b === a.b || cc.Node.prototype.setColor.call(this, a)
    }, _p.updateDisplayedColor = function(a) {
        cc.Node.prototype.updateDisplayedColor.call(this, a);
        a = this._oldDisplayColor;
        var b = this._displayedColor;
        a.r === b.r && a.g === b.g && a.b === b.b || (this._changeTextureColor(), this._setNodeDirtyForCache())
    }, _p.setSpriteFrame = function(a) {
        var b =
            this;
        cc.isString(a) && (a = cc.spriteFrameCache.getSpriteFrame(a), cc.assert(a, cc._LogInfos.CCSpriteBatchNode_setSpriteFrame));
        b.setNodeDirty(!0);
        var c = a.getOffset();
        b._unflippedOffsetPositionFromCenter.x = c.x;
        b._unflippedOffsetPositionFromCenter.y = c.y;
        b._rectRotated = a.isRotated();
        var c = a.getTexture(),
            d = a.textureLoaded();
        d || (b._textureLoaded = !1, a.addEventListener("load", function(a) {
            b._textureLoaded = !0;
            var c = a.getTexture();
            c != b._texture && (b.texture = c);
            b.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize());
            b.dispatchEvent("load")
        }, b));
        c != b._texture && (b.texture = c);
        b._rectRotated && (b._originalTexture = c);
        b.setTextureRect(a.getRect(), b._rectRotated, a.getOriginalSize());
        b._colorized = !1;
        b._rendererCmd._textureCoord.renderX = b._rendererCmd._textureCoord.x;
        b._rendererCmd._textureCoord.renderY = b._rendererCmd._textureCoord.y;
        d && (a = b.color, (255 !== a.r || 255 !== a.g || 255 !== a.b) && b._changeTextureColor())
    }, _p.isFrameDisplayed = function(a) {
        return a.getTexture() != this._texture ? !1 : cc.rectEqualToRect(a.getRect(), this._rect)
    },
    _p.setBatchNode = function(a) {
        (this._batchNode = a) ? (this._transformToBatch = cc.affineTransformIdentity(), this.textureAtlas = this._batchNode.textureAtlas) : (this.atlasIndex = cc.Sprite.INDEX_NOT_INITIALIZED, this.textureAtlas = null, this.dirty = this._recursiveDirty = !1)
    }, _p.setTexture = function(a) {
        var b = this;
        if (a && cc.isString(a)) {
            a = cc.textureCache.addImage(a);
            b.setTexture(a);
            var c = a.getContentSize();
            b.setTextureRect(cc.rect(0, 0, c.width, c.height));
            a._isLoaded || a.addEventListener("load", function() {
                var c = a.getContentSize();
                b.setTextureRect(cc.rect(0, 0, c.width, c.height))
            }, this)
        } else cc.assert(!a || a instanceof cc.Texture2D, cc._LogInfos.CCSpriteBatchNode_setTexture), b._texture != a && (a && a.getHtmlElementObj() instanceof HTMLImageElement && (b._originalTexture = a), b._texture = a)
    }, cc.sys._supportCanvasNewBlendModes || (_p._changeTextureColor = function() {
        var a, b = this._texture,
            c = this._rendererCmd._textureCoord;
        if (b && (c.validRect && this._originalTexture) && (a = b.getHtmlElementObj()))
            if (b = cc.textureCache.getTextureColors(this._originalTexture.getHtmlElementObj())) this._colorized = !0, a instanceof HTMLCanvasElement && !this._rectRotated && !this._newTextureWhenChangeColor ? cc.generateTintImage(a, b, this._displayedColor, c, a) : (a = cc.generateTintImage(a, b, this._displayedColor, c), b = new cc.Texture2D, b.initWithElement(a), b.handleLoadedTexture(), this.texture = b)
    }), _p = null) : (cc.assert(cc.isFunction(cc._tmp.WebGLSprite), cc._LogInfos.MissingFile, "SpritesWebGL.js"), cc._tmp.WebGLSprite(), delete cc._tmp.WebGLSprite);
cc.EventHelper.prototype.apply(cc.Sprite.prototype);
cc.assert(cc.isFunction(cc._tmp.PrototypeSprite), cc._LogInfos.MissingFile, "SpritesPropertyDefine.js");
cc._tmp.PrototypeSprite();
delete cc._tmp.PrototypeSprite;
cc.DEFAULT_SPRITE_BATCH_CAPACITY = 29;
cc.SpriteBatchNode = cc.Node.extend({
    textureAtlas: null,
    _blendFunc: null,
    _descendants: null,
    _className: "SpriteBatchNode",
    addSpriteWithoutQuad: function(a, b, c) {
        cc.assert(a, cc._LogInfos.SpriteBatchNode_addSpriteWithoutQuad_2);
        if (!(a instanceof cc.Sprite)) return cc.log(cc._LogInfos.SpriteBatchNode_addSpriteWithoutQuad), null;
        a.atlasIndex = b;
        var d = 0,
            e = this._descendants;
        if (e && 0 < e.length)
            for (var f = 0; f < e.length; f++) {
                var g = e[f];
                g && g.atlasIndex >= b && ++d
            }
        e.splice(d, 0, a);
        cc.Node.prototype.addChild.call(this, a, b, c);
        this.reorderBatch(!1);
        return this
    },
    getTextureAtlas: function() {
        return this.textureAtlas
    },
    setTextureAtlas: function(a) {
        a != this.textureAtlas && (this.textureAtlas = a)
    },
    getDescendants: function() {
        return this._descendants
    },
    initWithFile: function(a, b) {
        var c = cc.textureCache.getTextureForKey(a);
        c || (c = cc.textureCache.addImage(a));
        return this.initWithTexture(c, b)
    },
    _setNodeDirtyForCache: function() {
        this._cacheDirty = !0
    },
    init: function(a, b) {
        var c = cc.textureCache.getTextureForKey(a);
        c || (c = cc.textureCache.addImage(a));
        return this.initWithTexture(c,
            b)
    },
    increaseAtlasCapacity: function() {
        var a = this.textureAtlas.capacity,
            b = Math.floor(4 * (a + 1) / 3);
        cc.log(cc._LogInfos.SpriteBatchNode_increaseAtlasCapacity, a, b);
        this.textureAtlas.resizeCapacity(b) || cc.log(cc._LogInfos.SpriteBatchNode_increaseAtlasCapacity_2)
    },
    removeChildAtIndex: function(a, b) {
        this.removeChild(this._children[a], b)
    },
    rebuildIndexInOrder: function(a, b) {
        var c = a.children;
        if (c && 0 < c.length)
            for (var d = 0; d < c.length; d++) {
                var e = c[d];
                e && 0 > e.zIndex && (b = this.rebuildIndexInOrder(e, b))
            }!a == this && (a.atlasIndex =
                b, b++);
        if (c && 0 < c.length)
            for (d = 0; d < c.length; d++)(e = c[d]) && 0 <= e.zIndex && (b = this.rebuildIndexInOrder(e, b));
        return b
    },
    highestAtlasIndexInChild: function(a) {
        var b = a.children;
        return !b || 0 == b.length ? a.atlasIndex : this.highestAtlasIndexInChild(b[b.length - 1])
    },
    lowestAtlasIndexInChild: function(a) {
        var b = a.children;
        return !b || 0 == b.length ? a.atlasIndex : this.lowestAtlasIndexInChild(b[b.length - 1])
    },
    atlasIndexForChild: function(a, b) {
        var c = a.parent,
            d = c.children,
            e = d.indexOf(a),
            f = null;
        0 < e && e < cc.UINT_MAX && (f = d[e - 1]);
        return c ==
            this ? 0 == e ? 0 : this.highestAtlasIndexInChild(f) + 1 : 0 == e ? 0 > b ? c.atlasIndex : c.atlasIndex + 1 : 0 > f.zIndex && 0 > b || 0 <= f.zIndex && 0 <= b ? this.highestAtlasIndexInChild(f) + 1 : c.atlasIndex + 1
    },
    reorderBatch: function(a) {
        this._reorderChildDirty = a
    },
    setBlendFunc: function(a, b) {
        this._blendFunc = void 0 === b ? a : {
            src: a,
            dst: b
        }
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    reorderChild: function(a, b) {
        cc.assert(a, cc._LogInfos.SpriteBatchNode_reorderChild_2); - 1 === this._children.indexOf(a) ? cc.log(cc._LogInfos.SpriteBatchNode_reorderChild) :
            b !== a.zIndex && (cc.Node.prototype.reorderChild.call(this, a, b), this.setNodeDirty())
    },
    removeChild: function(a, b) {
        null != a && (-1 === this._children.indexOf(a) ? cc.log(cc._LogInfos.SpriteBatchNode_removeChild) : (this.removeSpriteFromAtlas(a), cc.Node.prototype.removeChild.call(this, a, b)))
    },
    _textureForCanvas: null,
    _useCache: !1,
    _originalTexture: null,
    ctor: null,
    _ctorForCanvas: function(a, b) {
        cc.Node.prototype.ctor.call(this);
        var c;
        b = b || cc.DEFAULT_SPRITE_BATCH_CAPACITY;
        cc.isString(a) ? (c = cc.textureCache.getTextureForKey(a)) ||
            (c = cc.textureCache.addImage(a)) : a instanceof cc.Texture2D && (c = a);
        c && this.initWithTexture(c, b)
    },
    _ctorForWebGL: function(a, b) {
        cc.Node.prototype.ctor.call(this);
        var c;
        b = b || cc.DEFAULT_SPRITE_BATCH_CAPACITY;
        cc.isString(a) ? (c = cc.textureCache.getTextureForKey(a)) || (c = cc.textureCache.addImage(a)) : a instanceof cc.Texture2D && (c = a);
        c && this.initWithTexture(c, b)
    },
    _initRendererCmd: function() {
        cc._renderType === cc._RENDER_TYPE_WEBGL && (this._rendererCmd = new cc.SpriteBatchNodeRenderCmdWebGL(this))
    },
    updateQuadFromSprite: null,
    _updateQuadFromSpriteForCanvas: function(a, b) {
        cc.assert(a, cc._LogInfos.CCSpriteBatchNode_updateQuadFromSprite_2);
        a instanceof cc.Sprite ? (a.batchNode = this, a.atlasIndex = b, a.dirty = !0, a.updateTransform()) : cc.log(cc._LogInfos.CCSpriteBatchNode_updateQuadFromSprite)
    },
    _updateQuadFromSpriteForWebGL: function(a, b) {
        cc.assert(a, cc._LogInfos.CCSpriteBatchNode_updateQuadFromSprite);
        if (a instanceof cc.Sprite) {
            for (var c = this.textureAtlas.capacity; b >= c || c == this.textureAtlas.totalQuads;) this.increaseAtlasCapacity();
            a.batchNode = this;
            a.atlasIndex = b;
            a.dirty = !0;
            a.updateTransform()
        } else cc.log(cc._LogInfos.CCSpriteBatchNode_updateQuadFromSprite)
    },
    _swap: function(a, b) {
        var c = this._descendants,
            d = this.textureAtlas,
            e = d.quads,
            f = c[a],
            g = cc.V3F_C4B_T2F_QuadCopy(e[a]);
        c[b].atlasIndex = a;
        c[a] = c[b];
        d.updateQuad(e[b], a);
        c[b] = f;
        d.updateQuad(g, b)
    },
    insertQuadFromSprite: null,
    _insertQuadFromSpriteForCanvas: function(a, b) {
        cc.assert(a, cc._LogInfos.CCSpriteBatchNode_insertQuadFromSprite_2);
        a instanceof cc.Sprite ? (a.batchNode = this, a.atlasIndex =
            b, a.dirty = !0, a.updateTransform(), a._setCachedParent(this), this._children.splice(b, 0, a)) : cc.log(cc._LogInfos.CCSpriteBatchNode_insertQuadFromSprite)
    },
    _insertQuadFromSpriteForWebGL: function(a, b) {
        cc.assert(a, cc._LogInfos.Sprite_insertQuadFromSprite_2);
        if (a instanceof cc.Sprite) {
            for (var c = this.textureAtlas; b >= c.capacity || c.capacity === c.totalQuads;) this.increaseAtlasCapacity();
            a.batchNode = this;
            a.atlasIndex = b;
            c.insertQuad(a.quad, b);
            a.dirty = !0;
            a.updateTransform()
        } else cc.log(cc._LogInfos.Sprite_insertQuadFromSprite)
    },
    _updateAtlasIndex: function(a, b) {
        var c = 0,
            d = a.children;
        d && (c = d.length);
        var e = 0;
        if (0 === c) e = a.atlasIndex, a.atlasIndex = b, a.arrivalOrder = 0, e != b && this._swap(e, b), b++;
        else {
            e = !0;
            0 <= d[0].zIndex && (e = a.atlasIndex, a.atlasIndex = b, a.arrivalOrder = 0, e != b && this._swap(e, b), b++, e = !1);
            for (c = 0; c < d.length; c++) {
                var f = d[c];
                e && 0 <= f.zIndex && (e = a.atlasIndex, a.atlasIndex = b, a.arrivalOrder = 0, e != b && this._swap(e, b), b++, e = !1);
                b = this._updateAtlasIndex(f, b)
            }
            e && (e = a.atlasIndex, a.atlasIndex = b, a.arrivalOrder = 0, e != b && this._swap(e, b), b++)
        }
        return b
    },
    _updateBlendFunc: function() {
        this.textureAtlas.texture.hasPremultipliedAlpha() || (this._blendFunc.src = cc.SRC_ALPHA, this._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA)
    },
    initWithTexture: null,
    _initWithTextureForCanvas: function(a, b) {
        this._children = [];
        this._descendants = [];
        this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
        this._textureForCanvas = this._originalTexture = a;
        return !0
    },
    _initWithTextureForWebGL: function(a, b) {
        this._children = [];
        this._descendants = [];
        this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
        b = b || cc.DEFAULT_SPRITE_BATCH_CAPACITY;
        this.textureAtlas = new cc.TextureAtlas;
        this.textureAtlas.initWithTexture(a, b);
        this._updateBlendFunc();
        this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
        return !0
    },
    insertChild: function(a, b) {
        a.batchNode = this;
        a.atlasIndex = b;
        a.dirty = !0;
        var c = this.textureAtlas;
        c.totalQuads >= c.capacity && this.increaseAtlasCapacity();
        c.insertQuad(a.quad, b);
        this._descendants.splice(b, 0, a);
        var c = b + 1,
            d = this._descendants;
        if (d && 0 < d.length)
            for (; c < d.length; c++) d[c].atlasIndex++;
        var d = a.children,
            e;
        if (d) {
            c = 0;
            for (l = d.length || 0; c < l; c++)
                if (e = d[c]) {
                    var f = this.atlasIndexForChild(e, e.zIndex);
                    this.insertChild(e, f)
                }
        }
    },
    appendChild: null,
    _appendChildForCanvas: function(a) {
        this._reorderChildDirty = !0;
        a.batchNode = this;
        a.dirty = !0;
        this._descendants.push(a);
        a.atlasIndex = this._descendants.length - 1;
        a = a.children;
        for (var b = 0, c = a.length || 0; b < c; b++) this.appendChild(a[b])
    },
    _appendChildForWebGL: function(a) {
        this._reorderChildDirty = !0;
        a.batchNode = this;
        a.dirty = !0;
        this._descendants.push(a);
        var b = this._descendants.length -
            1;
        a.atlasIndex = b;
        var c = this.textureAtlas;
        c.totalQuads == c.capacity && this.increaseAtlasCapacity();
        c.insertQuad(a.quad, b);
        a = a.children;
        b = 0;
        for (c = a.length || 0; b < c; b++) this.appendChild(a[b])
    },
    removeSpriteFromAtlas: null,
    _removeSpriteFromAtlasForCanvas: function(a) {
        a.batchNode = null;
        var b = this._descendants,
            c = b.indexOf(a);
        if (-1 != c) {
            b.splice(c, 1);
            for (var d = b.length; c < d; ++c) b[c].atlasIndex--
        }
        if (a = a.children) {
            b = 0;
            for (c = a.length || 0; b < c; b++) a[b] && this.removeSpriteFromAtlas(a[b])
        }
    },
    _removeSpriteFromAtlasForWebGL: function(a) {
        this.textureAtlas.removeQuadAtIndex(a.atlasIndex);
        a.batchNode = null;
        var b = this._descendants,
            c = b.indexOf(a);
        if (-1 != c) {
            b.splice(c, 1);
            for (var d = b.length; c < d; ++c) b[c].atlasIndex--
        }
        if (a = a.children) {
            b = 0;
            for (c = a.length || 0; b < c; b++) a[b] && this.removeSpriteFromAtlas(a[b])
        }
    },
    getTexture: null,
    _getTextureForCanvas: function() {
        return this._textureForCanvas
    },
    _getTextureForWebGL: function() {
        return this.textureAtlas.texture
    },
    setTexture: null,
    _setTextureForCanvas: function(a) {
        this._textureForCanvas = a;
        for (var b = this._children, c = 0; c < b.length; c++) b[c].texture = a
    },
    _setTextureForWebGL: function(a) {
        this.textureAtlas.texture =
            a;
        this._updateBlendFunc()
    },
    visit: null,
    _visitForCanvas: function(a) {
        var b = a || cc._renderContext;
        if (this._visible) {
            b.save();
            this.transform(a);
            var c = this._children;
            if (c) {
                this.sortAllChildren();
                for (a = 0; a < c.length; a++) c[a] && c[a].visit(b)
            }
            b.restore()
        }
    },
    _visitForWebGL: function(a) {
        a = a || cc._renderContext;
        if (this._visible) {
            var b = cc.current_stack;
            b.stack.push(b.top);
            cc.kmMat4Assign(this._stackMatrix, b.top);
            b.top = this._stackMatrix;
            this.sortAllChildren();
            this.transform(a);
            this._rendererCmd && cc.renderer.pushRenderCommand(this._rendererCmd);
            b.top = b.stack.pop()
        }
    },
    addChild: null,
    _addChildForCanvas: function(a, b, c) {
        cc.assert(null != a, cc._LogInfos.CCSpriteBatchNode_addChild_3);
        a instanceof cc.Sprite ? (b = null == b ? a.zIndex : b, c = null == c ? a.tag : c, cc.Node.prototype.addChild.call(this, a, b, c), this.appendChild(a), this.setNodeDirty()) : cc.log(cc._LogInfos.CCSpriteBatchNode_addChild)
    },
    _addChildForWebGL: function(a, b, c) {
        cc.assert(null != a, cc._LogInfos.Sprite_addChild_6);
        a instanceof cc.Sprite ? a.texture != this.textureAtlas.texture ? cc.log(cc._LogInfos.Sprite_addChild_5) :
            (b = null == b ? a.zIndex : b, c = null == c ? a.tag : c, cc.Node.prototype.addChild.call(this, a, b, c), this.appendChild(a), this.setNodeDirty()) : cc.log(cc._LogInfos.Sprite_addChild_4)
    },
    removeAllChildren: null,
    _removeAllChildrenForCanvas: function(a) {
        var b = this._descendants;
        if (b && 0 < b.length)
            for (var c = 0, d = b.length; c < d; c++) b[c] && (b[c].batchNode = null);
        cc.Node.prototype.removeAllChildren.call(this, a);
        this._descendants.length = 0
    },
    _removeAllChildrenForWebGL: function(a) {
        var b = this._descendants;
        if (b && 0 < b.length)
            for (var c = 0, d = b.length; c <
                d; c++) b[c] && (b[c].batchNode = null);
        cc.Node.prototype.removeAllChildren.call(this, a);
        this._descendants.length = 0;
        this.textureAtlas.removeAllQuads()
    },
    sortAllChildren: null,
    _sortAllChildrenForCanvas: function() {
        if (this._reorderChildDirty) {
            var a, b = 0,
                c = this._children,
                d = c.length,
                e;
            for (a = 1; a < d; a++) {
                var f = c[a],
                    b = a - 1;
                for (e = c[b]; 0 <= b && (f._localZOrder < e._localZOrder || f._localZOrder == e._localZOrder && f.arrivalOrder < e.arrivalOrder);) c[b + 1] = e, b -= 1, e = c[b];
                c[b + 1] = f
            }
            0 < c.length && this._arrayMakeObjectsPerformSelector(c,
                cc.Node._StateCallbackType.sortAllChildren);
            this._reorderChildDirty = !1
        }
    },
    _sortAllChildrenForWebGL: function() {
        if (this._reorderChildDirty) {
            var a = this._children,
                b, c = 0,
                d = a.length,
                e;
            for (b = 1; b < d; b++) {
                var f = a[b],
                    c = b - 1;
                for (e = a[c]; 0 <= c && (f._localZOrder < e._localZOrder || f._localZOrder == e._localZOrder && f.arrivalOrder < e.arrivalOrder);) a[c + 1] = e, c -= 1, e = a[c];
                a[c + 1] = f
            }
            if (0 < a.length) {
                this._arrayMakeObjectsPerformSelector(a, cc.Node._StateCallbackType.sortAllChildren);
                for (b = c = 0; b < a.length; b++) c = this._updateAtlasIndex(a[b],
                    c)
            }
            this._reorderChildDirty = !1
        }
    },
    draw: null,
    _drawForWebGL: function() {
        0 !== this.textureAtlas.totalQuads && (this._shaderProgram.use(), this._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4(), this._arrayMakeObjectsPerformSelector(this._children, cc.Node._StateCallbackType.updateTransform), cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst), this.textureAtlas.drawQuads())
    }
});
_p = cc.SpriteBatchNode.prototype;
cc._renderType === cc._RENDER_TYPE_WEBGL ? (_p.ctor = _p._ctorForWebGL, _p.updateQuadFromSprite = _p._updateQuadFromSpriteForWebGL, _p.insertQuadFromSprite = _p._insertQuadFromSpriteForWebGL, _p.initWithTexture = _p._initWithTextureForWebGL, _p.appendChild = _p._appendChildForWebGL, _p.removeSpriteFromAtlas = _p._removeSpriteFromAtlasForWebGL, _p.getTexture = _p._getTextureForWebGL, _p.setTexture = _p._setTextureForWebGL, _p.visit = _p._visitForWebGL, _p.addChild = _p._addChildForWebGL, _p.removeAllChildren = _p._removeAllChildrenForWebGL,
    _p.sortAllChildren = _p._sortAllChildrenForWebGL, _p.draw = _p._drawForWebGL) : (_p.ctor = _p._ctorForCanvas, _p.updateQuadFromSprite = _p._updateQuadFromSpriteForCanvas, _p.insertQuadFromSprite = _p._insertQuadFromSpriteForCanvas, _p.initWithTexture = _p._initWithTextureForCanvas, _p.appendChild = _p._appendChildForCanvas, _p.removeSpriteFromAtlas = _p._removeSpriteFromAtlasForCanvas, _p.getTexture = _p._getTextureForCanvas, _p.setTexture = _p._setTextureForCanvas, _p.visit = _p._visitForCanvas, _p.removeAllChildren = _p._removeAllChildrenForCanvas,
    _p.addChild = _p._addChildForCanvas, _p.sortAllChildren = _p._sortAllChildrenForCanvas, _p.draw = cc.Node.prototype.draw);
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.defineGetterSetter(_p, "descendants", _p.getDescendants);
cc.SpriteBatchNode.create = function(a, b) {
    return new cc.SpriteBatchNode(a, b)
};
cc.SpriteBatchNode.createWithTexture = cc.SpriteBatchNode.create;
cc.BakeSprite = cc.Sprite.extend({
    _cacheCanvas: null,
    _cacheContext: null,
    ctor: function() {
        cc.Sprite.prototype.ctor.call(this);
        var a = document.createElement("canvas");
        a.width = a.height = 10;
        this._cacheCanvas = a;
        this._cacheContext = a.getContext("2d");
        var b = new cc.Texture2D;
        b.initWithElement(a);
        b.handleLoadedTexture();
        this.setTexture(b)
    },
    getCacheContext: function() {
        return this._cacheContext
    },
    getCacheCanvas: function() {
        return this._cacheCanvas
    },
    resetCanvasSize: function(a, b) {
        void 0 === b && (b = a.height, a = a.width);
        var c =
            this._cacheCanvas;
        c.width = a;
        c.height = b;
        this.getTexture().handleLoadedTexture();
        this.setTextureRect(cc.rect(0, 0, a, b), !1)
    }
});
cc.AnimationFrame = cc.Class.extend({
    _spriteFrame: null,
    _delayPerUnit: 0,
    _userInfo: null,
    ctor: function(a, b, c) {
        this._spriteFrame = a || null;
        this._delayPerUnit = b || 0;
        this._userInfo = c || null
    },
    clone: function() {
        var a = new cc.AnimationFrame;
        a.initWithSpriteFrame(this._spriteFrame.clone(), this._delayPerUnit, this._userInfo);
        return a
    },
    copyWithZone: function(a) {
        return cc.clone(this)
    },
    copy: function(a) {
        a = new cc.AnimationFrame;
        a.initWithSpriteFrame(this._spriteFrame.clone(), this._delayPerUnit, this._userInfo);
        return a
    },
    initWithSpriteFrame: function(a,
        b, c) {
        this._spriteFrame = a;
        this._delayPerUnit = b;
        this._userInfo = c;
        return !0
    },
    getSpriteFrame: function() {
        return this._spriteFrame
    },
    setSpriteFrame: function(a) {
        this._spriteFrame = a
    },
    getDelayUnits: function() {
        return this._delayPerUnit
    },
    setDelayUnits: function(a) {
        this._delayPerUnit = a
    },
    getUserInfo: function() {
        return this._userInfo
    },
    setUserInfo: function(a) {
        this._userInfo = a
    }
});
cc.AnimationFrame.create = function(a, b, c) {
    return new cc.AnimationFrame(a, b, c)
};
cc.Animation = cc.Class.extend({
    _frames: null,
    _loops: 0,
    _restoreOriginalFrame: !1,
    _duration: 0,
    _delayPerUnit: 0,
    _totalDelayUnits: 0,
    ctor: function(a, b, c) {
        this._frames = [];
        if (void 0 === a) this.initWithSpriteFrames(null, 0);
        else {
            var d = a[0];
            d && (d instanceof cc.SpriteFrame ? this.initWithSpriteFrames(a, b, c) : d instanceof cc.AnimationFrame && this.initWithAnimationFrames(a, b, c))
        }
    },
    getFrames: function() {
        return this._frames
    },
    setFrames: function(a) {
        this._frames = a
    },
    addSpriteFrame: function(a) {
        var b = new cc.AnimationFrame;
        b.initWithSpriteFrame(a,
            1, null);
        this._frames.push(b);
        this._totalDelayUnits++
    },
    addSpriteFrameWithFile: function(a) {
        a = cc.textureCache.addImage(a);
        var b = cc.rect(0, 0, 0, 0);
        b.width = a.width;
        b.height = a.height;
        a = new cc.SpriteFrame(a, b);
        this.addSpriteFrame(a)
    },
    addSpriteFrameWithTexture: function(a, b) {
        var c = new cc.SpriteFrame(a, b);
        this.addSpriteFrame(c)
    },
    initWithAnimationFrames: function(a, b, c) {
        cc.arrayVerifyType(a, cc.AnimationFrame);
        this._delayPerUnit = b;
        this._loops = void 0 === c ? 1 : c;
        this._totalDelayUnits = 0;
        b = this._frames;
        for (c = b.length =
            0; c < a.length; c++) {
            var d = a[c];
            b.push(d);
            this._totalDelayUnits += d.getDelayUnits()
        }
        return !0
    },
    clone: function() {
        var a = new cc.Animation;
        a.initWithAnimationFrames(this._copyFrames(), this._delayPerUnit, this._loops);
        a.setRestoreOriginalFrame(this._restoreOriginalFrame);
        return a
    },
    copyWithZone: function(a) {
        a = new cc.Animation;
        a.initWithAnimationFrames(this._copyFrames(), this._delayPerUnit, this._loops);
        a.setRestoreOriginalFrame(this._restoreOriginalFrame);
        return a
    },
    _copyFrames: function() {
        for (var a = [], b = 0; b < this._frames.length; b++) a.push(this._frames[b].clone());
        return a
    },
    copy: function(a) {
        return this.copyWithZone(null)
    },
    getLoops: function() {
        return this._loops
    },
    setLoops: function(a) {
        this._loops = a
    },
    setRestoreOriginalFrame: function(a) {
        this._restoreOriginalFrame = a
    },
    getRestoreOriginalFrame: function() {
        return this._restoreOriginalFrame
    },
    getDuration: function() {
        return this._totalDelayUnits * this._delayPerUnit
    },
    getDelayPerUnit: function() {
        return this._delayPerUnit
    },
    setDelayPerUnit: function(a) {
        this._delayPerUnit = a
    },
    getTotalDelayUnits: function() {
        return this._totalDelayUnits
    },
    initWithSpriteFrames: function(a, b, c) {
        cc.arrayVerifyType(a, cc.SpriteFrame);
        this._loops = void 0 === c ? 1 : c;
        this._delayPerUnit = b || 0;
        this._totalDelayUnits = 0;
        b = this._frames;
        b.length = 0;
        if (a) {
            for (c = 0; c < a.length; c++) {
                var d = a[c],
                    e = new cc.AnimationFrame;
                e.initWithSpriteFrame(d, 1, null);
                b.push(e)
            }
            this._totalDelayUnits += a.length
        }
        return !0
    },
    retain: function() {},
    release: function() {}
});
cc.Animation.create = function(a, b, c) {
    return new cc.Animation(a, b, c)
};
cc.Animation.createWithAnimationFrames = cc.Animation.create;
cc.animationCache = {
    _animations: {},
    addAnimation: function(a, b) {
        this._animations[b] = a
    },
    removeAnimation: function(a) {
        a && this._animations[a] && delete this._animations[a]
    },
    getAnimation: function(a) {
        return this._animations[a] ? this._animations[a] : null
    },
    _addAnimationsWithDictionary: function(a, b) {
        var c = a.animations;
        if (c) {
            var d = 1,
                e = a.properties;
            if (e)
                for (var d = null != e.format ? parseInt(e.format) : d, e = e.spritesheets, f = cc.spriteFrameCache, g = cc.path, h = 0; h < e.length; h++) f.addSpriteFrames(g.changeBasename(b, e[h]));
            switch (d) {
                case 1:
                    this._parseVersion1(c);
                    break;
                case 2:
                    this._parseVersion2(c);
                    break;
                default:
                    cc.log(cc._LogInfos.animationCache__addAnimationsWithDictionary_2)
            }
        } else cc.log(cc._LogInfos.animationCache__addAnimationsWithDictionary)
    },
    addAnimations: function(a) {
        cc.assert(a, cc._LogInfos.animationCache_addAnimations_2);
        var b = cc.loader.getRes(a);
        b ? this._addAnimationsWithDictionary(b, a) : cc.log(cc._LogInfos.animationCache_addAnimations)
    },
    _parseVersion1: function(a) {
        var b = cc.spriteFrameCache,
            c;
        for (c in a) {
            var d = a[c],
                e = d.frames,
                d = parseFloat(d.delay) ||
                0,
                f = null;
            if (e) {
                for (var f = [], g = 0; g < e.length; g++) {
                    var h = b.getSpriteFrame(e[g]);
                    if (h) {
                        var k = new cc.AnimationFrame;
                        k.initWithSpriteFrame(h, 1, null);
                        f.push(k)
                    } else cc.log(cc._LogInfos.animationCache__parseVersion1_2, c, e[g])
                }
                0 === f.length ? cc.log(cc._LogInfos.animationCache__parseVersion1_3, c) : (f.length != e.length && cc.log(cc._LogInfos.animationCache__parseVersion1_4, c), f = new cc.Animation(f, d, 1), cc.animationCache.addAnimation(f, c))
            } else cc.log(cc._LogInfos.animationCache__parseVersion1, c)
        }
    },
    _parseVersion2: function(a) {
        var b =
            cc.spriteFrameCache,
            c;
        for (c in a) {
            var d = a[c],
                e = d.loop,
                f = parseInt(d.loops),
                e = e ? cc.REPEAT_FOREVER : isNaN(f) ? 1 : f,
                f = d.restoreOriginalFrame && !0 == d.restoreOriginalFrame ? !0 : !1,
                g = d.frames;
            if (g) {
                for (var h = [], k = 0; k < g.length; k++) {
                    var m = g[k],
                        n = m.spriteframe,
                        q = b.getSpriteFrame(n);
                    if (q) {
                        var n = parseFloat(m.delayUnits) || 0,
                            m = m.notification,
                            r = new cc.AnimationFrame;
                        r.initWithSpriteFrame(q, n, m);
                        h.push(r)
                    } else cc.log(cc._LogInfos.animationCache__parseVersion2_2, c, n)
                }
                d = parseFloat(d.delayPerUnit) || 0;
                g = new cc.Animation;
                g.initWithAnimationFrames(h,
                    d, e);
                g.setRestoreOriginalFrame(f);
                cc.animationCache.addAnimation(g, c)
            } else cc.log(cc._LogInfos.animationCache__parseVersion2, c)
        }
    },
    _clear: function() {
        this._animations = {}
    }
};
cc.SpriteFrame = cc.Class.extend({
    _offset: null,
    _originalSize: null,
    _rectInPixels: null,
    _rotated: !1,
    _rect: null,
    _offsetInPixels: null,
    _originalSizeInPixels: null,
    _texture: null,
    _textureFilename: "",
    _textureLoaded: !1,
    ctor: function(a, b, c, d, e) {
        this._offset = cc.p(0, 0);
        this._offsetInPixels = cc.p(0, 0);
        this._originalSize = cc.size(0, 0);
        this._rotated = !1;
        this._originalSizeInPixels = cc.size(0, 0);
        this._textureFilename = "";
        this._texture = null;
        this._textureLoaded = !1;
        void 0 !== a && void 0 !== b && (void 0 === c || void 0 === d || void 0 === e ?
            this.initWithTexture(a, b) : this.initWithTexture(a, b, c, d, e))
    },
    textureLoaded: function() {
        return this._textureLoaded
    },
    addLoadedEventListener: function(a, b) {
        this.addEventListener("load", a, b)
    },
    getRectInPixels: function() {
        var a = this._rectInPixels;
        return cc.rect(a.x, a.y, a.width, a.height)
    },
    setRectInPixels: function(a) {
        this._rectInPixels || (this._rectInPixels = cc.rect(0, 0, 0, 0));
        this._rectInPixels.x = a.x;
        this._rectInPixels.y = a.y;
        this._rectInPixels.width = a.width;
        this._rectInPixels.height = a.height;
        this._rect = cc.rectPixelsToPoints(a)
    },
    isRotated: function() {
        return this._rotated
    },
    setRotated: function(a) {
        this._rotated = a
    },
    getRect: function() {
        var a = this._rect;
        return cc.rect(a.x, a.y, a.width, a.height)
    },
    setRect: function(a) {
        this._rect || (this._rect = cc.rect(0, 0, 0, 0));
        this._rect.x = a.x;
        this._rect.y = a.y;
        this._rect.width = a.width;
        this._rect.height = a.height;
        this._rectInPixels = cc.rectPointsToPixels(this._rect)
    },
    getOffsetInPixels: function() {
        return cc.p(this._offsetInPixels)
    },
    setOffsetInPixels: function(a) {
        this._offsetInPixels.x = a.x;
        this._offsetInPixels.y =
            a.y;
        cc._pointPixelsToPointsOut(this._offsetInPixels, this._offset)
    },
    getOriginalSizeInPixels: function() {
        return cc.size(this._originalSizeInPixels)
    },
    setOriginalSizeInPixels: function(a) {
        this._originalSizeInPixels.width = a.width;
        this._originalSizeInPixels.height = a.height
    },
    getOriginalSize: function() {
        return cc.size(this._originalSize)
    },
    setOriginalSize: function(a) {
        this._originalSize.width = a.width;
        this._originalSize.height = a.height
    },
    getTexture: function() {
        if (this._texture) return this._texture;
        if ("" !== this._textureFilename) {
            var a =
                cc.textureCache.addImage(this._textureFilename);
            a && (this._textureLoaded = a.isLoaded());
            return a
        }
        return null
    },
    setTexture: function(a) {
        if (this._texture != a) {
            var b = a.isLoaded();
            this._textureLoaded = b;
            this._texture = a;
            b || a.addEventListener("load", function(a) {
                this._textureLoaded = !0;
                if (this._rotated && cc._renderType === cc._RENDER_TYPE_CANVAS) {
                    var b = a.getHtmlElementObj(),
                        b = cc.cutRotateImageToCanvas(b, this.getRect()),
                        e = new cc.Texture2D;
                    e.initWithElement(b);
                    e.handleLoadedTexture();
                    this.setTexture(e);
                    b = this.getRect();
                    this.setRect(cc.rect(0, 0, b.width, b.height))
                }
                b = this._rect;
                0 === b.width && 0 === b.height && (b = a.width, a = a.height, this._rect.width = b, this._rect.height = a, this._rectInPixels = cc.rectPointsToPixels(this._rect), this._originalSizeInPixels.width = this._rectInPixels.width, this._originalSizeInPixels.height = this._rectInPixels.height, this._originalSize.width = b, this._originalSize.height = a);
                this.dispatchEvent("load")
            }, this)
        }
    },
    getOffset: function() {
        return cc.p(this._offset)
    },
    setOffset: function(a) {
        this._offset.x = a.x;
        this._offset.y =
            a.y
    },
    clone: function() {
        var a = new cc.SpriteFrame;
        a.initWithTexture(this._textureFilename, this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels);
        a.setTexture(this._texture);
        return a
    },
    copyWithZone: function() {
        var a = new cc.SpriteFrame;
        a.initWithTexture(this._textureFilename, this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels);
        a.setTexture(this._texture);
        return a
    },
    copy: function() {
        return this.copyWithZone()
    },
    initWithTexture: function(a, b, c, d, e) {
        2 === arguments.length &&
            (b = cc.rectPointsToPixels(b));
        d = d || cc.p(0, 0);
        e = e || b;
        c = c || !1;
        cc.isString(a) ? (this._texture = null, this._textureFilename = a) : a instanceof cc.Texture2D && this.setTexture(a);
        a = this.getTexture();
        this._rectInPixels = b;
        b = this._rect = cc.rectPixelsToPoints(b);
        if (a && a.url && a.isLoaded()) {
            var f, g;
            c ? (f = b.x + b.height, g = b.y + b.width) : (f = b.x + b.width, g = b.y + b.height);
            f > a.getPixelsWide() && cc.error(cc._LogInfos.RectWidth, a.url);
            g > a.getPixelsHigh() && cc.error(cc._LogInfos.RectHeight, a.url)
        }
        this._offsetInPixels.x = d.x;
        this._offsetInPixels.y =
            d.y;
        cc._pointPixelsToPointsOut(d, this._offset);
        this._originalSizeInPixels.width = e.width;
        this._originalSizeInPixels.height = e.height;
        cc._sizePixelsToPointsOut(e, this._originalSize);
        this._rotated = c;
        return !0
    }
});
cc.EventHelper.prototype.apply(cc.SpriteFrame.prototype);
cc.SpriteFrame.create = function(a, b, c, d, e) {
    return new cc.SpriteFrame(a, b, c, d, e)
};
cc.SpriteFrame.createWithTexture = cc.SpriteFrame.create;
cc.SpriteFrame._frameWithTextureForCanvas = function(a, b, c, d, e) {
    var f = new cc.SpriteFrame;
    f._texture = a;
    f._rectInPixels = b;
    f._rect = cc.rectPixelsToPoints(b);
    f._offsetInPixels.x = d.x;
    f._offsetInPixels.y = d.y;
    cc._pointPixelsToPointsOut(f._offsetInPixels, f._offset);
    f._originalSizeInPixels.width = e.width;
    f._originalSizeInPixels.height = e.height;
    cc._sizePixelsToPointsOut(f._originalSizeInPixels, f._originalSize);
    f._rotated = c;
    return f
};
cc.spriteFrameCache = {
    _CCNS_REG1: /^\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*$/,
    _CCNS_REG2: /^\s*\{\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*,\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*\}\s*$/,
    _spriteFrames: {},
    _spriteFramesAliases: {},
    _frameConfigCache: {},
    _rectFromString: function(a) {
        a = this._CCNS_REG2.exec(a);
        return !a ? cc.rect(0, 0, 0, 0) : cc.rect(parseFloat(a[1]), parseFloat(a[2]), parseFloat(a[3]), parseFloat(a[4]))
    },
    _pointFromString: function(a) {
        a = this._CCNS_REG1.exec(a);
        return !a ? cc.p(0, 0) : cc.p(parseFloat(a[1]), parseFloat(a[2]))
    },
    _sizeFromString: function(a) {
        a = this._CCNS_REG1.exec(a);
        return !a ? cc.size(0, 0) : cc.size(parseFloat(a[1]), parseFloat(a[2]))
    },
    _getFrameConfig: function(a) {
        var b = cc.loader.getRes(a);
        cc.assert(b, cc._LogInfos.spriteFrameCache__getFrameConfig_2, a);
        cc.loader.release(a);
        if (b._inited) return this._frameConfigCache[a] = b;
        var c = b.frames,
            d = b.metadata || b.meta,
            b = {},
            e = {},
            f = 0;
        d && (f = d.format, f = 1 >= f.length ? parseInt(f) : f, e.image = d.textureFileName || d.textureFileName ||
            d.image);
        for (var g in c) {
            var h = c[g];
            if (h) {
                d = {};
                if (0 == f) {
                    d.rect = cc.rect(h.x, h.y, h.width, h.height);
                    d.rotated = !1;
                    d.offset = cc.p(h.offsetX, h.offsetY);
                    var k = h.originalWidth,
                        h = h.originalHeight;
                    (!k || !h) && cc.log(cc._LogInfos.spriteFrameCache__getFrameConfig);
                    k = Math.abs(k);
                    h = Math.abs(h);
                    d.size = cc.size(k, h)
                } else if (1 == f || 2 == f) d.rect = this._rectFromString(h.frame), d.rotated = h.rotated || !1, d.offset = this._pointFromString(h.offset), d.size = this._sizeFromString(h.sourceSize);
                else if (3 == f) {
                    var k = this._sizeFromString(h.spriteSize),
                        m = this._rectFromString(h.textureRect);
                    k && (m = cc.rect(m.x, m.y, k.width, k.height));
                    d.rect = m;
                    d.rotated = h.textureRotated || !1;
                    d.offset = this._pointFromString(h.spriteOffset);
                    d.size = this._sizeFromString(h.spriteSourceSize);
                    d.aliases = h.aliases
                } else k = h.frame, m = h.sourceSize, g = h.filename || g, d.rect = cc.rect(k.x, k.y, k.w, k.h), d.rotated = h.rotated || !1, d.offset = cc.p(0, 0), d.size = cc.size(m.w, m.h);
                b[g] = d
            }
        }
        return this._frameConfigCache[a] = {
            _inited: !0,
            frames: b,
            meta: e
        }
    },
    addSpriteFrames: function(a, b) {
        cc.assert(a, cc._LogInfos.spriteFrameCache_addSpriteFrames_2);
        var c = this._frameConfigCache[a] || cc.loader.getRes(a);
        if (c && c.frames) {
            var d = this._frameConfigCache[a] || this._getFrameConfig(a),
                c = d.frames,
                d = d.meta;
            b ? b instanceof cc.Texture2D || (cc.isString(b) ? b = cc.textureCache.addImage(b) : cc.assert(0, cc._LogInfos.spriteFrameCache_addSpriteFrames_3)) : (d = cc.path.changeBasename(a, d.image || ".png"), b = cc.textureCache.addImage(d));
            var d = this._spriteFramesAliases,
                e = this._spriteFrames,
                f;
            for (f in c) {
                var g = c[f],
                    h = e[f];
                if (!h) {
                    h = new cc.SpriteFrame(b, g.rect, g.rotated, g.offset, g.size);
                    if (g = g.aliases)
                        for (var k = 0, m = g.length; k < m; k++) {
                            var n = g[k];
                            d[n] && cc.log(cc._LogInfos.spriteFrameCache_addSpriteFrames, n);
                            d[n] = f
                        }
                    cc._renderType === cc._RENDER_TYPE_CANVAS && h.isRotated() && h.getTexture().isLoaded() && (g = h.getTexture().getHtmlElementObj(), g = cc.cutRotateImageToCanvas(g, h.getRectInPixels()), k = new cc.Texture2D, k.initWithElement(g), k.handleLoadedTexture(), h.setTexture(k), g = h._rect, h.setRect(cc.rect(0, 0, g.width, g.height)));
                    e[f] = h
                }
            }
        }
    },
    _checkConflict: function(a) {
        a = a.frames;
        for (var b in a) this._spriteFrames[b] &&
            cc.log(cc._LogInfos.spriteFrameCache__checkConflict, b)
    },
    addSpriteFrame: function(a, b) {
        this._spriteFrames[b] = a
    },
    removeSpriteFrames: function() {
        this._spriteFrames = {};
        this._spriteFramesAliases = {}
    },
    removeSpriteFrameByName: function(a) {
        a && (this._spriteFramesAliases[a] && delete this._spriteFramesAliases[a], this._spriteFrames[a] && delete this._spriteFrames[a])
    },
    removeSpriteFramesFromFile: function(a) {
        var b = this._spriteFrames,
            c = this._spriteFramesAliases;
        if (a = this._frameConfigCache[a]) {
            a = a.frames;
            for (var d in a)
                if (b[d]) {
                    delete b[d];
                    for (var e in c) c[e] == d && delete c[e]
                }
        }
    },
    removeSpriteFramesFromTexture: function(a) {
        var b = this._spriteFrames,
            c = this._spriteFramesAliases,
            d;
        for (d in b) {
            var e = b[d];
            if (e && e.getTexture() == a) {
                delete b[d];
                for (var f in c) c[f] == d && delete c[f]
            }
        }
    },
    getSpriteFrame: function(a) {
        var b = this._spriteFrames[a];
        if (!b) {
            var c = this._spriteFramesAliases[a];
            c && ((b = this._spriteFrames[c.toString()]) || delete this._spriteFramesAliases[a])
        }
        b || cc.log(cc._LogInfos.spriteFrameCache_getSpriteFrame, a);
        return b
    },
    _clear: function() {
        this._spriteFrames = {};
        this._spriteFramesAliases = {};
        this._frameConfigCache = {}
    }
};
cc.configuration = {
    ERROR: 0,
    STRING: 1,
    INT: 2,
    DOUBLE: 3,
    BOOLEAN: 4,
    _maxTextureSize: 0,
    _maxModelviewStackDepth: 0,
    _supportsPVRTC: !1,
    _supportsNPOT: !1,
    _supportsBGRA8888: !1,
    _supportsDiscardFramebuffer: !1,
    _supportsShareableVAO: !1,
    _maxSamplesAllowed: 0,
    _maxTextureUnits: 0,
    _GlExtensions: "",
    _valueDict: {},
    _inited: !1,
    _init: function() {
        var a = this._valueDict;
        a["cocos2d.x.version"] = cc.ENGINE_VERSION;
        a["cocos2d.x.compiled_with_profiler"] = !1;
        a["cocos2d.x.compiled_with_gl_state_cache"] = cc.ENABLE_GL_STATE_CACHE;
        this._inited = !0
    },
    getMaxTextureSize: function() {
        return this._maxTextureSize
    },
    getMaxModelviewStackDepth: function() {
        return this._maxModelviewStackDepth
    },
    getMaxTextureUnits: function() {
        return this._maxTextureUnits
    },
    supportsNPOT: function() {
        return this._supportsNPOT
    },
    supportsPVRTC: function() {
        return this._supportsPVRTC
    },
    supportsETC: function() {
        return !1
    },
    supportsS3TC: function() {
        return !1
    },
    supportsATITC: function() {
        return !1
    },
    supportsBGRA8888: function() {
        return this._supportsBGRA8888
    },
    supportsDiscardFramebuffer: function() {
        return this._supportsDiscardFramebuffer
    },
    supportsShareableVAO: function() {
        return this._supportsShareableVAO
    },
    checkForGLExtension: function(a) {
        return -1 < this._GlExtensions.indexOf(a)
    },
    getValue: function(a, b) {
        this._inited || this._init();
        var c = this._valueDict;
        return c[a] ? c[a] : b
    },
    setValue: function(a, b) {
        this._valueDict[a] = b
    },
    dumpInfo: function() {
        0 === cc.ENABLE_GL_STATE_CACHE && (cc.log(""), cc.log(cc._LogInfos.configuration_dumpInfo), cc.log(""))
    },
    gatherGPUInfo: function() {
        if (cc._renderType !== cc._RENDER_TYPE_CANVAS) {
            this._inited || this._init();
            var a = cc._renderContext,
                b = this._valueDict;
            b["gl.vendor"] = a.getParameter(a.VENDOR);
            b["gl.renderer"] = a.getParameter(a.RENDERER);
            b["gl.version"] = a.getParameter(a.VERSION);
            this._GlExtensions = "";
            for (var c = a.getSupportedExtensions(), d = 0; d < c.length; d++) this._GlExtensions += c[d] + " ";
            this._maxTextureSize = a.getParameter(a.MAX_TEXTURE_SIZE);
            b["gl.max_texture_size"] = this._maxTextureSize;
            this._maxTextureUnits = a.getParameter(a.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
            b["gl.max_texture_units"] = this._maxTextureUnits;
            this._supportsPVRTC = this.checkForGLExtension("GL_IMG_texture_compression_pvrtc");
            b["gl.supports_PVRTC"] = this._supportsPVRTC;
            this._supportsNPOT = !1;
            b["gl.supports_NPOT"] = this._supportsNPOT;
            this._supportsBGRA8888 = this.checkForGLExtension("GL_IMG_texture_format_BGRA888");
            b["gl.supports_BGRA8888"] = this._supportsBGRA8888;
            this._supportsDiscardFramebuffer = this.checkForGLExtension("GL_EXT_discard_framebuffer");
            b["gl.supports_discard_framebuffer"] = this._supportsDiscardFramebuffer;
            this._supportsShareableVAO = this.checkForGLExtension("vertex_array_object");
            b["gl.supports_vertex_array_object"] =
                this._supportsShareableVAO;
            cc.checkGLErrorDebug()
        }
    },
    loadConfigFile: function(a) {
        this._inited || this._init();
        var b = cc.loader.getRes(a);
        if (!b) throw "Please load the resource first : " + a;
        cc.assert(b, cc._LogInfos.configuration_loadConfigFile_2, a);
        if (b = b.data)
            for (var c in b) this._valueDict[c] = b[c];
        else cc.log(cc._LogInfos.configuration_loadConfigFile, a)
    }
};
cc._tmp.DirectorWebGL = function() {
    cc.DirectorDelegate = cc.Class.extend({
        updateProjection: function() {}
    });
    var a = cc.Director.prototype;
    a.setProjection = function(a) {
        var c = this._winSizeInPoints;
        this.setViewport();
        var d = this._openGLView,
            e = d._viewPortRect.x / d._scaleX,
            f = d._viewPortRect.y / d._scaleY;
        switch (a) {
            case cc.Director.PROJECTION_2D:
                cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
                cc.kmGLLoadIdentity();
                d = new cc.kmMat4;
                cc.kmMat4OrthographicProjection(d, 0, c.width, 0, c.height, -1024, 1024);
                cc.kmGLMultMatrix(d);
                cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
                cc.kmGLLoadIdentity();
                break;
            case cc.Director.PROJECTION_3D:
                var g = this.getZEye(),
                    h = new cc.kmMat4,
                    d = new cc.kmMat4;
                cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
                cc.kmGLLoadIdentity();
                cc.kmMat4PerspectiveProjection(h, 60, c.width / c.height, 0.1, 2 * g);
                cc.kmGLMultMatrix(h);
                cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
                cc.kmGLLoadIdentity();
                g = cc.kmVec3Fill(null, -e + c.width / 2, -f + c.height / 2, g);
                c = cc.kmVec3Fill(null, -e + c.width / 2, -f + c.height / 2, 0);
                e = cc.kmVec3Fill(null, 0, 1, 0);
                cc.kmMat4LookAt(d, g, c, e);
                cc.kmGLMultMatrix(d);
                break;
            case cc.Director.PROJECTION_CUSTOM:
                this._projectionDelegate &&
                    this._projectionDelegate.updateProjection();
                break;
            default:
                cc.log(cc._LogInfos.Director_setProjection)
        }
        this._projection = a;
        cc.eventManager.dispatchEvent(this._eventProjectionChanged);
        cc.setProjectionMatrixDirty();
        cc.renderer.childrenOrderDirty = !0
    };
    a.setDepthTest = function(a) {
        var c = cc._renderContext;
        a ? (c.clearDepth(1), c.enable(c.DEPTH_TEST), c.depthFunc(c.LEQUAL)) : c.disable(c.DEPTH_TEST)
    };
    a.setOpenGLView = function(a) {
        this._winSizeInPoints.width = cc._canvas.width;
        this._winSizeInPoints.height = cc._canvas.height;
        this._openGLView = a || cc.view;
        a = cc.configuration;
        a.gatherGPUInfo();
        a.dumpInfo();
        this._createStatsLabel();
        this.setGLDefaultValues();
        cc.eventManager && cc.eventManager.setEnabled(!0)
    };
    a._clear = function() {
        var a = cc._renderContext;
        a.clear(a.COLOR_BUFFER_BIT | a.DEPTH_BUFFER_BIT)
    };
    a._beforeVisitScene = function() {
        cc.kmGLPushMatrix()
    };
    a._afterVisitScene = function() {
        cc.kmGLPopMatrix()
    };
    a._createStatsLabel = function() {
        if (cc.LabelAtlas) {
            if (!(null == cc.Director._fpsImageLoaded || !1 == cc.Director._fpsImageLoaded)) {
                var a =
                    new cc.Texture2D;
                a.initWithElement(cc.Director._fpsImage);
                a.handleLoadedTexture();
                var c = cc.view.getDesignResolutionSize().height / 320;
                0 === c && (c = this._winSizeInPoints.height / 320);
                var d = new cc.LabelAtlas;
                d._setIgnoreContentScaleFactor(!0);
                d.initWithString("00.0", a, 12, 32, ".");
                d.scale = c;
                this._FPSLabel = d;
                d = new cc.LabelAtlas;
                d._setIgnoreContentScaleFactor(!0);
                d.initWithString("0.000", a, 12, 32, ".");
                d.scale = c;
                this._SPFLabel = d;
                d = new cc.LabelAtlas;
                d._setIgnoreContentScaleFactor(!0);
                d.initWithString("000", a, 12,
                    32, ".");
                d.scale = c;
                this._drawsLabel = d;
                a = cc.DIRECTOR_STATS_POSITION;
                this._drawsLabel.setPosition(a.x, 34 * c + a.y);
                this._SPFLabel.setPosition(a.x, 17 * c + a.y);
                this._FPSLabel.setPosition(a)
            }
        } else this._createStatsLabelForCanvas()
    };
    a._createStatsLabelForCanvas = function() {
        var a = 0,
            a = this._winSizeInPoints.width > this._winSizeInPoints.height ? 0 | 24 * (this._winSizeInPoints.height / 320) : 0 | 24 * (this._winSizeInPoints.width / 320);
        this._FPSLabel = new cc.LabelTTF("000.0", "Arial", a);
        this._SPFLabel = new cc.LabelTTF("0.000", "Arial",
            a);
        this._drawsLabel = new cc.LabelTTF("0000", "Arial", a);
        a = cc.DIRECTOR_STATS_POSITION;
        this._drawsLabel.setPosition(this._drawsLabel.width / 2 + a.x, 5 * this._drawsLabel.height / 2 + a.y);
        this._SPFLabel.setPosition(this._SPFLabel.width / 2 + a.x, 3 * this._SPFLabel.height / 2 + a.y);
        this._FPSLabel.setPosition(this._FPSLabel.width / 2 + a.x, this._FPSLabel.height / 2 + a.y)
    };
    a.convertToGL = function(a) {
        var c = new cc.kmMat4;
        cc.GLToClipTransform(c);
        var d = new cc.kmMat4;
        cc.kmMat4Inverse(d, c);
        var c = c.mat[14] / c.mat[15],
            e = this._openGLView.getDesignResolutionSize();
        a = new cc.kmVec3(2 * a.x / e.width - 1, 1 - 2 * a.y / e.height, c);
        c = new cc.kmVec3;
        cc.kmVec3TransformCoord(c, a, d);
        return cc.p(c.x, c.y)
    };
    a.convertToUI = function(a) {
        var c = new cc.kmMat4;
        cc.GLToClipTransform(c);
        var d = new cc.kmVec3;
        a = new cc.kmVec3(a.x, a.y, 0);
        cc.kmVec3TransformCoord(d, a, c);
        c = this._openGLView.getDesignResolutionSize();
        return cc.p(c.width * (0.5 * d.x + 0.5), c.height * (0.5 * -d.y + 0.5))
    };
    a.getVisibleSize = function() {
        return this._openGLView.getVisibleSize()
    };
    a.getVisibleOrigin = function() {
        return this._openGLView.getVisibleOrigin()
    };
    a.getZEye = function() {
        return this._winSizeInPoints.height / 1.1566
    };
    a.setViewport = function() {
        var a = this._openGLView;
        if (a) {
            var c = this._winSizeInPoints;
            a.setViewPortInPoints(-a._viewPortRect.x / a._scaleX, -a._viewPortRect.y / a._scaleY, c.width, c.height)
        }
    };
    a.getOpenGLView = function() {
        return this._openGLView
    };
    a.getProjection = function() {
        return this._projection
    };
    a.setAlphaBlending = function(a) {
        a ? cc.glBlendFunc(cc.BLEND_SRC, cc.BLEND_DST) : cc.glBlendFunc(cc._renderContext.ONE, cc._renderContext.ZERO)
    };
    a.setGLDefaultValues =
        function() {
            this.setAlphaBlending(!0);
            this.setDepthTest(!1);
            this.setProjection(this._projection);
            cc._renderContext.clearColor(0, 0, 0, 1)
        }
};
cc.g_NumberOfDraws = 0;
cc.GLToClipTransform = function(a) {
    var b = new cc.kmMat4;
    cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, b);
    var c = new cc.kmMat4;
    cc.kmGLGetMatrix(cc.KM_GL_MODELVIEW, c);
    cc.kmMat4Multiply(a, b, c)
};
cc.Director = cc.Class.extend({
    _landscape: !1,
    _nextDeltaTimeZero: !1,
    _paused: !1,
    _purgeDirectorInNextLoop: !1,
    _sendCleanupToScene: !1,
    _animationInterval: 0,
    _oldAnimationInterval: 0,
    _projection: 0,
    _accumDt: 0,
    _contentScaleFactor: 1,
    _displayStats: !1,
    _deltaTime: 0,
    _frameRate: 0,
    _FPSLabel: null,
    _SPFLabel: null,
    _drawsLabel: null,
    _winSizeInPoints: null,
    _lastUpdate: null,
    _nextScene: null,
    _notificationNode: null,
    _openGLView: null,
    _scenesStack: null,
    _projectionDelegate: null,
    _runningScene: null,
    _frames: 0,
    _totalFrames: 0,
    _secondsPerFrame: 0,
    _dirtyRegion: null,
    _scheduler: null,
    _actionManager: null,
    _eventProjectionChanged: null,
    _eventAfterDraw: null,
    _eventAfterVisit: null,
    _eventAfterUpdate: null,
    ctor: function() {
        var a = this;
        a._lastUpdate = Date.now();
        cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function() {
            a._lastUpdate = Date.now()
        })
    },
    init: function() {
        this._oldAnimationInterval = this._animationInterval = 1 / cc.defaultFPS;
        this._scenesStack = [];
        this._projection = cc.Director.PROJECTION_DEFAULT;
        this._projectionDelegate = null;
        this._frameRate = this._accumDt =
            0;
        this._displayStats = !1;
        this._totalFrames = this._frames = 0;
        this._lastUpdate = Date.now();
        this._purgeDirectorInNextLoop = this._paused = !1;
        this._winSizeInPoints = cc.size(0, 0);
        this._openGLView = null;
        this._contentScaleFactor = 1;
        this._scheduler = new cc.Scheduler;
        this._actionManager = cc.ActionManager ? new cc.ActionManager : null;
        this._scheduler.scheduleUpdateForTarget(this._actionManager, cc.Scheduler.PRIORITY_SYSTEM, !1);
        this._eventAfterDraw = new cc.EventCustom(cc.Director.EVENT_AFTER_DRAW);
        this._eventAfterDraw.setUserData(this);
        this._eventAfterVisit = new cc.EventCustom(cc.Director.EVENT_AFTER_VISIT);
        this._eventAfterVisit.setUserData(this);
        this._eventAfterUpdate = new cc.EventCustom(cc.Director.EVENT_AFTER_UPDATE);
        this._eventAfterUpdate.setUserData(this);
        this._eventProjectionChanged = new cc.EventCustom(cc.Director.EVENT_PROJECTION_CHANGED);
        this._eventProjectionChanged.setUserData(this);
        return !0
    },
    calculateDeltaTime: function() {
        var a = Date.now();
        this._nextDeltaTimeZero ? (this._deltaTime = 0, this._nextDeltaTimeZero = !1) : this._deltaTime =
            (a - this._lastUpdate) / 1E3;
        0 < cc.game.config[cc.game.CONFIG_KEY.debugMode] && 0.2 < this._deltaTime && (this._deltaTime = 1 / 60);
        this._lastUpdate = a
    },
    convertToGL: null,
    convertToUI: null,
    drawScene: function() {
        var a = cc.renderer;
        this.calculateDeltaTime();
        this._paused || (this._scheduler.update(this._deltaTime), cc.eventManager.dispatchEvent(this._eventAfterUpdate));
        this._clear();
        this._nextScene && this.setNextScene();
        this._beforeVisitScene && this._beforeVisitScene();
        this._runningScene && (!0 === a.childrenOrderDirty ? (cc.renderer.clearRenderCommands(),
            this._runningScene._curLevel = 0, this._runningScene.visit(), a.resetFlag()) : !0 === a.transformDirty() && a.transform(), cc.eventManager.dispatchEvent(this._eventAfterVisit));
        this._notificationNode && this._notificationNode.visit();
        this._displayStats && this._showStats();
        this._afterVisitScene && this._afterVisitScene();
        a.rendering(cc._renderContext);
        cc.eventManager.dispatchEvent(this._eventAfterDraw);
        this._totalFrames++;
        this._displayStats && this._calculateMPF()
    },
    _beforeVisitScene: null,
    _afterVisitScene: null,
    end: function() {
        this._purgeDirectorInNextLoop = !0
    },
    getContentScaleFactor: function() {
        return this._contentScaleFactor
    },
    getNotificationNode: function() {
        return this._notificationNode
    },
    getWinSize: function() {
        return cc.size(this._winSizeInPoints)
    },
    getWinSizeInPixels: function() {
        return cc.size(this._winSizeInPoints.width * this._contentScaleFactor, this._winSizeInPoints.height * this._contentScaleFactor)
    },
    getVisibleSize: null,
    getVisibleOrigin: null,
    getZEye: null,
    pause: function() {
        this._paused || (this._oldAnimationInterval = this._animationInterval, this.setAnimationInterval(0.25),
            this._paused = !0)
    },
    popScene: function() {
        cc.assert(this._runningScene, cc._LogInfos.Director_popScene);
        this._scenesStack.pop();
        var a = this._scenesStack.length;
        0 == a ? this.end() : (this._sendCleanupToScene = !0, this._nextScene = this._scenesStack[a - 1])
    },
    purgeCachedData: function() {
        cc.animationCache._clear();
        cc.spriteFrameCache._clear();
        cc.textureCache._clear()
    },
    purgeDirector: function() {
        this.getScheduler().unscheduleAllCallbacks();
        cc.eventManager && cc.eventManager.setEnabled(!1);
        this._runningScene && (this._runningScene.onExitTransitionDidStart(),
            this._runningScene.onExit(), this._runningScene.cleanup());
        this._nextScene = this._runningScene = null;
        this._scenesStack.length = 0;
        this.stopAnimation();
        this.purgeCachedData();
        cc.checkGLErrorDebug()
    },
    pushScene: function(a) {
        cc.assert(a, cc._LogInfos.Director_pushScene);
        this._sendCleanupToScene = !1;
        this._scenesStack.push(a);
        this._nextScene = a
    },
    runScene: function(a) {
        cc.assert(a, cc._LogInfos.Director_pushScene);
        if (this._runningScene) {
            var b = this._scenesStack.length;
            0 === b ? (this._sendCleanupToScene = !0, this._scenesStack[b] =
                a) : (this._sendCleanupToScene = !0, this._scenesStack[b - 1] = a);
            this._nextScene = a
        } else this.pushScene(a), this.startAnimation()
    },
    resume: function() {
        this._paused && (this.setAnimationInterval(this._oldAnimationInterval), (this._lastUpdate = Date.now()) || cc.log(cc._LogInfos.Director_resume), this._paused = !1, this._deltaTime = 0)
    },
    setContentScaleFactor: function(a) {
        a != this._contentScaleFactor && (this._contentScaleFactor = a, this._createStatsLabel())
    },
    setDepthTest: null,
    setDefaultValues: function() {},
    setNextDeltaTimeZero: function(a) {
        this._nextDeltaTimeZero =
            a
    },
    setNextScene: function() {
        var a = !1,
            b = !1;
        cc.TransitionScene && (a = this._runningScene ? this._runningScene instanceof cc.TransitionScene : !1, b = this._nextScene ? this._nextScene instanceof cc.TransitionScene : !1);
        if (!b) {
            if (b = this._runningScene) b.onExitTransitionDidStart(), b.onExit();
            this._sendCleanupToScene && b && b.cleanup()
        }
        this._runningScene = this._nextScene;
        cc.renderer.childrenOrderDirty = !0;
        this._nextScene = null;
        !a && null != this._runningScene && (this._runningScene.onEnter(), this._runningScene.onEnterTransitionDidFinish())
    },
    setNotificationNode: function(a) {
        this._notificationNode = a
    },
    getDelegate: function() {
        return this._projectionDelegate
    },
    setDelegate: function(a) {
        this._projectionDelegate = a
    },
    setOpenGLView: null,
    setProjection: null,
    setViewport: null,
    getOpenGLView: null,
    getProjection: null,
    setAlphaBlending: null,
    _showStats: function() {
        this._frames++;
        this._accumDt += this._deltaTime;
        this._FPSLabel && this._SPFLabel && this._drawsLabel ? (this._accumDt > cc.DIRECTOR_FPS_INTERVAL && (this._SPFLabel.string = this._secondsPerFrame.toFixed(3), this._frameRate =
            this._frames / this._accumDt, this._accumDt = this._frames = 0, this._FPSLabel.string = this._frameRate.toFixed(1), this._drawsLabel.string = (0 | cc.g_NumberOfDraws).toString()), this._FPSLabel.visit(), this._SPFLabel.visit(), this._drawsLabel.visit()) : this._createStatsLabel();
        cc.g_NumberOfDraws = 0
    },
    isSendCleanupToScene: function() {
        return this._sendCleanupToScene
    },
    getRunningScene: function() {
        return this._runningScene
    },
    getAnimationInterval: function() {
        return this._animationInterval
    },
    isDisplayStats: function() {
        return this._displayStats
    },
    setDisplayStats: function(a) {
        this._displayStats = a
    },
    getSecondsPerFrame: function() {
        return this._secondsPerFrame
    },
    isNextDeltaTimeZero: function() {
        return this._nextDeltaTimeZero
    },
    isPaused: function() {
        return this._paused
    },
    getTotalFrames: function() {
        return this._totalFrames
    },
    popToRootScene: function() {
        this.popToSceneStackLevel(1)
    },
    popToSceneStackLevel: function(a) {
        cc.assert(this._runningScene, cc._LogInfos.Director_popToSceneStackLevel_2);
        var b = this._scenesStack,
            c = b.length;
        if (0 == c) this.end();
        else if (!(a > c)) {
            for (; c >
                a;) {
                var d = b.pop();
                d.running && (d.onExitTransitionDidStart(), d.onExit());
                d.cleanup();
                c--
            }
            this._nextScene = b[b.length - 1];
            this._sendCleanupToScene = !1
        }
    },
    getScheduler: function() {
        return this._scheduler
    },
    setScheduler: function(a) {
        this._scheduler != a && (this._scheduler = a)
    },
    getActionManager: function() {
        return this._actionManager
    },
    setActionManager: function(a) {
        this._actionManager != a && (this._actionManager = a)
    },
    getDeltaTime: function() {
        return this._deltaTime
    },
    _createStatsLabel: null,
    _calculateMPF: function() {
        this._secondsPerFrame =
            (Date.now() - this._lastUpdate) / 1E3
    }
});
cc.Director.EVENT_PROJECTION_CHANGED = "director_projection_changed";
cc.Director.EVENT_AFTER_DRAW = "director_after_draw";
cc.Director.EVENT_AFTER_VISIT = "director_after_visit";
cc.Director.EVENT_AFTER_UPDATE = "director_after_update";
cc.DisplayLinkDirector = cc.Director.extend({
    invalid: !1,
    startAnimation: function() {
        this._nextDeltaTimeZero = !0;
        this.invalid = !1
    },
    mainLoop: function() {
        this._purgeDirectorInNextLoop ? (this._purgeDirectorInNextLoop = !1, this.purgeDirector()) : this.invalid || this.drawScene()
    },
    stopAnimation: function() {
        this.invalid = !0
    },
    setAnimationInterval: function(a) {
        this._animationInterval = a;
        this.invalid || (this.stopAnimation(), this.startAnimation())
    }
});
cc.Director.sharedDirector = null;
cc.Director.firstUseDirector = !0;
cc.Director._getInstance = function() {
    cc.Director.firstUseDirector && (cc.Director.firstUseDirector = !1, cc.Director.sharedDirector = new cc.DisplayLinkDirector, cc.Director.sharedDirector.init());
    return cc.Director.sharedDirector
};
cc.defaultFPS = 60;
cc.Director.PROJECTION_2D = 0;
cc.Director.PROJECTION_3D = 1;
cc.Director.PROJECTION_CUSTOM = 3;
cc.Director.PROJECTION_DEFAULT = cc.Director.PROJECTION_3D;
cc._renderType === cc._RENDER_TYPE_CANVAS ? (_p = cc.Director.prototype, _p.setProjection = function(a) {
    this._projection = a;
    cc.eventManager.dispatchEvent(this._eventProjectionChanged)
}, _p.setDepthTest = function() {}, _p.setOpenGLView = function(a) {
    this._winSizeInPoints.width = cc._canvas.width;
    this._winSizeInPoints.height = cc._canvas.height;
    this._openGLView = a || cc.view;
    cc.eventManager && cc.eventManager.setEnabled(!0)
}, _p._clear = function() {
    var a = this._openGLView.getViewPortRect();
    cc._renderContext.clearRect(-a.x, a.y,
        a.width, -a.height)
}, _p._createStatsLabel = function() {
    var a = 0,
        a = this._winSizeInPoints.width > this._winSizeInPoints.height ? 0 | 24 * (this._winSizeInPoints.height / 320) : 0 | 24 * (this._winSizeInPoints.width / 320);
    this._FPSLabel = new cc.LabelTTF("000.0", "Arial", a);
    this._SPFLabel = new cc.LabelTTF("0.000", "Arial", a);
    this._drawsLabel = new cc.LabelTTF("0000", "Arial", a);
    a = cc.DIRECTOR_STATS_POSITION;
    this._drawsLabel.setPosition(this._drawsLabel.width / 2 + a.x, 5 * this._drawsLabel.height / 2 + a.y);
    this._SPFLabel.setPosition(this._SPFLabel.width /
        2 + a.x, 3 * this._SPFLabel.height / 2 + a.y);
    this._FPSLabel.setPosition(this._FPSLabel.width / 2 + a.x, this._FPSLabel.height / 2 + a.y)
}, _p.getVisibleSize = function() {
    return this.getWinSize()
}, _p.getVisibleOrigin = function() {
    return cc.p(0, 0)
}) : (cc.Director._fpsImage = new Image, cc._addEventListener(cc.Director._fpsImage, "load", function() {
        cc.Director._fpsImageLoaded = !0
    }), cc._fpsImage && (cc.Director._fpsImage.src = cc._fpsImage), cc.assert(cc.isFunction(cc._tmp.DirectorWebGL), cc._LogInfos.MissingFile, "CCDirectorWebGL.js"),
    cc._tmp.DirectorWebGL(), delete cc._tmp.DirectorWebGL);
cc.Camera = cc.Class.extend({
    _eyeX: null,
    _eyeY: null,
    _eyeZ: null,
    _centerX: null,
    _centerY: null,
    _centerZ: null,
    _upX: null,
    _upY: null,
    _upZ: null,
    _dirty: null,
    _lookupMatrix: null,
    ctor: function() {
        this._lookupMatrix = new cc.kmMat4;
        this.restore()
    },
    description: function() {
        return "\x3cCCCamera | center \x3d(" + this._centerX + "," + this._centerY + "," + this._centerZ + ")\x3e"
    },
    setDirty: function(a) {
        this._dirty = a
    },
    isDirty: function() {
        return this._dirty
    },
    restore: function() {
        this._eyeX = this._eyeY = 0;
        this._eyeZ = cc.Camera.getZEye();
        this._upX =
            this._centerX = this._centerY = this._centerZ = 0;
        this._upY = 1;
        this._upZ = 0;
        cc.kmMat4Identity(this._lookupMatrix);
        this._dirty = !1
    },
    locate: function() {
        if (this._dirty) {
            var a = new cc.kmVec3,
                b = new cc.kmVec3,
                c = new cc.kmVec3;
            cc.kmVec3Fill(a, this._eyeX, this._eyeY, this._eyeZ);
            cc.kmVec3Fill(b, this._centerX, this._centerY, this._centerZ);
            cc.kmVec3Fill(c, this._upX, this._upY, this._upZ);
            cc.kmMat4LookAt(this._lookupMatrix, a, b, c);
            this._dirty = !1
        }
        cc.kmGLMultMatrix(this._lookupMatrix)
    },
    _locateForRenderer: function(a) {
        if (this._dirty) {
            var b =
                new cc.kmVec3,
                c = new cc.kmVec3,
                d = new cc.kmVec3;
            cc.kmVec3Fill(b, this._eyeX, this._eyeY, this._eyeZ);
            cc.kmVec3Fill(c, this._centerX, this._centerY, this._centerZ);
            cc.kmVec3Fill(d, this._upX, this._upY, this._upZ);
            cc.kmMat4LookAt(this._lookupMatrix, b, c, d);
            this._dirty = !1
        }
        cc.kmMat4Multiply(a, a, this._lookupMatrix)
    },
    setEyeXYZ: function(a, b, c) {
        this.setEye(a, b, c)
    },
    setEye: function(a, b, c) {
        this._eyeX = a;
        this._eyeY = b;
        this._eyeZ = c;
        this._dirty = !0
    },
    setCenterXYZ: function(a, b, c) {
        this.setCenter(a, b, c)
    },
    setCenter: function(a, b,
        c) {
        this._centerX = a;
        this._centerY = b;
        this._centerZ = c;
        this._dirty = !0
    },
    setUpXYZ: function(a, b, c) {
        this.setUp(a, b, c)
    },
    setUp: function(a, b, c) {
        this._upX = a;
        this._upY = b;
        this._upZ = c;
        this._dirty = !0
    },
    getEyeXYZ: function(a, b, c) {
        return {
            x: this._eyeX,
            y: this._eyeY,
            z: this._eyeZ
        }
    },
    getEye: function() {
        return {
            x: this._eyeX,
            y: this._eyeY,
            z: this._eyeZ
        }
    },
    getCenterXYZ: function(a, b, c) {
        return {
            x: this._centerX,
            y: this._centerY,
            z: this._centerZ
        }
    },
    getCenter: function() {
        return {
            x: this._centerX,
            y: this._centerY,
            z: this._centerZ
        }
    },
    getUpXYZ: function(a,
        b, c) {
        return {
            x: this._upX,
            y: this._upY,
            z: this._upZ
        }
    },
    getUp: function() {
        return {
            x: this._upX,
            y: this._upY,
            z: this._upZ
        }
    },
    _DISALLOW_COPY_AND_ASSIGN: function(a) {}
});
cc.Camera.getZEye = function() {
    return cc.FLT_EPSILON
};
cc.PRIORITY_NON_SYSTEM = cc.PRIORITY_SYSTEM + 1;
cc.ListEntry = function(a, b, c, d, e, f) {
    this.prev = a;
    this.next = b;
    this.target = c;
    this.priority = d;
    this.paused = e;
    this.markedForDeletion = f
};
cc.HashUpdateEntry = function(a, b, c, d) {
    this.list = a;
    this.entry = b;
    this.target = c;
    this.hh = d
};
cc.HashTimerEntry = function(a, b, c, d, e, f, g) {
    this.timers = a;
    this.target = b;
    this.timerIndex = c;
    this.currentTimer = d;
    this.currentTimerSalvaged = e;
    this.paused = f;
    this.hh = g
};
cc.Timer = cc.Class.extend({
    _interval: 0,
    _callback: null,
    _target: null,
    _elapsed: 0,
    _runForever: !1,
    _useDelay: !1,
    _timesExecuted: 0,
    _repeat: 0,
    _delay: 0,
    getInterval: function() {
        return this._interval
    },
    setInterval: function(a) {
        this._interval = a
    },
    getCallback: function() {
        return this._callback
    },
    ctor: function(a, b, c, d, e) {
        this._target = a;
        this._callback = b;
        this._elapsed = -1;
        this._interval = c || 0;
        this._delay = e || 0;
        this._useDelay = 0 < this._delay;
        this._repeat = null == d ? cc.REPEAT_FOREVER : d;
        this._runForever = this._repeat == cc.REPEAT_FOREVER
    },
    _doCallback: function() {
        if (cc.isString(this._callback)) this._target[this._callback](this._elapsed);
        else this._callback.call(this._target, this._elapsed)
    },
    update: function(a) {
        if (-1 == this._elapsed) this._timesExecuted = this._elapsed = 0;
        else {
            var b = this._target,
                c = this._callback;
            this._elapsed += a;
            this._runForever && !this._useDelay ? this._elapsed >= this._interval && (b && c && this._doCallback(), this._elapsed = 0) : (this._useDelay ? this._elapsed >= this._delay && (b && c && this._doCallback(), this._elapsed -= this._delay, this._timesExecuted +=
                1, this._useDelay = !1) : this._elapsed >= this._interval && (b && c && this._doCallback(), this._elapsed = 0, this._timesExecuted += 1), this._timesExecuted > this._repeat && cc.director.getScheduler().unscheduleCallbackForTarget(b, c))
        }
    }
});
cc.Scheduler = cc.Class.extend({
    _timeScale: 1,
    _updates: null,
    _hashForUpdates: null,
    _arrayForUpdates: null,
    _hashForTimers: null,
    _arrayForTimes: null,
    _currentTarget: null,
    _currentTargetSalvaged: !1,
    _updateHashLocked: !1,
    ctor: function() {
        this._timeScale = 1;
        this._updates = [
            [],
            [],
            []
        ];
        this._hashForUpdates = {};
        this._arrayForUpdates = [];
        this._hashForTimers = {};
        this._arrayForTimers = [];
        this._currentTarget = null;
        this._updateHashLocked = this._currentTargetSalvaged = !1
    },
    _removeHashElement: function(a) {
        delete this._hashForTimers[a.target.__instanceId];
        cc.arrayRemoveObject(this._arrayForTimers, a);
        a.Timer = null;
        a.target = null
    },
    _removeUpdateFromHash: function(a) {
        if (a = this._hashForUpdates[a.target.__instanceId]) cc.arrayRemoveObject(a.list, a.entry), delete this._hashForUpdates[a.target.__instanceId], cc.arrayRemoveObject(this._arrayForUpdates, a), a.entry = null, a.target = null
    },
    _priorityIn: function(a, b, c, d) {
        d = new cc.ListEntry(null, null, b, c, d, !1);
        if (a) {
            for (var e = a.length - 1, f = 0; f <= e && !(c < a[f].priority); f++);
            a.splice(f, 0, d)
        } else a = [], a.push(d);
        c = new cc.HashUpdateEntry(a,
            d, b, null);
        this._arrayForUpdates.push(c);
        this._hashForUpdates[b.__instanceId] = c;
        return a
    },
    _appendIn: function(a, b, c) {
        c = new cc.ListEntry(null, null, b, 0, c, !1);
        a.push(c);
        a = new cc.HashUpdateEntry(a, c, b, null);
        this._arrayForUpdates.push(a);
        this._hashForUpdates[b.__instanceId] = a
    },
    setTimeScale: function(a) {
        this._timeScale = a
    },
    getTimeScale: function() {
        return this._timeScale
    },
    update: function(a) {
        var b = this._updates,
            c = this._arrayForTimers,
            d, e, f;
        this._updateHashLocked = !0;
        1 != this._timeScale && (a *= this._timeScale);
        e = 0;
        for (f = b.length; e < f && 0 <= e; e++)
            for (var g = this._updates[e], h = 0, k = g.length; h < k; h++) d = g[h], !d.paused && !d.markedForDeletion && d.target.update(a);
        e = 0;
        for (f = c.length; e < f; e++) {
            d = c[e];
            if (!d) break;
            this._currentTarget = d;
            this._currentTargetSalvaged = !1;
            if (!d.paused)
                for (d.timerIndex = 0; d.timerIndex < d.timers.length; d.timerIndex++) d.currentTimer = d.timers[d.timerIndex], d.currentTimerSalvaged = !1, d.currentTimer.update(a), d.currentTimer = null;
            this._currentTargetSalvaged && 0 == d.timers.length && (this._removeHashElement(d), e--)
        }
        e =
            0;
        for (f = b.length; e < f; e++) {
            g = this._updates[e];
            h = 0;
            for (k = g.length; h < k;) {
                d = g[h];
                if (!d) break;
                d.markedForDeletion ? this._removeUpdateFromHash(d) : h++
            }
        }
        this._updateHashLocked = !1;
        this._currentTarget = null
    },
    scheduleCallbackForTarget: function(a, b, c, d, e, f) {
        cc.assert(b, cc._LogInfos.Scheduler_scheduleCallbackForTarget_2);
        cc.assert(a, cc._LogInfos.Scheduler_scheduleCallbackForTarget_3);
        c = c || 0;
        d = null == d ? cc.REPEAT_FOREVER : d;
        e = e || 0;
        f = f || !1;
        var g = this._hashForTimers[a.__instanceId];
        g || (g = new cc.HashTimerEntry(null, a,
            0, null, null, f, null), this._arrayForTimers.push(g), this._hashForTimers[a.__instanceId] = g);
        if (null == g.timers) g.timers = [];
        else
            for (var h = 0; h < g.timers.length; h++)
                if (f = g.timers[h], b == f._callback) {
                    cc.log(cc._LogInfos.Scheduler_scheduleCallbackForTarget, f.getInterval().toFixed(4), c.toFixed(4));
                    f._interval = c;
                    return
                }
        f = new cc.Timer(a, b, c, d, e);
        g.timers.push(f)
    },
    scheduleUpdateForTarget: function(a, b, c) {
        if (null !== a) {
            var d = this._updates,
                e = this._hashForUpdates[a.__instanceId];
            e ? e.entry.markedForDeletion = !1 : 0 == b ? this._appendIn(d[1],
                a, c) : 0 > b ? d[0] = this._priorityIn(d[0], a, b, c) : d[2] = this._priorityIn(d[2], a, b, c)
        }
    },
    unscheduleCallbackForTarget: function(a, b) {
        if (!(null == a || null == b)) {
            var c = this._hashForTimers[a.__instanceId];
            if (c)
                for (var d = c.timers, e = 0, f = d.length; e < f; e++) {
                    var g = d[e];
                    if (b == g._callback) {
                        g == c.currentTimer && !c.currentTimerSalvaged && (c.currentTimerSalvaged = !0);
                        d.splice(e, 1);
                        c.timerIndex >= e && c.timerIndex--;
                        0 == d.length && (this._currentTarget == c ? this._currentTargetSalvaged = !0 : this._removeHashElement(c));
                        break
                    }
                }
        }
    },
    unscheduleUpdateForTarget: function(a) {
        null !=
            a && (a = this._hashForUpdates[a.__instanceId], null != a && (this._updateHashLocked ? a.entry.markedForDeletion = !0 : this._removeUpdateFromHash(a.entry)))
    },
    unscheduleAllCallbacksForTarget: function(a) {
        if (null != a) {
            var b = this._hashForTimers[a.__instanceId];
            if (b) {
                var c = b.timers;
                !b.currentTimerSalvaged && 0 <= c.indexOf(b.currentTimer) && (b.currentTimerSalvaged = !0);
                c.length = 0;
                this._currentTarget == b ? this._currentTargetSalvaged = !0 : this._removeHashElement(b)
            }
            this.unscheduleUpdateForTarget(a)
        }
    },
    unscheduleAllCallbacks: function() {
        this.unscheduleAllCallbacksWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM)
    },
    unscheduleAllCallbacksWithMinPriority: function(a) {
        for (var b = this._arrayForTimers, c = this._updates, d = 0, e = b.length; d < e; d++) this.unscheduleAllCallbacksForTarget(b[d].target);
        for (d = 2; 0 <= d; d--)
            if (!(1 == d && 0 < a || 0 == d && 0 <= a))
                for (var b = c[d], e = 0, f = b.length; e < f; e++) this.unscheduleUpdateForTarget(b[e].target)
    },
    pauseAllTargets: function() {
        return this.pauseAllTargetsWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM)
    },
    pauseAllTargetsWithMinPriority: function(a) {
        a = [];
        for (var b, c = this._arrayForTimers, d = this._updates, e = 0, f =
            c.length; e < f; e++)
            if (b = c[e]) b.paused = !0, a.push(b.target);
        e = 0;
        for (f = d.length; e < f; e++)
            for (var c = d[e], g = 0, h = c.length; g < h; g++)
                if (b = c[g]) b.paused = !0, a.push(b.target);
        return a
    },
    resumeTargets: function(a) {
        if (a)
            for (var b = 0; b < a.length; b++) this.resumeTarget(a[b])
    },
    pauseTarget: function(a) {
        cc.assert(a, cc._LogInfos.Scheduler_pauseTarget);
        var b = this._hashForTimers[a.__instanceId];
        b && (b.paused = !0);
        (a = this._hashForUpdates[a.__instanceId]) && (a.entry.paused = !0)
    },
    resumeTarget: function(a) {
        cc.assert(a, cc._LogInfos.Scheduler_resumeTarget);
        var b = this._hashForTimers[a.__instanceId];
        b && (b.paused = !1);
        (a = this._hashForUpdates[a.__instanceId]) && (a.entry.paused = !1)
    },
    isTargetPaused: function(a) {
        cc.assert(a, cc._LogInfos.Scheduler_isTargetPaused);
        return (a = this._hashForTimers[a.__instanceId]) ? a.paused : !1
    }
});
cc.Scheduler.PRIORITY_SYSTEM = -2147483648;
cc.PI2 = 2 * Math.PI;
cc.DrawingPrimitiveCanvas = cc.Class.extend({
    _cacheArray: [],
    _renderContext: null,
    ctor: function(a) {
        this._renderContext = a
    },
    drawPoint: function(a, b) {
        b || (b = 1);
        var c = cc.view.getScaleX(),
            d = cc.view.getScaleY(),
            d = cc.p(a.x * c, a.y * d);
        this._renderContext.beginPath();
        this._renderContext.arc(d.x, -d.y, b * c, 0, 2 * Math.PI, !1);
        this._renderContext.closePath();
        this._renderContext.fill()
    },
    drawPoints: function(a, b, c) {
        if (null != a) {
            c || (c = 1);
            b = this._renderContext;
            var d = cc.view.getScaleX(),
                e = cc.view.getScaleY();
            b.beginPath();
            for (var f =
                0, g = a.length; f < g; f++) b.arc(a[f].x * d, -a[f].y * e, c * d, 0, 2 * Math.PI, !1);
            b.closePath();
            b.fill()
        }
    },
    drawLine: function(a, b) {
        var c = this._renderContext,
            d = cc.view.getScaleX(),
            e = cc.view.getScaleY();
        c.beginPath();
        c.moveTo(a.x * d, -a.y * e);
        c.lineTo(b.x * d, -b.y * e);
        c.closePath();
        c.stroke()
    },
    drawRect: function(a, b) {
        this.drawLine(cc.p(a.x, a.y), cc.p(b.x, a.y));
        this.drawLine(cc.p(b.x, a.y), cc.p(b.x, b.y));
        this.drawLine(cc.p(b.x, b.y), cc.p(a.x, b.y));
        this.drawLine(cc.p(a.x, b.y), cc.p(a.x, a.y))
    },
    drawSolidRect: function(a, b, c) {
        a = [a,
            cc.p(b.x, a.y), b, cc.p(a.x, b.y)
        ];
        this.drawSolidPoly(a, 4, c)
    },
    drawPoly: function(a, b, c, d) {
        d = d || !1;
        if (null != a) {
            if (3 > a.length) throw Error("Polygon's point must greater than 2");
            var e = a[0];
            b = this._renderContext;
            var f = cc.view.getScaleX(),
                g = cc.view.getScaleY();
            b.beginPath();
            b.moveTo(e.x * f, -e.y * g);
            for (var e = 1, h = a.length; e < h; e++) b.lineTo(a[e].x * f, -a[e].y * g);
            c && b.closePath();
            d ? b.fill() : b.stroke()
        }
    },
    drawSolidPoly: function(a, b, c) {
        this.setDrawColor(c.r, c.g, c.b, c.a);
        this.drawPoly(a, b, !0, !0)
    },
    drawCircle: function(a,
        b, c, d, e) {
        e = e || !1;
        d = this._renderContext;
        var f = cc.view.getScaleX(),
            g = cc.view.getScaleY();
        d.beginPath();
        d.arc(0 | a.x * f, 0 | -(a.y * g), b * f, -c, -(c - 2 * Math.PI), !1);
        e && d.lineTo(0 | a.x * f, 0 | -(a.y * g));
        d.stroke()
    },
    drawQuadBezier: function(a, b, c, d) {
        for (var e = this._cacheArray, f = e.length = 0, g = 0; g < d; g++) {
            var h = Math.pow(1 - f, 2) * a.x + 2 * (1 - f) * f * b.x + f * f * c.x,
                k = Math.pow(1 - f, 2) * a.y + 2 * (1 - f) * f * b.y + f * f * c.y;
            e.push(cc.p(h, k));
            f += 1 / d
        }
        e.push(cc.p(c.x, c.y));
        this.drawPoly(e, d + 1, !1, !1)
    },
    drawCubicBezier: function(a, b, c, d, e) {
        for (var f = this._cacheArray,
            g = f.length = 0, h = 0; h < e; h++) {
            var k = Math.pow(1 - g, 3) * a.x + 3 * Math.pow(1 - g, 2) * g * b.x + 3 * (1 - g) * g * g * c.x + g * g * g * d.x,
                m = Math.pow(1 - g, 3) * a.y + 3 * Math.pow(1 - g, 2) * g * b.y + 3 * (1 - g) * g * g * c.y + g * g * g * d.y;
            f.push(cc.p(k, m));
            g += 1 / e
        }
        f.push(cc.p(d.x, d.y));
        this.drawPoly(f, e + 1, !1, !1)
    },
    drawCatmullRom: function(a, b) {
        this.drawCardinalSpline(a, 0.5, b)
    },
    drawCardinalSpline: function(a, b, c) {
        cc._renderContext.strokeStyle = "rgba(255,255,255,1)";
        var d = this._cacheArray;
        d.length = 0;
        for (var e, f, g = 1 / a.length, h = 0; h < c + 1; h++) f = h / c, 1 == f ? (e = a.length - 1, f = 1) :
            (e = 0 | f / g, f = (f - g * e) / g), e = cc.CardinalSplineAt(cc.getControlPointAt(a, e - 1), cc.getControlPointAt(a, e - 0), cc.getControlPointAt(a, e + 1), cc.getControlPointAt(a, e + 2), b, f), d.push(e);
        this.drawPoly(d, c + 1, !1, !1)
    },
    drawImage: function(a, b, c, d, e) {
        switch (arguments.length) {
            case 2:
                this._renderContext.drawImage(a, b.x, -(b.y + a.height));
                break;
            case 3:
                this._renderContext.drawImage(a, b.x, -(b.y + c.height), c.width, c.height);
                break;
            case 5:
                this._renderContext.drawImage(a, b.x, b.y, c.width, c.height, d.x, -(d.y + e.height), e.width, e.height);
                break;
            default:
                throw Error("Argument must be non-nil");
        }
    },
    drawStar: function(a, b, c) {
        a = a || this._renderContext;
        b *= cc.view.getScaleX();
        c = "rgba(" + (0 | c.r) + "," + (0 | c.g) + "," + (0 | c.b);
        a.fillStyle = c + ",1)";
        var d = b / 10;
        a.beginPath();
        a.moveTo(-b, b);
        a.lineTo(0, d);
        a.lineTo(b, b);
        a.lineTo(d, 0);
        a.lineTo(b, -b);
        a.lineTo(0, -d);
        a.lineTo(-b, -b);
        a.lineTo(-d, 0);
        a.lineTo(-b, b);
        a.closePath();
        a.fill();
        var e = a.createRadialGradient(0, 0, d, 0, 0, b);
        e.addColorStop(0, c + ", 1)");
        e.addColorStop(0.3, c + ", 0.8)");
        e.addColorStop(1, c + ", 0.0)");
        a.fillStyle = e;
        a.beginPath();
        a.arc(0, 0, b - d, 0, cc.PI2, !1);
        a.closePath();
        a.fill()
    },
    drawColorBall: function(a, b, c) {
        a = a || this._renderContext;
        b *= cc.view.getScaleX();
        c = "rgba(" + (0 | c.r) + "," + (0 | c.g) + "," + (0 | c.b);
        var d = a.createRadialGradient(0, 0, b / 10, 0, 0, b);
        d.addColorStop(0, c + ", 1)");
        d.addColorStop(0.3, c + ", 0.8)");
        d.addColorStop(0.6, c + ", 0.4)");
        d.addColorStop(1, c + ", 0.0)");
        a.fillStyle = d;
        a.beginPath();
        a.arc(0, 0, b, 0, cc.PI2, !1);
        a.closePath();
        a.fill()
    },
    fillText: function(a, b, c) {
        this._renderContext.fillText(a, b, -c)
    },
    setDrawColor: function(a, b, c, d) {
        this._renderContext.fillStyle = "rgba(" + a + "," + b + "," + c + "," + d / 255 + ")";
        this._renderContext.strokeStyle = "rgba(" + a + "," + b + "," + c + "," + d / 255 + ")"
    },
    setPointSize: function(a) {},
    setLineWidth: function(a) {
        this._renderContext.lineWidth = a * cc.view.getScaleX()
    }
});
cc.DrawingPrimitiveWebGL = cc.Class.extend({
    _renderContext: null,
    _initialized: !1,
    _shader: null,
    _colorLocation: -1,
    _colorArray: null,
    _pointSizeLocation: -1,
    _pointSize: -1,
    ctor: function(a) {
        null == a && (a = cc._renderContext);
        if (!a instanceof WebGLRenderingContext) throw "Can't initialise DrawingPrimitiveWebGL. context need is WebGLRenderingContext";
        this._renderContext = a;
        this._colorArray = new Float32Array([1, 1, 1, 1])
    },
    lazy_init: function() {
        this._initialized || (this._shader = cc.shaderCache.programForKey(cc.SHADER_POSITION_UCOLOR),
            this._colorLocation = this._renderContext.getUniformLocation(this._shader.getProgram(), "u_color"), this._pointSizeLocation = this._renderContext.getUniformLocation(this._shader.getProgram(), "u_pointSize"), this._initialized = !0)
    },
    drawInit: function() {
        this._initialized = !1
    },
    drawPoint: function(a) {
        this.lazy_init();
        var b = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        b.uniform4fv(this._colorLocation,
            this._colorArray);
        this._shader.setUniformLocationWith1f(this._pointSizeLocation, this._pointSize);
        var c = b.createBuffer();
        b.bindBuffer(b.ARRAY_BUFFER, c);
        b.bufferData(b.ARRAY_BUFFER, new Float32Array([a.x, a.y]), b.STATIC_DRAW);
        b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, b.FLOAT, !1, 0, 0);
        b.drawArrays(b.POINTS, 0, 1);
        b.deleteBuffer(c);
        cc.incrementGLDraws(1)
    },
    drawPoints: function(a, b) {
        if (a && 0 != a.length) {
            this.lazy_init();
            var c = this._renderContext;
            this._shader.use();
            this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
            c.uniform4fv(this._colorLocation, this._colorArray);
            this._shader.setUniformLocationWith1f(this._pointSizeLocation, this._pointSize);
            var d = c.createBuffer();
            c.bindBuffer(c.ARRAY_BUFFER, d);
            c.bufferData(c.ARRAY_BUFFER, this._pointsToTypeArray(a), c.STATIC_DRAW);
            c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, c.FLOAT, !1, 0, 0);
            c.drawArrays(c.POINTS, 0, a.length);
            c.deleteBuffer(d);
            cc.incrementGLDraws(1)
        }
    },
    _pointsToTypeArray: function(a) {
        for (var b = new Float32Array(2 *
            a.length), c = 0; c < a.length; c++) b[2 * c] = a[c].x, b[2 * c + 1] = a[c].y;
        return b
    },
    drawLine: function(a, b) {
        this.lazy_init();
        var c = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        c.uniform4fv(this._colorLocation, this._colorArray);
        var d = c.createBuffer();
        c.bindBuffer(c.ARRAY_BUFFER, d);
        c.bufferData(c.ARRAY_BUFFER, this._pointsToTypeArray([a, b]), c.STATIC_DRAW);
        c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION,
            2, c.FLOAT, !1, 0, 0);
        c.drawArrays(c.LINES, 0, 2);
        c.deleteBuffer(d);
        cc.incrementGLDraws(1)
    },
    drawRect: function(a, b) {
        this.drawLine(cc.p(a.x, a.y), cc.p(b.x, a.y));
        this.drawLine(cc.p(b.x, a.y), cc.p(b.x, b.y));
        this.drawLine(cc.p(b.x, b.y), cc.p(a.x, b.y));
        this.drawLine(cc.p(a.x, b.y), cc.p(a.x, a.y))
    },
    drawSolidRect: function(a, b, c) {
        a = [a, cc.p(b.x, a.y), b, cc.p(a.x, b.y)];
        this.drawSolidPoly(a, 4, c)
    },
    drawPoly: function(a, b, c) {
        this.lazy_init();
        b = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        b.uniform4fv(this._colorLocation, this._colorArray);
        var d = b.createBuffer();
        b.bindBuffer(b.ARRAY_BUFFER, d);
        b.bufferData(b.ARRAY_BUFFER, this._pointsToTypeArray(a), b.STATIC_DRAW);
        b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, b.FLOAT, !1, 0, 0);
        c ? b.drawArrays(b.LINE_LOOP, 0, a.length) : b.drawArrays(b.LINE_STRIP, 0, a.length);
        b.deleteBuffer(d);
        cc.incrementGLDraws(1)
    },
    drawSolidPoly: function(a, b, c) {
        this.lazy_init();
        c && this.setDrawColor(c.r, c.g, c.b, c.a);
        b = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        b.uniform4fv(this._colorLocation, this._colorArray);
        c = b.createBuffer();
        b.bindBuffer(b.ARRAY_BUFFER, c);
        b.bufferData(b.ARRAY_BUFFER, this._pointsToTypeArray(a), b.STATIC_DRAW);
        b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, b.FLOAT, !1, 0, 0);
        b.drawArrays(b.TRIANGLE_FAN, 0, a.length);
        b.deleteBuffer(c);
        cc.incrementGLDraws(1)
    },
    drawCircle: function(a,
        b, c, d, e) {
        this.lazy_init();
        var f = 1;
        e && f++;
        var g = 2 * Math.PI / d;
        if (e = new Float32Array(2 * (d + 2))) {
            for (var h = 0; h <= d; h++) {
                var k = h * g,
                    m = b * Math.cos(k + c) + a.x,
                    k = b * Math.sin(k + c) + a.y;
                e[2 * h] = m;
                e[2 * h + 1] = k
            }
            e[2 * (d + 1)] = a.x;
            e[2 * (d + 1) + 1] = a.y;
            a = this._renderContext;
            this._shader.use();
            this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
            a.uniform4fv(this._colorLocation, this._colorArray);
            b = a.createBuffer();
            a.bindBuffer(a.ARRAY_BUFFER, b);
            a.bufferData(a.ARRAY_BUFFER,
                e, a.STATIC_DRAW);
            a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
            a.drawArrays(a.LINE_STRIP, 0, d + f);
            a.deleteBuffer(b);
            cc.incrementGLDraws(1)
        }
    },
    drawQuadBezier: function(a, b, c, d) {
        this.lazy_init();
        for (var e = new Float32Array(2 * (d + 1)), f = 0, g = 0; g < d; g++) e[2 * g] = Math.pow(1 - f, 2) * a.x + 2 * (1 - f) * f * b.x + f * f * c.x, e[2 * g + 1] = Math.pow(1 - f, 2) * a.y + 2 * (1 - f) * f * b.y + f * f * c.y, f += 1 / d;
        e[2 * d] = c.x;
        e[2 * d + 1] = c.y;
        a = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        a.uniform4fv(this._colorLocation, this._colorArray);
        b = a.createBuffer();
        a.bindBuffer(a.ARRAY_BUFFER, b);
        a.bufferData(a.ARRAY_BUFFER, e, a.STATIC_DRAW);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
        a.drawArrays(a.LINE_STRIP, 0, d + 1);
        a.deleteBuffer(b);
        cc.incrementGLDraws(1)
    },
    drawCubicBezier: function(a, b, c, d, e) {
        this.lazy_init();
        for (var f = new Float32Array(2 * (e + 1)), g = 0, h = 0; h < e; h++) f[2 * h] = Math.pow(1 - g, 3) * a.x + 3 * Math.pow(1 - g, 2) * g * b.x + 3 * (1 - g) * g * g * c.x + g * g * g * d.x, f[2 * h + 1] = Math.pow(1 - g, 3) * a.y + 3 * Math.pow(1 -
            g, 2) * g * b.y + 3 * (1 - g) * g * g * c.y + g * g * g * d.y, g += 1 / e;
        f[2 * e] = d.x;
        f[2 * e + 1] = d.y;
        a = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        a.uniform4fv(this._colorLocation, this._colorArray);
        b = a.createBuffer();
        a.bindBuffer(a.ARRAY_BUFFER, b);
        a.bufferData(a.ARRAY_BUFFER, f, a.STATIC_DRAW);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
        a.drawArrays(a.LINE_STRIP, 0, e + 1);
        a.deleteBuffer(b);
        cc.incrementGLDraws(1)
    },
    drawCatmullRom: function(a, b) {
        this.drawCardinalSpline(a, 0.5, b)
    },
    drawCardinalSpline: function(a, b, c) {
        this.lazy_init();
        for (var d = new Float32Array(2 * (c + 1)), e, f, g = 1 / a.length, h = 0; h < c + 1; h++) f = h / c, 1 == f ? (e = a.length - 1, f = 1) : (e = 0 | f / g, f = (f - g * e) / g), e = cc.CardinalSplineAt(cc.getControlPointAt(a, e - 1), cc.getControlPointAt(a, e), cc.getControlPointAt(a, e + 1), cc.getControlPointAt(a, e + 2), b, f), d[2 * h] = e.x, d[2 * h + 1] = e.y;
        a = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        a.uniform4fv(this._colorLocation, this._colorArray);
        b = a.createBuffer();
        a.bindBuffer(a.ARRAY_BUFFER, b);
        a.bufferData(a.ARRAY_BUFFER, d, a.STATIC_DRAW);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
        a.drawArrays(a.LINE_STRIP, 0, c + 1);
        a.deleteBuffer(b);
        cc.incrementGLDraws(1)
    },
    setDrawColor: function(a, b, c, d) {
        this._colorArray[0] = a / 255;
        this._colorArray[1] = b / 255;
        this._colorArray[2] = c / 255;
        this._colorArray[3] = d / 255
    },
    setPointSize: function(a) {
        this._pointSize =
            a * cc.contentScaleFactor()
    },
    setLineWidth: function(a) {
        this._renderContext.lineWidth && this._renderContext.lineWidth(a)
    }
});
cc._tmp.WebGLLabelTTF = function() {
    var a = cc.LabelTTF.prototype;
    a.setColor = cc.Sprite.prototype.setColor;
    a._transformForRenderer = function() {
        this._needUpdateTexture && (this._needUpdateTexture = !1, this._updateTexture());
        cc.Node.prototype._transformForRenderer.call(this)
    };
    a._setColorsString = function() {
        this._needUpdateTexture = !0;
        var a = this._strokeColor,
            c = this._textFillColor;
        this._shadowColorStr = "rgba(128,128,128," + this._shadowOpacity + ")";
        this._fillColorStr = "rgba(" + (0 | c.r) + "," + (0 | c.g) + "," + (0 | c.b) + ", 1)";
        this._strokeColorStr =
            "rgba(" + (0 | a.r) + "," + (0 | a.g) + "," + (0 | a.b) + ", 1)"
    };
    a.updateDisplayedColor = cc.Sprite.prototype.updateDisplayedColor;
    a.setOpacity = cc.Sprite.prototype.setOpacity;
    a.updateDisplayedOpacity = cc.Sprite.prototype.updateDisplayedOpacity;
    a.initWithStringAndTextDefinition = function(a, c) {
        if (!cc.Sprite.prototype.init.call(this)) return !1;
        this.shaderProgram = cc.shaderCache.programForKey(cc.LabelTTF._SHADER_PROGRAM);
        this._updateWithTextDefinition(c, !1);
        this.string = a;
        return !0
    };
    a.setFontFillColor = function(a) {
        var c = this._textFillColor;
        if (c.r != a.r || c.g != a.g || c.b != a.b) c.r = a.r, c.g = a.g, c.b = a.b, this._setColorsString(), this._needUpdateTexture = !0
    };
    a.draw = function(a) {
        if (this._string && "" != this._string) {
            a = a || cc._renderContext;
            var c = this._texture;
            c && c._isLoaded && (this._shaderProgram.use(), this._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst), cc.glBindTexture2D(c), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), a.bindBuffer(a.ARRAY_BUFFER, this._quadWebBuffer),
                this._quadDirty && (a.bufferData(a.ARRAY_BUFFER, this._quad.arrayBuffer, a.STATIC_DRAW), this._quadDirty = !1), a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, a.FLOAT, !1, 24, 0), a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, 24, 16), a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 24, 12), a.drawArrays(a.TRIANGLE_STRIP, 0, 4));
            if (1 === cc.SPRITE_DEBUG_DRAW) a = this._quad, a = [cc.p(a.tl.vertices.x, a.tl.vertices.y), cc.p(a.bl.vertices.x, a.bl.vertices.y), cc.p(a.br.vertices.x, a.br.vertices.y),
                cc.p(a.tr.vertices.x, a.tr.vertices.y)
            ], cc._drawingUtil.drawPoly(a, 4, !0);
            else if (2 === cc.SPRITE_DEBUG_DRAW) {
                a = this.getTextureRect();
                var c = this.offsetX,
                    d = this.offsetY;
                a = [cc.p(c, d), cc.p(c + a.width, d), cc.p(c + a.width, d + a.height), cc.p(c, d + a.height)];
                cc._drawingUtil.drawPoly(a, 4, !0)
            }
            cc.g_NumberOfDraws++
        }
    };
    a.setTextureRect = cc.Sprite.prototype.setTextureRect
};
cc._tmp.PrototypeLabelTTF = function() {
    var a = cc.LabelTTF.prototype;
    cc.defineGetterSetter(a, "color", a.getColor, a.setColor);
    cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity);
    cc.defineGetterSetter(a, "string", a.getString, a.setString);
    cc.defineGetterSetter(a, "textAlign", a.getHorizontalAlignment, a.setHorizontalAlignment);
    cc.defineGetterSetter(a, "verticalAlign", a.getVerticalAlignment, a.setVerticalAlignment);
    cc.defineGetterSetter(a, "fontSize", a.getFontSize, a.setFontSize);
    cc.defineGetterSetter(a,
        "fontName", a.getFontName, a.setFontName);
    cc.defineGetterSetter(a, "font", a._getFont, a._setFont);
    cc.defineGetterSetter(a, "boundingWidth", a._getBoundingWidth, a._setBoundingWidth);
    cc.defineGetterSetter(a, "boundingHeight", a._getBoundingHeight, a._setBoundingHeight);
    cc.defineGetterSetter(a, "fillStyle", a._getFillStyle, a.setFontFillColor);
    cc.defineGetterSetter(a, "strokeStyle", a._getStrokeStyle, a._setStrokeStyle);
    cc.defineGetterSetter(a, "lineWidth", a._getLineWidth, a._setLineWidth);
    cc.defineGetterSetter(a, "shadowOffsetX",
        a._getShadowOffsetX, a._setShadowOffsetX);
    cc.defineGetterSetter(a, "shadowOffsetY", a._getShadowOffsetY, a._setShadowOffsetY);
    cc.defineGetterSetter(a, "shadowOpacity", a._getShadowOpacity, a._setShadowOpacity);
    cc.defineGetterSetter(a, "shadowBlur", a._getShadowBlur, a._setShadowBlur)
};
cc.LabelTTF = cc.Sprite.extend({
    _dimensions: null,
    _hAlignment: cc.TEXT_ALIGNMENT_CENTER,
    _vAlignment: cc.VERTICAL_TEXT_ALIGNMENT_TOP,
    _fontName: null,
    _fontSize: 0,
    _string: "",
    _originalText: null,
    _isMultiLine: !1,
    _fontStyleStr: null,
    _shadowEnabled: !1,
    _shadowOffset: null,
    _shadowOpacity: 0,
    _shadowBlur: 0,
    _shadowColorStr: null,
    _shadowColor: null,
    _strokeEnabled: !1,
    _strokeColor: null,
    _strokeSize: 0,
    _strokeColorStr: null,
    _textFillColor: null,
    _fillColorStr: null,
    _strokeShadowOffsetX: 0,
    _strokeShadowOffsetY: 0,
    _needUpdateTexture: !1,
    _labelCanvas: null,
    _labelContext: null,
    _lineWidths: null,
    _className: "LabelTTF",
    initWithString: function(a, b, c, d, e, f) {
        a = a ? a + "" : "";
        c = c || 16;
        d = d || cc.size(0, 0);
        e = e || cc.TEXT_ALIGNMENT_LEFT;
        f = f || cc.VERTICAL_TEXT_ALIGNMENT_TOP;
        this._opacityModifyRGB = !1;
        this._dimensions = cc.size(d.width, d.height);
        this._fontName = b || "Arial";
        this._hAlignment = e;
        this._vAlignment = f;
        this._fontSize = c;
        this._fontStyleStr = this._fontSize + "px '" + b + "'";
        this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(b, this._fontSize);
        this.string = a;
        this._setColorsString();
        this._updateTexture();
        this._setUpdateTextureDirty();
        return !0
    },
    _setUpdateTextureDirty: function() {
        this._renderCmdDiry = this._needUpdateTexture = !0;
        cc.renderer.pushDirtyNode(this)
    },
    ctor: function(a, b, c, d, e, f) {
        cc.Sprite.prototype.ctor.call(this);
        this._dimensions = cc.size(0, 0);
        this._hAlignment = cc.TEXT_ALIGNMENT_LEFT;
        this._vAlignment = cc.VERTICAL_TEXT_ALIGNMENT_TOP;
        this._opacityModifyRGB = !1;
        this._fontStyleStr = "";
        this._fontName = "Arial";
        this._shadowEnabled = this._isMultiLine = !1;
        this._shadowOffset = cc.p(0, 0);
        this._shadowBlur =
            this._shadowOpacity = 0;
        this._shadowColorStr = "rgba(128, 128, 128, 0.5)";
        this._strokeEnabled = !1;
        this._strokeColor = cc.color(255, 255, 255, 255);
        this._strokeSize = 0;
        this._strokeColorStr = "";
        this._textFillColor = cc.color(255, 255, 255, 255);
        this._fillColorStr = "rgba(255,255,255,1)";
        this._strokeShadowOffsetY = this._strokeShadowOffsetX = 0;
        this._needUpdateTexture = !1;
        this._lineWidths = [];
        this._setColorsString();
        b && b instanceof cc.FontDefinition ? this.initWithStringAndTextDefinition(a, b) : cc.LabelTTF.prototype.initWithString.call(this,
            a, b, c, d, e, f)
    },
    init: function() {
        return this.initWithString(" ", this._fontName, this._fontSize)
    },
    _measureConfig: function() {
        this._getLabelContext().font = this._fontStyleStr
    },
    _measure: function(a) {
        return this._getLabelContext().measureText(a).width
    },
    description: function() {
        return "\x3ccc.LabelTTF | FontName \x3d" + this._fontName + " FontSize \x3d " + this._fontSize.toFixed(1) + "\x3e"
    },
    setColor: null,
    _setColorsString: null,
    updateDisplayedColor: null,
    setOpacity: null,
    updateDisplayedOpacity: null,
    updateDisplayedOpacityForCanvas: function(a) {
        cc.Node.prototype.updateDisplayedOpacity.call(this,
            a);
        this._setColorsString()
    },
    getString: function() {
        return this._string
    },
    getHorizontalAlignment: function() {
        return this._hAlignment
    },
    getVerticalAlignment: function() {
        return this._vAlignment
    },
    getDimensions: function() {
        return cc.size(this._dimensions)
    },
    getFontSize: function() {
        return this._fontSize
    },
    getFontName: function() {
        return this._fontName
    },
    initWithStringAndTextDefinition: null,
    setTextDefinition: function(a) {
        a && this._updateWithTextDefinition(a, !0)
    },
    getTextDefinition: function() {
        return this._prepareTextDefinition(!1)
    },
    enableShadow: function(a, b, c, d) {
        null != a.r && null != a.g && null != a.b && null != a.a ? this._enableShadow(a, b, c) : this._enableShadowNoneColor(a, b, c, d)
    },
    _enableShadowNoneColor: function(a, b, c, d) {
        c = c || 0.5;
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        var e = this._shadowOffset;
        if (e && e.x != a || e._y != b) e.x = a, e.y = b;
        this._shadowOpacity != c && (this._shadowOpacity = c);
        this._setColorsString();
        this._shadowBlur != d && (this._shadowBlur = d);
        this._setUpdateTextureDirty()
    },
    _enableShadow: function(a, b, c) {
        this._shadowColor || (this._shadowColor =
            cc.color(255, 255, 255, 128));
        this._shadowColor.r = a.r;
        this._shadowColor.g = a.g;
        this._shadowColor.b = a.b;
        this._enableShadowNoneColor(b.width || b.x || 0, b.height || b.y || 0, null != a.a ? a.a / 255 : 0.5, c)
    },
    _getShadowOffsetX: function() {
        return this._shadowOffset.x
    },
    _setShadowOffsetX: function(a) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        this._shadowOffset.x != a && (this._shadowOffset.x = a, this._setUpdateTextureDirty())
    },
    _getShadowOffsetY: function() {
        return this._shadowOffset._y
    },
    _setShadowOffsetY: function(a) {
        !1 === this._shadowEnabled &&
            (this._shadowEnabled = !0);
        this._shadowOffset._y != a && (this._shadowOffset._y = a, this._setUpdateTextureDirty())
    },
    _getShadowOffset: function() {
        return cc.p(this._shadowOffset.x, this._shadowOffset.y)
    },
    _setShadowOffset: function(a) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        if (this._shadowOffset.x != a.x || this._shadowOffset.y != a.y) this._shadowOffset.x = a.x, this._shadowOffset.y = a.y, this._setUpdateTextureDirty()
    },
    _getShadowOpacity: function() {
        return this._shadowOpacity
    },
    _setShadowOpacity: function(a) {
        !1 ===
            this._shadowEnabled && (this._shadowEnabled = !0);
        this._shadowOpacity != a && (this._shadowOpacity = a, this._setColorsString(), this._setUpdateTextureDirty())
    },
    _getShadowBlur: function() {
        return this._shadowBlur
    },
    _setShadowBlur: function(a) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        this._shadowBlur != a && (this._shadowBlur = a, this._setUpdateTextureDirty())
    },
    disableShadow: function() {
        this._shadowEnabled && (this._shadowEnabled = !1, this._setUpdateTextureDirty())
    },
    enableStroke: function(a, b) {
        !1 === this._strokeEnabled &&
            (this._strokeEnabled = !0);
        var c = this._strokeColor;
        if (c.r !== a.r || c.g !== a.g || c.b !== a.b) c.r = a.r, c.g = a.g, c.b = a.b, this._setColorsString();
        this._strokeSize !== b && (this._strokeSize = b || 0);
        this._setUpdateTextureDirty()
    },
    _getStrokeStyle: function() {
        return this._strokeColor
    },
    _setStrokeStyle: function(a) {
        !1 === this._strokeEnabled && (this._strokeEnabled = !0);
        var b = this._strokeColor;
        if (b.r !== a.r || b.g !== a.g || b.b !== a.b) b.r = a.r, b.g = a.g, b.b = a.b, this._setColorsString(), this._setUpdateTextureDirty()
    },
    _getLineWidth: function() {
        return this._strokeSize
    },
    _setLineWidth: function(a) {
        !1 === this._strokeEnabled && (this._strokeEnabled = !0);
        this._strokeSize !== a && (this._strokeSize = a || 0, this._setUpdateTextureDirty())
    },
    disableStroke: function() {
        this._strokeEnabled && (this._strokeEnabled = !1, this._setUpdateTextureDirty())
    },
    setFontFillColor: null,
    _getFillStyle: function() {
        return this._textFillColor
    },
    _updateWithTextDefinition: function(a, b) {
        a.fontDimensions ? (this._dimensions.width = a.boundingWidth, this._dimensions.height = a.boundingHeight) : (this._dimensions.width = 0, this._dimensions.height =
            0);
        this._hAlignment = a.textAlign;
        this._vAlignment = a.verticalAlign;
        this._fontName = a.fontName;
        this._fontSize = a.fontSize || 12;
        this._fontStyleStr = this._fontSize + "px '" + this._fontName + "'";
        this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(this._fontName, this._fontSize);
        a.shadowEnabled && this.enableShadow(a.shadowOffsetX, a.shadowOffsetY, a.shadowOpacity, a.shadowBlur);
        a.strokeEnabled && this.enableStroke(a.strokeStyle, a.lineWidth);
        this.setFontFillColor(a.fillStyle);
        b && this._updateTexture()
    },
    _prepareTextDefinition: function(a) {
        var b =
            new cc.FontDefinition;
        a ? (b.fontSize = this._fontSize, b.boundingWidth = cc.contentScaleFactor() * this._dimensions.width, b.boundingHeight = cc.contentScaleFactor() * this._dimensions.height) : (b.fontSize = this._fontSize, b.boundingWidth = this._dimensions.width, b.boundingHeight = this._dimensions.height);
        b.fontName = this._fontName;
        b.textAlign = this._hAlignment;
        b.verticalAlign = this._vAlignment;
        if (this._strokeEnabled) {
            b.strokeEnabled = !0;
            var c = this._strokeColor;
            b.strokeStyle = cc.color(c.r, c.g, c.b);
            b.lineWidth = this._strokeSize
        } else b.strokeEnabled = !1;
        this._shadowEnabled ? (b.shadowEnabled = !0, b.shadowBlur = this._shadowBlur, b.shadowOpacity = this._shadowOpacity, b.shadowOffsetX = (a ? cc.contentScaleFactor() : 1) * this._shadowOffset.x, b.shadowOffsetY = (a ? cc.contentScaleFactor() : 1) * this._shadowOffset.y) : b._shadowEnabled = !1;
        a = this._textFillColor;
        b.fillStyle = cc.color(a.r, a.g, a.b);
        return b
    },
    _fontClientHeight: 18,
    setString: function(a) {
        a = String(a);
        this._originalText != a && (this._originalText = a + "", this._updateString(), this._setUpdateTextureDirty())
    },
    _updateString: function() {
        this._string =
            this._originalText
    },
    setHorizontalAlignment: function(a) {
        a !== this._hAlignment && (this._hAlignment = a, this._setUpdateTextureDirty())
    },
    setVerticalAlignment: function(a) {
        a != this._vAlignment && (this._vAlignment = a, this._setUpdateTextureDirty())
    },
    setDimensions: function(a, b) {
        var c;
        void 0 === b ? (c = a.width, b = a.height) : c = a;
        if (c != this._dimensions.width || b != this._dimensions.height) this._dimensions.width = c, this._dimensions.height = b, this._updateString(), this._setUpdateTextureDirty()
    },
    _getBoundingWidth: function() {
        return this._dimensions.width
    },
    _setBoundingWidth: function(a) {
        a != this._dimensions.width && (this._dimensions.width = a, this._updateString(), this._setUpdateTextureDirty())
    },
    _getBoundingHeight: function() {
        return this._dimensions.height
    },
    _setBoundingHeight: function(a) {
        a != this._dimensions.height && (this._dimensions.height = a, this._updateString(), this._setUpdateTextureDirty())
    },
    setFontSize: function(a) {
        this._fontSize !== a && (this._fontSize = a, this._fontStyleStr = a + "px '" + this._fontName + "'", this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(this._fontName,
            a), this._setUpdateTextureDirty())
    },
    setFontName: function(a) {
        this._fontName && this._fontName != a && (this._fontName = a, this._fontStyleStr = this._fontSize + "px '" + a + "'", this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(a, this._fontSize), this._setUpdateTextureDirty())
    },
    _getFont: function() {
        return this._fontStyleStr
    },
    _setFont: function(a) {
        var b = cc.LabelTTF._fontStyleRE.exec(a);
        b && (this._fontSize = parseInt(b[1]), this._fontName = b[2], this._fontStyleStr = a, this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(this._fontName,
            this._fontSize), this._setUpdateTextureDirty())
    },
    _drawTTFInCanvas: function(a) {
        if (a) {
            var b = this._strokeShadowOffsetX,
                c = this._strokeShadowOffsetY,
                d = this._contentSize.height - c,
                e = this._vAlignment,
                f = this._hAlignment,
                g = this._fontClientHeight,
                h = this._strokeSize;
            a.setTransform(1, 0, 0, 1, 0 + 0.5 * b, d + 0.5 * c);
            a.font != this._fontStyleStr && (a.font = this._fontStyleStr);
            a.fillStyle = this._fillColorStr;
            var k = c = 0,
                m = this._strokeEnabled;
            m && (a.lineWidth = 2 * h, a.strokeStyle = this._strokeColorStr);
            this._shadowEnabled && (h = this._shadowOffset,
                a.shadowColor = this._shadowColorStr, a.shadowOffsetX = h.x, a.shadowOffsetY = -h.y, a.shadowBlur = this._shadowBlur);
            a.textBaseline = cc.LabelTTF._textBaseline[e];
            a.textAlign = cc.LabelTTF._textAlign[f];
            b = this._contentSize.width - b;
            c = f === cc.TEXT_ALIGNMENT_RIGHT ? c + b : f === cc.TEXT_ALIGNMENT_CENTER ? c + b / 2 : c + 0;
            if (this._isMultiLine) {
                f = this._strings.length;
                e === cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM ? k = g + d - g * f : e === cc.VERTICAL_TEXT_ALIGNMENT_CENTER && (k = g / 2 + (d - g * f) / 2);
                for (e = 0; e < f; e++) b = this._strings[e], h = -d + g * e + k, m && a.strokeText(b,
                    c, h), a.fillText(b, c, h)
            } else e !== cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM && (k = e === cc.VERTICAL_TEXT_ALIGNMENT_TOP ? k - d : k - 0.5 * d), m && a.strokeText(this._string, c, k), a.fillText(this._string, c, k)
        }
    },
    _getLabelContext: function() {
        if (this._labelContext) return this._labelContext;
        if (!this._labelCanvas) {
            var a = cc.newElement("canvas"),
                b = new cc.Texture2D;
            b.initWithElement(a);
            this.texture = b;
            this._labelCanvas = a
        }
        return this._labelContext = this._labelCanvas.getContext("2d")
    },
    _checkWarp: function(a, b, c) {
        var d = a[b],
            e = this._measure(d);
        if (e > c && 1 < d.length) {
            for (var f = d.length * (c / e) | 0, g = d.substr(f), h = e - this._measure(g), k, m = 0, n = 0; h > c && 100 > n++;) f *= c / h, f |= 0, g = d.substr(f), h = e - this._measure(g);
            for (n = 0; h < c && 100 > n++;) g && (m = (k = cc.LabelTTF._wordRex.exec(g)) ? k[0].length : 1, k = g), f += m, g = d.substr(f), h = e - this._measure(g);
            f -= m;
            c = d.substr(0, f);
            if (cc.LabelTTF.wrapInspection && cc.LabelTTF._symbolRex.test(k || g)) e = cc.LabelTTF._lastWordRex.exec(c), f -= e ? e[0].length : 0, k = d.substr(f), c = d.substr(0, f);
            if (cc.LabelTTF._firsrEnglish.test(k) && (e = cc.LabelTTF._lastEnglish.exec(c)) &&
                c !== e[0]) f -= e[0].length, k = d.substr(f), c = d.substr(0, f);
            a[b] = k || g;
            a.splice(b, 0, c)
        }
    },
    _updateTTF: function() {
        var a = this._dimensions.width,
            b, c, d = this._lineWidths;
        d.length = 0;
        this._isMultiLine = !1;
        this._measureConfig();
        if (0 !== a) {
            this._strings = this._string.split("\n");
            for (b = 0; b < this._strings.length; b++) this._checkWarp(this._strings, b, a)
        } else {
            this._strings = this._string.split("\n");
            b = 0;
            for (c = this._strings.length; b < c; b++) d.push(this._measure(this._strings[b]))
        }
        0 < this._strings.length && (this._isMultiLine = !0);
        c =
            b = 0;
        this._strokeEnabled && (b = c = 2 * this._strokeSize);
        if (this._shadowEnabled) {
            var e = this._shadowOffset;
            b += 2 * Math.abs(e.x);
            c += 2 * Math.abs(e.y)
        }
        a = 0 === a ? this._isMultiLine ? cc.size(0 | Math.max.apply(Math, d) + b, 0 | this._fontClientHeight * this._strings.length + c) : cc.size(0 | this._measure(this._string) + b, 0 | this._fontClientHeight + c) : 0 === this._dimensions.height ? this._isMultiLine ? cc.size(0 | a + b, 0 | this._fontClientHeight * this._strings.length + c) : cc.size(0 | a + b, 0 | this._fontClientHeight + c) : cc.size(0 | a + b, 0 | this._dimensions.height +
            c);
        this.setContentSize(a);
        this._strokeShadowOffsetX = b;
        this._strokeShadowOffsetY = c;
        d = this._anchorPoint;
        this._anchorPointInPoints.x = 0.5 * b + (a.width - b) * d.x;
        this._anchorPointInPoints.y = 0.5 * c + (a.height - c) * d.y
    },
    getContentSize: function() {
        this._needUpdateTexture && this._updateTTF();
        return cc.Sprite.prototype.getContentSize.call(this)
    },
    _getWidth: function() {
        this._needUpdateTexture && this._updateTTF();
        return cc.Sprite.prototype._getWidth.call(this)
    },
    _getHeight: function() {
        this._needUpdateTexture && this._updateTTF();
        return cc.Sprite.prototype._getHeight.call(this)
    },
    _updateTexture: function() {
        var a = this._getLabelContext(),
            b = this._labelCanvas,
            c = this._contentSize;
        if (0 === this._string.length) return b.width = 1, b.height = c.height || 1, this._texture && this._texture.handleLoadedTexture(), this.setTextureRect(cc.rect(0, 0, 1, c.height)), !0;
        a.font = this._fontStyleStr;
        this._updateTTF();
        var d = c.width,
            c = c.height,
            e = b.width == d && b.height == c;
        b.width = d;
        b.height = c;
        e && a.clearRect(0, 0, d, c);
        this._drawTTFInCanvas(a);
        this._texture && this._texture.handleLoadedTexture();
        this.setTextureRect(cc.rect(0, 0, d, c));
        return !0
    },
    visit: function(a) {
        this._string && "" != this._string && (this._needUpdateTexture && (this._needUpdateTexture = !1, this._updateTexture()), cc.Sprite.prototype.visit.call(this, a || cc._renderContext))
    },
    draw: null,
    _setTextureCoords: function(a) {
        var b = this._batchNode ? this.textureAtlas.texture : this._texture;
        if (b) {
            var c = b.pixelsWidth,
                d = b.pixelsHeight,
                e, f = this._quad;
            this._rectRotated ? (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (b = (2 * a.x + 1) / (2 * c), c = b + (2 * a.height - 2) / (2 * c), e = (2 * a.y +
                1) / (2 * d), a = e + (2 * a.width - 2) / (2 * d)) : (b = a.x / c, c = (a.x + a.height) / c, e = a.y / d, a = (a.y + a.width) / d), this._flippedX && (d = e, e = a, a = d), this._flippedY && (d = b, b = c, c = d), f.bl.texCoords.u = b, f.bl.texCoords.v = e, f.br.texCoords.u = b, f.br.texCoords.v = a, f.tl.texCoords.u = c, f.tl.texCoords.v = e, f.tr.texCoords.u = c, f.tr.texCoords.v = a) : (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (b = (2 * a.x + 1) / (2 * c), c = b + (2 * a.width - 2) / (2 * c), e = (2 * a.y + 1) / (2 * d), a = e + (2 * a.height - 2) / (2 * d)) : (b = a.x / c, c = (a.x + a.width) / c, e = a.y / d, a = (a.y + a.height) / d), this._flippedX && (d = b,
                b = c, c = d), this._flippedY && (d = e, e = a, a = d), f.bl.texCoords.u = b, f.bl.texCoords.v = a, f.br.texCoords.u = c, f.br.texCoords.v = a, f.tl.texCoords.u = b, f.tl.texCoords.v = e, f.tr.texCoords.u = c, f.tr.texCoords.v = e);
            this._quadDirty = !0
        }
    }
});
cc._renderType === cc._RENDER_TYPE_CANVAS ? (_p = cc.LabelTTF.prototype, _p.setColor = function(a) {
    cc.Node.prototype.setColor.call(this, a);
    this._setColorsString()
}, _p._transformForRenderer = function() {
    this._needUpdateTexture && (this._needUpdateTexture = !1, this._updateTexture());
    cc.Node.prototype._transformForRenderer.call(this)
}, _p._setColorsString = function() {
    this._setUpdateTextureDirty();
    var a = this._displayedColor,
        b = this._displayedOpacity,
        c = this._shadowColor || this._displayedColor,
        d = this._strokeColor,
        e = this._textFillColor;
    this._shadowColorStr = "rgba(" + (0 | 0.5 * c.r) + "," + (0 | 0.5 * c.g) + "," + (0 | 0.5 * c.b) + "," + this._shadowOpacity + ")";
    this._fillColorStr = "rgba(" + (0 | a.r / 255 * e.r) + "," + (0 | a.g / 255 * e.g) + "," + (0 | a.b / 255 * e.b) + ", " + b / 255 + ")";
    this._strokeColorStr = "rgba(" + (0 | a.r / 255 * d.r) + "," + (0 | a.g / 255 * d.g) + "," + (0 | a.b / 255 * d.b) + ", " + b / 255 + ")"
}, _p.updateDisplayedColor = function(a) {
    cc.Node.prototype.updateDisplayedColor.call(this, a);
    this._setColorsString()
}, _p.setOpacity = function(a) {
    this._opacity !== a && (cc.Sprite.prototype.setOpacity.call(this, a),
        this._setColorsString(), this._setUpdateTextureDirty())
}, _p.updateDisplayedOpacity = cc.Sprite.prototype.updateDisplayedOpacity, _p.initWithStringAndTextDefinition = function(a, b) {
    this._updateWithTextDefinition(b, !1);
    this.string = a;
    return !0
}, _p.setFontFillColor = function(a) {
    var b = this._textFillColor;
    if (b.r != a.r || b.g != a.g || b.b != a.b) b.r = a.r, b.g = a.g, b.b = a.b, this._setColorsString(), this._setUpdateTextureDirty()
}, _p.draw = cc.Sprite.prototype.draw, _p.setTextureRect = function(a, b, c) {
    this._rectRotated = b || !1;
    this.setContentSize(c ||
        a);
    this.setVertexRect(a);
    b = this._rendererCmd._textureCoord;
    b.x = a.x;
    b.y = a.y;
    b.renderX = a.x;
    b.renderY = a.y;
    b.width = a.width;
    b.height = a.height;
    b.validRect = !(0 === b.width || 0 === b.height || 0 > b.x || 0 > b.y);
    a = this._unflippedOffsetPositionFromCenter;
    this._flippedX && (a.x = -a.x);
    this._flippedY && (a.y = -a.y);
    this._offsetPosition.x = a.x + (this._contentSize.width - this._rect.width) / 2;
    this._offsetPosition.y = a.y + (this._contentSize.height - this._rect.height) / 2;
    this._batchNode && (this.dirty = !0)
}, _p = null) : (cc.assert(cc.isFunction(cc._tmp.WebGLLabelTTF),
    cc._LogInfos.MissingFile, "LabelTTFWebGL.js"), cc._tmp.WebGLLabelTTF(), delete cc._tmp.WebGLLabelTTF);
cc.assert(cc.isFunction(cc._tmp.PrototypeLabelTTF), cc._LogInfos.MissingFile, "LabelTTFPropertyDefine.js");
cc._tmp.PrototypeLabelTTF();
delete cc._tmp.PrototypeLabelTTF;
cc.LabelTTF._textAlign = ["left", "center", "right"];
cc.LabelTTF._textBaseline = ["top", "middle", "bottom"];
cc.LabelTTF.wrapInspection = !0;
cc.LabelTTF._wordRex = /([a-zA-Z0-9\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00e9\u00e8\u00e7\u00e0\u00f9\u00ea\u00e2\u00ee\u00f4\u00fb]+|\S)/;
cc.LabelTTF._symbolRex = /^[!,.:;}\]%\?>\u3001\u2018\u201c\u300b\uff1f\u3002\uff0c\uff01]/;
cc.LabelTTF._lastWordRex = /([a-zA-Z0-9\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00e9\u00e8\u00e7\u00e0\u00f9\u00ea\u00e2\u00ee\u00f4\u00fb]+|\S)$/;
cc.LabelTTF._lastEnglish = /[a-zA-Z0-9\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00e9\u00e8\u00e7\u00e0\u00f9\u00ea\u00e2\u00ee\u00f4\u00fb]+$/;
cc.LabelTTF._firsrEnglish = /^[a-zA-Z0-9\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00e9\u00e8\u00e7\u00e0\u00f9\u00ea\u00e2\u00ee\u00f4\u00fb]/;
cc.LabelTTF._fontStyleRE = /^(\d+)px\s+['"]?([\w\s\d]+)['"]?$/;
cc.LabelTTF.create = function(a, b, c, d, e, f) {
    return new cc.LabelTTF(a, b, c, d, e, f)
};
cc.LabelTTF.createWithFontDefinition = cc.LabelTTF.create;
cc.LabelTTF._SHADER_PROGRAM = cc.USE_LA88_LABELS ? cc.SHADER_POSITION_TEXTURECOLOR : cc.SHADER_POSITION_TEXTUREA8COLOR;
cc.LabelTTF.__labelHeightDiv = cc.newElement("div");
cc.LabelTTF.__labelHeightDiv.style.fontFamily = "Arial";
cc.LabelTTF.__labelHeightDiv.style.position = "absolute";
cc.LabelTTF.__labelHeightDiv.style.left = "-100px";
cc.LabelTTF.__labelHeightDiv.style.top = "-100px";
cc.LabelTTF.__labelHeightDiv.style.lineHeight = "normal";
document.body ? document.body.appendChild(cc.LabelTTF.__labelHeightDiv) : cc._addEventListener(window, "load", function() {
    this.removeEventListener("load", arguments.callee, !1);
    document.body.appendChild(cc.LabelTTF.__labelHeightDiv)
}, !1);
cc.LabelTTF.__getFontHeightByDiv = function(a, b) {
    var c = cc.LabelTTF.__fontHeightCache[a + "." + b];
    if (0 < c) return c;
    var d = cc.LabelTTF.__labelHeightDiv;
    d.innerHTML = "ajghl~!";
    d.style.fontFamily = a;
    d.style.fontSize = b + "px";
    c = d.clientHeight;
    cc.LabelTTF.__fontHeightCache[a + "." + b] = c;
    d.innerHTML = "";
    return c
};
cc.LabelTTF.__fontHeightCache = {};
cc.HashElement = cc.Class.extend({
    actions: null,
    target: null,
    actionIndex: 0,
    currentAction: null,
    currentActionSalvaged: !1,
    paused: !1,
    hh: null,
    ctor: function() {
        this.actions = [];
        this.target = null;
        this.actionIndex = 0;
        this.currentAction = null;
        this.paused = this.currentActionSalvaged = !1;
        this.hh = null
    }
});
cc.ActionManager = cc.Class.extend({
    _hashTargets: null,
    _arrayTargets: null,
    _currentTarget: null,
    _currentTargetSalvaged: !1,
    _searchElementByTarget: function(a, b) {
        for (var c = 0; c < a.length; c++)
            if (b == a[c].target) return a[c];
        return null
    },
    ctor: function() {
        this._hashTargets = {};
        this._arrayTargets = [];
        this._currentTarget = null;
        this._currentTargetSalvaged = !1
    },
    addAction: function(a, b, c) {
        if (!a) throw "cc.ActionManager.addAction(): action must be non-null";
        if (!b) throw "cc.ActionManager.addAction(): action must be non-null";
        var d =
            this._hashTargets[b.__instanceId];
        d || (d = new cc.HashElement, d.paused = c, d.target = b, this._hashTargets[b.__instanceId] = d, this._arrayTargets.push(d));
        this._actionAllocWithHashElement(d);
        d.actions.push(a);
        a.startWithTarget(b)
    },
    removeAllActions: function() {
        for (var a = this._arrayTargets, b = 0; b < a.length; b++) {
            var c = a[b];
            c && this.removeAllActionsFromTarget(c.target, !0)
        }
    },
    removeAllActionsFromTarget: function(a, b) {
        if (null != a) {
            var c = this._hashTargets[a.__instanceId];
            c && (-1 !== c.actions.indexOf(c.currentAction) && !c.currentActionSalvaged &&
                (c.currentActionSalvaged = !0), c.actions.length = 0, this._currentTarget == c && !b ? this._currentTargetSalvaged = !0 : this._deleteHashElement(c))
        }
    },
    removeAction: function(a) {
        if (null != a) {
            var b = a.getOriginalTarget();
            if (b = this._hashTargets[b.__instanceId])
                for (var c = 0; c < b.actions.length; c++) {
                    if (b.actions[c] == a) {
                        b.actions.splice(c, 1);
                        break
                    }
                } else cc.log(cc._LogInfos.ActionManager_removeAction)
        }
    },
    removeActionByTag: function(a, b) {
        a == cc.ACTION_TAG_INVALID && cc.log(cc._LogInfos.ActionManager_addAction);
        cc.assert(b, cc._LogInfos.ActionManager_addAction);
        var c = this._hashTargets[b.__instanceId];
        if (c)
            for (var d = c.actions.length, e = 0; e < d; ++e) {
                var f = c.actions[e];
                if (f && f.getTag() === a && f.getOriginalTarget() == b) {
                    this._removeActionAtIndex(e, c);
                    break
                }
            }
    },
    getActionByTag: function(a, b) {
        a == cc.ACTION_TAG_INVALID && cc.log(cc._LogInfos.ActionManager_getActionByTag);
        var c = this._hashTargets[b.__instanceId];
        if (c) {
            if (null != c.actions)
                for (var d = 0; d < c.actions.length; ++d) {
                    var e = c.actions[d];
                    if (e && e.getTag() === a) return e
                }
            cc.log(cc._LogInfos.ActionManager_getActionByTag_2, a)
        }
        return null
    },
    numberOfRunningActionsInTarget: function(a) {
        return (a = this._hashTargets[a.__instanceId]) ? a.actions ? a.actions.length : 0 : 0
    },
    pauseTarget: function(a) {
        (a = this._hashTargets[a.__instanceId]) && (a.paused = !0)
    },
    resumeTarget: function(a) {
        (a = this._hashTargets[a.__instanceId]) && (a.paused = !1)
    },
    pauseAllRunningActions: function() {
        for (var a = [], b = this._arrayTargets, c = 0; c < b.length; c++) {
            var d = b[c];
            d && !d.paused && (d.paused = !0, a.push(d.target))
        }
        return a
    },
    resumeTargets: function(a) {
        if (a)
            for (var b = 0; b < a.length; b++) a[b] && this.resumeTarget(a[b])
    },
    purgeSharedManager: function() {
        cc.director.getScheduler().unscheduleUpdateForTarget(this)
    },
    _removeActionAtIndex: function(a, b) {
        b.actions[a] == b.currentAction && !b.currentActionSalvaged && (b.currentActionSalvaged = !0);
        b.actions.splice(a, 1);
        b.actionIndex >= a && b.actionIndex--;
        0 == b.actions.length && (this._currentTarget == b ? this._currentTargetSalvaged = !0 : this._deleteHashElement(b))
    },
    _deleteHashElement: function(a) {
        a && (delete this._hashTargets[a.target.__instanceId], cc.arrayRemoveObject(this._arrayTargets, a), a.actions =
            null, a.target = null)
    },
    _actionAllocWithHashElement: function(a) {
        null == a.actions && (a.actions = [])
    },
    update: function(a) {
        for (var b = this._arrayTargets, c, d = 0; d < b.length; d++) {
            c = this._currentTarget = b[d];
            if (!c.paused)
                for (c.actionIndex = 0; c.actionIndex < c.actions.length; c.actionIndex++)
                    if (c.currentAction = c.actions[c.actionIndex], c.currentAction) {
                        c.currentActionSalvaged = !1;
                        c.currentAction.step(a * (c.currentAction._speedMethod ? c.currentAction._speed : 1));
                        if (c.currentActionSalvaged) c.currentAction = null;
                        else if (c.currentAction.isDone()) {
                            c.currentAction.stop();
                            var e = c.currentAction;
                            c.currentAction = null;
                            this.removeAction(e)
                        }
                        c.currentAction = null
                    }
            this._currentTargetSalvaged && 0 === c.actions.length && this._deleteHashElement(c)
        }
    }
});
cc.kmScalar = Number;
cc.kmBool = Number;
cc.kmEnum = Number;
cc.KM_FALSE = 0;
cc.KM_TRUE = 1;
cc.kmPI = 3.141592;
cc.kmPIOver180 = 0.017453;
cc.kmPIUnder180 = 57.295779;
cc.kmEpsilon = 0.015625;
cc.kmSQR = function(a) {
    return a * a
};
cc.kmDegreesToRadians = function(a) {
    return a * cc.kmPIOver180
};
cc.kmRadiansToDegrees = function(a) {
    return a * cc.kmPIUnder180
};
cc.kmMin = function(a, b) {
    return a < b ? a : b
};
cc.kmMax = function(a, b) {
    return a > b ? a : b
};
cc.kmAlmostEqual = function(a, b) {
    return a + cc.kmEpsilon > b && a - cc.kmEpsilon < b
};
cc.kmVec2 = function(a, b) {
    this.x = a || 0;
    this.y = b || 0
};
cc.kmVec2Fill = function(a, b, c) {
    a.x = b;
    a.y = c;
    return a
};
cc.kmVec2Length = function(a) {
    return Math.sqrt(cc.kmSQR(a.x) + cc.kmSQR(a.y))
};
cc.kmVec2LengthSq = function(a) {
    return cc.kmSQR(a.x) + cc.kmSQR(a.y)
};
cc.kmVec2Normalize = function(a, b) {
    var c = 1 / cc.kmVec2Length(b),
        d = new cc.kmVec2;
    d.x = b.x * c;
    d.y = b.y * c;
    a.x = d.x;
    a.y = d.y;
    return a
};
cc.kmVec2Add = function(a, b, c) {
    a.x = b.x + c.x;
    a.y = b.y + c.y;
    return a
};
cc.kmVec2Dot = function(a, b) {
    return a.x * b.x + a.y * b.y
};
cc.kmVec2Subtract = function(a, b, c) {
    a.x = b.x - c.x;
    a.y = b.y - c.y;
    return a
};
cc.kmVec2Transform = function(a, b, c) {
    var d = new cc.kmVec2;
    d.x = b.x * c.mat[0] + b.y * c.mat[3] + c.mat[6];
    d.y = b.x * c.mat[1] + b.y * c.mat[4] + c.mat[7];
    a.x = d.x;
    a.y = d.y;
    return a
};
cc.kmVec2TransformCoord = function(a, b, c) {
    return null
};
cc.kmVec2Scale = function(a, b, c) {
    a.x = b.x * c;
    a.y = b.y * c;
    return a
};
cc.kmVec2AreEqual = function(a, b) {
    return a.x < b.x + cc.kmEpsilon && a.x > b.x - cc.kmEpsilon && a.y < b.y + cc.kmEpsilon && a.y > b.y - cc.kmEpsilon
};
cc.kmVec3 = function(a, b, c) {
    this.x = a || 0;
    this.y = b || 0;
    this.z = c || 0
};
cc.kmVec3Fill = function(a, b, c, d) {
    if (!a) return new cc.kmVec3(b, c, d);
    a.x = b;
    a.y = c;
    a.z = d;
    return a
};
cc.kmVec3Length = function(a) {
    return Math.sqrt(cc.kmSQR(a.x) + cc.kmSQR(a.y) + cc.kmSQR(a.z))
};
cc.kmVec3LengthSq = function(a) {
    return cc.kmSQR(a.x) + cc.kmSQR(a.y) + cc.kmSQR(a.z)
};
cc.kmVec3Normalize = function(a, b) {
    var c = 1 / cc.kmVec3Length(b);
    a.x = b.x * c;
    a.y = b.y * c;
    a.z = b.z * c;
    return a
};
cc.kmVec3Cross = function(a, b, c) {
    a.x = b.y * c.z - b.z * c.y;
    a.y = b.z * c.x - b.x * c.z;
    a.z = b.x * c.y - b.y * c.x;
    return a
};
cc.kmVec3Dot = function(a, b) {
    return a.x * b.x + a.y * b.y + a.z * b.z
};
cc.kmVec3Add = function(a, b, c) {
    a.x = b.x + c.x;
    a.y = b.y + c.y;
    a.z = b.z + c.z;
    return a
};
cc.kmVec3Subtract = function(a, b, c) {
    a.x = b.x - c.x;
    a.y = b.y - c.y;
    a.z = b.z - c.z;
    return a
};
cc.kmVec3Transform = function(a, b, c) {
    a.x = b.x * c.mat[0] + b.y * c.mat[4] + b.z * c.mat[8] + c.mat[12];
    a.y = b.x * c.mat[1] + b.y * c.mat[5] + b.z * c.mat[9] + c.mat[13];
    a.z = b.x * c.mat[2] + b.y * c.mat[6] + b.z * c.mat[10] + c.mat[14];
    return a
};
cc.kmVec3TransformNormal = function(a, b, c) {
    a.x = b.x * c.mat[0] + b.y * c.mat[4] + b.z * c.mat[8];
    a.y = b.x * c.mat[1] + b.y * c.mat[5] + b.z * c.mat[9];
    a.z = b.x * c.mat[2] + b.y * c.mat[6] + b.z * c.mat[10];
    return a
};
cc.kmVec3TransformCoord = function(a, b, c) {
    var d = new cc.kmVec4,
        e = new cc.kmVec4;
    cc.kmVec4Fill(e, b.x, b.y, b.z, 1);
    cc.kmVec4Transform(d, e, c);
    a.x = d.x / d.w;
    a.y = d.y / d.w;
    a.z = d.z / d.w;
    return a
};
cc.kmVec3Scale = function(a, b, c) {
    a.x = b.x * c;
    a.y = b.y * c;
    a.z = b.z * c;
    return a
};
cc.kmVec3AreEqual = function(a, b) {
    return a.x < b.x + cc.kmEpsilon && a.x > b.x - cc.kmEpsilon && a.y < b.y + cc.kmEpsilon && a.y > b.y - cc.kmEpsilon && a.z < b.z + cc.kmEpsilon && a.z > b.z - cc.kmEpsilon ? 1 : 0
};
cc.kmVec3InverseTransform = function(a, b, c) {
    b = new cc.kmVec3(b.x - c.mat[12], b.y - c.mat[13], b.z - c.mat[14]);
    a.x = b.x * c.mat[0] + b.y * c.mat[1] + b.z * c.mat[2];
    a.y = b.x * c.mat[4] + b.y * c.mat[5] + b.z * c.mat[6];
    a.z = b.x * c.mat[8] + b.y * c.mat[9] + b.z * c.mat[10];
    return a
};
cc.kmVec3InverseTransformNormal = function(a, b, c) {
    a.x = b.x * c.mat[0] + b.y * c.mat[1] + b.z * c.mat[2];
    a.y = b.x * c.mat[4] + b.y * c.mat[5] + b.z * c.mat[6];
    a.z = b.x * c.mat[8] + b.y * c.mat[9] + b.z * c.mat[10];
    return a
};
cc.kmVec3Assign = function(a, b) {
    if (a == b) return a;
    a.x = b.x;
    a.y = b.y;
    a.z = b.z;
    return a
};
cc.kmVec3Zero = function(a) {
    a.x = 0;
    a.y = 0;
    a.z = 0;
    return a
};
cc.kmVec3ToTypeArray = function(a) {
    if (!a) return null;
    var b = new Float32Array(3);
    b[0] = a.x;
    b[1] = a.y;
    b[2] = a.z;
    return b
};
cc.kmVec4 = function(a, b, c, d) {
    this.x = a || 0;
    this.y = b || 0;
    this.z = c || 0;
    this.w = d || 0
};
cc.kmVec4Fill = function(a, b, c, d, e) {
    a.x = b;
    a.y = c;
    a.z = d;
    a.w = e;
    return a
};
cc.kmVec4Add = function(a, b, c) {
    a.x = b.x + c.x;
    a.y = b.y + c.y;
    a.z = b.z + c.z;
    a.w = b.w + c.w;
    return a
};
cc.kmVec4Dot = function(a, b) {
    return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w
};
cc.kmVec4Length = function(a) {
    return Math.sqrt(cc.kmSQR(a.x) + cc.kmSQR(a.y) + cc.kmSQR(a.z) + cc.kmSQR(a.w))
};
cc.kmVec4LengthSq = function(a) {
    return cc.kmSQR(a.x) + cc.kmSQR(a.y) + cc.kmSQR(a.z) + cc.kmSQR(a.w)
};
cc.kmVec4Lerp = function(a, b, c, d) {
    return a
};
cc.kmVec4Normalize = function(a, b) {
    var c = 1 / cc.kmVec4Length(b);
    a.x *= c;
    a.y *= c;
    a.z *= c;
    a.w *= c;
    return a
};
cc.kmVec4Scale = function(a, b, c) {
    cc.kmVec4Normalize(a, b);
    a.x *= c;
    a.y *= c;
    a.z *= c;
    a.w *= c;
    return a
};
cc.kmVec4Subtract = function(a, b, c) {
    a.x = b.x - c.x;
    a.y = b.y - c.y;
    a.z = b.z - c.z;
    a.w = b.w - c.w;
    return a
};
cc.kmVec4Transform = function(a, b, c) {
    a.x = b.x * c.mat[0] + b.y * c.mat[4] + b.z * c.mat[8] + b.w * c.mat[12];
    a.y = b.x * c.mat[1] + b.y * c.mat[5] + b.z * c.mat[9] + b.w * c.mat[13];
    a.z = b.x * c.mat[2] + b.y * c.mat[6] + b.z * c.mat[10] + b.w * c.mat[14];
    a.w = b.x * c.mat[3] + b.y * c.mat[7] + b.z * c.mat[11] + b.w * c.mat[15];
    return a
};
cc.kmVec4TransformArray = function(a, b, c, d, e, f) {
    for (var g = 0; g < f;) cc.kmVec4Transform(a + g * b, c + g * d, e), ++g;
    return a
};
cc.kmVec4AreEqual = function(a, b) {
    return a.x < b.x + cc.kmEpsilon && a.x > b.x - cc.kmEpsilon && a.y < b.y + cc.kmEpsilon && a.y > b.y - cc.kmEpsilon && a.z < b.z + cc.kmEpsilon && a.z > b.z - cc.kmEpsilon && a.w < b.w + cc.kmEpsilon && a.w > b.w - cc.kmEpsilon
};
cc.kmVec4Assign = function(a, b) {
    if (a == b) return cc.log("destVec and srcVec are same object"), a;
    a.x = b.x;
    a.y = b.y;
    a.z = b.z;
    a.w = b.w;
    return a
};
cc.kmVec4ToTypeArray = function(a) {
    if (!a) return null;
    var b = new Float32Array(4);
    b[0] = a.x;
    b[1] = a.y;
    b[2] = a.z;
    b[3] = a.w;
    return b
};
cc.kmRay2 = function(a, b) {
    this.start = a || new cc.kmVec2;
    this.start = a || new cc.kmVec2
};
cc.kmRay2Fill = function(a, b, c, d, e) {
    a.start.x = b;
    a.start.y = c;
    a.dir.x = d;
    a.dir.y = e
};
cc.kmRay2IntersectLineSegment = function(a, b, c, d) {
    var e = a.start.x,
        f = a.start.y,
        g = a.start.x + a.dir.x;
    a = a.start.y + a.dir.y;
    var h = b.x,
        k = b.y,
        m = c.x,
        n = c.y,
        q = (n - k) * (g - e) - (m - h) * (a - f);
    if (q > -cc.kmEpsilon && q < cc.kmEpsilon) return cc.KM_FALSE;
    k = ((m - h) * (f - k) - (n - k) * (e - h)) / q;
    h = e + k * (g - e);
    k = f + k * (a - f);
    if (h < cc.kmMin(b.x, c.x) - cc.kmEpsilon || h > cc.kmMax(b.x, c.x) + cc.kmEpsilon || k < cc.kmMin(b.y, c.y) - cc.kmEpsilon || k > cc.kmMax(b.y, c.y) + cc.kmEpsilon || h < cc.kmMin(e, g) - cc.kmEpsilon || h > cc.kmMax(e, g) + cc.kmEpsilon || k < cc.kmMin(f, a) - cc.kmEpsilon ||
        k > cc.kmMax(f, a) + cc.kmEpsilon) return cc.KM_FALSE;
    d.x = h;
    d.y = k;
    return cc.KM_TRUE
};
cc.calculate_line_normal = function(a, b, c) {
    var d = new cc.kmVec2;
    cc.kmVec2Subtract(d, b, a);
    c.x = -d.y;
    c.y = d.x;
    cc.kmVec2Normalize(c, c)
};
cc.kmRay2IntersectTriangle = function(a, b, c, d, e, f) {
    var g = new cc.kmVec2,
        h = new cc.kmVec2,
        k = new cc.kmVec2,
        m = 1E4,
        n = cc.KM_FALSE,
        q;
    cc.kmRay2IntersectLineSegment(a, b, c, g) && (q = new cc.kmVec2, n = cc.KM_TRUE, q = cc.kmVec2Length(cc.kmVec2Subtract(q, g, a.start)), q < m && (h.x = g.x, h.y = g.y, m = q, cc.calculate_line_normal(b, c, k)));
    cc.kmRay2IntersectLineSegment(a, c, d, g) && (q = new cc.kmVec2, n = cc.KM_TRUE, q = cc.kmVec2Length(cc.kmVec2Subtract(q, g, a.start)), q < m && (h.x = g.x, h.y = g.y, m = q, cc.calculate_line_normal(c, d, k)));
    cc.kmRay2IntersectLineSegment(a,
        d, b, g) && (q = new cc.kmVec2, n = cc.KM_TRUE, q = cc.kmVec2Length(cc.kmVec2Subtract(q, g, a.start)), q < m && (h.x = g.x, h.y = g.y, cc.calculate_line_normal(d, b, k)));
    n && (e.x = h.x, e.y = h.y, f && (f.x = k.x, f.y = k.y));
    return n
};
cc.kmRay2IntersectCircle = function(a, b, c, d) {
    cc.log("cc.kmRay2IntersectCircle() has not been implemented.")
};
var Float32Array = Float32Array || Array;
cc.kmMat3 = function() {
    this.mat = new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0])
};
cc.kmMat3Fill = function(a, b) {
    for (var c = 0; 9 > c; c++) a.mat[c] = b;
    return a
};
cc.kmMat3Adjugate = function(a, b) {
    a.mat[0] = b.mat[4] * b.mat[8] - b.mat[5] * b.mat[7];
    a.mat[1] = b.mat[2] * b.mat[7] - b.mat[1] * b.mat[8];
    a.mat[2] = b.mat[1] * b.mat[5] - b.mat[2] * b.mat[4];
    a.mat[3] = b.mat[5] * b.mat[6] - b.mat[3] * b.mat[8];
    a.mat[4] = b.mat[0] * b.mat[8] - b.mat[2] * b.mat[6];
    a.mat[5] = b.mat[2] * b.mat[3] - b.mat[0] * b.mat[5];
    a.mat[6] = b.mat[3] * b.mat[7] - b.mat[4] * b.mat[6];
    a.mat[8] = b.mat[0] * b.mat[4] - b.mat[1] * b.mat[3];
    return a
};
cc.kmMat3Identity = function(a) {
    a.mat[1] = a.mat[2] = a.mat[3] = a.mat[5] = a.mat[6] = a.mat[7] = 0;
    a.mat[0] = a.mat[4] = a.mat[8] = 1;
    return a
};
cc.kmMat3Inverse = function(a, b, c) {
    var d = new cc.kmMat3;
    if (0 === b) return null;
    b = 1 / b;
    cc.kmMat3Adjugate(d, c);
    cc.kmMat3ScalarMultiply(a, d, b);
    return a
};
cc.kmMat3._identity = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
cc.kmMat3IsIdentity = function(a) {
    for (var b = 0; 9 > b; b++)
        if (cc.kmMat3._identity[b] !== a.mat[b]) return !1;
    return !0
};
cc.kmMat3Transpose = function(a, b) {
    var c, d;
    for (c = 0; 3 > c; ++c)
        for (d = 0; 3 > d; ++d) a.mat[3 * c + d] = b.mat[3 * d + c];
    return a
};
cc.kmMat3Determinant = function(a) {
    var b;
    b = a.mat[0] * a.mat[4] * a.mat[8] + a.mat[1] * a.mat[5] * a.mat[6] + a.mat[2] * a.mat[3] * a.mat[7];
    return b -= a.mat[2] * a.mat[4] * a.mat[6] + a.mat[0] * a.mat[5] * a.mat[7] + a.mat[1] * a.mat[3] * a.mat[8]
};
cc.kmMat3Multiply = function(a, b, c) {
    b = b.mat;
    c = c.mat;
    a.mat[0] = b[0] * c[0] + b[3] * c[1] + b[6] * c[2];
    a.mat[1] = b[1] * c[0] + b[4] * c[1] + b[7] * c[2];
    a.mat[2] = b[2] * c[0] + b[5] * c[1] + b[8] * c[2];
    a.mat[3] = b[0] * c[3] + b[3] * c[4] + b[6] * c[5];
    a.mat[4] = b[1] * c[3] + b[4] * c[4] + b[7] * c[5];
    a.mat[5] = b[2] * c[3] + b[5] * c[4] + b[8] * c[5];
    a.mat[6] = b[0] * c[6] + b[3] * c[7] + b[6] * c[8];
    a.mat[7] = b[1] * c[6] + b[4] * c[7] + b[7] * c[8];
    a.mat[8] = b[2] * c[6] + b[5] * c[7] + b[8] * c[8];
    return a
};
cc.kmMat3ScalarMultiply = function(a, b, c) {
    for (var d = 0; 9 > d; d++) a.mat[d] = b.mat[d] * c;
    return a
};
cc.kmMat3RotationAxisAngle = function(a, b, c) {
    var d = Math.cos(c);
    c = Math.sin(c);
    a.mat[0] = d + b.x * b.x * (1 - d);
    a.mat[1] = b.z * c + b.y * b.x * (1 - d);
    a.mat[2] = -b.y * c + b.z * b.x * (1 - d);
    a.mat[3] = -b.z * c + b.x * b.y * (1 - d);
    a.mat[4] = d + b.y * b.y * (1 - d);
    a.mat[5] = b.x * c + b.z * b.y * (1 - d);
    a.mat[6] = b.y * c + b.x * b.z * (1 - d);
    a.mat[7] = -b.x * c + b.y * b.z * (1 - d);
    a.mat[8] = d + b.z * b.z * (1 - d);
    return a
};
cc.kmMat3Assign = function(a, b) {
    if (a == b) return cc.log("cc.kmMat3Assign(): pOut equals pIn"), a;
    for (var c = 0; 9 > c; c++) a.mat[c] = b.mat[c];
    return a
};
cc.kmMat3AreEqual = function(a, b) {
    if (a == b) return !0;
    for (var c = 0; 9 > c; ++c)
        if (!(a.mat[c] + cc.kmEpsilon > b.mat[c] && a.mat[c] - cc.kmEpsilon < b.mat[c])) return !1;
    return !0
};
cc.kmMat3RotationX = function(a, b) {
    a.mat[0] = 1;
    a.mat[1] = 0;
    a.mat[2] = 0;
    a.mat[3] = 0;
    a.mat[4] = Math.cos(b);
    a.mat[5] = Math.sin(b);
    a.mat[6] = 0;
    a.mat[7] = -Math.sin(b);
    a.mat[8] = Math.cos(b);
    return a
};
cc.kmMat3RotationY = function(a, b) {
    a.mat[0] = Math.cos(b);
    a.mat[1] = 0;
    a.mat[2] = -Math.sin(b);
    a.mat[3] = 0;
    a.mat[4] = 1;
    a.mat[5] = 0;
    a.mat[6] = Math.sin(b);
    a.mat[7] = 0;
    a.mat[8] = Math.cos(b);
    return a
};
cc.kmMat3RotationZ = function(a, b) {
    a.mat[0] = Math.cos(b);
    a.mat[1] = -Math.sin(b);
    a.mat[2] = 0;
    a.mat[3] = Math.sin(b);
    a.mat[4] = Math.cos(b);
    a.mat[5] = 0;
    a.mat[6] = 0;
    a.mat[7] = 0;
    a.mat[8] = 1;
    return a
};
cc.kmMat3Rotation = function(a, b) {
    a.mat[0] = Math.cos(b);
    a.mat[1] = Math.sin(b);
    a.mat[2] = 0;
    a.mat[3] = -Math.sin(b);
    a.mat[4] = Math.cos(b);
    a.mat[5] = 0;
    a.mat[6] = 0;
    a.mat[7] = 0;
    a.mat[8] = 1;
    return a
};
cc.kmMat3Scaling = function(a, b, c) {
    cc.kmMat3Identity(a);
    a.mat[0] = b;
    a.mat[4] = c;
    return a
};
cc.kmMat3Translation = function(a, b, c) {
    cc.kmMat3Identity(a);
    a.mat[6] = b;
    a.mat[7] = c;
    return a
};
cc.kmMat3RotationQuaternion = function(a, b) {
    if (!b || !a) return null;
    a.mat[0] = 1 - 2 * (b.y * b.y + b.z * b.z);
    a.mat[1] = 2 * (b.x * b.y - b.w * b.z);
    a.mat[2] = 2 * (b.x * b.z + b.w * b.y);
    a.mat[3] = 2 * (b.x * b.y + b.w * b.z);
    a.mat[4] = 1 - 2 * (b.x * b.x + b.z * b.z);
    a.mat[5] = 2 * (b.y * b.z - b.w * b.x);
    a.mat[6] = 2 * (b.x * b.z - b.w * b.y);
    a.mat[7] = 2 * (b.y * b.z + b.w * b.x);
    a.mat[8] = 1 - 2 * (b.x * b.x + b.y * b.y);
    return a
};
cc.kmMat3RotationToAxisAngle = function(a, b, c) {
    cc.kmQuaternionRotationMatrix(void 0, c);
    cc.kmQuaternionToAxisAngle(void 0, a, b);
    return a
};
cc.kmMat4 = function() {
    this.mat = new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
};
cc.kmMat4Fill = function(a, b) {
    a.mat[0] = a.mat[1] = a.mat[2] = a.mat[3] = a.mat[4] = a.mat[5] = a.mat[6] = a.mat[7] = a.mat[8] = a.mat[9] = a.mat[10] = a.mat[11] = a.mat[12] = a.mat[13] = a.mat[14] = a.mat[15] = b
};
cc.kmMat4Identity = function(a) {
    a.mat[1] = a.mat[2] = a.mat[3] = a.mat[4] = a.mat[6] = a.mat[7] = a.mat[8] = a.mat[9] = a.mat[11] = a.mat[12] = a.mat[13] = a.mat[14] = 0;
    a.mat[0] = a.mat[5] = a.mat[10] = a.mat[15] = 1;
    return a
};
cc.kmMat4._get = function(a, b, c) {
    return a.mat[b + 4 * c]
};
cc.kmMat4._set = function(a, b, c, d) {
    a.mat[b + 4 * c] = d
};
cc.kmMat4._swap = function(a, b, c, d, e) {
    var f = cc.kmMat4._get(a, b, c);
    cc.kmMat4._set(a, b, c, cc.kmMat4._get(a, d, e));
    cc.kmMat4._set(a, d, e, f)
};
cc.kmMat4._gaussj = function(a, b) {
    var c, d = 0,
        e = 0,
        f, g, h, k = [0, 0, 0, 0],
        m = [0, 0, 0, 0],
        n = [0, 0, 0, 0];
    for (c = 0; 4 > c; c++) {
        for (f = h = 0; 4 > f; f++)
            if (1 != n[f])
                for (g = 0; 4 > g; g++) 0 == n[g] && Math.abs(cc.kmMat4._get(a, f, g)) >= h && (h = Math.abs(cc.kmMat4._get(a, f, g)), e = f, d = g);
            ++n[d];
        if (e != d) {
            for (f = 0; 4 > f; f++) cc.kmMat4._swap(a, e, f, d, f);
            for (f = 0; 4 > f; f++) cc.kmMat4._swap(b, e, f, d, f)
        }
        m[c] = e;
        k[c] = d;
        if (0 == cc.kmMat4._get(a, d, d)) return cc.KM_FALSE;
        g = 1 / cc.kmMat4._get(a, d, d);
        cc.kmMat4._set(a, d, d, 1);
        for (f = 0; 4 > f; f++) cc.kmMat4._set(a, d, f, cc.kmMat4._get(a,
            d, f) * g);
        for (f = 0; 4 > f; f++) cc.kmMat4._set(b, d, f, cc.kmMat4._get(b, d, f) * g);
        for (g = 0; 4 > g; g++)
            if (g != d) {
                h = cc.kmMat4._get(a, g, d);
                cc.kmMat4._set(a, g, d, 0);
                for (f = 0; 4 > f; f++) cc.kmMat4._set(a, g, f, cc.kmMat4._get(a, g, f) - cc.kmMat4._get(a, d, f) * h);
                for (f = 0; 4 > f; f++) cc.kmMat4._set(b, g, f, cc.kmMat4._get(a, g, f) - cc.kmMat4._get(b, d, f) * h)
            }
    }
    for (f = 3; 0 <= f; f--)
        if (m[f] != k[f])
            for (g = 0; 4 > g; g++) cc.kmMat4._swap(a, g, m[f], g, k[f]);
    return cc.KM_TRUE
};
cc.kmMat4._identity = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
cc.kmMat4Inverse = function(a, b) {
    var c = new cc.kmMat4,
        d = new cc.kmMat4;
    cc.kmMat4Assign(c, b);
    cc.kmMat4Identity(d);
    if (cc.kmMat4._gaussj(c, d) == cc.KM_FALSE) return null;
    cc.kmMat4Assign(a, c);
    return a
};
cc.kmMat4IsIdentity = function(a) {
    for (var b = 0; 16 > b; b++)
        if (cc.kmMat4._identity[b] != a.mat[b]) return !1;
    return !0
};
cc.kmMat4Transpose = function(a, b) {
    var c, d, e = a.mat,
        f = b.mat;
    for (d = 0; 4 > d; ++d)
        for (c = 0; 4 > c; ++c) e[4 * d + c] = f[4 * c + d];
    return a
};
cc.kmMat4Multiply = function(a, b, c) {
    var d = a.mat,
        e = b.mat[0],
        f = b.mat[1],
        g = b.mat[2],
        h = b.mat[3],
        k = b.mat[4],
        m = b.mat[5],
        n = b.mat[6],
        q = b.mat[7],
        r = b.mat[8],
        s = b.mat[9],
        t = b.mat[10],
        u = b.mat[11],
        w = b.mat[12],
        v = b.mat[13],
        y = b.mat[14];
    b = b.mat[15];
    var D = c.mat[0],
        C = c.mat[1],
        z = c.mat[2],
        A = c.mat[3],
        x = c.mat[4],
        B = c.mat[5],
        I = c.mat[6],
        K = c.mat[7],
        F = c.mat[8],
        L = c.mat[9],
        M = c.mat[10],
        E = c.mat[11],
        H = c.mat[12],
        G = c.mat[13],
        J = c.mat[14];
    c = c.mat[15];
    d[0] = D * e + C * k + z * r + A * w;
    d[1] = D * f + C * m + z * s + A * v;
    d[2] = D * g + C * n + z * t + A * y;
    d[3] = D * h + C * q + z * u + A * b;
    d[4] =
        x * e + B * k + I * r + K * w;
    d[5] = x * f + B * m + I * s + K * v;
    d[6] = x * g + B * n + I * t + K * y;
    d[7] = x * h + B * q + I * u + K * b;
    d[8] = F * e + L * k + M * r + E * w;
    d[9] = F * f + L * m + M * s + E * v;
    d[10] = F * g + L * n + M * t + E * y;
    d[11] = F * h + L * q + M * u + E * b;
    d[12] = H * e + G * k + J * r + c * w;
    d[13] = H * f + G * m + J * s + c * v;
    d[14] = H * g + G * n + J * t + c * y;
    d[15] = H * h + G * q + J * u + c * b;
    return a
};
cc.getMat4MultiplyValue = function(a, b) {
    var c = a.mat,
        d = b.mat,
        e = new Float32Array(16);
    e[0] = c[0] * d[0] + c[4] * d[1] + c[8] * d[2] + c[12] * d[3];
    e[1] = c[1] * d[0] + c[5] * d[1] + c[9] * d[2] + c[13] * d[3];
    e[2] = c[2] * d[0] + c[6] * d[1] + c[10] * d[2] + c[14] * d[3];
    e[3] = c[3] * d[0] + c[7] * d[1] + c[11] * d[2] + c[15] * d[3];
    e[4] = c[0] * d[4] + c[4] * d[5] + c[8] * d[6] + c[12] * d[7];
    e[5] = c[1] * d[4] + c[5] * d[5] + c[9] * d[6] + c[13] * d[7];
    e[6] = c[2] * d[4] + c[6] * d[5] + c[10] * d[6] + c[14] * d[7];
    e[7] = c[3] * d[4] + c[7] * d[5] + c[11] * d[6] + c[15] * d[7];
    e[8] = c[0] * d[8] + c[4] * d[9] + c[8] * d[10] + c[12] * d[11];
    e[9] = c[1] * d[8] + c[5] * d[9] + c[9] * d[10] + c[13] * d[11];
    e[10] = c[2] * d[8] + c[6] * d[9] + c[10] * d[10] + c[14] * d[11];
    e[11] = c[3] * d[8] + c[7] * d[9] + c[11] * d[10] + c[15] * d[11];
    e[12] = c[0] * d[12] + c[4] * d[13] + c[8] * d[14] + c[12] * d[15];
    e[13] = c[1] * d[12] + c[5] * d[13] + c[9] * d[14] + c[13] * d[15];
    e[14] = c[2] * d[12] + c[6] * d[13] + c[10] * d[14] + c[14] * d[15];
    e[15] = c[3] * d[12] + c[7] * d[13] + c[11] * d[14] + c[15] * d[15];
    return e
};
cc.getMat4MultiplyWithMat4 = function(a, b, c) {
    a = a.mat;
    b = b.mat;
    var d = c.mat;
    d[0] = a[0] * b[0] + a[4] * b[1] + a[8] * b[2] + a[12] * b[3];
    d[1] = a[1] * b[0] + a[5] * b[1] + a[9] * b[2] + a[13] * b[3];
    d[2] = a[2] * b[0] + a[6] * b[1] + a[10] * b[2] + a[14] * b[3];
    d[3] = a[3] * b[0] + a[7] * b[1] + a[11] * b[2] + a[15] * b[3];
    d[4] = a[0] * b[4] + a[4] * b[5] + a[8] * b[6] + a[12] * b[7];
    d[5] = a[1] * b[4] + a[5] * b[5] + a[9] * b[6] + a[13] * b[7];
    d[6] = a[2] * b[4] + a[6] * b[5] + a[10] * b[6] + a[14] * b[7];
    d[7] = a[3] * b[4] + a[7] * b[5] + a[11] * b[6] + a[15] * b[7];
    d[8] = a[0] * b[8] + a[4] * b[9] + a[8] * b[10] + a[12] * b[11];
    d[9] = a[1] *
        b[8] + a[5] * b[9] + a[9] * b[10] + a[13] * b[11];
    d[10] = a[2] * b[8] + a[6] * b[9] + a[10] * b[10] + a[14] * b[11];
    d[11] = a[3] * b[8] + a[7] * b[9] + a[11] * b[10] + a[15] * b[11];
    d[12] = a[0] * b[12] + a[4] * b[13] + a[8] * b[14] + a[12] * b[15];
    d[13] = a[1] * b[12] + a[5] * b[13] + a[9] * b[14] + a[13] * b[15];
    d[14] = a[2] * b[12] + a[6] * b[13] + a[10] * b[14] + a[14] * b[15];
    d[15] = a[3] * b[12] + a[7] * b[13] + a[11] * b[14] + a[15] * b[15];
    return c.mat
};
cc.kmMat4Assign = function(a, b) {
    if (a == b) return cc.log("cc.kmMat4Assign(): pOut equals pIn"), a;
    var c = a.mat,
        d = b.mat;
    c[0] = d[0];
    c[1] = d[1];
    c[2] = d[2];
    c[3] = d[3];
    c[4] = d[4];
    c[5] = d[5];
    c[6] = d[6];
    c[7] = d[7];
    c[8] = d[8];
    c[9] = d[9];
    c[10] = d[10];
    c[11] = d[11];
    c[12] = d[12];
    c[13] = d[13];
    c[14] = d[14];
    c[15] = d[15];
    return a
};
cc.kmMat4AreEqual = function(a, b) {
    if (a == b) return cc.log("cc.kmMat4AreEqual(): pMat1 and pMat2 are same object."), !0;
    for (var c = 0; 16 > c; c++)
        if (!(a.mat[c] + cc.kmEpsilon > b.mat[c] && a.mat[c] - cc.kmEpsilon < b.mat[c])) return !1;
    return !0
};
cc.kmMat4RotationX = function(a, b) {
    a.mat[0] = 1;
    a.mat[1] = 0;
    a.mat[2] = 0;
    a.mat[3] = 0;
    a.mat[4] = 0;
    a.mat[5] = Math.cos(b);
    a.mat[6] = Math.sin(b);
    a.mat[7] = 0;
    a.mat[8] = 0;
    a.mat[9] = -Math.sin(b);
    a.mat[10] = Math.cos(b);
    a.mat[11] = 0;
    a.mat[12] = 0;
    a.mat[13] = 0;
    a.mat[14] = 0;
    a.mat[15] = 1;
    return a
};
cc.kmMat4RotationY = function(a, b) {
    a.mat[0] = Math.cos(b);
    a.mat[1] = 0;
    a.mat[2] = -Math.sin(b);
    a.mat[3] = 0;
    a.mat[4] = 0;
    a.mat[5] = 1;
    a.mat[6] = 0;
    a.mat[7] = 0;
    a.mat[8] = Math.sin(b);
    a.mat[9] = 0;
    a.mat[10] = Math.cos(b);
    a.mat[11] = 0;
    a.mat[12] = 0;
    a.mat[13] = 0;
    a.mat[14] = 0;
    a.mat[15] = 1;
    return a
};
cc.kmMat4RotationZ = function(a, b) {
    a.mat[0] = Math.cos(b);
    a.mat[1] = Math.sin(b);
    a.mat[2] = 0;
    a.mat[3] = 0;
    a.mat[4] = -Math.sin(b);
    a.mat[5] = Math.cos(b);
    a.mat[6] = 0;
    a.mat[7] = 0;
    a.mat[8] = 0;
    a.mat[9] = 0;
    a.mat[10] = 1;
    a.mat[11] = 0;
    a.mat[12] = 0;
    a.mat[13] = 0;
    a.mat[14] = 0;
    a.mat[15] = 1;
    return a
};
cc.kmMat4RotationPitchYawRoll = function(a, b, c, d) {
    var e = Math.cos(b);
    b = Math.sin(b);
    var f = Math.cos(c);
    c = Math.sin(c);
    var g = Math.cos(d);
    d = Math.sin(d);
    var h = b * c,
        k = e * c;
    a.mat[0] = f * g;
    a.mat[4] = f * d;
    a.mat[8] = -c;
    a.mat[1] = h * g - e * d;
    a.mat[5] = h * d + e * g;
    a.mat[9] = b * f;
    a.mat[2] = k * g + b * d;
    a.mat[6] = k * d - b * g;
    a.mat[10] = e * f;
    a.mat[3] = a.mat[7] = a.mat[11] = 0;
    a.mat[15] = 1;
    return a
};
cc.kmMat4RotationQuaternion = function(a, b) {
    a.mat[0] = 1 - 2 * (b.y * b.y + b.z * b.z);
    a.mat[1] = 2 * (b.x * b.y + b.z * b.w);
    a.mat[2] = 2 * (b.x * b.z - b.y * b.w);
    a.mat[3] = 0;
    a.mat[4] = 2 * (b.x * b.y - b.z * b.w);
    a.mat[5] = 1 - 2 * (b.x * b.x + b.z * b.z);
    a.mat[6] = 2 * (b.z * b.y + b.x * b.w);
    a.mat[7] = 0;
    a.mat[8] = 2 * (b.x * b.z + b.y * b.w);
    a.mat[9] = 2 * (b.y * b.z - b.x * b.w);
    a.mat[10] = 1 - 2 * (b.x * b.x + b.y * b.y);
    a.mat[11] = 0;
    a.mat[12] = 0;
    a.mat[13] = 0;
    a.mat[14] = 0;
    a.mat[15] = 1;
    return a
};
cc.kmMat4RotationTranslation = function(a, b, c) {
    a.mat[0] = b.mat[0];
    a.mat[1] = b.mat[1];
    a.mat[2] = b.mat[2];
    a.mat[3] = 0;
    a.mat[4] = b.mat[3];
    a.mat[5] = b.mat[4];
    a.mat[6] = b.mat[5];
    a.mat[7] = 0;
    a.mat[8] = b.mat[6];
    a.mat[9] = b.mat[7];
    a.mat[10] = b.mat[8];
    a.mat[11] = 0;
    a.mat[12] = c.x;
    a.mat[13] = c.y;
    a.mat[14] = c.z;
    a.mat[15] = 1;
    return a
};
cc.kmMat4Scaling = function(a, b, c, d) {
    a.mat[0] = b;
    a.mat[5] = c;
    a.mat[10] = d;
    a.mat[15] = 1;
    a.mat[1] = a.mat[2] = a.mat[3] = a.mat[4] = a.mat[6] = a.mat[7] = a.mat[8] = a.mat[9] = a.mat[11] = a.mat[12] = a.mat[13] = a.mat[14] = 0;
    return a
};
cc.kmMat4Translation = function(a, b, c, d) {
    a.mat[0] = a.mat[5] = a.mat[10] = a.mat[15] = 1;
    a.mat[1] = a.mat[2] = a.mat[3] = a.mat[4] = a.mat[6] = a.mat[7] = a.mat[8] = a.mat[9] = a.mat[11] = 0;
    a.mat[12] = b;
    a.mat[13] = c;
    a.mat[14] = d;
    return a
};
cc.kmMat4GetUpVec3 = function(a, b) {
    a.x = b.mat[4];
    a.y = b.mat[5];
    a.z = b.mat[6];
    cc.kmVec3Normalize(a, a);
    return a
};
cc.kmMat4GetRightVec3 = function(a, b) {
    a.x = b.mat[0];
    a.y = b.mat[1];
    a.z = b.mat[2];
    cc.kmVec3Normalize(a, a);
    return a
};
cc.kmMat4GetForwardVec3 = function(a, b) {
    a.x = b.mat[8];
    a.y = b.mat[9];
    a.z = b.mat[10];
    cc.kmVec3Normalize(a, a);
    return a
};
cc.kmMat4PerspectiveProjection = function(a, b, c, d, e) {
    var f = cc.kmDegreesToRadians(b / 2);
    b = e - d;
    var g = Math.sin(f);
    if (0 == b || 0 == g || 0 == c) return null;
    f = Math.cos(f) / g;
    cc.kmMat4Identity(a);
    a.mat[0] = f / c;
    a.mat[5] = f;
    a.mat[10] = -(e + d) / b;
    a.mat[11] = -1;
    a.mat[14] = -2 * d * e / b;
    a.mat[15] = 0;
    return a
};
cc.kmMat4OrthographicProjection = function(a, b, c, d, e, f, g) {
    cc.kmMat4Identity(a);
    a.mat[0] = 2 / (c - b);
    a.mat[5] = 2 / (e - d);
    a.mat[10] = -2 / (g - f);
    a.mat[12] = -((c + b) / (c - b));
    a.mat[13] = -((e + d) / (e - d));
    a.mat[14] = -((g + f) / (g - f));
    return a
};
cc.kmMat4LookAt = function(a, b, c, d) {
    var e = new cc.kmVec3,
        f = new cc.kmVec3,
        g = new cc.kmVec3,
        h = new cc.kmVec3,
        k = new cc.kmMat4;
    cc.kmVec3Subtract(e, c, b);
    cc.kmVec3Normalize(e, e);
    cc.kmVec3Assign(f, d);
    cc.kmVec3Normalize(f, f);
    cc.kmVec3Cross(g, e, f);
    cc.kmVec3Normalize(g, g);
    cc.kmVec3Cross(h, g, e);
    cc.kmVec3Normalize(g, g);
    cc.kmMat4Identity(a);
    a.mat[0] = g.x;
    a.mat[4] = g.y;
    a.mat[8] = g.z;
    a.mat[1] = h.x;
    a.mat[5] = h.y;
    a.mat[9] = h.z;
    a.mat[2] = -e.x;
    a.mat[6] = -e.y;
    a.mat[10] = -e.z;
    cc.kmMat4Translation(k, -b.x, -b.y, -b.z);
    cc.kmMat4Multiply(a,
        a, k);
    return a
};
cc.kmMat4RotationAxisAngle = function(a, b, c) {
    var d = Math.cos(c);
    c = Math.sin(c);
    var e = new cc.kmVec3;
    cc.kmVec3Normalize(e, b);
    a.mat[0] = d + e.x * e.x * (1 - d);
    a.mat[1] = e.z * c + e.y * e.x * (1 - d);
    a.mat[2] = -e.y * c + e.z * e.x * (1 - d);
    a.mat[3] = 0;
    a.mat[4] = -e.z * c + e.x * e.y * (1 - d);
    a.mat[5] = d + e.y * e.y * (1 - d);
    a.mat[6] = e.x * c + e.z * e.y * (1 - d);
    a.mat[7] = 0;
    a.mat[8] = e.y * c + e.x * e.z * (1 - d);
    a.mat[9] = -e.x * c + e.y * e.z * (1 - d);
    a.mat[10] = d + e.z * e.z * (1 - d);
    a.mat[11] = 0;
    a.mat[12] = 0;
    a.mat[13] = 0;
    a.mat[14] = 0;
    a.mat[15] = 1;
    return a
};
cc.kmMat4ExtractRotation = function(a, b) {
    a.mat[0] = b.mat[0];
    a.mat[1] = b.mat[1];
    a.mat[2] = b.mat[2];
    a.mat[3] = b.mat[4];
    a.mat[4] = b.mat[5];
    a.mat[5] = b.mat[6];
    a.mat[6] = b.mat[8];
    a.mat[7] = b.mat[9];
    a.mat[8] = b.mat[10];
    return a
};
cc.kmMat4ExtractPlane = function(a, b, c) {
    switch (c) {
        case cc.KM_PLANE_RIGHT:
            a.a = b.mat[3] - b.mat[0];
            a.b = b.mat[7] - b.mat[4];
            a.c = b.mat[11] - b.mat[8];
            a.d = b.mat[15] - b.mat[12];
            break;
        case cc.KM_PLANE_LEFT:
            a.a = b.mat[3] + b.mat[0];
            a.b = b.mat[7] + b.mat[4];
            a.c = b.mat[11] + b.mat[8];
            a.d = b.mat[15] + b.mat[12];
            break;
        case cc.KM_PLANE_BOTTOM:
            a.a = b.mat[3] + b.mat[1];
            a.b = b.mat[7] + b.mat[5];
            a.c = b.mat[11] + b.mat[9];
            a.d = b.mat[15] + b.mat[13];
            break;
        case cc.KM_PLANE_TOP:
            a.a = b.mat[3] - b.mat[1];
            a.b = b.mat[7] - b.mat[5];
            a.c = b.mat[11] - b.mat[9];
            a.d = b.mat[15] -
                b.mat[13];
            break;
        case cc.KM_PLANE_FAR:
            a.a = b.mat[3] - b.mat[2];
            a.b = b.mat[7] - b.mat[6];
            a.c = b.mat[11] - b.mat[10];
            a.d = b.mat[15] - b.mat[14];
            break;
        case cc.KM_PLANE_NEAR:
            a.a = b.mat[3] + b.mat[2];
            a.b = b.mat[7] + b.mat[6];
            a.c = b.mat[11] + b.mat[10];
            a.d = b.mat[15] + b.mat[14];
            break;
        default:
            cc.log("cc.kmMat4ExtractPlane(): Invalid plane index")
    }
    b = Math.sqrt(a.a * a.a + a.b * a.b + a.c * a.c);
    a.a /= b;
    a.b /= b;
    a.c /= b;
    a.d /= b;
    return a
};
cc.kmMat4RotationToAxisAngle = function(a, b, c) {
    var d = new cc.kmQuaternion,
        e = new cc.kmMat3;
    cc.kmMat4ExtractRotation(e, c);
    cc.kmQuaternionRotationMatrix(d, e);
    cc.kmQuaternionToAxisAngle(d, a, b);
    return a
};
cc.KM_PLANE_LEFT = 0;
cc.KM_PLANE_RIGHT = 1;
cc.KM_PLANE_BOTTOM = 2;
cc.KM_PLANE_TOP = 3;
cc.KM_PLANE_NEAR = 4;
cc.KM_PLANE_FAR = 5;
cc.kmPlane = function(a, b, c, d) {
    this.a = a || 0;
    this.b = b || 0;
    this.c = c || 0;
    this.d = d || 0
};
cc.POINT_INFRONT_OF_PLANE = 0;
cc.POINT_BEHIND_PLANE = 1;
cc.POINT_ON_PLANE = 2;
cc.kmPlaneDot = function(a, b) {
    return a.a * b.x + a.b * b.y + a.c * b.z + a.d * b.w
};
cc.kmPlaneDotCoord = function(a, b) {
    return a.a * b.x + a.b * b.y + a.c * b.z + a.d
};
cc.kmPlaneDotNormal = function(a, b) {
    return a.a * b.x + a.b * b.y + a.c * b.z
};
cc.kmPlaneFromPointNormal = function(a, b, c) {
    a.a = c.x;
    a.b = c.y;
    a.c = c.z;
    a.d = -cc.kmVec3Dot(c, b);
    return a
};
cc.kmPlaneFromPoints = function(a, b, c, d) {
    var e = new cc.kmVec3,
        f = new cc.kmVec3,
        g = new cc.kmVec3;
    cc.kmVec3Subtract(f, c, b);
    cc.kmVec3Subtract(g, d, b);
    cc.kmVec3Cross(e, f, g);
    cc.kmVec3Normalize(e, e);
    a.a = e.x;
    a.b = e.y;
    a.c = e.z;
    a.d = cc.kmVec3Dot(cc.kmVec3Scale(e, e, -1), b);
    return a
};
cc.kmPlaneIntersectLine = function(a, b, c, d) {
    throw "cc.kmPlaneIntersectLine() hasn't been implemented.";
};
cc.kmPlaneNormalize = function(a, b) {
    var c = new cc.kmVec3;
    c.x = b.a;
    c.y = b.b;
    c.z = b.c;
    var d = 1 / cc.kmVec3Length(c);
    cc.kmVec3Normalize(c, c);
    a.a = c.x;
    a.b = c.y;
    a.c = c.z;
    a.d = b.d * d;
    return a
};
cc.kmPlaneScale = function(a, b, c) {
    cc.log("cc.kmPlaneScale() has not been implemented.")
};
cc.kmPlaneClassifyPoint = function(a, b) {
    var c = a.a * b.x + a.b * b.y + a.c * b.z + a.d;
    return 0.0010 < c ? cc.POINT_INFRONT_OF_PLANE : -0.0010 > c ? cc.POINT_BEHIND_PLANE : cc.POINT_ON_PLANE
};
cc.kmQuaternion = function(a, b, c, d) {
    this.x = a || 0;
    this.y = b || 0;
    this.z = c || 0;
    this.w = d || 0
};
cc.kmQuaternionConjugate = function(a, b) {
    a.x = -b.x;
    a.y = -b.y;
    a.z = -b.z;
    a.w = b.w;
    return a
};
cc.kmQuaternionDot = function(a, b) {
    return a.w * b.w + a.x * b.x + a.y * b.y + a.z * b.z
};
cc.kmQuaternionExp = function(a, b) {
    return a
};
cc.kmQuaternionIdentity = function(a) {
    a.x = 0;
    a.y = 0;
    a.z = 0;
    a.w = 1;
    return a
};
cc.kmQuaternionInverse = function(a, b) {
    var c = cc.kmQuaternionLength(b),
        d = new cc.kmQuaternion;
    if (Math.abs(c) > cc.kmEpsilon) return a.x = 0, a.y = 0, a.z = 0, a.w = 0, a;
    cc.kmQuaternionScale(a, cc.kmQuaternionConjugate(d, b), 1 / c);
    return a
};
cc.kmQuaternionIsIdentity = function(a) {
    return 0 == a.x && 0 == a.y && 0 == a.z && 1 == a.w
};
cc.kmQuaternionLength = function(a) {
    return Math.sqrt(cc.kmQuaternionLengthSq(a))
};
cc.kmQuaternionLengthSq = function(a) {
    return a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w
};
cc.kmQuaternionLn = function(a, b) {
    return a
};
cc.kmQuaternionMultiply = function(a, b, c) {
    a.w = b.w * c.w - b.x * c.x - b.y * c.y - b.z * c.z;
    a.x = b.w * c.x + b.x * c.w + b.y * c.z - b.z * c.y;
    a.y = b.w * c.y + b.y * c.w + b.z * c.x - b.x * c.z;
    a.z = b.w * c.z + b.z * c.w + b.x * c.y - b.y * c.x;
    return a
};
cc.kmQuaternionNormalize = function(a, b) {
    var c = cc.kmQuaternionLength(b);
    if (Math.abs(c) <= cc.kmEpsilon) throw "cc.kmQuaternionNormalize(): pIn is an invalid value";
    cc.kmQuaternionScale(a, b, 1 / c);
    return a
};
cc.kmQuaternionRotationAxis = function(a, b, c) {
    c *= 0.5;
    var d = Math.sin(c);
    a.w = Math.cos(c);
    a.x = b.x * d;
    a.y = b.y * d;
    a.z = b.z * d;
    return a
};
cc.kmQuaternionRotationMatrix = function(a, b) {
    var c, d, e, f;
    c = [];
    d = f = 0;
    if (!b) return null;
    c[0] = b.mat[0];
    c[1] = b.mat[3];
    c[2] = b.mat[6];
    c[4] = b.mat[1];
    c[5] = b.mat[4];
    c[6] = b.mat[7];
    c[8] = b.mat[2];
    c[9] = b.mat[5];
    c[10] = b.mat[8];
    c[15] = 1;
    var g = c[0];
    d = g[0] + g[5] + g[10] + 1;
    d > cc.kmEpsilon ? (f = 2 * Math.sqrt(d), c = (g[9] - g[6]) / f, d = (g[2] - g[8]) / f, e = (g[4] - g[1]) / f, f *= 0.25) : g[0] > g[5] && g[0] > g[10] ? (f = 2 * Math.sqrt(1 + g[0] - g[5] - g[10]), c = 0.25 * f, d = (g[4] + g[1]) / f, e = (g[2] + g[8]) / f, f = (g[9] - g[6]) / f) : g[5] > g[10] ? (f = 2 * Math.sqrt(1 + g[5] - g[0] - g[10]), c =
        (g[4] + g[1]) / f, d = 0.25 * f, e = (g[9] + g[6]) / f, f = (g[2] - g[8]) / f) : (f = 2 * Math.sqrt(1 + g[10] - g[0] - g[5]), c = (g[2] + g[8]) / f, d = (g[9] + g[6]) / f, e = 0.25 * f, f = (g[4] - g[1]) / f);
    a.x = c;
    a.y = d;
    a.z = e;
    a.w = f;
    return a
};
cc.kmQuaternionRotationYawPitchRoll = function(a, b, c, d) {
    var e, f, g, h, k;
    e = cc.kmDegreesToRadians(c) / 2;
    f = cc.kmDegreesToRadians(b) / 2;
    g = cc.kmDegreesToRadians(d) / 2;
    d = Math.cos(e);
    b = Math.cos(f);
    c = Math.cos(g);
    e = Math.sin(e);
    f = Math.sin(f);
    g = Math.sin(g);
    h = b * c;
    k = f * g;
    a.w = d * h + e * k;
    a.x = e * h - d * k;
    a.y = d * f * c + e * b * g;
    a.z = d * b * g - e * f * c;
    cc.kmQuaternionNormalize(a, a);
    return a
};
cc.kmQuaternionSlerp = function(a, b, c, d) {
    if (b.x == c.x && b.y == c.y && b.z == c.z && b.w == c.w) return a.x = b.x, a.y = b.y, a.z = b.z, a.w = b.w, a;
    var e = cc.kmQuaternionDot(b, c),
        f = Math.acos(e),
        g = Math.sqrt(1 - cc.kmSQR(e)),
        e = Math.sin(d * f) / g;
    d = Math.sin((1 - d) * f) / g;
    f = new cc.kmQuaternion;
    g = new cc.kmQuaternion;
    cc.kmQuaternionScale(f, b, d);
    cc.kmQuaternionScale(g, c, e);
    cc.kmQuaternionAdd(a, f, g);
    return a
};
cc.kmQuaternionToAxisAngle = function(a, b, c) {
    Math.acos(a.w);
    c = Math.sqrt(cc.kmSQR(a.x) + cc.kmSQR(a.y) + cc.kmSQR(a.z));
    c > -cc.kmEpsilon && c < cc.kmEpsilon || c < 2 * cc.kmPI + cc.kmEpsilon && c > 2 * cc.kmPI - cc.kmEpsilon ? (b.x = 0, b.y = 0, b.z = 1) : (b.x = a.x / c, b.y = a.y / c, b.z = a.z / c, cc.kmVec3Normalize(b, b))
};
cc.kmQuaternionScale = function(a, b, c) {
    a.x = b.x * c;
    a.y = b.y * c;
    a.z = b.z * c;
    a.w = b.w * c;
    return a
};
cc.kmQuaternionAssign = function(a, b) {
    a.x = b.x;
    a.y = b.y;
    a.z = b.z;
    a.w = b.w;
    return a
};
cc.kmQuaternionAdd = function(a, b, c) {
    a.x = b.x + c.x;
    a.y = b.y + c.y;
    a.z = b.z + c.z;
    a.w = b.w + c.w;
    return a
};
cc.kmQuaternionRotationBetweenVec3 = function(a, b, c, d) {
    var e = new cc.kmVec3,
        f = new cc.kmVec3;
    cc.kmVec3Assign(e, b);
    cc.kmVec3Assign(f, c);
    cc.kmVec3Normalize(e, e);
    cc.kmVec3Normalize(f, f);
    c = cc.kmVec3Dot(e, f);
    if (1 <= c) return cc.kmQuaternionIdentity(a), a; - 0.999999 > c ? Math.abs(cc.kmVec3LengthSq(d)) < cc.kmEpsilon ? cc.kmQuaternionRotationAxis(a, d, cc.kmPI) : (e = new cc.kmVec3, f = new cc.kmVec3, f.x = 1, f.y = 0, f.z = 0, cc.kmVec3Cross(e, f, b), Math.abs(cc.kmVec3LengthSq(e)) < cc.kmEpsilon && (f = new cc.kmVec3, f.x = 0, f.y = 1, f.z = 0, cc.kmVec3Cross(e,
        f, b)), cc.kmVec3Normalize(e, e), cc.kmQuaternionRotationAxis(a, e, cc.kmPI)) : (b = Math.sqrt(2 * (1 + c)), d = 1 / b, c = new cc.kmVec3, cc.kmVec3Cross(c, e, f), a.x = c.x * d, a.y = c.y * d, a.z = c.z * d, a.w = 0.5 * b, cc.kmQuaternionNormalize(a, a));
    return a
};
cc.kmQuaternionMultiplyVec3 = function(a, b, c) {
    var d = new cc.kmVec3,
        e = new cc.kmVec3,
        f = new cc.kmVec3;
    f.x = b.x;
    f.y = b.y;
    f.z = b.z;
    cc.kmVec3Cross(d, f, c);
    cc.kmVec3Cross(e, f, d);
    cc.kmVec3Scale(d, d, 2 * b.w);
    cc.kmVec3Scale(e, e, 2);
    cc.kmVec3Add(a, c, d);
    cc.kmVec3Add(a, a, e);
    return a
};
cc.kmAABB = function(a, b) {
    this.min = a || new cc.kmVec3;
    this.max = b || new cc.kmVec3
};
cc.kmAABBContainsPoint = function(a, b) {
    return a.x >= b.min.x && a.x <= b.max.x && a.y >= b.min.y && a.y <= b.max.y && a.z >= b.min.z && a.z <= b.max.z ? cc.KM_TRUE : cc.KM_FALSE
};
cc.kmAABBAssign = function(a, b) {
    cc.kmVec3Assign(a.min, b.min);
    cc.kmVec3Assign(a.max, b.max);
    return a
};
cc.kmAABBScale = function(a, b, c) {
    cc.log("cc.kmAABBScale hasn't been supported.")
};
cc.km_mat4_stack = function(a, b, c, d) {
    this.top = c;
    this.stack = d
};
cc.km_mat4_stack.INITIAL_SIZE = 30;
cc.km_mat4_stack_initialize = function(a) {
    a.stack = [];
    a.top = null
};
cc.km_mat4_stack_push = function(a, b) {
    a.stack.push(a.top);
    a.top = new cc.kmMat4;
    cc.kmMat4Assign(a.top, b)
};
cc.km_mat4_stack_pop = function(a, b) {
    a.top = a.stack.pop()
};
cc.km_mat4_stack_release = function(a) {
    a.stack = null;
    a.top = null
};
cc.KM_GL_MODELVIEW = 5888;
cc.KM_GL_PROJECTION = 5889;
cc.KM_GL_TEXTURE = 5890;
cc.modelview_matrix_stack = new cc.km_mat4_stack;
cc.projection_matrix_stack = new cc.km_mat4_stack;
cc.texture_matrix_stack = new cc.km_mat4_stack;
cc.current_stack = null;
cc.initialized = !1;
cc.lazyInitialize = function() {
    if (!cc.initialized) {
        var a = new cc.kmMat4;
        cc.km_mat4_stack_initialize(cc.modelview_matrix_stack);
        cc.km_mat4_stack_initialize(cc.projection_matrix_stack);
        cc.km_mat4_stack_initialize(cc.texture_matrix_stack);
        cc.current_stack = cc.modelview_matrix_stack;
        cc.initialized = !0;
        cc.kmMat4Identity(a);
        cc.km_mat4_stack_push(cc.modelview_matrix_stack, a);
        cc.km_mat4_stack_push(cc.projection_matrix_stack, a);
        cc.km_mat4_stack_push(cc.texture_matrix_stack, a)
    }
};
cc.lazyInitialize();
cc.kmGLFreeAll = function() {
    cc.km_mat4_stack_release(cc.modelview_matrix_stack);
    cc.km_mat4_stack_release(cc.projection_matrix_stack);
    cc.km_mat4_stack_release(cc.texture_matrix_stack);
    cc.initialized = !1;
    cc.current_stack = null
};
cc.kmGLPushMatrix = function() {
    cc.km_mat4_stack_push(cc.current_stack, cc.current_stack.top)
};
cc.kmGLPushMatrixWitMat4 = function(a) {
    cc.current_stack.stack.push(cc.current_stack.top);
    cc.kmMat4Assign(a, cc.current_stack.top);
    cc.current_stack.top = a
};
cc.kmGLPopMatrix = function() {
    cc.current_stack.top = cc.current_stack.stack.pop()
};
cc.kmGLMatrixMode = function(a) {
    switch (a) {
        case cc.KM_GL_MODELVIEW:
            cc.current_stack = cc.modelview_matrix_stack;
            break;
        case cc.KM_GL_PROJECTION:
            cc.current_stack = cc.projection_matrix_stack;
            break;
        case cc.KM_GL_TEXTURE:
            cc.current_stack = cc.texture_matrix_stack;
            break;
        default:
            throw "Invalid matrix mode specified";
    }
};
cc.kmGLLoadIdentity = function() {
    cc.kmMat4Identity(cc.current_stack.top)
};
cc.kmGLLoadMatrix = function(a) {
    cc.kmMat4Assign(cc.current_stack.top, a)
};
cc.kmGLMultMatrix = function(a) {
    cc.kmMat4Multiply(cc.current_stack.top, cc.current_stack.top, a)
};
cc.kmGLTranslatef = function(a, b, c) {
    var d = new cc.kmMat4;
    cc.kmMat4Translation(d, a, b, c);
    cc.kmMat4Multiply(cc.current_stack.top, cc.current_stack.top, d)
};
cc.kmGLRotatef = function(a, b, c, d) {
    b = new cc.kmVec3(b, c, d);
    c = new cc.kmMat4;
    cc.kmMat4RotationAxisAngle(c, b, cc.kmDegreesToRadians(a));
    cc.kmMat4Multiply(cc.current_stack.top, cc.current_stack.top, c)
};
cc.kmGLScalef = function(a, b, c) {
    var d = new cc.kmMat4;
    cc.kmMat4Scaling(d, a, b, c);
    cc.kmMat4Multiply(cc.current_stack.top, cc.current_stack.top, d)
};
cc.kmGLGetMatrix = function(a, b) {
    switch (a) {
        case cc.KM_GL_MODELVIEW:
            cc.kmMat4Assign(b, cc.modelview_matrix_stack.top);
            break;
        case cc.KM_GL_PROJECTION:
            cc.kmMat4Assign(b, cc.projection_matrix_stack.top);
            break;
        case cc.KM_GL_TEXTURE:
            cc.kmMat4Assign(b, cc.texture_matrix_stack.top);
            break;
        default:
            throw "Invalid matrix mode specified";
    }
};
cc.SHADER_POSITION_UCOLOR_FRAG = "precision lowp float;\nvarying vec4 v_fragmentColor;\nvoid main()                              \n{ \n    gl_FragColor \x3d v_fragmentColor;      \n}\n";
cc.SHADER_POSITION_UCOLOR_VERT = "attribute vec4 a_position;\nuniform    vec4 u_color;\nuniform float u_pointSize;\nvarying lowp vec4 v_fragmentColor; \nvoid main(void)   \n{\n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    gl_PointSize \x3d u_pointSize;          \n    v_fragmentColor \x3d u_color;           \n}";
cc.SHADER_POSITION_COLOR_FRAG = "precision lowp float; \nvarying vec4 v_fragmentColor; \nvoid main() \n{ \n     gl_FragColor \x3d v_fragmentColor; \n} ";
cc.SHADER_POSITION_COLOR_VERT = "attribute vec4 a_position;\nattribute vec4 a_color;\nvarying lowp vec4 v_fragmentColor;\nvoid main()\n{\n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_fragmentColor \x3d a_color;             \n}";
cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_FRAG = "// #extension GL_OES_standard_derivatives : enable\nvarying mediump vec4 v_color;\nvarying mediump vec2 v_texcoord;\nvoid main()\t\n{ \n// #if defined GL_OES_standard_derivatives\t\n// gl_FragColor \x3d v_color*smoothstep(0.0, length(fwidth(v_texcoord)), 1.0 - length(v_texcoord)); \n// #else\t\ngl_FragColor \x3d v_color * step(0.0, 1.0 - length(v_texcoord)); \n// #endif \n}";
cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_VERT = "attribute mediump vec4 a_position; \nattribute mediump vec2 a_texcoord; \nattribute mediump vec4 a_color;\t\nvarying mediump vec4 v_color; \nvarying mediump vec2 v_texcoord;\t\nvoid main() \n{ \n     v_color \x3d a_color;//vec4(a_color.rgb * a_color.a, a_color.a); \n     v_texcoord \x3d a_texcoord; \n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n}";
cc.SHADER_POSITION_TEXTURE_FRAG = "precision lowp float;   \nvarying vec2 v_texCoord;  \nvoid main() \n{  \n    gl_FragColor \x3d  texture2D(CC_Texture0, v_texCoord);   \n}";
cc.SHADER_POSITION_TEXTURE_VERT = "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_texCoord \x3d a_texCoord;               \n}";
cc.SHADER_POSITION_TEXTURE_UCOLOR_FRAG = "precision lowp float;  \nuniform vec4 u_color; \nvarying vec2 v_texCoord; \nvoid main() \n{  \n    gl_FragColor \x3d  texture2D(CC_Texture0, v_texCoord) * u_color;    \n}";
cc.SHADER_POSITION_TEXTURE_UCOLOR_VERT = "attribute vec4 a_position;\nattribute vec2 a_texCoord; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_texCoord \x3d a_texCoord;                 \n}";
cc.SHADER_POSITION_TEXTURE_A8COLOR_FRAG = "precision lowp float;  \nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nvoid main() \n{ \n    gl_FragColor \x3d vec4( v_fragmentColor.rgb,         \n        v_fragmentColor.a * texture2D(CC_Texture0, v_texCoord).a   \n    ); \n}";
cc.SHADER_POSITION_TEXTURE_A8COLOR_VERT = "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nattribute vec4 a_color;  \nvarying lowp vec4 v_fragmentColor; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_fragmentColor \x3d a_color; \n    v_texCoord \x3d a_texCoord; \n}";
cc.SHADER_POSITION_TEXTURE_COLOR_FRAG = "precision lowp float;\nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nvoid main() \n{ \n    gl_FragColor \x3d v_fragmentColor * texture2D(CC_Texture0, v_texCoord); \n}";
cc.SHADER_POSITION_TEXTURE_COLOR_VERT = "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nattribute vec4 a_color;  \nvarying lowp vec4 v_fragmentColor; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_fragmentColor \x3d a_color; \n    v_texCoord \x3d a_texCoord; \n}";
cc.SHADER_POSITION_TEXTURE_COLOR_ALPHATEST_FRAG = "precision lowp float;   \nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord;   \nuniform float CC_alpha_value; \nvoid main() \n{  \n    vec4 texColor \x3d texture2D(CC_Texture0, v_texCoord);  \n    if ( texColor.a \x3c\x3d CC_alpha_value )          \n        discard; \n    gl_FragColor \x3d texColor * v_fragmentColor;  \n}";
cc.SHADEREX_SWITCHMASK_FRAG = "precision lowp float; \nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nuniform sampler2D u_texture;  \nuniform sampler2D   u_mask;   \nvoid main()  \n{  \n    vec4 texColor   \x3d texture2D(u_texture, v_texCoord);  \n    vec4 maskColor  \x3d texture2D(u_mask, v_texCoord); \n    vec4 finalColor \x3d vec4(texColor.r, texColor.g, texColor.b, maskColor.a * texColor.a);        \n    gl_FragColor    \x3d v_fragmentColor * finalColor; \n}";
cc.shaderCache = {
    TYPE_POSITION_TEXTURECOLOR: 0,
    TYPE_POSITION_TEXTURECOLOR_ALPHATEST: 1,
    TYPE_POSITION_COLOR: 2,
    TYPE_POSITION_TEXTURE: 3,
    TYPE_POSITION_TEXTURE_UCOLOR: 4,
    TYPE_POSITION_TEXTURE_A8COLOR: 5,
    TYPE_POSITION_UCOLOR: 6,
    TYPE_POSITION_LENGTH_TEXTURECOLOR: 7,
    TYPE_MAX: 8,
    _programs: {},
    _init: function() {
        this.loadDefaultShaders();
        return !0
    },
    _loadDefaultShader: function(a, b) {
        switch (b) {
            case this.TYPE_POSITION_TEXTURECOLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_COLOR_VERT, cc.SHADER_POSITION_TEXTURE_COLOR_FRAG);
                a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
                a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                break;
            case this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_COLOR_VERT, cc.SHADER_POSITION_TEXTURE_COLOR_ALPHATEST_FRAG);
                a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
                a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                break;
            case this.TYPE_POSITION_COLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_COLOR_VERT, cc.SHADER_POSITION_COLOR_FRAG);
                a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
                break;
            case this.TYPE_POSITION_TEXTURE:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_VERT, cc.SHADER_POSITION_TEXTURE_FRAG);
                a.addAttribute(cc.ATTRIBUTE_NAME_POSITION,
                    cc.VERTEX_ATTRIB_POSITION);
                a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                break;
            case this.TYPE_POSITION_TEXTURE_UCOLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_UCOLOR_VERT, cc.SHADER_POSITION_TEXTURE_UCOLOR_FRAG);
                a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                break;
            case this.TYPE_POSITION_TEXTURE_A8COLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_A8COLOR_VERT,
                    cc.SHADER_POSITION_TEXTURE_A8COLOR_FRAG);
                a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
                a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                break;
            case this.TYPE_POSITION_UCOLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_UCOLOR_VERT, cc.SHADER_POSITION_UCOLOR_FRAG);
                a.addAttribute("aVertex", cc.VERTEX_ATTRIB_POSITION);
                break;
            case this.TYPE_POSITION_LENGTH_TEXTURECOLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_VERT,
                    cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_FRAG);
                a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
                break;
            default:
                cc.log("cocos2d: cc.shaderCache._loadDefaultShader, error shader type");
                return
        }
        a.link();
        a.updateUniforms()
    },
    loadDefaultShaders: function() {
        var a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURECOLOR);
        this._programs[cc.SHADER_POSITION_TEXTURECOLOR] =
            a;
        this._programs.ShaderPositionTextureColor = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST);
        this._programs[cc.SHADER_POSITION_TEXTURECOLORALPHATEST] = a;
        this._programs.ShaderPositionTextureColorAlphaTest = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_COLOR);
        this._programs[cc.SHADER_POSITION_COLOR] = a;
        this._programs.ShaderPositionColor = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE);
        this._programs[cc.SHADER_POSITION_TEXTURE] =
            a;
        this._programs.ShaderPositionTexture = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE_UCOLOR);
        this._programs[cc.SHADER_POSITION_TEXTURE_UCOLOR] = a;
        this._programs.ShaderPositionTextureUColor = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE_A8COLOR);
        this._programs[cc.SHADER_POSITION_TEXTUREA8COLOR] = a;
        this._programs.ShaderPositionTextureA8Color = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_UCOLOR);
        this._programs[cc.SHADER_POSITION_UCOLOR] =
            a;
        this._programs.ShaderPositionUColor = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_LENGTH_TEXTURECOLOR);
        this._programs[cc.SHADER_POSITION_LENGTHTEXTURECOLOR] = a;
        this._programs.ShaderPositionLengthTextureColor = a
    },
    reloadDefaultShaders: function() {
        var a = this.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURECOLOR);
        a = this.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST);
        a = this.programForKey(cc.SHADER_POSITION_COLOR);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_COLOR);
        a = this.programForKey(cc.SHADER_POSITION_TEXTURE);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE);
        a = this.programForKey(cc.SHADER_POSITION_TEXTURE_UCOLOR);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE_UCOLOR);
        a = this.programForKey(cc.SHADER_POSITION_TEXTUREA8COLOR);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE_A8COLOR);
        a = this.programForKey(cc.SHADER_POSITION_UCOLOR);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_UCOLOR)
    },
    programForKey: function(a) {
        return this._programs[a]
    },
    getProgram: function(a) {
        return this._programs[a]
    },
    addProgram: function(a, b) {
        this._programs[b] = a
    }
};
cc.HashUniformEntry = function(a, b, c) {
    this.value = a;
    this.location = b;
    this.hh = c || {}
};
cc.GLProgram = cc.Class.extend({
    _glContext: null,
    _programObj: null,
    _vertShader: null,
    _fragShader: null,
    _uniforms: null,
    _hashForUniforms: null,
    _usesTime: !1,
    _updateUniformLocation: function(a, b, c) {
        if (null == a) return !1;
        c = !0;
        for (var d = null, e = 0; e < this._hashForUniforms.length; e++) this._hashForUniforms[e].location == a && (d = this._hashForUniforms[e]);
        d ? d.value == b ? c = !1 : d.value = b : (d = new cc.HashUniformEntry, d.location = a, d.value = b, this._hashForUniforms.push(d));
        return c
    },
    _description: function() {
        return "\x3cCCGLProgram \x3d " +
            this.toString() + " | Program \x3d " + this._programObj.toString() + ", VertexShader \x3d " + this._vertShader.toString() + ", FragmentShader \x3d " + this._fragShader.toString() + "\x3e"
    },
    _compileShader: function(a, b, c) {
        if (!c || !a) return !1;
        this._glContext.shaderSource(a, "precision highp float;        \nuniform mat4 CC_PMatrix;         \nuniform mat4 CC_MVMatrix;        \nuniform mat4 CC_MVPMatrix;       \nuniform vec4 CC_Time;            \nuniform vec4 CC_SinTime;         \nuniform vec4 CC_CosTime;         \nuniform vec4 CC_Random01;        \nuniform sampler2D CC_Texture0;   \n//CC INCLUDES END                \n" +
            c);
        this._glContext.compileShader(a);
        c = this._glContext.getShaderParameter(a, this._glContext.COMPILE_STATUS);
        c || (cc.log("cocos2d: ERROR: Failed to compile shader:\n" + this._glContext.getShaderSource(a)), b == this._glContext.VERTEX_SHADER ? cc.log("cocos2d: \n" + this.vertexShaderLog()) : cc.log("cocos2d: \n" + this.fragmentShaderLog()));
        return 1 == c
    },
    ctor: function(a, b, c) {
        this._uniforms = [];
        this._hashForUniforms = [];
        this._glContext = c || cc._renderContext;
        a && b && this.init(a, b)
    },
    destroyProgram: function() {
        this._hashForUniforms =
            this._uniforms = this._fragShader = this._vertShader = null;
        this._glContext.deleteProgram(this._programObj)
    },
    initWithVertexShaderByteArray: function(a, b) {
        var c = this._glContext;
        this._programObj = c.createProgram();
        this._fragShader = this._vertShader = null;
        a && (this._vertShader = c.createShader(c.VERTEX_SHADER), this._compileShader(this._vertShader, c.VERTEX_SHADER, a) || cc.log("cocos2d: ERROR: Failed to compile vertex shader"));
        b && (this._fragShader = c.createShader(c.FRAGMENT_SHADER), this._compileShader(this._fragShader,
            c.FRAGMENT_SHADER, b) || cc.log("cocos2d: ERROR: Failed to compile fragment shader"));
        this._vertShader && c.attachShader(this._programObj, this._vertShader);
        cc.checkGLErrorDebug();
        this._fragShader && c.attachShader(this._programObj, this._fragShader);
        this._hashForUniforms.length = 0;
        cc.checkGLErrorDebug();
        return !0
    },
    initWithString: function(a, b) {
        return this.initWithVertexShaderByteArray(a, b)
    },
    initWithVertexShaderFilename: function(a, b) {
        var c = cc.loader.getRes(a);
        if (!c) throw "Please load the resource firset : " + a;
        var d = cc.loader.getRes(b);
        if (!d) throw "Please load the resource firset : " + b;
        return this.initWithVertexShaderByteArray(c, d)
    },
    init: function(a, b) {
        return this.initWithVertexShaderFilename(a, b)
    },
    addAttribute: function(a, b) {
        this._glContext.bindAttribLocation(this._programObj, b, a)
    },
    link: function() {
        if (!this._programObj) return cc.log("cc.GLProgram.link(): Cannot link invalid program"), !1;
        this._glContext.linkProgram(this._programObj);
        this._vertShader && this._glContext.deleteShader(this._vertShader);
        this._fragShader &&
            this._glContext.deleteShader(this._fragShader);
        this._fragShader = this._vertShader = null;
        return cc.game.config[cc.game.CONFIG_KEY.debugMode] && !this._glContext.getProgramParameter(this._programObj, this._glContext.LINK_STATUS) ? (cc.log("cocos2d: ERROR: Failed to link program: " + this._glContext.getProgramInfoLog(this._programObj)), cc.glDeleteProgram(this._programObj), this._programObj = null, !1) : !0
    },
    use: function() {
        cc.glUseProgram(this._programObj)
    },
    updateUniforms: function() {
        this._uniforms[cc.UNIFORM_PMATRIX] =
            this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_PMATRIX_S);
        this._uniforms[cc.UNIFORM_MVMATRIX] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_MVMATRIX_S);
        this._uniforms[cc.UNIFORM_MVPMATRIX] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_MVPMATRIX_S);
        this._uniforms[cc.UNIFORM_TIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_TIME_S);
        this._uniforms[cc.UNIFORM_SINTIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_SINTIME_S);
        this._uniforms[cc.UNIFORM_COSTIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_COSTIME_S);
        this._usesTime = null != this._uniforms[cc.UNIFORM_TIME] || null != this._uniforms[cc.UNIFORM_SINTIME] || null != this._uniforms[cc.UNIFORM_COSTIME];
        this._uniforms[cc.UNIFORM_RANDOM01] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_RANDOM01_S);
        this._uniforms[cc.UNIFORM_SAMPLER] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_SAMPLER_S);
        this.use();
        this.setUniformLocationWith1i(this._uniforms[cc.UNIFORM_SAMPLER],
            0)
    },
    getUniformLocationForName: function(a) {
        if (!a) throw "cc.GLProgram.getUniformLocationForName(): uniform name should be non-null";
        if (!this._programObj) throw "cc.GLProgram.getUniformLocationForName(): Invalid operation. Cannot get uniform location when program is not initialized";
        return this._glContext.getUniformLocation(this._programObj, a)
    },
    getUniformMVPMatrix: function() {
        return this._uniforms[cc.UNIFORM_MVPMATRIX]
    },
    getUniformSampler: function() {
        return this._uniforms[cc.UNIFORM_SAMPLER]
    },
    setUniformLocationWith1i: function(a,
        b) {
        this._updateUniformLocation(a, b) && this._glContext.uniform1i(a, b)
    },
    setUniformLocationWith2i: function(a, b, c) {
        this._updateUniformLocation(a, [b, c]) && this._glContext.uniform2i(a, b, c)
    },
    setUniformLocationWith3i: function(a, b, c, d) {
        this._updateUniformLocation(a, [b, c, d]) && this._glContext.uniform3i(a, b, c, d)
    },
    setUniformLocationWith4i: function(a, b, c, d, e) {
        this._updateUniformLocation(a, [b, c, d, e]) && this._glContext.uniform4i(a, b, c, d, e)
    },
    setUniformLocationWith2iv: function(a, b, c) {
        this._updateUniformLocation(a, b) &&
            this._glContext.uniform2iv(a, b)
    },
    setUniformLocationWith3iv: function(a, b, c) {
        this._updateUniformLocation(a, b) && this._glContext.uniform3iv(a, b)
    },
    setUniformLocationWith4iv: function(a, b, c) {
        this._updateUniformLocation(a, b) && this._glContext.uniform4iv(a, b)
    },
    setUniformLocationI32: function(a, b) {
        this.setUniformLocationWith1i(a, b)
    },
    setUniformLocationWith1f: function(a, b) {
        this._updateUniformLocation(a, b) && this._glContext.uniform1f(a, b)
    },
    setUniformLocationWith2f: function(a, b, c) {
        this._updateUniformLocation(a, [b,
            c
        ]) && this._glContext.uniform2f(a, b, c)
    },
    setUniformLocationWith3f: function(a, b, c, d) {
        this._updateUniformLocation(a, [b, c, d]) && this._glContext.uniform3f(a, b, c, d)
    },
    setUniformLocationWith4f: function(a, b, c, d, e) {
        this._updateUniformLocation(a, [b, c, d, e]) && this._glContext.uniform4f(a, b, c, d, e)
    },
    setUniformLocationWith2fv: function(a, b, c) {
        this._updateUniformLocation(a, b) && this._glContext.uniform2fv(a, b)
    },
    setUniformLocationWith3fv: function(a, b, c) {
        this._updateUniformLocation(a, b) && this._glContext.uniform3fv(a, b)
    },
    setUniformLocationWith4fv: function(a, b, c) {
        this._updateUniformLocation(a, b) && this._glContext.uniform4fv(a, b)
    },
    setUniformLocationWithMatrix4fv: function(a, b, c) {
        this._updateUniformLocation(a, b) && this._glContext.uniformMatrix4fv(a, !1, b)
    },
    setUniformLocationF32: function() {
        if (!(2 > arguments.length)) switch (arguments.length) {
            case 2:
                this.setUniformLocationWith1f(arguments[0], arguments[1]);
                break;
            case 3:
                this.setUniformLocationWith2f(arguments[0], arguments[1], arguments[2]);
                break;
            case 4:
                this.setUniformLocationWith3f(arguments[0],
                    arguments[1], arguments[2], arguments[3]);
                break;
            case 5:
                this.setUniformLocationWith4f(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4])
        }
    },
    setUniformsForBuiltins: function() {
        var a = new cc.kmMat4,
            b = new cc.kmMat4,
            c = new cc.kmMat4;
        cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, a);
        cc.kmGLGetMatrix(cc.KM_GL_MODELVIEW, b);
        cc.kmMat4Multiply(c, a, b);
        this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], a.mat, 1);
        this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], b.mat,
            1);
        this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], c.mat, 1);
        this._usesTime && (a = cc.director, a = a.getTotalFrames() * a.getAnimationInterval(), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_TIME], a / 10, a, 2 * a, 4 * a), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_SINTIME], a / 8, a / 4, a / 2, Math.sin(a)), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_COSTIME], a / 8, a / 4, a / 2, Math.cos(a))); - 1 != this._uniforms[cc.UNIFORM_RANDOM01] && this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_RANDOM01],
            Math.random(), Math.random(), Math.random(), Math.random())
    },
    _setUniformsForBuiltinsForRenderer: function(a) {
        var b = new cc.kmMat4,
            c = new cc.kmMat4;
        cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, b);
        cc.kmMat4Multiply(c, b, a._stackMatrix);
        this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], b.mat, 1);
        this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], a._stackMatrix.mat, 1);
        this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], c.mat, 1);
        this._usesTime && (a = cc.director,
            a = a.getTotalFrames() * a.getAnimationInterval(), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_TIME], a / 10, a, 2 * a, 4 * a), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_SINTIME], a / 8, a / 4, a / 2, Math.sin(a)), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_COSTIME], a / 8, a / 4, a / 2, Math.cos(a))); - 1 != this._uniforms[cc.UNIFORM_RANDOM01] && this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_RANDOM01], Math.random(), Math.random(), Math.random(), Math.random())
    },
    setUniformForModelViewProjectionMatrix: function() {
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], !1, cc.getMat4MultiplyValue(cc.projection_matrix_stack.top, cc.modelview_matrix_stack.top))
    },
    setUniformForModelViewProjectionMatrixWithMat4: function(a) {
        cc.kmMat4Multiply(a, cc.projection_matrix_stack.top, cc.modelview_matrix_stack.top);
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], !1, a.mat)
    },
    setUniformForModelViewAndProjectionMatrixWithMat4: function() {
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], !1, cc.modelview_matrix_stack.top.mat);
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], !1, cc.projection_matrix_stack.top.mat)
    },
    _setUniformForMVPMatrixWithMat4: function(a) {
        if (!a) throw "modelView matrix is undefined.";
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], !1, a.mat);
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], !1, cc.projection_matrix_stack.top.mat)
    },
    vertexShaderLog: function() {
        return this._glContext.getShaderInfoLog(this._vertShader)
    },
    getVertexShaderLog: function() {
        return this._glContext.getShaderInfoLog(this._vertShader)
    },
    getFragmentShaderLog: function() {
        return this._glContext.getShaderInfoLog(this._vertShader)
    },
    fragmentShaderLog: function() {
        return this._glContext.getShaderInfoLog(this._fragShader)
    },
    programLog: function() {
        return this._glContext.getProgramInfoLog(this._programObj)
    },
    getProgramLog: function() {
        return this._glContext.getProgramInfoLog(this._programObj)
    },
    reset: function() {
        this._fragShader = this._vertShader = null;
        this._uniforms.length = 0;
        this._glContext.deleteProgram(this._programObj);
        this._programObj = null;
        for (var a = 0; a < this._hashForUniforms.length; a++) this._hashForUniforms[a].value = null, this._hashForUniforms[a] =
            null;
        this._hashForUniforms.length = 0
    },
    getProgram: function() {
        return this._programObj
    },
    retain: function() {},
    release: function() {}
});
cc.GLProgram.create = function(a, b) {
    return new cc.GLProgram(a, b)
};
cc.setProgram = function(a, b) {
    a.shaderProgram = b;
    var c = a.children;
    if (c)
        for (var d = 0; d < c.length; d++) cc.setProgram(c[d], b)
};
cc._currentProjectionMatrix = -1;
cc._vertexAttribPosition = !1;
cc._vertexAttribColor = !1;
cc._vertexAttribTexCoords = !1;
cc.ENABLE_GL_STATE_CACHE && (cc.MAX_ACTIVETEXTURE = 16, cc._currentShaderProgram = -1, cc._currentBoundTexture = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], cc._blendingSource = -1, cc._blendingDest = -1, cc._GLServerState = 0, cc.TEXTURE_ATLAS_USE_VAO && (cc._uVAO = 0));
cc.glInvalidateStateCache = function() {
    cc.kmGLFreeAll();
    cc._currentProjectionMatrix = -1;
    cc._vertexAttribPosition = !1;
    cc._vertexAttribColor = !1;
    cc._vertexAttribTexCoords = !1;
    if (cc.ENABLE_GL_STATE_CACHE) {
        cc._currentShaderProgram = -1;
        for (var a = 0; a < cc.MAX_ACTIVETEXTURE; a++) cc._currentBoundTexture[a] = -1;
        cc._blendingSource = -1;
        cc._blendingDest = -1;
        cc._GLServerState = 0
    }
};
cc.glUseProgram = function(a) {
    a !== cc._currentShaderProgram && (cc._currentShaderProgram = a, cc._renderContext.useProgram(a))
};
cc.ENABLE_GL_STATE_CACHE || (cc.glUseProgram = function(a) {
    cc._renderContext.useProgram(a)
});
cc.glDeleteProgram = function(a) {
    cc.ENABLE_GL_STATE_CACHE && a === cc._currentShaderProgram && (cc._currentShaderProgram = -1);
    gl.deleteProgram(a)
};
cc.glBlendFunc = function(a, b) {
    if (a !== cc._blendingSource || b !== cc._blendingDest) cc._blendingSource = a, cc._blendingDest = b, cc.setBlending(a, b)
};
cc.setBlending = function(a, b) {
    var c = cc._renderContext;
    a === c.ONE && b === c.ZERO ? c.disable(c.BLEND) : (c.enable(c.BLEND), cc._renderContext.blendFunc(a, b))
};
cc.glBlendFuncForParticle = function(a, b) {
    if (a !== cc._blendingSource || b !== cc._blendingDest) {
        cc._blendingSource = a;
        cc._blendingDest = b;
        var c = cc._renderContext;
        a === c.ONE && b === c.ZERO ? c.disable(c.BLEND) : (c.enable(c.BLEND), c.blendFuncSeparate(c.SRC_ALPHA, b, a, b))
    }
};
cc.ENABLE_GL_STATE_CACHE || (cc.glBlendFunc = cc.setBlending);
cc.glBlendResetToCache = function() {
    var a = cc._renderContext;
    a.blendEquation(a.FUNC_ADD);
    cc.ENABLE_GL_STATE_CACHE ? cc.setBlending(cc._blendingSource, cc._blendingDest) : cc.setBlending(a.BLEND_SRC, a.BLEND_DST)
};
cc.setProjectionMatrixDirty = function() {
    cc._currentProjectionMatrix = -1
};
cc.glEnableVertexAttribs = function(a) {
    var b = cc._renderContext,
        c = a & cc.VERTEX_ATTRIB_FLAG_POSITION;
    c !== cc._vertexAttribPosition && (c ? b.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION) : b.disableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION), cc._vertexAttribPosition = c);
    c = a & cc.VERTEX_ATTRIB_FLAG_COLOR;
    c !== cc._vertexAttribColor && (c ? b.enableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR) : b.disableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR), cc._vertexAttribColor = c);
    a &= cc.VERTEX_ATTRIB_FLAG_TEX_COORDS;
    a !== cc._vertexAttribTexCoords &&
        (a ? b.enableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS) : b.disableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS), cc._vertexAttribTexCoords = a)
};
cc.glBindTexture2D = function(a) {
    cc.glBindTexture2DN(0, a)
};
cc.glBindTexture2DN = function(a, b) {
    if (cc._currentBoundTexture[a] != b) {
        cc._currentBoundTexture[a] = b;
        var c = cc._renderContext;
        c.activeTexture(c.TEXTURE0 + a);
        b ? c.bindTexture(c.TEXTURE_2D, b._webTextureObj) : c.bindTexture(c.TEXTURE_2D, null)
    }
};
cc.ENABLE_GL_STATE_CACHE || (cc.glBindTexture2DN = function(a, b) {
    var c = cc._renderContext;
    c.activeTexture(c.TEXTURE0 + a);
    b ? c.bindTexture(c.TEXTURE_2D, b._webTextureObj) : c.bindTexture(c.TEXTURE_2D, null)
});
cc.glDeleteTexture = function(a) {
    cc.glDeleteTextureN(0, a)
};
cc.glDeleteTextureN = function(a, b) {
    cc.ENABLE_GL_STATE_CACHE && b == cc._currentBoundTexture[a] && (cc._currentBoundTexture[a] = -1);
    cc._renderContext.deleteTexture(b)
};
cc.glBindVAO = function(a) {
    cc.TEXTURE_ATLAS_USE_VAO && (cc.ENABLE_GL_STATE_CACHE && cc._uVAO != a) && (cc._uVAO = a)
};
cc.glEnable = function(a) {};
cc.ACTION_TAG_INVALID = -1;
cc.Action = cc.Class.extend({
    originalTarget: null,
    target: null,
    tag: cc.ACTION_TAG_INVALID,
    ctor: function() {
        this.target = this.originalTarget = null;
        this.tag = cc.ACTION_TAG_INVALID
    },
    copy: function() {
        cc.log("copy is deprecated. Please use clone instead.");
        return this.clone()
    },
    clone: function() {
        var a = new cc.Action;
        a.originalTarget = null;
        a.target = null;
        a.tag = this.tag;
        return a
    },
    isDone: function() {
        return !0
    },
    startWithTarget: function(a) {
        this.target = this.originalTarget = a
    },
    stop: function() {
        this.target = null
    },
    step: function(a) {
        cc.log("[Action step]. override me")
    },
    update: function(a) {
        cc.log("[Action update]. override me")
    },
    getTarget: function() {
        return this.target
    },
    setTarget: function(a) {
        this.target = a
    },
    getOriginalTarget: function() {
        return this.originalTarget
    },
    setOriginalTarget: function(a) {
        this.originalTarget = a
    },
    getTag: function() {
        return this.tag
    },
    setTag: function(a) {
        this.tag = a
    },
    retain: function() {},
    release: function() {}
});
cc.action = function() {
    return new cc.Action
};
cc.Action.create = cc.action;
cc.FiniteTimeAction = cc.Action.extend({
    _duration: 0,
    ctor: function() {
        cc.Action.prototype.ctor.call(this);
        this._duration = 0
    },
    getDuration: function() {
        return this._duration * (this._times || 1)
    },
    setDuration: function(a) {
        this._duration = a
    },
    reverse: function() {
        cc.log("cocos2d: FiniteTimeAction#reverse: Implement me");
        return null
    },
    clone: function() {
        return new cc.FiniteTimeAction
    }
});
cc.Speed = cc.Action.extend({
    _speed: 0,
    _innerAction: null,
    ctor: function(a, b) {
        cc.Action.prototype.ctor.call(this);
        this._speed = 0;
        this._innerAction = null;
        a && this.initWithAction(a, b)
    },
    getSpeed: function() {
        return this._speed
    },
    setSpeed: function(a) {
        this._speed = a
    },
    initWithAction: function(a, b) {
        if (!a) throw "cc.Speed.initWithAction(): action must be non nil";
        this._innerAction = a;
        this._speed = b;
        return !0
    },
    clone: function() {
        var a = new cc.Speed;
        a.initWithAction(this._innerAction.clone(), this._speed);
        return a
    },
    startWithTarget: function(a) {
        cc.Action.prototype.startWithTarget.call(this,
            a);
        this._innerAction.startWithTarget(a)
    },
    stop: function() {
        this._innerAction.stop();
        cc.Action.prototype.stop.call(this)
    },
    step: function(a) {
        this._innerAction.step(a * this._speed)
    },
    isDone: function() {
        return this._innerAction.isDone()
    },
    reverse: function() {
        return new cc.Speed(this._innerAction.reverse(), this._speed)
    },
    setInnerAction: function(a) {
        this._innerAction != a && (this._innerAction = a)
    },
    getInnerAction: function() {
        return this._innerAction
    }
});
cc.speed = function(a, b) {
    return new cc.Speed(a, b)
};
cc.Speed.create = cc.speed;
cc.Follow = cc.Action.extend({
    _followedNode: null,
    _boundarySet: !1,
    _boundaryFullyCovered: !1,
    _halfScreenSize: null,
    _fullScreenSize: null,
    _worldRect: null,
    leftBoundary: 0,
    rightBoundary: 0,
    topBoundary: 0,
    bottomBoundary: 0,
    ctor: function(a, b) {
        cc.Action.prototype.ctor.call(this);
        this._followedNode = null;
        this._boundaryFullyCovered = this._boundarySet = !1;
        this._fullScreenSize = this._halfScreenSize = null;
        this.bottomBoundary = this.topBoundary = this.rightBoundary = this.leftBoundary = 0;
        this._worldRect = cc.rect(0, 0, 0, 0);
        a && (b ? this.initWithTarget(a,
            b) : this.initWithTarget(a))
    },
    clone: function() {
        var a = new cc.Follow,
            b = this._worldRect,
            b = new cc.Rect(b.x, b.y, b.width, b.height);
        a.initWithTarget(this._followedNode, b);
        return a
    },
    isBoundarySet: function() {
        return this._boundarySet
    },
    setBoudarySet: function(a) {
        this._boundarySet = a
    },
    initWithTarget: function(a, b) {
        if (!a) throw "cc.Follow.initWithAction(): followedNode must be non nil";
        b = b || cc.rect(0, 0, 0, 0);
        this._followedNode = a;
        this._worldRect = b;
        this._boundarySet = !cc._rectEqualToZero(b);
        this._boundaryFullyCovered = !1;
        var c = cc.director.getWinSize();
        this._fullScreenSize = cc.p(c.width, c.height);
        this._halfScreenSize = cc.pMult(this._fullScreenSize, 0.5);
        this._boundarySet && (this.leftBoundary = -(b.x + b.width - this._fullScreenSize.x), this.rightBoundary = -b.x, this.topBoundary = -b.y, this.bottomBoundary = -(b.y + b.height - this._fullScreenSize.y), this.rightBoundary < this.leftBoundary && (this.rightBoundary = this.leftBoundary = (this.leftBoundary + this.rightBoundary) / 2), this.topBoundary < this.bottomBoundary && (this.topBoundary = this.bottomBoundary =
            (this.topBoundary + this.bottomBoundary) / 2), this.topBoundary == this.bottomBoundary && this.leftBoundary == this.rightBoundary && (this._boundaryFullyCovered = !0));
        return !0
    },
    step: function(a) {
        a = this._followedNode.x;
        var b = this._followedNode.y;
        a = this._halfScreenSize.x - a;
        b = this._halfScreenSize.y - b;
        this._boundarySet ? this._boundaryFullyCovered || this.target.setPosition(cc.clampf(a, this.leftBoundary, this.rightBoundary), cc.clampf(b, this.bottomBoundary, this.topBoundary)) : this.target.setPosition(a, b)
    },
    isDone: function() {
        return !this._followedNode.running
    },
    stop: function() {
        this.target = null;
        cc.Action.prototype.stop.call(this)
    }
});
cc.follow = function(a, b) {
    return new cc.Follow(a, b)
};
cc.Follow.create = cc.follow;
cc.ActionInterval = cc.FiniteTimeAction.extend({
    _elapsed: 0,
    _firstTick: !1,
    _easeList: null,
    _times: 1,
    _repeatForever: !1,
    _repeatMethod: !1,
    _speed: 1,
    _speedMethod: !1,
    ctor: function(a) {
        this._times = this._speed = 1;
        this._repeatForever = !1;
        this.MAX_VALUE = 2;
        this._speedMethod = this._repeatMethod = !1;
        cc.FiniteTimeAction.prototype.ctor.call(this);
        void 0 !== a && this.initWithDuration(a)
    },
    getElapsed: function() {
        return this._elapsed
    },
    initWithDuration: function(a) {
        this._duration = 0 === a ? cc.FLT_EPSILON : a;
        this._elapsed = 0;
        return this._firstTick = !0
    },
    isDone: function() {
        return this._elapsed >= this._duration
    },
    _cloneDecoration: function(a) {
        a._repeatForever = this._repeatForever;
        a._speed = this._speed;
        a._times = this._times;
        a._easeList = this._easeList;
        a._speedMethod = this._speedMethod;
        a._repeatMethod = this._repeatMethod
    },
    _reverseEaseList: function(a) {
        if (this._easeList) {
            a._easeList = [];
            for (var b = 0; b < this._easeList.length; b++) a._easeList.push(this._easeList[b].reverse())
        }
    },
    clone: function() {
        var a = new cc.ActionInterval(this._duration);
        this._cloneDecoration(a);
        return a
    },
    easing: function(a) {
        this._easeList ? this._easeList.length = 0 : this._easeList = [];
        for (var b = 0; b < arguments.length; b++) this._easeList.push(arguments[b]);
        return this
    },
    _computeEaseTime: function(a) {
        var b = this._easeList;
        if (!b || 0 === b.length) return a;
        for (var c = 0, d = b.length; c < d; c++) a = b[c].easing(a);
        return a
    },
    step: function(a) {
        this._firstTick ? (this._firstTick = !1, this._elapsed = 0) : this._elapsed += a;
        a = this._elapsed / (1.192092896E-7 < this._duration ? this._duration : 1.192092896E-7);
        a = 1 > a ? a : 1;
        this.update(0 < a ? a : 0);
        this._repeatMethod && (1 < this._times && this.isDone()) && (this._repeatForever || this._times--, this.startWithTarget(this.target), this.step(this._elapsed - this._duration))
    },
    startWithTarget: function(a) {
        cc.Action.prototype.startWithTarget.call(this, a);
        this._elapsed = 0;
        this._firstTick = !0
    },
    reverse: function() {
        cc.log("cc.IntervalAction: reverse not implemented.");
        return null
    },
    setAmplitudeRate: function(a) {
        cc.log("cc.ActionInterval.setAmplitudeRate(): it should be overridden in subclass.")
    },
    getAmplitudeRate: function() {
        cc.log("cc.ActionInterval.getAmplitudeRate(): it should be overridden in subclass.");
        return 0
    },
    speed: function(a) {
        if (0 >= a) return cc.log("The speed parameter error"), this;
        this._speedMethod = !0;
        this._speed *= a;
        return this
    },
    getSpeed: function() {
        return this._speed
    },
    setSpeed: function(a) {
        this._speed = a;
        return this
    },
    repeat: function(a) {
        a = Math.round(a);
        if (isNaN(a) || 1 > a) return cc.log("The repeat parameter error"), this;
        this._repeatMethod = !0;
        this._times *= a;
        return this
    },
    repeatForever: function() {
        this._repeatMethod = !0;
        this._times = this.MAX_VALUE;
        this._repeatForever = !0;
        return this
    }
});
cc.actionInterval = function(a) {
    return new cc.ActionInterval(a)
};
cc.ActionInterval.create = cc.actionInterval;
cc.Sequence = cc.ActionInterval.extend({
    _actions: null,
    _split: null,
    _last: 0,
    ctor: function(a) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._actions = [];
        var b = a instanceof Array ? a : arguments,
            c = b.length - 1;
        0 <= c && null == b[c] && cc.log("parameters should not be ending with null in Javascript");
        if (0 <= c) {
            for (var d = b[0], e = 1; e < c; e++) b[e] && (d = cc.Sequence._actionOneTwo(d, b[e]));
            this.initWithTwoActions(d, b[c])
        }
    },
    initWithTwoActions: function(a, b) {
        if (!a || !b) throw "cc.Sequence.initWithTwoActions(): arguments must all be non nil";
        this.initWithDuration(a._duration + b._duration);
        this._actions[0] = a;
        this._actions[1] = b;
        return !0
    },
    clone: function() {
        var a = new cc.Sequence;
        this._cloneDecoration(a);
        a.initWithTwoActions(this._actions[0].clone(), this._actions[1].clone());
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._split = this._actions[0]._duration / this._duration;
        this._last = -1
    },
    stop: function() {
        -1 !== this._last && this._actions[this._last].stop();
        cc.Action.prototype.stop.call(this)
    },
    update: function(a) {
        a =
            this._computeEaseTime(a);
        var b = 0,
            c = this._split,
            d = this._actions,
            e = this._last;
        a < c ? (a = 0 !== c ? a / c : 1, 0 === b && 1 === e && (d[1].update(0), d[1].stop())) : (b = 1, a = 1 === c ? 1 : (a - c) / (1 - c), -1 === e && (d[0].startWithTarget(this.target), d[0].update(1), d[0].stop()), e || (d[0].update(1), d[0].stop()));
        e === b && d[b].isDone() || (e !== b && d[b].startWithTarget(this.target), d[b].update(a), this._last = b)
    },
    reverse: function() {
        var a = cc.Sequence._actionOneTwo(this._actions[1].reverse(), this._actions[0].reverse());
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.sequence = function(a) {
    var b = a instanceof Array ? a : arguments;
    0 < b.length && null == b[b.length - 1] && cc.log("parameters should not be ending with null in Javascript");
    for (var c = b[0], d = 1; d < b.length; d++) b[d] && (c = cc.Sequence._actionOneTwo(c, b[d]));
    return c
};
cc.Sequence.create = cc.sequence;
cc.Sequence._actionOneTwo = function(a, b) {
    var c = new cc.Sequence;
    c.initWithTwoActions(a, b);
    return c
};
cc.Repeat = cc.ActionInterval.extend({
    _times: 0,
    _total: 0,
    _nextDt: 0,
    _actionInstant: !1,
    _innerAction: null,
    ctor: function(a, b) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== b && this.initWithAction(a, b)
    },
    initWithAction: function(a, b) {
        return this.initWithDuration(a._duration * b) ? (this._times = b, this._innerAction = a, a instanceof cc.ActionInstant && (this._actionInstant = !0, this._times -= 1), this._total = 0, !0) : !1
    },
    clone: function() {
        var a = new cc.Repeat;
        this._cloneDecoration(a);
        a.initWithAction(this._innerAction.clone(),
            this._times);
        return a
    },
    startWithTarget: function(a) {
        this._total = 0;
        this._nextDt = this._innerAction._duration / this._duration;
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._innerAction.startWithTarget(a)
    },
    stop: function() {
        this._innerAction.stop();
        cc.Action.prototype.stop.call(this)
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        var b = this._innerAction,
            c = this._duration,
            d = this._times,
            e = this._nextDt;
        if (a >= e) {
            for (; a > e && this._total < d;) b.update(1), this._total++, b.stop(), b.startWithTarget(this.target),
                this._nextDt = e += b._duration / c;
            1 <= a && this._total < d && this._total++;
            this._actionInstant || (this._total === d ? (b.update(1), b.stop()) : b.update(a - (e - b._duration / c)))
        } else b.update(a * d % 1)
    },
    isDone: function() {
        return this._total == this._times
    },
    reverse: function() {
        var a = new cc.Repeat(this._innerAction.reverse(), this._times);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    },
    setInnerAction: function(a) {
        this._innerAction != a && (this._innerAction = a)
    },
    getInnerAction: function() {
        return this._innerAction
    }
});
cc.repeat = function(a, b) {
    return new cc.Repeat(a, b)
};
cc.Repeat.create = cc.repeat;
cc.RepeatForever = cc.ActionInterval.extend({
    _innerAction: null,
    ctor: function(a) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._innerAction = null;
        a && this.initWithAction(a)
    },
    initWithAction: function(a) {
        if (!a) throw "cc.RepeatForever.initWithAction(): action must be non null";
        this._innerAction = a;
        return !0
    },
    clone: function() {
        var a = new cc.RepeatForever;
        this._cloneDecoration(a);
        a.initWithAction(this._innerAction.clone());
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this,
            a);
        this._innerAction.startWithTarget(a)
    },
    step: function(a) {
        var b = this._innerAction;
        b.step(a);
        b.isDone() && (b.startWithTarget(this.target), b.step(b.getElapsed() - b._duration))
    },
    isDone: function() {
        return !1
    },
    reverse: function() {
        var a = new cc.RepeatForever(this._innerAction.reverse());
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    },
    setInnerAction: function(a) {
        this._innerAction != a && (this._innerAction = a)
    },
    getInnerAction: function() {
        return this._innerAction
    }
});
cc.repeatForever = function(a) {
    return new cc.RepeatForever(a)
};
cc.RepeatForever.create = cc.repeatForever;
cc.Spawn = cc.ActionInterval.extend({
    _one: null,
    _two: null,
    ctor: function(a) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._two = this._one = null;
        var b = a instanceof Array ? a : arguments,
            c = b.length - 1;
        0 <= c && null == b[c] && cc.log("parameters should not be ending with null in Javascript");
        if (0 <= c) {
            for (var d = b[0], e = 1; e < c; e++) b[e] && (d = cc.Spawn._actionOneTwo(d, b[e]));
            this.initWithTwoActions(d, b[c])
        }
    },
    initWithTwoActions: function(a, b) {
        if (!a || !b) throw "cc.Spawn.initWithTwoActions(): arguments must all be non null";
        var c = !1,
            d = a._duration,
            e = b._duration;
        this.initWithDuration(Math.max(d, e)) && (this._one = a, this._two = b, d > e ? this._two = cc.Sequence._actionOneTwo(b, cc.delayTime(d - e)) : d < e && (this._one = cc.Sequence._actionOneTwo(a, cc.delayTime(e - d))), c = !0);
        return c
    },
    clone: function() {
        var a = new cc.Spawn;
        this._cloneDecoration(a);
        a.initWithTwoActions(this._one.clone(), this._two.clone());
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._one.startWithTarget(a);
        this._two.startWithTarget(a)
    },
    stop: function() {
        this._one.stop();
        this._two.stop();
        cc.Action.prototype.stop.call(this)
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        this._one && this._one.update(a);
        this._two && this._two.update(a)
    },
    reverse: function() {
        var a = cc.Spawn._actionOneTwo(this._one.reverse(), this._two.reverse());
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.spawn = function(a) {
    var b = a instanceof Array ? a : arguments;
    0 < b.length && null == b[b.length - 1] && cc.log("parameters should not be ending with null in Javascript");
    for (var c = b[0], d = 1; d < b.length; d++) null != b[d] && (c = cc.Spawn._actionOneTwo(c, b[d]));
    return c
};
cc.Spawn.create = cc.spawn;
cc.Spawn._actionOneTwo = function(a, b) {
    var c = new cc.Spawn;
    c.initWithTwoActions(a, b);
    return c
};
cc.RotateTo = cc.ActionInterval.extend({
    _dstAngleX: 0,
    _startAngleX: 0,
    _diffAngleX: 0,
    _dstAngleY: 0,
    _startAngleY: 0,
    _diffAngleY: 0,
    ctor: function(a, b, c) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== b && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._dstAngleX = b || 0, this._dstAngleY = c || this._dstAngleX, !0) : !1
    },
    clone: function() {
        var a = new cc.RotateTo;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._dstAngleX,
            this._dstAngleY);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        var b = a.rotationX % 360,
            c = this._dstAngleX - b;
        180 < c && (c -= 360); - 180 > c && (c += 360);
        this._startAngleX = b;
        this._diffAngleX = c;
        this._startAngleY = a.rotationY % 360;
        a = this._dstAngleY - this._startAngleY;
        180 < a && (a -= 360); - 180 > a && (a += 360);
        this._diffAngleY = a
    },
    reverse: function() {
        cc.log("cc.RotateTo.reverse(): it should be overridden in subclass.")
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        this.target && (this.target.rotationX =
            this._startAngleX + this._diffAngleX * a, this.target.rotationY = this._startAngleY + this._diffAngleY * a)
    }
});
cc.rotateTo = function(a, b, c) {
    return new cc.RotateTo(a, b, c)
};
cc.RotateTo.create = cc.rotateTo;
cc.RotateBy = cc.ActionInterval.extend({
    _angleX: 0,
    _startAngleX: 0,
    _angleY: 0,
    _startAngleY: 0,
    ctor: function(a, b, c) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== b && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._angleX = b || 0, this._angleY = c || this._angleX, !0) : !1
    },
    clone: function() {
        var a = new cc.RotateBy;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._angleX, this._angleY);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this,
            a);
        this._startAngleX = a.rotationX;
        this._startAngleY = a.rotationY
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        this.target && (this.target.rotationX = this._startAngleX + this._angleX * a, this.target.rotationY = this._startAngleY + this._angleY * a)
    },
    reverse: function() {
        var a = new cc.RotateBy(this._duration, -this._angleX, -this._angleY);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.rotateBy = function(a, b, c) {
    return new cc.RotateBy(a, b, c)
};
cc.RotateBy.create = cc.rotateBy;
cc.MoveBy = cc.ActionInterval.extend({
    _positionDelta: null,
    _startPosition: null,
    _previousPosition: null,
    ctor: function(a, b, c) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._positionDelta = cc.p(0, 0);
        this._startPosition = cc.p(0, 0);
        this._previousPosition = cc.p(0, 0);
        void 0 !== b && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (void 0 !== b.x && (c = b.y, b = b.x), this._positionDelta.x = b, this._positionDelta.y = c, !0) : !1
    },
    clone: function() {
        var a =
            new cc.MoveBy;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._positionDelta);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        var b = a.getPositionX();
        a = a.getPositionY();
        this._previousPosition.x = b;
        this._previousPosition.y = a;
        this._startPosition.x = b;
        this._startPosition.y = a
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        if (this.target) {
            var b = this._positionDelta.x * a;
            a *= this._positionDelta.y;
            var c = this._startPosition;
            if (cc.ENABLE_STACKABLE_ACTIONS) {
                var d =
                    this.target.getPositionX(),
                    e = this.target.getPositionY(),
                    f = this._previousPosition;
                c.x = c.x + d - f.x;
                c.y = c.y + e - f.y;
                b += c.x;
                a += c.y;
                f.x = b;
                f.y = a;
                this.target.setPosition(b, a)
            } else this.target.setPosition(c.x + b, c.y + a)
        }
    },
    reverse: function() {
        var a = new cc.MoveBy(this._duration, cc.p(-this._positionDelta.x, -this._positionDelta.y));
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.moveBy = function(a, b, c) {
    return new cc.MoveBy(a, b, c)
};
cc.MoveBy.create = cc.moveBy;
cc.MoveTo = cc.MoveBy.extend({
    _endPosition: null,
    ctor: function(a, b, c) {
        cc.MoveBy.prototype.ctor.call(this);
        this._endPosition = cc.p(0, 0);
        void 0 !== b && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        return cc.MoveBy.prototype.initWithDuration.call(this, a, b, c) ? (void 0 !== b.x && (c = b.y, b = b.x), this._endPosition.x = b, this._endPosition.y = c, !0) : !1
    },
    clone: function() {
        var a = new cc.MoveTo;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._endPosition);
        return a
    },
    startWithTarget: function(a) {
        cc.MoveBy.prototype.startWithTarget.call(this,
            a);
        this._positionDelta.x = this._endPosition.x - a.getPositionX();
        this._positionDelta.y = this._endPosition.y - a.getPositionY()
    }
});
cc.moveTo = function(a, b, c) {
    return new cc.MoveTo(a, b, c)
};
cc.MoveTo.create = cc.moveTo;
cc.SkewTo = cc.ActionInterval.extend({
    _skewX: 0,
    _skewY: 0,
    _startSkewX: 0,
    _startSkewY: 0,
    _endSkewX: 0,
    _endSkewY: 0,
    _deltaX: 0,
    _deltaY: 0,
    ctor: function(a, b, c) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== c && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        var d = !1;
        cc.ActionInterval.prototype.initWithDuration.call(this, a) && (this._endSkewX = b, this._endSkewY = c, d = !0);
        return d
    },
    clone: function() {
        var a = new cc.SkewTo;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._endSkewX, this._endSkewY);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._startSkewX = a.skewX % 180;
        this._deltaX = this._endSkewX - this._startSkewX;
        180 < this._deltaX && (this._deltaX -= 360); - 180 > this._deltaX && (this._deltaX += 360);
        this._startSkewY = a.skewY % 360;
        this._deltaY = this._endSkewY - this._startSkewY;
        180 < this._deltaY && (this._deltaY -= 360); - 180 > this._deltaY && (this._deltaY += 360)
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        this.target.skewX = this._startSkewX + this._deltaX * a;
        this.target.skewY =
            this._startSkewY + this._deltaY * a
    }
});
cc.skewTo = function(a, b, c) {
    return new cc.SkewTo(a, b, c)
};
cc.SkewTo.create = cc.skewTo;
cc.SkewBy = cc.SkewTo.extend({
    ctor: function(a, b, c) {
        cc.SkewTo.prototype.ctor.call(this);
        void 0 !== c && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        var d = !1;
        cc.SkewTo.prototype.initWithDuration.call(this, a, b, c) && (this._skewX = b, this._skewY = c, d = !0);
        return d
    },
    clone: function() {
        var a = new cc.SkewBy;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._skewX, this._skewY);
        return a
    },
    startWithTarget: function(a) {
        cc.SkewTo.prototype.startWithTarget.call(this, a);
        this._deltaX = this._skewX;
        this._deltaY = this._skewY;
        this._endSkewX = this._startSkewX + this._deltaX;
        this._endSkewY = this._startSkewY + this._deltaY
    },
    reverse: function() {
        var a = new cc.SkewBy(this._duration, -this._skewX, -this._skewY);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.skewBy = function(a, b, c) {
    return new cc.SkewBy(a, b, c)
};
cc.SkewBy.create = cc.skewBy;
cc.JumpBy = cc.ActionInterval.extend({
    _startPosition: null,
    _delta: null,
    _height: 0,
    _jumps: 0,
    _previousPosition: null,
    ctor: function(a, b, c, d, e) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._startPosition = cc.p(0, 0);
        this._previousPosition = cc.p(0, 0);
        this._delta = cc.p(0, 0);
        void 0 !== d && this.initWithDuration(a, b, c, d, e)
    },
    initWithDuration: function(a, b, c, d, e) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (void 0 === e && (e = d, d = c, c = b.y, b = b.x), this._delta.x = b, this._delta.y = c, this._height = d, this._jumps =
            e, !0) : !1
    },
    clone: function() {
        var a = new cc.JumpBy;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._delta, this._height, this._jumps);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        var b = a.getPositionX();
        a = a.getPositionY();
        this._previousPosition.x = b;
        this._previousPosition.y = a;
        this._startPosition.x = b;
        this._startPosition.y = a
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        if (this.target) {
            var b = a * this._jumps % 1,
                b = 4 * this._height * b * (1 - b),
                b = b + this._delta.y *
                a;
            a *= this._delta.x;
            var c = this._startPosition;
            if (cc.ENABLE_STACKABLE_ACTIONS) {
                var d = this.target.getPositionX(),
                    e = this.target.getPositionY(),
                    f = this._previousPosition;
                c.x = c.x + d - f.x;
                c.y = c.y + e - f.y;
                a += c.x;
                b += c.y;
                f.x = a;
                f.y = b;
                this.target.setPosition(a, b)
            } else this.target.setPosition(c.x + a, c.y + b)
        }
    },
    reverse: function() {
        var a = new cc.JumpBy(this._duration, cc.p(-this._delta.x, -this._delta.y), this._height, this._jumps);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.jumpBy = function(a, b, c, d, e) {
    return new cc.JumpBy(a, b, c, d, e)
};
cc.JumpBy.create = cc.jumpBy;
cc.JumpTo = cc.JumpBy.extend({
    _endPosition: null,
    ctor: function(a, b, c, d, e) {
        cc.JumpBy.prototype.ctor.call(this);
        this._endPosition = cc.p(0, 0);
        void 0 !== d && this.initWithDuration(a, b, c, d, e)
    },
    initWithDuration: function(a, b, c, d, e) {
        return cc.JumpBy.prototype.initWithDuration.call(this, a, b, c, d, e) ? (void 0 === e && (c = b.y, b = b.x), this._endPosition.x = b, this._endPosition.y = c, !0) : !1
    },
    startWithTarget: function(a) {
        cc.JumpBy.prototype.startWithTarget.call(this, a);
        this._delta.x = this._endPosition.x - this._startPosition.x;
        this._delta.y =
            this._endPosition.y - this._startPosition.y
    },
    clone: function() {
        var a = new cc.JumpTo;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._endPosition, this._height, this._jumps);
        return a
    }
});
cc.jumpTo = function(a, b, c, d, e) {
    return new cc.JumpTo(a, b, c, d, e)
};
cc.JumpTo.create = cc.jumpTo;
cc.bezierAt = function(a, b, c, d, e) {
    return Math.pow(1 - e, 3) * a + 3 * e * Math.pow(1 - e, 2) * b + 3 * Math.pow(e, 2) * (1 - e) * c + Math.pow(e, 3) * d
};
cc.BezierBy = cc.ActionInterval.extend({
    _config: null,
    _startPosition: null,
    _previousPosition: null,
    ctor: function(a, b) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._config = [];
        this._startPosition = cc.p(0, 0);
        this._previousPosition = cc.p(0, 0);
        b && this.initWithDuration(a, b)
    },
    initWithDuration: function(a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._config = b, !0) : !1
    },
    clone: function() {
        var a = new cc.BezierBy;
        this._cloneDecoration(a);
        for (var b = [], c = 0; c < this._config.length; c++) {
            var d =
                this._config[c];
            b.push(cc.p(d.x, d.y))
        }
        a.initWithDuration(this._duration, b);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        var b = a.getPositionX();
        a = a.getPositionY();
        this._previousPosition.x = b;
        this._previousPosition.y = a;
        this._startPosition.x = b;
        this._startPosition.y = a
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        if (this.target) {
            var b = this._config,
                c = b[0].y,
                d = b[1].y,
                e = b[2].y,
                b = cc.bezierAt(0, b[0].x, b[1].x, b[2].x, a);
            a = cc.bezierAt(0, c, d, e, a);
            c = this._startPosition;
            if (cc.ENABLE_STACKABLE_ACTIONS) {
                var d = this.target.getPositionX(),
                    e = this.target.getPositionY(),
                    f = this._previousPosition;
                c.x = c.x + d - f.x;
                c.y = c.y + e - f.y;
                b += c.x;
                a += c.y;
                f.x = b;
                f.y = a;
                this.target.setPosition(b, a)
            } else this.target.setPosition(c.x + b, c.y + a)
        }
    },
    reverse: function() {
        var a = this._config,
            a = [cc.pAdd(a[1], cc.pNeg(a[2])), cc.pAdd(a[0], cc.pNeg(a[2])), cc.pNeg(a[2])],
            a = new cc.BezierBy(this._duration, a);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.bezierBy = function(a, b) {
    return new cc.BezierBy(a, b)
};
cc.BezierBy.create = cc.bezierBy;
cc.BezierTo = cc.BezierBy.extend({
    _toConfig: null,
    ctor: function(a, b) {
        cc.BezierBy.prototype.ctor.call(this);
        this._toConfig = [];
        b && this.initWithDuration(a, b)
    },
    initWithDuration: function(a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._toConfig = b, !0) : !1
    },
    clone: function() {
        var a = new cc.BezierTo;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._toConfig);
        return a
    },
    startWithTarget: function(a) {
        cc.BezierBy.prototype.startWithTarget.call(this, a);
        a = this._startPosition;
        var b =
            this._toConfig,
            c = this._config;
        c[0] = cc.pSub(b[0], a);
        c[1] = cc.pSub(b[1], a);
        c[2] = cc.pSub(b[2], a)
    }
});
cc.bezierTo = function(a, b) {
    return new cc.BezierTo(a, b)
};
cc.BezierTo.create = cc.bezierTo;
cc.ScaleTo = cc.ActionInterval.extend({
    _scaleX: 1,
    _scaleY: 1,
    _startScaleX: 1,
    _startScaleY: 1,
    _endScaleX: 0,
    _endScaleY: 0,
    _deltaX: 0,
    _deltaY: 0,
    ctor: function(a, b, c) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== b && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._endScaleX = b, this._endScaleY = null != c ? c : b, !0) : !1
    },
    clone: function() {
        var a = new cc.ScaleTo;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._endScaleX,
            this._endScaleY);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._startScaleX = a.scaleX;
        this._startScaleY = a.scaleY;
        this._deltaX = this._endScaleX - this._startScaleX;
        this._deltaY = this._endScaleY - this._startScaleY
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        this.target && (this.target.scaleX = this._startScaleX + this._deltaX * a, this.target.scaleY = this._startScaleY + this._deltaY * a)
    }
});
cc.scaleTo = function(a, b, c) {
    return new cc.ScaleTo(a, b, c)
};
cc.ScaleTo.create = cc.scaleTo;
cc.ScaleBy = cc.ScaleTo.extend({
    startWithTarget: function(a) {
        cc.ScaleTo.prototype.startWithTarget.call(this, a);
        this._deltaX = this._startScaleX * this._endScaleX - this._startScaleX;
        this._deltaY = this._startScaleY * this._endScaleY - this._startScaleY
    },
    reverse: function() {
        var a = new cc.ScaleBy(this._duration, 1 / this._endScaleX, 1 / this._endScaleY);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    },
    clone: function() {
        var a = new cc.ScaleBy;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._endScaleX,
            this._endScaleY);
        return a
    }
});
cc.scaleBy = function(a, b, c) {
    return new cc.ScaleBy(a, b, c)
};
cc.ScaleBy.create = cc.scaleBy;
cc.Blink = cc.ActionInterval.extend({
    _times: 0,
    _originalState: !1,
    ctor: function(a, b) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== b && this.initWithDuration(a, b)
    },
    initWithDuration: function(a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._times = b, !0) : !1
    },
    clone: function() {
        var a = new cc.Blink;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._times);
        return a
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        if (this.target && !this.isDone()) {
            var b = 1 / this._times;
            this.target.visible =
                a % b > b / 2
        }
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._originalState = a.visible
    },
    stop: function() {
        this.target.visible = this._originalState;
        cc.ActionInterval.prototype.stop.call(this)
    },
    reverse: function() {
        var a = new cc.Blink(this._duration, this._times);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.blink = function(a, b) {
    return new cc.Blink(a, b)
};
cc.Blink.create = cc.blink;
cc.FadeTo = cc.ActionInterval.extend({
    _toOpacity: 0,
    _fromOpacity: 0,
    ctor: function(a, b) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== b && this.initWithDuration(a, b)
    },
    initWithDuration: function(a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._toOpacity = b, !0) : !1
    },
    clone: function() {
        var a = new cc.FadeTo;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._toOpacity);
        return a
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        var b = void 0 !== this._fromOpacity ? this._fromOpacity :
            255;
        this.target.opacity = b + (this._toOpacity - b) * a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._fromOpacity = a.opacity
    }
});
cc.fadeTo = function(a, b) {
    return new cc.FadeTo(a, b)
};
cc.FadeTo.create = cc.fadeTo;
cc.FadeIn = cc.FadeTo.extend({
    _reverseAction: null,
    ctor: function(a) {
        cc.FadeTo.prototype.ctor.call(this);
        a && this.initWithDuration(a, 255)
    },
    reverse: function() {
        var a = new cc.FadeOut;
        a.initWithDuration(this._duration, 0);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    },
    clone: function() {
        var a = new cc.FadeIn;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._toOpacity);
        return a
    },
    startWithTarget: function(a) {
        this._reverseAction && (this._toOpacity = this._reverseAction._fromOpacity);
        cc.FadeTo.prototype.startWithTarget.call(this,
            a)
    }
});
cc.fadeIn = function(a) {
    return new cc.FadeIn(a)
};
cc.FadeIn.create = cc.fadeIn;
cc.FadeOut = cc.FadeTo.extend({
    ctor: function(a) {
        cc.FadeTo.prototype.ctor.call(this);
        a && this.initWithDuration(a, 0)
    },
    reverse: function() {
        var a = new cc.FadeIn;
        a._reverseAction = this;
        a.initWithDuration(this._duration, 255);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    },
    clone: function() {
        var a = new cc.FadeOut;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._toOpacity);
        return a
    }
});
cc.fadeOut = function(a) {
    return new cc.FadeOut(a)
};
cc.FadeOut.create = cc.fadeOut;
cc.TintTo = cc.ActionInterval.extend({
    _to: null,
    _from: null,
    ctor: function(a, b, c, d) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._to = cc.color(0, 0, 0);
        this._from = cc.color(0, 0, 0);
        void 0 !== d && this.initWithDuration(a, b, c, d)
    },
    initWithDuration: function(a, b, c, d) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._to = cc.color(b, c, d), !0) : !1
    },
    clone: function() {
        var a = new cc.TintTo;
        this._cloneDecoration(a);
        var b = this._to;
        a.initWithDuration(this._duration, b.r, b.g, b.b);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this,
            a);
        this._from = this.target.color
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        var b = this._from,
            c = this._to;
        b && (this.target.color = cc.color(b.r + (c.r - b.r) * a, b.g + (c.g - b.g) * a, b.b + (c.b - b.b) * a))
    }
});
cc.tintTo = function(a, b, c, d) {
    return new cc.TintTo(a, b, c, d)
};
cc.TintTo.create = cc.tintTo;
cc.TintBy = cc.ActionInterval.extend({
    _deltaR: 0,
    _deltaG: 0,
    _deltaB: 0,
    _fromR: 0,
    _fromG: 0,
    _fromB: 0,
    ctor: function(a, b, c, d) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== d && this.initWithDuration(a, b, c, d)
    },
    initWithDuration: function(a, b, c, d) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._deltaR = b, this._deltaG = c, this._deltaB = d, !0) : !1
    },
    clone: function() {
        var a = new cc.TintBy;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._deltaR, this._deltaG, this._deltaB);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        a = a.color;
        this._fromR = a.r;
        this._fromG = a.g;
        this._fromB = a.b
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        this.target.color = cc.color(this._fromR + this._deltaR * a, this._fromG + this._deltaG * a, this._fromB + this._deltaB * a)
    },
    reverse: function() {
        var a = new cc.TintBy(this._duration, -this._deltaR, -this._deltaG, -this._deltaB);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.tintBy = function(a, b, c, d) {
    return new cc.TintBy(a, b, c, d)
};
cc.TintBy.create = cc.tintBy;
cc.DelayTime = cc.ActionInterval.extend({
    update: function(a) {},
    reverse: function() {
        var a = new cc.DelayTime(this._duration);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    },
    clone: function() {
        var a = new cc.DelayTime;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration);
        return a
    }
});
cc.delayTime = function(a) {
    return new cc.DelayTime(a)
};
cc.DelayTime.create = cc.delayTime;
cc.ReverseTime = cc.ActionInterval.extend({
    _other: null,
    ctor: function(a) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._other = null;
        a && this.initWithAction(a)
    },
    initWithAction: function(a) {
        if (!a) throw "cc.ReverseTime.initWithAction(): action must be non null";
        if (a == this._other) throw "cc.ReverseTime.initWithAction(): the action was already passed in.";
        return cc.ActionInterval.prototype.initWithDuration.call(this, a._duration) ? (this._other = a, !0) : !1
    },
    clone: function() {
        var a = new cc.ReverseTime;
        this._cloneDecoration(a);
        a.initWithAction(this._other.clone());
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._other.startWithTarget(a)
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        this._other && this._other.update(1 - a)
    },
    reverse: function() {
        return this._other.clone()
    },
    stop: function() {
        this._other.stop();
        cc.Action.prototype.stop.call(this)
    }
});
cc.reverseTime = function(a) {
    return new cc.ReverseTime(a)
};
cc.ReverseTime.create = cc.reverseTime;
cc.Animate = cc.ActionInterval.extend({
    _animation: null,
    _nextFrame: 0,
    _origFrame: null,
    _executedLoops: 0,
    _splitTimes: null,
    ctor: function(a) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._splitTimes = [];
        a && this.initWithAnimation(a)
    },
    getAnimation: function() {
        return this._animation
    },
    setAnimation: function(a) {
        this._animation = a
    },
    initWithAnimation: function(a) {
        if (!a) throw "cc.Animate.initWithAnimation(): animation must be non-NULL";
        var b = a.getDuration();
        if (this.initWithDuration(b * a.getLoops())) {
            this._nextFrame =
                0;
            this.setAnimation(a);
            this._origFrame = null;
            this._executedLoops = 0;
            var c = this._splitTimes,
                d = c.length = 0,
                e = b / a.getTotalDelayUnits();
            a = a.getFrames();
            cc.arrayVerifyType(a, cc.AnimationFrame);
            for (var f = 0; f < a.length; f++) {
                var g = d * e / b,
                    d = d + a[f].getDelayUnits();
                c.push(g)
            }
            return !0
        }
        return !1
    },
    clone: function() {
        var a = new cc.Animate;
        this._cloneDecoration(a);
        a.initWithAnimation(this._animation.clone());
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._animation.getRestoreOriginalFrame() &&
            (this._origFrame = a.displayFrame());
        this._executedLoops = this._nextFrame = 0
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        1 > a && (a *= this._animation.getLoops(), (0 | a) > this._executedLoops && (this._nextFrame = 0, this._executedLoops++), a %= 1);
        for (var b = this._animation.getFrames(), c = b.length, d = this._splitTimes, e = this._nextFrame; e < c; e++)
            if (d[e] <= a) this.target.setSpriteFrame(b[e].getSpriteFrame()), this._nextFrame = e + 1;
            else break
    },
    reverse: function() {
        var a = this._animation,
            b = a.getFrames(),
            c = [];
        cc.arrayVerifyType(b,
            cc.AnimationFrame);
        if (0 < b.length)
            for (var d = b.length - 1; 0 <= d; d--) {
                var e = b[d];
                if (!e) break;
                c.push(e.clone())
            }
        b = new cc.Animation(c, a.getDelayPerUnit(), a.getLoops());
        b.setRestoreOriginalFrame(a.getRestoreOriginalFrame());
        a = new cc.Animate(b);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    },
    stop: function() {
        this._animation.getRestoreOriginalFrame() && this.target && this.target.setSpriteFrame(this._origFrame);
        cc.Action.prototype.stop.call(this)
    }
});
cc.animate = function(a) {
    return new cc.Animate(a)
};
cc.Animate.create = cc.animate;
cc.TargetedAction = cc.ActionInterval.extend({
    _action: null,
    _forcedTarget: null,
    ctor: function(a, b) {
        cc.ActionInterval.prototype.ctor.call(this);
        b && this.initWithTarget(a, b)
    },
    initWithTarget: function(a, b) {
        return this.initWithDuration(b._duration) ? (this._forcedTarget = a, this._action = b, !0) : !1
    },
    clone: function() {
        var a = new cc.TargetedAction;
        this._cloneDecoration(a);
        a.initWithTarget(this._forcedTarget, this._action.clone());
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._action.startWithTarget(this._forcedTarget)
    },
    stop: function() {
        this._action.stop()
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        this._action.update(a)
    },
    getForcedTarget: function() {
        return this._forcedTarget
    },
    setForcedTarget: function(a) {
        this._forcedTarget != a && (this._forcedTarget = a)
    }
});
cc.targetedAction = function(a, b) {
    return new cc.TargetedAction(a, b)
};
cc.TargetedAction.create = cc.targetedAction;
cc.ActionInstant = cc.FiniteTimeAction.extend({
    isDone: function() {
        return !0
    },
    step: function(a) {
        this.update(1)
    },
    update: function(a) {},
    reverse: function() {
        return this.clone()
    },
    clone: function() {
        return new cc.ActionInstant
    }
});
cc.Show = cc.ActionInstant.extend({
    update: function(a) {
        this.target.visible = !0
    },
    reverse: function() {
        return new cc.Hide
    },
    clone: function() {
        return new cc.Show
    }
});
cc.show = function() {
    return new cc.Show
};
cc.Show.create = cc.show;
cc.Hide = cc.ActionInstant.extend({
    update: function(a) {
        this.target.visible = !1
    },
    reverse: function() {
        return new cc.Show
    },
    clone: function() {
        return new cc.Hide
    }
});
cc.hide = function() {
    return new cc.Hide
};
cc.Hide.create = cc.hide;
cc.ToggleVisibility = cc.ActionInstant.extend({
    update: function(a) {
        this.target.visible = !this.target.visible
    },
    reverse: function() {
        return new cc.ToggleVisibility
    },
    clone: function() {
        return new cc.ToggleVisibility
    }
});
cc.toggleVisibility = function() {
    return new cc.ToggleVisibility
};
cc.ToggleVisibility.create = cc.toggleVisibility;
cc.RemoveSelf = cc.ActionInstant.extend({
    _isNeedCleanUp: !0,
    ctor: function(a) {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        void 0 !== a && this.init(a)
    },
    update: function(a) {
        this.target.removeFromParent(this._isNeedCleanUp)
    },
    init: function(a) {
        this._isNeedCleanUp = a;
        return !0
    },
    reverse: function() {
        return new cc.RemoveSelf(this._isNeedCleanUp)
    },
    clone: function() {
        return new cc.RemoveSelf(this._isNeedCleanUp)
    }
});
cc.removeSelf = function(a) {
    return new cc.RemoveSelf(a)
};
cc.RemoveSelf.create = cc.removeSelf;
cc.FlipX = cc.ActionInstant.extend({
    _flippedX: !1,
    ctor: function(a) {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        this._flippedX = !1;
        void 0 !== a && this.initWithFlipX(a)
    },
    initWithFlipX: function(a) {
        this._flippedX = a;
        return !0
    },
    update: function(a) {
        this.target.flippedX = this._flippedX
    },
    reverse: function() {
        return new cc.FlipX(!this._flippedX)
    },
    clone: function() {
        var a = new cc.FlipX;
        a.initWithFlipX(this._flippedX);
        return a
    }
});
cc.flipX = function(a) {
    return new cc.FlipX(a)
};
cc.FlipX.create = cc.flipX;
cc.FlipY = cc.ActionInstant.extend({
    _flippedY: !1,
    ctor: function(a) {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        this._flippedY = !1;
        void 0 !== a && this.initWithFlipY(a)
    },
    initWithFlipY: function(a) {
        this._flippedY = a;
        return !0
    },
    update: function(a) {
        this.target.flippedY = this._flippedY
    },
    reverse: function() {
        return new cc.FlipY(!this._flippedY)
    },
    clone: function() {
        var a = new cc.FlipY;
        a.initWithFlipY(this._flippedY);
        return a
    }
});
cc.flipY = function(a) {
    return new cc.FlipY(a)
};
cc.FlipY.create = cc.flipY;
cc.Place = cc.ActionInstant.extend({
    _x: 0,
    _y: 0,
    ctor: function(a, b) {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        this._y = this._x = 0;
        void 0 !== a && (void 0 !== a.x && (b = a.y, a = a.x), this.initWithPosition(a, b))
    },
    initWithPosition: function(a, b) {
        this._x = a;
        this._y = b;
        return !0
    },
    update: function(a) {
        this.target.setPosition(this._x, this._y)
    },
    clone: function() {
        var a = new cc.Place;
        a.initWithPosition(this._x, this._y);
        return a
    }
});
cc.place = function(a, b) {
    return new cc.Place(a, b)
};
cc.Place.create = cc.place;
cc.CallFunc = cc.ActionInstant.extend({
    _selectorTarget: null,
    _callFunc: null,
    _function: null,
    _data: null,
    ctor: function(a, b, c) {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        void 0 !== a && (void 0 === b ? this.initWithFunction(a) : this.initWithFunction(a, b, c))
    },
    initWithFunction: function(a, b, c) {
        b ? (this._data = c, this._callFunc = a, this._selectorTarget = b) : a && (this._function = a);
        return !0
    },
    execute: function() {
        null != this._callFunc ? this._callFunc.call(this._selectorTarget, this.target, this._data) : this._function && this._function.call(null,
            this.target)
    },
    update: function(a) {
        this.execute()
    },
    getTargetCallback: function() {
        return this._selectorTarget
    },
    setTargetCallback: function(a) {
        a != this._selectorTarget && (this._selectorTarget && (this._selectorTarget = null), this._selectorTarget = a)
    },
    clone: function() {
        var a = new cc.CallFunc;
        this._selectorTarget ? a.initWithFunction(this._callFunc, this._selectorTarget, this._data) : this._function && a.initWithFunction(this._function);
        return a
    }
});
cc.callFunc = function(a, b, c) {
    return new cc.CallFunc(a, b, c)
};
cc.CallFunc.create = cc.callFunc;
cc.ActionCamera = cc.ActionInterval.extend({
    _centerXOrig: 0,
    _centerYOrig: 0,
    _centerZOrig: 0,
    _eyeXOrig: 0,
    _eyeYOrig: 0,
    _eyeZOrig: 0,
    _upXOrig: 0,
    _upYOrig: 0,
    _upZOrig: 0,
    ctor: function() {
        cc.ActionInterval.prototype.ctor.call(this);
        this._upZOrig = this._upYOrig = this._upXOrig = this._eyeZOrig = this._eyeYOrig = this._eyeXOrig = this._centerZOrig = this._centerYOrig = this._centerXOrig = 0
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        a = a.getCamera();
        var b = a.getCenter();
        this._centerXOrig = b.x;
        this._centerYOrig = b.y;
        this._centerZOrig = b.z;
        b = a.getEye();
        this._eyeXOrig = b.x;
        this._eyeYOrig = b.y;
        this._eyeZOrig = b.z;
        a = a.getUp();
        this._upXOrig = a.x;
        this._upYOrig = a.y;
        this._upZOrig = a.z
    },
    clone: function() {
        return new cc.ActionCamera
    },
    reverse: function() {
        return new cc.ReverseTime(this)
    }
});
cc.OrbitCamera = cc.ActionCamera.extend({
    _radius: 0,
    _deltaRadius: 0,
    _angleZ: 0,
    _deltaAngleZ: 0,
    _angleX: 0,
    _deltaAngleX: 0,
    _radZ: 0,
    _radDeltaZ: 0,
    _radX: 0,
    _radDeltaX: 0,
    ctor: function(a, b, c, d, e, f, g) {
        cc.ActionCamera.prototype.ctor.call(this);
        void 0 !== g && this.initWithDuration(a, b, c, d, e, f, g)
    },
    initWithDuration: function(a, b, c, d, e, f, g) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._radius = b, this._deltaRadius = c, this._angleZ = d, this._deltaAngleZ = e, this._angleX = f, this._deltaAngleX = g, this._radDeltaZ =
            cc.degreesToRadians(e), this._radDeltaX = cc.degreesToRadians(g), !0) : !1
    },
    sphericalRadius: function() {
        var a, b;
        b = this.target.getCamera();
        var c = b.getEye();
        a = b.getCenter();
        b = c.x - a.x;
        var d = c.y - a.y;
        a = c.z - a.z;
        var c = Math.sqrt(Math.pow(b, 2) + Math.pow(d, 2) + Math.pow(a, 2)),
            e = Math.sqrt(Math.pow(b, 2) + Math.pow(d, 2));
        0 === e && (e = cc.FLT_EPSILON);
        0 === c && (c = cc.FLT_EPSILON);
        a = Math.acos(a / c);
        b = 0 > b ? Math.PI - Math.asin(d / e) : Math.asin(d / e);
        return {
            newRadius: c / cc.Camera.getZEye(),
            zenith: a,
            azimuth: b
        }
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this,
            a);
        a = this.sphericalRadius();
        isNaN(this._radius) && (this._radius = a.newRadius);
        isNaN(this._angleZ) && (this._angleZ = cc.radiansToDegrees(a.zenith));
        isNaN(this._angleX) && (this._angleX = cc.radiansToDegrees(a.azimuth));
        this._radZ = cc.degreesToRadians(this._angleZ);
        this._radX = cc.degreesToRadians(this._angleX)
    },
    clone: function() {
        var a = new cc.OrbitCamera;
        a.initWithDuration(this._duration, this._radius, this._deltaRadius, this._angleZ, this._deltaAngleZ, this._angleX, this._deltaAngleX);
        return a
    },
    update: function(a) {
        a =
            this._computeEaseTime(a);
        var b = (this._radius + this._deltaRadius * a) * cc.Camera.getZEye(),
            c = this._radZ + this._radDeltaZ * a,
            d = this._radX + this._radDeltaX * a;
        a = Math.sin(c) * Math.cos(d) * b + this._centerXOrig;
        d = Math.sin(c) * Math.sin(d) * b + this._centerYOrig;
        b = Math.cos(c) * b + this._centerZOrig;
        this.target.getCamera().setEye(a, d, b);
        this.target.setNodeDirty()
    }
});
cc.orbitCamera = function(a, b, c, d, e, f, g) {
    return new cc.OrbitCamera(a, b, c, d, e, f, g)
};
cc.OrbitCamera.create = cc.orbitCamera;
cc.ActionEase = cc.ActionInterval.extend({
    _inner: null,
    ctor: function(a) {
        cc.ActionInterval.prototype.ctor.call(this);
        a && this.initWithAction(a)
    },
    initWithAction: function(a) {
        if (!a) throw "cc.ActionEase.initWithAction(): action must be non nil";
        return this.initWithDuration(a.getDuration()) ? (this._inner = a, !0) : !1
    },
    clone: function() {
        var a = new cc.ActionEase;
        a.initWithAction(this._inner.clone());
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._inner.startWithTarget(this.target)
    },
    stop: function() {
        this._inner.stop();
        cc.ActionInterval.prototype.stop.call(this)
    },
    update: function(a) {
        this._inner.update(a)
    },
    reverse: function() {
        return new cc.ActionEase(this._inner.reverse())
    },
    getInnerAction: function() {
        return this._inner
    }
});
cc.actionEase = function(a) {
    return new cc.ActionEase(a)
};
cc.ActionEase.create = cc.actionEase;
cc.EaseRateAction = cc.ActionEase.extend({
    _rate: 0,
    ctor: function(a, b) {
        cc.ActionEase.prototype.ctor.call(this);
        void 0 !== b && this.initWithAction(a, b)
    },
    setRate: function(a) {
        this._rate = a
    },
    getRate: function() {
        return this._rate
    },
    initWithAction: function(a, b) {
        return cc.ActionEase.prototype.initWithAction.call(this, a) ? (this._rate = b, !0) : !1
    },
    clone: function() {
        var a = new cc.EaseRateAction;
        a.initWithAction(this._inner.clone(), this._rate);
        return a
    },
    reverse: function() {
        return new cc.EaseRateAction(this._inner.reverse(),
            1 / this._rate)
    }
});
cc.easeRateAction = function(a, b) {
    return new cc.EaseRateAction(a, b)
};
cc.EaseRateAction.create = cc.easeRateAction;
cc.EaseIn = cc.EaseRateAction.extend({
    update: function(a) {
        this._inner.update(Math.pow(a, this._rate))
    },
    reverse: function() {
        return new cc.EaseIn(this._inner.reverse(), 1 / this._rate)
    },
    clone: function() {
        var a = new cc.EaseIn;
        a.initWithAction(this._inner.clone(), this._rate);
        return a
    }
});
cc.EaseIn.create = function(a, b) {
    return new cc.EaseIn(a, b)
};
cc.easeIn = function(a) {
    return {
        _rate: a,
        easing: function(a) {
            return Math.pow(a, this._rate)
        },
        reverse: function() {
            return cc.easeIn(1 / this._rate)
        }
    }
};
cc.EaseOut = cc.EaseRateAction.extend({
    update: function(a) {
        this._inner.update(Math.pow(a, 1 / this._rate))
    },
    reverse: function() {
        return new cc.EaseOut(this._inner.reverse(), 1 / this._rate)
    },
    clone: function() {
        var a = new cc.EaseOut;
        a.initWithAction(this._inner.clone(), this._rate);
        return a
    }
});
cc.EaseOut.create = function(a, b) {
    return new cc.EaseOut(a, b)
};
cc.easeOut = function(a) {
    return {
        _rate: a,
        easing: function(a) {
            return Math.pow(a, 1 / this._rate)
        },
        reverse: function() {
            return cc.easeOut(1 / this._rate)
        }
    }
};
cc.EaseInOut = cc.EaseRateAction.extend({
    update: function(a) {
        a *= 2;
        1 > a ? this._inner.update(0.5 * Math.pow(a, this._rate)) : this._inner.update(1 - 0.5 * Math.pow(2 - a, this._rate))
    },
    clone: function() {
        var a = new cc.EaseInOut;
        a.initWithAction(this._inner.clone(), this._rate);
        return a
    },
    reverse: function() {
        return new cc.EaseInOut(this._inner.reverse(), this._rate)
    }
});
cc.EaseInOut.create = function(a, b) {
    return new cc.EaseInOut(a, b)
};
cc.easeInOut = function(a) {
    return {
        _rate: a,
        easing: function(a) {
            a *= 2;
            return 1 > a ? 0.5 * Math.pow(a, this._rate) : 1 - 0.5 * Math.pow(2 - a, this._rate)
        },
        reverse: function() {
            return cc.easeInOut(this._rate)
        }
    }
};
cc.EaseExponentialIn = cc.ActionEase.extend({
    update: function(a) {
        this._inner.update(0 === a ? 0 : Math.pow(2, 10 * (a - 1)))
    },
    reverse: function() {
        return new cc.EaseExponentialOut(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseExponentialIn;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseExponentialIn.create = function(a) {
    return new cc.EaseExponentialIn(a)
};
cc._easeExponentialInObj = {
    easing: function(a) {
        return 0 === a ? 0 : Math.pow(2, 10 * (a - 1))
    },
    reverse: function() {
        return cc._easeExponentialOutObj
    }
};
cc.easeExponentialIn = function() {
    return cc._easeExponentialInObj
};
cc.EaseExponentialOut = cc.ActionEase.extend({
    update: function(a) {
        this._inner.update(1 == a ? 1 : -Math.pow(2, -10 * a) + 1)
    },
    reverse: function() {
        return new cc.EaseExponentialIn(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseExponentialOut;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseExponentialOut.create = function(a) {
    return new cc.EaseExponentialOut(a)
};
cc._easeExponentialOutObj = {
    easing: function(a) {
        return 1 == a ? 1 : -Math.pow(2, -10 * a) + 1
    },
    reverse: function() {
        return cc._easeExponentialInObj
    }
};
cc.easeExponentialOut = function() {
    return cc._easeExponentialOutObj
};
cc.EaseExponentialInOut = cc.ActionEase.extend({
    update: function(a) {
        1 != a && 0 !== a && (a *= 2, a = 1 > a ? 0.5 * Math.pow(2, 10 * (a - 1)) : 0.5 * (-Math.pow(2, -10 * (a - 1)) + 2));
        this._inner.update(a)
    },
    reverse: function() {
        return new cc.EaseExponentialInOut(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseExponentialInOut;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseExponentialInOut.create = function(a) {
    return new cc.EaseExponentialInOut(a)
};
cc._easeExponentialInOutObj = {
    easing: function(a) {
        return 1 !== a && 0 !== a ? (a *= 2, 1 > a ? 0.5 * Math.pow(2, 10 * (a - 1)) : 0.5 * (-Math.pow(2, -10 * (a - 1)) + 2)) : a
    },
    reverse: function() {
        return cc._easeExponentialInOutObj
    }
};
cc.easeExponentialInOut = function() {
    return cc._easeExponentialInOutObj
};
cc.EaseSineIn = cc.ActionEase.extend({
    update: function(a) {
        a = 0 === a || 1 === a ? a : -1 * Math.cos(a * Math.PI / 2) + 1;
        this._inner.update(a)
    },
    reverse: function() {
        return new cc.EaseSineOut(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseSineIn;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseSineIn.create = function(a) {
    return new cc.EaseSineIn(a)
};
cc._easeSineInObj = {
    easing: function(a) {
        return 0 === a || 1 === a ? a : -1 * Math.cos(a * Math.PI / 2) + 1
    },
    reverse: function() {
        return cc._easeSineOutObj
    }
};
cc.easeSineIn = function() {
    return cc._easeSineInObj
};
cc.EaseSineOut = cc.ActionEase.extend({
    update: function(a) {
        a = 0 === a || 1 === a ? a : Math.sin(a * Math.PI / 2);
        this._inner.update(a)
    },
    reverse: function() {
        return new cc.EaseSineIn(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseSineOut;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseSineOut.create = function(a) {
    return new cc.EaseSineOut(a)
};
cc._easeSineOutObj = {
    easing: function(a) {
        return 0 === a || 1 == a ? a : Math.sin(a * Math.PI / 2)
    },
    reverse: function() {
        return cc._easeSineInObj
    }
};
cc.easeSineOut = function() {
    return cc._easeSineOutObj
};
cc.EaseSineInOut = cc.ActionEase.extend({
    update: function(a) {
        a = 0 === a || 1 === a ? a : -0.5 * (Math.cos(Math.PI * a) - 1);
        this._inner.update(a)
    },
    clone: function() {
        var a = new cc.EaseSineInOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseSineInOut(this._inner.reverse())
    }
});
cc.EaseSineInOut.create = function(a) {
    return new cc.EaseSineInOut(a)
};
cc._easeSineInOutObj = {
    easing: function(a) {
        return 0 === a || 1 === a ? a : -0.5 * (Math.cos(Math.PI * a) - 1)
    },
    reverse: function() {
        return cc._easeSineInOutObj
    }
};
cc.easeSineInOut = function() {
    return cc._easeSineInOutObj
};
cc.EaseElastic = cc.ActionEase.extend({
    _period: 0.3,
    ctor: function(a, b) {
        cc.ActionEase.prototype.ctor.call(this);
        a && this.initWithAction(a, b)
    },
    getPeriod: function() {
        return this._period
    },
    setPeriod: function(a) {
        this._period = a
    },
    initWithAction: function(a, b) {
        cc.ActionEase.prototype.initWithAction.call(this, a);
        this._period = null == b ? 0.3 : b;
        return !0
    },
    reverse: function() {
        cc.log("cc.EaseElastic.reverse(): it should be overridden in subclass.");
        return null
    },
    clone: function() {
        var a = new cc.EaseElastic;
        a.initWithAction(this._inner.clone(),
            this._period);
        return a
    }
});
cc.EaseElastic.create = function(a, b) {
    return new cc.EaseElastic(a, b)
};
cc.EaseElasticIn = cc.EaseElastic.extend({
    update: function(a) {
        var b = 0;
        0 === a || 1 === a ? b = a : (b = this._period / 4, a -= 1, b = -Math.pow(2, 10 * a) * Math.sin(2 * (a - b) * Math.PI / this._period));
        this._inner.update(b)
    },
    reverse: function() {
        return new cc.EaseElasticOut(this._inner.reverse(), this._period)
    },
    clone: function() {
        var a = new cc.EaseElasticIn;
        a.initWithAction(this._inner.clone(), this._period);
        return a
    }
});
cc.EaseElasticIn.create = function(a, b) {
    return new cc.EaseElasticIn(a, b)
};
cc._easeElasticInObj = {
    easing: function(a) {
        if (0 === a || 1 === a) return a;
        a -= 1;
        return -Math.pow(2, 10 * a) * Math.sin(2 * (a - 0.075) * Math.PI / 0.3)
    },
    reverse: function() {
        return cc._easeElasticOutObj
    }
};
cc.easeElasticIn = function(a) {
    return a && 0.3 !== a ? {
        _period: a,
        easing: function(a) {
            if (0 === a || 1 === a) return a;
            a -= 1;
            return -Math.pow(2, 10 * a) * Math.sin(2 * (a - this._period / 4) * Math.PI / this._period)
        },
        reverse: function() {
            return cc.easeElasticOut(this._period)
        }
    } : cc._easeElasticInObj
};
cc.EaseElasticOut = cc.EaseElastic.extend({
    update: function(a) {
        var b = 0;
        0 === a || 1 == a ? b = a : (b = this._period / 4, b = Math.pow(2, -10 * a) * Math.sin(2 * (a - b) * Math.PI / this._period) + 1);
        this._inner.update(b)
    },
    reverse: function() {
        return new cc.EaseElasticIn(this._inner.reverse(), this._period)
    },
    clone: function() {
        var a = new cc.EaseElasticOut;
        a.initWithAction(this._inner.clone(), this._period);
        return a
    }
});
cc.EaseElasticOut.create = function(a, b) {
    return new cc.EaseElasticOut(a, b)
};
cc._easeElasticOutObj = {
    easing: function(a) {
        return 0 === a || 1 === a ? a : Math.pow(2, -10 * a) * Math.sin(2 * (a - 0.075) * Math.PI / 0.3) + 1
    },
    reverse: function() {
        return cc._easeElasticInObj
    }
};
cc.easeElasticOut = function(a) {
    return a && 0.3 !== a ? {
        _period: a,
        easing: function(a) {
            return 0 === a || 1 === a ? a : Math.pow(2, -10 * a) * Math.sin(2 * (a - this._period / 4) * Math.PI / this._period) + 1
        },
        reverse: function() {
            return cc.easeElasticIn(this._period)
        }
    } : cc._easeElasticOutObj
};
cc.EaseElasticInOut = cc.EaseElastic.extend({
    update: function(a) {
        var b = 0,
            b = this._period;
        if (0 === a || 1 == a) b = a;
        else {
            b || (b = this._period = 0.3 * 1.5);
            var c = b / 4;
            a = 2 * a - 1;
            b = 0 > a ? -0.5 * Math.pow(2, 10 * a) * Math.sin(2 * (a - c) * Math.PI / b) : 0.5 * Math.pow(2, -10 * a) * Math.sin(2 * (a - c) * Math.PI / b) + 1
        }
        this._inner.update(b)
    },
    reverse: function() {
        return new cc.EaseElasticInOut(this._inner.reverse(), this._period)
    },
    clone: function() {
        var a = new cc.EaseElasticInOut;
        a.initWithAction(this._inner.clone(), this._period);
        return a
    }
});
cc.EaseElasticInOut.create = function(a, b) {
    return new cc.EaseElasticInOut(a, b)
};
cc.easeElasticInOut = function(a) {
    return {
        _period: a || 0.3,
        easing: function(a) {
            var c = 0,
                c = this._period;
            if (0 === a || 1 === a) c = a;
            else {
                c || (c = this._period = 0.3 * 1.5);
                var d = c / 4;
                a = 2 * a - 1;
                c = 0 > a ? -0.5 * Math.pow(2, 10 * a) * Math.sin(2 * (a - d) * Math.PI / c) : 0.5 * Math.pow(2, -10 * a) * Math.sin(2 * (a - d) * Math.PI / c) + 1
            }
            return c
        },
        reverse: function() {
            return cc.easeElasticInOut(this._period)
        }
    }
};
cc.EaseBounce = cc.ActionEase.extend({
    bounceTime: function(a) {
        if (a < 1 / 2.75) return 7.5625 * a * a;
        if (a < 2 / 2.75) return a -= 1.5 / 2.75, 7.5625 * a * a + 0.75;
        if (a < 2.5 / 2.75) return a -= 2.25 / 2.75, 7.5625 * a * a + 0.9375;
        a -= 2.625 / 2.75;
        return 7.5625 * a * a + 0.984375
    },
    clone: function() {
        var a = new cc.EaseBounce;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseBounce(this._inner.reverse())
    }
});
cc.EaseBounce.create = function(a) {
    return new cc.EaseBounce(a)
};
cc.EaseBounceIn = cc.EaseBounce.extend({
    update: function(a) {
        a = 1 - this.bounceTime(1 - a);
        this._inner.update(a)
    },
    reverse: function() {
        return new cc.EaseBounceOut(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseBounceIn;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseBounceIn.create = function(a) {
    return new cc.EaseBounceIn(a)
};
cc._bounceTime = function(a) {
    if (a < 1 / 2.75) return 7.5625 * a * a;
    if (a < 2 / 2.75) return a -= 1.5 / 2.75, 7.5625 * a * a + 0.75;
    if (a < 2.5 / 2.75) return a -= 2.25 / 2.75, 7.5625 * a * a + 0.9375;
    a -= 2.625 / 2.75;
    return 7.5625 * a * a + 0.984375
};
cc._easeBounceInObj = {
    easing: function(a) {
        return 1 - cc._bounceTime(1 - a)
    },
    reverse: function() {
        return cc._easeBounceOutObj
    }
};
cc.easeBounceIn = function() {
    return cc._easeBounceInObj
};
cc.EaseBounceOut = cc.EaseBounce.extend({
    update: function(a) {
        a = this.bounceTime(a);
        this._inner.update(a)
    },
    reverse: function() {
        return new cc.EaseBounceIn(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseBounceOut;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseBounceOut.create = function(a) {
    return new cc.EaseBounceOut(a)
};
cc._easeBounceOutObj = {
    easing: function(a) {
        return cc._bounceTime(a)
    },
    reverse: function() {
        return cc._easeBounceInObj
    }
};
cc.easeBounceOut = function() {
    return cc._easeBounceOutObj
};
cc.EaseBounceInOut = cc.EaseBounce.extend({
    update: function(a) {
        var b = 0,
            b = 0.5 > a ? 0.5 * (1 - this.bounceTime(1 - 2 * a)) : 0.5 * this.bounceTime(2 * a - 1) + 0.5;
        this._inner.update(b)
    },
    clone: function() {
        var a = new cc.EaseBounceInOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseBounceInOut(this._inner.reverse())
    }
});
cc.EaseBounceInOut.create = function(a) {
    return new cc.EaseBounceInOut(a)
};
cc._easeBounceInOutObj = {
    easing: function(a) {
        return a = 0.5 > a ? 0.5 * (1 - cc._bounceTime(1 - 2 * a)) : 0.5 * cc._bounceTime(2 * a - 1) + 0.5
    },
    reverse: function() {
        return cc._easeBounceInOutObj
    }
};
cc.easeBounceInOut = function() {
    return cc._easeBounceInOutObj
};
cc.EaseBackIn = cc.ActionEase.extend({
    update: function(a) {
        this._inner.update(0 === a || 1 == a ? a : a * a * (2.70158 * a - 1.70158))
    },
    reverse: function() {
        return new cc.EaseBackOut(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseBackIn;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseBackIn.create = function(a) {
    return new cc.EaseBackIn(a)
};
cc._easeBackInObj = {
    easing: function(a) {
        return 0 === a || 1 === a ? a : a * a * (2.70158 * a - 1.70158)
    },
    reverse: function() {
        return cc._easeBackOutObj
    }
};
cc.easeBackIn = function() {
    return cc._easeBackInObj
};
cc.EaseBackOut = cc.ActionEase.extend({
    update: function(a) {
        a -= 1;
        this._inner.update(a * a * (2.70158 * a + 1.70158) + 1)
    },
    reverse: function() {
        return new cc.EaseBackIn(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseBackOut;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseBackOut.create = function(a) {
    return new cc.EaseBackOut(a)
};
cc._easeBackOutObj = {
    easing: function(a) {
        a -= 1;
        return a * a * (2.70158 * a + 1.70158) + 1
    },
    reverse: function() {
        return cc._easeBackInObj
    }
};
cc.easeBackOut = function() {
    return cc._easeBackOutObj
};
cc.EaseBackInOut = cc.ActionEase.extend({
    update: function(a) {
        a *= 2;
        1 > a ? this._inner.update(a * a * (3.5949095 * a - 2.5949095) / 2) : (a -= 2, this._inner.update(a * a * (3.5949095 * a + 2.5949095) / 2 + 1))
    },
    clone: function() {
        var a = new cc.EaseBackInOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseBackInOut(this._inner.reverse())
    }
});
cc.EaseBackInOut.create = function(a) {
    return new cc.EaseBackInOut(a)
};
cc._easeBackInOutObj = {
    easing: function(a) {
        a *= 2;
        if (1 > a) return a * a * (3.5949095 * a - 2.5949095) / 2;
        a -= 2;
        return a * a * (3.5949095 * a + 2.5949095) / 2 + 1
    },
    reverse: function() {
        return cc._easeBackInOutObj
    }
};
cc.easeBackInOut = function() {
    return cc._easeBackInOutObj
};
cc.EaseBezierAction = cc.ActionEase.extend({
    _p0: null,
    _p1: null,
    _p2: null,
    _p3: null,
    ctor: function(a) {
        cc.ActionEase.prototype.ctor.call(this, a)
    },
    _updateTime: function(a, b, c, d, e) {
        return Math.pow(1 - e, 3) * a + 3 * e * Math.pow(1 - e, 2) * b + 3 * Math.pow(e, 2) * (1 - e) * c + Math.pow(e, 3) * d
    },
    update: function(a) {
        a = this._updateTime(this._p0, this._p1, this._p2, this._p3, a);
        this._inner.update(a)
    },
    clone: function() {
        var a = new cc.EaseBezierAction;
        a.initWithAction(this._inner.clone());
        a.setBezierParamer(this._p0, this._p1, this._p2, this._p3);
        return a
    },
    reverse: function() {
        var a = new cc.EaseBezierAction(this._inner.reverse());
        a.setBezierParamer(this._p3, this._p2, this._p1, this._p0);
        return a
    },
    setBezierParamer: function(a, b, c, d) {
        this._p0 = a || 0;
        this._p1 = b || 0;
        this._p2 = c || 0;
        this._p3 = d || 0
    }
});
cc.EaseBezierAction.create = function(a) {
    return new cc.EaseBezierAction(a)
};
cc.easeBezierAction = function(a, b, c, d) {
    return {
        easing: function(e) {
            return cc.EaseBezierAction.prototype._updateTime(a, b, c, d, e)
        },
        reverse: function() {
            return cc.easeBezierAction(d, c, b, a)
        }
    }
};
cc.EaseQuadraticActionIn = cc.ActionEase.extend({
    _updateTime: function(a) {
        return Math.pow(a, 2)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuadraticActionIn;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseQuadraticActionIn(this._inner.reverse())
    }
});
cc.EaseQuadraticActionIn.create = function(a) {
    return new cc.EaseQuadraticActionIn(a)
};
cc._easeQuadraticActionIn = {
    easing: cc.EaseQuadraticActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeQuadraticActionIn
    }
};
cc.easeQuadraticActionIn = function() {
    return cc._easeQuadraticActionIn
};
cc.EaseQuadraticActionOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        return -a * (a - 2)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuadraticActionOut;
        a.initWithAction();
        return a
    },
    reverse: function() {
        return new cc.EaseQuadraticActionOut(this._inner.reverse())
    }
});
cc.EaseQuadraticActionOut.create = function(a) {
    return new cc.EaseQuadraticActionOut(a)
};
cc._easeQuadraticActionOut = {
    easing: cc.EaseQuadraticActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuadraticActionOut
    }
};
cc.easeQuadraticActionOut = function() {
    return cc._easeQuadraticActionOut
};
cc.EaseQuadraticActionInOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        var b = a;
        a *= 2;
        1 > a ? b = 0.5 * a * a : (--a, b = -0.5 * (a * (a - 2) - 1));
        return b
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuadraticActionInOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseQuadraticActionInOut(this._inner.reverse())
    }
});
cc.EaseQuadraticActionInOut.create = function(a) {
    return new cc.EaseQuadraticActionInOut(a)
};
cc._easeQuadraticActionInOut = {
    easing: cc.EaseQuadraticActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuadraticActionInOut
    }
};
cc.easeQuadraticActionInOut = function() {
    return cc._easeQuadraticActionInOut
};
cc.EaseQuarticActionIn = cc.ActionEase.extend({
    _updateTime: function(a) {
        return a * a * a * a
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuarticActionIn;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseQuarticActionIn(this._inner.reverse())
    }
});
cc.EaseQuarticActionIn.create = function(a) {
    return new cc.EaseQuarticActionIn(a)
};
cc._easeQuarticActionIn = {
    easing: cc.EaseQuarticActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeQuarticActionIn
    }
};
cc.easeQuarticActionIn = function() {
    return cc._easeQuarticActionIn
};
cc.EaseQuarticActionOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        a -= 1;
        return -(a * a * a * a - 1)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuarticActionOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseQuarticActionOut(this._inner.reverse())
    }
});
cc.EaseQuarticActionOut.create = function(a) {
    return new cc.EaseQuarticActionOut(a)
};
cc._easeQuarticActionOut = {
    easing: cc.EaseQuarticActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuarticActionOut
    }
};
cc.easeQuarticActionOut = function() {
    return cc._easeQuarticActionOut
};
cc.EaseQuarticActionInOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        a *= 2;
        if (1 > a) return 0.5 * a * a * a * a;
        a -= 2;
        return -0.5 * (a * a * a * a - 2)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuarticActionInOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseQuarticActionInOut(this._inner.reverse())
    }
});
cc.EaseQuarticActionInOut.create = function(a) {
    return new cc.EaseQuarticActionInOut(a)
};
cc._easeQuarticActionInOut = {
    easing: cc.EaseQuarticActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuarticActionInOut
    }
};
cc.easeQuarticActionInOut = function() {
    return cc._easeQuarticActionInOut
};
cc.EaseQuinticActionIn = cc.ActionEase.extend({
    _updateTime: function(a) {
        return a * a * a * a * a
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuinticActionIn;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseQuinticActionIn(this._inner.reverse())
    }
});
cc.EaseQuinticActionIn.create = function(a) {
    return new cc.EaseQuinticActionIn(a)
};
cc._easeQuinticActionIn = {
    easing: cc.EaseQuinticActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeQuinticActionIn
    }
};
cc.easeQuinticActionIn = function() {
    return cc._easeQuinticActionIn
};
cc.EaseQuinticActionOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        a -= 1;
        return a * a * a * a * a + 1
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuinticActionOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseQuinticActionOut(this._inner.reverse())
    }
});
cc.EaseQuinticActionOut.create = function(a) {
    return new cc.EaseQuinticActionOut(a)
};
cc._easeQuinticActionOut = {
    easing: cc.EaseQuinticActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuinticActionOut
    }
};
cc.easeQuinticActionOut = function() {
    return cc._easeQuinticActionOut
};
cc.EaseQuinticActionInOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        a *= 2;
        if (1 > a) return 0.5 * a * a * a * a * a;
        a -= 2;
        return 0.5 * (a * a * a * a * a + 2)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuinticActionInOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseQuinticActionInOut(this._inner.reverse())
    }
});
cc.EaseQuinticActionInOut.create = function(a) {
    return new cc.EaseQuinticActionInOut(a)
};
cc._easeQuinticActionInOut = {
    easing: cc.EaseQuinticActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuinticActionInOut
    }
};
cc.easeQuinticActionInOut = function() {
    return cc._easeQuinticActionInOut
};
cc.EaseCircleActionIn = cc.ActionEase.extend({
    _updateTime: function(a) {
        return -1 * (Math.sqrt(1 - a * a) - 1)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseCircleActionIn;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseCircleActionIn(this._inner.reverse())
    }
});
cc.EaseCircleActionIn.create = function(a) {
    return new cc.EaseCircleActionIn(a)
};
cc._easeCircleActionIn = {
    easing: cc.EaseCircleActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeCircleActionIn
    }
};
cc.easeCircleActionIn = function() {
    return cc._easeCircleActionIn
};
cc.EaseCircleActionOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        a -= 1;
        return Math.sqrt(1 - a * a)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseCircleActionOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseCircleActionOut(this._inner.reverse())
    }
});
cc.EaseCircleActionOut.create = function(a) {
    return new cc.EaseCircleActionOut(a)
};
cc._easeCircleActionOut = {
    easing: cc.EaseCircleActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeCircleActionOut
    }
};
cc.easeCircleActionOut = function() {
    return cc._easeCircleActionOut
};
cc.EaseCircleActionInOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        a *= 2;
        if (1 > a) return -0.5 * (Math.sqrt(1 - a * a) - 1);
        a -= 2;
        return 0.5 * (Math.sqrt(1 - a * a) + 1)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseCircleActionInOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseCircleActionInOut(this._inner.reverse())
    }
});
cc.EaseCircleActionInOut.create = function(a) {
    return new cc.EaseCircleActionInOut(a)
};
cc._easeCircleActionInOut = {
    easing: cc.EaseCircleActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeCircleActionInOut
    }
};
cc.easeCircleActionInOut = function() {
    return cc._easeCircleActionInOut
};
cc.EaseCubicActionIn = cc.ActionEase.extend({
    _updateTime: function(a) {
        return a * a * a
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseCubicActionIn;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseCubicActionIn(this._inner.reverse())
    }
});
cc.EaseCubicActionIn.create = function(a) {
    return new cc.EaseCubicActionIn(a)
};
cc._easeCubicActionIn = {
    easing: cc.EaseCubicActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeCubicActionIn
    }
};
cc.easeCubicActionIn = function() {
    return cc._easeCubicActionIn
};
cc.EaseCubicActionOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        a -= 1;
        return a * a * a + 1
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseCubicActionOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseCubicActionOut(this._inner.reverse())
    }
});
cc.EaseCubicActionOut.create = function(a) {
    return new cc.EaseCubicActionOut(a)
};
cc._easeCubicActionOut = {
    easing: cc.EaseCubicActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeCubicActionOut
    }
};
cc.easeCubicActionOut = function() {
    return cc._easeCubicActionOut
};
cc.EaseCubicActionInOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        a *= 2;
        if (1 > a) return 0.5 * a * a * a;
        a -= 2;
        return 0.5 * (a * a * a + 2)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseCubicActionInOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseCubicActionInOut(this._inner.reverse())
    }
});
cc.EaseCubicActionInOut.create = function(a) {
    return new cc.EaseCubicActionInOut(a)
};
cc._easeCubicActionInOut = {
    easing: cc.EaseCubicActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeCubicActionInOut
    }
};
cc.easeCubicActionInOut = function() {
    return cc._easeCubicActionInOut
};
cc.cardinalSplineAt = function(a, b, c, d, e, f) {
    var g = f * f,
        h = g * f,
        k = (1 - e) / 2;
    e = k * (-h + 2 * g - f);
    var m = k * (-h + g) + (2 * h - 3 * g + 1);
    f = k * (h - 2 * g + f) + (-2 * h + 3 * g);
    g = k * (h - g);
    return cc.p(a.x * e + b.x * m + c.x * f + d.x * g, a.y * e + b.y * m + c.y * f + d.y * g)
};
cc.reverseControlPoints = function(a) {
    for (var b = [], c = a.length - 1; 0 <= c; c--) b.push(cc.p(a[c].x, a[c].y));
    return b
};
cc.cloneControlPoints = function(a) {
    for (var b = [], c = 0; c < a.length; c++) b.push(cc.p(a[c].x, a[c].y));
    return b
};
cc.copyControlPoints = cc.cloneControlPoints;
cc.getControlPointAt = function(a, b) {
    var c = Math.min(a.length - 1, Math.max(b, 0));
    return a[c]
};
cc.reverseControlPointsInline = function(a) {
    for (var b = a.length, c = 0 | b / 2, d = 0; d < c; ++d) {
        var e = a[d];
        a[d] = a[b - d - 1];
        a[b - d - 1] = e
    }
};
cc.CardinalSplineTo = cc.ActionInterval.extend({
    _points: null,
    _deltaT: 0,
    _tension: 0,
    _previousPosition: null,
    _accumulatedDiff: null,
    ctor: function(a, b, c) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._points = [];
        void 0 !== c && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        if (!b || 0 == b.length) throw "Invalid configuration. It must at least have one control point";
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this.setPoints(b), this._tension = c, !0) : !1
    },
    clone: function() {
        var a =
            new cc.CardinalSplineTo;
        a.initWithDuration(this._duration, cc.copyControlPoints(this._points), this._tension);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._deltaT = 1 / (this._points.length - 1);
        this._previousPosition = cc.p(this.target.getPositionX(), this.target.getPositionY());
        this._accumulatedDiff = cc.p(0, 0)
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        var b, c = this._points;
        if (1 == a) b = c.length - 1, a = 1;
        else {
            var d = this._deltaT;
            b = 0 | a / d;
            a = (a - d * b) / d
        }
        b = cc.cardinalSplineAt(cc.getControlPointAt(c,
            b - 1), cc.getControlPointAt(c, b - 0), cc.getControlPointAt(c, b + 1), cc.getControlPointAt(c, b + 2), this._tension, a);
        if (cc.ENABLE_STACKABLE_ACTIONS && (c = this.target.getPositionX() - this._previousPosition.x, a = this.target.getPositionY() - this._previousPosition.y, 0 != c || 0 != a)) d = this._accumulatedDiff, c = d.x + c, a = d.y + a, d.x = c, d.y = a, b.x += c, b.y += a;
        this.updatePosition(b)
    },
    reverse: function() {
        var a = cc.reverseControlPoints(this._points);
        return cc.cardinalSplineTo(this._duration, a, this._tension)
    },
    updatePosition: function(a) {
        this.target.setPosition(a);
        this._previousPosition = a
    },
    getPoints: function() {
        return this._points
    },
    setPoints: function(a) {
        this._points = a
    }
});
cc.cardinalSplineTo = function(a, b, c) {
    return new cc.CardinalSplineTo(a, b, c)
};
cc.CardinalSplineTo.create = cc.cardinalSplineTo;
cc.CardinalSplineBy = cc.CardinalSplineTo.extend({
    _startPosition: null,
    ctor: function(a, b, c) {
        cc.CardinalSplineTo.prototype.ctor.call(this);
        this._startPosition = cc.p(0, 0);
        void 0 !== c && this.initWithDuration(a, b, c)
    },
    startWithTarget: function(a) {
        cc.CardinalSplineTo.prototype.startWithTarget.call(this, a);
        this._startPosition.x = a.getPositionX();
        this._startPosition.y = a.getPositionY()
    },
    reverse: function() {
        for (var a = this._points.slice(), b, c = a[0], d = 1; d < a.length; ++d) b = a[d], a[d] = cc.pSub(b, c), c = b;
        a = cc.reverseControlPoints(a);
        c = a[a.length - 1];
        a.pop();
        c.x = -c.x;
        c.y = -c.y;
        a.unshift(c);
        for (d = 1; d < a.length; ++d) b = a[d], b.x = -b.x, b.y = -b.y, b.x += c.x, b.y += c.y, c = a[d] = b;
        return cc.cardinalSplineBy(this._duration, a, this._tension)
    },
    updatePosition: function(a) {
        var b = this._startPosition,
            c = a.x + b.x;
        a = a.y + b.y;
        this._previousPosition.x = c;
        this._previousPosition.y = a;
        this.target.setPosition(c, a)
    },
    clone: function() {
        var a = new cc.CardinalSplineBy;
        a.initWithDuration(this._duration, cc.copyControlPoints(this._points), this._tension);
        return a
    }
});
cc.cardinalSplineBy = function(a, b, c) {
    return new cc.CardinalSplineBy(a, b, c)
};
cc.CardinalSplineBy.create = cc.cardinalSplineBy;
cc.CatmullRomTo = cc.CardinalSplineTo.extend({
    ctor: function(a, b) {
        b && this.initWithDuration(a, b)
    },
    initWithDuration: function(a, b) {
        return cc.CardinalSplineTo.prototype.initWithDuration.call(this, a, b, 0.5)
    },
    clone: function() {
        var a = new cc.CatmullRomTo;
        a.initWithDuration(this._duration, cc.copyControlPoints(this._points));
        return a
    }
});
cc.catmullRomTo = function(a, b) {
    return new cc.CatmullRomTo(a, b)
};
cc.CatmullRomTo.create = cc.catmullRomTo;
cc.CatmullRomBy = cc.CardinalSplineBy.extend({
    ctor: function(a, b) {
        cc.CardinalSplineBy.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    initWithDuration: function(a, b) {
        return cc.CardinalSplineTo.prototype.initWithDuration.call(this, a, b, 0.5)
    },
    clone: function() {
        var a = new cc.CatmullRomBy;
        a.initWithDuration(this._duration, cc.copyControlPoints(this._points));
        return a
    }
});
cc.catmullRomBy = function(a, b) {
    return new cc.CatmullRomBy(a, b)
};
cc.CatmullRomBy.create = cc.catmullRomBy;
cc.ActionTweenDelegate = cc.Class.extend({
    updateTweenAction: function(a, b) {}
});
cc.ActionTween = cc.ActionInterval.extend({
    key: "",
    from: 0,
    to: 0,
    delta: 0,
    ctor: function(a, b, c, d) {
        cc.ActionInterval.prototype.ctor.call(this);
        this.key = "";
        void 0 !== d && this.initWithDuration(a, b, c, d)
    },
    initWithDuration: function(a, b, c, d) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this.key = b, this.to = d, this.from = c, !0) : !1
    },
    startWithTarget: function(a) {
        if (!a || !a.updateTweenAction) throw "cc.ActionTween.startWithTarget(): target must be non-null, and target must implement updateTweenAction function";
        cc.ActionInterval.prototype.startWithTarget.call(this,
            a);
        this.delta = this.to - this.from
    },
    update: function(a) {
        this.target.updateTweenAction(this.to - this.delta * (1 - a), this.key)
    },
    reverse: function() {
        return new cc.ActionTween(this.duration, this.key, this.to, this.from)
    },
    clone: function() {
        var a = new cc.ActionTween;
        a.initWithDuration(this._duration, this.key, this.from, this.to);
        return a
    }
});
cc.actionTween = function(a, b, c, d) {
    return new cc.ActionTween(a, b, c, d)
};
cc.ActionTween.create = cc.actionTween;
cc._globalFontSize = cc.ITEM_SIZE;
cc._globalFontName = "Arial";
cc._globalFontNameRelease = !1;
cc.MenuItem = cc.Node.extend({
    _enabled: !1,
    _target: null,
    _callback: null,
    _isSelected: !1,
    _className: "MenuItem",
    ctor: function(a, b) {
        var c = cc.Node.prototype;
        c.ctor.call(this);
        this._callback = this._target = null;
        this._enabled = this._isSelected = !1;
        c.setAnchorPoint.call(this, 0.5, 0.5);
        this._target = b || null;
        if (this._callback = a || null) this._enabled = !0
    },
    isSelected: function() {
        return this._isSelected
    },
    setOpacityModifyRGB: function(a) {},
    isOpacityModifyRGB: function() {
        return !1
    },
    setTarget: function(a, b) {
        this._target = b;
        this._callback =
            a
    },
    isEnabled: function() {
        return this._enabled
    },
    setEnabled: function(a) {
        this._enabled = a
    },
    initWithCallback: function(a, b) {
        this.anchorY = this.anchorX = 0.5;
        this._target = b;
        this._callback = a;
        this._enabled = !0;
        this._isSelected = !1;
        return !0
    },
    rect: function() {
        var a = this._position,
            b = this._contentSize,
            c = this._anchorPoint;
        return cc.rect(a.x - b.width * c.x, a.y - b.height * c.y, b.width, b.height)
    },
    selected: function() {
        this._isSelected = !0
    },
    unselected: function() {
        this._isSelected = !1
    },
    setCallback: function(a, b) {
        this._target = b;
        this._callback =
            a
    },
    activate: function() {
        if (this._enabled) {
            var a = this._target,
                b = this._callback;
            if (b)
                if (a && cc.isString(b)) a[b](this);
                else a && cc.isFunction(b) ? b.call(a, this) : b(this)
        }
    }
});
_p = cc.MenuItem.prototype;
cc.defineGetterSetter(_p, "enabled", _p.isEnabled, _p.setEnabled);
cc.MenuItem.create = function(a, b) {
    return new cc.MenuItem(a, b)
};
cc.MenuItemLabel = cc.MenuItem.extend({
    _disabledColor: null,
    _label: null,
    _orginalScale: 0,
    _colorBackup: null,
    ctor: function(a, b, c) {
        cc.MenuItem.prototype.ctor.call(this, b, c);
        this._label = this._disabledColor = null;
        this._orginalScale = 0;
        this._colorBackup = null;
        a && (this._originalScale = 1, this._colorBackup = cc.color.WHITE, this._disabledColor = cc.color(126, 126, 126), this.setLabel(a), this.cascadeOpacity = this.cascadeColor = !0)
    },
    getDisabledColor: function() {
        return this._disabledColor
    },
    setDisabledColor: function(a) {
        this._disabledColor =
            a
    },
    getLabel: function() {
        return this._label
    },
    setLabel: function(a) {
        a && (this.addChild(a), a.anchorX = 0, a.anchorY = 0, this.width = a.width, this.height = a.height);
        this._label && this.removeChild(this._label, !0);
        this._label = a
    },
    setEnabled: function(a) {
        if (this._enabled != a) {
            var b = this._label;
            a ? b.color = this._colorBackup : (this._colorBackup = b.color, b.color = this._disabledColor)
        }
        cc.MenuItem.prototype.setEnabled.call(this, a)
    },
    setOpacity: function(a) {
        this._label.opacity = a
    },
    getOpacity: function() {
        return this._label.opacity
    },
    setColor: function(a) {
        this._label.color =
            a
    },
    getColor: function() {
        return this._label.color
    },
    initWithLabel: function(a, b, c) {
        this.initWithCallback(b, c);
        this._originalScale = 1;
        this._colorBackup = cc.color.WHITE;
        this._disabledColor = cc.color(126, 126, 126);
        this.setLabel(a);
        return this.cascadeOpacity = this.cascadeColor = !0
    },
    setString: function(a) {
        this._label.string = a;
        this.width = this._label.width;
        this.height = this._label.height
    },
    getString: function() {
        return this._label.string
    },
    activate: function() {
        this._enabled && (this.stopAllActions(), this.scale = this._originalScale,
            cc.MenuItem.prototype.activate.call(this))
    },
    selected: function() {
        if (this._enabled) {
            cc.MenuItem.prototype.selected.call(this);
            var a = this.getActionByTag(cc.ZOOM_ACTION_TAG);
            a ? this.stopAction(a) : this._originalScale = this.scale;
            a = cc.scaleTo(0.1, 1.2 * this._originalScale);
            a.setTag(cc.ZOOM_ACTION_TAG);
            this.runAction(a)
        }
    },
    unselected: function() {
        if (this._enabled) {
            cc.MenuItem.prototype.unselected.call(this);
            this.stopActionByTag(cc.ZOOM_ACTION_TAG);
            var a = cc.scaleTo(0.1, this._originalScale);
            a.setTag(cc.ZOOM_ACTION_TAG);
            this.runAction(a)
        }
    }
});
_p = cc.MenuItemLabel.prototype;
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
cc.defineGetterSetter(_p, "disabledColor", _p.getDisabledColor, _p.setDisabledColor);
cc.defineGetterSetter(_p, "label", _p.getLabel, _p.setLabel);
cc.MenuItemLabel.create = function(a, b, c) {
    return new cc.MenuItemLabel(a, b, c)
};
cc.MenuItemAtlasFont = cc.MenuItemLabel.extend({
    ctor: function(a, b, c, d, e, f, g) {
        var h;
        a && 0 < a.length && (h = new cc.LabelAtlas(a, b, c, d, e));
        cc.MenuItemLabel.prototype.ctor.call(this, h, f, g)
    },
    initWithString: function(a, b, c, d, e, f, g) {
        if (!a || 0 == a.length) throw "cc.MenuItemAtlasFont.initWithString(): value should be non-null and its length should be greater than 0";
        var h = new cc.LabelAtlas;
        h.initWithString(a, b, c, d, e);
        this.initWithLabel(h, f, g);
        return !0
    }
});
cc.MenuItemAtlasFont.create = function(a, b, c, d, e, f, g) {
    return new cc.MenuItemAtlasFont(a, b, c, d, e, f, g)
};
cc.MenuItemFont = cc.MenuItemLabel.extend({
    _fontSize: null,
    _fontName: null,
    ctor: function(a, b, c) {
        var d;
        a && 0 < a.length ? (this._fontName = cc._globalFontName, this._fontSize = cc._globalFontSize, d = new cc.LabelTTF(a, this._fontName, this._fontSize)) : (this._fontSize = 0, this._fontName = "");
        cc.MenuItemLabel.prototype.ctor.call(this, d, b, c)
    },
    initWithString: function(a, b, c) {
        if (!a || 0 == a.length) throw "Value should be non-null and its length should be greater than 0";
        this._fontName = cc._globalFontName;
        this._fontSize = cc._globalFontSize;
        a = new cc.LabelTTF(a, this._fontName, this._fontSize);
        this.initWithLabel(a, b, c);
        return !0
    },
    setFontSize: function(a) {
        this._fontSize = a;
        this._recreateLabel()
    },
    getFontSize: function() {
        return this._fontSize
    },
    setFontName: function(a) {
        this._fontName = a;
        this._recreateLabel()
    },
    getFontName: function() {
        return this._fontName
    },
    _recreateLabel: function() {
        var a = new cc.LabelTTF(this._label.string, this._fontName, this._fontSize);
        this.setLabel(a)
    }
});
cc.MenuItemFont.setFontSize = function(a) {
    cc._globalFontSize = a
};
cc.MenuItemFont.fontSize = function() {
    return cc._globalFontSize
};
cc.MenuItemFont.setFontName = function(a) {
    cc._globalFontNameRelease && (cc._globalFontName = "");
    cc._globalFontName = a;
    cc._globalFontNameRelease = !0
};
_p = cc.MenuItemFont.prototype;
cc.defineGetterSetter(_p, "fontSize", _p.getFontSize, _p.setFontSize);
cc.defineGetterSetter(_p, "fontName", _p.getFontName, _p.setFontName);
cc.MenuItemFont.fontName = function() {
    return cc._globalFontName
};
cc.MenuItemFont.create = function(a, b, c) {
    return new cc.MenuItemFont(a, b, c)
};
cc.MenuItemSprite = cc.MenuItem.extend({
    _normalImage: null,
    _selectedImage: null,
    _disabledImage: null,
    ctor: function(a, b, c, d, e) {
        cc.MenuItem.prototype.ctor.call(this);
        this._disabledImage = this._selectedImage = this._normalImage = null;
        if (void 0 !== b) {
            var f, g, h;
            void 0 !== e ? (f = c, h = d, g = e) : void 0 !== d && cc.isFunction(d) ? (f = c, h = d) : void 0 !== d && cc.isFunction(c) ? (g = d, h = c, f = new cc.Sprite(b)) : void 0 === c && (f = new cc.Sprite(b));
            this.initWithNormalSprite(a, b, f, h, g)
        }
    },
    getNormalImage: function() {
        return this._normalImage
    },
    setNormalImage: function(a) {
        this._normalImage !=
            a && (a && (this.addChild(a, 0, cc.NORMAL_TAG), a.anchorX = 0, a.anchorY = 0), this._normalImage && this.removeChild(this._normalImage, !0), this._normalImage = a, this.width = this._normalImage.width, this.height = this._normalImage.height, this._updateImagesVisibility(), a.textureLoaded && !a.textureLoaded() && a.addEventListener("load", function(a) {
                this.width = a.width;
                this.height = a.height
            }, this))
    },
    getSelectedImage: function() {
        return this._selectedImage
    },
    setSelectedImage: function(a) {
        this._selectedImage != a && (a && (this.addChild(a,
            0, cc.SELECTED_TAG), a.anchorX = 0, a.anchorY = 0), this._selectedImage && this.removeChild(this._selectedImage, !0), this._selectedImage = a, this._updateImagesVisibility())
    },
    getDisabledImage: function() {
        return this._disabledImage
    },
    setDisabledImage: function(a) {
        this._disabledImage != a && (a && (this.addChild(a, 0, cc.DISABLE_TAG), a.anchorX = 0, a.anchorY = 0), this._disabledImage && this.removeChild(this._disabledImage, !0), this._disabledImage = a, this._updateImagesVisibility())
    },
    initWithNormalSprite: function(a, b, c, d, e) {
        this.initWithCallback(d,
            e);
        this.setNormalImage(a);
        this.setSelectedImage(b);
        this.setDisabledImage(c);
        if (a = this._normalImage) this.width = a.width, this.height = a.height, a.textureLoaded && !a.textureLoaded() && a.addEventListener("load", function(a) {
            this.width = a.width;
            this.height = a.height;
            this.cascadeOpacity = this.cascadeColor = !0
        }, this);
        return this.cascadeOpacity = this.cascadeColor = !0
    },
    setColor: function(a) {
        this._normalImage.color = a;
        this._selectedImage && (this._selectedImage.color = a);
        this._disabledImage && (this._disabledImage.color = a)
    },
    getColor: function() {
        return this._normalImage.color
    },
    setOpacity: function(a) {
        this._normalImage.opacity = a;
        this._selectedImage && (this._selectedImage.opacity = a);
        this._disabledImage && (this._disabledImage.opacity = a)
    },
    getOpacity: function() {
        return this._normalImage.opacity
    },
    selected: function() {
        cc.MenuItem.prototype.selected.call(this);
        this._normalImage && (this._disabledImage && (this._disabledImage.visible = !1), this._selectedImage ? (this._normalImage.visible = !1, this._selectedImage.visible = !0) : this._normalImage.visible = !0)
    },
    unselected: function() {
        cc.MenuItem.prototype.unselected.call(this);
        this._normalImage && (this._normalImage.visible = !0, this._selectedImage && (this._selectedImage.visible = !1), this._disabledImage && (this._disabledImage.visible = !1))
    },
    setEnabled: function(a) {
        this._enabled != a && (cc.MenuItem.prototype.setEnabled.call(this, a), this._updateImagesVisibility())
    },
    _updateImagesVisibility: function() {
        var a = this._normalImage,
            b = this._selectedImage,
            c = this._disabledImage;
        this._enabled ? (a && (a.visible = !0), b && (b.visible = !1), c && (c.visible = !1)) : c ? (a && (a.visible = !1), b && (b.visible = !1), c && (c.visible = !0)) : (a && (a.visible = !0), b && (b.visible = !1))
    }
});
_p = cc.MenuItemSprite.prototype;
cc.defineGetterSetter(_p, "normalImage", _p.getNormalImage, _p.setNormalImage);
cc.defineGetterSetter(_p, "selectedImage", _p.getSelectedImage, _p.setSelectedImage);
cc.defineGetterSetter(_p, "disabledImage", _p.getDisabledImage, _p.setDisabledImage);
cc.MenuItemSprite.create = function(a, b, c, d, e) {
    return new cc.MenuItemSprite(a, b, c, d, e || void 0)
};
cc.MenuItemImage = cc.MenuItemSprite.extend({
    ctor: function(a, b, c, d, e) {
        var f = null,
            g = null,
            h = null,
            k = null,
            m = null;
        void 0 === a ? cc.MenuItemSprite.prototype.ctor.call(this) : (f = new cc.Sprite(a), b && (g = new cc.Sprite(b)), void 0 === d ? k = c : void 0 === e ? (k = c, m = d) : e && (h = new cc.Sprite(c), k = d, m = e), cc.MenuItemSprite.prototype.ctor.call(this, f, g, h, k, m))
    },
    setNormalSpriteFrame: function(a) {
        this.setNormalImage(new cc.Sprite(a))
    },
    setSelectedSpriteFrame: function(a) {
        this.setSelectedImage(new cc.Sprite(a))
    },
    setDisabledSpriteFrame: function(a) {
        this.setDisabledImage(new cc.Sprite(a))
    },
    initWithNormalImage: function(a, b, c, d, e) {
        var f = null,
            g = null,
            h = null;
        a && (f = new cc.Sprite(a));
        b && (g = new cc.Sprite(b));
        c && (h = new cc.Sprite(c));
        return this.initWithNormalSprite(f, g, h, d, e)
    }
});
cc.MenuItemImage.create = function(a, b, c, d, e) {
    return new cc.MenuItemImage(a, b, c, d, e)
};
cc.MenuItemToggle = cc.MenuItem.extend({
    subItems: null,
    _selectedIndex: 0,
    _opacity: null,
    _color: null,
    ctor: function() {
        cc.MenuItem.prototype.ctor.call(this);
        this._selectedIndex = 0;
        this.subItems = [];
        this._opacity = 0;
        this._color = cc.color.WHITE;
        0 < arguments.length && this.initWithItems(Array.prototype.slice.apply(arguments))
    },
    getOpacity: function() {
        return this._opacity
    },
    setOpacity: function(a) {
        this._opacity = a;
        if (this.subItems && 0 < this.subItems.length)
            for (var b = 0; b < this.subItems.length; b++) this.subItems[b].opacity = a;
        this._color.a = a
    },
    getColor: function() {
        var a = this._color;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    setColor: function(a) {
        var b = this._color;
        b.r = a.r;
        b.g = a.g;
        b.b = a.b;
        if (this.subItems && 0 < this.subItems.length)
            for (b = 0; b < this.subItems.length; b++) this.subItems[b].setColor(a);
        void 0 !== a.a && !a.a_undefined && this.setOpacity(a.a)
    },
    getSelectedIndex: function() {
        return this._selectedIndex
    },
    setSelectedIndex: function(a) {
        if (a != this._selectedIndex) {
            this._selectedIndex = a;
            (a = this.getChildByTag(cc.CURRENT_ITEM)) && a.removeFromParent(!1);
            a = this.subItems[this._selectedIndex];
            this.addChild(a, 0, cc.CURRENT_ITEM);
            var b = a.width,
                c = a.height;
            this.width = b;
            this.height = c;
            a.setPosition(b / 2, c / 2)
        }
    },
    getSubItems: function() {
        return this.subItems
    },
    setSubItems: function(a) {
        this.subItems = a
    },
    initWithItems: function(a) {
        var b = a.length;
        cc.isFunction(a[a.length - 2]) ? (this.initWithCallback(a[a.length - 2], a[a.length - 1]), b -= 2) : cc.isFunction(a[a.length - 1]) ? (this.initWithCallback(a[a.length - 1], null), b -= 1) : this.initWithCallback(null, null);
        for (var c = this.subItems, d = c.length =
            0; d < b; d++) a[d] && c.push(a[d]);
        this._selectedIndex = cc.UINT_MAX;
        this.setSelectedIndex(0);
        return this.cascadeOpacity = this.cascadeColor = !0
    },
    addSubItem: function(a) {
        this.subItems.push(a)
    },
    activate: function() {
        this._enabled && this.setSelectedIndex((this._selectedIndex + 1) % this.subItems.length);
        cc.MenuItem.prototype.activate.call(this)
    },
    selected: function() {
        cc.MenuItem.prototype.selected.call(this);
        this.subItems[this._selectedIndex].selected()
    },
    unselected: function() {
        cc.MenuItem.prototype.unselected.call(this);
        this.subItems[this._selectedIndex].unselected()
    },
    setEnabled: function(a) {
        if (this._enabled != a) {
            cc.MenuItem.prototype.setEnabled.call(this, a);
            var b = this.subItems;
            if (b && 0 < b.length)
                for (var c = 0; c < b.length; c++) b[c].enabled = a
        }
    },
    selectedItem: function() {
        return this.subItems[this._selectedIndex]
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this);
        this.setSelectedIndex(this._selectedIndex)
    }
});
_p = cc.MenuItemToggle.prototype;
cc.defineGetterSetter(_p, "selectedIndex", _p.getSelectedIndex, _p.setSelectedIndex);
cc.MenuItemToggle.create = function() {
    0 < arguments.length && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
    var a = new cc.MenuItemToggle;
    a.initWithItems(Array.prototype.slice.apply(arguments));
    return a
};
cc.MENU_STATE_WAITING = 0;
cc.MENU_STATE_TRACKING_TOUCH = 1;
cc.MENU_HANDLER_PRIORITY = -128;
cc.DEFAULT_PADDING = 5;
cc.Menu = cc.Layer.extend({
    enabled: !1,
    _selectedItem: null,
    _state: -1,
    _touchListener: null,
    _className: "Menu",
    ctor: function(a) {
        cc.Layer.prototype.ctor.call(this);
        this._color = cc.color.WHITE;
        this.enabled = !1;
        this._opacity = 255;
        this._selectedItem = null;
        this._state = -1;
        this._touchListener = cc.EventListener.create({
            event: cc.EventListener.TOUCH_ONE_BY_ONE,
            swallowTouches: !0,
            onTouchBegan: this._onTouchBegan,
            onTouchMoved: this._onTouchMoved,
            onTouchEnded: this._onTouchEnded,
            onTouchCancelled: this._onTouchCancelled
        });
        0 < arguments.length &&
            null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
        var b = arguments.length,
            c;
        if (0 == b) c = [];
        else if (1 == b) c = a instanceof Array ? a : [a];
        else if (1 < b) {
            c = [];
            for (var d = 0; d < b; d++) arguments[d] && c.push(arguments[d])
        }
        this.initWithArray(c)
    },
    onEnter: function() {
        var a = this._touchListener;
        a._isRegistered() || cc.eventManager.addListener(a, this);
        cc.Node.prototype.onEnter.call(this)
    },
    isEnabled: function() {
        return this.enabled
    },
    setEnabled: function(a) {
        this.enabled = a
    },
    initWithItems: function(a) {
        var b = [];
        if (a)
            for (var c = 0; c < a.length; c++) a[c] && b.push(a[c]);
        return this.initWithArray(b)
    },
    initWithArray: function(a) {
        if (cc.Layer.prototype.init.call(this)) {
            this.enabled = !0;
            var b = cc.winSize;
            this.setPosition(b.width / 2, b.height / 2);
            this.setContentSize(b);
            this.setAnchorPoint(0.5, 0.5);
            this.ignoreAnchorPointForPosition(!0);
            if (a)
                for (b = 0; b < a.length; b++) this.addChild(a[b], b);
            this._selectedItem = null;
            this._state = cc.MENU_STATE_WAITING;
            return this.cascadeOpacity = this.cascadeColor = !0
        }
        return !1
    },
    addChild: function(a, b, c) {
        if (!(a instanceof cc.MenuItem)) throw "cc.Menu.addChild() : Menu only supports MenuItem objects as children";
        cc.Layer.prototype.addChild.call(this, a, b, c)
    },
    alignItemsVertically: function() {
        this.alignItemsVerticallyWithPadding(cc.DEFAULT_PADDING)
    },
    alignItemsVerticallyWithPadding: function(a) {
        var b = -a,
            c = this._children,
            d, e, f, g;
        if (c && 0 < c.length) {
            e = 0;
            for (d = c.length; e < d; e++) b += c[e].height * c[e].scaleY + a;
            var h = b / 2;
            e = 0;
            for (d = c.length; e < d; e++) g = c[e], f = g.height, b = g.scaleY, g.setPosition(0, h - f * b / 2), h -= f * b + a
        }
    },
    alignItemsHorizontally: function() {
        this.alignItemsHorizontallyWithPadding(cc.DEFAULT_PADDING)
    },
    alignItemsHorizontallyWithPadding: function(a) {
        var b = -a,
            c = this._children,
            d, e, f, g;
        if (c && 0 < c.length) {
            d = 0;
            for (e = c.length; d < e; d++) b += c[d].width * c[d].scaleX + a;
            var h = -b / 2;
            d = 0;
            for (e = c.length; d < e; d++) g = c[d], b = g.scaleX, f = c[d].width, g.setPosition(h + f * b / 2, 0), h += f * b + a
        }
    },
    alignItemsInColumns: function() {
        0 < arguments.length && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
        for (var a = [], b = 0; b < arguments.length; b++) a.push(arguments[b]);
        var c = -5,
            d = 0,
            e = 0,
            f = 0,
            g, h, k, m =
            this._children;
        if (m && 0 < m.length) {
            b = 0;
            for (k = m.length; b < k; b++)
                if (!(d >= a.length) && (g = a[d])) h = m[b].height, e = e >= h || isNaN(h) ? e : h, ++f, f >= g && (c += e + 5, e = f = 0, ++d)
        }
        var n = cc.director.getWinSize(),
            q = g = e = d = 0,
            r = 0,
            c = c / 2;
        if (m && 0 < m.length) {
            b = 0;
            for (k = m.length; b < k; b++) {
                var s = m[b];
                0 == g && (g = a[d], r = q = n.width / (1 + g));
                h = s._getHeight();
                e = e >= h || isNaN(h) ? e : h;
                s.setPosition(r - n.width / 2, c - h / 2);
                r += q;
                ++f;
                f >= g && (c -= e + 5, e = g = f = 0, ++d)
            }
        }
    },
    alignItemsInRows: function() {
        0 < arguments.length && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
        var a = [],
            b;
        for (b = 0; b < arguments.length; b++) a.push(arguments[b]);
        var c = [],
            d = [],
            e = -10,
            f = -5,
            g = 0,
            h = 0,
            k = 0,
            m, n, q, r, s = this._children;
        if (s && 0 < s.length) {
            b = 0;
            for (q = s.length; b < q; b++)
                if (n = s[b], !(g >= a.length) && (m = a[g])) r = n.width, h = h >= r || isNaN(r) ? h : r, f += n.height + 5, ++k, k >= m && (c.push(h), d.push(f), e += h + 10, h = k = 0, f = -5, ++g)
        }
        f = cc.director.getWinSize();
        m = h = g = 0;
        var e = -e / 2,
            t = 0;
        if (s && 0 < s.length) {
            b = 0;
            for (q = s.length; b < q; b++) n = s[b], 0 == m && (m = a[g], t = d[g]), r = n._getWidth(), h = h >= r || isNaN(r) ? h : r, n.setPosition(e + c[g] / 2, t - f.height / 2),
                t -= n.height + 10, ++k, k >= m && (e += h + 5, h = m = k = 0, ++g)
        }
    },
    removeChild: function(a, b) {
        null != a && (a instanceof cc.MenuItem ? (this._selectedItem == a && (this._selectedItem = null), cc.Node.prototype.removeChild.call(this, a, b)) : cc.log("cc.Menu.removeChild():Menu only supports MenuItem objects as children"))
    },
    _onTouchBegan: function(a, b) {
        var c = b.getCurrentTarget();
        if (c._state != cc.MENU_STATE_WAITING || !c._visible || !c.enabled) return !1;
        for (var d = c.parent; null != d; d = d.parent)
            if (!d.isVisible()) return !1;
        c._selectedItem = c._itemForTouch(a);
        return c._selectedItem ? (c._state = cc.MENU_STATE_TRACKING_TOUCH, c._selectedItem.selected(), !0) : !1
    },
    _onTouchEnded: function(a, b) {
        var c = b.getCurrentTarget();
        c._state !== cc.MENU_STATE_TRACKING_TOUCH ? cc.log("cc.Menu.onTouchEnded(): invalid state") : (c._selectedItem && (c._selectedItem.unselected(), c._selectedItem.activate()), c._state = cc.MENU_STATE_WAITING)
    },
    _onTouchCancelled: function(a, b) {
        var c = b.getCurrentTarget();
        c._state !== cc.MENU_STATE_TRACKING_TOUCH ? cc.log("cc.Menu.onTouchCancelled(): invalid state") : (this._selectedItem &&
            c._selectedItem.unselected(), c._state = cc.MENU_STATE_WAITING)
    },
    _onTouchMoved: function(a, b) {
        var c = b.getCurrentTarget();
        if (c._state !== cc.MENU_STATE_TRACKING_TOUCH) cc.log("cc.Menu.onTouchMoved(): invalid state");
        else {
            var d = c._itemForTouch(a);
            d != c._selectedItem && (c._selectedItem && c._selectedItem.unselected(), c._selectedItem = d, c._selectedItem && c._selectedItem.selected())
        }
    },
    onExit: function() {
        this._state == cc.MENU_STATE_TRACKING_TOUCH && (this._selectedItem && (this._selectedItem.unselected(), this._selectedItem =
            null), this._state = cc.MENU_STATE_WAITING);
        cc.Node.prototype.onExit.call(this)
    },
    setOpacityModifyRGB: function(a) {},
    isOpacityModifyRGB: function() {
        return !1
    },
    _itemForTouch: function(a) {
        a = a.getLocation();
        var b = this._children,
            c;
        if (b && 0 < b.length)
            for (var d = b.length - 1; 0 <= d; d--)
                if (c = b[d], c.isVisible() && c.isEnabled()) {
                    var e = c.convertToNodeSpace(a),
                        f = c.rect();
                    f.x = 0;
                    f.y = 0;
                    if (cc.rectContainsPoint(f, e)) return c
                }
        return null
    }
});
_p = cc.Menu.prototype;
cc.Menu.create = function(a) {
    var b = arguments.length;
    0 < b && null == arguments[b - 1] && cc.log("parameters should not be ending with null in Javascript");
    return 0 == b ? new cc.Menu : 1 == b ? new cc.Menu(a) : new cc.Menu(Array.prototype.slice.call(arguments, 0))
};
cc.LabelAtlas = cc.AtlasNode.extend({
    _string: null,
    _mapStartChar: null,
    _textureLoaded: !1,
    _className: "LabelAtlas",
    ctor: function(a, b, c, d, e) {
        cc.AtlasNode.prototype.ctor.call(this);
        this._cascadeColorEnabled = this._cascadeOpacityEnabled = !0;
        b && cc.LabelAtlas.prototype.initWithString.call(this, a, b, c, d, e)
    },
    textureLoaded: function() {
        return this._textureLoaded
    },
    addLoadedEventListener: function(a, b) {
        this.addEventListener("load", a, b)
    },
    initWithString: function(a, b, c, d, e) {
        var f = a + "",
            g, h;
        if (void 0 === c) {
            c = cc.loader.getRes(b);
            if (1 !== parseInt(c.version, 10)) return cc.log("cc.LabelAtlas.initWithString(): Unsupported version. Upgrade cocos2d version"), !1;
            b = cc.path.changeBasename(b, c.textureFilename);
            d = cc.contentScaleFactor();
            g = parseInt(c.itemWidth, 10) / d;
            h = parseInt(c.itemHeight, 10) / d;
            c = String.fromCharCode(parseInt(c.firstChar, 10))
        } else g = c || 0, h = d || 0, c = e || " ";
        var k = null,
            k = b instanceof cc.Texture2D ? b : cc.textureCache.addImage(b);
        (this._textureLoaded = b = k.isLoaded()) || k.addEventListener("load", function(a) {
            this.initWithTexture(k,
                g, h, f.length);
            this.string = f;
            this.dispatchEvent("load")
        }, this);
        return this.initWithTexture(k, g, h, f.length) ? (this._mapStartChar = c, this.string = f, !0) : !1
    },
    setColor: function(a) {
        cc.AtlasNode.prototype.setColor.call(this, a);
        this.updateAtlasValues()
    },
    getString: function() {
        return this._string
    },
    draw: function(a) {
        cc.AtlasNode.prototype.draw.call(this, a);
        cc.LABELATLAS_DEBUG_DRAW && (a = this.size, a = [cc.p(0, 0), cc.p(a.width, 0), cc.p(a.width, a.height), cc.p(0, a.height)], cc._drawingUtil.drawPoly(a, 4, !0))
    },
    _addChildForCanvas: function(a,
        b, c) {
        a._lateChild = !0;
        cc.Node.prototype.addChild.call(this, a, b, c)
    },
    updateAtlasValues: null,
    _updateAtlasValuesForCanvas: function() {
        for (var a = this._string || "", b = a.length, c = this.texture, d = this._itemWidth, e = this._itemHeight, f = 0; f < b; f++) {
            var g = a.charCodeAt(f) - this._mapStartChar.charCodeAt(0),
                h = parseInt(g % this._itemsPerRow, 10),
                g = parseInt(g / this._itemsPerRow, 10),
                h = cc.rect(h * d, g * e, d, e),
                g = a.charCodeAt(f),
                k = this.getChildByTag(f);
            k ? 32 == g ? (k.init(), k.setTextureRect(cc.rect(0, 0, 10, 10), !1, cc.size(0, 0))) : (k.initWithTexture(c,
                h), k.visible = !0) : (k = new cc.Sprite, 32 == g ? (k.init(), k.setTextureRect(cc.rect(0, 0, 10, 10), !1, cc.size(0, 0))) : k.initWithTexture(c, h), cc.Node.prototype.addChild.call(this, k, 0, f));
            k.setPosition(f * d + d / 2, e / 2)
        }
    },
    _updateAtlasValuesForWebGL: function() {
        var a = this._string,
            b = a.length,
            c = this.textureAtlas,
            d = c.texture,
            e = d.pixelsWidth,
            d = d.pixelsHeight,
            f = this._itemWidth,
            g = this._itemHeight;
        this._ignoreContentScaleFactor || (f = this._itemWidth * cc.contentScaleFactor(), g = this._itemHeight * cc.contentScaleFactor());
        b > c.getCapacity() &&
            cc.log("cc.LabelAtlas._updateAtlasValues(): Invalid String length");
        for (var h = c.quads, k = this._displayedColor, k = {
            r: k.r,
            g: k.g,
            b: k.b,
            a: this._displayedOpacity
        }, m = this._itemWidth, n = 0; n < b; n++) {
            var q = a.charCodeAt(n) - this._mapStartChar.charCodeAt(0),
                r = q % this._itemsPerRow,
                s = 0 | q / this._itemsPerRow,
                t;
            cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (r = (2 * r * f + 1) / (2 * e), q = r + (2 * f - 2) / (2 * e), s = (2 * s * g + 1) / (2 * d), t = s + (2 * g - 2) / (2 * d)) : (r = r * f / e, q = r + f / e, s = s * g / d, t = s + g / d);
            var u = h[n],
                w = u.tl,
                v = u.tr,
                y = u.bl,
                u = u.br;
            w.texCoords.u = r;
            w.texCoords.v =
                s;
            v.texCoords.u = q;
            v.texCoords.v = s;
            y.texCoords.u = r;
            y.texCoords.v = t;
            u.texCoords.u = q;
            u.texCoords.v = t;
            y.vertices.x = n * m;
            y.vertices.y = 0;
            y.vertices.z = 0;
            u.vertices.x = n * m + m;
            u.vertices.y = 0;
            u.vertices.z = 0;
            w.vertices.x = n * m;
            w.vertices.y = this._itemHeight;
            w.vertices.z = 0;
            v.vertices.x = n * m + m;
            v.vertices.y = this._itemHeight;
            v.vertices.z = 0;
            w.colors = k;
            v.colors = k;
            y.colors = k;
            u.colors = k
        }
        0 < b && (c.dirty = !0, a = c.totalQuads, b > a && c.increaseTotalQuadsWith(b - a))
    },
    setString: null,
    _setStringForCanvas: function(a) {
        a = String(a);
        var b = a.length;
        this._string = a;
        this.width = b * this._itemWidth;
        this.height = this._itemHeight;
        if (this._children) {
            a = this._children;
            for (var b = a.length, c = 0; c < b; c++) {
                var d = a[c];
                d && !d._lateChild && (d.visible = !1)
            }
        }
        this.updateAtlasValues();
        this.quadsToDraw = b
    },
    _setStringForWebGL: function(a) {
        a = String(a);
        var b = a.length;
        b > this.textureAtlas.totalQuads && this.textureAtlas.resizeCapacity(b);
        this._string = a;
        this.width = b * this._itemWidth;
        this.height = this._itemHeight;
        this.updateAtlasValues();
        this.quadsToDraw = b
    },
    setOpacity: null,
    _setOpacityForWebGL: function(a) {
        this._opacity !==
            a && cc.AtlasNode.prototype.setOpacity.call(this, a)
    }
});
_p = cc.LabelAtlas.prototype;
cc.EventHelper.prototype.apply(_p);
cc._renderType === cc._RENDER_TYPE_WEBGL ? (_p.updateAtlasValues = _p._updateAtlasValuesForWebGL, _p.setString = _p._setStringForWebGL, _p.setOpacity = _p._setOpacityForWebGL) : (_p.updateAtlasValues = _p._updateAtlasValuesForCanvas, _p.setString = _p._setStringForCanvas, _p.setOpacity = _p._setOpacityForCanvas, _p.addChild = _p._addChildForCanvas);
cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
cc.defineGetterSetter(_p, "color", _p.getColor, _p.setColor);
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
cc.LabelAtlas.create = function(a, b, c, d, e) {
    return new cc.LabelAtlas(a, b, c, d, e)
};
cc.LABEL_AUTOMATIC_WIDTH = -1;
cc.LabelBMFont = cc.SpriteBatchNode.extend({
    _opacityModifyRGB: !1,
    _string: "",
    _config: null,
    _fntFile: "",
    _initialString: "",
    _alignment: cc.TEXT_ALIGNMENT_CENTER,
    _width: -1,
    _lineBreakWithoutSpaces: !1,
    _imageOffset: null,
    _reusedChar: null,
    _displayedOpacity: 255,
    _realOpacity: 255,
    _displayedColor: null,
    _realColor: null,
    _cascadeColorEnabled: !0,
    _cascadeOpacityEnabled: !0,
    _textureLoaded: !1,
    _className: "LabelBMFont",
    _setString: function(a, b) {
        b ? this._initialString = a : this._string = a;
        var c = this._children;
        if (c)
            for (var d = 0; d < c.length; d++) {
                var e =
                    c[d];
                e && e.setVisible(!1)
            }
        this._textureLoaded && (this.createFontChars(), b && this.updateLabel())
    },
    ctor: function(a, b, c, d, e) {
        cc.SpriteBatchNode.prototype.ctor.call(this);
        this._imageOffset = cc.p(0, 0);
        this._displayedColor = cc.color(255, 255, 255, 255);
        this._realColor = cc.color(255, 255, 255, 255);
        this._reusedChar = [];
        this.initWithString(a, b, c, d, e)
    },
    textureLoaded: function() {
        return this._textureLoaded
    },
    addLoadedEventListener: function(a, b) {
        this.addEventListener("load", a, b)
    },
    draw: function(a) {
        cc.SpriteBatchNode.prototype.draw.call(this,
            a);
        if (cc.LABELBMFONT_DEBUG_DRAW) {
            a = this.getContentSize();
            var b = cc.p(0 | -this._anchorPointInPoints.x, 0 | -this._anchorPointInPoints.y);
            a = [cc.p(b.x, b.y), cc.p(b.x + a.width, b.y), cc.p(b.x + a.width, b.y + a.height), cc.p(b.x, b.y + a.height)];
            cc._drawingUtil.setDrawColor(0, 255, 0, 255);
            cc._drawingUtil.drawPoly(a, 4, !0)
        }
    },
    setColor: function(a) {
        var b = this._displayedColor,
            c = this._realColor;
        c.r == a.r && c.g == a.g && c.b == a.b && c.a == a.a || (b.r = c.r = a.r, b.g = c.g = a.g, b.b = c.b = a.b, this._textureLoaded && this._cascadeColorEnabled && (a = cc.color.WHITE, (b = this._parent) && b.cascadeColor && (a = b.getDisplayedColor()), this.updateDisplayedColor(a)))
    },
    isOpacityModifyRGB: function() {
        return this._opacityModifyRGB
    },
    setOpacityModifyRGB: function(a) {
        this._opacityModifyRGB = a;
        if (a = this._children)
            for (var b = 0; b < a.length; b++) {
                var c = a[b];
                c && (c.opacityModifyRGB = this._opacityModifyRGB)
            }
    },
    getOpacity: function() {
        return this._realOpacity
    },
    getDisplayedOpacity: function() {
        return this._displayedOpacity
    },
    setOpacity: function(a) {
        this._displayedOpacity = this._realOpacity = a;
        if (this._cascadeOpacityEnabled) {
            var b =
                255,
                c = this._parent;
            c && c.cascadeOpacity && (b = c.getDisplayedOpacity());
            this.updateDisplayedOpacity(b)
        }
        this._displayedColor.a = this._realColor.a = a
    },
    updateDisplayedOpacity: function(a) {
        this._displayedOpacity = this._realOpacity * a / 255;
        a = this._children;
        for (var b = 0; b < a.length; b++) {
            var c = a[b];
            cc._renderType == cc._RENDER_TYPE_WEBGL ? c.updateDisplayedOpacity(this._displayedOpacity) : (cc.Node.prototype.updateDisplayedOpacity.call(c, this._displayedOpacity), c.setNodeDirty())
        }
        this._changeTextureColor()
    },
    isCascadeOpacityEnabled: function() {
        return !1
    },
    setCascadeOpacityEnabled: function(a) {
        this._cascadeOpacityEnabled = a
    },
    getColor: function() {
        var a = this._realColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    getDisplayedColor: function() {
        var a = this._displayedColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    updateDisplayedColor: function(a) {
        var b = this._displayedColor,
            c = this._realColor;
        b.r = c.r * a.r / 255;
        b.g = c.g * a.g / 255;
        b.b = c.b * a.b / 255;
        a = this._children;
        for (b = 0; b < a.length; b++) c = a[b], cc._renderType == cc._RENDER_TYPE_WEBGL ? c.updateDisplayedColor(this._displayedColor) : (cc.Node.prototype.updateDisplayedColor.call(c,
            this._displayedColor), c.setNodeDirty());
        this._changeTextureColor()
    },
    _changeTextureColor: function() {
        if (cc._renderType != cc._RENDER_TYPE_WEBGL) {
            var a = this.getTexture();
            if (a && 0 < a.getContentSize().width) {
                var b = this._originalTexture.getHtmlElementObj();
                if (b) {
                    var c = a.getHtmlElementObj(),
                        d = cc.rect(0, 0, b.width, b.height);
                    c instanceof HTMLCanvasElement && !this._rectRotated ? cc.generateTintImageWithMultiply(b, this._displayedColor, d, c) : (c = cc.generateTintImageWithMultiply(b, this._displayedColor, d), a = new cc.Texture2D,
                        a.initWithElement(c), a.handleLoadedTexture());
                    this.setTexture(a)
                }
            }
        }
    },
    isCascadeColorEnabled: function() {
        return !1
    },
    setCascadeColorEnabled: function(a) {
        this._cascadeColorEnabled = a
    },
    init: function() {
        return this.initWithString(null, null, null, null, null)
    },
    initWithString: function(a, b, c, d, e) {
        a = a || "";
        this._config && cc.log("cc.LabelBMFont.initWithString(): re-init is no longer supported");
        if (b) {
            var f = cc.loader.getRes(b);
            if (!f) return cc.log("cc.LabelBMFont.initWithString(): Impossible to create font. Please check file"), !1;
            this._config = f;
            this._fntFile = b;
            b = cc.textureCache.addImage(f.atlasName);
            (this._textureLoaded = f = b.isLoaded()) || b.addEventListener("load", function(a) {
                this._textureLoaded = !0;
                this.initWithTexture(a, this._initialString.length);
                this.setString(this._initialString, !0);
                this.dispatchEvent("load")
            }, this)
        } else b = new cc.Texture2D, f = new Image, b.initWithElement(f), this._textureLoaded = !1;
        return this.initWithTexture(b, a.length) ? (this._alignment = d || cc.TEXT_ALIGNMENT_LEFT, this._imageOffset = e || cc.p(0, 0), this._width =
            null == c ? -1 : c, this._displayedOpacity = this._realOpacity = 255, this._displayedColor = cc.color(255, 255, 255, 255), this._realColor = cc.color(255, 255, 255, 255), this._cascadeColorEnabled = this._cascadeOpacityEnabled = !0, this._contentSize.width = 0, this._contentSize.height = 0, this.setAnchorPoint(0.5, 0.5), cc._renderType === cc._RENDER_TYPE_WEBGL && (c = this.textureAtlas.texture, this._opacityModifyRGB = c.hasPremultipliedAlpha(), d = this._reusedChar = new cc.Sprite, d.initWithTexture(c, cc.rect(0, 0, 0, 0), !1), d.batchNode = this), this.setString(a, !0), !0) : !1
    },
    createFontChars: function() {
        var a = cc._renderType,
            b = a === cc._RENDER_TYPE_CANVAS ? this.texture : this.textureAtlas.texture,
            c = 0,
            d = cc.size(0, 0),
            e = 0,
            f = 1,
            g = this._string,
            h = g ? g.length : 0;
        if (0 !== h) {
            var k, m = this._config,
                n = m.kerningDict,
                q = m.commonHeight,
                r = m.fontDefDictionary;
            for (k = 0; k < h - 1; k++) 10 == g.charCodeAt(k) && f++;
            var s = q * f,
                f = -(q - q * f),
                t = -1;
            for (k = 0; k < h; k++)
                if (q = g.charCodeAt(k), 0 != q)
                    if (10 === q) c = 0, f -= m.commonHeight;
                    else {
                        var u = n[t << 16 | q & 65535] || 0,
                            w = r[q];
                        if (w) {
                            var v = cc.rect(w.rect.x, w.rect.y, w.rect.width,
                                    w.rect.height),
                                v = cc.rectPixelsToPoints(v);
                            v.x += this._imageOffset.x;
                            v.y += this._imageOffset.y;
                            (t = this.getChildByTag(k)) ? 32 === q && a === cc._RENDER_TYPE_CANVAS ? t.setTextureRect(v, !1, cc.size(0, 0)) : (t.setTextureRect(v, !1), t.visible = !0): (t = new cc.Sprite, 32 === q && a === cc._RENDER_TYPE_CANVAS && (v = cc.rect(0, 0, 0, 0)), t.initWithTexture(b, v, !1), t._newTextureWhenChangeColor = !0, this.addChild(t, 0, k));
                            t.opacityModifyRGB = this._opacityModifyRGB;
                            cc._renderType == cc._RENDER_TYPE_WEBGL ? (t.updateDisplayedColor(this._displayedColor),
                                t.updateDisplayedOpacity(this._displayedOpacity)) : (cc.Node.prototype.updateDisplayedColor.call(t, this._displayedColor), cc.Node.prototype.updateDisplayedOpacity.call(t, this._displayedOpacity), t.setNodeDirty());
                            v = cc.p(c + w.xOffset + 0.5 * w.rect.width + u, f + (m.commonHeight - w.yOffset) - 0.5 * v.height * cc.contentScaleFactor());
                            t.setPosition(cc.pointPixelsToPoints(v));
                            c += w.xAdvance + u;
                            t = q;
                            e < c && (e = c)
                        } else cc.log("cocos2d: LabelBMFont: character not found " + g[k])
                    }
            d.width = w && w.xAdvance < w.rect.width ? e - w.xAdvance + w.rect.width :
                e;
            d.height = s;
            this.setContentSize(cc.sizePixelsToPoints(d))
        }
    },
    updateString: function(a) {
        var b = this._children;
        if (b)
            for (var c = 0, d = b.length; c < d; c++) {
                var e = b[c];
                e && (e.visible = !1)
            }
        this._config && this.createFontChars();
        a || this.updateLabel()
    },
    getString: function() {
        return this._initialString
    },
    setString: function(a, b) {
        a = String(a);
        null == b && (b = !0);
        if (null == a || !cc.isString(a)) a += "";
        this._initialString = a;
        this._setString(a, b)
    },
    _setStringForSetter: function(a) {
        this.setString(a, !1)
    },
    setCString: function(a) {
        this.setString(a, !0)
    },
    updateLabel: function() {
        this.string = this._initialString;
        if (0 < this._width) {
            for (var a = this._string.length, b = [], c = [], d = 1, e = 0, f = !1, g = !1, h = -1, k = -1, m = 0, n, q = 0, r = this._children.length; q < r; q++) {
                for (var s = 0; !(n = this.getChildByTag(q + m + s));) s++;
                m += s;
                if (e >= a) break;
                var t = this._string[e];
                g || (k = this._getLetterPosXLeft(n), g = !0);
                f || (h = k, f = !0);
                if (10 == t.charCodeAt(0)) {
                    c.push("\n");
                    b = b.concat(c);
                    c.length = 0;
                    f = g = !1;
                    h = k = -1;
                    q--;
                    m -= s;
                    d++;
                    if (e >= a) break;
                    k || (k = this._getLetterPosXLeft(n), g = !0);
                    h || (h = k, f = !0);
                    e++
                } else if (this._isspace_unicode(t)) c.push(t),
                    b = b.concat(c), c.length = 0, g = !1, k = -1, e++;
                else if (this._getLetterPosXRight(n) - h > this._width)
                    if (this._lineBreakWithoutSpaces) {
                        this._utf8_trim_ws(c);
                        c.push("\n");
                        b = b.concat(c);
                        c.length = 0;
                        f = g = !1;
                        h = k = -1;
                        d++;
                        if (e >= a) break;
                        k || (k = this._getLetterPosXLeft(n), g = !0);
                        h || (h = k, f = !0);
                        q--
                    } else c.push(t), -1 != b.lastIndexOf(" ") ? this._utf8_trim_ws(b) : b = [], 0 < b.length && b.push("\n"), d++, f = !1, h = -1, e++;
                else c.push(t), e++
            }
            b = b.concat(c);
            q = b.length;
            n = "";
            for (e = 0; e < q; ++e) n += b[e];
            n += String.fromCharCode(0);
            this._setString(n, !1)
        }
        if (this._alignment !=
            cc.TEXT_ALIGNMENT_LEFT) {
            b = e = 0;
            a = this._string.length;
            c = [];
            for (d = 0; d < a; d++)
                if (10 == this._string[d].charCodeAt(0) || 0 == this._string[d].charCodeAt(0))
                    if (q = 0, f = c.length, 0 == f) b++;
                    else {
                        if (n = e + f - 1 + b, !(0 > n) && (q = this.getChildByTag(n), null != q)) {
                            q = q.getPositionX() + q._getWidth() / 2;
                            g = 0;
                            switch (this._alignment) {
                                case cc.TEXT_ALIGNMENT_CENTER:
                                    g = this.width / 2 - q / 2;
                                    break;
                                case cc.TEXT_ALIGNMENT_RIGHT:
                                    g = this.width - q
                            }
                            if (0 != g)
                                for (q = 0; q < f; q++)
                                    if (n = e + q + b, !(0 > n) && (n = this.getChildByTag(n))) n.x += g;
                            e += f;
                            b++;
                            c.length = 0
                        }
                    } else c.push(this._string[e])
        }
    },
    setAlignment: function(a) {
        this._alignment = a;
        this.updateLabel()
    },
    _getAlignment: function() {
        return this._alignment
    },
    setBoundingWidth: function(a) {
        this._width = a;
        this.updateLabel()
    },
    _getBoundingWidth: function() {
        return this._width
    },
    setLineBreakWithoutSpace: function(a) {
        this._lineBreakWithoutSpaces = a;
        this.updateLabel()
    },
    setScale: function(a, b) {
        cc.Node.prototype.setScale.call(this, a, b);
        this.updateLabel()
    },
    setScaleX: function(a) {
        cc.Node.prototype.setScaleX.call(this, a);
        this.updateLabel()
    },
    setScaleY: function(a) {
        cc.Node.prototype.setScaleY.call(this,
            a);
        this.updateLabel()
    },
    setFntFile: function(a) {
        if (null != a && a != this._fntFile) {
            var b = cc.loader.getRes(a);
            b ? (this._fntFile = a, this._config = b, a = cc.textureCache.addImage(b.atlasName), this._textureLoaded = b = a.isLoaded(), this.texture = a, cc._renderType === cc._RENDER_TYPE_CANVAS && (this._originalTexture = this.texture), b ? this.createFontChars() : a.addEventListener("load", function(a) {
                    this._textureLoaded = !0;
                    this.texture = a;
                    this.createFontChars();
                    this._changeTextureColor();
                    this.updateLabel();
                    this.dispatchEvent("load")
                },
                this)) : cc.log("cc.LabelBMFont.setFntFile() : Impossible to create font. Please check file")
        }
    },
    getFntFile: function() {
        return this._fntFile
    },
    setAnchorPoint: function(a, b) {
        cc.Node.prototype.setAnchorPoint.call(this, a, b);
        this.updateLabel()
    },
    _setAnchor: function(a) {
        cc.Node.prototype._setAnchor.call(this, a);
        this.updateLabel()
    },
    _setAnchorX: function(a) {
        cc.Node.prototype._setAnchorX.call(this, a);
        this.updateLabel()
    },
    _setAnchorY: function(a) {
        cc.Node.prototype._setAnchorY.call(this, a);
        this.updateLabel()
    },
    _atlasNameFromFntFile: function(a) {},
    _kerningAmountForFirst: function(a, b) {
        var c = 0;
        if (this._configuration.kerningDictionary) {
            var d = this._configuration.kerningDictionary[(a << 16 | b & 65535).toString()];
            d && (c = d.amount)
        }
        return c
    },
    _getLetterPosXLeft: function(a) {
        return a.getPositionX() * this._scaleX - a._getWidth() * this._scaleX * a._getAnchorX()
    },
    _getLetterPosXRight: function(a) {
        return a.getPositionX() * this._scaleX + a._getWidth() * this._scaleX * a._getAnchorX()
    },
    _isspace_unicode: function(a) {
        a = a.charCodeAt(0);
        return 9 <= a && 13 >= a || 32 == a || 133 == a || 160 == a || 5760 ==
            a || 8192 <= a && 8202 >= a || 8232 == a || 8233 == a || 8239 == a || 8287 == a || 12288 == a
    },
    _utf8_trim_ws: function(a) {
        var b = a.length;
        if (!(0 >= b) && (b -= 1, this._isspace_unicode(a[b]))) {
            for (var c = b - 1; 0 <= c; --c)
                if (this._isspace_unicode(a[c])) b = c;
                else break;
            this._utf8_trim_from(a, b)
        }
    },
    _utf8_trim_from: function(a, b) {
        var c = a.length;
        b >= c || 0 > b || a.splice(b, c)
    }
});
_p = cc.LabelBMFont.prototype;
cc.EventHelper.prototype.apply(_p);
cc._renderType === cc._RENDER_TYPE_CANVAS && (cc.sys._supportCanvasNewBlendModes || (_p._changeTextureColor = function() {
    if (cc._renderType != cc._RENDER_TYPE_WEBGL) {
        var a, b = this.getTexture();
        if (b && 0 < b.getContentSize().width && (a = b.getHtmlElementObj())) {
            var c = cc.textureCache.getTextureColors(this._originalTexture.getHtmlElementObj());
            c && (a instanceof HTMLCanvasElement && !this._rectRotated ? cc.generateTintImage(a, c, this._displayedColor, null, a) : (a = cc.generateTintImage(a, c, this._displayedColor), b = new cc.Texture2D,
                b.initWithElement(a), b.handleLoadedTexture()), this.setTexture(b))
        }
    }
}), _p.setTexture = function(a) {
    for (var b = this._children, c = this._displayedColor, d = 0; d < b.length; d++) {
        var e = b[d],
            f = e._displayedColor;
        this._textureForCanvas != e._texture && (f.r !== c.r || f.g !== c.g || f.b !== c.b) || (e.texture = a)
    }
    this._textureForCanvas = a
});
cc.defineGetterSetter(_p, "string", _p.getString, _p._setStringForSetter);
cc.defineGetterSetter(_p, "boundingWidth", _p._getBoundingWidth, _p.setBoundingWidth);
cc.defineGetterSetter(_p, "textAlign", _p._getAlignment, _p.setAlignment);
cc.LabelBMFont.create = function(a, b, c, d, e) {
    return new cc.LabelBMFont(a, b, c, d, e)
};
cc._fntLoader = {
    INFO_EXP: /info [^\n]*(\n|$)/gi,
    COMMON_EXP: /common [^\n]*(\n|$)/gi,
    PAGE_EXP: /page [^\n]*(\n|$)/gi,
    CHAR_EXP: /char [^\n]*(\n|$)/gi,
    KERNING_EXP: /kerning [^\n]*(\n|$)/gi,
    ITEM_EXP: /\w+=[^ \r\n]+/gi,
    INT_EXP: /^[\-]?\d+$/,
    _parseStrToObj: function(a) {
        a = a.match(this.ITEM_EXP);
        var b = {};
        if (a)
            for (var c = 0, d = a.length; c < d; c++) {
                var e = a[c],
                    f = e.indexOf("\x3d"),
                    g = e.substring(0, f),
                    e = e.substring(f + 1);
                e.match(this.INT_EXP) ? e = parseInt(e) : '"' == e[0] && (e = e.substring(1, e.length - 1));
                b[g] = e
            }
        return b
    },
    parseFnt: function(a,
        b) {
        var c = {},
            d = this._parseStrToObj(a.match(this.INFO_EXP)[0]).padding.split(",");
        parseInt(d[0]);
        parseInt(d[1]);
        parseInt(d[2]);
        parseInt(d[3]);
        d = this._parseStrToObj(a.match(this.COMMON_EXP)[0]);
        c.commonHeight = d.lineHeight;
        if (cc._renderType === cc._RENDER_TYPE_WEBGL) {
            var e = cc.configuration.getMaxTextureSize();
            (d.scaleW > e.width || d.scaleH > e.height) && cc.log("cc.LabelBMFont._parseCommonArguments(): page can't be larger than supported")
        }
        1 !== d.pages && cc.log("cc.LabelBMFont._parseCommonArguments(): only supports 1 page");
        d = this._parseStrToObj(a.match(this.PAGE_EXP)[0]);
        0 !== d.id && cc.log("cc.LabelBMFont._parseImageFileName() : file could not be found");
        c.atlasName = cc.path.changeBasename(b, d.file);
        for (var f = a.match(this.CHAR_EXP), g = c.fontDefDictionary = {}, d = 0, e = f.length; d < e; d++) {
            var h = this._parseStrToObj(f[d]);
            g[h.id] = {
                rect: {
                    x: h.x,
                    y: h.y,
                    width: h.width,
                    height: h.height
                },
                xOffset: h.xoffset,
                yOffset: h.yoffset,
                xAdvance: h.xadvance
            }
        }
        f = c.kerningDict = {};
        if (g = a.match(this.KERNING_EXP)) {
            d = 0;
            for (e = g.length; d < e; d++) h = this._parseStrToObj(g[d]),
                f[h.first << 16 | h.second & 65535] = h.amount
        }
        return c
    },
    load: function(a, b, c, d) {
        var e = this;
        cc.loader.loadTxt(a, function(a, c) {
            if (a) return d(a);
            d(null, e.parseFnt(c, b))
        })
    }
};
cc.loader.register(["fnt"], cc._fntLoader);
cc.GridBase = cc.Class.extend({
    _active: !1,
    _reuseGrid: 0,
    _gridSize: null,
    _texture: null,
    _step: null,
    _grabber: null,
    _isTextureFlipped: !1,
    _shaderProgram: null,
    _directorProjection: 0,
    _dirty: !1,
    ctor: function(a, b, c) {
        cc._checkWebGLRenderMode();
        this._active = !1;
        this._reuseGrid = 0;
        this._texture = this._gridSize = null;
        this._step = cc.p(0, 0);
        this._grabber = null;
        this._isTextureFlipped = !1;
        this._shaderProgram = null;
        this._directorProjection = 0;
        this._dirty = !1;
        void 0 !== a && this.initWithSize(a, b, c)
    },
    isActive: function() {
        return this._active
    },
    setActive: function(a) {
        this._active = a;
        if (!a) {
            a = cc.director;
            var b = a.getProjection();
            a.setProjection(b)
        }
    },
    getReuseGrid: function() {
        return this._reuseGrid
    },
    setReuseGrid: function(a) {
        this._reuseGrid = a
    },
    getGridSize: function() {
        return cc.size(this._gridSize.width, this._gridSize.height)
    },
    setGridSize: function(a) {
        this._gridSize.width = parseInt(a.width);
        this._gridSize.height = parseInt(a.height)
    },
    getStep: function() {
        return cc.p(this._step.x, this._step.y)
    },
    setStep: function(a) {
        this._step.x = a.x;
        this._step.y = a.y
    },
    isTextureFlipped: function() {
        return this._isTextureFlipped
    },
    setTextureFlipped: function(a) {
        this._isTextureFlipped != a && (this._isTextureFlipped = a, this.calculateVertexPoints())
    },
    initWithSize: function(a, b, c) {
        if (!b) {
            var d = cc.director.getWinSizeInPixels(),
                e = cc.NextPOT(d.width),
                f = cc.NextPOT(d.height),
                g = new Uint8Array(4 * e * f);
            if (!g) return cc.log("cocos2d: CCGrid: not enough memory."), !1;
            b = new cc.Texture2D;
            b.initWithData(g, cc.Texture2D.PIXEL_FORMAT_RGBA8888, e, f, d);
            if (!b) return cc.log("cocos2d: CCGrid: error creating texture"), !1
        }
        this._active = !1;
        this._reuseGrid = 0;
        this._gridSize =
            a;
        this._texture = b;
        this._isTextureFlipped = c || !1;
        this._step.x = this._texture.width / a.width;
        this._step.y = this._texture.height / a.height;
        this._grabber = new cc.Grabber;
        if (!this._grabber) return !1;
        this._grabber.grab(this._texture);
        this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE);
        this.calculateVertexPoints();
        return !0
    },
    beforeDraw: function() {
        this._directorProjection = cc.director.getProjection();
        this._grabber.beforeRender(this._texture)
    },
    afterDraw: function(a) {
        this._grabber.afterRender(this._texture);
        if (a && a.getCamera().isDirty()) {
            var b = a.getAnchorPointInPoints();
            cc.kmGLTranslatef(b.x, b.y, 0);
            a.getCamera().locate();
            cc.kmGLTranslatef(-b.x, -b.y, 0)
        }
        cc.glBindTexture2D(this._texture);
        this.blit()
    },
    blit: function() {
        cc.log("cc.GridBase.blit(): Shall be overridden in subclass.")
    },
    reuse: function() {
        cc.log("cc.GridBase.reuse(): Shall be overridden in subclass.")
    },
    calculateVertexPoints: function() {
        cc.log("cc.GridBase.calculateVertexPoints(): Shall be overridden in subclass.")
    },
    set2DProjection: function() {
        var a =
            cc.director.getWinSizeInPixels();
        cc._renderContext.viewport(0, 0, a.width, a.height);
        cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
        cc.kmGLLoadIdentity();
        var b = new cc.kmMat4;
        cc.kmMat4OrthographicProjection(b, 0, a.width, 0, a.height, -1, 1);
        cc.kmGLMultMatrix(b);
        cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
        cc.kmGLLoadIdentity();
        cc.setProjectionMatrixDirty()
    }
});
cc.GridBase.create = function(a, b, c) {
    return new cc.GridBase(a, b, c)
};
cc.Grid3D = cc.GridBase.extend({
    _texCoordinates: null,
    _vertices: null,
    _originalVertices: null,
    _indices: null,
    _texCoordinateBuffer: null,
    _verticesBuffer: null,
    _indicesBuffer: null,
    ctor: function(a, b, c) {
        cc.GridBase.prototype.ctor.call(this);
        this._indicesBuffer = this._verticesBuffer = this._texCoordinateBuffer = this._indices = this._originalVertices = this._vertices = this._texCoordinates = null;
        void 0 !== a && this.initWithSize(a, b, c)
    },
    vertex: function(a) {
        (a.x !== (0 | a.x) || a.y !== (0 | a.y)) && cc.log("cc.Grid3D.vertex() : Numbers must be integers");
        a = 0 | 3 * (a.x * (this._gridSize.height + 1) + a.y);
        var b = this._vertices;
        return new cc.Vertex3F(b[a], b[a + 1], b[a + 2])
    },
    originalVertex: function(a) {
        (a.x !== (0 | a.x) || a.y !== (0 | a.y)) && cc.log("cc.Grid3D.originalVertex() : Numbers must be integers");
        a = 0 | 3 * (a.x * (this._gridSize.height + 1) + a.y);
        var b = this._originalVertices;
        return new cc.Vertex3F(b[a], b[a + 1], b[a + 2])
    },
    setVertex: function(a, b) {
        (a.x !== (0 | a.x) || a.y !== (0 | a.y)) && cc.log("cc.Grid3D.setVertex() : Numbers must be integers");
        var c = 0 | 3 * (a.x * (this._gridSize.height + 1) +
                a.y),
            d = this._vertices;
        d[c] = b.x;
        d[c + 1] = b.y;
        d[c + 2] = b.z;
        this._dirty = !0
    },
    blit: function(a) {
        a = this._gridSize.width * this._gridSize.height;
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS);
        this._shaderProgram.use();
        this._shaderProgram.setUniformsForBuiltins();
        var b = cc._renderContext,
            c = this._dirty;
        b.bindBuffer(b.ARRAY_BUFFER, this._verticesBuffer);
        c && b.bufferData(b.ARRAY_BUFFER, this._vertices, b.DYNAMIC_DRAW);
        b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, b.FLOAT, !1,
            0, 0);
        b.bindBuffer(b.ARRAY_BUFFER, this._texCoordinateBuffer);
        c && b.bufferData(b.ARRAY_BUFFER, this._texCoordinates, b.DYNAMIC_DRAW);
        b.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, b.FLOAT, !1, 0, 0);
        b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
        c && b.bufferData(b.ELEMENT_ARRAY_BUFFER, this._indices, b.STATIC_DRAW);
        b.drawElements(b.TRIANGLES, 6 * a, b.UNSIGNED_SHORT, 0);
        c && (this._dirty = !1);
        cc.incrementGLDraws(1)
    },
    reuse: function() {
        if (0 < this._reuseGrid) {
            for (var a = this._originalVertices, b = this._vertices,
                c = 0, d = this._vertices.length; c < d; c++) a[c] = b[c];
            --this._reuseGrid
        }
    },
    calculateVertexPoints: function() {
        var a = cc._renderContext,
            b = this._texture.pixelsWidth,
            c = this._texture.pixelsHeight,
            d = this._texture.getContentSizeInPixels().height,
            e = this._gridSize,
            f = (e.width + 1) * (e.height + 1);
        this._vertices = new Float32Array(3 * f);
        this._texCoordinates = new Float32Array(2 * f);
        this._indices = new Uint16Array(6 * e.width * e.height);
        this._verticesBuffer && a.deleteBuffer(this._verticesBuffer);
        this._verticesBuffer = a.createBuffer();
        this._texCoordinateBuffer &&
            a.deleteBuffer(this._texCoordinateBuffer);
        this._texCoordinateBuffer = a.createBuffer();
        this._indicesBuffer && a.deleteBuffer(this._indicesBuffer);
        this._indicesBuffer = a.createBuffer();
        for (var g, h, k = this._indices, m = this._texCoordinates, n = this._isTextureFlipped, q = this._vertices, f = 0; f < e.width; ++f)
            for (g = 0; g < e.height; ++g) {
                var r = g * e.width + f;
                h = f * this._step.x;
                var s = h + this._step.x,
                    t = g * this._step.y,
                    u = t + this._step.y,
                    w = f * (e.height + 1) + g,
                    v = (f + 1) * (e.height + 1) + g,
                    y = (f + 1) * (e.height + 1) + (g + 1),
                    D = f * (e.height + 1) + (g + 1);
                k[6 * r] =
                    w;
                k[6 * r + 1] = v;
                k[6 * r + 2] = D;
                k[6 * r + 3] = v;
                k[6 * r + 4] = y;
                k[6 * r + 5] = D;
                var r = [3 * w, 3 * v, 3 * y, 3 * D],
                    C = [{
                        x: h,
                        y: t,
                        z: 0
                    }, {
                        x: s,
                        y: t,
                        z: 0
                    }, {
                        x: s,
                        y: u,
                        z: 0
                    }, {
                        x: h,
                        y: u,
                        z: 0
                    }],
                    w = [2 * w, 2 * v, 2 * y, 2 * D],
                    s = [cc.p(h, t), cc.p(s, t), cc.p(s, u), cc.p(h, u)];
                for (h = 0; 4 > h; ++h) q[r[h]] = C[h].x, q[r[h] + 1] = C[h].y, q[r[h] + 2] = C[h].z, m[w[h]] = s[h].x / b, m[w[h] + 1] = n ? (d - s[h].y) / c : s[h].y / c
            }
        this._originalVertices = new Float32Array(this._vertices);
        a.bindBuffer(a.ARRAY_BUFFER, this._verticesBuffer);
        a.bufferData(a.ARRAY_BUFFER, this._vertices, a.DYNAMIC_DRAW);
        a.bindBuffer(a.ARRAY_BUFFER,
            this._texCoordinateBuffer);
        a.bufferData(a.ARRAY_BUFFER, this._texCoordinates, a.DYNAMIC_DRAW);
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
        a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indices, a.STATIC_DRAW);
        this._dirty = !0
    }
});
cc.Grid3D.create = function(a, b, c) {
    return new cc.Grid3D(a, b, c)
};
cc.TiledGrid3D = cc.GridBase.extend({
    _texCoordinates: null,
    _vertices: null,
    _originalVertices: null,
    _indices: null,
    _texCoordinateBuffer: null,
    _verticesBuffer: null,
    _indicesBuffer: null,
    ctor: function(a, b, c) {
        cc.GridBase.prototype.ctor.call(this);
        this._indicesBuffer = this._verticesBuffer = this._texCoordinateBuffer = this._indices = this._originalVertices = this._vertices = this._texCoordinates = null;
        void 0 !== a && this.initWithSize(a, b, c)
    },
    tile: function(a) {
        (a.x !== (0 | a.x) || a.y !== (0 | a.y)) && cc.log("cc.TiledGrid3D.tile() : Numbers must be integers");
        a = 12 * (this._gridSize.height * a.x + a.y);
        var b = this._vertices;
        return new cc.Quad3(new cc.Vertex3F(b[a], b[a + 1], b[a + 2]), new cc.Vertex3F(b[a + 3], b[a + 4], b[a + 5]), new cc.Vertex3F(b[a + 6], b[a + 7], b[a + 8]), new cc.Vertex3F(b[a + 9], b[a + 10], b[a + 11]))
    },
    originalTile: function(a) {
        (a.x !== (0 | a.x) || a.y !== (0 | a.y)) && cc.log("cc.TiledGrid3D.originalTile() : Numbers must be integers");
        a = 12 * (this._gridSize.height * a.x + a.y);
        var b = this._originalVertices;
        return new cc.Quad3(new cc.Vertex3F(b[a], b[a + 1], b[a + 2]), new cc.Vertex3F(b[a + 3],
            b[a + 4], b[a + 5]), new cc.Vertex3F(b[a + 6], b[a + 7], b[a + 8]), new cc.Vertex3F(b[a + 9], b[a + 10], b[a + 11]))
    },
    setTile: function(a, b) {
        (a.x !== (0 | a.x) || a.y !== (0 | a.y)) && cc.log("cc.TiledGrid3D.setTile() : Numbers must be integers");
        var c = 12 * (this._gridSize.height * a.x + a.y),
            d = this._vertices;
        d[c] = b.bl.x;
        d[c + 1] = b.bl.y;
        d[c + 2] = b.bl.z;
        d[c + 3] = b.br.x;
        d[c + 4] = b.br.y;
        d[c + 5] = b.br.z;
        d[c + 6] = b.tl.x;
        d[c + 7] = b.tl.y;
        d[c + 8] = b.tl.z;
        d[c + 9] = b.tr.x;
        d[c + 10] = b.tr.y;
        d[c + 11] = b.tr.z;
        this._dirty = !0
    },
    blit: function(a) {
        a = this._gridSize.width * this._gridSize.height;
        this._shaderProgram.use();
        this._shaderProgram.setUniformsForBuiltins();
        var b = cc._renderContext,
            c = this._dirty;
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS);
        b.bindBuffer(b.ARRAY_BUFFER, this._verticesBuffer);
        c && b.bufferData(b.ARRAY_BUFFER, this._vertices, b.DYNAMIC_DRAW);
        b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, b.FLOAT, !1, 0, this._vertices);
        b.bindBuffer(b.ARRAY_BUFFER, this._texCoordinateBuffer);
        c && b.bufferData(b.ARRAY_BUFFER, this._texCoordinates, b.DYNAMIC_DRAW);
        b.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, b.FLOAT, !1, 0, this._texCoordinates);
        b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
        c && b.bufferData(b.ELEMENT_ARRAY_BUFFER, this._indices, b.STATIC_DRAW);
        b.drawElements(b.TRIANGLES, 6 * a, b.UNSIGNED_SHORT, 0);
        c && (this._dirty = !1);
        cc.incrementGLDraws(1)
    },
    reuse: function() {
        if (0 < this._reuseGrid) {
            for (var a = this._vertices, b = this._originalVertices, c = 0; c < a.length; c++) b[c] = a[c];
            --this._reuseGrid
        }
    },
    calculateVertexPoints: function() {
        var a = this._texture.pixelsWidth,
            b = this._texture.pixelsHeight,
            c = this._texture.getContentSizeInPixels().height,
            d = this._gridSize,
            e = d.width * d.height;
        this._vertices = new Float32Array(12 * e);
        this._texCoordinates = new Float32Array(8 * e);
        this._indices = new Uint16Array(6 * e);
        var f = cc._renderContext;
        this._verticesBuffer && f.deleteBuffer(this._verticesBuffer);
        this._verticesBuffer = f.createBuffer();
        this._texCoordinateBuffer && f.deleteBuffer(this._texCoordinateBuffer);
        this._texCoordinateBuffer = f.createBuffer();
        this._indicesBuffer && f.deleteBuffer(this._indicesBuffer);
        this._indicesBuffer = f.createBuffer();
        var g, h, k = 0,
            m = this._step,
            n = this._vertices,
            q = this._texCoordinates,
            r = this._isTextureFlipped;
        for (g = 0; g < d.width; g++)
            for (h = 0; h < d.height; h++) {
                var s = g * m.x,
                    t = s + m.x,
                    u = h * m.y,
                    w = u + m.y;
                n[12 * k] = s;
                n[12 * k + 1] = u;
                n[12 * k + 2] = 0;
                n[12 * k + 3] = t;
                n[12 * k + 4] = u;
                n[12 * k + 5] = 0;
                n[12 * k + 6] = s;
                n[12 * k + 7] = w;
                n[12 * k + 8] = 0;
                n[12 * k + 9] = t;
                n[12 * k + 10] = w;
                n[12 * k + 11] = 0;
                var v = u,
                    y = w;
                r && (v = c - u, y = c - w);
                q[8 * k] = s / a;
                q[8 * k + 1] = v / b;
                q[8 * k + 2] = t / a;
                q[8 * k + 3] = v / b;
                q[8 * k + 4] = s / a;
                q[8 * k + 5] = y / b;
                q[8 * k + 6] = t / a;
                q[8 * k + 7] = y / b;
                k++
            }
        a = this._indices;
        for (g = 0; g < e; g++) a[6 * g + 0] = 4 * g + 0, a[6 * g + 1] = 4 * g + 1, a[6 * g + 2] = 4 * g + 2, a[6 * g + 3] = 4 * g + 1, a[6 * g + 4] = 4 * g + 2, a[6 * g + 5] = 4 * g + 3;
        this._originalVertices = new Float32Array(this._vertices);
        f.bindBuffer(f.ARRAY_BUFFER, this._verticesBuffer);
        f.bufferData(f.ARRAY_BUFFER, this._vertices, f.DYNAMIC_DRAW);
        f.bindBuffer(f.ARRAY_BUFFER, this._texCoordinateBuffer);
        f.bufferData(f.ARRAY_BUFFER, this._texCoordinates, f.DYNAMIC_DRAW);
        f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
        f.bufferData(f.ELEMENT_ARRAY_BUFFER, this._indices, f.DYNAMIC_DRAW);
        this._dirty = !0
    }
});
cc.TiledGrid3D.create = function(a, b, c) {
    return new cc.TiledGrid3D(a, b, c)
};
cc.Grabber = cc.Class.extend({
    _FBO: null,
    _oldFBO: null,
    _oldClearColor: null,
    _gl: null,
    ctor: function() {
        cc._checkWebGLRenderMode();
        this._gl = cc._renderContext;
        this._oldClearColor = [0, 0, 0, 0];
        this._oldFBO = null;
        this._FBO = this._gl.createFramebuffer()
    },
    grab: function(a) {
        var b = this._gl;
        this._oldFBO = b.getParameter(b.FRAMEBUFFER_BINDING);
        b.bindFramebuffer(b.FRAMEBUFFER, this._FBO);
        b.framebufferTexture2D(b.FRAMEBUFFER, b.COLOR_ATTACHMENT0, b.TEXTURE_2D, a._webTextureObj, 0);
        b.checkFramebufferStatus(b.FRAMEBUFFER) != b.FRAMEBUFFER_COMPLETE &&
            cc.log("Frame Grabber: could not attach texture to frmaebuffer");
        b.bindFramebuffer(b.FRAMEBUFFER, this._oldFBO)
    },
    beforeRender: function(a) {
        a = this._gl;
        this._oldFBO = a.getParameter(a.FRAMEBUFFER_BINDING);
        a.bindFramebuffer(a.FRAMEBUFFER, this._FBO);
        this._oldClearColor = a.getParameter(a.COLOR_CLEAR_VALUE);
        a.clearColor(0, 0, 0, 0);
        a.clear(a.COLOR_BUFFER_BIT | a.DEPTH_BUFFER_BIT)
    },
    afterRender: function(a) {
        a = this._gl;
        a.bindFramebuffer(a.FRAMEBUFFER, this._oldFBO);
        a.colorMask(!0, !0, !0, !0)
    },
    destroy: function() {
        this._gl.deleteFramebuffer(this._FBO)
    }
});
cc.IMEKeyboardNotificationInfo = function(a, b, c) {
    this.begin = a || cc.rect(0, 0, 0, 0);
    this.end = b || cc.rect(0, 0, 0, 0);
    this.duration = c || 0
};
cc.IMEDelegate = cc.Class.extend({
    ctor: function() {
        cc.imeDispatcher.addDelegate(this)
    },
    removeDelegate: function() {
        cc.imeDispatcher.removeDelegate(this)
    },
    attachWithIME: function() {
        return cc.imeDispatcher.attachDelegateWithIME(this)
    },
    detachWithIME: function() {
        return cc.imeDispatcher.detachDelegateWithIME(this)
    },
    canAttachWithIME: function() {
        return !1
    },
    didAttachWithIME: function() {},
    canDetachWithIME: function() {
        return !1
    },
    didDetachWithIME: function() {},
    insertText: function(a, b) {},
    deleteBackward: function() {},
    getContentText: function() {
        return ""
    },
    keyboardWillShow: function(a) {},
    keyboardDidShow: function(a) {},
    keyboardWillHide: function(a) {},
    keyboardDidHide: function(a) {}
});
cc.IMEDispatcher = cc.Class.extend({
    _domInputControl: null,
    impl: null,
    _currentInputString: "",
    _lastClickPosition: null,
    ctor: function() {
        this.impl = new cc.IMEDispatcher.Impl;
        this._lastClickPosition = cc.p(0, 0)
    },
    init: function() {
        if (!cc.sys.isMobile) {
            this._domInputControl = cc.$("#imeDispatcherInput");
            this._domInputControl || (this._domInputControl = cc.$new("input"), this._domInputControl.setAttribute("type", "text"), this._domInputControl.setAttribute("id", "imeDispatcherInput"), this._domInputControl.resize(0, 0), this._domInputControl.translates(0,
                0), this._domInputControl.style.opacity = "0", this._domInputControl.style.fontSize = "1px", this._domInputControl.setAttribute("tabindex", 2), this._domInputControl.style.position = "absolute", this._domInputControl.style.top = 0, this._domInputControl.style.left = 0, document.body.appendChild(this._domInputControl));
            var a = this;
            cc._addEventListener(this._domInputControl, "input", function() {
                a._processDomInputString(a._domInputControl.value)
            }, !1);
            cc._addEventListener(this._domInputControl, "keydown", function(b) {
                b.keyCode ===
                    cc.KEY.tab ? (b.stopPropagation(), b.preventDefault()) : b.keyCode == cc.KEY.enter && (a.dispatchInsertText("\n", 1), b.stopPropagation(), b.preventDefault())
            }, !1);
            /msie/i.test(navigator.userAgent) && cc._addEventListener(this._domInputControl, "keyup", function(b) {
                b.keyCode == cc.KEY.backspace && a._processDomInputString(a._domInputControl.value)
            }, !1);
            cc._addEventListener(window, "mousedown", function(b) {
                var c = b.pageY || 0;
                a._lastClickPosition.x = b.pageX || 0;
                a._lastClickPosition.y = c
            }, !1)
        }
    },
    _processDomInputString: function(a) {
        var b,
            c;
        b = this._currentInputString.length < a.length ? this._currentInputString.length : a.length;
        for (c = 0; c < b && a[c] === this._currentInputString[c]; c++);
        var d = this._currentInputString.length - c,
            e = a.length - c;
        for (b = 0; b < d; b++) this.dispatchDeleteBackward();
        for (b = 0; b < e; b++) this.dispatchInsertText(a[c + b], 1);
        this._currentInputString = a
    },
    dispatchInsertText: function(a, b) {
        this.impl && a && !(0 >= b) && this.impl._delegateWithIme && this.impl._delegateWithIme.insertText(a, b)
    },
    dispatchDeleteBackward: function() {
        this.impl && this.impl._delegateWithIme &&
            this.impl._delegateWithIme.deleteBackward()
    },
    getContentText: function() {
        if (this.impl && this.impl._delegateWithIme) {
            var a = this.impl._delegateWithIme.getContentText();
            return a ? a : ""
        }
        return ""
    },
    dispatchKeyboardWillShow: function(a) {
        if (this.impl)
            for (var b = 0; b < this.impl._delegateList.length; b++) {
                var c = this.impl._delegateList[b];
                c && c.keyboardWillShow(a)
            }
    },
    dispatchKeyboardDidShow: function(a) {
        if (this.impl)
            for (var b = 0; b < this.impl._delegateList.length; b++) {
                var c = this.impl._delegateList[b];
                c && c.keyboardDidShow(a)
            }
    },
    dispatchKeyboardWillHide: function(a) {
        if (this.impl)
            for (var b = 0; b < this.impl._delegateList.length; b++) {
                var c = this.impl._delegateList[b];
                c && c.keyboardWillHide(a)
            }
    },
    dispatchKeyboardDidHide: function(a) {
        if (this.impl)
            for (var b = 0; b < this.impl._delegateList.length; b++) {
                var c = this.impl._delegateList[b];
                c && c.keyboardDidHide(a)
            }
    },
    addDelegate: function(a) {
        a && this.impl && (-1 < this.impl._delegateList.indexOf(a) || this.impl._delegateList.splice(0, 0, a))
    },
    attachDelegateWithIME: function(a) {
        if (!this.impl || !a || -1 == this.impl._delegateList.indexOf(a)) return !1;
        if (this.impl._delegateWithIme) {
            if (!this.impl._delegateWithIme.canDetachWithIME() || !a.canAttachWithIME()) return !1;
            var b = this.impl._delegateWithIme;
            this.impl._delegateWithIme = null;
            b.didDetachWithIME();
            this._focusDomInput(a);
            return !0
        }
        if (!a.canAttachWithIME()) return !1;
        this._focusDomInput(a);
        return !0
    },
    _focusDomInput: function(a) {
        cc.sys.isMobile ? (this.impl._delegateWithIme = a, a.didAttachWithIME(), this._currentInputString = a.string || "", a = prompt("please enter your word:", this._currentInputString), null != a && this._processDomInputString(a),
            this.dispatchInsertText("\n", 1)) : (this.impl._delegateWithIme = a, this._currentInputString = a.string || "", a.didAttachWithIME(), this._domInputControl.focus(), this._domInputControl.value = this._currentInputString, this._domInputControlTranslate())
    },
    _domInputControlTranslate: function() {
        /msie/i.test(navigator.userAgent) ? (this._domInputControl.style.left = this._lastClickPosition.x + "px", this._domInputControl.style.top = this._lastClickPosition.y + "px") : this._domInputControl.translates(this._lastClickPosition.x, this._lastClickPosition.y)
    },
    detachDelegateWithIME: function(a) {
        if (!this.impl || !a || this.impl._delegateWithIme != a || !a.canDetachWithIME()) return !1;
        this.impl._delegateWithIme = null;
        a.didDetachWithIME();
        cc._canvas.focus();
        return !0
    },
    removeDelegate: function(a) {
        this.impl && a && -1 != this.impl._delegateList.indexOf(a) && (this.impl._delegateWithIme && a == this.impl._delegateWithIme && (this.impl._delegateWithIme = null), cc.arrayRemoveObject(this.impl._delegateList, a))
    },
    processKeycode: function(a) {
        32 > a ? a == cc.KEY.backspace ? this.dispatchDeleteBackward() :
            a == cc.KEY.enter && this.dispatchInsertText("\n", 1) : 255 > a && this.dispatchInsertText(String.fromCharCode(a), 1)
    }
});
cc.IMEDispatcher.Impl = cc.Class.extend({
    _delegateWithIme: null,
    _delegateList: null,
    ctor: function() {
        this._delegateList = []
    },
    findDelegate: function(a) {
        for (var b = 0; b < this._delegateList.length; b++)
            if (this._delegateList[b] == a) return b;
        return null
    }
});
cc.imeDispatcher = new cc.IMEDispatcher;
document.body ? cc.imeDispatcher.init() : cc._addEventListener(window, "load", function() {
    cc.imeDispatcher.init()
}, !1);
cc.TextFieldDelegate = cc.Class.extend({
    onTextFieldAttachWithIME: function(a) {
        return !1
    },
    onTextFieldDetachWithIME: function(a) {
        return !1
    },
    onTextFieldInsertText: function(a, b, c) {
        return !1
    },
    onTextFieldDeleteBackward: function(a, b, c) {
        return !1
    },
    onDraw: function(a) {
        return !1
    }
});
cc.TextFieldTTF = cc.LabelTTF.extend({
    delegate: null,
    colorSpaceHolder: null,
    _colorText: null,
    _lens: null,
    _inputText: "",
    _placeHolder: "",
    _charCount: 0,
    _className: "TextFieldTTF",
    ctor: function(a, b, c, d, e) {
        this.colorSpaceHolder = cc.color(127, 127, 127);
        this._colorText = cc.color(255, 255, 255, 255);
        cc.imeDispatcher.addDelegate(this);
        cc.LabelTTF.prototype.ctor.call(this);
        void 0 !== e ? (this.initWithPlaceHolder("", b, c, d, e), a && this.setPlaceHolder(a)) : void 0 === d && void 0 !== c && (this.initWithString("", b, c), a && this.setPlaceHolder(a))
    },
    getDelegate: function() {
        return this.delegate
    },
    setDelegate: function(a) {
        this.delegate = a
    },
    getCharCount: function() {
        return this._charCount
    },
    getColorSpaceHolder: function() {
        return cc.color(this.colorSpaceHolder)
    },
    setColorSpaceHolder: function(a) {
        this.colorSpaceHolder.r = a.r;
        this.colorSpaceHolder.g = a.g;
        this.colorSpaceHolder.b = a.b;
        this.colorSpaceHolder.a = cc.isUndefined(a.a) ? 255 : a.a
    },
    setTextColor: function(a) {
        this._colorText.r = a.r;
        this._colorText.g = a.g;
        this._colorText.b = a.b;
        this._colorText.a = cc.isUndefined(a.a) ?
            255 : a.a
    },
    initWithPlaceHolder: function(a, b, c, d, e) {
        switch (arguments.length) {
            case 5:
                return a && this.setPlaceHolder(a), this.initWithString(this._placeHolder, d, e, b, c);
            case 3:
                return a && this.setPlaceHolder(a), this.initWithString(this._placeHolder, arguments[1], arguments[2]);
            default:
                throw "Argument must be non-nil ";
        }
    },
    setString: function(a) {
        this._inputText = (a = String(a)) || "";
        this._inputText.length ? (cc.LabelTTF.prototype.setString.call(this, this._inputText), this.setColor(this._colorText)) : (cc.LabelTTF.prototype.setString.call(this,
            this._placeHolder), this.setColor(this.colorSpaceHolder));
        cc._renderType === cc._RENDER_TYPE_CANVAS && this._updateTexture();
        this._charCount = this._inputText.length
    },
    getString: function() {
        return this._inputText
    },
    setPlaceHolder: function(a) {
        this._placeHolder = a || "";
        this._inputText.length || (cc.LabelTTF.prototype.setString.call(this, this._placeHolder), this.setColor(this.colorSpaceHolder))
    },
    getPlaceHolder: function() {
        return this._placeHolder
    },
    draw: function(a) {
        a = a || cc._renderContext;
        (!this.delegate || !this.delegate.onDraw(this)) &&
        cc.LabelTTF.prototype.draw.call(this, a)
    },
    visit: function(a) {
        this._super(a)
    },
    attachWithIME: function() {
        return cc.imeDispatcher.attachDelegateWithIME(this)
    },
    detachWithIME: function() {
        return cc.imeDispatcher.detachDelegateWithIME(this)
    },
    canAttachWithIME: function() {
        return this.delegate ? !this.delegate.onTextFieldAttachWithIME(this) : !0
    },
    didAttachWithIME: function() {},
    canDetachWithIME: function() {
        return this.delegate ? !this.delegate.onTextFieldDetachWithIME(this) : !0
    },
    didDetachWithIME: function() {},
    deleteBackward: function() {
        var a =
            this._inputText.length;
        if (0 != a && (!this.delegate || !this.delegate.onTextFieldDeleteBackward(this, this._inputText[a - 1], 1))) 1 >= a ? (this._inputText = "", this._charCount = 0, cc.LabelTTF.prototype.setString.call(this, this._placeHolder), this.setColor(this.colorSpaceHolder)) : this.string = this._inputText.substring(0, a - 1)
    },
    removeDelegate: function() {
        cc.imeDispatcher.removeDelegate(this)
    },
    insertText: function(a, b) {
        var c = a,
            d = c.indexOf("\n"); - 1 < d && (c = c.substring(0, d));
        if (0 < c.length) {
            if (this.delegate && this.delegate.onTextFieldInsertText(this,
                c, c.length)) return;
            c = this._inputText + c;
            this._charCount = c.length;
            this.string = c
        } - 1 != d && (!this.delegate || !this.delegate.onTextFieldInsertText(this, "\n", 1)) && this.detachWithIME()
    },
    getContentText: function() {
        return this._inputText
    },
    keyboardWillShow: function(a) {},
    keyboardDidShow: function(a) {},
    keyboardWillHide: function(a) {},
    keyboardDidHide: function(a) {}
});
_p = cc.TextFieldTTF.prototype;
cc.defineGetterSetter(_p, "charCount", _p.getCharCount);
cc.defineGetterSetter(_p, "placeHolder", _p.getPlaceHolder, _p.setPlaceHolder);
cc.TextFieldTTF.create = function(a, b, c, d, e) {
    return new cc.TextFieldTTF(a, b, c, d, e)
};
cc.v2fzero = function() {
    return {
        x: 0,
        y: 0
    }
};
cc.v2f = function(a, b) {
    return {
        x: a,
        y: b
    }
};
cc.v2fadd = function(a, b) {
    return cc.v2f(a.x + b.x, a.y + b.y)
};
cc.v2fsub = function(a, b) {
    return cc.v2f(a.x - b.x, a.y - b.y)
};
cc.v2fmult = function(a, b) {
    return cc.v2f(a.x * b, a.y * b)
};
cc.v2fperp = function(a) {
    return cc.v2f(-a.y, a.x)
};
cc.v2fneg = function(a) {
    return cc.v2f(-a.x, -a.y)
};
cc.v2fdot = function(a, b) {
    return a.x * b.x + a.y * b.y
};
cc.v2fforangle = function(a) {
    return cc.v2f(Math.cos(a), Math.sin(a))
};
cc.v2fnormalize = function(a) {
    a = cc.pNormalize(cc.p(a.x, a.y));
    return cc.v2f(a.x, a.y)
};
cc.__v2f = function(a) {
    return cc.v2f(a.x, a.y)
};
cc.__t = function(a) {
    return {
        u: a.x,
        v: a.y
    }
};
cc.DrawNodeCanvas = cc.Node.extend({
    _buffer: null,
    _blendFunc: null,
    _lineWidth: 1,
    _drawColor: null,
    _className: "DrawNodeCanvas",
    ctor: function() {
        cc.Node.prototype.ctor.call(this);
        var a = this._rendererCmd;
        a._buffer = this._buffer = [];
        a._drawColor = this._drawColor = cc.color(255, 255, 255, 255);
        a._blendFunc = this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
        this.init()
    },
    _initRendererCmd: function() {
        this._rendererCmd = new cc.DrawNodeRenderCmdCanvas(this)
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    setBlendFunc: function(a,
        b) {
        void 0 === b ? (this._blendFunc.src = a.src, this._blendFunc.dst = a.dst) : (this._blendFunc.src = a, this._blendFunc.dst = b)
    },
    setLineWidth: function(a) {
        this._lineWidth = a
    },
    getLineWidth: function() {
        return this._lineWidth
    },
    setDrawColor: function(a) {
        var b = this._drawColor;
        b.r = a.r;
        b.g = a.g;
        b.b = a.b;
        b.a = null == a.a ? 255 : a.a
    },
    getDrawColor: function() {
        return cc.color(this._drawColor.r, this._drawColor.g, this._drawColor.b, this._drawColor.a)
    },
    drawRect: function(a, b, c, d, e) {
        d = d || this._lineWidth;
        e = e || this.getDrawColor();
        null == e.a &&
            (e.a = 255);
        a = [a, cc.p(b.x, a.y), b, cc.p(a.x, b.y)];
        b = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
        b.verts = a;
        b.lineWidth = d;
        b.lineColor = e;
        b.isClosePolygon = !0;
        b.isStroke = !0;
        b.lineCap = "butt";
        if (b.fillColor = c) null == c.a && (c.a = 255), b.isFill = !0;
        this._buffer.push(b)
    },
    drawCircle: function(a, b, c, d, e, f, g) {
        f = f || this._lineWidth;
        g = g || this.getDrawColor();
        null == g.a && (g.a = 255);
        for (var h = 2 * Math.PI / d, k = [], m = 0; m <= d; m++) {
            var n = m * h,
                q = b * Math.cos(n + c) + a.x,
                n = b * Math.sin(n + c) + a.y;
            k.push(cc.p(q, n))
        }
        e && k.push(cc.p(a.x, a.y));
        a = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
        a.verts = k;
        a.lineWidth = f;
        a.lineColor = g;
        a.isClosePolygon = !0;
        a.isStroke = !0;
        this._buffer.push(a)
    },
    drawQuadBezier: function(a, b, c, d, e, f) {
        e = e || this._lineWidth;
        f = f || this.getDrawColor();
        null == f.a && (f.a = 255);
        for (var g = [], h = 0, k = 0; k < d; k++) {
            var m = Math.pow(1 - h, 2) * a.x + 2 * (1 - h) * h * b.x + h * h * c.x,
                n = Math.pow(1 - h, 2) * a.y + 2 * (1 - h) * h * b.y + h * h * c.y;
            g.push(cc.p(m, n));
            h += 1 / d
        }
        g.push(cc.p(c.x, c.y));
        a = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
        a.verts = g;
        a.lineWidth = e;
        a.lineColor = f;
        a.isStroke = !0;
        a.lineCap = "round";
        this._buffer.push(a)
    },
    drawCubicBezier: function(a, b, c, d, e, f, g) {
        f = f || this._lineWidth;
        g = g || this.getDrawColor();
        null == g.a && (g.a = 255);
        for (var h = [], k = 0, m = 0; m < e; m++) {
            var n = Math.pow(1 - k, 3) * a.x + 3 * Math.pow(1 - k, 2) * k * b.x + 3 * (1 - k) * k * k * c.x + k * k * k * d.x,
                q = Math.pow(1 - k, 3) * a.y + 3 * Math.pow(1 - k, 2) * k * b.y + 3 * (1 - k) * k * k * c.y + k * k * k * d.y;
            h.push(cc.p(n, q));
            k += 1 / e
        }
        h.push(cc.p(d.x, d.y));
        a = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
        a.verts = h;
        a.lineWidth = f;
        a.lineColor = g;
        a.isStroke = !0;
        a.lineCap = "round";
        this._buffer.push(a)
    },
    drawCatmullRom: function(a, b,
        c, d) {
        this.drawCardinalSpline(a, 0.5, b, c, d)
    },
    drawCardinalSpline: function(a, b, c, d, e) {
        d = d || this._lineWidth;
        e = e || this.getDrawColor();
        null == e.a && (e.a = 255);
        for (var f = [], g, h, k = 1 / a.length, m = 0; m < c + 1; m++) h = m / c, 1 == h ? (g = a.length - 1, h = 1) : (g = 0 | h / k, h = (h - k * g) / k), g = cc.cardinalSplineAt(cc.getControlPointAt(a, g - 1), cc.getControlPointAt(a, g - 0), cc.getControlPointAt(a, g + 1), cc.getControlPointAt(a, g + 2), b, h), f.push(g);
        a = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
        a.verts = f;
        a.lineWidth = d;
        a.lineColor = e;
        a.isStroke = !0;
        a.lineCap =
            "round";
        this._buffer.push(a)
    },
    drawDot: function(a, b, c) {
        c = c || this.getDrawColor();
        null == c.a && (c.a = 255);
        var d = new cc._DrawNodeElement(cc.DrawNode.TYPE_DOT);
        d.verts = [a];
        d.lineWidth = b;
        d.fillColor = c;
        this._buffer.push(d)
    },
    drawDots: function(a, b, c) {
        if (a && 0 != a.length) {
            c = c || this.getDrawColor();
            null == c.a && (c.a = 255);
            for (var d = 0, e = a.length; d < e; d++) this.drawDot(a[d], b, c)
        }
    },
    drawSegment: function(a, b, c, d) {
        c = c || this._lineWidth;
        d = d || this.getDrawColor();
        null == d.a && (d.a = 255);
        var e = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
        e.verts = [a, b];
        e.lineWidth = 2 * c;
        e.lineColor = d;
        e.isStroke = !0;
        e.lineCap = "round";
        this._buffer.push(e)
    },
    drawPoly_: function(a, b, c, d) {
        c = c || this._lineWidth;
        d = d || this.getDrawColor();
        null == d.a && (d.a = 255);
        var e = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
        e.verts = a;
        e.fillColor = b;
        e.lineWidth = c;
        e.lineColor = d;
        e.isClosePolygon = !0;
        e.isStroke = !0;
        e.lineCap = "round";
        b && (e.isFill = !0);
        this._buffer.push(e)
    },
    drawPoly: function(a, b, c, d) {
        for (var e = [], f = 0; f < a.length; f++) e.push(cc.p(a[f].x, a[f].y));
        return this.drawPoly_(e, b,
            c, d)
    },
    draw: function(a) {
        a = a || cc._renderContext;
        this._blendFunc && (this._blendFunc.src == cc.SRC_ALPHA && this._blendFunc.dst == cc.ONE) && (a.globalCompositeOperation = "lighter");
        for (var b = 0; b < this._buffer.length; b++) {
            var c = this._buffer[b];
            switch (c.type) {
                case cc.DrawNode.TYPE_DOT:
                    this._drawDot(a, c);
                    break;
                case cc.DrawNode.TYPE_SEGMENT:
                    this._drawSegment(a, c);
                    break;
                case cc.DrawNode.TYPE_POLY:
                    this._drawPoly(a, c)
            }
        }
    },
    _drawDot: function(a, b) {
        var c = b.fillColor,
            d = b.verts[0],
            e = b.lineWidth,
            f = cc.view.getScaleX(),
            g = cc.view.getScaleY();
        a.fillStyle = "rgba(" + (0 | c.r) + "," + (0 | c.g) + "," + (0 | c.b) + "," + c.a / 255 + ")";
        a.beginPath();
        a.arc(d.x * f, -d.y * g, e * f, 0, 2 * Math.PI, !1);
        a.closePath();
        a.fill()
    },
    _drawSegment: function(a, b) {
        var c = b.lineColor,
            d = b.verts[0],
            e = b.verts[1],
            f = b.lineWidth,
            g = b.lineCap,
            h = cc.view.getScaleX(),
            k = cc.view.getScaleY();
        a.strokeStyle = "rgba(" + (0 | c.r) + "," + (0 | c.g) + "," + (0 | c.b) + "," + c.a / 255 + ")";
        a.lineWidth = f * h;
        a.beginPath();
        a.lineCap = g;
        a.moveTo(d.x * h, -d.y * k);
        a.lineTo(e.x * h, -e.y * k);
        a.stroke()
    },
    _drawPoly: function(a, b) {
        var c = b.verts,
            d = b.lineCap,
            e = b.fillColor,
            f = b.lineWidth,
            g = b.lineColor,
            h = b.isClosePolygon,
            k = b.isFill,
            m = b.isStroke;
        if (null != c) {
            var n = c[0],
                q = cc.view.getScaleX(),
                r = cc.view.getScaleY();
            a.lineCap = d;
            e && (a.fillStyle = "rgba(" + (0 | e.r) + "," + (0 | e.g) + "," + (0 | e.b) + "," + e.a / 255 + ")");
            f && (a.lineWidth = f * q);
            g && (a.strokeStyle = "rgba(" + (0 | g.r) + "," + (0 | g.g) + "," + (0 | g.b) + "," + g.a / 255 + ")");
            a.beginPath();
            a.moveTo(n.x * q, -n.y * r);
            d = 1;
            for (e = c.length; d < e; d++) a.lineTo(c[d].x * q, -c[d].y * r);
            h && a.closePath();
            k && a.fill();
            m && a.stroke()
        }
    },
    clear: function() {
        this._buffer.length =
            0
    }
});
cc.DrawNodeWebGL = cc.Node.extend({
    _bufferCapacity: 0,
    _buffer: null,
    _trianglesArrayBuffer: null,
    _trianglesWebBuffer: null,
    _trianglesReader: null,
    _lineWidth: 1,
    _drawColor: null,
    _blendFunc: null,
    _dirty: !1,
    _className: "DrawNodeWebGL",
    getBlendFunc: function() {
        return this._blendFunc
    },
    setBlendFunc: function(a, b) {
        void 0 === b ? (this._blendFunc.src = a.src, this._blendFunc.dst = a.dst) : (this._blendFunc.src = a, this._blendFunc.dst = b)
    },
    ctor: function() {
        cc.Node.prototype.ctor.call(this);
        this._buffer = [];
        this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
        this._drawColor = cc.color(255, 255, 255, 255);
        this.init()
    },
    _initRendererCmd: function() {
        this._rendererCmd = new cc.DrawNodeRenderCmdWebGL(this)
    },
    init: function() {
        return cc.Node.prototype.init.call(this) ? (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_LENGTHTEXTURECOLOR), this._ensureCapacity(64), this._trianglesWebBuffer = cc._renderContext.createBuffer(), this._dirty = !0) : !1
    },
    setLineWidth: function(a) {
        this._lineWidth = a
    },
    getLineWidth: function() {
        return this._lineWidth
    },
    setDrawColor: function(a) {
        var b =
            this._drawColor;
        b.r = a.r;
        b.g = a.g;
        b.b = a.b;
        b.a = a.a
    },
    getDrawColor: function() {
        return cc.color(this._drawColor.r, this._drawColor.g, this._drawColor.b, this._drawColor.a)
    },
    drawRect: function(a, b, c, d, e) {
        d = d || this._lineWidth;
        e = e || this.getDrawColor();
        null == e.a && (e.a = 255);
        a = [a, cc.p(b.x, a.y), b, cc.p(a.x, b.y)];
        null == c ? this._drawSegments(a, d, e, !0) : this.drawPoly(a, c, d, e)
    },
    drawCircle: function(a, b, c, d, e, f, g) {
        f = f || this._lineWidth;
        g = g || this.getDrawColor();
        null == g.a && (g.a = 255);
        var h = 2 * Math.PI / d,
            k = [],
            m;
        for (m = 0; m <= d; m++) {
            var n =
                m * h,
                q = b * Math.cos(n + c) + a.x,
                n = b * Math.sin(n + c) + a.y;
            k.push(cc.p(q, n))
        }
        e && k.push(cc.p(a.x, a.y));
        f *= 0.5;
        m = 0;
        for (a = k.length; m < a - 1; m++) this.drawSegment(k[m], k[m + 1], f, g)
    },
    drawQuadBezier: function(a, b, c, d, e, f) {
        e = e || this._lineWidth;
        f = f || this.getDrawColor();
        null == f.a && (f.a = 255);
        for (var g = [], h = 0, k = 0; k < d; k++) {
            var m = Math.pow(1 - h, 2) * a.x + 2 * (1 - h) * h * b.x + h * h * c.x,
                n = Math.pow(1 - h, 2) * a.y + 2 * (1 - h) * h * b.y + h * h * c.y;
            g.push(cc.p(m, n));
            h += 1 / d
        }
        g.push(cc.p(c.x, c.y));
        this._drawSegments(g, e, f, !1)
    },
    drawCubicBezier: function(a, b, c, d, e, f,
        g) {
        f = f || this._lineWidth;
        g = g || this.getDrawColor();
        null == g.a && (g.a = 255);
        for (var h = [], k = 0, m = 0; m < e; m++) {
            var n = Math.pow(1 - k, 3) * a.x + 3 * Math.pow(1 - k, 2) * k * b.x + 3 * (1 - k) * k * k * c.x + k * k * k * d.x,
                q = Math.pow(1 - k, 3) * a.y + 3 * Math.pow(1 - k, 2) * k * b.y + 3 * (1 - k) * k * k * c.y + k * k * k * d.y;
            h.push(cc.p(n, q));
            k += 1 / e
        }
        h.push(cc.p(d.x, d.y));
        this._drawSegments(h, f, g, !1)
    },
    drawCatmullRom: function(a, b, c, d) {
        this.drawCardinalSpline(a, 0.5, b, c, d)
    },
    drawCardinalSpline: function(a, b, c, d, e) {
        d = d || this._lineWidth;
        e = e || this.getDrawColor();
        null == e.a && (e.a = 255);
        for (var f = [], g, h, k = 1 / a.length, m = 0; m < c + 1; m++) h = m / c, 1 == h ? (g = a.length - 1, h = 1) : (g = 0 | h / k, h = (h - k * g) / k), g = cc.cardinalSplineAt(cc.getControlPointAt(a, g - 1), cc.getControlPointAt(a, g - 0), cc.getControlPointAt(a, g + 1), cc.getControlPointAt(a, g + 2), b, h), f.push(g);
        d *= 0.5;
        a = 0;
        for (b = f.length; a < b - 1; a++) this.drawSegment(f[a], f[a + 1], d, e)
    },
    _render: function() {
        var a = cc._renderContext;
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
        a.bindBuffer(a.ARRAY_BUFFER, this._trianglesWebBuffer);
        this._dirty && (a.bufferData(a.ARRAY_BUFFER,
            this._trianglesArrayBuffer, a.STREAM_DRAW), this._dirty = !1);
        var b = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, b, 0);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, b, 8);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, b, 12);
        a.drawArrays(a.TRIANGLES, 0, 3 * this._buffer.length);
        cc.incrementGLDraws(1)
    },
    _ensureCapacity: function(a) {
        var b = this._buffer;
        if (b.length + a > this._bufferCapacity) {
            var c = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT;
            this._bufferCapacity += Math.max(this._bufferCapacity, a);
            if (null == b || 0 === b.length) this._buffer = [], this._trianglesArrayBuffer = new ArrayBuffer(c * this._bufferCapacity), this._trianglesReader = new Uint8Array(this._trianglesArrayBuffer);
            else {
                a = [];
                for (var d = new ArrayBuffer(c * this._bufferCapacity), e = 0; e < b.length; e++) a[e] = new cc.V2F_C4B_T2F_Triangle(b[e].a, b[e].b, b[e].c, d, e * c);
                this._trianglesReader = new Uint8Array(d);
                this._trianglesArrayBuffer = d;
                this._buffer = a
            }
        }
    },
    draw: function() {
        cc.glBlendFunc(this._blendFunc.src,
            this._blendFunc.dst);
        this._shaderProgram.use();
        this._shaderProgram.setUniformsForBuiltins();
        this._render()
    },
    drawDot: function(a, b, c) {
        c = c || this.getDrawColor();
        null == c.a && (c.a = 255);
        var d = {
            r: 0 | c.r,
            g: 0 | c.g,
            b: 0 | c.b,
            a: 0 | c.a
        };
        c = {
            vertices: {
                x: a.x - b,
                y: a.y - b
            },
            colors: d,
            texCoords: {
                u: -1,
                v: -1
            }
        };
        var e = {
                vertices: {
                    x: a.x - b,
                    y: a.y + b
                },
                colors: d,
                texCoords: {
                    u: -1,
                    v: 1
                }
            },
            f = {
                vertices: {
                    x: a.x + b,
                    y: a.y + b
                },
                colors: d,
                texCoords: {
                    u: 1,
                    v: 1
                }
            };
        a = {
            vertices: {
                x: a.x + b,
                y: a.y - b
            },
            colors: d,
            texCoords: {
                u: 1,
                v: -1
            }
        };
        this._ensureCapacity(6);
        this._buffer.push(new cc.V2F_C4B_T2F_Triangle(c,
            e, f, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT));
        this._buffer.push(new cc.V2F_C4B_T2F_Triangle(c, f, a, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT));
        this._dirty = !0
    },
    drawDots: function(a, b, c) {
        if (a && 0 != a.length) {
            c = c || this.getDrawColor();
            null == c.a && (c.a = 255);
            for (var d = 0, e = a.length; d < e; d++) this.drawDot(a[d], b, c)
        }
    },
    drawSegment: function(a, b, c, d) {
        d = d || this.getDrawColor();
        null == d.a && (d.a = 255);
        c = c || 0.5 * this._lineWidth;
        this._ensureCapacity(18);
        d = {
            r: 0 | d.r,
            g: 0 | d.g,
            b: 0 | d.b,
            a: 0 | d.a
        };
        var e = cc.__v2f(a),
            f = cc.__v2f(b);
        b = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(f, e)));
        a = cc.v2fperp(b);
        var g = cc.v2fmult(b, c),
            h = cc.v2fmult(a, c);
        c = cc.v2fsub(f, cc.v2fadd(g, h));
        var k = cc.v2fadd(f, cc.v2fsub(g, h)),
            m = cc.v2fsub(f, g),
            f = cc.v2fadd(f, g),
            n = cc.v2fsub(e, g),
            q = cc.v2fadd(e, g),
            r = cc.v2fsub(e, cc.v2fsub(g, h)),
            e = cc.v2fadd(e, cc.v2fadd(g, h)),
            g = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT,
            h = this._trianglesArrayBuffer,
            s = this._buffer;
        s.push(new cc.V2F_C4B_T2F_Triangle({
            vertices: c,
            colors: d,
            texCoords: cc.__t(cc.v2fneg(cc.v2fadd(b, a)))
        }, {
            vertices: k,
            colors: d,
            texCoords: cc.__t(cc.v2fsub(b, a))
        }, {
            vertices: m,
            colors: d,
            texCoords: cc.__t(cc.v2fneg(b))
        }, h, s.length * g));
        s.push(new cc.V2F_C4B_T2F_Triangle({
            vertices: f,
            colors: d,
            texCoords: cc.__t(b)
        }, {
            vertices: k,
            colors: d,
            texCoords: cc.__t(cc.v2fsub(b, a))
        }, {
            vertices: m,
            colors: d,
            texCoords: cc.__t(cc.v2fneg(b))
        }, h, s.length * g));
        s.push(new cc.V2F_C4B_T2F_Triangle({
            vertices: f,
            colors: d,
            texCoords: cc.__t(b)
        }, {
            vertices: n,
            colors: d,
            texCoords: cc.__t(cc.v2fneg(b))
        }, {
            vertices: m,
            colors: d,
            texCoords: cc.__t(cc.v2fneg(b))
        }, h, s.length * g));
        s.push(new cc.V2F_C4B_T2F_Triangle({
            vertices: f,
            colors: d,
            texCoords: cc.__t(b)
        }, {
            vertices: n,
            colors: d,
            texCoords: cc.__t(cc.v2fneg(b))
        }, {
            vertices: q,
            colors: d,
            texCoords: cc.__t(b)
        }, h, s.length * g));
        s.push(new cc.V2F_C4B_T2F_Triangle({
            vertices: r,
            colors: d,
            texCoords: cc.__t(cc.v2fsub(a, b))
        }, {
            vertices: n,
            colors: d,
            texCoords: cc.__t(cc.v2fneg(b))
        }, {
            vertices: q,
            colors: d,
            texCoords: cc.__t(b)
        }, h, s.length * g));
        s.push(new cc.V2F_C4B_T2F_Triangle({
            vertices: r,
            colors: d,
            texCoords: cc.__t(cc.v2fsub(a, b))
        }, {
            vertices: e,
            colors: d,
            texCoords: cc.__t(cc.v2fadd(b, a))
        }, {
            vertices: q,
            colors: d,
            texCoords: cc.__t(b)
        }, h, s.length * g));
        this._dirty = !0
    },
    drawPoly: function(a, b, c, d) {
        if (null == b) this._drawSegments(a, c, d, !0);
        else {
            null == b.a && (b.a = 255);
            null == d.a && (d.a = 255);
            c = c || this._lineWidth;
            c *= 0.5;
            b = {
                r: 0 | b.r,
                g: 0 | b.g,
                b: 0 | b.b,
                a: 0 | b.a
            };
            d = {
                r: 0 | d.r,
                g: 0 | d.g,
                b: 0 | d.b,
                a: 0 | d.a
            };
            var e = [],
                f, g, h, k, m = a.length;
            for (f = 0; f < m; f++) {
                g = cc.__v2f(a[(f - 1 + m) % m]);
                h = cc.__v2f(a[f]);
                k = cc.__v2f(a[(f + 1) % m]);
                var n =
                    cc.v2fnormalize(cc.v2fperp(cc.v2fsub(h, g)));
                h = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(k, h)));
                n = cc.v2fmult(cc.v2fadd(n, h), 1 / (cc.v2fdot(n, h) + 1));
                e[f] = {
                    offset: n,
                    n: h
                }
            }
            n = 0 < c;
            this._ensureCapacity(3 * (3 * m - 2));
            var q = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT,
                r = this._trianglesArrayBuffer,
                s = this._buffer,
                t = !1 == n ? 0.5 : 0;
            for (f = 0; f < m - 2; f++) g = cc.v2fsub(cc.__v2f(a[0]), cc.v2fmult(e[0].offset, t)), h = cc.v2fsub(cc.__v2f(a[f + 1]), cc.v2fmult(e[f + 1].offset, t)), k = cc.v2fsub(cc.__v2f(a[f + 2]), cc.v2fmult(e[f + 2].offset, t)), s.push(new cc.V2F_C4B_T2F_Triangle({
                vertices: g,
                colors: b,
                texCoords: cc.__t(cc.v2fzero())
            }, {
                vertices: h,
                colors: b,
                texCoords: cc.__t(cc.v2fzero())
            }, {
                vertices: k,
                colors: b,
                texCoords: cc.__t(cc.v2fzero())
            }, r, s.length * q));
            for (f = 0; f < m; f++) {
                t = (f + 1) % m;
                g = cc.__v2f(a[f]);
                h = cc.__v2f(a[t]);
                k = e[f].n;
                var u = e[f].offset,
                    w = e[t].offset,
                    t = n ? cc.v2fsub(g, cc.v2fmult(u, c)) : cc.v2fsub(g, cc.v2fmult(u, 0.5)),
                    v = n ? cc.v2fsub(h, cc.v2fmult(w, c)) : cc.v2fsub(h, cc.v2fmult(w, 0.5));
                g = n ? cc.v2fadd(g, cc.v2fmult(u, c)) : cc.v2fadd(g, cc.v2fmult(u, 0.5));
                h = n ? cc.v2fadd(h, cc.v2fmult(w, c)) : cc.v2fadd(h,
                    cc.v2fmult(w, 0.5));
                n ? (s.push(new cc.V2F_C4B_T2F_Triangle({
                    vertices: t,
                    colors: d,
                    texCoords: cc.__t(cc.v2fneg(k))
                }, {
                    vertices: v,
                    colors: d,
                    texCoords: cc.__t(cc.v2fneg(k))
                }, {
                    vertices: h,
                    colors: d,
                    texCoords: cc.__t(k)
                }, r, s.length * q)), s.push(new cc.V2F_C4B_T2F_Triangle({
                    vertices: t,
                    colors: d,
                    texCoords: cc.__t(cc.v2fneg(k))
                }, {
                    vertices: g,
                    colors: d,
                    texCoords: cc.__t(k)
                }, {
                    vertices: h,
                    colors: d,
                    texCoords: cc.__t(k)
                }, r, s.length * q))) : (s.push(new cc.V2F_C4B_T2F_Triangle({
                    vertices: t,
                    colors: b,
                    texCoords: cc.__t(cc.v2fzero())
                }, {
                    vertices: v,
                    colors: b,
                    texCoords: cc.__t(cc.v2fzero())
                }, {
                    vertices: h,
                    colors: b,
                    texCoords: cc.__t(k)
                }, r, s.length * q)), s.push(new cc.V2F_C4B_T2F_Triangle({
                    vertices: t,
                    colors: b,
                    texCoords: cc.__t(cc.v2fzero())
                }, {
                    vertices: g,
                    colors: b,
                    texCoords: cc.__t(k)
                }, {
                    vertices: h,
                    colors: b,
                    texCoords: cc.__t(k)
                }, r, s.length * q)))
            }
            this._dirty = !0
        }
    },
    _drawSegments: function(a, b, c, d) {
        b = b || this._lineWidth;
        c = c || this._drawColor;
        null == c.a && (c.a = 255);
        b *= 0.5;
        if (!(0 >= b)) {
            c = {
                r: 0 | c.r,
                g: 0 | c.g,
                b: 0 | c.b,
                a: 0 | c.a
            };
            var e = [],
                f, g, h, k, m = a.length;
            for (f = 0; f < m; f++) {
                g = cc.__v2f(a[(f -
                    1 + m) % m]);
                h = cc.__v2f(a[f]);
                k = cc.__v2f(a[(f + 1) % m]);
                var n = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(h, g)));
                h = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(k, h)));
                k = cc.v2fmult(cc.v2fadd(n, h), 1 / (cc.v2fdot(n, h) + 1));
                e[f] = {
                    offset: k,
                    n: h
                }
            }
            this._ensureCapacity(3 * (3 * m - 2));
            k = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT;
            var n = this._trianglesArrayBuffer,
                q = this._buffer;
            d = d ? m : m - 1;
            for (f = 0; f < d; f++) {
                var r = (f + 1) % m;
                g = cc.__v2f(a[f]);
                h = cc.__v2f(a[r]);
                var s = e[f].n,
                    t = e[f].offset,
                    u = e[r].offset,
                    r = cc.v2fsub(g, cc.v2fmult(t, b)),
                    w = cc.v2fsub(h, cc.v2fmult(u,
                        b));
                g = cc.v2fadd(g, cc.v2fmult(t, b));
                h = cc.v2fadd(h, cc.v2fmult(u, b));
                q.push(new cc.V2F_C4B_T2F_Triangle({
                    vertices: r,
                    colors: c,
                    texCoords: cc.__t(cc.v2fneg(s))
                }, {
                    vertices: w,
                    colors: c,
                    texCoords: cc.__t(cc.v2fneg(s))
                }, {
                    vertices: h,
                    colors: c,
                    texCoords: cc.__t(s)
                }, n, q.length * k));
                q.push(new cc.V2F_C4B_T2F_Triangle({
                    vertices: r,
                    colors: c,
                    texCoords: cc.__t(cc.v2fneg(s))
                }, {
                    vertices: g,
                    colors: c,
                    texCoords: cc.__t(s)
                }, {
                    vertices: h,
                    colors: c,
                    texCoords: cc.__t(s)
                }, n, q.length * k))
            }
            this._dirty = !0
        }
    },
    clear: function() {
        this._buffer.length =
            0;
        this._dirty = !0
    }
});
cc.DrawNode = cc._renderType == cc._RENDER_TYPE_WEBGL ? cc.DrawNodeWebGL : cc.DrawNodeCanvas;
cc.DrawNode.create = function() {
    return new cc.DrawNode
};
cc._DrawNodeElement = function(a, b, c, d, e, f, g, h, k) {
    this.type = a;
    this.verts = b || null;
    this.fillColor = c || null;
    this.lineWidth = d || 0;
    this.lineColor = e || null;
    this.lineCap = f || "butt";
    this.isClosePolygon = g || !1;
    this.isFill = h || !1;
    this.isStroke = k || !1
};
cc.DrawNode.TYPE_DOT = 0;
cc.DrawNode.TYPE_SEGMENT = 1;
cc.DrawNode.TYPE_POLY = 2;
cc.stencilBits = -1;
cc.ClippingNode = cc.Node.extend({
    alphaThreshold: 0,
    inverted: !1,
    _rendererSaveCmd: null,
    _rendererClipCmd: null,
    _rendererRestoreCmd: null,
    _beforeVisitCmd: null,
    _afterDrawStencilCmd: null,
    _afterVisitCmd: null,
    _stencil: null,
    _godhelpme: !1,
    _clipElemType: null,
    _currentStencilFunc: null,
    _currentStencilRef: null,
    _currentStencilValueMask: null,
    _currentStencilFail: null,
    _currentStencilPassDepthFail: null,
    _currentStencilPassDepthPass: null,
    _currentStencilWriteMask: null,
    _currentStencilEnabled: null,
    _currentDepthWriteMask: null,
    _mask_layer_le: null,
    ctor: function(a) {
        cc.Node.prototype.ctor.call(this);
        this._stencil = null;
        this.alphaThreshold = 0;
        this.inverted = !1;
        cc.ClippingNode.prototype.init.call(this, a || null)
    },
    _initRendererCmd: function() {
        cc._renderType === cc._RENDER_TYPE_CANVAS ? (this._rendererSaveCmd = new cc.ClippingNodeSaveRenderCmdCanvas(this), this._rendererClipCmd = new cc.ClippingNodeClipRenderCmdCanvas(this), this._rendererRestoreCmd = new cc.ClippingNodeRestoreRenderCmdCanvas(this)) : (this._beforeVisitCmd = new cc.CustomRenderCmdWebGL(this, this._onBeforeVisit),
            this._afterDrawStencilCmd = new cc.CustomRenderCmdWebGL(this, this._onAfterDrawStencil), this._afterVisitCmd = new cc.CustomRenderCmdWebGL(this, this._onAfterVisit))
    },
    init: null,
    _className: "ClippingNode",
    _initForWebGL: function(a) {
        this._stencil = a;
        this.alphaThreshold = 1;
        this.inverted = !1;
        cc.ClippingNode._init_once = !0;
        cc.ClippingNode._init_once && (cc.stencilBits = cc._renderContext.getParameter(cc._renderContext.STENCIL_BITS), 0 >= cc.stencilBits && cc.log("Stencil buffer is not enabled."), cc.ClippingNode._init_once = !1);
        return !0
    },
    _initForCanvas: function(a) {
        this._stencil = a;
        this.alphaThreshold = 1;
        this.inverted = !1
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this);
        this._stencil.onEnter()
    },
    onEnterTransitionDidFinish: function() {
        cc.Node.prototype.onEnterTransitionDidFinish.call(this);
        this._stencil.onEnterTransitionDidFinish()
    },
    onExitTransitionDidStart: function() {
        this._stencil.onExitTransitionDidStart();
        cc.Node.prototype.onExitTransitionDidStart.call(this)
    },
    onExit: function() {
        this._stencil.onExit();
        cc.Node.prototype.onExit.call(this)
    },
    visit: null,
    _visitForWebGL: function(a) {
        if (1 > cc.stencilBits) cc.Node.prototype.visit.call(this, a);
        else if (!this._stencil || !this._stencil.visible) this.inverted && cc.Node.prototype.visit.call(this, a);
        else if (cc.ClippingNode._layer + 1 == cc.stencilBits) cc.ClippingNode._visit_once = !0, cc.ClippingNode._visit_once && (cc.log("Nesting more than " + cc.stencilBits + "stencils is not supported. Everything will be drawn without stencil for this node and its childs."), cc.ClippingNode._visit_once = !1), cc.Node.prototype.visit.call(this,
            a);
        else {
            cc.renderer.pushRenderCommand(this._beforeVisitCmd);
            a = cc.current_stack;
            a.stack.push(a.top);
            cc.kmMat4Assign(this._stackMatrix, a.top);
            a.top = this._stackMatrix;
            this.transform();
            this._stencil.visit();
            cc.renderer.pushRenderCommand(this._afterDrawStencilCmd);
            var b = this._children;
            if (b && 0 < b.length) {
                var c = b.length;
                this.sortAllChildren();
                for (var d = 0; d < c; d++)
                    if (b[d] && 0 > b[d]._localZOrder) b[d].visit();
                    else break;
                for (this._rendererCmd && cc.renderer.pushRenderCommand(this._rendererCmd); d < c; d++) b[d] && b[d].visit()
            } else this._rendererCmd &&
                cc.renderer.pushRenderCommand(this._rendererCmd);
            cc.renderer.pushRenderCommand(this._afterVisitCmd);
            a.top = a.stack.pop()
        }
    },
    _onBeforeVisit: function(a) {
        a = a || cc._renderContext;
        cc.ClippingNode._layer++;
        var b = 1 << cc.ClippingNode._layer;
        this._mask_layer_le = b | b - 1;
        this._currentStencilEnabled = a.isEnabled(a.STENCIL_TEST);
        this._currentStencilWriteMask = a.getParameter(a.STENCIL_WRITEMASK);
        this._currentStencilFunc = a.getParameter(a.STENCIL_FUNC);
        this._currentStencilRef = a.getParameter(a.STENCIL_REF);
        this._currentStencilValueMask =
            a.getParameter(a.STENCIL_VALUE_MASK);
        this._currentStencilFail = a.getParameter(a.STENCIL_FAIL);
        this._currentStencilPassDepthFail = a.getParameter(a.STENCIL_PASS_DEPTH_FAIL);
        this._currentStencilPassDepthPass = a.getParameter(a.STENCIL_PASS_DEPTH_PASS);
        a.enable(a.STENCIL_TEST);
        a.stencilMask(b);
        this._currentDepthWriteMask = a.getParameter(a.DEPTH_WRITEMASK);
        a.depthMask(!1);
        a.stencilFunc(a.NEVER, b, b);
        a.stencilOp(!this.inverted ? a.ZERO : a.REPLACE, a.KEEP, a.KEEP);
        this._drawFullScreenQuadClearStencil();
        a.stencilFunc(a.NEVER,
            b, b);
        a.stencilOp(!this.inverted ? a.REPLACE : a.ZERO, a.KEEP, a.KEEP);
        1 > this.alphaThreshold && (b = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST), a = a.getUniformLocation(b.getProgram(), cc.UNIFORM_ALPHA_TEST_VALUE_S), cc.glUseProgram(b.getProgram()), b.setUniformLocationWith1f(a, this.alphaThreshold), cc.setProgram(this._stencil, b))
    },
    _drawFullScreenQuadClearStencil: function() {
        cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
        cc.kmGLPushMatrix();
        cc.kmGLLoadIdentity();
        cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
        cc.kmGLPushMatrix();
        cc.kmGLLoadIdentity();
        cc._drawingUtil.drawSolidRect(cc.p(-1, -1), cc.p(1, 1), cc.color(255, 255, 255, 255));
        cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
        cc.kmGLPopMatrix();
        cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
        cc.kmGLPopMatrix()
    },
    _onAfterDrawStencil: function(a) {
        a = a || cc._renderContext;
        a.depthMask(this._currentDepthWriteMask);
        a.stencilFunc(a.EQUAL, this._mask_layer_le, this._mask_layer_le);
        a.stencilOp(a.KEEP, a.KEEP, a.KEEP)
    },
    _onAfterVisit: function(a) {
        a = a || cc._renderContext;
        a.stencilFunc(this._currentStencilFunc,
            this._currentStencilRef, this._currentStencilValueMask);
        a.stencilOp(this._currentStencilFail, this._currentStencilPassDepthFail, this._currentStencilPassDepthPass);
        a.stencilMask(this._currentStencilWriteMask);
        this._currentStencilEnabled || a.disable(a.STENCIL_TEST);
        cc.ClippingNode._layer--
    },
    _visitForCanvas: function(a) {
        this._clipElemType = this._cangodhelpme() || this._stencil instanceof cc.Sprite;
        var b = a || cc._renderContext,
            c = this._children,
            d;
        if (!this._stencil || !this._stencil.visible) this.inverted && cc.Node.prototype.visit.call(this,
            a);
        else {
            this._rendererSaveCmd && cc.renderer.pushRenderCommand(this._rendererSaveCmd);
            this._clipElemType ? cc.Node.prototype.visit.call(this, b) : this._stencil.visit(b);
            this._rendererClipCmd && cc.renderer.pushRenderCommand(this._rendererClipCmd);
            this.transform();
            if (this._clipElemType) this._stencil.visit();
            else {
                this._cangodhelpme(!0);
                var e = c.length;
                if (0 < e) {
                    this.sortAllChildren();
                    for (a = 0; a < e; a++)
                        if (d = c[a], 0 > d._localZOrder) d.visit(b);
                        else break;
                    for (this._rendererCmd && cc.renderer.pushRenderCommand(this._rendererCmd); a <
                        e; a++) c[a].visit(b)
                } else this._rendererCmd && cc.renderer.pushRenderCommand(this._rendererCmd);
                this._cangodhelpme(!1)
            }
            this._rendererRestoreCmd && cc.renderer.pushRenderCommand(this._rendererRestoreCmd)
        }
    },
    getStencil: function() {
        return this._stencil
    },
    setStencil: null,
    _setStencilForWebGL: function(a) {
        if (this._stencil != a && (this._stencil && (this._stencil._parent = null), this._stencil = a)) this._stencil._parent = this
    },
    _setStencilForCanvas: function(a) {
        this._stencil = a;
        if (a._buffer)
            for (var b = 0; b < a._buffer.length; b++) a._buffer[b].isFill = !1, a._buffer[b].isStroke = !1;
        a instanceof cc.DrawNode && (a._rendererCmd.rendering = function(b, d, e) {
            d = d || cc.view.getScaleX();
            e = e || cc.view.getScaleY();
            b = b || cc._renderContext;
            var f = this._node._transformWorld;
            b.save();
            b.beginPath();
            for (var g = 0; g < a._buffer.length; g++) {
                var h = a._buffer[g].verts;
                b.transform(f.a, f.b, f.c, f.d, f.tx, -f.ty);
                var k = h[0];
                b.moveTo(k.x * d, -k.y * e);
                for (var k = 1, m = h.length; k < m; k++) b.lineTo(h[k].x * d, -h[k].y * e)
            }
            b.restore()
        })
    },
    getAlphaThreshold: function() {
        return this.alphaThreshold
    },
    setAlphaThreshold: function(a) {
        this.alphaThreshold =
            a
    },
    isInverted: function() {
        return this.inverted
    },
    setInverted: function(a) {
        this.inverted = a
    },
    _cangodhelpme: function(a) {
        if (!0 === a || !1 === a) cc.ClippingNode.prototype._godhelpme = a;
        return cc.ClippingNode.prototype._godhelpme
    },
    _transformForRenderer: function(a) {
        cc.Node.prototype._transformForRenderer.call(this, a);
        this._stencil && this._stencil._transformForRenderer(this._stackMatrix)
    }
});
_p = cc.ClippingNode.prototype;
cc._renderType === cc._RENDER_TYPE_WEBGL ? (_p.init = _p._initForWebGL, _p.visit = _p._visitForWebGL, _p.setStencil = _p._setStencilForWebGL) : (_p.init = _p._initForCanvas, _p.visit = _p._visitForCanvas, _p.setStencil = _p._setStencilForCanvas);
cc.defineGetterSetter(_p, "stencil", _p.getStencil, _p.setStencil);
cc.ClippingNode._init_once = null;
cc.ClippingNode._visit_once = null;
cc.ClippingNode._layer = -1;
cc.ClippingNode._sharedCache = null;
cc.ClippingNode._getSharedCache = function() {
    return cc.ClippingNode._sharedCache || (cc.ClippingNode._sharedCache = document.createElement("canvas"))
};
cc.ClippingNode.create = function(a) {
    return new cc.ClippingNode(a)
};
cc.ProtectedNode = cc.Node.extend({
    _protectedChildren: null,
    _reorderProtectedChildDirty: !1,
    _insertProtectedChild: function(a, b) {
        this._reorderProtectedChildDirty = !0;
        this._protectedChildren.push(a);
        a._setLocalZOrder(b)
    },
    ctor: function() {
        cc.Node.prototype.ctor.call(this);
        this._protectedChildren = []
    },
    addProtectedChild: function(a, b, c) {
        cc.assert(null != a, "child must be non-nil");
        cc.assert(!a.parent, "child already added. It can't be added again");
        b = b || a.getLocalZOrder();
        c && a.setTag(c);
        this._insertProtectedChild(a,
            b);
        a.setParent(this);
        a.setOrderOfArrival(cc.s_globalOrderOfArrival);
        if (this._running && (a.onEnter(), this._isTransitionFinished)) a.onEnterTransitionDidFinish();
        this._cascadeColorEnabled && this._enableCascadeColor();
        this._cascadeOpacityEnabled && this._enableCascadeOpacity()
    },
    getProtectedChildByTag: function(a) {
        cc.assert(a != cc.NODE_TAG_INVALID, "Invalid tag");
        for (var b = this._protectedChildren, c = 0, d = b.length; c < d; c++)
            if (b.getTag() == a) return b[c];
        return null
    },
    removeProtectedChild: function(a, b) {
        null == b && (b = !0);
        var c = this._protectedChildren;
        if (0 !== c.length) {
            var d = c.indexOf(a); - 1 < d && (this._running && (a.onExitTransitionDidStart(), a.onExit()), b && a.cleanup(), a.setParent(null), c.splice(d, 1))
        }
    },
    removeProtectedChildByTag: function(a, b) {
        cc.assert(a != cc.NODE_TAG_INVALID, "Invalid tag");
        null == b && (b = !0);
        var c = this.getProtectedChildByTag(a);
        null == c ? cc.log("cocos2d: removeChildByTag(tag \x3d %d): child not found!", a) : this.removeProtectedChild(c, b)
    },
    removeAllProtectedChildren: function() {
        this.removeAllProtectedChildrenWithCleanup(!0)
    },
    removeAllProtectedChildrenWithCleanup: function(a) {
        null == a && (a = !0);
        for (var b = this._protectedChildren, c = 0, d = b.length; c < d; c++) {
            var e = b[c];
            this._running && (e.onExitTransitionDidStart(), e.onExit());
            a && e.cleanup();
            e.setParent(null)
        }
        b.length = 0
    },
    reorderProtectedChild: function(a, b) {
        cc.assert(null != a, "Child must be non-nil");
        this._reorderProtectedChildDirty = !0;
        a.setOrderOfArrival(cc.s_globalOrderOfArrival++);
        a._setLocalZOrder(b)
    },
    sortAllProtectedChildren: function() {
        if (this._reorderProtectedChildDirty) {
            var a =
                this._protectedChildren,
                b = a.length,
                c, d, e;
            for (c = 1; c < b; c++) {
                e = a[c];
                for (d = c - 1; 0 <= d;) {
                    if (e._localZOrder < a[d]._localZOrder) a[d + 1] = a[d];
                    else if (e._localZOrder === a[d]._localZOrder && e.arrivalOrder < a[d].arrivalOrder) a[d + 1] = a[d];
                    else break;
                    d--
                }
                a[d + 1] = e
            }
            this._reorderProtectedChildDirty = !1
        }
    },
    visit: null,
    _visitForCanvas: function(a) {
        if (this._visible) {
            a = a || cc._renderContext;
            var b, c, d = this._children,
                e, f = this._protectedChildren,
                g = this._children.length,
                h = f.length;
            this.transform(a);
            this.sortAllChildren();
            this.sortAllProtectedChildren();
            for (b = 0; b < g; b++)
                if (e = d[b], 0 > e._localZOrder) e.visit(a);
                else break;
            for (c = 0; c < h; c++)
                if (e = f[c], 0 > e._localZOrder) e.visit(a);
                else break;
            for (this._rendererCmd && cc.renderer.pushRenderCommand(this._rendererCmd); b < g; b++) d[b] && d[b].visit(a);
            for (; c < h; c++) f[c] && f[c].visit(a);
            this._cacheDirty = !1
        }
    },
    _visitForWebGL: function() {
        if (this._visible) {
            var a, b = cc.current_stack,
                c;
            b.stack.push(b.top);
            cc.kmMat4Assign(this._stackMatrix, b.top);
            b.top = this._stackMatrix;
            var d = this.grid;
            d && d._active && d.beforeDraw();
            this.transform();
            var e = this._children,
                f = this._protectedChildren,
                g = e.length,
                h = f.length;
            this.sortAllChildren();
            this.sortAllProtectedChildren();
            for (a = 0; a < g; a++)
                if (e[a] && 0 > e[a]._localZOrder) e[a].visit();
                else break;
            for (c = 0; c < h; c++)
                if (f[c] && 0 > f[c]._localZOrder) f[c].visit();
                else break;
            for (this._rendererCmd && cc.renderer.pushRenderCommand(this._rendererCmd); a < g; a++) e[a] && e[a].visit();
            for (; c < h; c++) f[c] && f[c].visit();
            d && d._active && d.afterDraw(this);
            b.top = b.stack.pop()
        }
    },
    cleanup: function() {
        cc.Node.prototype.cleanup.call(this);
        for (var a = this._protectedChildren, b = 0, c = a.length; b < c; b++) a[b].cleanup()
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this);
        for (var a = this._protectedChildren, b = 0, c = a.length; b < c; b++) a[b].onEnter()
    },
    onEnterTransitionDidFinish: function() {
        cc.Node.prototype.onEnterTransitionDidFinish.call(this);
        for (var a = this._protectedChildren, b = 0, c = a.length; b < c; b++) a[b].onEnterTransitionDidFinish()
    },
    onExit: function() {
        cc.Node.prototype.onExit.call(this);
        for (var a = this._protectedChildren, b = 0, c = a.length; b < c; b++) a[b].onExit()
    },
    onExitTransitionDidStart: function() {
        cc.Node.prototype.onExitTransitionDidStart.call(this);
        for (var a = this._protectedChildren, b = 0, c = a.length; b < c; b++) a[b].onExitTransitionDidStart()
    },
    updateDisplayedOpacity: function(a) {
        this._displayedOpacity = this._realOpacity * a / 255;
        this._updateColor();
        var b, c, d = this._displayedOpacity;
        if (this._cascadeOpacityEnabled) {
            c = this._children;
            a = 0;
            for (b = c.length; a < b; a++) c[a].updateDisplayedOpacity && c[a].updateDisplayedOpacity(d)
        }
        c = this._protectedChildren;
        a = 0;
        for (b = c.length; a < b; a++) c[a] &&
            c[a].updateDisplayedOpacity(d)
    },
    updateDisplayedColor: function(a) {
        var b = this._displayedColor,
            c = this._realColor;
        b.r = c.r * a.r / 255;
        b.g = c.g * a.g / 255;
        b.b = c.b * a.b / 255;
        this._updateColor();
        var d;
        if (this._cascadeColorEnabled) {
            d = this._children;
            a = 0;
            for (c = d.length; a < c; a++) d[a].updateDisplayedColor && d[a].updateDisplayedColor(b)
        }
        d = this._protectedChildren;
        a = 0;
        for (c = d.length; a < c; a++) d[a] && d[a].updateDisplayedColor(b)
    },
    _disableCascadeOpacity: function() {
        this._displayedOpacity = this._realOpacity;
        var a = this._children,
            b,
            c;
        for (b = 0; b < a.length; b++)(c = a[b]) && c.updateDisplayedOpacity(255);
        a = this._protectedChildren;
        for (b = 0; b < a.length; b++)(c = a[b]) && c.updateDisplayedOpacity(255)
    },
    _disableCascadeColor: function() {
        var a = cc.color.WHITE,
            b, c, d = this._children;
        b = 0;
        for (c = d.length; b < c; b++) d[b].updateDisplayedColor(a);
        d = this._protectedChildren;
        b = 0;
        for (c = d.length; b < c; b++) d[b].setColor(a)
    }
});
cc._renderType === cc._RENDER_TYPE_CANVAS ? (cc.ProtectedNode.prototype.visit = cc.ProtectedNode.prototype._visitForCanvas, cc.ProtectedNode.prototype._transformForRenderer = function() {
    var a = this.nodeToParentTransform(),
        b = this._transformWorld;
    if (this._parent) {
        var c = this._parent._transformWorld;
        b.a = a.a * c.a + a.b * c.c;
        b.b = a.a * c.b + a.b * c.d;
        b.c = a.c * c.a + a.d * c.c;
        b.d = a.c * c.b + a.d * c.d;
        if (this._skewX || this._skewY) {
            var d = this._parent._transform,
                e = -(d.b + d.c) * a.tx;
            b.tx = a.tx * c.a + a.ty * c.c + c.tx + -(d.b + d.c) * a.ty;
            b.ty = a.tx * c.b +
                a.ty * c.d + c.ty + e
        } else b.tx = a.tx * c.a + a.ty * c.c + c.tx, b.ty = a.tx * c.b + a.ty * c.d + c.ty
    } else b.a = a.a, b.b = a.b, b.c = a.c, b.d = a.d, b.tx = a.tx, b.ty = a.ty;
    this._renderCmdDiry = !1;
    c = this._children;
    a = 0;
    for (b = c.length; a < b; a++) c[a]._transformForRenderer();
    c = this._protectedChildren;
    a = 0;
    for (b = c.length; a < b; a++) c[a]._transformForRenderer()
}) : (cc.ProtectedNode.prototype.visit = cc.ProtectedNode.prototype._visitForWebGL, cc.ProtectedNode.prototype._transformForRenderer = function() {
    var a = this._transform4x4,
        b = this._stackMatrix,
        c = this._parent ?
        this._parent._stackMatrix : cc.current_stack.top,
        d = this.nodeToParentTransform(),
        e = a.mat;
    e[0] = d.a;
    e[4] = d.c;
    e[12] = d.tx;
    e[1] = d.b;
    e[5] = d.d;
    e[13] = d.ty;
    e[14] = this._vertexZ;
    cc.kmMat4Multiply(b, c, a);
    this._renderCmdDiry = !1;
    c = this._children;
    a = 0;
    for (b = c.length; a < b; a++) c[a]._transformForRenderer();
    c = this._protectedChildren;
    a = 0;
    for (b = c.length; a < b; a++) c[a]._transformForRenderer()
});
cc.ProtectedNode.create = function() {
    return new cc.ProtectedNode
};
var ccui = ccui || {};
ccui.Class = ccui.Class || cc.Class;
ccui.Class.extend = ccui.Class.extend || cc.Class.extend;
ccui.Node = ccui.Node || cc.Node;
ccui.Node.extend = ccui.Node.extend || cc.Node.extend;
ccui.ProtectedNode = ccui.ProtectedNode || cc.ProtectedNode;
ccui.ProtectedNode.extend = ccui.ProtectedNode.extend || cc.ProtectedNode.extend;
ccui.cocosGUIVersion = "CocosGUI v1.0.0.0";
ccui.__LAYOUT_COMPONENT_NAME = "__ui_layout";
ccui.Widget = ccui.ProtectedNode.extend({
    _enabled: !0,
    _bright: !0,
    _touchEnabled: !1,
    _brightStyle: null,
    _touchBeganPosition: null,
    _touchMovePosition: null,
    _touchEndPosition: null,
    _touchEventListener: null,
    _touchEventSelector: null,
    _name: "default",
    _widgetType: null,
    _actionTag: 0,
    _customSize: null,
    _layoutParameterDictionary: null,
    _layoutParameterType: 0,
    _focused: !1,
    _focusEnabled: !0,
    _ignoreSize: !1,
    _affectByClipping: !1,
    _sizeType: null,
    _sizePercent: null,
    _positionType: null,
    _positionPercent: null,
    _hit: !1,
    _nodes: null,
    _touchListener: null,
    _className: "Widget",
    _flippedX: !1,
    _flippedY: !1,
    _opacity: 255,
    _highlight: !1,
    _touchEventCallback: null,
    _propagateTouchEvents: !0,
    _unifySize: !1,
    ctor: function() {
        cc.ProtectedNode.prototype.ctor.call(this);
        this._brightStyle = ccui.Widget.BRIGHT_STYLE_NONE;
        this._touchBeganPosition = cc.p(0, 0);
        this._touchMovePosition = cc.p(0, 0);
        this._touchEndPosition = cc.p(0, 0);
        this._widgetType = ccui.Widget.TYPE_WIDGET;
        this._customSize = cc.size(0, 0);
        this._layoutParameterDictionary = {};
        this._sizeType = ccui.Widget.SIZE_ABSOLUTE;
        this._sizePercent =
            cc.p(0, 0);
        this._positionType = ccui.Widget.POSITION_ABSOLUTE;
        this._positionPercent = cc.p(0, 0);
        this._nodes = [];
        this._layoutParameterType = ccui.LayoutParameter.NONE;
        this.init()
    },
    init: function() {
        return cc.ProtectedNode.prototype.init.call(this) ? (this._layoutParameterDictionary = {}, this._initRenderer(), this.setBright(!0), this.onFocusChanged = this.onFocusChange.bind(this), this.onNextFocusedWidget = null, this.setAnchorPoint(cc.p(0.5, 0.5)), this.ignoreContentAdaptWithSize(!0), !0) : !1
    },
    onEnter: function() {
        this.updateSizeAndPosition();
        cc.ProtectedNode.prototype.onEnter.call(this)
    },
    onExit: function() {
        this.unscheduleUpdate();
        cc.ProtectedNode.prototype.onExit.call(this)
    },
    getOrCreateLayoutComponent: function() {
        var a = this.getComponent(ccui.__LAYOUT_COMPONENT_NAME);
        null == a && (a = new ccui.LayoutComponent, this.addComponent(a));
        return a
    },
    visit: function(a) {
        this._visible && (this._adaptRenderers(), cc.ProtectedNode.prototype.visit.call(this, a))
    },
    getWidgetParent: function() {
        var a = this.getParent();
        return a instanceof ccui.Widget ? a : null
    },
    _updateContentSizeWithTextureSize: function(a) {
        this.setContentSize(this._ignoreSize ?
            a : this._customSize)
    },
    _isAncestorsEnabled: function() {
        var a = this._getAncensterWidget(this);
        return null == a ? !0 : a && !a.isEnabled() ? !1 : a._isAncestorsEnabled()
    },
    setPropagateTouchEvents: function(a) {
        this._propagateTouchEvents = a
    },
    isPropagateTouchEvents: function() {
        return this._propagateTouchEvents
    },
    setSwallowTouches: function(a) {
        this._touchListener && this._touchListener.setSwallowTouches(a)
    },
    isSwallowTouches: function() {
        return this._touchListener ? !0 : !1
    },
    _getAncensterWidget: function(a) {
        if (null == a) return null;
        a = a.getParent();
        return null == a ? null : a instanceof ccui.Widget ? a : this._getAncensterWidget(a.getParent())
    },
    _isAncestorsVisible: function(a) {
        return null == a ? !0 : (a = a.getParent()) && !a.isVisible() ? !1 : this._isAncestorsVisible(a)
    },
    _cleanupWidget: function() {
        this._eventDispatcher.removeEventListener(this._touchListener);
        ccui.Widget._focusedWidget == this && (ccui.Widget._focusedWidget = null)
    },
    setEnabled: function(a) {
        this._enabled = a
    },
    _initRenderer: function() {},
    setContentSize: function(a, b) {
        var c = void 0 === b ? a.width : a,
            d = void 0 === b ? a.height :
            b;
        cc.Node.prototype.setContentSize.call(this, c, d);
        this._customSize.width = c;
        this._customSize.height = d;
        this._ignoreSize && (this._contentSize = this.getVirtualRendererSize());
        if (this._running) {
            var e = this.getWidgetParent(),
                e = e ? e.getContentSize() : this._parent.getContentSize();
            this._sizePercent.x = 0 < e.width ? c / e.width : 0;
            this._sizePercent.y = 0 < e.height ? d / e.height : 0
        }
        this._onSizeChanged()
    },
    _setWidth: function(a) {
        cc.Node.prototype._setWidth.call(this, a);
        this._customSize.width = a;
        this._ignoreSize && (this._contentSize =
            this.getVirtualRendererSize());
        this._running && (a = (a = this.getWidgetParent()) ? a.width : this._parent.width, this._sizePercent.x = 0 < a ? this._customSize.width / a : 0);
        this._onSizeChanged()
    },
    _setHeight: function(a) {
        cc.Node.prototype._setHeight.call(this, a);
        this._customSize.height = a;
        this._ignoreSize && (this._contentSize = this.getVirtualRendererSize());
        this._running && (a = (a = this.getWidgetParent()) ? a.height : this._parent.height, this._sizePercent.y = 0 < a ? this._customSize.height / a : 0);
        this._onSizeChanged()
    },
    setSizePercent: function(a) {
        this._sizePercent.x =
            a.x;
        this._sizePercent.y = a.y;
        var b = this._customSize.width,
            c = this._customSize.height;
        this._running && ((c = this.getWidgetParent()) ? (b = c.width * a.x, c = c.height * a.y) : (b = this._parent.width * a.x, c = this._parent.height * a.y));
        this._ignoreSize ? this.setContentSize(this.getVirtualRendererSize()) : this.setContentSize(b, c);
        this._customSize.width = b;
        this._customSize.height = c
    },
    _setWidthPercent: function(a) {
        this._sizePercent.x = a;
        var b = this._customSize.width;
        this._running && (b = this.getWidgetParent(), b = (b ? b.width : this._parent.width) *
            a);
        this._ignoreSize ? this._setWidth(this.getVirtualRendererSize().width) : this._setWidth(b);
        this._customSize.width = b
    },
    _setHeightPercent: function(a) {
        this._sizePercent.y = a;
        var b = this._customSize.height;
        this._running && (b = this.getWidgetParent(), b = (b ? b.height : this._parent.height) * a);
        this._ignoreSize ? this._setHeight(this.getVirtualRendererSize().height) : this._setHeight(b);
        this._customSize.height = b
    },
    updateSizeAndPosition: function(a) {
        a || (a = (a = this.getWidgetParent()) ? a.getLayoutSize() : this._parent.getContentSize());
        switch (this._sizeType) {
            case ccui.Widget.SIZE_ABSOLUTE:
                this._ignoreSize ? this.setContentSize(this.getVirtualRendererSize()) : this.setContentSize(this._customSize);
                this._sizePercent.x = 0 < a.width ? this._customSize.width / a.width : 0;
                this._sizePercent.y = 0 < a.height ? this._customSize.height / a.height : 0;
                break;
            case ccui.Widget.SIZE_PERCENT:
                var b = cc.size(a.width * this._sizePercent.x, a.height * this._sizePercent.y);
                this._ignoreSize ? this.setContentSize(this.getVirtualRendererSize()) : this.setContentSize(b);
                this._customSize.width =
                    b.width;
                this._customSize.height = b.height
        }
        this._onSizeChanged();
        b = this.getPosition();
        switch (this._positionType) {
            case ccui.Widget.POSITION_ABSOLUTE:
                0 >= a.width || 0 >= a.height ? this._positionPercent.x = this._positionPercent.y = 0 : (this._positionPercent.x = b.x / a.width, this._positionPercent.y = b.y / a.height);
                break;
            case ccui.Widget.POSITION_PERCENT:
                b = cc.p(a.width * this._positionPercent.x, a.height * this._positionPercent.y)
        }
        if (this._parent instanceof ccui.ImageView && (a = this._parent._imageRenderer) && !a._textureLoaded) return;
        this.setPosition(b)
    },
    setSizeType: function(a) {
        this._sizeType = a
    },
    getSizeType: function() {
        return this._sizeType
    },
    ignoreContentAdaptWithSize: function(a) {
        this._ignoreSize != a && (this._ignoreSize = a, this.setContentSize(a ? this.getVirtualRendererSize() : this._customSize), this._onSizeChanged())
    },
    isIgnoreContentAdaptWithSize: function() {
        return this._ignoreSize
    },
    getCustomSize: function() {
        return cc.size(this._customSize)
    },
    getLayoutSize: function() {
        return cc.size(this._contentSize)
    },
    getSizePercent: function() {
        return this.getOrCreateLayoutComponent().getPercentContentSize()
    },
    _getWidthPercent: function() {
        return this._sizePercent.x
    },
    _getHeightPercent: function() {
        return this._sizePercent.y
    },
    getWorldPosition: function() {
        return this.convertToWorldSpace(cc.p(this._anchorPoint.x * this._contentSize.width, this._anchorPoint.y * this._contentSize.height))
    },
    getVirtualRenderer: function() {
        return this
    },
    getVirtualRendererSize: function() {
        return cc.size(this._contentSize)
    },
    _onSizeChanged: function() {
        for (var a = this.getChildren(), b = 0, c = a.length; b < c; b++) {
            var d = a[b];
            d instanceof ccui.Widget && d.updateSizeAndPosition()
        }
    },
    setTouchEnabled: function(a) {
        this._touchEnabled !== a && ((this._touchEnabled = a) ? (this._touchListener || (this._touchListener = cc.EventListener.create({
            event: cc.EventListener.TOUCH_ONE_BY_ONE,
            swallowTouches: !0,
            onTouchBegan: this.onTouchBegan.bind(this),
            onTouchMoved: this.onTouchMoved.bind(this),
            onTouchEnded: this.onTouchEnded.bind(this)
        })), cc.eventManager.addListener(this._touchListener, this)) : cc.eventManager.removeListener(this._touchListener))
    },
    isTouchEnabled: function() {
        return this._touchEnabled
    },
    isHighlighted: function() {
        return this._highlight
    },
    setHighlighted: function(a) {
        a != this._highlight && (this._highlight = a, this._bright ? this._highlight ? this.setBrightStyle(ccui.Widget.BRIGHT_STYLE_HIGH_LIGHT) : this.setBrightStyle(ccui.Widget.BRIGHT_STYLE_NORMAL) : this._onPressStateChangedToDisabled())
    },
    isFocused: function() {
        return this._focused
    },
    setFocused: function(a) {
        if (this._focused = a) ccui.Widget._focusedWidget = this
    },
    isFocusEnabled: function() {
        return this._focusEnabled
    },
    setFocusEnabled: function(a) {
        this._focused = a
    },
    findNextFocusedWidget: function(a, b) {
        if (null ==
            this.onNextFocusedWidget || null == this.onNextFocusedWidget(a)) {
            var c = b instanceof ccui.Layout;
            if (this.isFocused() || c) {
                var d = this.getParent();
                return null == d ? c ? b.findNextFocusedWidget(a, b) : b : d.findNextFocusedWidget(a, b)
            }
            return b
        }
        c = this.onNextFocusedWidget(a);
        this.dispatchFocusEvent(this, c);
        return c
    },
    requestFocus: function() {
        this != ccui.Widget._focusedWidget && this.dispatchFocusEvent(ccui.Widget._focusedWidget, this)
    },
    getCurrentFocusedWidget: function() {
        return ccui.Widget._focusedWidget
    },
    enableDpadNavigation: function(a) {},
    onFocusChanged: null,
    onNextFocusedWidget: null,
    interceptTouchEvent: function(a, b, c) {
        var d = this.getWidgetParent();
        d && d.interceptTouchEvent(a, b, c)
    },
    onFocusChange: function(a, b) {
        a && a.setFocused(!1);
        b && b.setFocused(!0)
    },
    dispatchFocusEvent: function(a, b) {
        a && !a.isFocused() && (a = ccui.Widget._focusedWidget);
        if (b != a) {
            if (b && b.onFocusChanged) b.onFocusChanged(a, b);
            if (a && b.onFocusChanged) a.onFocusChanged(a, b);
            cc.eventManager.dispatchEvent(new cc.EventFocus(a, b))
        }
    },
    setBright: function(a) {
        (this._bright = a) ? (this._brightStyle =
            ccui.Widget.BRIGHT_STYLE_NONE, this.setBrightStyle(ccui.Widget.BRIGHT_STYLE_NORMAL)) : this._onPressStateChangedToDisabled()
    },
    setBrightStyle: function(a) {
        if (this._brightStyle != a) switch (this._brightStyle = a = a || ccui.Widget.BRIGHT_STYLE_NORMAL, this._brightStyle) {
            case ccui.Widget.BRIGHT_STYLE_NORMAL:
                this._onPressStateChangedToNormal();
                break;
            case ccui.Widget.BRIGHT_STYLE_HIGH_LIGHT:
                this._onPressStateChangedToPressed()
        }
    },
    _onPressStateChangedToNormal: function() {},
    _onPressStateChangedToPressed: function() {},
    _onPressStateChangedToDisabled: function() {},
    _updateChildrenDisplayedRGBA: function() {
        this.setColor(this.getColor());
        this.setOpacity(this.getOpacity())
    },
    didNotSelectSelf: function() {},
    onTouchBegan: function(a, b) {
        this._hit = !1;
        if (this.isVisible() && this.isEnabled() && this._isAncestorsEnabled() && this._isAncestorsVisible(this)) {
            var c = a.getLocation();
            this._touchBeganPosition.x = c.x;
            this._touchBeganPosition.y = c.y;
            this.hitTest(this._touchBeganPosition) && this.isClippingParentContainsPoint(this._touchBeganPosition) && (this._hit = !0)
        }
        if (!this._hit) return !1;
        this.setHighlighted(!0);
        this._propagateTouchEvents && this.propagateTouchEvent(ccui.Widget.TOUCH_BEGAN, this, a);
        this._pushDownEvent();
        return !0
    },
    propagateTouchEvent: function(a, b, c) {
        var d = this.getWidgetParent();
        d && d.interceptTouchEvent(a, b, c)
    },
    onTouchMoved: function(a, b) {
        var c = a.getLocation();
        this._touchMovePosition.x = c.x;
        this._touchMovePosition.y = c.y;
        this.setHighlighted(this.hitTest(c));
        (c = this.getWidgetParent()) && c.interceptTouchEvent(ccui.Widget.TOUCH_MOVED, this, a);
        this._moveEvent()
    },
    onTouchEnded: function(a, b) {
        var c = a.getLocation();
        this._touchEndPosition.x = c.x;
        this._touchEndPosition.y = c.y;
        (c = this.getWidgetParent()) && c.interceptTouchEvent(ccui.Widget.TOUCH_ENDED, this, a);
        c = this._highlight;
        this.setHighlighted(!1);
        c ? this._releaseUpEvent() : this._cancelUpEvent()
    },
    onTouchCancelled: function(a) {
        this.setHighlighted(!1);
        this._cancelUpEvent()
    },
    onTouchLongClicked: function(a) {
        this.longClickEvent()
    },
    _pushDownEvent: function() {
        this._touchEventCallback && this._touchEventCallback(this, ccui.Widget.TOUCH_BEGAN);
        this._touchEventListener && this._touchEventSelector &&
            this._touchEventSelector.call(this._touchEventListener, this, ccui.Widget.TOUCH_BEGAN)
    },
    _moveEvent: function() {
        this._touchEventCallback && this._touchEventCallback(this, ccui.Widget.TOUCH_MOVED);
        this._touchEventListener && this._touchEventSelector && this._touchEventSelector.call(this._touchEventListener, this, ccui.Widget.TOUCH_MOVED)
    },
    _releaseUpEvent: function() {
        this._touchEventCallback && this._touchEventCallback(this, ccui.Widget.TOUCH_ENDED);
        this._touchEventListener && this._touchEventSelector && this._touchEventSelector.call(this._touchEventListener,
            this, ccui.Widget.TOUCH_ENDED);
        this._clickEventListener && this._clickEventListener(this)
    },
    _cancelUpEvent: function() {
        this._touchEventCallback && this._touchEventCallback(this, ccui.Widget.TOUCH_CANCELED);
        this._touchEventListener && this._touchEventSelector && this._touchEventSelector.call(this._touchEventListener, this, ccui.Widget.TOUCH_CANCELED)
    },
    longClickEvent: function() {},
    addTouchEventListener: function(a, b) {
        void 0 === b ? this._touchEventCallback = a : (this._touchEventSelector = a, this._touchEventListener = b)
    },
    addClickEventListener: function(a) {
        this._clickEventListener =
            a
    },
    hitTest: function(a) {
        var b = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        return cc.rectContainsPoint(b, this.convertToNodeSpace(a))
    },
    isClippingParentContainsPoint: function(a) {
        this._affectByClipping = !1;
        for (var b = this.getParent(), c = null; b;) {
            if (b instanceof ccui.Layout && b.isClippingEnabled()) {
                this._affectByClipping = !0;
                c = b;
                break
            }
            b = b.getParent()
        }
        return !this._affectByClipping ? !0 : c ? c.hitTest(a) ? c.isClippingParentContainsPoint(a) : !1 : !0
    },
    checkChildInfo: function(a, b, c) {
        var d = this.getWidgetParent();
        d && d.checkChildInfo(a, b, c)
    },
    setPosition: function(a, b) {
        if (this._running) {
            var c = this.getWidgetParent();
            c && (c = c.getContentSize(), 0 >= c.width || 0 >= c.height ? (this._positionPercent.x = 0, this._positionPercent.y = 0) : void 0 == b ? (this._positionPercent.x = a.x / c.width, this._positionPercent.y = a.y / c.height) : (this._positionPercent.x = a / c.width, this._positionPercent.y = b / c.height))
        }
        cc.Node.prototype.setPosition.call(this, a, b);
        this._positionType = ccui.Widget.POSITION_ABSOLUTE
    },
    setPositionX: function(a) {
        if (this._running) {
            var b =
                this.getWidgetParent();
            b && (b = b.width, this._positionPercent.x = 0 >= b ? 0 : a / b)
        }
        cc.Node.prototype.setPositionX.call(this, a)
    },
    setPositionY: function(a) {
        if (this._running) {
            var b = this.getWidgetParent();
            b && (b = b.height, this._positionPercent.y = 0 >= b ? 0 : a / b)
        }
        cc.Node.prototype.setPositionY.call(this, a)
    },
    setPositionPercent: function(a) {
        this._positionPercent = a;
        if (this._running && (a = this.getWidgetParent())) a = a.getSize(), this.setPosition(a.width * this._positionPercent.x, a.height * this._positionPercent.y)
    },
    _setXPercent: function(a) {
        this._positionPercent.x =
            a;
        if (this._running) {
            var b = this.getWidgetParent();
            b && this.setPositionX(b.width * a)
        }
    },
    _setYPercent: function(a) {
        this._positionPercent.y = a;
        if (this._running) {
            var b = this.getWidgetParent();
            b && this.setPositionY(b.height * a)
        }
    },
    getPositionPercent: function() {
        return cc.p(this.getNormalizedPosition())
    },
    _getXPercent: function() {
        return this._positionPercent.x
    },
    _getYPercent: function() {
        return this._positionPercent.y
    },
    setPositionType: function(a) {
        this._positionType = a;
        this.setNodeDirty()
    },
    getPositionType: function() {
        return this._positionType
    },
    setFlippedX: function(a) {
        this._flippedX = a;
        this._updateFlippedX()
    },
    isFlippedX: function() {
        return this._flippedX
    },
    setFlippedY: function(a) {
        this._flippedY = a;
        this._updateFlippedY()
    },
    isFlippedY: function() {
        return this._flippedY
    },
    _updateFlippedX: function() {},
    _updateFlippedY: function() {},
    _adaptRenderers: function() {},
    isBright: function() {
        return this._bright
    },
    isEnabled: function() {
        return this._enabled
    },
    getLeftBoundary: function() {
        return this.getPositionX() - this._getAnchorX() * this._contentSize.width
    },
    getBottomBoundary: function() {
        return this.getPositionY() -
            this._getAnchorY() * this._contentSize.height
    },
    getRightBoundary: function() {
        return this.getLeftBoundary() + this._contentSize.width
    },
    getTopBoundary: function() {
        return this.getBottomBoundary() + this._contentSize.height
    },
    getTouchBeganPosition: function() {
        return cc.p(this._touchBeganPosition)
    },
    getTouchMovePosition: function() {
        return cc.p(this._touchMovePosition)
    },
    getTouchEndPosition: function() {
        return cc.p(this._touchEndPosition)
    },
    getWidgetType: function() {
        return this._widgetType
    },
    setLayoutParameter: function(a) {
        a &&
            (this._layoutParameterDictionary[a.getLayoutType()] = a, this._layoutParameterType = a.getLayoutType())
    },
    getLayoutParameter: function(a) {
        a = a || this._layoutParameterType;
        return this._layoutParameterDictionary[a]
    },
    getDescription: function() {
        return "Widget"
    },
    clone: function() {
        var a = this._createCloneInstance();
        a._copyProperties(this);
        a._copyClonedWidgetChildren(this);
        return a
    },
    _createCloneInstance: function() {
        return new ccui.Widget
    },
    _copyClonedWidgetChildren: function(a) {
        a = a.getChildren();
        for (var b = 0; b < a.length; b++) {
            var c =
                a[b];
            c instanceof ccui.Widget && this.addChild(c.clone())
        }
    },
    _copySpecialProperties: function(a) {},
    _copyProperties: function(a) {
        this.setEnabled(a.isEnabled());
        this.setVisible(a.isVisible());
        this.setBright(a.isBright());
        this.setTouchEnabled(a.isTouchEnabled());
        this.setLocalZOrder(a.getLocalZOrder());
        this.setTag(a.getTag());
        this.setName(a.getName());
        this.setActionTag(a.getActionTag());
        this._ignoreSize = a._ignoreSize;
        this.setContentSize(a._contentSize);
        this._customSize.width = a._customSize.width;
        this._customSize.height =
            a._customSize.height;
        this._copySpecialProperties(a);
        this._sizeType = a.getSizeType();
        this._sizePercent.x = a._sizePercent.x;
        this._sizePercent.y = a._sizePercent.y;
        this._positionType = a._positionType;
        this._positionPercent.x = a._positionPercent.x;
        this._positionPercent.y = a._positionPercent.y;
        this.setPosition(a.getPosition());
        this.setAnchorPoint(a.getAnchorPoint());
        this.setScaleX(a.getScaleX());
        this.setScaleY(a.getScaleY());
        this.setRotation(a.getRotation());
        this.setRotationX(a.getRotationX());
        this.setRotationY(a.getRotationY());
        this.setFlippedX(a.isFlippedX());
        this.setFlippedY(a.isFlippedY());
        this.setColor(a.getColor());
        this.setOpacity(a.getOpacity());
        this._touchEventCallback = a._touchEventCallback;
        this._touchEventListener = a._touchEventListener;
        this._touchEventSelector = a._touchEventSelector;
        this._clickEventListener = a._clickEventListener;
        this._focused = a._focused;
        this._focusEnabled = a._focusEnabled;
        this._propagateTouchEvents = a._propagateTouchEvents;
        for (var b in a._layoutParameterDictionary) {
            var c = a._layoutParameterDictionary[b];
            c && this.setLayoutParameter(c.clone())
        }
        this._onSizeChanged()
    },
    setActionTag: function(a) {
        this._actionTag = a
    },
    getActionTag: function() {
        return this._actionTag
    },
    getLeftInParent: function() {
        cc.log("getLeftInParent is deprecated. Please use getLeftBoundary instead.");
        return this.getLeftBoundary()
    },
    getBottomInParent: function() {
        cc.log("getBottomInParent is deprecated. Please use getBottomBoundary instead.");
        return this.getBottomBoundary()
    },
    getRightInParent: function() {
        cc.log("getRightInParent is deprecated. Please use getRightBoundary instead.");
        return this.getRightBoundary()
    },
    getTopInParent: function() {
        cc.log("getTopInParent is deprecated. Please use getTopBoundary instead.");
        return this.getTopBoundary()
    },
    getTouchEndPos: function() {
        cc.log("getTouchEndPos is deprecated. Please use getTouchEndPosition instead.");
        return this.getTouchEndPosition()
    },
    getTouchMovePos: function() {
        cc.log("getTouchMovePos is deprecated. Please use getTouchMovePosition instead.");
        return this.getTouchMovePosition()
    },
    clippingParentAreaContainPoint: function(a) {
        cc.log("clippingParentAreaContainPoint is deprecated. Please use isClippingParentContainsPoint instead.");
        this.isClippingParentContainsPoint(a)
    },
    getTouchStartPos: function() {
        cc.log("getTouchStartPos is deprecated. Please use getTouchBeganPosition instead.");
        return this.getTouchBeganPosition()
    },
    setSize: function(a) {
        this.setContentSize(a)
    },
    getSize: function() {
        return this.getContentSize()
    },
    addNode: function(a, b, c) {
        a instanceof ccui.Widget ? cc.log("Please use addChild to add a Widget.") : (cc.Node.prototype.addChild.call(this, a, b, c), this._nodes.push(a))
    },
    getNodeByTag: function(a) {
        for (var b = this._nodes, c = 0; c < b.length; c++) {
            var d =
                b[c];
            if (d && d.getTag() == a) return d
        }
        return null
    },
    getNodes: function() {
        return this._nodes
    },
    removeNode: function(a, b) {
        cc.Node.prototype.removeChild.call(this, a, b);
        cc.arrayRemoveObject(this._nodes, a)
    },
    removeNodeByTag: function(a, b) {
        var c = this.getNodeByTag(a);
        c ? this.removeNode(c) : cc.log("cocos2d: removeNodeByTag(tag \x3d %d): child not found!", a)
    },
    removeAllNodes: function() {
        for (var a = 0; a < this._nodes.length; a++) cc.Node.prototype.removeChild.call(this, this._nodes[a]);
        this._nodes.length = 0
    },
    _findLayout: function() {
        cc.renderer.childrenOrderDirty = !0;
        for (var a = this._parent; a;)
            if (a._doLayout) {
                a._doLayoutDirty = !0;
                break
            } else a = a._parent
    },
    isUnifySizeEnabled: function() {
        return this._unifySize
    },
    setUnifySizeEnabled: function(a) {
        this._unifySize = a
    }
});
_p = ccui.Widget.prototype;
cc.defineGetterSetter(_p, "xPercent", _p._getXPercent, _p._setXPercent);
cc.defineGetterSetter(_p, "yPercent", _p._getYPercent, _p._setYPercent);
cc.defineGetterSetter(_p, "widthPercent", _p._getWidthPercent, _p._setWidthPercent);
cc.defineGetterSetter(_p, "heightPercent", _p._getHeightPercent, _p._setHeightPercent);
cc.defineGetterSetter(_p, "widgetParent", _p.getWidgetParent);
cc.defineGetterSetter(_p, "enabled", _p.isEnabled, _p.setEnabled);
cc.defineGetterSetter(_p, "focused", _p.isFocused, _p.setFocused);
cc.defineGetterSetter(_p, "sizeType", _p.getSizeType, _p.setSizeType);
cc.defineGetterSetter(_p, "widgetType", _p.getWidgetType);
cc.defineGetterSetter(_p, "touchEnabled", _p.isTouchEnabled, _p.setTouchEnabled);
cc.defineGetterSetter(_p, "updateEnabled", _p.isUpdateEnabled, _p.setUpdateEnabled);
cc.defineGetterSetter(_p, "bright", _p.isBright, _p.setBright);
cc.defineGetterSetter(_p, "name", _p.getName, _p.setName);
cc.defineGetterSetter(_p, "actionTag", _p.getActionTag, _p.setActionTag);
cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
_p = null;
ccui.Widget.create = function() {
    return new ccui.Widget
};
ccui.Widget._focusedWidget = null;
ccui.Widget.getCurrentFocusedWidget = function() {
    return ccui.Widget._focusedWidget
};
ccui.Widget.BRIGHT_STYLE_NONE = -1;
ccui.Widget.BRIGHT_STYLE_NORMAL = 0;
ccui.Widget.BRIGHT_STYLE_HIGH_LIGHT = 1;
ccui.Widget.TYPE_WIDGET = 0;
ccui.Widget.TYPE_CONTAINER = 1;
ccui.Widget.LEFT = 0;
ccui.Widget.RIGHT = 1;
ccui.Widget.UP = 0;
ccui.Widget.DOWN = 1;
ccui.Widget.LOCAL_TEXTURE = 0;
ccui.Widget.PLIST_TEXTURE = 1;
ccui.Widget.TOUCH_BEGAN = 0;
ccui.Widget.TOUCH_MOVED = 1;
ccui.Widget.TOUCH_ENDED = 2;
ccui.Widget.TOUCH_CANCELED = 3;
ccui.Widget.SIZE_ABSOLUTE = 0;
ccui.Widget.SIZE_PERCENT = 1;
ccui.Widget.POSITION_ABSOLUTE = 0;
ccui.Widget.POSITION_PERCENT = 1;
cc.EventFocus = cc.Event.extend({
    _widgetGetFocus: null,
    _widgetLoseFocus: null,
    ctor: function(a, b) {
        this._widgetGetFocus = b;
        this._widgetLoseFocus = a
    }
});
ccui.Scale9Sprite = cc.Node.extend({
    _spriteRect: null,
    _capInsetsInternal: null,
    _positionsAreDirty: !1,
    _scale9Image: null,
    _topLeft: null,
    _top: null,
    _topRight: null,
    _left: null,
    _centre: null,
    _right: null,
    _bottomLeft: null,
    _bottom: null,
    _bottomRight: null,
    _cacheSprite: null,
    _cacheCanvas: null,
    _cacheContext: null,
    _cacheTexture: null,
    _scale9Dirty: !0,
    _opacityModifyRGB: !1,
    _originalSize: null,
    _preferredSize: null,
    _opacity: 0,
    _color: null,
    _capInsets: null,
    _insetLeft: 0,
    _insetTop: 0,
    _insetRight: 0,
    _insetBottom: 0,
    _spritesGenerated: !1,
    _spriteFrameRotated: !1,
    _textureLoaded: !1,
    _className: "Scale9Sprite",
    textureLoaded: function() {
        return this._textureLoaded
    },
    addLoadedEventListener: function(a, b) {
        this.addEventListener("load", a, b)
    },
    _updateCapInset: function() {
        var a;
        a = this._insetLeft;
        var b = this._insetTop,
            c = this._insetRight,
            d = this._spriteRect,
            e = this._insetBottom;
        a = 0 === a && 0 === b && 0 === c && 0 === e ? cc.rect(0, 0, 0, 0) : this._spriteFrameRotated ? cc.rect(e, a, d.width - c - a, d.height - b - e) : cc.rect(a, b, d.width - a - c, d.height - b - e);
        this.setCapInsets(a)
    },
    _updatePositions: function() {
        if (this._topLeft &&
            this._topRight && this._bottomRight && this._bottomLeft && this._centre) {
            var a = this._contentSize,
                b = this._topLeft,
                c = this._topRight,
                d = this._bottomRight,
                e = this._bottomLeft,
                f = this._centre,
                g = this._centre.getContentSize(),
                h = b.getContentSize(),
                k = e.getContentSize(),
                m = a.width - h.width - c.getContentSize().width,
                a = a.height - h.height - d.getContentSize().height,
                m = m / g.width,
                a = a / g.height,
                h = g.width * m,
                n = g.height * a,
                q = k.width,
                k = k.height;
            if (cc._renderType == cc._RENDER_TYPE_WEBGL) {
                var r = Math.round(h);
                h != r && (h = r, m = h / g.width);
                r = Math.round(n);
                n != r && (n = r, a = n / g.height)
            }
            f.setScaleX(m);
            f.setScaleY(a);
            var g = this._left,
                r = this._right,
                s = this._top,
                t = this._bottom,
                u = cc.p(0, 0);
            e.setAnchorPoint(u);
            d.setAnchorPoint(u);
            b.setAnchorPoint(u);
            c.setAnchorPoint(u);
            g.setAnchorPoint(u);
            r.setAnchorPoint(u);
            s.setAnchorPoint(u);
            t.setAnchorPoint(u);
            f.setAnchorPoint(u);
            e.setPosition(0, 0);
            d.setPosition(q + h, 0);
            b.setPosition(0, k + n);
            c.setPosition(q + h, k + n);
            g.setPosition(0, k);
            g.setScaleY(a);
            r.setPosition(q + h, k);
            r.setScaleY(a);
            t.setPosition(q, 0);
            t.setScaleX(m);
            s.setPosition(q,
                k + n);
            s.setScaleX(m);
            f.setPosition(q, k)
        }
    },
    _cacheScale9Sprite: function() {
        if (this._scale9Image) {
            var a = this._contentSize,
                b = this._cacheCanvas,
                c = !1;
            if (b.width != a.width || b.height != a.height) b.width = a.width, b.height = a.height, this._cacheContext.translate(0, a.height), c = !0;
            cc.renderer._turnToCacheMode(this.__instanceId);
            this._scale9Image.visit();
            this._cacheContext.clearRect(0, 0, a.width, -a.height);
            cc.renderer._renderingToCacheCanvas(this._cacheContext, this.__instanceId);
            c && this._cacheSprite.setTextureRect(cc.rect(0,
                0, a.width, a.height));
            this._cacheSprite.getParent() || this.addChild(this._cacheSprite)
        }
    },
    ctor: function(a, b, c) {
        cc.Node.prototype.ctor.call(this);
        this._spriteRect = cc.rect(0, 0, 0, 0);
        this._capInsetsInternal = cc.rect(0, 0, 0, 0);
        this._originalSize = cc.size(0, 0);
        this._preferredSize = cc.size(0, 0);
        this._capInsets = cc.rect(0, 0, 0, 0);
        if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
            var d = this._cacheCanvas = cc.newElement("canvas");
            d.width = 1;
            d.height = 1;
            this._cacheContext = d.getContext("2d");
            var e = this._cacheTexture = new cc.Texture2D;
            e.initWithElement(d);
            e.handleLoadedTexture();
            this._cacheSprite = new cc.Sprite(e);
            this._cacheSprite.setAnchorPoint(0, 0);
            this.addChild(this._cacheSprite)
        }
        void 0 != a ? a instanceof cc.SpriteFrame ? this.initWithSpriteFrame(a, b) : (d = cc.spriteFrameCache.getSpriteFrame(a), null != d ? this.initWithSpriteFrame(d, b) : this.initWithFile(a, b, c)) : this.init()
    },
    getOriginalSize: function() {
        return cc.size(this._originalSize)
    },
    getPreferredSize: function() {
        return cc.size(this._preferredSize)
    },
    _getPreferredWidth: function() {
        return this._preferredSize.width
    },
    _getPreferredHeight: function() {
        return this._preferredSize.height
    },
    setPreferredSize: function(a) {
        this.setContentSize(a);
        this._preferredSize = a;
        this._positionsAreDirty && (this._updatePositions(), this._positionsAreDirty = !1, this._scale9Dirty = !0)
    },
    _setPreferredWidth: function(a) {
        this._setWidth(a);
        this._preferredSize.width = a
    },
    _setPreferredHeight: function(a) {
        this._setHeight(a);
        this._preferredSize.height = a
    },
    setOpacity: function(a) {
        if (this._scale9Image) {
            cc.Node.prototype.setOpacity.call(this, a);
            for (var b = this._scale9Image.getChildren(),
                c = 0; c < b.length; c++) {
                var d = b[c];
                d && d.setOpacity(a)
            }
            this._scale9Dirty = !0
        }
    },
    updateDisplayedOpacity: function(a) {
        if (this._scale9Image) {
            cc.Node.prototype.updateDisplayedOpacity.call(this, a);
            for (var b = this._scale9Image.getChildren(), c = 0; c < b.length; c++) {
                var d = b[c];
                d && d.updateDisplayedOpacity(a)
            }
            this._scale9Dirty = !0
        }
    },
    setColor: function(a) {
        if (this._scale9Image) {
            cc.Node.prototype.setColor.call(this, a);
            for (var b = this._scale9Image.getChildren(), c = 0; c < b.length; c++) {
                var d = b[c];
                d && d.setColor(a)
            }
            this._scale9Dirty = !0
        }
    },
    updateDisplayedColor: function(a) {
        if (this._scale9Image) {
            cc.Node.prototype.updateDisplayedColor.call(this, a);
            for (var b = this._scale9Image.getChildren(), c = 0; c < b.length; c++) {
                var d = b[c];
                if (d)
                    if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
                        if (cc.Node.prototype.updateDisplayedColor.call(d, a), 255 !== a.r || 255 !== a.g || 255 !== a.b) d._changeTextureColor(), d._setNodeDirtyForCache()
                    } else d.updateDisplayedColor(a)
            }
            this._scale9Dirty = !0
        }
    },
    getCapInsets: function() {
        return cc.rect(this._capInsets)
    },
    setCapInsets: function(a) {
        if (this._scale9Image) {
            var b =
                this._contentSize,
                c = b.width,
                b = b.height;
            this.updateWithBatchNode(this._scale9Image, this._spriteRect, this._spriteFrameRotated, a);
            this.setContentSize(c, b)
        }
    },
    getInsetLeft: function() {
        return this._insetLeft
    },
    setInsetLeft: function(a) {
        this._insetLeft = a;
        this._updateCapInset()
    },
    getInsetTop: function() {
        return this._insetTop
    },
    setInsetTop: function(a) {
        this._insetTop = a;
        this._updateCapInset()
    },
    getInsetRight: function() {
        return this._insetRight
    },
    setInsetRight: function(a) {
        this._insetRight = a;
        this._updateCapInset()
    },
    getInsetBottom: function() {
        return this._insetBottom
    },
    setInsetBottom: function(a) {
        this._insetBottom = a;
        this._updateCapInset()
    },
    setContentSize: function(a, b) {
        cc.Node.prototype.setContentSize.call(this, a, b);
        this._positionsAreDirty = !0
    },
    _setWidth: function(a) {
        cc.Node.prototype._setWidth.call(this, a);
        this._positionsAreDirty = !0
    },
    _setHeight: function(a) {
        cc.Node.prototype._setHeight.call(this, a);
        this._positionsAreDirty = !0
    },
    visit: function(a) {
        this._visible && (this._positionsAreDirty && (this._updatePositions(), this._positionsAreDirty = !1, this._scale9Dirty = !0), cc._renderType ===
            cc._RENDER_TYPE_CANVAS && (this._scale9Dirty = !1, this._cacheScale9Sprite()), cc.Node.prototype.visit.call(this, a))
    },
    _transformForRenderer: function() {
        cc._renderType === cc._RENDER_TYPE_CANVAS && (this._cacheScale9Sprite(), this.transform());
        cc.Node.prototype._transformForRenderer.call(this)
    },
    init: function() {
        return this.initWithBatchNode(null, cc.rect(0, 0, 0, 0), !1, cc.rect(0, 0, 0, 0))
    },
    initWithBatchNode: function(a, b, c, d) {
        void 0 === d && (d = c, c = !1);
        a && this.updateWithBatchNode(a, b, c, d);
        this.setCascadeColorEnabled(!0);
        this.setCascadeOpacityEnabled(!0);
        this.setAnchorPoint(0.5, 0.5);
        return this._positionsAreDirty = !0
    },
    initWithFile: function(a, b, c) {
        a instanceof cc.Rect ? (c = a = b, b = cc.rect(0, 0, 0, 0)) : (b = b || cc.rect(0, 0, 0, 0), c = c || cc.rect(0, 0, 0, 0));
        if (!a) throw "ccui.Scale9Sprite.initWithFile(): file should be non-null";
        var d = cc.textureCache.getTextureForKey(a);
        d || (d = cc.textureCache.addImage(a));
        var e = d.isLoaded();
        (this._textureLoaded = e) || d.addEventListener("load", function(a) {
            var b = this._preferredSize,
                b = cc.size(b.width, b.height);
            a = a.getContentSize();
            this.updateWithBatchNode(this._scale9Image, cc.rect(0, 0, a.width, a.height), !1, this._capInsets);
            this.setPreferredSize(b);
            this._positionsAreDirty = !0;
            this.dispatchEvent("load")
        }, this);
        return this.initWithBatchNode(new cc.SpriteBatchNode(a, 9), b, !1, c)
    },
    initWithSpriteFrame: function(a, b) {
        if (!a || !a.getTexture()) throw "ccui.Scale9Sprite.initWithSpriteFrame(): spriteFrame should be non-null and its texture should be non-null";
        b = b || cc.rect(0, 0, 0, 0);
        var c = a.textureLoaded();
        (this._textureLoaded =
            c) || a.addEventListener("load", function(a) {
            var b = this._preferredSize,
                b = cc.size(b.width, b.height);
            this.updateWithBatchNode(this._scale9Image, a.getRect(), cc._renderType == cc._RENDER_TYPE_WEBGL && a.isRotated(), this._capInsets);
            this.setPreferredSize(b);
            this._positionsAreDirty = !0;
            this.dispatchEvent("load")
        }, this);
        c = new cc.SpriteBatchNode(a.getTexture(), 9);
        return this.initWithBatchNode(c, a.getRect(), cc._renderType == cc._RENDER_TYPE_WEBGL && a.isRotated(), b)
    },
    initWithSpriteFrameName: function(a, b) {
        if (!a) throw "ccui.Scale9Sprite.initWithSpriteFrameName(): spriteFrameName should be non-null";
        b = b || cc.rect(0, 0, 0, 0);
        var c = cc.spriteFrameCache.getSpriteFrame(a);
        return null == c ? (cc.log("ccui.Scale9Sprite.initWithSpriteFrameName(): can't find the sprite frame by spriteFrameName"), !1) : this.initWithSpriteFrame(c, b)
    },
    resizableSpriteWithCapInsets: function(a) {
        var b = new ccui.Scale9Sprite;
        return b && b.initWithBatchNode(this._scale9Image, this._spriteRect, !1, a) ? b : null
    },
    setOpacityModifyRGB: function(a) {
        if (this._scale9Image) {
            this._opacityModifyRGB = a;
            var b = this._scale9Image.getChildren();
            if (b)
                for (var c = 0,
                    d = b.length; c < d; c++) b[c].setOpacityModifyRGB(a)
        }
    },
    isOpacityModifyRGB: function() {
        return this._opacityModifyRGB
    },
    updateWithBatchNode: function(a, b, c, d) {
        var e = this.getOpacity(),
            f = this.getColor();
        b = cc.rect(b.x, b.y, b.width, b.height);
        this.removeAllChildren(!0);
        this._scale9Image != a && (this._scale9Image = a);
        if (!this._scale9Image) return !1;
        a = a.getTexture();
        var g = a.isLoaded();
        this._textureLoaded = g;
        if (!g) return a.addEventListener("load", function(a) {
            this._positionsAreDirty = !0;
            this.dispatchEvent("load")
        }, this), !0;
        a = this._scale9Image;
        a.removeAllChildren(!0);
        g = this._capInsets;
        g.x = d.x;
        g.y = d.y;
        g.width = d.width;
        g.height = d.height;
        this._spriteFrameRotated = c;
        g = a.getTexture();
        cc._rectEqualToZero(b) && (b = g.getContentSize(), b = cc.rect(0, 0, b.width, b.height));
        var h = this._spriteRect = b;
        h.x = b.x;
        h.y = b.y;
        h.width = b.width;
        h.height = b.height;
        this._originalSize.width = b.width;
        this._originalSize.height = b.height;
        h = this._preferredSize;
        0 === h.width && 0 === h.height && (h.width = b.width, h.height = b.height);
        h = this._capInsetsInternal;
        d && (h.x = d.x,
            h.y = d.y, h.width = d.width, h.height = d.height);
        var k = b.width;
        d = b.height;
        cc._rectEqualToZero(h) && (h.x = k / 3, h.y = d / 3, h.width = k / 3, h.height = d / 3);
        var m = h.x,
            n = h.width,
            q = k - (m + n),
            r = h.y,
            s = h.height,
            t = d - (r + s),
            u = 0,
            w = 0;
        d = cc.rect(u + 0.5 | 0, w + 0.5 | 0, m + 0.5 | 0, r + 0.5 | 0);
        var u = u + m,
            h = cc.rect(u + 0.5 | 0, w + 0.5 | 0, n + 0.5 | 0, r + 0.5 | 0),
            k = cc.rect(u + n + 0.5 | 0, w + 0.5 | 0, q + 0.5 | 0, r + 0.5 | 0),
            u = 0,
            w = 0 + r,
            v = cc.rect(u + 0.5 | 0, w + 0.5 | 0, m + 0.5 | 0, s + 0.5 | 0),
            u = u + m,
            y = cc.rect(u + 0.5 | 0, w + 0.5 | 0, n + 0.5 | 0, s + 0.5 | 0),
            u = u + n,
            D = cc.rect(u + 0.5 | 0, w + 0.5 | 0, q + 0.5 | 0, s + 0.5 | 0),
            u = 0,
            w = 0 + r +
            s,
            r = cc.rect(u + 0.5 | 0, w + 0.5 | 0, m + 0.5 | 0, t + 0.5 | 0),
            u = u + m,
            m = cc.rect(u + 0.5 | 0, w + 0.5 | 0, n + 0.5 | 0, t + 0.5 | 0),
            u = u + n,
            n = cc.rect(u + 0.5 | 0, w + 0.5 | 0, q + 0.5 | 0, t + 0.5 | 0),
            q = cc.affineTransformMakeIdentity();
        if (c) {
            c = y;
            var t = n,
                u = r,
                w = k,
                s = d,
                C = D,
                z = v,
                A = m,
                x = h,
                q = cc.affineTransformTranslate(q, b.height + b.x, b.y),
                q = cc.affineTransformRotate(q, 1.57079633),
                y = cc.rectApplyAffineTransform(y, q),
                n = cc.rectApplyAffineTransform(n, q),
                r = cc.rectApplyAffineTransform(r, q),
                k = cc.rectApplyAffineTransform(k, q);
            d = cc.rectApplyAffineTransform(d, q);
            D = cc.rectApplyAffineTransform(D,
                q);
            v = cc.rectApplyAffineTransform(v, q);
            m = cc.rectApplyAffineTransform(m, q);
            h = cc.rectApplyAffineTransform(h, q);
            c.x = y.x;
            c.y = y.y;
            t.x = n.x;
            t.y = n.y;
            u.x = r.x;
            u.y = r.y;
            w.x = k.x;
            w.y = k.y;
            s.x = d.x;
            s.y = d.y;
            C.x = D.x;
            C.y = D.y;
            z.x = v.x;
            z.y = v.y;
            A.x = m.x;
            A.y = m.y;
            x.x = h.x;
            x.y = h.y;
            this._centre = new cc.Sprite;
            this._centre.initWithTexture(g, c, !0);
            a.addChild(this._centre, 0, ccui.Scale9Sprite.POSITIONS_CENTRE);
            this._top = new cc.Sprite;
            this._top.initWithTexture(g, x, !0);
            a.addChild(this._top, 1, ccui.Scale9Sprite.POSITIONS_TOP);
            this._bottom =
                new cc.Sprite;
            this._bottom.initWithTexture(g, A, !0);
            a.addChild(this._bottom, 1, ccui.Scale9Sprite.POSITIONS_BOTTOM);
            this._left = new cc.Sprite;
            this._left.initWithTexture(g, z, !0);
            a.addChild(this._left, 1, ccui.Scale9Sprite.POSITIONS_LEFT);
            this._right = new cc.Sprite;
            this._right.initWithTexture(g, C, !0);
            a.addChild(this._right, 1, ccui.Scale9Sprite.POSITIONS_RIGHT);
            this._topLeft = new cc.Sprite;
            this._topLeft.initWithTexture(g, s, !0);
            a.addChild(this._topLeft, 2, ccui.Scale9Sprite.POSITIONS_TOPLEFT);
            this._topRight = new cc.Sprite;
            this._topRight.initWithTexture(g, w, !0);
            a.addChild(this._topRight, 2, ccui.Scale9Sprite.POSITIONS_TOPRIGHT);
            this._bottomLeft = new cc.Sprite;
            this._bottomLeft.initWithTexture(g, u, !0);
            a.addChild(this._bottomLeft, 2, ccui.Scale9Sprite.POSITIONS_BOTTOMLEFT);
            this._bottomRight = new cc.Sprite;
            this._bottomRight.initWithTexture(g, t, !0)
        } else q = cc.affineTransformTranslate(q, b.x, b.y), cc._rectApplyAffineTransformIn(y, q), cc._rectApplyAffineTransformIn(n, q), cc._rectApplyAffineTransformIn(r, q), cc._rectApplyAffineTransformIn(k,
                q), cc._rectApplyAffineTransformIn(d, q), cc._rectApplyAffineTransformIn(D, q), cc._rectApplyAffineTransformIn(v, q), cc._rectApplyAffineTransformIn(m, q), cc._rectApplyAffineTransformIn(h, q), this._centre = new cc.Sprite, this._centre.initWithTexture(g, y), a.addChild(this._centre, 0, ccui.Scale9Sprite.POSITIONS_CENTRE), this._top = new cc.Sprite, this._top.initWithTexture(g, h), a.addChild(this._top, 1, ccui.Scale9Sprite.POSITIONS_TOP), this._bottom = new cc.Sprite, this._bottom.initWithTexture(g, m), a.addChild(this._bottom,
                1, ccui.Scale9Sprite.POSITIONS_BOTTOM), this._left = new cc.Sprite, this._left.initWithTexture(g, v), a.addChild(this._left, 1, ccui.Scale9Sprite.POSITIONS_LEFT), this._right = new cc.Sprite, this._right.initWithTexture(g, D), a.addChild(this._right, 1, ccui.Scale9Sprite.POSITIONS_RIGHT), this._topLeft = new cc.Sprite, this._topLeft.initWithTexture(g, d), a.addChild(this._topLeft, 2, ccui.Scale9Sprite.POSITIONS_TOPLEFT), this._topRight = new cc.Sprite, this._topRight.initWithTexture(g, k), a.addChild(this._topRight, 2, ccui.Scale9Sprite.POSITIONS_TOPRIGHT),
            this._bottomLeft = new cc.Sprite, this._bottomLeft.initWithTexture(g, r), a.addChild(this._bottomLeft, 2, ccui.Scale9Sprite.POSITIONS_BOTTOMLEFT), this._bottomRight = new cc.Sprite, this._bottomRight.initWithTexture(g, n);
        a.addChild(this._bottomRight, 2, ccui.Scale9Sprite.POSITIONS_BOTTOMRIGHT);
        this.setContentSize(b.width, b.height);
        cc._renderType === cc._RENDER_TYPE_WEBGL && this.addChild(a);
        this._spritesGenerated && (this.setOpacity(e), this.setColor(f));
        return this._spritesGenerated = !0
    },
    setSpriteFrame: function(a) {
        var b =
            new cc.SpriteBatchNode(a.getTexture(), 9),
            c = a.textureLoaded();
        (this._textureLoaded = c) || a.addEventListener("load", function(a) {
            var b = this._preferredSize,
                b = cc.size(b.width, b.height);
            this.updateWithBatchNode(this._scale9Image, a.getRect(), cc._renderType == cc._RENDER_TYPE_WEBGL && a.isRotated(), this._capInsets);
            this.setPreferredSize(b);
            this._positionsAreDirty = !0;
            this.dispatchEvent("load")
        }, this);
        this.updateWithBatchNode(b, a.getRect(), cc._renderType == cc._RENDER_TYPE_WEBGL && a.isRotated(), cc.rect(0, 0, 0, 0));
        this._insetBottom =
            this._insetRight = this._insetTop = this._insetLeft = 0
    }
});
_p = ccui.Scale9Sprite.prototype;
cc.EventHelper.prototype.apply(_p);
cc.defineGetterSetter(_p, "preferredSize", _p.getPreferredSize, _p.setPreferredSize);
cc.defineGetterSetter(_p, "capInsets", _p.getCapInsets, _p.setCapInsets);
cc.defineGetterSetter(_p, "insetLeft", _p.getInsetLeft, _p.setInsetLeft);
cc.defineGetterSetter(_p, "insetTop", _p.getInsetTop, _p.setInsetTop);
cc.defineGetterSetter(_p, "insetRight", _p.getInsetRight, _p.setInsetRight);
cc.defineGetterSetter(_p, "insetBottom", _p.getInsetBottom, _p.setInsetBottom);
_p = null;
ccui.Scale9Sprite.create = function(a, b, c) {
    return new ccui.Scale9Sprite(a, b, c)
};
ccui.Scale9Sprite.createWithSpriteFrame = function(a, b) {
    return new ccui.Scale9Sprite(a, b)
};
ccui.Scale9Sprite.createWithSpriteFrameName = function(a, b) {
    return new ccui.Scale9Sprite(a, b)
};
ccui.Scale9Sprite.POSITIONS_CENTRE = 0;
ccui.Scale9Sprite.POSITIONS_TOP = 1;
ccui.Scale9Sprite.POSITIONS_LEFT = 2;
ccui.Scale9Sprite.POSITIONS_RIGHT = 3;
ccui.Scale9Sprite.POSITIONS_BOTTOM = 4;
ccui.Scale9Sprite.POSITIONS_TOPRIGHT = 5;
ccui.Scale9Sprite.POSITIONS_TOPLEFT = 6;
ccui.Scale9Sprite.POSITIONS_BOTTOMRIGHT = 7;
ccui.Layout = ccui.Widget.extend({
    _clippingEnabled: !1,
    _backGroundScale9Enabled: null,
    _backGroundImage: null,
    _backGroundImageFileName: null,
    _backGroundImageCapInsets: null,
    _colorType: null,
    _bgImageTexType: ccui.Widget.LOCAL_TEXTURE,
    _colorRender: null,
    _gradientRender: null,
    _color: null,
    _startColor: null,
    _endColor: null,
    _alongVector: null,
    _opacity: 255,
    _backGroundImageTextureSize: null,
    _layoutType: null,
    _doLayoutDirty: !0,
    _clippingRectDirty: !0,
    _clippingType: null,
    _clippingStencil: null,
    _scissorRectDirty: !1,
    _clippingRect: null,
    _clippingParent: null,
    _className: "Layout",
    _backGroundImageColor: null,
    _finalPositionX: 0,
    _finalPositionY: 0,
    _currentStencilEnabled: 0,
    _currentStencilWriteMask: 0,
    _currentStencilFunc: 0,
    _currentStencilRef: 0,
    _currentStencilValueMask: 0,
    _currentStencilFail: 0,
    _currentStencilPassDepthFail: 0,
    _currentStencilPassDepthPass: 0,
    _currentDepthWriteMask: 0,
    _currentAlphaTestEnabled: 0,
    _currentAlphaTestFunc: 0,
    _currentAlphaTestRef: 0,
    _backGroundImageOpacity: 0,
    _mask_layer_le: 0,
    _loopFocus: !1,
    __passFocusToChild: !1,
    _isFocusPassing: !1,
    _isInterceptTouch: !1,
    _beforeVisitCmdStencil: null,
    _afterDrawStencilCmd: null,
    _afterVisitCmdStencil: null,
    _beforeVisitCmdScissor: null,
    _afterVisitCmdScissor: null,
    _clipElemType: !1,
    ctor: function() {
        this._layoutType = ccui.Layout.ABSOLUTE;
        this._widgetType = ccui.Widget.TYPE_CONTAINER;
        this._clippingType = ccui.Layout.CLIPPING_STENCIL;
        this._colorType = ccui.Layout.BG_COLOR_NONE;
        ccui.Widget.prototype.ctor.call(this);
        this._backGroundImageCapInsets = cc.rect(0, 0, 0, 0);
        this._color = cc.color(255, 255, 255, 255);
        this._startColor =
            cc.color(255, 255, 255, 255);
        this._endColor = cc.color(255, 255, 255, 255);
        this._alongVector = cc.p(0, -1);
        this._backGroundImageTextureSize = cc.size(0, 0);
        this._clippingRect = cc.rect(0, 0, 0, 0);
        this._backGroundImageColor = cc.color(255, 255, 255, 255);
        cc._renderType == cc._RENDER_TYPE_CANVAS ? (this._rendererSaveCmd = new cc.CustomRenderCmdCanvas(this, this._onRenderSaveCmd), this._rendererSaveCmdSprite = new cc.CustomRenderCmdCanvas(this, this._onRenderSaveSpriteCmd), this._rendererClipCmd = new cc.CustomRenderCmdCanvas(this, this._onRenderClipCmd),
            this._rendererRestoreCmd = new cc.CustomRenderCmdCanvas(this, this._onRenderRestoreCmd)) : (this._beforeVisitCmdStencil = new cc.CustomRenderCmdWebGL(this, this._onBeforeVisitStencil), this._afterDrawStencilCmd = new cc.CustomRenderCmdWebGL(this, this._onAfterDrawStencil), this._afterVisitCmdStencil = new cc.CustomRenderCmdWebGL(this, this._onAfterVisitStencil), this._beforeVisitCmdScissor = new cc.CustomRenderCmdWebGL(this, this._onBeforeVisitScissor), this._afterVisitCmdScissor = new cc.CustomRenderCmdWebGL(this, this._onAfterVisitScissor))
    },
    onEnter: function() {
        ccui.Widget.prototype.onEnter.call(this);
        if (this._clippingStencil) this._clippingStencil.onEnter();
        this._clippingRectDirty = this._doLayoutDirty = !0
    },
    onExit: function() {
        ccui.Widget.prototype.onExit.call(this);
        if (this._clippingStencil) this._clippingStencil.onExit()
    },
    setLoopFocus: function(a) {
        this._loopFocus = a
    },
    isLoopFocus: function() {
        return this._loopFocus
    },
    setPassFocusToChild: function(a) {
        this.__passFocusToChild = a
    },
    isPassFocusToChild: function() {
        return this.__passFocusToChild
    },
    findNextFocusedWidget: function(a,
        b) {
        if (this._isFocusPassing || this.isFocused()) {
            var c = this.getParent();
            this._isFocusPassing = !1;
            if (this.__passFocusToChild) {
                var d = this._passFocusToChild(a, b);
                return d instanceof ccui.Layout && c ? (c._isFocusPassing = !0, c.findNextFocusedWidget(a, this)) : d
            }
            if (null == c) return this;
            c._isFocusPassing = !0;
            return c.findNextFocusedWidget(a, this)
        }
        if (b.isFocused() || b instanceof ccui.Layout)
            if (this._layoutType == ccui.Layout.LINEAR_HORIZONTAL) switch (a) {
                    case ccui.Widget.LEFT:
                        return this._getPreviousFocusedWidget(a, b);
                    case ccui.Widget.RIGHT:
                        return this._getNextFocusedWidget(a,
                            b);
                    case ccui.Widget.DOWN:
                    case ccui.Widget.UP:
                        return this._isLastWidgetInContainer(this, a) ? this._isWidgetAncestorSupportLoopFocus(b, a) ? this.findNextFocusedWidget(a, this) : b : this.findNextFocusedWidget(a, this);
                    default:
                        return cc.assert(0, "Invalid Focus Direction"), b
                } else if (this._layoutType == ccui.Layout.LINEAR_VERTICAL) switch (a) {
                    case ccui.Widget.LEFT:
                    case ccui.Widget.RIGHT:
                        return this._isLastWidgetInContainer(this, a) ? this._isWidgetAncestorSupportLoopFocus(b, a) ? this.findNextFocusedWidget(a, this) : b : this.findNextFocusedWidget(a,
                            this);
                    case ccui.Widget.DOWN:
                        return this._getNextFocusedWidget(a, b);
                    case ccui.Widget.UP:
                        return this._getPreviousFocusedWidget(a, b);
                    default:
                        return cc.assert(0, "Invalid Focus Direction"), b
                } else return cc.assert(0, "Un Supported Layout type, please use VBox and HBox instead!!!"), b;
                else return b
    },
    onPassFocusToChild: null,
    init: function() {
        return ccui.Widget.prototype.init.call(this) ? (this.ignoreContentAdaptWithSize(!1), this.setContentSize(cc.size(0, 0)), this.setAnchorPoint(0, 0), this.onPassFocusToChild = this._findNearestChildWidgetIndex.bind(this), !0) : !1
    },
    __stencilDraw: function(a) {
        a = a || cc._renderContext;
        for (var b = this._clippingStencil, c = cc.view.getScaleX(), d = cc.view.getScaleY(), e = 0; e < b._buffer.length; e++) {
            var f = b._buffer[e].verts,
                g = f[0];
            a.beginPath();
            a.moveTo(g.x * c, -g.y * d);
            for (var g = 1, h = f.length; g < h; g++) a.lineTo(f[g].x * c, -f[g].y * d)
        }
    },
    addChild: function(a, b, c) {
        a instanceof ccui.Widget && this._supplyTheLayoutParameterLackToChild(a);
        ccui.Widget.prototype.addChild.call(this, a, b, c);
        this._doLayoutDirty = !0
    },
    removeChild: function(a, b) {
        ccui.Widget.prototype.removeChild.call(this,
            a, b);
        this._doLayoutDirty = !0
    },
    removeAllChildren: function(a) {
        ccui.Widget.prototype.removeAllChildren.call(this, a);
        this._doLayoutDirty = !0
    },
    removeAllChildrenWithCleanup: function(a) {
        ccui.Widget.prototype.removeAllChildrenWithCleanup.call(this, a);
        this._doLayoutDirty = !0
    },
    isClippingEnabled: function() {
        return this._clippingEnabled
    },
    visit: function(a) {
        if (this._visible)
            if (this._adaptRenderers(), this._doLayout(), this._clippingEnabled) switch (this._clippingType) {
                case ccui.Layout.CLIPPING_STENCIL:
                    this._stencilClippingVisit(a);
                    break;
                case ccui.Layout.CLIPPING_SCISSOR:
                    this._scissorClippingVisit(a)
            } else ccui.Widget.prototype.visit.call(this, a)
    },
    _stencilClippingVisit: null,
    _stencilClippingVisitForWebGL: function(a) {
        if (this._clippingStencil && this._clippingStencil.isVisible())
            if (ccui.Layout._layer + 1 == cc.stencilBits) ccui.Layout._visit_once = !0, ccui.Layout._visit_once && (cc.log("Nesting more than " + cc.stencilBits + "stencils is not supported. Everything will be drawn without stencil for this node and its childs."), ccui.Layout._visit_once = !1), cc.Node.prototype.visit.call(this, a);
            else {
                cc.renderer.pushRenderCommand(this._beforeVisitCmdStencil);
                a = cc.current_stack;
                a.stack.push(a.top);
                cc.kmMat4Assign(this._stackMatrix, a.top);
                a.top = this._stackMatrix;
                this.transform();
                this._clippingStencil.visit();
                cc.renderer.pushRenderCommand(this._afterDrawStencilCmd);
                var b = 0,
                    c = 0;
                this.sortAllChildren();
                this.sortAllProtectedChildren();
                for (var d = this._children, e = this._protectedChildren, f = d.length, g = e.length, h; b < f; b++)
                    if ((h = d[b]) && 0 > h.getLocalZOrder()) h.visit();
                    else break;
                for (; c < g; c++)
                    if ((h = e[c]) && 0 > h.getLocalZOrder()) h.visit();
                    else break;
                for (this._rendererCmd && cc.renderer.pushRenderCommand(this._rendererCmd); b < f; b++) d[b].visit();
                for (; c < g; c++) e[c].visit();
                cc.renderer.pushRenderCommand(this._afterVisitCmdStencil);
                a.top = a.stack.pop()
            }
    },
    _stencilClippingVisitForCanvas: function(a) {
        if (this._clippingStencil && this._clippingStencil.isVisible()) {
            var b;
            this._clipElemType = this._stencil instanceof cc.Sprite ? !0 : !1;
            var c = a || cc._renderContext;
            this.transform();
            this._rendererSaveCmd &&
                cc.renderer.pushRenderCommand(this._rendererSaveCmd);
            this._clipElemType ? (cc.ProtectedNode.prototype.visit.call(this, c), this._rendererSaveCmdSprite && cc.renderer.pushRenderCommand(this._rendererSaveCmdSprite), this._clippingStencil.visit()) : this._clippingStencil.visit(c);
            this._rendererClipCmd && cc.renderer.pushRenderCommand(this._rendererClipCmd);
            if (!this._clipElemType) {
                this.sortAllChildren();
                this.sortAllProtectedChildren();
                var d = this._children,
                    e, f = this._protectedChildren,
                    g = d.length,
                    h = f.length;
                for (a =
                    0; a < g; a++)
                    if ((b = d[a]) && 0 > b._localZOrder) b.visit(c);
                    else break;
                for (e = 0; e < h; e++)
                    if ((b = f[e]) && 0 > b._localZOrder) b.visit(c);
                    else break;
                for (; a < g; a++) d[a].visit(c);
                for (; e < h; e++) f[e].visit(c);
                this._rendererRestoreCmd && cc.renderer.pushRenderCommand(this._rendererRestoreCmd)
            }
        }
    },
    _onRenderSaveCmd: function(a, b, c) {
        a = a || cc._renderContext;
        if (this._clipElemType) b = a.canvas, this._locCache = ccui.Layout._getSharedCache(), this._locCache.width = b.width, this._locCache.height = b.height, this._locCache.getContext("2d").drawImage(b,
            0, 0), a.save();
        else {
            this.transform();
            var d = this._transformWorld;
            a.save();
            a.save();
            a.transform(d.a, d.c, d.b, d.d, d.tx * b, -d.ty * c)
        }
    },
    _onRenderSaveSpriteCmd: function(a) {
        a = a || cc._renderContext;
        this._clipElemType && (a.globalCompositeOperation = "destination-in", this.transform(a))
    },
    _onRenderClipCmd: function(a) {
        a = a || cc._renderContext;
        this._clipElemType || (a.restore(), a.clip())
    },
    _onRenderRestoreCmd: function(a) {
        a = a || cc._renderContext;
        this._clipElemType && (a.restore(), a.save(), a.setTransform(1, 0, 0, 1, 0, 0), a.globalCompositeOperation =
            "destination-over", a.drawImage(this._node._locCache, 0, 0));
        a.restore()
    },
    _scissorClippingVisit: null,
    _scissorClippingVisitForWebGL: function(a) {
        cc.renderer.pushRenderCommand(this._beforeVisitCmdScissor);
        cc.ProtectedNode.prototype.visit.call(this);
        cc.renderer.pushRenderCommand(this._afterVisitCmdScissor)
    },
    setClippingEnabled: function(a) {
        if (a != this._clippingEnabled) switch (this._clippingEnabled = a, this._clippingType) {
            case ccui.Layout.CLIPPING_STENCIL:
                if (a) {
                    this._clippingStencil = new cc.DrawNode;
                    cc._renderType ===
                        cc._RENDER_TYPE_CANVAS && (this._clippingStencil._rendererCmd.rendering = this.__stencilDraw.bind(this));
                    if (this._running) this._clippingStencil.onEnter();
                    this._setStencilClippingSize(this._contentSize)
                } else {
                    if (this._running && this._clippingStencil) this._clippingStencil.onExit();
                    this._clippingStencil = null
                }
        }
    },
    setClippingType: function(a) {
        if (a != this._clippingType)
            if (cc._renderType === cc._RENDER_TYPE_CANVAS && a == ccui.Layout.CLIPPING_SCISSOR) cc.log("Only supports STENCIL on canvas mode.");
            else {
                var b = this.isClippingEnabled();
                this.setClippingEnabled(!1);
                this._clippingType = a;
                this.setClippingEnabled(b)
            }
    },
    getClippingType: function() {
        return this._clippingType
    },
    _setStencilClippingSize: function(a) {
        if (this._clippingEnabled && this._clippingType == ccui.Layout.CLIPPING_STENCIL) {
            var b = [];
            b[0] = cc.p(0, 0);
            b[1] = cc.p(a.width, 0);
            b[2] = cc.p(a.width, a.height);
            b[3] = cc.p(0, a.height);
            a = cc.color.GREEN;
            this._clippingStencil.clear();
            this._clippingStencil.drawPoly(b, 4, a, 0, a)
        }
    },
    _getClippingRect: function() {
        if (this._clippingRectDirty) {
            for (var a = this.convertToWorldSpace(cc.p(0,
                0)), b = this.nodeToWorldTransform(), c = this._contentSize.width * b.a, d = this._contentSize.height * b.d, b = this; b;)
                if ((b = b.getParent()) && b instanceof ccui.Layout && b.isClippingEnabled()) {
                    this._clippingParent = b;
                    break
                }
            if (this._clippingParent) {
                var b = this._clippingParent._getClippingRect(),
                    e = a.x - c * this._anchorPoint.x,
                    f = a.y - d * this._anchorPoint.y,
                    g = c,
                    h = d,
                    k = a.x - b.x;
                0 > k && (e = b.x, g += k);
                c = a.x + c - (b.x + b.width);
                0 < c && (g -= c);
                c = a.y + d - (b.y + b.height);
                0 < c && (h -= c);
                a = a.y - b.y;
                0 > a && (f = b.x, h += a);
                0 > g && (g = 0);
                0 > h && (h = 0);
                this._clippingRect.x =
                    e;
                this._clippingRect.y = f;
                this._clippingRect.width = g;
                this._clippingRect.height = h
            } else this._clippingRect.x = a.x - c * this._anchorPoint.x, this._clippingRect.y = a.y - d * this._anchorPoint.y, this._clippingRect.width = c, this._clippingRect.height = d;
            this._clippingRectDirty = !1
        }
        return this._clippingRect
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this);
        var a = this._contentSize;
        this._setStencilClippingSize(a);
        this._clippingRectDirty = this._doLayoutDirty = !0;
        this._backGroundImage && (this._backGroundImage.setPosition(0.5 *
            a.width, 0.5 * a.height), this._backGroundScale9Enabled && this._backGroundImage instanceof ccui.Scale9Sprite && this._backGroundImage.setPreferredSize(a));
        this._colorRender && this._colorRender.setContentSize(a);
        this._gradientRender && this._gradientRender.setContentSize(a)
    },
    setBackGroundImageScale9Enabled: function(a) {
        this._backGroundScale9Enabled != a && (this.removeProtectedChild(this._backGroundImage), this._backGroundImage = null, this._backGroundScale9Enabled = a, this._addBackGroundImage(), this.setBackGroundImage(this._backGroundImageFileName,
            this._bgImageTexType), this.setBackGroundImageCapInsets(this._backGroundImageCapInsets))
    },
    isBackGroundImageScale9Enabled: function() {
        return this._backGroundScale9Enabled
    },
    setBackGroundImage: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            null == this._backGroundImage && (this._addBackGroundImage(), this.setBackGroundImageScale9Enabled(this._backGroundScale9Enabled));
            this._backGroundImageFileName = a;
            this._bgImageTexType = b;
            var c = this._backGroundImage;
            if (this._backGroundScale9Enabled) {
                switch (this._bgImageTexType) {
                    case ccui.Widget.LOCAL_TEXTURE:
                        c.initWithFile(a);
                        break;
                    case ccui.Widget.PLIST_TEXTURE:
                        c.initWithSpriteFrameName(a)
                }
                c.setPreferredSize(this._contentSize)
            } else switch (this._bgImageTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    c.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    c.initWithSpriteFrameName(a)
            }
            this._backGroundImageTextureSize = c.getContentSize();
            c.setPosition(0.5 * this._contentSize.width, 0.5 * this._contentSize.height);
            this._updateBackGroundImageColor()
        }
    },
    setBackGroundImageCapInsets: function(a) {
        if (a) {
            var b = this._backGroundImageCapInsets;
            b.x =
                a.x;
            b.y = a.y;
            b.width = a.width;
            b.height = a.height;
            this._backGroundScale9Enabled && this._backGroundImage.setCapInsets(a)
        }
    },
    getBackGroundImageCapInsets: function() {
        return cc.rect(this._backGroundImageCapInsets)
    },
    _supplyTheLayoutParameterLackToChild: function(a) {
        if (a) switch (this._layoutType) {
            case ccui.Layout.LINEAR_HORIZONTAL:
            case ccui.Layout.LINEAR_VERTICAL:
                var b = a.getLayoutParameter(ccui.LayoutParameter.LINEAR);
                b || a.setLayoutParameter(new ccui.LinearLayoutParameter);
                break;
            case ccui.Layout.RELATIVE:
                (b = a.getLayoutParameter(ccui.LayoutParameter.RELATIVE)) ||
                a.setLayoutParameter(new ccui.RelativeLayoutParameter)
        }
    },
    _addBackGroundImage: function() {
        this._backGroundScale9Enabled ? (this._backGroundImage = new ccui.Scale9Sprite, this._backGroundImage.setPreferredSize(this._contentSize)) : this._backGroundImage = new cc.Sprite;
        this.addProtectedChild(this._backGroundImage, ccui.Layout.BACKGROUND_IMAGE_ZORDER, -1);
        this._backGroundImage.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    },
    removeBackGroundImage: function() {
        this._backGroundImage && (this.removeProtectedChild(this._backGroundImage),
            this._backGroundImage = null, this._backGroundImageFileName = "", this._backGroundImageTextureSize.width = 0, this._backGroundImageTextureSize.height = 0)
    },
    setBackGroundColorType: function(a) {
        if (this._colorType != a) {
            switch (this._colorType) {
                case ccui.Layout.BG_COLOR_NONE:
                    this._colorRender && (this.removeProtectedChild(this._colorRender), this._colorRender = null);
                    this._gradientRender && (this.removeProtectedChild(this._gradientRender), this._gradientRender = null);
                    break;
                case ccui.Layout.BG_COLOR_SOLID:
                    this._colorRender &&
                        (this.removeProtectedChild(this._colorRender), this._colorRender = null);
                    break;
                case ccui.Layout.BG_COLOR_GRADIENT:
                    this._gradientRender && (this.removeProtectedChild(this._gradientRender), this._gradientRender = null)
            }
            this._colorType = a;
            switch (this._colorType) {
                case ccui.Layout.BG_COLOR_SOLID:
                    this._colorRender = new cc.LayerColor;
                    this._colorRender.setContentSize(this._contentSize);
                    this._colorRender.setOpacity(this._opacity);
                    this._colorRender.setColor(this._color);
                    this.addProtectedChild(this._colorRender, ccui.Layout.BACKGROUND_RENDERER_ZORDER, -1);
                    break;
                case ccui.Layout.BG_COLOR_GRADIENT:
                    this._gradientRender = new cc.LayerGradient(cc.color(255, 0, 0, 255), cc.color(0, 255, 0, 255)), this._gradientRender.setContentSize(this._contentSize), this._gradientRender.setOpacity(this._opacity), this._gradientRender.setStartColor(this._startColor), this._gradientRender.setEndColor(this._endColor), this._gradientRender.setVector(this._alongVector), this.addProtectedChild(this._gradientRender, ccui.Layout.BACKGROUND_RENDERER_ZORDER, -1)
            }
        }
    },
    getBackGroundColorType: function() {
        return this._colorType
    },
    setBackGroundColor: function(a, b) {
        b ? (this._startColor.r = a.r, this._startColor.g = a.g, this._startColor.b = a.b, this._gradientRender && this._gradientRender.setStartColor(a), this._endColor.r = b.r, this._endColor.g = b.g, this._endColor.b = b.b, this._gradientRender && this._gradientRender.setEndColor(b)) : (this._color.r = a.r, this._color.g = a.g, this._color.b = a.b, this._colorRender && this._colorRender.setColor(a))
    },
    getBackGroundColor: function() {
        var a = this._color;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    getBackGroundStartColor: function() {
        var a =
            this._startColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    getBackGroundEndColor: function() {
        var a = this._endColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    setBackGroundColorOpacity: function(a) {
        this._opacity = a;
        switch (this._colorType) {
            case ccui.Layout.BG_COLOR_SOLID:
                this._colorRender.setOpacity(a);
                break;
            case ccui.Layout.BG_COLOR_GRADIENT:
                this._gradientRender.setOpacity(a)
        }
    },
    getBackGroundColorOpacity: function() {
        return this._opacity
    },
    setBackGroundColorVector: function(a) {
        this._alongVector.x = a.x;
        this._alongVector.y = a.y;
        this._gradientRender && this._gradientRender.setVector(a)
    },
    getBackGroundColorVector: function() {
        return this._alongVector
    },
    setBackGroundImageColor: function(a) {
        this._backGroundImageColor.r = a.r;
        this._backGroundImageColor.g = a.g;
        this._backGroundImageColor.b = a.b;
        this._updateBackGroundImageColor()
    },
    setBackGroundImageOpacity: function(a) {
        this._backGroundImageColor.a = a;
        this.getBackGroundImageColor()
    },
    getBackGroundImageColor: function() {
        var a = this._backGroundImageColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    getBackGroundImageOpacity: function() {
        return this._backGroundImageColor.a
    },
    _updateBackGroundImageColor: function() {
        this._backGroundImage && this._backGroundImage.setColor(this._backGroundImageColor)
    },
    getBackGroundImageTextureSize: function() {
        return this._backGroundImageTextureSize
    },
    setLayoutType: function(a) {
        this._layoutType = a;
        a = this._children;
        for (var b = null, c = 0; c < a.length; c++) b = a[c], b instanceof ccui.Widget && this._supplyTheLayoutParameterLackToChild(b);
        this._doLayoutDirty = !0
    },
    getLayoutType: function() {
        return this._layoutType
    },
    requestDoLayout: function() {
        this._doLayoutDirty = !0
    },
    _doLayout: function() {
        if (this._doLayoutDirty) {
            this.sortAllChildren();
            var a = ccui.getLayoutManager(this._layoutType);
            a && a._doLayout(this);
            this._doLayoutDirty = !1
        }
    },
    _getLayoutContentSize: function() {
        return this.getContentSize()
    },
    _getLayoutElements: function() {
        return this.getChildren()
    },
    _onBeforeVisitStencil: function(a) {
        a = a || cc._renderContext;
        ccui.Layout._layer++;
        var b = 1 << ccui.Layout._layer;
        this._mask_layer_le = b | b - 1;
        this._currentStencilEnabled = a.isEnabled(a.STENCIL_TEST);
        this._currentStencilWriteMask = a.getParameter(a.STENCIL_WRITEMASK);
        this._currentStencilFunc = a.getParameter(a.STENCIL_FUNC);
        this._currentStencilRef = a.getParameter(a.STENCIL_REF);
        this._currentStencilValueMask = a.getParameter(a.STENCIL_VALUE_MASK);
        this._currentStencilFail = a.getParameter(a.STENCIL_FAIL);
        this._currentStencilPassDepthFail = a.getParameter(a.STENCIL_PASS_DEPTH_FAIL);
        this._currentStencilPassDepthPass = a.getParameter(a.STENCIL_PASS_DEPTH_PASS);
        a.enable(a.STENCIL_TEST);
        a.stencilMask(b);
        this._currentDepthWriteMask = a.getParameter(a.DEPTH_WRITEMASK);
        a.depthMask(!1);
        a.stencilFunc(a.NEVER, b, b);
        a.stencilOp(a.ZERO, a.KEEP, a.KEEP);
        this._drawFullScreenQuadClearStencil();
        a.stencilFunc(a.NEVER, b, b);
        a.stencilOp(a.REPLACE, a.KEEP, a.KEEP)
    },
    _drawFullScreenQuadClearStencil: function() {
        cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
        cc.kmGLPushMatrix();
        cc.kmGLLoadIdentity();
        cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
        cc.kmGLPushMatrix();
        cc.kmGLLoadIdentity();
        cc._drawingUtil.drawSolidRect(cc.p(-1, -1), cc.p(1, 1), cc.color(255, 255, 255, 255));
        cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
        cc.kmGLPopMatrix();
        cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
        cc.kmGLPopMatrix()
    },
    _onAfterDrawStencil: function(a) {
        a = a || cc._renderContext;
        a.depthMask(this._currentDepthWriteMask);
        a.stencilFunc(a.EQUAL, this._mask_layer_le, this._mask_layer_le);
        a.stencilOp(a.KEEP, a.KEEP, a.KEEP)
    },
    _onAfterVisitStencil: function(a) {
        a = a || cc._renderContext;
        a.stencilFunc(this._currentStencilFunc, this._currentStencilRef, this._currentStencilValueMask);
        a.stencilOp(this._currentStencilFail, this._currentStencilPassDepthFail, this._currentStencilPassDepthPass);
        a.stencilMask(this._currentStencilWriteMask);
        this._currentStencilEnabled || a.disable(a.STENCIL_TEST);
        ccui.Layout._layer--
    },
    _onBeforeVisitScissor: function(a) {
        var b = this._getClippingRect();
        a = a || cc._renderContext;
        a.enable(a.SCISSOR_TEST);
        cc.view.setScissorInPoints(b.x, b.y, b.width, b.height)
    },
    _onAfterVisitScissor: function(a) {
        gl.disable(gl.SCISSOR_TEST)
    },
    _updateBackGroundImageOpacity: function() {
        this._backGroundImage && this._backGroundImage.setOpacity(this._backGroundImageOpacity)
    },
    _updateBackGroundImageRGBA: function() {
        this._backGroundImage &&
            (this._backGroundImage.setColor(this._backGroundImageColor), this._backGroundImage.setOpacity(this._backGroundImageOpacity))
    },
    _getLayoutAccumulatedSize: function() {
        for (var a = this.getChildren(), b = cc.size(0, 0), c = 0, d, e = 0, f = a.length; e < f; e++)
            if (d = a[e], null != d && d instanceof ccui.Layout) d = d._getLayoutAccumulatedSize(), b.width += d.width, b.height += d.height;
            else if (d instanceof ccui.Widget) {
            c++;
            var g = d.getLayoutParameter().getMargin();
            d = d.getContentSize();
            b.width += d.width + 0.5 * (g.right + g.left);
            b.height += d.height +
                0.5 * (g.top + g.bottom)
        }
        a = this.getLayoutType();
        a == ccui.Layout.LINEAR_HORIZONTAL && (b.height -= b.height / c * (c - 1));
        a == ccui.Layout.LINEAR_VERTICAL && (b.width -= b.width / c * (c - 1));
        return b
    },
    _findNearestChildWidgetIndex: function(a, b) {
        if (null == b || b == this) return this._findFirstFocusEnabledWidgetIndex();
        var c = 0,
            d = this.getChildren(),
            e = d.length,
            f, g = cc.FLT_MAX,
            h = 0;
        if (a == ccui.Widget.LEFT || a == ccui.Widget.RIGHT || a == ccui.Widget.DOWN || a == ccui.Widget.UP) {
            for (f = this._getWorldCenterPoint(b); c < e;) {
                var k = d[c];
                k && (k instanceof ccui.Widget &&
                    k.isFocusEnabled()) && (k = k instanceof ccui.Layout ? k._calculateNearestDistance(b) : cc.pLength(cc.pSub(this._getWorldCenterPoint(k), f)), k < g && (h = c, g = k));
                c++
            }
            return h
        }
        cc.log("invalid focus direction!");
        return 0
    },
    _findFarthestChildWidgetIndex: function(a, b) {
        if (null == b || b == this) return this._findFirstFocusEnabledWidgetIndex();
        var c = 0,
            d = this.getChildren(),
            e = d.length,
            f = -cc.FLT_MAX,
            g = 0;
        if (a == ccui.Widget.LEFT || a == ccui.Widget.RIGHT || a == ccui.Widget.DOWN || a == ccui.Widget.UP) {
            for (var h = this._getWorldCenterPoint(b); c <
                e;) {
                var k = d[c];
                k && (k instanceof ccui.Widget && k.isFocusEnabled()) && (k = k instanceof ccui.Layout ? k._calculateFarthestDistance(b) : cc.pLength(cc.pSub(this._getWorldCenterPoint(k), h)), k > f && (g = c, f = k));
                c++
            }
            return g
        }
        cc.log("invalid focus direction!!!");
        return 0
    },
    _calculateNearestDistance: function(a) {
        for (var b = cc.FLT_MAX, c = this._getWorldCenterPoint(a), d = this._children, e = 0, f = d.length; e < f; e++) {
            var g = d[e];
            if (g instanceof ccui.Layout) g = g._calculateNearestDistance(a);
            else if (g instanceof ccui.Widget && g.isFocusEnabled()) g =
                cc.pLength(cc.pSub(this._getWorldCenterPoint(g), c));
            else continue;
            g < b && (b = g)
        }
        return b
    },
    _calculateFarthestDistance: function(a) {
        for (var b = -cc.FLT_MAX, c = this._getWorldCenterPoint(a), d = this._children, e = 0, f = d.length; e < f; e++) {
            var g = d[e];
            if (g instanceof ccui.Layout) g = g._calculateFarthestDistance(a);
            else if (g instanceof ccui.Widget && g.isFocusEnabled()) g = this._getWorldCenterPoint(g), g = cc.pLength(cc.pSub(g, c));
            else continue;
            g > b && (b = g)
        }
        return b
    },
    _findProperSearchingFunctor: function(a, b) {
        if (null != b) {
            var c = this._getWorldCenterPoint(b),
                d = this._getWorldCenterPoint(this._findFirstNonLayoutWidget());
            a == ccui.Widget.LEFT ? this.onPassFocusToChild = c.x > d.x ? this._findNearestChildWidgetIndex.bind(this) : this._findFarthestChildWidgetIndex.bind(this) : a == ccui.Widget.RIGHT ? this.onPassFocusToChild = c.x > d.x ? this._findFarthestChildWidgetIndex.bind(this) : this._findNearestChildWidgetIndex.bind(this) : a == ccui.Widget.DOWN ? this.onPassFocusToChild = c.y > d.y ? this._findNearestChildWidgetIndex.bind(this) : this._findFarthestChildWidgetIndex.bind(this) : a == ccui.Widget.UP ?
                this.onPassFocusToChild = c.y < d.y ? this._findNearestChildWidgetIndex.bind(this) : this._findFarthestChildWidgetIndex.bind(this) : cc.log("invalid direction!")
        }
    },
    _findFirstNonLayoutWidget: function() {
        for (var a = this._children, b = 0, c = a.length; b < c; b++) {
            var d = a[b];
            if (d instanceof ccui.Layout) {
                if (d = d._findFirstNonLayoutWidget()) return d
            } else if (d instanceof cc.Widget) return d
        }
        return null
    },
    _findFirstFocusEnabledWidgetIndex: function() {
        for (var a = 0, b = this.getChildren(), c = b.length; a < c;) {
            var d = b[a];
            if (d && d instanceof ccui.Widget && d.isFocusEnabled()) return a;
            a++
        }
        return 0
    },
    _findFocusEnabledChildWidgetByIndex: function(a) {
        var b = this._getChildWidgetByIndex(a);
        return b ? b.isFocusEnabled() ? b : this._findFocusEnabledChildWidgetByIndex(a + 1) : null
    },
    _getWorldCenterPoint: function(a) {
        var b = a instanceof ccui.Layout ? a._getLayoutAccumulatedSize() : a.getContentSize();
        return a.convertToWorldSpace(cc.p(b.width / 2, b.height / 2))
    },
    _getNextFocusedWidget: function(a, b) {
        var c = null,
            c = this._children,
            d = c.indexOf(b),
            d = d + 1;
        if (d < c.length) {
            if (c = this._getChildWidgetByIndex(d)) {
                if (c.isFocusEnabled()) {
                    if (c instanceof ccui.Layout) return c._isFocusPassing = !0, c.findNextFocusedWidget(a, c);
                    this.dispatchFocusEvent(b, c);
                    return c
                }
                return this._getNextFocusedWidget(a, c)
            }
            return b
        }
        if (this._loopFocus) {
            if (this._checkFocusEnabledChild()) {
                c = this._getChildWidgetByIndex(0);
                if (c.isFocusEnabled()) {
                    if (c instanceof ccui.Layout) return c._isFocusPassing = !0, c.findNextFocusedWidget(a, c);
                    this.dispatchFocusEvent(b, c);
                    return c
                }
                return this._getNextFocusedWidget(a, c)
            }
            return b instanceof ccui.Layout ? b : this._focusedWidget
        }
        return this._isLastWidgetInContainer(b,
            a) ? this._isWidgetAncestorSupportLoopFocus(this, a) ? this.findNextFocusedWidget(a, this) : b instanceof ccui.Layout ? b : this._focusedWidget : this.findNextFocusedWidget(a, this)
    },
    _getPreviousFocusedWidget: function(a, b) {
        var c = null,
            c = this._children,
            d = c.indexOf(b),
            d = d - 1;
        if (0 <= d) {
            c = this._getChildWidgetByIndex(d);
            if (c.isFocusEnabled()) {
                if (c instanceof ccui.Layout) return c._isFocusPassing = !0, c.findNextFocusedWidget(a, c);
                this.dispatchFocusEvent(b, c);
                return c
            }
            return this._getPreviousFocusedWidget(a, c)
        }
        if (this._loopFocus) {
            if (this._checkFocusEnabledChild()) {
                d =
                    c.length - 1;
                c = this._getChildWidgetByIndex(d);
                if (c.isFocusEnabled()) {
                    if (c instanceof ccui.Layout) return c._isFocusPassing = !0, c.findNextFocusedWidget(a, c);
                    this.dispatchFocusEvent(b, c);
                    return c
                }
                return this._getPreviousFocusedWidget(a, c)
            }
            return b instanceof ccui.Layout ? b : this._focusedWidget
        }
        return this._isLastWidgetInContainer(b, a) ? this._isWidgetAncestorSupportLoopFocus(this, a) ? this.findNextFocusedWidget(a, this) : b instanceof ccui.Layout ? b : this._focusedWidget : this.findNextFocusedWidget(a, this)
    },
    _getChildWidgetByIndex: function(a) {
        for (var b =
            this._children, c = b.length, d = 0, e = a; a < c;) {
            var f = b[a];
            if (f && f instanceof ccui.Widget) return f;
            d++;
            a++
        }
        for (a = 0; a < e;) {
            if ((c = b[a]) && c instanceof ccui.Widget) return c;
            d++;
            a++
        }
        return null
    },
    _isLastWidgetInContainer: function(a, b) {
        var c = a.getParent();
        if (c instanceof ccui.Layout) return !0;
        var d = c.getChildren(),
            e = d.indexOf(a);
        if (c.getLayoutType() == ccui.Layout.LINEAR_HORIZONTAL) {
            if (b == ccui.Widget.LEFT) return 0 == e ? this._isLastWidgetInContainer(c, b) : !1;
            if (b == ccui.Widget.RIGHT) return e == d.length - 1 ? this._isLastWidgetInContainer(c,
                b) : !1;
            if (b == ccui.Widget.DOWN || b == ccui.Widget.UP) return this._isLastWidgetInContainer(c, b)
        } else if (c.getLayoutType() == ccui.Layout.LINEAR_VERTICAL) {
            if (b == ccui.Widget.UP) return 0 == e ? this._isLastWidgetInContainer(c, b) : !1;
            if (b == ccui.Widget.DOWN) return e == d.length - 1 ? this._isLastWidgetInContainer(c, b) : !1;
            if (b == ccui.Widget.LEFT || b == ccui.Widget.RIGHT) return this._isLastWidgetInContainer(c, b)
        } else return cc.log("invalid layout Type"), !1
    },
    _isWidgetAncestorSupportLoopFocus: function(a, b) {
        var c = a.getParent();
        if (null ==
            c) return !1;
        if (c.isLoopFocus()) {
            var d = c.getLayoutType();
            if (d == ccui.Layout.LINEAR_HORIZONTAL) return b == ccui.Widget.LEFT || b == ccui.Widget.RIGHT ? !0 : this._isWidgetAncestorSupportLoopFocus(c, b);
            if (d == ccui.Layout.LINEAR_VERTICAL) return b == ccui.Widget.DOWN || b == ccui.Widget.UP ? !0 : this._isWidgetAncestorSupportLoopFocus(c, b);
            cc.assert(0, "invalid layout type");
            return !1
        }
        return this._isWidgetAncestorSupportLoopFocus(c, b)
    },
    _passFocusToChild: function(a, b) {
        if (this._checkFocusEnabledChild()) {
            var c = ccui.Widget.getCurrentFocusedWidget();
            this._findProperSearchingFunctor(a, c);
            c = this.onPassFocusToChild(a, c);
            c = this._getChildWidgetByIndex(c);
            if (c instanceof ccui.Layout) return c._isFocusPassing = !0, c.findNextFocusedWidget(a, c);
            this.dispatchFocusEvent(b, c);
            return c
        }
        return this
    },
    _checkFocusEnabledChild: function() {
        for (var a = this._children, b = 0, c = a.length; b < c; b++) {
            var d = a[b];
            if (d && d instanceof ccui.Widget && d.isFocusEnabled()) return !0
        }
        return !1
    },
    getDescription: function() {
        return "Layout"
    },
    _createCloneInstance: function() {
        return new ccui.Layout
    },
    _copyClonedWidgetChildren: function(a) {
        ccui.Widget.prototype._copyClonedWidgetChildren.call(this, a)
    },
    _copySpecialProperties: function(a) {
        a instanceof ccui.Layout && (this.setBackGroundImageScale9Enabled(a._backGroundScale9Enabled), this.setBackGroundImage(a._backGroundImageFileName, a._bgImageTexType), this.setBackGroundImageCapInsets(a._backGroundImageCapInsets), this.setBackGroundColorType(a._colorType), this.setBackGroundColor(a._color), this.setBackGroundColor(a._startColor, a._endColor), this.setBackGroundColorOpacity(a._opacity),
            this.setBackGroundColorVector(a._alongVector), this.setLayoutType(a._layoutType), this.setClippingEnabled(a._clippingEnabled), this.setClippingType(a._clippingType), this._loopFocus = a._loopFocus, this.__passFocusToChild = a.__passFocusToChild, this._isInterceptTouch = a._isInterceptTouch)
    },
    _transformForRenderer: function(a) {
        cc._renderType === cc._RENDER_TYPE_WEBGL ? (ccui.Widget.prototype._transformForRenderer.call(this, a), this._clippingStencil && this._clippingStencil._transformForRenderer(this._stackMatrix)) : ccui.ProtectedNode.prototype._transformForRenderer.call(this)
    }
});
ccui.Layout._init_once = null;
ccui.Layout._visit_once = null;
ccui.Layout._layer = -1;
ccui.Layout._sharedCache = null;
cc._renderType == cc._RENDER_TYPE_WEBGL ? (ccui.Layout.prototype._stencilClippingVisit = ccui.Layout.prototype._stencilClippingVisitForWebGL, ccui.Layout.prototype._scissorClippingVisit = ccui.Layout.prototype._scissorClippingVisitForWebGL) : (ccui.Layout.prototype._stencilClippingVisit = ccui.Layout.prototype._stencilClippingVisitForCanvas, ccui.Layout.prototype._scissorClippingVisit = ccui.Layout.prototype._stencilClippingVisitForCanvas);
ccui.Layout._getSharedCache = function() {
    return cc.ClippingNode._sharedCache || (cc.ClippingNode._sharedCache = cc.newElement("canvas"))
};
_p = ccui.Layout.prototype;
cc.defineGetterSetter(_p, "clippingEnabled", _p.isClippingEnabled, _p.setClippingEnabled);
cc.defineGetterSetter(_p, "clippingType", null, _p.setClippingType);
cc.defineGetterSetter(_p, "layoutType", _p.getLayoutType, _p.setLayoutType);
_p = null;
ccui.Layout.create = function() {
    return new ccui.Layout
};
ccui.Layout.BG_COLOR_NONE = 0;
ccui.Layout.BG_COLOR_SOLID = 1;
ccui.Layout.BG_COLOR_GRADIENT = 2;
ccui.Layout.ABSOLUTE = 0;
ccui.Layout.LINEAR_VERTICAL = 1;
ccui.Layout.LINEAR_HORIZONTAL = 2;
ccui.Layout.RELATIVE = 3;
ccui.Layout.CLIPPING_STENCIL = 0;
ccui.Layout.CLIPPING_SCISSOR = 1;
ccui.Layout.BACKGROUND_IMAGE_ZORDER = -2;
ccui.Layout.BACKGROUND_RENDERER_ZORDER = -2;
ccui.Margin = ccui.Class.extend({
    left: 0,
    top: 0,
    right: 0,
    bottom: 0,
    ctor: function(a, b, c, d) {
        void 0 !== a && void 0 === b && (this.left = a.left, this.top = a.top, this.right = a.right, this.bottom = a.bottom);
        void 0 !== d && (this.left = a, this.top = b, this.right = c, this.bottom = d)
    },
    setMargin: function(a, b, c, d) {
        this.left = a;
        this.top = b;
        this.right = c;
        this.bottom = d
    },
    equals: function(a) {
        return this.left == a.left && this.top == a.top && this.right == a.right && this.bottom == a.bottom
    }
});
ccui.MarginZero = function() {
    return new ccui.Margin(0, 0, 0, 0)
};
ccui.LayoutParameter = ccui.Class.extend({
    _margin: null,
    _layoutParameterType: null,
    ctor: function() {
        this._margin = new ccui.Margin;
        this._layoutParameterType = ccui.LayoutParameter.NONE
    },
    setMargin: function(a, b, c, d) {
        cc.isObject(a) ? (this._margin.left = a.left, this._margin.top = a.top, this._margin.right = a.right, this._margin.bottom = a.bottom) : (this._margin.left = a, this._margin.top = b, this._margin.right = c, this._margin.bottom = d)
    },
    getMargin: function() {
        return this._margin
    },
    getLayoutType: function() {
        return this._layoutParameterType
    },
    clone: function() {
        var a = this._createCloneInstance();
        a._copyProperties(this);
        return a
    },
    _createCloneInstance: function() {
        return new ccui.LayoutParameter
    },
    _copyProperties: function(a) {
        this._margin.bottom = a._margin.bottom;
        this._margin.left = a._margin.left;
        this._margin.right = a._margin.right;
        this._margin.top = a._margin.top
    }
});
ccui.LayoutParameter.create = function() {
    return new ccui.LayoutParameter
};
ccui.LayoutParameter.NONE = 0;
ccui.LayoutParameter.LINEAR = 1;
ccui.LayoutParameter.RELATIVE = 2;
ccui.LinearLayoutParameter = ccui.LayoutParameter.extend({
    _linearGravity: null,
    ctor: function() {
        ccui.LayoutParameter.prototype.ctor.call(this);
        this._linearGravity = ccui.LinearLayoutParameter.NONE;
        this._layoutParameterType = ccui.LayoutParameter.LINEAR
    },
    setGravity: function(a) {
        this._linearGravity = a
    },
    getGravity: function() {
        return this._linearGravity
    },
    _createCloneInstance: function() {
        return new ccui.LinearLayoutParameter
    },
    _copyProperties: function(a) {
        ccui.LayoutParameter.prototype._copyProperties.call(this, a);
        a instanceof ccui.LinearLayoutParameter && this.setGravity(a._linearGravity)
    }
});
ccui.LinearLayoutParameter.create = function() {
    return new ccui.LinearLayoutParameter
};
ccui.LinearLayoutParameter.NONE = 0;
ccui.LinearLayoutParameter.LEFT = 1;
ccui.LinearLayoutParameter.TOP = 2;
ccui.LinearLayoutParameter.RIGHT = 3;
ccui.LinearLayoutParameter.BOTTOM = 4;
ccui.LinearLayoutParameter.CENTER_VERTICAL = 5;
ccui.LinearLayoutParameter.CENTER_HORIZONTAL = 6;
ccui.RelativeLayoutParameter = ccui.LayoutParameter.extend({
    _relativeAlign: null,
    _relativeWidgetName: "",
    _relativeLayoutName: "",
    _put: !1,
    ctor: function() {
        ccui.LayoutParameter.prototype.ctor.call(this);
        this._relativeAlign = ccui.RelativeLayoutParameter.NONE;
        this._relativeLayoutName = this._relativeWidgetName = "";
        this._put = !1;
        this._layoutParameterType = ccui.LayoutParameter.RELATIVE
    },
    setAlign: function(a) {
        this._relativeAlign = a
    },
    getAlign: function() {
        return this._relativeAlign
    },
    setRelativeToWidgetName: function(a) {
        this._relativeWidgetName =
            a
    },
    getRelativeToWidgetName: function() {
        return this._relativeWidgetName
    },
    setRelativeName: function(a) {
        this._relativeLayoutName = a
    },
    getRelativeName: function() {
        return this._relativeLayoutName
    },
    _createCloneInstance: function() {
        return new ccui.RelativeLayoutParameter
    },
    _copyProperties: function(a) {
        ccui.LayoutParameter.prototype._copyProperties.call(this, a);
        a instanceof ccui.RelativeLayoutParameter && (this.setAlign(a._relativeAlign), this.setRelativeToWidgetName(a._relativeWidgetName), this.setRelativeName(a._relativeLayoutName))
    }
});
ccui.RelativeLayoutParameter.create = function() {
    return new ccui.RelativeLayoutParameter
};
ccui.RelativeLayoutParameter.NONE = 0;
ccui.RelativeLayoutParameter.PARENT_TOP_LEFT = 1;
ccui.RelativeLayoutParameter.PARENT_TOP_CENTER_HORIZONTAL = 2;
ccui.RelativeLayoutParameter.PARENT_TOP_RIGHT = 3;
ccui.RelativeLayoutParameter.PARENT_LEFT_CENTER_VERTICAL = 4;
ccui.RelativeLayoutParameter.CENTER_IN_PARENT = 5;
ccui.RelativeLayoutParameter.PARENT_RIGHT_CENTER_VERTICAL = 6;
ccui.RelativeLayoutParameter.PARENT_LEFT_BOTTOM = 7;
ccui.RelativeLayoutParameter.PARENT_BOTTOM_CENTER_HORIZONTAL = 8;
ccui.RelativeLayoutParameter.PARENT_RIGHT_BOTTOM = 9;
ccui.RelativeLayoutParameter.LOCATION_ABOVE_LEFTALIGN = 10;
ccui.RelativeLayoutParameter.LOCATION_ABOVE_CENTER = 11;
ccui.RelativeLayoutParameter.LOCATION_ABOVE_RIGHTALIGN = 12;
ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_TOPALIGN = 13;
ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_CENTER = 14;
ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_BOTTOMALIGN = 15;
ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_TOPALIGN = 16;
ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_CENTER = 17;
ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_BOTTOMALIGN = 18;
ccui.RelativeLayoutParameter.LOCATION_BELOW_LEFTALIGN = 19;
ccui.RelativeLayoutParameter.LOCATION_BELOW_CENTER = 20;
ccui.RelativeLayoutParameter.LOCATION_BELOW_RIGHTALIGN = 21;
ccui.LINEAR_GRAVITY_NONE = 0;
ccui.LINEAR_GRAVITY_LEFT = 1;
ccui.LINEAR_GRAVITY_TOP = 2;
ccui.LINEAR_GRAVITY_RIGHT = 3;
ccui.LINEAR_GRAVITY_BOTTOM = 4;
ccui.LINEAR_GRAVITY_CENTER_VERTICAL = 5;
ccui.LINEAR_GRAVITY_CENTER_HORIZONTAL = 6;
ccui.RELATIVE_ALIGN_NONE = 0;
ccui.RELATIVE_ALIGN_PARENT_TOP_LEFT = 1;
ccui.RELATIVE_ALIGN_PARENT_TOP_CENTER_HORIZONTAL = 2;
ccui.RELATIVE_ALIGN_PARENT_TOP_RIGHT = 3;
ccui.RELATIVE_ALIGN_PARENT_LEFT_CENTER_VERTICAL = 4;
ccui.RELATIVE_ALIGN_PARENT_CENTER = 5;
ccui.RELATIVE_ALIGN_PARENT_RIGHT_CENTER_VERTICAL = 6;
ccui.RELATIVE_ALIGN_PARENT_LEFT_BOTTOM = 7;
ccui.RELATIVE_ALIGN_PARENT_BOTTOM_CENTER_HORIZONTAL = 8;
ccui.RELATIVE_ALIGN_PARENT_RIGHT_BOTTOM = 9;
ccui.RELATIVE_ALIGN_LOCATION_ABOVE_LEFT = 10;
ccui.RELATIVE_ALIGN_LOCATION_ABOVE_CENTER = 11;
ccui.RELATIVE_ALIGN_LOCATION_ABOVE_RIGHT = 12;
ccui.RELATIVE_ALIGN_LOCATION_LEFT_TOP = 13;
ccui.RELATIVE_ALIGN_LOCATION_LEFT_CENTER = 14;
ccui.RELATIVE_ALIGN_LOCATION_LEFT_BOTTOM = 15;
ccui.RELATIVE_ALIGN_LOCATION_RIGHT_TOP = 16;
ccui.RELATIVE_ALIGN_LOCATION_RIGHT_CENTER = 17;
ccui.RELATIVE_ALIGN_LOCATION_RIGHT_BOTTOM = 18;
ccui.RELATIVE_ALIGN_LOCATION_BELOW_TOP = 19;
ccui.RELATIVE_ALIGN_LOCATION_BELOW_CENTER = 20;
ccui.RELATIVE_ALIGN_LOCATION_BELOW_BOTTOM = 21;
ccui.getLayoutManager = function(a) {
    switch (a) {
        case ccui.Layout.LINEAR_VERTICAL:
            return ccui.linearVerticalLayoutManager;
        case ccui.Layout.LINEAR_HORIZONTAL:
            return ccui.linearHorizontalLayoutManager;
        case ccui.Layout.RELATIVE:
            return ccui.relativeLayoutManager
    }
    return null
};
ccui.linearVerticalLayoutManager = {
    _doLayout: function(a) {
        var b = a._getLayoutContentSize();
        a = a._getLayoutElements();
        for (var c = b.height, d = 0, e = a.length; d < e; d++) {
            var f = a[d];
            if (f) {
                var g = f.getLayoutParameter();
                if (g) {
                    var h = g.getGravity(),
                        k = f.getAnchorPoint(),
                        m = f.getContentSize(),
                        n = k.x * m.width,
                        c = c - (1 - k.y) * m.height;
                    switch (h) {
                        case ccui.LinearLayoutParameter.RIGHT:
                            n = b.width - (1 - k.x) * m.width;
                            break;
                        case ccui.LinearLayoutParameter.CENTER_HORIZONTAL:
                            n = b.width / 2 - m.width * (0.5 - k.x)
                    }
                    g = g.getMargin();
                    n += g.left;
                    c -= g.top;
                    f.setPosition(n, c);
                    c = f.getPositionY() - f.getAnchorPoint().y * f.getContentSize().height - g.bottom
                }
            }
        }
    }
};
ccui.linearHorizontalLayoutManager = {
    _doLayout: function(a) {
        var b = a._getLayoutContentSize();
        a = a._getLayoutElements();
        for (var c = 0, d = 0, e = a.length; d < e; d++) {
            var f = a[d];
            if (f) {
                var g = f.getLayoutParameter();
                if (g) {
                    var h = g.getGravity(),
                        k = f.getAnchorPoint(),
                        m = f.getSize(),
                        c = c + k.x * m.width,
                        n = b.height - (1 - k.y) * m.height;
                    switch (h) {
                        case ccui.LinearLayoutParameter.BOTTOM:
                            n = k.y * m.height;
                            break;
                        case ccui.LinearLayoutParameter.CENTER_VERTICAL:
                            n = b.height / 2 - m.height * (0.5 - k.y)
                    }
                    g = g.getMargin();
                    c += g.left;
                    n -= g.top;
                    f.setPosition(c,
                        n);
                    c = f.getRightBoundary() + g.right
                }
            }
        }
    }
};
ccui.relativeLayoutManager = {
    _unlayoutChildCount: 0,
    _widgetChildren: [],
    _widget: null,
    _finalPositionX: 0,
    _finalPositionY: 0,
    _relativeWidgetLP: null,
    _doLayout: function(a) {
        for (var b = this._widgetChildren = this._getAllWidgets(a); 0 < this._unlayoutChildCount;) {
            for (var c = 0, d = b.length; c < d; c++) {
                this._widget = b[c];
                var e = this._widget.getLayoutParameter();
                e && !e._put && this._calculateFinalPositionWithRelativeWidget(a) && (this._calculateFinalPositionWithRelativeAlign(), this._widget.setPosition(this._finalPositionX, this._finalPositionY),
                    e._put = !0)
            }
            this._unlayoutChildCount--
        }
        this._widgetChildren.length = 0
    },
    _getAllWidgets: function(a) {
        a = a._getLayoutElements();
        for (var b = this._widgetChildren, c = b.length = 0, d = a.length; c < d; c++) {
            var e = a[c];
            e && (e.getLayoutParameter()._put = !1, this._unlayoutChildCount++, b.push(e))
        }
        return b
    },
    _getRelativeWidget: function(a) {
        var b = null;
        if ((a = a.getLayoutParameter().getRelativeToWidgetName()) && 0 != a.length)
            for (var c = this._widgetChildren, d = 0, e = c.length; d < e; d++) {
                var f = c[d];
                if (f) {
                    var g = f.getLayoutParameter();
                    if (g && g.getRelativeName() ==
                        a) {
                        b = f;
                        this._relativeWidgetLP = g;
                        break
                    }
                }
            }
        return b
    },
    _calculateFinalPositionWithRelativeWidget: function(a) {
        var b = this._widget,
            c = b.getAnchorPoint(),
            d = b.getContentSize();
        this._finalPositionY = this._finalPositionX = 0;
        var e = this._getRelativeWidget(b),
            b = b.getLayoutParameter().getAlign();
        a = a._getLayoutContentSize();
        switch (b) {
            case ccui.RelativeLayoutParameter.NONE:
            case ccui.RelativeLayoutParameter.PARENT_TOP_LEFT:
                this._finalPositionX = c.x * d.width;
                this._finalPositionY = a.height - (1 - c.y) * d.height;
                break;
            case ccui.RelativeLayoutParameter.PARENT_TOP_CENTER_HORIZONTAL:
                this._finalPositionX =
                    0.5 * a.width - d.width * (0.5 - c.x);
                this._finalPositionY = a.height - (1 - c.y) * d.height;
                break;
            case ccui.RelativeLayoutParameter.PARENT_TOP_RIGHT:
                this._finalPositionX = a.width - (1 - c.x) * d.width;
                this._finalPositionY = a.height - (1 - c.y) * d.height;
                break;
            case ccui.RelativeLayoutParameter.PARENT_LEFT_CENTER_VERTICAL:
                this._finalPositionX = c.x * d.width;
                this._finalPositionY = 0.5 * a.height - d.height * (0.5 - c.y);
                break;
            case ccui.RelativeLayoutParameter.CENTER_IN_PARENT:
                this._finalPositionX = 0.5 * a.width - d.width * (0.5 - c.x);
                this._finalPositionY =
                    0.5 * a.height - d.height * (0.5 - c.y);
                break;
            case ccui.RelativeLayoutParameter.PARENT_RIGHT_CENTER_VERTICAL:
                this._finalPositionX = a.width - (1 - c.x) * d.width;
                this._finalPositionY = 0.5 * a.height - d.height * (0.5 - c.y);
                break;
            case ccui.RelativeLayoutParameter.PARENT_LEFT_BOTTOM:
                this._finalPositionX = c.x * d.width;
                this._finalPositionY = c.y * d.height;
                break;
            case ccui.RelativeLayoutParameter.PARENT_BOTTOM_CENTER_HORIZONTAL:
                this._finalPositionX = 0.5 * a.width - d.width * (0.5 - c.x);
                this._finalPositionY = c.y * d.height;
                break;
            case ccui.RelativeLayoutParameter.PARENT_RIGHT_BOTTOM:
                this._finalPositionX =
                    a.width - (1 - c.x) * d.width;
                this._finalPositionY = c.y * d.height;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_ABOVE_LEFTALIGN:
                if (e) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    this._finalPositionY = e.getTopBoundary() + c.y * d.height;
                    this._finalPositionX = e.getLeftBoundary() + c.x * d.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_ABOVE_CENTER:
                if (e) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    a = e.getContentSize();
                    this._finalPositionY = e.getTopBoundary() + c.y * d.height;
                    this._finalPositionX = e.getLeftBoundary() + 0.5 * a.width + c.x * d.width - 0.5 * d.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_ABOVE_RIGHTALIGN:
                if (e) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    this._finalPositionY = e.getTopBoundary() + c.y * d.height;
                    this._finalPositionX = e.getRightBoundary() - (1 - c.x) * d.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_TOPALIGN:
                if (e) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    this._finalPositionY = e.getTopBoundary() -
                        (1 - c.y) * d.height;
                    this._finalPositionX = e.getLeftBoundary() - (1 - c.x) * d.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_CENTER:
                if (e) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    a = e.getContentSize();
                    this._finalPositionX = e.getLeftBoundary() - (1 - c.x) * d.width;
                    this._finalPositionY = e.getBottomBoundary() + 0.5 * a.height + c.y * d.height - 0.5 * d.height
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_BOTTOMALIGN:
                if (e) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    this._finalPositionY = e.getBottomBoundary() + c.y * d.height;
                    this._finalPositionX = e.getLeftBoundary() - (1 - c.x) * d.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_TOPALIGN:
                if (e) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    this._finalPositionY = e.getTopBoundary() - (1 - c.y) * d.height;
                    this._finalPositionX = e.getRightBoundary() + c.x * d.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_CENTER:
                if (e) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    a = e.getContentSize();
                    this._finalPositionX = e.getRightBoundary() + c.x * d.width;
                    this._finalPositionY = e.getBottomBoundary() + 0.5 * a.height + c.y * d.height - 0.5 * d.height
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_BOTTOMALIGN:
                if (e) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    this._finalPositionY = e.getBottomBoundary() + c.y * d.height;
                    this._finalPositionX = e.getRightBoundary() + c.x * d.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_BELOW_LEFTALIGN:
                if (e) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    this._finalPositionY = e.getBottomBoundary() - (1 - c.y) * d.height;
                    this._finalPositionX = e.getLeftBoundary() + c.x * d.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_BELOW_CENTER:
                if (e) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    a = e.getContentSize();
                    this._finalPositionY = e.getBottomBoundary() - (1 - c.y) * d.height;
                    this._finalPositionX = e.getLeftBoundary() + 0.5 * a.width + c.x * d.width - 0.5 * d.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_BELOW_RIGHTALIGN:
                if (e) {
                    if (this._relativeWidgetLP &&
                        !this._relativeWidgetLP._put) return !1;
                    this._finalPositionY = e.getBottomBoundary() - (1 - c.y) * d.height;
                    this._finalPositionX = e.getRightBoundary() - (1 - c.x) * d.width
                }
        }
        return !0
    },
    _calculateFinalPositionWithRelativeAlign: function() {
        var a = this._widget.getLayoutParameter(),
            b = a.getMargin();
        switch (a.getAlign()) {
            case ccui.RelativeLayoutParameter.NONE:
            case ccui.RelativeLayoutParameter.PARENT_TOP_LEFT:
                this._finalPositionX += b.left;
                this._finalPositionY -= b.top;
                break;
            case ccui.RelativeLayoutParameter.PARENT_TOP_CENTER_HORIZONTAL:
                this._finalPositionY -=
                    b.top;
                break;
            case ccui.RelativeLayoutParameter.PARENT_TOP_RIGHT:
                this._finalPositionX -= b.right;
                this._finalPositionY -= b.top;
                break;
            case ccui.RelativeLayoutParameter.PARENT_LEFT_CENTER_VERTICAL:
                this._finalPositionX += b.left;
                break;
            case ccui.RelativeLayoutParameter.PARENT_RIGHT_CENTER_VERTICAL:
                this._finalPositionX -= b.right;
                break;
            case ccui.RelativeLayoutParameter.PARENT_LEFT_BOTTOM:
                this._finalPositionX += b.left;
                this._finalPositionY += b.bottom;
                break;
            case ccui.RelativeLayoutParameter.PARENT_BOTTOM_CENTER_HORIZONTAL:
                this._finalPositionY +=
                    b.bottom;
                break;
            case ccui.RelativeLayoutParameter.PARENT_RIGHT_BOTTOM:
                this._finalPositionX -= b.right;
                this._finalPositionY += b.bottom;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_ABOVE_LEFTALIGN:
                this._finalPositionY += b.bottom;
                this._finalPositionX += b.left;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_ABOVE_RIGHTALIGN:
                this._finalPositionY += b.bottom;
                this._finalPositionX -= b.right;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_ABOVE_CENTER:
                this._finalPositionY += b.bottom;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_TOPALIGN:
                this._finalPositionX -=
                    b.right;
                this._finalPositionY -= b.top;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_BOTTOMALIGN:
                this._finalPositionX -= b.right;
                this._finalPositionY += b.bottom;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_CENTER:
                this._finalPositionX -= b.right;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_TOPALIGN:
                this._finalPositionX += b.left;
                this._finalPositionY -= b.top;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_BOTTOMALIGN:
                this._finalPositionX += b.left;
                this._finalPositionY +=
                    b.bottom;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_CENTER:
                this._finalPositionX += b.left;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_BELOW_LEFTALIGN:
                this._finalPositionY -= b.top;
                this._finalPositionX += b.left;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_BELOW_RIGHTALIGN:
                this._finalPositionY -= b.top;
                this._finalPositionX -= b.right;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_BELOW_CENTER:
                this._finalPositionY -= b.top
        }
    }
};
ccui.HBox = ccui.Layout.extend({
    ctor: function(a) {
        void 0 !== a ? this.initWithSize(a) : this.init()
    },
    init: function() {
        return ccui.Layout.prototype.init.call(this) ? (this.setLayoutType(ccui.Layout.LINEAR_HORIZONTAL), !0) : !1
    },
    initWithSize: function(a) {
        return this.init() ? (this.setContentSize(a), !0) : !1
    }
});
ccui.HBox.create = function(a) {
    return new ccui.HBox(a)
};
ccui.RelativeBox = ccui.Layout.extend({
    ctor: function(a) {
        a ? this.initWithSize(a) : this.init()
    },
    init: function() {
        return ccui.Layout.prototype.init.call(this) ? (this.setLayoutType(ccui.Layout.RELATIVE), !0) : !1
    },
    initWithSize: function(a) {
        return this.init() ? (this.setContentSize(a), !0) : !1
    }
});
ccui.RelativeBox.create = function(a) {
    return new ccui.RelativeBox(a)
};
ccui.VBox = ccui.Layout.extend({
    ctor: function(a) {
        void 0 !== a ? this.initWithSize(a) : this.init()
    },
    init: function() {
        return ccui.Layout.prototype.init.call(this) ? (this.setLayoutType(ccui.Layout.LINEAR_VERTICAL), !0) : !1
    },
    initWithSize: function(a) {
        return this.init() ? (this.setContentSize(a), !0) : !1
    }
});
ccui.VBox.create = function(a) {
    return new ccui.VBox(a)
};
ccui.helper = {
    seekWidgetByTag: function(a, b) {
        if (!a) return null;
        if (a.getTag() == b) return a;
        for (var c = a.getChildren(), d = c.length, e = 0; e < d; e++) {
            var f = ccui.helper.seekWidgetByTag(c[e], b);
            if (null != f) return f
        }
        return null
    },
    seekWidgetByName: function(a, b) {
        if (!a) return null;
        if (a.getName() == b) return a;
        for (var c = a.getChildren(), d = c.length, e = 0; e < d; e++) {
            var f = ccui.helper.seekWidgetByName(c[e], b);
            if (null != f) return f
        }
        return null
    },
    seekWidgetByRelativeName: function(a, b) {
        if (!a) return null;
        for (var c = a.getChildren(), d = c.length,
            e = 0; e < d; e++) {
            var f = c[e],
                g = f.getLayoutParameter(ccui.LayoutParameter.RELATIVE);
            if (g && g.getRelativeName() == b) return f
        }
        return null
    },
    seekActionWidgetByActionTag: function(a, b) {
        if (!a) return null;
        if (a.getActionTag() == b) return a;
        for (var c = a.getChildren(), d = 0; d < c.length; d++) {
            var e = ccui.helper.seekActionWidgetByActionTag(c[d], b);
            if (null != e) return e
        }
        return null
    }
};
ccui.Button = ccui.Widget.extend({
    _buttonNormalRenderer: null,
    _buttonClickedRenderer: null,
    _buttonDisableRenderer: null,
    _titleRenderer: null,
    _normalFileName: "",
    _clickedFileName: "",
    _disabledFileName: "",
    _prevIgnoreSize: !0,
    _scale9Enabled: !1,
    _capInsetsNormal: null,
    _capInsetsPressed: null,
    _capInsetsDisabled: null,
    _normalTexType: ccui.Widget.LOCAL_TEXTURE,
    _pressedTexType: ccui.Widget.LOCAL_TEXTURE,
    _disabledTexType: ccui.Widget.LOCAL_TEXTURE,
    _normalTextureSize: null,
    _pressedTextureSize: null,
    _disabledTextureSize: null,
    pressedActionEnabled: !1,
    _titleColor: null,
    _normalTextureScaleXInSize: 1,
    _normalTextureScaleYInSize: 1,
    _pressedTextureScaleXInSize: 1,
    _pressedTextureScaleYInSize: 1,
    _zoomScale: 0.1,
    _normalTextureLoaded: !1,
    _pressedTextureLoaded: !1,
    _disabledTextureLoaded: !1,
    _className: "Button",
    _normalTextureAdaptDirty: !0,
    _pressedTextureAdaptDirty: !0,
    _disabledTextureAdaptDirty: !0,
    _fontName: "Thonburi",
    _fontSize: 12,
    _type: 0,
    ctor: function(a, b, c, d) {
        this._capInsetsNormal = cc.rect(0, 0, 0, 0);
        this._capInsetsPressed = cc.rect(0, 0, 0, 0);
        this._capInsetsDisabled =
            cc.rect(0, 0, 0, 0);
        this._normalTextureSize = cc.size(0, 0);
        this._pressedTextureSize = cc.size(0, 0);
        this._disabledTextureSize = cc.size(0, 0);
        this._titleColor = cc.color.WHITE;
        ccui.Widget.prototype.ctor.call(this);
        this.setTouchEnabled(!0);
        void 0 !== d && this.init(a, b, c, d)
    },
    init: function(a, b, c, d) {
        if (ccui.Widget.prototype.init.call(this)) {
            if (void 0 === a) return !0;
            this.loadTextures(a, b, c, d)
        }
        return !1
    },
    _initRenderer: function() {
        this._buttonNormalRenderer = new cc.Sprite;
        this._buttonClickedRenderer = new cc.Sprite;
        this._buttonDisableRenderer =
            new cc.Sprite;
        this._titleRenderer = new cc.LabelTTF("");
        this._titleRenderer.setAnchorPoint(0.5, 0.5);
        this.addProtectedChild(this._buttonNormalRenderer, ccui.Button.NORMAL_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._buttonClickedRenderer, ccui.Button.PRESSED_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._buttonDisableRenderer, ccui.Button.DISABLED_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._titleRenderer, ccui.Button.TITLE_RENDERER_ZORDER, -1)
    },
    setScale9Enabled: function(a) {
        this._scale9Enabled !=
            a && (this._brightStyle = ccui.Widget.BRIGHT_STYLE_NONE, this._scale9Enabled = a, this.removeProtectedChild(this._buttonNormalRenderer), this.removeProtectedChild(this._buttonClickedRenderer), this.removeProtectedChild(this._buttonDisableRenderer), this._scale9Enabled ? (this._buttonNormalRenderer = new ccui.Scale9Sprite, this._buttonClickedRenderer = new ccui.Scale9Sprite, this._buttonDisableRenderer = new ccui.Scale9Sprite) : (this._buttonNormalRenderer = new cc.Sprite, this._buttonClickedRenderer = new cc.Sprite, this._buttonDisableRenderer =
                new cc.Sprite), this._buttonClickedRenderer.setVisible(!1), this._buttonDisableRenderer.setVisible(!1), this.loadTextureNormal(this._normalFileName, this._normalTexType), this.loadTexturePressed(this._clickedFileName, this._pressedTexType), this.loadTextureDisabled(this._disabledFileName, this._disabledTexType), this.addProtectedChild(this._buttonNormalRenderer, ccui.Button.NORMAL_RENDERER_ZORDER, -1), this.addProtectedChild(this._buttonClickedRenderer, ccui.Button.PRESSED_RENDERER_ZORDER, -1), this.addProtectedChild(this._buttonDisableRenderer,
                ccui.Button.DISABLED_RENDERER_ZORDER, -1), this._scale9Enabled ? (a = this._ignoreSize, this.ignoreContentAdaptWithSize(!1), this._prevIgnoreSize = a) : this.ignoreContentAdaptWithSize(this._prevIgnoreSize), this.setCapInsetsNormalRenderer(this._capInsetsNormal), this.setCapInsetsPressedRenderer(this._capInsetsPressed), this.setCapInsetsDisabledRenderer(this._capInsetsDisabled), this.setBright(this._bright))
    },
    isScale9Enabled: function() {
        return this._scale9Enabled
    },
    ignoreContentAdaptWithSize: function(a) {
        if (this._unifySize) this._scale9Enabled ?
            ccui.ProtectedNode.prototype.setContentSize.call(this, this._customSize) : (a = this.getVirtualRendererSize(), ccui.ProtectedNode.prototype.setContentSize.call(this, a)), this._onSizeChanged();
        else if (!this._scale9Enabled || this._scale9Enabled && !a) ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this, a), this._prevIgnoreSize = a
    },
    getVirtualRendererSize: function() {
        var a = this._titleRenderer.getContentSize();
        return !this._normalTextureLoaded && 0 < this._titleRenderer.getString().length ? a : cc.size(this._normalTextureSize)
    },
    loadTextures: function(a, b, c, d) {
        this.loadTextureNormal(a, d);
        this.loadTexturePressed(b, d);
        this.loadTextureDisabled(c, d)
    },
    loadTextureNormal: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._normalFileName = a;
            this._normalTexType = b;
            var c = this;
            (!this._buttonNormalRenderer.texture || !this._buttonNormalRenderer.texture.isLoaded()) && this._buttonNormalRenderer.addEventListener("load", function() {
                c._findLayout();
                c._normalTextureSize = c._buttonNormalRenderer.getContentSize();
                c._updateFlippedX();
                c._updateFlippedY();
                c._updateChildrenDisplayedRGBA();
                c._buttonNormalRenderer.setColor(c.getColor());
                c._buttonNormalRenderer.setOpacity(c.getOpacity());
                c._updateContentSizeWithTextureSize(c._normalTextureSize);
                c._normalTextureLoaded = !0;
                c._normalTextureAdaptDirty = !0
            });
            if (this._scale9Enabled) {
                var d = this._buttonNormalRenderer;
                switch (this._normalTexType) {
                    case ccui.Widget.LOCAL_TEXTURE:
                        d.initWithFile(a);
                        break;
                    case ccui.Widget.PLIST_TEXTURE:
                        d.initWithSpriteFrameName(a)
                }
                d.setCapInsets(this._capInsetsNormal)
            } else switch (d = this._buttonNormalRenderer,
                this._normalTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    d.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    d.initWithSpriteFrameName(a)
            }
            this._normalTextureSize = this._buttonNormalRenderer.getContentSize();
            this._updateFlippedX();
            this._updateFlippedY();
            this._updateChildrenDisplayedRGBA();
            this._updateContentSizeWithTextureSize(this._normalTextureSize);
            this._normalTextureAdaptDirty = this._normalTextureLoaded = !0
        }
    },
    loadTexturePressed: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._clickedFileName =
                a;
            this._pressedTexType = b;
            var c = this;
            (!this._buttonClickedRenderer.texture || !this._buttonClickedRenderer.texture.isLoaded()) && this._buttonClickedRenderer.addEventListener("load", function() {
                c._findLayout();
                c._pressedTextureSize = c._buttonClickedRenderer.getContentSize();
                c._updateFlippedX();
                c._updateFlippedY();
                c._updateChildrenDisplayedRGBA();
                c._pressedTextureLoaded = !0;
                c._pressedTextureAdaptDirty = !0
            });
            if (this._scale9Enabled) {
                var d = this._buttonClickedRenderer;
                switch (this._pressedTexType) {
                    case ccui.Widget.LOCAL_TEXTURE:
                        d.initWithFile(a);
                        break;
                    case ccui.Widget.PLIST_TEXTURE:
                        d.initWithSpriteFrameName(a)
                }
                d.setCapInsets(this._capInsetsPressed)
            } else switch (d = this._buttonClickedRenderer, this._pressedTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    d.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    d.initWithSpriteFrameName(a)
            }
            this._pressedTextureSize = this._buttonClickedRenderer.getContentSize();
            this._updateFlippedX();
            this._updateFlippedY();
            this._updateChildrenDisplayedRGBA();
            this._pressedTextureAdaptDirty = this._pressedTextureLoaded = !0
        }
    },
    loadTextureDisabled: function(a,
        b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._disabledFileName = a;
            this._disabledTexType = b;
            var c = this;
            (!this._buttonDisableRenderer.texture || !this._buttonDisableRenderer.texture.isLoaded()) && this._buttonDisableRenderer.addEventListener("load", function() {
                c._findLayout();
                c._disabledTextureSize = c._buttonDisableRenderer.getContentSize();
                c._updateFlippedX();
                c._updateFlippedY();
                c._updateChildrenDisplayedRGBA();
                c._disabledTextureLoaded = !0;
                c._disabledTextureAdaptDirty = !0
            });
            if (this._scale9Enabled) {
                var d = this._buttonDisableRenderer;
                switch (this._disabledTexType) {
                    case ccui.Widget.LOCAL_TEXTURE:
                        d.initWithFile(a);
                        break;
                    case ccui.Widget.PLIST_TEXTURE:
                        d.initWithSpriteFrameName(a)
                }
                d.setCapInsets(this._capInsetsDisabled)
            } else switch (d = this._buttonDisableRenderer, this._disabledTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    d.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    d.initWithSpriteFrameName(a)
            }
            this._disabledTextureSize = this._buttonDisableRenderer.getContentSize();
            this._updateFlippedX();
            this._updateFlippedY();
            this._updateChildrenDisplayedRGBA();
            this._disabledTextureAdaptDirty = this._disabledTextureLoaded = !0
        }
    },
    setCapInsets: function(a) {
        this.setCapInsetsNormalRenderer(a);
        this.setCapInsetsPressedRenderer(a);
        this.setCapInsetsDisabledRenderer(a)
    },
    setCapInsetsNormalRenderer: function(a) {
        if (a) {
            var b = a.x,
                c = a.y,
                d = a.width;
            a = a.height;
            this._normalTextureSize.width < d && (d = b = 0);
            this._normalTextureSize.height < a && (a = c = 0);
            var e = cc.rect(b, c, d, a),
                f = this._capInsetsNormal;
            f.x = b;
            f.y = c;
            f.width = d;
            f.height = a;
            this._scale9Enabled && this._buttonNormalRenderer.setCapInsets(e)
        }
    },
    getCapInsetsNormalRenderer: function() {
        return cc.rect(this._capInsetsNormal)
    },
    setCapInsetsPressedRenderer: function(a) {
        if (a) {
            var b = a.x,
                c = a.y,
                d = a.width;
            a = a.height;
            this._normalTextureSize.width < d && (d = b = 0);
            this._normalTextureSize.height < a && (a = c = 0);
            var e = cc.rect(b, c, d, a),
                f = this._capInsetsPressed;
            f.x = b;
            f.y = c;
            f.width = d;
            f.height = a;
            this._scale9Enabled && this._buttonClickedRenderer.setCapInsets(e)
        }
    },
    getCapInsetsPressedRenderer: function() {
        return cc.rect(this._capInsetsPressed)
    },
    setCapInsetsDisabledRenderer: function(a) {
        if (a) {
            var b =
                a.x,
                c = a.y,
                d = a.width;
            a = a.height;
            this._normalTextureSize.width < d && (d = b = 0);
            this._normalTextureSize.height < a && (a = c = 0);
            var e = cc.rect(b, c, d, a),
                f = this._capInsetsDisabled;
            f.x = b;
            f.y = c;
            f.width = d;
            f.height = a;
            this._scale9Enabled && this._buttonDisableRenderer.setCapInsets(e)
        }
    },
    getCapInsetsDisabledRenderer: function() {
        return cc.rect(this._capInsetsDisabled)
    },
    _onPressStateChangedToNormal: function() {
        this._buttonNormalRenderer.setVisible(!0);
        this._buttonClickedRenderer.setVisible(!1);
        this._buttonDisableRenderer.setVisible(!1);
        if (this._pressedTextureLoaded) {
            if (this.pressedActionEnabled) {
                this._buttonNormalRenderer.stopAllActions();
                this._buttonClickedRenderer.stopAllActions();
                var a = cc.scaleTo(0.05, this._normalTextureScaleXInSize, this._normalTextureScaleYInSize);
                this._buttonNormalRenderer.runAction(a);
                this._buttonClickedRenderer.setScale(this._pressedTextureScaleXInSize, this._pressedTextureScaleYInSize);
                this._titleRenderer.stopAllActions();
                this._titleRenderer.runAction(a.clone())
            }
        } else this._scale9Enabled ? this._buttonNormalRenderer.setColor(cc.color.WHITE) :
            (this._buttonNormalRenderer.stopAllActions(), this._buttonNormalRenderer.setScale(this._normalTextureScaleXInSize, this._normalTextureScaleYInSize), this._titleRenderer.stopAllActions(), this._titleRenderer.setScaleX(this._normalTextureScaleXInSize), this._titleRenderer.setScaleY(this._normalTextureScaleYInSize))
    },
    _onPressStateChangedToPressed: function() {
        var a = this._buttonNormalRenderer;
        if (this._pressedTextureLoaded) {
            if (a.setVisible(!1), this._buttonClickedRenderer.setVisible(!0), this._buttonDisableRenderer.setVisible(!1),
                this.pressedActionEnabled) {
                a.stopAllActions();
                this._buttonClickedRenderer.stopAllActions();
                var b = cc.scaleTo(0.05, this._pressedTextureScaleXInSize + 0.1, this._pressedTextureScaleYInSize + 0.1);
                this._buttonClickedRenderer.runAction(b);
                a.setScale(this._pressedTextureScaleXInSize + 0.1, this._pressedTextureScaleYInSize + 0.1);
                this._titleRenderer.stopAllActions();
                this._titleRenderer.runAction(b.clone())
            }
        } else a.setVisible(!0), this._buttonClickedRenderer.setVisible(!0), this._buttonDisableRenderer.setVisible(!1),
            this._scale9Enabled ? a.setColor(cc.color.GRAY) : (a.stopAllActions(), a.setScale(this._normalTextureScaleXInSize + 0.1, this._normalTextureScaleYInSize + 0.1), this._titleRenderer.stopAllActions(), this._titleRenderer.setScaleX(this._normalTextureScaleXInSize + this._zoomScale), this._titleRenderer.setScaleY(this._normalTextureScaleYInSize + this._zoomScale))
    },
    _onPressStateChangedToDisabled: function() {
        this._buttonNormalRenderer.setVisible(!1);
        this._buttonClickedRenderer.setVisible(!1);
        this._buttonDisableRenderer.setVisible(!0);
        this._buttonNormalRenderer.setScale(this._normalTextureScaleXInSize, this._normalTextureScaleYInSize);
        this._buttonClickedRenderer.setScale(this._pressedTextureScaleXInSize, this._pressedTextureScaleYInSize)
    },
    _updateFlippedX: function() {
        var a = this._flippedX ? -1 : 1;
        this._titleRenderer.setScaleX(a);
        this._scale9Enabled ? (this._buttonNormalRenderer.setScaleX(a), this._buttonClickedRenderer.setScaleX(a), this._buttonDisableRenderer.setScaleX(a)) : (this._buttonNormalRenderer.setFlippedX(this._flippedX), this._buttonClickedRenderer.setFlippedX(this._flippedX),
            this._buttonDisableRenderer.setFlippedX(this._flippedX))
    },
    _updateFlippedY: function() {
        var a = this._flippedY ? -1 : 1;
        this._titleRenderer.setScaleY(a);
        this._scale9Enabled ? (this._buttonNormalRenderer.setScaleY(a), this._buttonClickedRenderer.setScaleY(a), this._buttonDisableRenderer.setScaleY(a)) : (this._buttonNormalRenderer.setFlippedY(this._flippedY), this._buttonClickedRenderer.setFlippedY(this._flippedY), this._buttonDisableRenderer.setFlippedY(this._flippedY))
    },
    _updateTexturesRGBA: function() {
        this._buttonNormalRenderer.setColor(this.getColor());
        this._buttonClickedRenderer.setColor(this.getColor());
        this._buttonDisableRenderer.setColor(this.getColor());
        this._buttonNormalRenderer.setOpacity(this.getOpacity());
        this._buttonClickedRenderer.setOpacity(this.getOpacity());
        this._buttonDisableRenderer.setOpacity(this.getOpacity())
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this);
        this._updateTitleLocation();
        this._disabledTextureAdaptDirty = this._pressedTextureAdaptDirty = this._normalTextureAdaptDirty = !0
    },
    getVirtualRenderer: function() {
        if (this._bright) switch (this._brightStyle) {
            case ccui.Widget.BRIGHT_STYLE_NORMAL:
                return this._buttonNormalRenderer;
            case ccui.Widget.BRIGHT_STYLE_HIGH_LIGHT:
                return this._buttonClickedRenderer;
            default:
                return null
        } else return this._buttonDisableRenderer
    },
    _normalTextureScaleChangedWithSize: function() {
        if (this._unifySize) this._scale9Enabled && this._buttonNormalRenderer.setPreferredSize(this._contentSize);
        else if (this._ignoreSize) this._scale9Enabled || (this._buttonNormalRenderer.setScale(1), this._normalTextureScaleXInSize = this._normalTextureScaleYInSize = 1);
        else if (this._scale9Enabled) this._buttonNormalRenderer.setPreferredSize(this._contentSize),
            this._normalTextureScaleXInSize = this._normalTextureScaleYInSize = 1;
        else {
            var a = this._normalTextureSize;
            if (0 >= a.width || 0 >= a.height) {
                this._buttonNormalRenderer.setScale(1);
                return
            }
            var b = this._contentSize.width / a.width,
                a = this._contentSize.height / a.height;
            this._buttonNormalRenderer.setScaleX(b);
            this._buttonNormalRenderer.setScaleY(a);
            this._normalTextureScaleXInSize = b;
            this._normalTextureScaleYInSize = a
        }
        this._buttonNormalRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    },
    _pressedTextureScaleChangedWithSize: function() {
        if (this._ignoreSize) this._scale9Enabled ||
            (this._buttonClickedRenderer.setScale(1), this._pressedTextureScaleXInSize = this._pressedTextureScaleYInSize = 1);
        else if (this._scale9Enabled) this._buttonClickedRenderer.setPreferredSize(this._contentSize), this._pressedTextureScaleXInSize = this._pressedTextureScaleYInSize = 1;
        else {
            var a = this._pressedTextureSize;
            if (0 >= a.width || 0 >= a.height) {
                this._buttonClickedRenderer.setScale(1);
                return
            }
            var b = this._contentSize.width / a.width,
                a = this._contentSize.height / a.height;
            this._buttonClickedRenderer.setScaleX(b);
            this._buttonClickedRenderer.setScaleY(a);
            this._pressedTextureScaleXInSize = b;
            this._pressedTextureScaleYInSize = a
        }
        this._buttonClickedRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    },
    _disabledTextureScaleChangedWithSize: function() {
        if (this._unifySize) this._scale9Enabled && this._buttonNormalRenderer.setPreferredSize(this._contentSize);
        else if (this._ignoreSize) this._scale9Enabled || this._buttonDisableRenderer.setScale(1);
        else if (this._scale9Enabled) this._buttonDisableRenderer.setPreferredSize(this._contentSize);
        else {
            var a =
                this._disabledTextureSize;
            if (0 >= a.width || 0 >= a.height) {
                this._buttonDisableRenderer.setScale(1);
                return
            }
            var b = this._contentSize.height / a.height;
            this._buttonDisableRenderer.setScaleX(this._contentSize.width / a.width);
            this._buttonDisableRenderer.setScaleY(b)
        }
        this._buttonDisableRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    },
    _adaptRenderers: function() {
        this._normalTextureAdaptDirty && (this._normalTextureScaleChangedWithSize(), this._normalTextureAdaptDirty = !1);
        this._pressedTextureAdaptDirty &&
            (this._pressedTextureScaleChangedWithSize(), this._pressedTextureAdaptDirty = !1);
        this._disabledTextureAdaptDirty && (this._disabledTextureScaleChangedWithSize(), this._disabledTextureAdaptDirty = !1)
    },
    _updateTitleLocation: function() {
        this._titleRenderer.setPosition(0.5 * this._contentSize.width, 0.5 * this._contentSize.height)
    },
    setPressedActionEnabled: function(a) {
        this.pressedActionEnabled = a
    },
    setTitleText: function(a) {
        this._titleRenderer.setString(a);
        this._ignoreSize && (a = this.getVirtualRendererSize(), this.setContentSize(a))
    },
    getTitleText: function() {
        return this._titleRenderer.getString()
    },
    setTitleColor: function(a) {
        this._titleColor.r = a.r;
        this._titleColor.g = a.g;
        this._titleColor.b = a.b;
        this._titleRenderer.updateDisplayedColor(a)
    },
    getTitleColor: function() {
        return this._titleRenderer.getColor()
    },
    setTitleFontSize: function(a) {
        this._titleRenderer.setFontSize(a)
    },
    getTitleFontSize: function() {
        return this._titleRenderer.getFontSize()
    },
    setZoomScale: function(a) {
        this._zoomScale = a
    },
    getZoomScale: function() {
        return this._zoomScale
    },
    setTitleFontName: function(a) {
        this._titleRenderer.setFontName(a);
        this._fontName = a
    },
    getTitleRenderer: function() {
        return this._titleRenderer
    },
    getTitleFontName: function() {
        return this._titleRenderer.getFontName()
    },
    _setTitleFont: function(a) {
        this._titleRenderer.font = a
    },
    _getTitleFont: function() {
        return this._titleRenderer.font
    },
    getDescription: function() {
        return "Button"
    },
    _createCloneInstance: function() {
        return new ccui.Button
    },
    _copySpecialProperties: function(a) {
        this._prevIgnoreSize = a._prevIgnoreSize;
        this.setScale9Enabled(a._scale9Enabled);
        this.loadTextureNormal(a._normalFileName,
            a._normalTexType);
        this.loadTexturePressed(a._clickedFileName, a._pressedTexType);
        this.loadTextureDisabled(a._disabledFileName, a._disabledTexType);
        this.setCapInsetsNormalRenderer(a._capInsetsNormal);
        this.setCapInsetsPressedRenderer(a._capInsetsPressed);
        this.setCapInsetsDisabledRenderer(a._capInsetsDisabled);
        this.setTitleText(a.getTitleText());
        this.setTitleFontName(a.getTitleFontName());
        this.setTitleFontSize(a.getTitleFontSize());
        this.setTitleColor(a.getTitleColor());
        this.setPressedActionEnabled(a.pressedActionEnabled);
        this.setZoomScale(a._zoomScale)
    }
});
_p = ccui.Button.prototype;
cc.defineGetterSetter(_p, "titleText", _p.getTitleText, _p.setTitleText);
cc.defineGetterSetter(_p, "titleFont", _p._getTitleFont, _p._setTitleFont);
cc.defineGetterSetter(_p, "titleFontSize", _p.getTitleFontSize, _p.setTitleFontSize);
cc.defineGetterSetter(_p, "titleFontName", _p.getTitleFontName, _p.setTitleFontName);
cc.defineGetterSetter(_p, "titleColor", _p.getTitleColor, _p.setTitleColor);
_p = null;
ccui.Button.create = function(a, b, c, d) {
    return new ccui.Button(a, b, c, d)
};
ccui.Button.NORMAL_RENDERER_ZORDER = -2;
ccui.Button.PRESSED_RENDERER_ZORDER = -2;
ccui.Button.DISABLED_RENDERER_ZORDER = -2;
ccui.Button.TITLE_RENDERER_ZORDER = -1;
ccui.Button.SYSTEM = 0;
ccui.Button.TTF = 1;
ccui.CheckBox = ccui.Widget.extend({
    _backGroundBoxRenderer: null,
    _backGroundSelectedBoxRenderer: null,
    _frontCrossRenderer: null,
    _backGroundBoxDisabledRenderer: null,
    _frontCrossDisabledRenderer: null,
    _isSelected: !0,
    _checkBoxEventListener: null,
    _checkBoxEventSelector: null,
    _backGroundTexType: ccui.Widget.LOCAL_TEXTURE,
    _backGroundSelectedTexType: ccui.Widget.LOCAL_TEXTURE,
    _frontCrossTexType: ccui.Widget.LOCAL_TEXTURE,
    _backGroundDisabledTexType: ccui.Widget.LOCAL_TEXTURE,
    _frontCrossDisabledTexType: ccui.Widget.LOCAL_TEXTURE,
    _backGroundFileName: "",
    _backGroundSelectedFileName: "",
    _frontCrossFileName: "",
    _backGroundDisabledFileName: "",
    _frontCrossDisabledFileName: "",
    _className: "CheckBox",
    _backGroundBoxRendererAdaptDirty: !0,
    _backGroundSelectedBoxRendererAdaptDirty: !0,
    _frontCrossRendererAdaptDirty: !0,
    _backGroundBoxDisabledRendererAdaptDirty: !0,
    _frontCrossDisabledRendererAdaptDirty: !0,
    ctor: function(a, b, c, d, e, f) {
        ccui.Widget.prototype.ctor.call(this);
        this.setTouchEnabled(!0);
        void 0 !== f && this.init(a, b, c, d, e, f)
    },
    init: function(a,
        b, c, d, e, f) {
        return ccui.Widget.prototype.init.call(this) ? (this._isSelected = !0, this.setSelected(!1), void 0 === a && this.loadTextures(a, b, c, d, e, f), !0) : !1
    },
    _initRenderer: function() {
        this._backGroundBoxRenderer = new cc.Sprite;
        this._backGroundSelectedBoxRenderer = new cc.Sprite;
        this._frontCrossRenderer = new cc.Sprite;
        this._backGroundBoxDisabledRenderer = new cc.Sprite;
        this._frontCrossDisabledRenderer = new cc.Sprite;
        this.addProtectedChild(this._backGroundBoxRenderer, ccui.CheckBox.BOX_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._backGroundSelectedBoxRenderer,
            ccui.CheckBox.BOX_SELECTED_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._frontCrossRenderer, ccui.CheckBox.FRONT_CROSS_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._backGroundBoxDisabledRenderer, ccui.CheckBox.BOX_DISABLED_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._frontCrossDisabledRenderer, ccui.CheckBox.FRONT_CROSS_DISABLED_RENDERER_ZORDER, -1)
    },
    loadTextures: function(a, b, c, d, e, f) {
        this.loadTextureBackGround(a, f);
        this.loadTextureBackGroundSelected(b, f);
        this.loadTextureFrontCross(c, f);
        this.loadTextureBackGroundDisabled(d,
            f);
        this.loadTextureFrontCrossDisabled(e, f)
    },
    loadTextureBackGround: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._backGroundFileName = a;
            this._backGroundTexType = b;
            var c = this._backGroundBoxRenderer,
                d = this;
            (!c.texture || !c.texture.isLoaded()) && c.addEventListener("load", function() {
                d._findLayout();
                d._updateFlippedX();
                d._updateFlippedY();
                d._updateChildrenDisplayedRGBA();
                d._updateContentSizeWithTextureSize(d._backGroundBoxRenderer.getContentSize());
                d._backGroundBoxRendererAdaptDirty = !0
            });
            switch (this._backGroundTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    c.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    c.initWithSpriteFrameName(a)
            }
            c.textureLoaded() || (this._backGroundBoxRenderer.setContentSize(this._customSize), c.addEventListener("load", function() {
                this._updateContentSizeWithTextureSize(this._backGroundBoxRenderer.getContentSize())
            }, this));
            this._updateFlippedX();
            this._updateFlippedY();
            this._updateChildrenDisplayedRGBA();
            this._updateContentSizeWithTextureSize(this._backGroundBoxRenderer.getContentSize());
            this._backGroundBoxRendererAdaptDirty = !0
        }
    },
    loadTextureBackGroundSelected: function(a,
        b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._backGroundSelectedFileName = a;
            this._backGroundSelectedTexType = b;
            var c = this;
            (!this._backGroundSelectedBoxRenderer.texture || !this._backGroundSelectedBoxRenderer.texture.isLoaded()) && this._backGroundSelectedBoxRenderer.addEventListener("load", function() {
                c._findLayout();
                c._updateFlippedX();
                c._updateFlippedY();
                c._updateChildrenDisplayedRGBA();
                c._backGroundSelectedBoxRendererAdaptDirty = !0
            });
            switch (this._backGroundSelectedTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._backGroundSelectedBoxRenderer.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._backGroundSelectedBoxRenderer.initWithSpriteFrameName(a)
            }
            this._updateFlippedX();
            this._updateFlippedY();
            this._updateChildrenDisplayedRGBA();
            this._backGroundSelectedBoxRendererAdaptDirty = !0
        }
    },
    loadTextureFrontCross: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._frontCrossFileName = a;
            this._frontCrossTexType = b;
            var c = this;
            (!this._frontCrossRenderer.texture || !this._frontCrossRenderer.texture.isLoaded()) && this._frontCrossRenderer.addEventListener("load",
                function() {
                    c._findLayout();
                    c._updateFlippedX();
                    c._updateFlippedY();
                    c._updateChildrenDisplayedRGBA();
                    c._frontCrossRendererAdaptDirty = !0
                });
            switch (this._frontCrossTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._frontCrossRenderer.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._frontCrossRenderer.initWithSpriteFrameName(a)
            }
            this._updateFlippedX();
            this._updateFlippedY();
            this._updateChildrenDisplayedRGBA();
            this._frontCrossRendererAdaptDirty = !0
        }
    },
    loadTextureBackGroundDisabled: function(a, b) {
        if (a) {
            b =
                b || ccui.Widget.LOCAL_TEXTURE;
            this._backGroundDisabledFileName = a;
            this._backGroundDisabledTexType = b;
            var c = this;
            (!this._backGroundBoxDisabledRenderer.texture || !this._backGroundBoxDisabledRenderer.texture.isLoaded()) && this._backGroundBoxDisabledRenderer.addEventListener("load", function() {
                c._findLayout();
                c._updateFlippedX();
                c._updateFlippedY();
                c._updateChildrenDisplayedRGBA();
                c._backGroundBoxDisabledRendererAdaptDirty = !0
            });
            switch (this._backGroundDisabledTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._backGroundBoxDisabledRenderer.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._backGroundBoxDisabledRenderer.initWithSpriteFrameName(a)
            }
            this._updateFlippedX();
            this._updateFlippedY();
            this._updateChildrenDisplayedRGBA();
            this._backGroundBoxDisabledRendererAdaptDirty = !0
        }
    },
    loadTextureFrontCrossDisabled: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._frontCrossDisabledFileName = a;
            this._frontCrossDisabledTexType = b;
            var c = this;
            (!this._frontCrossDisabledRenderer.texture || !this._frontCrossDisabledRenderer.texture.isLoaded()) && this._frontCrossDisabledRenderer.addEventListener("load",
                function() {
                    c._findLayout();
                    c._updateFlippedX();
                    c._updateFlippedY();
                    c._updateChildrenDisplayedRGBA();
                    c._frontCrossDisabledRendererAdaptDirty = !0
                });
            switch (this._frontCrossDisabledTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._frontCrossDisabledRenderer.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._frontCrossDisabledRenderer.initWithSpriteFrameName(a)
            }
            this._updateFlippedX();
            this._updateFlippedY();
            this._updateChildrenDisplayedRGBA();
            this._frontCrossDisabledRendererAdaptDirty = !0
        }
    },
    _onPressStateChangedToNormal: function() {
        this._backGroundBoxRenderer.setVisible(!0);
        this._backGroundSelectedBoxRenderer.setVisible(!1);
        this._backGroundBoxDisabledRenderer.setVisible(!1);
        this._frontCrossDisabledRenderer.setVisible(!1);
        this._isSelected && this._frontCrossRenderer.setVisible(!0)
    },
    _onPressStateChangedToPressed: function() {
        this._backGroundBoxRenderer.setVisible(!1);
        this._backGroundSelectedBoxRenderer.setVisible(!0);
        this._backGroundBoxDisabledRenderer.setVisible(!1);
        this._frontCrossDisabledRenderer.setVisible(!1)
    },
    _onPressStateChangedToDisabled: function() {
        this._backGroundBoxRenderer.setVisible(!1);
        this._backGroundSelectedBoxRenderer.setVisible(!1);
        this._backGroundBoxDisabledRenderer.setVisible(!0);
        this._frontCrossRenderer.setVisible(!1);
        this._isSelected && this._frontCrossDisabledRenderer.setVisible(!0)
    },
    setSelectedState: function(a) {
        this.setSelected(a)
    },
    setSelected: function(a) {
        a != this._isSelected && (this._isSelected = a, this._frontCrossRenderer.setVisible(this._isSelected))
    },
    getSelectedState: function() {
        this.isSelected()
    },
    isSelected: function() {
        return this._isSelected
    },
    _selectedEvent: function() {
        this._checkBoxEventSelector &&
            (this._checkBoxEventListener ? this._checkBoxEventSelector.call(this._checkBoxEventListener, this, ccui.CheckBox.EVENT_SELECTED) : this._checkBoxEventSelector(this, ccui.CheckBox.EVENT_SELECTED))
    },
    _unSelectedEvent: function() {
        this._checkBoxEventSelector && (this._checkBoxEventListener ? this._checkBoxEventSelector.call(this._checkBoxEventListener, this, ccui.CheckBox.EVENT_UNSELECTED) : this._checkBoxEventSelector(this, ccui.CheckBox.EVENT_UNSELECTED))
    },
    _releaseUpEvent: function() {
        ccui.Widget.prototype._releaseUpEvent.call(this);
        this._isSelected ? (this.setSelected(!1), this._unSelectedEvent()) : (this.setSelected(!0), this._selectedEvent())
    },
    addEventListenerCheckBox: function(a, b) {
        this.addEventListener(a, b)
    },
    addEventListener: function(a, b) {
        this._checkBoxEventSelector = a;
        this._checkBoxEventListener = b
    },
    getVirtualRendererSize: function() {
        return this._backGroundBoxRenderer.getContentSize()
    },
    _updateFlippedX: function() {
        this._backGroundBoxRenderer.setFlippedX(this._flippedX);
        this._backGroundSelectedBoxRenderer.setFlippedX(this._flippedX);
        this._frontCrossRenderer.setFlippedX(this._flippedX);
        this._backGroundBoxDisabledRenderer.setFlippedX(this._flippedX);
        this._frontCrossDisabledRenderer.setFlippedX(this._flippedX)
    },
    _updateFlippedY: function() {
        this._backGroundBoxRenderer.setFlippedY(this._flippedY);
        this._backGroundSelectedBoxRenderer.setFlippedY(this._flippedY);
        this._frontCrossRenderer.setFlippedY(this._flippedY);
        this._backGroundBoxDisabledRenderer.setFlippedY(this._flippedY);
        this._frontCrossDisabledRenderer.setFlippedY(this._flippedY)
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this);
        this._frontCrossDisabledRendererAdaptDirty = this._backGroundBoxDisabledRendererAdaptDirty = this._frontCrossRendererAdaptDirty = this._backGroundSelectedBoxRendererAdaptDirty = this._backGroundBoxRendererAdaptDirty = !0
    },
    getVirtualRenderer: function() {
        return this._backGroundBoxRenderer
    },
    _backGroundTextureScaleChangedWithSize: function() {
        var a = this._backGroundBoxRenderer,
            b = this._contentSize;
        if (this._ignoreSize) a.setScale(1);
        else {
            var c =
                a.getContentSize();
            if (0 >= c.width || 0 >= c.height) {
                a.setScale(1);
                return
            }
            var d = b.height / c.height;
            a.setScaleX(b.width / c.width);
            a.setScaleY(d)
        }
        a.setPosition(0.5 * b.width, 0.5 * b.height)
    },
    _backGroundSelectedTextureScaleChangedWithSize: function() {
        var a = this._backGroundSelectedBoxRenderer,
            b = this._contentSize;
        if (this._ignoreSize) a.setScale(1);
        else {
            var c = a.getContentSize();
            if (0 >= c.width || 0 >= c.height) {
                a.setScale(1);
                return
            }
            var d = b.height / c.height;
            a.setScaleX(b.width / c.width);
            a.setScaleY(d)
        }
        a.setPosition(0.5 * b.width,
            0.5 * b.height)
    },
    _frontCrossTextureScaleChangedWithSize: function() {
        var a = this._frontCrossRenderer,
            b = this._contentSize;
        if (this._ignoreSize) a.setScale(1);
        else {
            var c = a.getContentSize();
            if (0 >= c.width || 0 >= c.height) {
                a.setScale(1);
                return
            }
            var d = b.height / c.height;
            a.setScaleX(b.width / c.width);
            a.setScaleY(d)
        }
        a.setPosition(0.5 * b.width, 0.5 * b.height)
    },
    _backGroundDisabledTextureScaleChangedWithSize: function() {
        var a = this._backGroundBoxDisabledRenderer,
            b = this._contentSize;
        if (this._ignoreSize) a.setScale(1);
        else {
            var c =
                a.getContentSize();
            if (0 >= c.width || 0 >= c.height) {
                a.setScale(1);
                return
            }
            var d = b.height / c.height;
            a.setScaleX(b.width / c.width);
            a.setScaleY(d)
        }
        a.setPosition(0.5 * b.width, 0.5 * b.height)
    },
    _frontCrossDisabledTextureScaleChangedWithSize: function() {
        var a = this._frontCrossDisabledRenderer,
            b = this._contentSize;
        if (this._ignoreSize) a.setScale(1);
        else {
            var c = a.getContentSize();
            if (0 >= c.width || 0 >= c.height) {
                a.setScale(1);
                return
            }
            var d = b.height / c.height;
            a.setScaleX(b.width / c.width);
            a.setScaleY(d)
        }
        a.setPosition(0.5 * b.width,
            0.5 * b.height)
    },
    getDescription: function() {
        return "CheckBox"
    },
    _createCloneInstance: function() {
        return new ccui.CheckBox
    },
    _copySpecialProperties: function(a) {
        a instanceof ccui.CheckBox && (this.loadTextureBackGround(a._backGroundFileName, a._backGroundTexType), this.loadTextureBackGroundSelected(a._backGroundSelectedFileName, a._backGroundSelectedTexType), this.loadTextureFrontCross(a._frontCrossFileName, a._frontCrossTexType), this.loadTextureBackGroundDisabled(a._backGroundDisabledFileName, a._backGroundDisabledTexType),
            this.loadTextureFrontCrossDisabled(a._frontCrossDisabledFileName, a._frontCrossDisabledTexType), this.setSelected(a._isSelected), this._checkBoxEventListener = a._checkBoxEventListener, this._checkBoxEventSelector = a._checkBoxEventSelector)
    },
    _adaptRenderers: function() {
        this._backGroundBoxRendererAdaptDirty && (this._backGroundTextureScaleChangedWithSize(), this._backGroundBoxRendererAdaptDirty = !1);
        this._backGroundSelectedBoxRendererAdaptDirty && (this._backGroundSelectedTextureScaleChangedWithSize(), this._backGroundSelectedBoxRendererAdaptDirty = !1);
        this._frontCrossRendererAdaptDirty && (this._frontCrossTextureScaleChangedWithSize(), this._frontCrossRendererAdaptDirty = !1);
        this._backGroundBoxDisabledRendererAdaptDirty && (this._backGroundDisabledTextureScaleChangedWithSize(), this._backGroundBoxDisabledRendererAdaptDirty = !1);
        this._frontCrossDisabledRendererAdaptDirty && (this._frontCrossDisabledTextureScaleChangedWithSize(), this._frontCrossDisabledRendererAdaptDirty = !1)
    }
});
_p = ccui.CheckBox.prototype;
cc.defineGetterSetter(_p, "selected", _p.isSelected, _p.setSelected);
_p = null;
ccui.CheckBox.create = function(a, b, c, d, e, f) {
    return new ccui.CheckBox(a, b, c, d, e, f)
};
ccui.CheckBox.EVENT_SELECTED = 0;
ccui.CheckBox.EVENT_UNSELECTED = 1;
ccui.CheckBox.BOX_RENDERER_ZORDER = -1;
ccui.CheckBox.BOX_SELECTED_RENDERER_ZORDER = -1;
ccui.CheckBox.BOX_DISABLED_RENDERER_ZORDER = -1;
ccui.CheckBox.FRONT_CROSS_RENDERER_ZORDER = -1;
ccui.CheckBox.FRONT_CROSS_DISABLED_RENDERER_ZORDER = -1;
ccui.ImageView = ccui.Widget.extend({
    _scale9Enabled: !1,
    _prevIgnoreSize: !0,
    _capInsets: null,
    _imageRenderer: null,
    _textureFile: "",
    _imageTexType: ccui.Widget.LOCAL_TEXTURE,
    _imageTextureSize: null,
    _className: "ImageView",
    _imageRendererAdaptDirty: !0,
    ctor: function(a, b) {
        this._capInsets = cc.rect(0, 0, 0, 0);
        this._imageTextureSize = cc.size(this._capInsets.width, this._capInsets.height);
        ccui.Widget.prototype.ctor.call(this);
        void 0 !== b && this.init(a, b)
    },
    init: function(a, b) {
        return ccui.Widget.prototype.init.call(this) ? (void 0 ===
            a ? this._imageTexType = ccui.Widget.LOCAL_TEXTURE : this.loadTexture(a, b), !0) : !1
    },
    _initRenderer: function() {
        this._imageRenderer = new cc.Sprite;
        this.addProtectedChild(this._imageRenderer, ccui.ImageView.RENDERER_ZORDER, -1)
    },
    loadTexture: function(a, b) {
        if (a) {
            var c = this;
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._textureFile = a;
            this._imageTexType = b;
            var d = c._imageRenderer;
            switch (c._imageTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    c._scale9Enabled ? (d.initWithFile(a), d.setCapInsets(c._capInsets)) : d.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    c._scale9Enabled ?
                        (d.initWithSpriteFrameName(a), d.setCapInsets(c._capInsets)) : d.initWithSpriteFrameName(a)
            }(!d.texture || !d.texture.isLoaded()) && d.addEventListener("load", function() {
                c._findLayout();
                c._imageTextureSize = d.getContentSize();
                c._updateFlippedX();
                c._updateFlippedY();
                c._updateChildrenDisplayedRGBA();
                c._updateContentSizeWithTextureSize(c._imageTextureSize);
                c._imageRendererAdaptDirty = !0
            });
            c._imageTextureSize = d.getContentSize();
            c._updateFlippedX();
            c._updateFlippedY();
            this._updateChildrenDisplayedRGBA();
            c._updateContentSizeWithTextureSize(c._imageTextureSize);
            c._imageRendererAdaptDirty = !0
        }
    },
    setTextureRect: function(a) {
        this._scale9Enabled || this._imageRenderer.setTextureRect(a)
    },
    _updateFlippedX: function() {
        this._scale9Enabled ? this._imageRenderer.setScaleX(this._flippedX ? -1 : 1) : this._imageRenderer.setFlippedX(this._flippedX)
    },
    _updateFlippedY: function() {
        this._scale9Enabled ? this._imageRenderer.setScaleY(this._flippedY ? -1 : 1) : this._imageRenderer.setFlippedY(this._flippedY)
    },
    setScale9Enabled: function(a) {
        this._scale9Enabled != a && (this._scale9Enabled = a, this.removeProtectedChild(this._imageRenderer),
            this._imageRenderer = null, this._imageRenderer = this._scale9Enabled ? new ccui.Scale9Sprite : new cc.Sprite, this.loadTexture(this._textureFile, this._imageTexType), this.addProtectedChild(this._imageRenderer, ccui.ImageView.RENDERER_ZORDER, -1), this._scale9Enabled ? (a = this._ignoreSize, this.ignoreContentAdaptWithSize(!1), this._prevIgnoreSize = a) : this.ignoreContentAdaptWithSize(this._prevIgnoreSize), this.setCapInsets(this._capInsets))
    },
    isScale9Enabled: function() {
        return this._scale9Enabled
    },
    ignoreContentAdaptWithSize: function(a) {
        if (!this._scale9Enabled ||
            this._scale9Enabled && !a) ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this, a), this._prevIgnoreSize = a
    },
    setCapInsets: function(a) {
        if (a) {
            var b = this._capInsets;
            b.x = a.x;
            b.y = a.y;
            b.width = a.width;
            b.height = a.height;
            this._scale9Enabled && this._imageRenderer.setCapInsets(a)
        }
    },
    getCapInsets: function() {
        return cc.rect(this._capInsets)
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this);
        this._imageRendererAdaptDirty = !0
    },
    _adaptRenderers: function() {
        this._imageRendererAdaptDirty && (this._imageTextureScaleChangedWithSize(),
            this._imageRendererAdaptDirty = !1)
    },
    getVirtualRendererSize: function() {
        return cc.size(this._imageTextureSize)
    },
    getVirtualRenderer: function() {
        return this._imageRenderer
    },
    _imageTextureScaleChangedWithSize: function() {
        if (this._ignoreSize) this._scale9Enabled || this._imageRenderer.setScale(1);
        else if (this._scale9Enabled) this._imageRenderer.setPreferredSize(this._contentSize);
        else {
            var a = this._imageRenderer.getContentSize();
            if (0 >= a.width || 0 >= a.height) {
                this._imageRenderer.setScale(1);
                return
            }
            this._imageRenderer.setScaleX(this._contentSize.width /
                a.width);
            this._imageRenderer.setScaleY(this._contentSize.height / a.height)
        }
        this._imageRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    },
    getDescription: function() {
        return "ImageView"
    },
    _createCloneInstance: function() {
        return new ccui.ImageView
    },
    _copySpecialProperties: function(a) {
        a instanceof ccui.ImageView && (this._prevIgnoreSize = a._prevIgnoreSize, this.setScale9Enabled(a._scale9Enabled), this.loadTexture(a._textureFile, a._imageTexType), this.setCapInsets(a._capInsets))
    }
});
ccui.ImageView.create = function(a, b) {
    return new ccui.ImageView(a, b)
};
ccui.ImageView.RENDERER_ZORDER = -1;
ccui.LoadingBar = ccui.Widget.extend({
    _direction: null,
    _percent: 100,
    _totalLength: 0,
    _barRenderer: null,
    _renderBarTexType: ccui.Widget.LOCAL_TEXTURE,
    _barRendererTextureSize: null,
    _scale9Enabled: !1,
    _prevIgnoreSize: !0,
    _capInsets: null,
    _textureFile: "",
    _isTextureLoaded: !1,
    _className: "LoadingBar",
    _barRendererAdaptDirty: !0,
    ctor: function(a, b) {
        this._direction = ccui.LoadingBar.TYPE_LEFT;
        this._barRendererTextureSize = cc.size(0, 0);
        this._capInsets = cc.rect(0, 0, 0, 0);
        ccui.Widget.prototype.ctor.call(this);
        void 0 !== a && this.loadTexture(a);
        void 0 !== b && this.setPercent(b)
    },
    _initRenderer: function() {
        this._barRenderer = new cc.Sprite;
        this.addProtectedChild(this._barRenderer, ccui.LoadingBar.RENDERER_ZORDER, -1);
        this._barRenderer.setAnchorPoint(0, 0.5)
    },
    setDirection: function(a) {
        if (this._direction != a) switch (this._direction = a, this._direction) {
            case ccui.LoadingBar.TYPE_LEFT:
                this._barRenderer.setAnchorPoint(0, 0.5);
                this._barRenderer.setPosition(0, 0.5 * this._contentSize.height);
                this._scale9Enabled || this._barRenderer.setFlippedX(!1);
                break;
            case ccui.LoadingBar.TYPE_RIGHT:
                this._barRenderer.setAnchorPoint(1,
                    0.5), this._barRenderer.setPosition(this._totalLength, 0.5 * this._contentSize.height), this._scale9Enabled || this._barRenderer.setFlippedX(!0)
        }
    },
    getDirection: function() {
        return this._direction
    },
    loadTexture: function(a, b) {
        if (a) {
            this._renderBarTexType = b = b || ccui.Widget.LOCAL_TEXTURE;
            this._textureFile = a;
            var c = this._barRenderer,
                d = this;
            (!c.texture || !c.texture.isLoaded()) && c.addEventListener("load", function() {
                d._findLayout();
                var a = c.getContentSize();
                d._barRendererTextureSize.width = a.width;
                d._barRendererTextureSize.height =
                    a.height;
                switch (d._direction) {
                    case ccui.LoadingBar.TYPE_LEFT:
                        c.setAnchorPoint(0, 0.5);
                        d._scale9Enabled || c.setFlippedX(!1);
                        break;
                    case ccui.LoadingBar.TYPE_RIGHT:
                        c.setAnchorPoint(1, 0.5), d._scale9Enabled || c.setFlippedX(!0)
                }
                d._updateChildrenDisplayedRGBA();
                d._barRendererScaleChangedWithSize();
                d._updateContentSizeWithTextureSize(d._barRendererTextureSize);
                d._barRendererAdaptDirty = !0
            });
            switch (this._renderBarTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._scale9Enabled ? (c.initWithFile(a), c.setCapInsets(this._capInsets)) :
                        c.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._scale9Enabled ? (c.initWithSpriteFrameName(a), c.setCapInsets(this._capInsets)) : c.initWithSpriteFrameName(a)
            }
            var e = c.getContentSize();
            this._barRendererTextureSize.width = e.width;
            this._barRendererTextureSize.height = e.height;
            switch (this._direction) {
                case ccui.LoadingBar.TYPE_LEFT:
                    c.setAnchorPoint(0, 0.5);
                    this._scale9Enabled || c.setFlippedX(!1);
                    break;
                case ccui.LoadingBar.TYPE_RIGHT:
                    c.setAnchorPoint(1, 0.5), this._scale9Enabled || c.setFlippedX(!0)
            }
            this._updateChildrenDisplayedRGBA();
            this._barRendererScaleChangedWithSize();
            this._updateContentSizeWithTextureSize(this._barRendererTextureSize);
            this._barRendererAdaptDirty = !0
        }
    },
    setScale9Enabled: function(a) {
        this._scale9Enabled != a && (this._scale9Enabled = a, this.removeProtectedChild(this._barRenderer), this._barRenderer = this._scale9Enabled ? new ccui.Scale9Sprite : new cc.Sprite, this.loadTexture(this._textureFile, this._renderBarTexType), this.addProtectedChild(this._barRenderer, ccui.LoadingBar.RENDERER_ZORDER, -1), this._scale9Enabled ? (a = this._ignoreSize,
            this.ignoreContentAdaptWithSize(!1), this._prevIgnoreSize = a) : this.ignoreContentAdaptWithSize(this._prevIgnoreSize), this.setCapInsets(this._capInsets), this.setPercent(this._percent))
    },
    isScale9Enabled: function() {
        return this._scale9Enabled
    },
    setCapInsets: function(a) {
        if (a) {
            var b = this._capInsets;
            b.x = a.x;
            b.y = a.y;
            b.width = a.width;
            b.height = a.height;
            this._scale9Enabled && this._barRenderer.setCapInsets(a)
        }
    },
    getCapInsets: function() {
        return cc.rect(this._capInsets)
    },
    setPercent: function(a) {
        if (!(0 > a || 100 < a))
            if (this._percent =
                a, !(0 >= this._totalLength))
                if (a = this._percent / 100, this._scale9Enabled) this._setScale9Scale();
                else {
                    var b = this._barRenderer.getTextureRect();
                    b.width = this._barRendererTextureSize.width * a;
                    this._barRenderer.setTextureRect(cc.rect(b.x, b.y, this._barRendererTextureSize.width * a, this._barRendererTextureSize.height))
                }
    },
    setContentSize: function(a, b) {
        ccui.Widget.prototype.setContentSize.call(this, a, b);
        this._totalLength = void 0 === b ? a.width : a
    },
    getPercent: function() {
        return this._percent
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this);
        this._barRendererAdaptDirty = !0
    },
    _adaptRenderers: function() {
        this._barRendererAdaptDirty && (this._barRendererScaleChangedWithSize(), this._barRendererAdaptDirty = !1)
    },
    ignoreContentAdaptWithSize: function(a) {
        if (!this._scale9Enabled || this._scale9Enabled && !a) ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this, a), this._prevIgnoreSize = a
    },
    getVirtualRendererSize: function() {
        return cc.size(this._barRendererTextureSize)
    },
    getVirtualRenderer: function() {
        return this._barRenderer
    },
    _barRendererScaleChangedWithSize: function() {
        var a =
            this._barRenderer,
            b = this._contentSize;
        if (this._unifySize) this._totalLength = this._contentSize.width, this.setPercent(this._percent);
        else if (this._ignoreSize) this._scale9Enabled || (this._totalLength = this._barRendererTextureSize.width, a.setScale(1));
        else if (this._totalLength = b.width, this._scale9Enabled) this._setScale9Scale();
        else {
            var c = this._barRendererTextureSize;
            if (0 >= c.width || 0 >= c.height) {
                a.setScale(1);
                return
            }
            var d = b.height / c.height;
            a.setScaleX(b.width / c.width);
            a.setScaleY(d)
        }
        switch (this._direction) {
            case ccui.LoadingBar.TYPE_LEFT:
                a.setPosition(0,
                    0.5 * b.height);
                break;
            case ccui.LoadingBar.TYPE_RIGHT:
                a.setPosition(this._totalLength, 0.5 * b.height)
        }
    },
    _setScale9Scale: function() {
        this._barRenderer.setPreferredSize(cc.size(this._percent / 100 * this._totalLength, this._contentSize.height))
    },
    getDescription: function() {
        return "LoadingBar"
    },
    _createCloneInstance: function() {
        return new ccui.LoadingBar
    },
    _copySpecialProperties: function(a) {
        a instanceof ccui.LoadingBar && (this._prevIgnoreSize = a._prevIgnoreSize, this.setScale9Enabled(a._scale9Enabled), this.loadTexture(a._textureFile,
            a._renderBarTexType), this.setCapInsets(a._capInsets), this.setPercent(a._percent), this.setDirection(a._direction))
    }
});
_p = ccui.LoadingBar.prototype;
cc.defineGetterSetter(_p, "direction", _p.getDirection, _p.setDirection);
cc.defineGetterSetter(_p, "percent", _p.getPercent, _p.setPercent);
_p = null;
ccui.LoadingBar.create = function(a, b) {
    return new ccui.LoadingBar(a, b)
};
ccui.LoadingBar.TYPE_LEFT = 0;
ccui.LoadingBar.TYPE_RIGHT = 1;
ccui.LoadingBar.RENDERER_ZORDER = -1;
ccui.Slider = ccui.Widget.extend({
    _barRenderer: null,
    _progressBarRenderer: null,
    _progressBarTextureSize: null,
    _slidBallNormalRenderer: null,
    _slidBallPressedRenderer: null,
    _slidBallDisabledRenderer: null,
    _slidBallRenderer: null,
    _barLength: 0,
    _percent: 0,
    _scale9Enabled: !1,
    _prevIgnoreSize: !0,
    _textureFile: "",
    _progressBarTextureFile: "",
    _slidBallNormalTextureFile: "",
    _slidBallPressedTextureFile: "",
    _slidBallDisabledTextureFile: "",
    _capInsetsBarRenderer: null,
    _capInsetsProgressBarRenderer: null,
    _sliderEventListener: null,
    _sliderEventSelector: null,
    _barTexType: ccui.Widget.LOCAL_TEXTURE,
    _progressBarTexType: ccui.Widget.LOCAL_TEXTURE,
    _ballNTexType: ccui.Widget.LOCAL_TEXTURE,
    _ballPTexType: ccui.Widget.LOCAL_TEXTURE,
    _ballDTexType: ccui.Widget.LOCAL_TEXTURE,
    _isTextureLoaded: !1,
    _className: "Slider",
    _barRendererAdaptDirty: !0,
    _progressBarRendererDirty: !0,
    ctor: function() {
        this._progressBarTextureSize = cc.size(0, 0);
        this._capInsetsBarRenderer = cc.rect(0, 0, 0, 0);
        this._capInsetsProgressBarRenderer = cc.rect(0, 0, 0, 0);
        ccui.Widget.prototype.ctor.call(this)
    },
    init: function() {
        return ccui.Widget.prototype.init.call(this)
    },
    _initRenderer: function() {
        this._barRenderer = new cc.Sprite;
        this._progressBarRenderer = new cc.Sprite;
        this._progressBarRenderer.setAnchorPoint(0, 0.5);
        this.addProtectedChild(this._barRenderer, ccui.Slider.BASEBAR_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._progressBarRenderer, ccui.Slider.PROGRESSBAR_RENDERER_ZORDER, -1);
        this._slidBallNormalRenderer = new cc.Sprite;
        this._slidBallPressedRenderer = new cc.Sprite;
        this._slidBallPressedRenderer.setVisible(!1);
        this._slidBallDisabledRenderer = new cc.Sprite;
        this._slidBallDisabledRenderer.setVisible(!1);
        this._slidBallRenderer = new cc.Node;
        this._slidBallRenderer.addChild(this._slidBallNormalRenderer);
        this._slidBallRenderer.addChild(this._slidBallPressedRenderer);
        this._slidBallRenderer.addChild(this._slidBallDisabledRenderer);
        this._slidBallRenderer.setCascadeColorEnabled(!0);
        this._slidBallRenderer.setCascadeOpacityEnabled(!0);
        this.addProtectedChild(this._slidBallRenderer, ccui.Slider.BALL_RENDERER_ZORDER, -1)
    },
    loadBarTexture: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._textureFile = a;
            this._barTexType = b;
            var c = this._barRenderer,
                d = this;
            (!c.texture || !c.texture.isLoaded()) && c.addEventListener("load", function() {
                d._findLayout();
                d._updateChildrenDisplayedRGBA();
                d._barRendererAdaptDirty = !0;
                d._progressBarRendererDirty = !0;
                d._updateContentSizeWithTextureSize(d._barRenderer.getContentSize())
            });
            switch (this._barTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    c.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    c.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA();
            this._progressBarRendererDirty = this._barRendererAdaptDirty = !0;
            this._updateContentSizeWithTextureSize(this._barRenderer.getContentSize())
        }
    },
    loadProgressBarTexture: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._progressBarTextureFile = a;
            this._progressBarTexType = b;
            var c = this._progressBarRenderer,
                d = this;
            (!c.texture || !c.texture.isLoaded()) && c.addEventListener("load", function() {
                d._findLayout();
                d._updateChildrenDisplayedRGBA();
                d._progressBarRenderer.setAnchorPoint(cc.p(0, 0.5));
                var a = d._progressBarRenderer.getContentSize();
                d._progressBarTextureSize = {
                    width: a.width,
                    height: a.height
                };
                d._progressBarRendererDirty = !0
            });
            switch (this._progressBarTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    c.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    c.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA();
            this._progressBarRenderer.setAnchorPoint(cc.p(0, 0.5));
            c = this._progressBarRenderer.getContentSize();
            this._progressBarTextureSize = {
                width: c.width,
                height: c.height
            };
            this._progressBarRendererDirty = !0
        }
    },
    setScale9Enabled: function(a) {
        this._scale9Enabled !=
            a && (this._scale9Enabled = a, this.removeProtectedChild(this._barRenderer, !0), this.removeProtectedChild(this._progressBarRenderer, !0), this._progressBarRenderer = this._barRenderer = null, this._scale9Enabled ? (this._barRenderer = new ccui.Scale9Sprite, this._progressBarRenderer = new ccui.Scale9Sprite) : (this._barRenderer = new cc.Sprite, this._progressBarRenderer = new cc.Sprite), this.loadBarTexture(this._textureFile, this._barTexType), this.loadProgressBarTexture(this._progressBarTextureFile, this._progressBarTexType),
                this.addProtectedChild(this._barRenderer, ccui.Slider.BASEBAR_RENDERER_ZORDER, -1), this.addProtectedChild(this._progressBarRenderer, ccui.Slider.PROGRESSBAR_RENDERER_ZORDER, -1), this._scale9Enabled ? (a = this._ignoreSize, this.ignoreContentAdaptWithSize(!1), this._prevIgnoreSize = a) : this.ignoreContentAdaptWithSize(this._prevIgnoreSize), this.setCapInsetsBarRenderer(this._capInsetsBarRenderer), this.setCapInsetProgressBarRenderer(this._capInsetsProgressBarRenderer))
    },
    isScale9Enabled: function() {
        return this._scale9Enabled
    },
    ignoreContentAdaptWithSize: function(a) {
        if (!this._scale9Enabled || this._scale9Enabled && !a) ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this, a), this._prevIgnoreSize = a
    },
    setCapInsets: function(a) {
        this.setCapInsetsBarRenderer(a);
        this.setCapInsetProgressBarRenderer(a)
    },
    setCapInsetsBarRenderer: function(a) {
        if (a) {
            var b = this._capInsetsBarRenderer;
            b.x = a.x;
            b.y = a.y;
            b.width = a.width;
            b.height = a.height;
            this._scale9Enabled && this._barRenderer.setCapInsets(a)
        }
    },
    getCapInsetsBarRenderer: function() {
        return cc.rect(this._capInsetsBarRenderer)
    },
    setCapInsetProgressBarRenderer: function(a) {
        if (a) {
            var b = this._capInsetsProgressBarRenderer;
            b.x = a.x;
            b.y = a.y;
            b.width = a.width;
            b.height = a.height;
            this._scale9Enabled && this._progressBarRenderer.setCapInsets(a)
        }
    },
    getCapInsetsProgressBarRenderer: function() {
        return cc.rect(this._capInsetsProgressBarRenderer)
    },
    loadSlidBallTextures: function(a, b, c, d) {
        this.loadSlidBallTextureNormal(a, d);
        this.loadSlidBallTexturePressed(b, d);
        this.loadSlidBallTextureDisabled(c, d)
    },
    loadSlidBallTextureNormal: function(a, b) {
        if (a) {
            b = b ||
                ccui.Widget.LOCAL_TEXTURE;
            this._slidBallNormalTextureFile = a;
            this._ballNTexType = b;
            var c = this;
            (!this._slidBallNormalRenderer.texture || !this._slidBallNormalRenderer.texture.isLoaded()) && this._slidBallNormalRenderer.addEventListener("load", function() {
                c._updateChildrenDisplayedRGBA()
            });
            switch (this._ballNTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._slidBallNormalRenderer.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._slidBallNormalRenderer.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA()
        }
    },
    loadSlidBallTexturePressed: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._slidBallPressedTextureFile = a;
            this._ballPTexType = b;
            var c = this;
            (!this._slidBallPressedRenderer.texture || !this._slidBallPressedRenderer.texture.isLoaded()) && this._slidBallPressedRenderer.addEventListener("load", function() {
                c._updateChildrenDisplayedRGBA()
            });
            switch (this._ballPTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._slidBallPressedRenderer.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._slidBallPressedRenderer.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA()
        }
    },
    loadSlidBallTextureDisabled: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._slidBallDisabledTextureFile = a;
            this._ballDTexType = b;
            var c = this;
            (!this._slidBallDisabledRenderer.texture || !this._slidBallDisabledRenderer.texture.isLoaded()) && this._slidBallDisabledRenderer.addEventListener("load", function() {
                c._updateChildrenDisplayedRGBA()
            });
            switch (this._ballDTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._slidBallDisabledRenderer.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._slidBallDisabledRenderer.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA()
        }
    },
    setPercent: function(a) {
        100 < a && (a = 100);
        0 > a && (a = 0);
        this._percent = a;
        a = this._barLength * (a / 100);
        this._slidBallRenderer.setPosition(a, this._contentSize.height / 2);
        if (this._scale9Enabled) this._progressBarRenderer.setPreferredSize(cc.size(a, this._progressBarTextureSize.height));
        else {
            var b = this._progressBarRenderer,
                c = b.getTextureRect();
            b.setTextureRect(cc.rect(c.x, c.y, a, c.height), b.isTextureRectRotated())
        }
    },
    hitTest: function(a) {
        a = this._slidBallNormalRenderer.convertToNodeSpace(a);
        var b = this._slidBallNormalRenderer.getContentSize(),
            b = cc.rect(0, 0, b.width, b.height);
        return a.x >= b.x && a.x <= b.x + b.width && a.y >= b.y && a.y <= b.y + b.height
    },
    onTouchBegan: function(a, b) {
        var c = ccui.Widget.prototype.onTouchBegan.call(this, a, b);
        if (this._hit) {
            var d = this.convertToNodeSpace(this._touchBeganPosition);
            this.setPercent(this._getPercentWithBallPos(d.x));
            this._percentChangedEvent()
        }
        return c
    },
    onTouchMoved: function(a, b) {
        var c = a.getLocation(),
            c = this.convertToNodeSpace(c);
        this.setPercent(this._getPercentWithBallPos(c.x));
        this._percentChangedEvent()
    },
    onTouchEnded: function(a,
        b) {
        ccui.Widget.prototype.onTouchEnded.call(this, a, b)
    },
    onTouchCancelled: function(a, b) {
        ccui.Widget.prototype.onTouchCancelled.call(this, a, b)
    },
    _getPercentWithBallPos: function(a) {
        return 100 * (a / this._barLength)
    },
    addEventListenerSlider: function(a, b) {
        this.addEventListener(a, b)
    },
    addEventListener: function(a, b) {
        this._sliderEventSelector = a;
        this._sliderEventListener = b
    },
    _percentChangedEvent: function() {
        this._sliderEventSelector && (this._sliderEventListener ? this._sliderEventSelector.call(this._sliderEventListener,
            this, ccui.Slider.EVENT_PERCENT_CHANGED) : this._sliderEventSelector(this, ccui.Slider.EVENT_PERCENT_CHANGED))
    },
    getPercent: function() {
        return this._percent
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this);
        this._progressBarRendererDirty = this._barRendererAdaptDirty = !0
    },
    _adaptRenderers: function() {
        this._barRendererAdaptDirty && (this._barRendererScaleChangedWithSize(), this._barRendererAdaptDirty = !1);
        this._progressBarRendererDirty && (this._progressBarRendererScaleChangedWithSize(), this._progressBarRendererDirty = !1)
    },
    getVirtualRendererSize: function() {
        return this._barRenderer.getContentSize()
    },
    getVirtualRenderer: function() {
        return this._barRenderer
    },
    _barRendererScaleChangedWithSize: function() {
        if (this._ignoreSize) this._barRenderer.setScale(1), this._barLength = this._contentSize.width;
        else if (this._barLength = this._contentSize.width, this._scale9Enabled) this._barRenderer.setPreferredSize(this._contentSize);
        else {
            var a = this._barRenderer.getContentSize();
            if (0 >= a.width || 0 >= a.height) {
                this._barRenderer.setScale(1);
                return
            }
            var b =
                this._contentSize.height / a.height;
            this._barRenderer.setScaleX(this._contentSize.width / a.width);
            this._barRenderer.setScaleY(b)
        }
        this._barRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2);
        this.setPercent(this._percent)
    },
    _progressBarRendererScaleChangedWithSize: function() {
        if (this._ignoreSize) {
            if (!this._scale9Enabled) {
                var a = this._progressBarTextureSize,
                    b = this._contentSize.width / a.width,
                    a = this._contentSize.height / a.height;
                this._progressBarRenderer.setScaleX(b);
                this._progressBarRenderer.setScaleY(a)
            }
        } else if (this._scale9Enabled) this._progressBarRenderer.setPreferredSize(this._contentSize),
            this._progressBarTextureSize = this._progressBarRenderer.getContentSize();
        else {
            a = this._progressBarTextureSize;
            if (0 >= a.width || 0 >= a.height) {
                this._progressBarRenderer.setScale(1);
                return
            }
            b = this._contentSize.width / a.width;
            a = this._contentSize.height / a.height;
            this._progressBarRenderer.setScaleX(b);
            this._progressBarRenderer.setScaleY(a)
        }
        this._progressBarRenderer.setPosition(0, this._contentSize.height / 2);
        this.setPercent(this._percent)
    },
    _onPressStateChangedToNormal: function() {
        this._slidBallNormalRenderer.setVisible(!0);
        this._slidBallPressedRenderer.setVisible(!1);
        this._slidBallDisabledRenderer.setVisible(!1)
    },
    _onPressStateChangedToPressed: function() {
        this._slidBallNormalRenderer.setVisible(!1);
        this._slidBallPressedRenderer.setVisible(!0);
        this._slidBallDisabledRenderer.setVisible(!1)
    },
    _onPressStateChangedToDisabled: function() {
        this._slidBallNormalRenderer.setVisible(!1);
        this._slidBallPressedRenderer.setVisible(!1);
        this._slidBallDisabledRenderer.setVisible(!0)
    },
    getDescription: function() {
        return "Slider"
    },
    _createCloneInstance: function() {
        return new ccui.Slider
    },
    _copySpecialProperties: function(a) {
        this._prevIgnoreSize = a._prevIgnoreSize;
        this.setScale9Enabled(a._scale9Enabled);
        this.loadBarTexture(a._textureFile, a._barTexType);
        this.loadProgressBarTexture(a._progressBarTextureFile, a._progressBarTexType);
        this.loadSlidBallTextureNormal(a._slidBallNormalTextureFile, a._ballNTexType);
        this.loadSlidBallTexturePressed(a._slidBallPressedTextureFile, a._ballPTexType);
        this.loadSlidBallTextureDisabled(a._slidBallDisabledTextureFile, a._ballDTexType);
        this.setPercent(a.getPercent());
        this._sliderEventListener = a._sliderEventListener;
        this._sliderEventSelector = a._sliderEventSelector
    }
});
_p = ccui.Slider.prototype;
cc.defineGetterSetter(_p, "percent", _p.getPercent, _p.setPercent);
_p = null;
ccui.Slider.create = function() {
    return new ccui.Slider
};
ccui.Slider.EVENT_PERCENT_CHANGED = 0;
ccui.Slider.BASEBAR_RENDERER_ZORDER = -3;
ccui.Slider.PROGRESSBAR_RENDERER_ZORDER = -2;
ccui.Slider.BALL_RENDERER_ZORDER = -1;
ccui.Text = ccui.Widget.extend({
    _touchScaleChangeEnabled: !1,
    _normalScaleValueX: 1,
    _normalScaleValueY: 1,
    _fontName: "Thonburi",
    _fontSize: 10,
    _onSelectedScaleOffset: 0.5,
    _labelRenderer: "",
    _textAreaSize: null,
    _textVerticalAlignment: 0,
    _textHorizontalAlignment: 0,
    _className: "Text",
    _type: null,
    _labelRendererAdaptDirty: !0,
    ctor: function(a, b, c) {
        this._type = ccui.Text.Type.SYSTEM;
        this._textAreaSize = cc.size(0, 0);
        ccui.Widget.prototype.ctor.call(this);
        void 0 !== c && this.init(a, b, c)
    },
    init: function(a, b, c) {
        return ccui.Widget.prototype.init.call(this) ?
            (0 < arguments.length && (this.setString(a), this.setFontName(b), this.setFontSize(c)), !0) : !1
    },
    _initRenderer: function() {
        this._labelRenderer = new cc.LabelTTF;
        this.addProtectedChild(this._labelRenderer, ccui.Text.RENDERER_ZORDER, -1)
    },
    setText: function(a) {
        cc.log("Please use the setString");
        this.setString(a)
    },
    setString: function(a) {
        this._labelRenderer.setString(a);
        this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize());
        this._labelRendererAdaptDirty = !0
    },
    getStringValue: function() {
        cc.log("Please use the getString");
        return this._labelRenderer.getString()
    },
    getString: function() {
        return this._labelRenderer.getString()
    },
    getStringLength: function() {
        return this._labelRenderer.getStringLength()
    },
    setFontSize: function(a) {
        this._labelRenderer.setFontSize(a);
        this._fontSize = a;
        this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize());
        this._labelRendererAdaptDirty = !0
    },
    getFontSize: function() {
        return this._fontSize
    },
    setFontName: function(a) {
        this._fontName = a;
        this._labelRenderer.setFontName(a);
        this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize());
        this._labelRendererAdaptDirty = !0
    },
    getFontName: function() {
        return this._fontName
    },
    _setFont: function(a) {
        var b = cc.LabelTTF._fontStyleRE.exec(a);
        b && (this._fontSize = parseInt(b[1]), this._fontName = b[2], this._labelRenderer._setFont(a), this._labelScaleChangedWithSize())
    },
    _getFont: function() {
        return this._labelRenderer._getFont()
    },
    getType: function() {
        return this._type
    },
    setTextAreaSize: function(a) {
        this._labelRenderer.setDimensions(a);
        this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize());
        this._labelRendererAdaptDirty = !0
    },
    getTextAreaSize: function() {
        return this._labelRenderer.getDimensions()
    },
    setTextHorizontalAlignment: function(a) {
        this._labelRenderer.setHorizontalAlignment(a);
        this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize());
        this._labelRendererAdaptDirty = !0
    },
    getTextHorizontalAlignment: function() {
        return this._labelRenderer.getHorizontalAlignment()
    },
    setTextVerticalAlignment: function(a) {
        this._labelRenderer.setVerticalAlignment(a);
        this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize());
        this._labelRendererAdaptDirty = !0
    },
    getTextVerticalAlignment: function() {
        return this._labelRenderer.getVerticalAlignment()
    },
    setTouchScaleChangeEnabled: function(a) {
        this._touchScaleChangeEnabled = a
    },
    isTouchScaleChangeEnabled: function() {
        return this._touchScaleChangeEnabled
    },
    _onPressStateChangedToNormal: function() {
        this._touchScaleChangeEnabled && (this._labelRenderer.setScaleX(this._normalScaleValueX), this._labelRenderer.setScaleY(this._normalScaleValueY))
    },
    _onPressStateChangedToPressed: function() {
        this._touchScaleChangeEnabled &&
            (this._labelRenderer.setScaleX(this._normalScaleValueX + this._onSelectedScaleOffset), this._labelRenderer.setScaleY(this._normalScaleValueY + this._onSelectedScaleOffset))
    },
    _onPressStateChangedToDisabled: function() {},
    _updateFlippedX: function() {
        this._flippedX ? this._labelRenderer.setScaleX(-1) : this._labelRenderer.setScaleX(1)
    },
    _updateFlippedY: function() {
        this._flippedY ? this._labelRenderer.setScaleY(-1) : this._labelRenderer.setScaleY(1)
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this);
        this._labelRendererAdaptDirty = !0
    },
    _adaptRenderers: function() {
        this._labelRendererAdaptDirty && (this._labelScaleChangedWithSize(), this._labelRendererAdaptDirty = !1)
    },
    getVirtualRendererSize: function() {
        return this._labelRenderer.getContentSize()
    },
    getVirtualRenderer: function() {
        return this._labelRenderer
    },
    _labelScaleChangedWithSize: function() {
        var a = this._contentSize;
        if (this._ignoreSize) this._labelRenderer.setDimensions(0, 0), this._labelRenderer.setScale(1), this._normalScaleValueX = this._normalScaleValueY = 1;
        else {
            this._labelRenderer.setDimensions(cc.size(a.width, a.height));
            var b = this._labelRenderer.getContentSize();
            if (0 >= b.width || 0 >= b.height) {
                this._labelRenderer.setScale(1);
                return
            }
            var c = a.width / b.width,
                b = a.height / b.height;
            this._labelRenderer.setScaleX(c);
            this._labelRenderer.setScaleY(b);
            this._normalScaleValueX = c;
            this._normalScaleValueY = b
        }
        this._labelRenderer.setPosition(a.width / 2, a.height / 2)
    },
    getDescription: function() {
        return "Label"
    },
    enableShadow: function(a, b, c) {
        this._labelRenderer.enableShadow(a, b, c)
    },
    enableOutline: function(a, b) {
        this._labelRenderer.enableStroke(a, b)
    },
    enableGlow: function(a) {
        this._type == ccui.Text.Type.TTF && this._labelRenderer.enableGlow(a)
    },
    disableEffect: function() {
        this._labelRenderer.disableEffect && this._labelRenderer.disableEffect()
    },
    _createCloneInstance: function() {
        return new ccui.Text
    },
    _copySpecialProperties: function(a) {
        a instanceof ccui.Text && (this.setFontName(a._fontName), this.setFontSize(a.getFontSize()), this.setString(a.getString()), this.setTouchScaleChangeEnabled(a.touchScaleEnabled),
            this.setTextAreaSize(a._textAreaSize), this.setTextHorizontalAlignment(a._labelRenderer.getHorizontalAlignment()), this.setTextVerticalAlignment(a._labelRenderer.getVerticalAlignment()))
    },
    _setBoundingWidth: function(a) {
        this._textAreaSize.width = a;
        this._labelRenderer._setBoundingWidth(a);
        this._labelScaleChangedWithSize()
    },
    _setBoundingHeight: function(a) {
        this._textAreaSize.height = a;
        this._labelRenderer._setBoundingHeight(a);
        this._labelScaleChangedWithSize()
    },
    _getBoundingWidth: function() {
        return this._textAreaSize.width
    },
    _getBoundingHeight: function() {
        return this._textAreaSize.height
    },
    _transformForRenderer: function() {
        this._adaptRenderers();
        cc._renderType === cc._RENDER_TYPE_CANVAS ? cc.Node.prototype.transform.call(this) : cc.ProtectedNode.prototype._transformForRenderer.call(this);
        this._labelRenderer._transformForRenderer()
    }
});
_p = ccui.Text.prototype;
cc.defineGetterSetter(_p, "boundingWidth", _p._getBoundingWidth, _p._setBoundingWidth);
cc.defineGetterSetter(_p, "boundingHeight", _p._getBoundingHeight, _p._setBoundingHeight);
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
cc.defineGetterSetter(_p, "stringLength", _p.getStringLength);
cc.defineGetterSetter(_p, "font", _p._getFont, _p._setFont);
cc.defineGetterSetter(_p, "fontSize", _p.getFontSize, _p.setFontSize);
cc.defineGetterSetter(_p, "fontName", _p.getFontName, _p.setFontName);
cc.defineGetterSetter(_p, "textAlign", _p.getTextHorizontalAlignment, _p.setTextHorizontalAlignment);
cc.defineGetterSetter(_p, "verticalAlign", _p.getTextVerticalAlignment, _p.setTextVerticalAlignment);
_p = null;
ccui.Label = ccui.Text.create = function(a, b, c) {
    return new ccui.Text(a, b, c)
};
ccui.Text.RENDERER_ZORDER = -1;
ccui.Text.Type = {
    SYSTEM: 0,
    TTF: 1
};
ccui.TextAtlas = ccui.Widget.extend({
    _labelAtlasRenderer: null,
    _stringValue: "",
    _charMapFileName: "",
    _itemWidth: 0,
    _itemHeight: 0,
    _startCharMap: "",
    _className: "TextAtlas",
    _labelAtlasRendererAdaptDirty: null,
    ctor: function(a, b, c, d, e) {
        ccui.Widget.prototype.ctor.call(this);
        void 0 !== e && this.setProperty(a, b, c, d, e)
    },
    _initRenderer: function() {
        this._labelAtlasRenderer = new cc.LabelAtlas;
        this._labelAtlasRenderer.setAnchorPoint(cc.p(0.5, 0.5));
        this.addProtectedChild(this._labelAtlasRenderer, ccui.TextAtlas.RENDERER_ZORDER, -1)
    },
    setProperty: function(a, b, c, d, e) {
        this._stringValue = a;
        this._charMapFileName = b;
        this._itemWidth = c;
        this._itemHeight = d;
        this._startCharMap = e;
        this._labelAtlasRenderer.initWithString(a, this._charMapFileName, this._itemWidth, this._itemHeight, this._startCharMap[0]);
        this._updateContentSizeWithTextureSize(this._labelAtlasRenderer.getContentSize());
        this._labelAtlasRendererAdaptDirty = !0
    },
    setString: function(a) {
        this._stringValue = a;
        this._labelAtlasRenderer.setString(a);
        this._updateContentSizeWithTextureSize(this._labelAtlasRenderer.getContentSize());
        this._labelAtlasRendererAdaptDirty = !0
    },
    setStringValue: function(a) {
        cc.log("Please use the setString");
        this.setString(a)
    },
    getStringValue: function() {
        cc.log("Please use the getString");
        return this.getString()
    },
    getString: function() {
        return this._labelAtlasRenderer.getString()
    },
    getStringLength: function() {
        return this._labelAtlasRenderer.getStringLength()
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this);
        this._labelAtlasRendererAdaptDirty = !0
    },
    _adaptRenderers: function() {
        this._labelAtlasRendererAdaptDirty &&
            (this._labelAtlasScaleChangedWithSize(), this._labelAtlasRendererAdaptDirty = !1)
    },
    getVirtualRendererSize: function() {
        return this._labelAtlasRenderer.getContentSize()
    },
    getVirtualRenderer: function() {
        return this._labelAtlasRenderer
    },
    _labelAtlasScaleChangedWithSize: function() {
        var a = this._labelAtlasRenderer;
        if (this._ignoreSize) a.setScale(1);
        else {
            var b = a.getContentSize();
            if (0 >= b.width || 0 >= b.height) {
                a.setScale(1);
                return
            }
            a.setScaleX(this._contentSize.width / b.width);
            a.setScaleY(this._contentSize.height / b.height)
        }
        a.setPosition(this._contentSize.width /
            2, this._contentSize.height / 2)
    },
    getDescription: function() {
        return "LabelAtlas"
    },
    _copySpecialProperties: function(a) {
        a && this.setProperty(a._stringValue, a._charMapFileName, a._itemWidth, a._itemHeight, a._startCharMap)
    },
    _createCloneInstance: function() {
        return new ccui.TextAtlas
    }
});
_p = ccui.TextAtlas.prototype;
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
_p = null;
ccui.TextAtlas.create = function(a, b, c, d, e) {
    return new ccui.TextAtlas(a, b, c, d, e)
};
ccui.TextAtlas.RENDERER_ZORDER = -1;
ccui.LabelBMFont = ccui.TextBMFont = ccui.Widget.extend({
    _labelBMFontRenderer: null,
    _fntFileHasInit: !1,
    _fntFileName: "",
    _stringValue: "",
    _className: "TextBMFont",
    _labelBMFontRendererAdaptDirty: !0,
    ctor: function(a, b) {
        ccui.Widget.prototype.ctor.call(this);
        void 0 != b && (this.setFntFile(b), this.setString(a))
    },
    _initRenderer: function() {
        this._labelBMFontRenderer = new cc.LabelBMFont;
        this.addProtectedChild(this._labelBMFontRenderer, ccui.TextBMFont.RENDERER_ZORDER, -1)
    },
    setFntFile: function(a) {
        if (a) {
            var b = this;
            b._fntFileName =
                a;
            b._fntFileHasInit = !0;
            b._labelBMFontRenderer.initWithString(this._stringValue, a);
            a = b._labelBMFontRenderer;
            a._textureLoaded || a.addEventListener("load", function() {
                b.updateSizeAndPosition()
            })
        }
    },
    setText: function(a) {
        cc.log("Please use the setString");
        this.setString(a)
    },
    setString: function(a) {
        this._stringValue = a;
        this._fntFileHasInit && (this._labelBMFontRenderer.setString(a), this._updateContentSizeWithTextureSize(this._labelBMFontRenderer.getContentSize()), this._labelBMFontRendererAdaptDirty = !0)
    },
    getString: function() {
        return this._stringValue
    },
    getStringLength: function() {
        return this._labelBMFontRenderer.getStringLength()
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this);
        this._labelBMFontRendererAdaptDirty = !0
    },
    _adaptRenderers: function() {
        this._labelBMFontRendererAdaptDirty && (this._labelBMFontScaleChangedWithSize(), this._labelBMFontRendererAdaptDirty = !1)
    },
    getVirtualRendererSize: function() {
        return this._labelBMFontRenderer.getContentSize()
    },
    getVirtualRenderer: function() {
        return this._labelBMFontRenderer
    },
    _labelBMFontScaleChangedWithSize: function() {
        var a =
            this._labelBMFontRenderer;
        if (this._ignoreSize) a.setScale(1);
        else {
            var b = a.getContentSize();
            if (0 >= b.width || 0 >= b.height) {
                a.setScale(1);
                return
            }
            a.setScaleX(this._contentSize.width / b.width);
            a.setScaleY(this._contentSize.height / b.height)
        }
        a.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    },
    getDescription: function() {
        return "TextBMFont"
    },
    _createCloneInstance: function() {
        return new ccui.TextBMFont
    },
    _copySpecialProperties: function(a) {
        this.setFntFile(a._fntFileName);
        this.setString(a._stringValue)
    }
});
_p = ccui.TextBMFont.prototype;
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
_p = null;
ccui.TextBMFont.create = function(a, b) {
    return new ccui.TextBMFont(a, b)
};
ccui.TextBMFont.RENDERER_ZORDER = -1;
ccui._TextFieldRenderer = cc.TextFieldTTF.extend({
    _maxLengthEnabled: !1,
    _maxLength: 0,
    _passwordEnabled: !1,
    _passwordStyleText: "",
    _attachWithIME: !1,
    _detachWithIME: !1,
    _insertText: !1,
    _deleteBackward: !1,
    _className: "_TextFieldRenderer",
    _textFieldRendererAdaptDirty: !0,
    ctor: function() {
        cc.TextFieldTTF.prototype.ctor.call(this);
        this._maxLengthEnabled = !1;
        this._maxLength = 0;
        this._passwordEnabled = !1;
        this._passwordStyleText = "*";
        this._deleteBackward = this._insertText = this._detachWithIME = this._attachWithIME = !1
    },
    onEnter: function() {
        cc.TextFieldTTF.prototype.onEnter.call(this);
        cc.TextFieldTTF.prototype.setDelegate.call(this, this)
    },
    onTextFieldAttachWithIME: function(a) {
        this.setAttachWithIME(!0);
        return !1
    },
    onTextFieldInsertText: function(a, b, c) {
        if (1 == c && "\n" == b) return !1;
        this.setInsertText(!0);
        return this._maxLengthEnabled && cc.TextFieldTTF.prototype.getCharCount.call(this) >= this._maxLength
    },
    onTextFieldDeleteBackward: function(a, b, c) {
        this.setDeleteBackward(!0);
        return !1
    },
    onTextFieldDetachWithIME: function(a) {
        this.setDetachWithIME(!0);
        return !1
    },
    insertText: function(a, b) {
        "\n" != a && this._maxLengthEnabled &&
            this.getString().length >= this._maxLength ? this._passwordEnabled && this.setPasswordText(this.getString()) : (cc.TextFieldTTF.prototype.insertText.call(this, a, b), this._passwordEnabled && 0 < cc.TextFieldTTF.prototype.getCharCount.call(this) && this.setPasswordText(this.getString()))
    },
    deleteBackward: function() {
        cc.TextFieldTTF.prototype.deleteBackward.call(this);
        0 < cc.TextFieldTTF.prototype.getCharCount.call(this) && this._passwordEnabled && this.setPasswordText(this._inputText)
    },
    openIME: function() {
        cc.TextFieldTTF.prototype.attachWithIME.call(this)
    },
    closeIME: function() {
        cc.TextFieldTTF.prototype.detachWithIME.call(this)
    },
    setMaxLengthEnabled: function(a) {
        this._maxLengthEnabled = a
    },
    isMaxLengthEnabled: function() {
        return this._maxLengthEnabled
    },
    setMaxLength: function(a) {
        this._maxLength = a
    },
    getMaxLength: function() {
        return this._maxLength
    },
    getCharCount: function() {
        return cc.TextFieldTTF.prototype.getCharCount.call(this)
    },
    setPasswordEnabled: function(a) {
        this._passwordEnabled = a
    },
    isPasswordEnabled: function() {
        return this._passwordEnabled
    },
    setPasswordStyleText: function(a) {
        if (!(1 <
            a.length)) {
            var b = a.charCodeAt(0);
            33 > b || 126 < b || (this._passwordStyleText = a)
        }
    },
    setPasswordText: function(a) {
        var b = "",
            c = a.length;
        a = c;
        this._maxLengthEnabled && c > this._maxLength && (a = this._maxLength);
        for (c = 0; c < a; ++c) b += this._passwordStyleText;
        cc.LabelTTF.prototype.setString.call(this, b)
    },
    setAttachWithIME: function(a) {
        this._attachWithIME = a
    },
    getAttachWithIME: function() {
        return this._attachWithIME
    },
    setDetachWithIME: function(a) {
        this._detachWithIME = a
    },
    getDetachWithIME: function() {
        return this._detachWithIME
    },
    setInsertText: function(a) {
        this._insertText =
            a
    },
    getInsertText: function() {
        return this._insertText
    },
    setDeleteBackward: function(a) {
        this._deleteBackward = a
    },
    getDeleteBackward: function() {
        return this._deleteBackward
    },
    onDraw: function(a) {
        return !1
    }
});
ccui._TextFieldRenderer.create = function(a, b, c) {
    var d = new ccui._TextFieldRenderer;
    return d && d.initWithString("", b, c) ? (a && d.setPlaceHolder(a), d) : null
};
ccui.TextField = ccui.Widget.extend({
    _textFieldRenderer: null,
    _touchWidth: 0,
    _touchHeight: 0,
    _useTouchArea: !1,
    _textFieldEventListener: null,
    _textFieldEventSelector: null,
    _passwordStyleText: "",
    _textFieldRendererAdaptDirty: !0,
    _fontName: "",
    _fontSize: 12,
    ctor: function(a, b, c) {
        ccui.Widget.prototype.ctor.call(this);
        a && this.setPlaceHolder(a);
        b && this.setFontName(b);
        c && this.setFontSize(c)
    },
    init: function() {
        return ccui.Widget.prototype.init.call(this) ? (this.setTouchEnabled(!0), !0) : !1
    },
    onEnter: function() {
        ccui.Widget.prototype.onEnter.call(this);
        this.scheduleUpdate()
    },
    _initRenderer: function() {
        this._textFieldRenderer = ccui._TextFieldRenderer.create("input words here", "Thonburi", 20);
        this.addProtectedChild(this._textFieldRenderer, ccui.TextField.RENDERER_ZORDER, -1)
    },
    setTouchSize: function(a) {
        this._touchWidth = a.width;
        this._touchHeight = a.height
    },
    setTouchAreaEnabled: function(a) {
        this._useTouchArea = a
    },
    hitTest: function(a) {
        if (this._useTouchArea) {
            a = this.convertToNodeSpace(a);
            var b = cc.rect(-this._touchWidth * this._anchorPoint.x, -this._touchHeight * this._anchorPoint.y,
                this._touchWidth, this._touchHeight);
            return a.x >= b.x && a.x <= b.x + b.width && a.y >= b.y && a.y <= b.y + b.height
        }
        return ccui.Widget.prototype.hitTest.call(this, a)
    },
    getTouchSize: function() {
        return cc.size(this._touchWidth, this._touchHeight)
    },
    setText: function(a) {
        cc.log("Please use the setString");
        this.setString(a)
    },
    setString: function(a) {
        null != a && (a = String(a), this.isMaxLengthEnabled() && (a = a.substr(0, this.getMaxLength())), this.isPasswordEnabled() ? (this._textFieldRenderer.setPasswordText(a), this._textFieldRenderer.setString(""),
            this._textFieldRenderer.insertText(a, a.length)) : this._textFieldRenderer.setString(a), this._textFieldRendererAdaptDirty = !0, this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize()))
    },
    setPlaceHolder: function(a) {
        this._textFieldRenderer.setPlaceHolder(a);
        this._textFieldRendererAdaptDirty = !0;
        this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize())
    },
    getPlaceHolder: function() {
        return this._textFieldRenderer.getPlaceHolder()
    },
    getPlaceHolderColor: function() {
        return this._textFieldRenderer.getPlaceHolderColor()
    },
    setPlaceHolderColor: function(a) {
        this._textFieldRenderer.setColorSpaceHolder(a)
    },
    setTextColor: function(a) {
        this._textFieldRenderer.setTextColor(a)
    },
    setFontSize: function(a) {
        this._textFieldRenderer.setFontSize(a);
        this._fontSize = a;
        this._textFieldRendererAdaptDirty = !0;
        this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize())
    },
    getFontSize: function() {
        return this._fontSize
    },
    setFontName: function(a) {
        this._textFieldRenderer.setFontName(a);
        this._fontName = a;
        this._textFieldRendererAdaptDirty = !0;
        this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize())
    },
    getFontName: function() {
        return this._fontName
    },
    didNotSelectSelf: function() {
        this._textFieldRenderer.detachWithIME()
    },
    getStringValue: function() {
        cc.log("Please use the getString");
        return this.getString()
    },
    getString: function() {
        return this._textFieldRenderer.getString()
    },
    getStringLength: function() {
        return this._textFieldRenderer.getStringLength()
    },
    onTouchBegan: function(a, b) {
        var c = this,
            d = ccui.Widget.prototype.onTouchBegan.call(c,
                a, b);
        c._hit && setTimeout(function() {
            c._textFieldRenderer.attachWithIME()
        }, 0);
        return d
    },
    setMaxLengthEnabled: function(a) {
        this._textFieldRenderer.setMaxLengthEnabled(a)
    },
    isMaxLengthEnabled: function() {
        return this._textFieldRenderer.isMaxLengthEnabled()
    },
    setMaxLength: function(a) {
        this._textFieldRenderer.setMaxLength(a);
        this.setString(this.getString())
    },
    getMaxLength: function() {
        return this._textFieldRenderer.getMaxLength()
    },
    setPasswordEnabled: function(a) {
        this._textFieldRenderer.setPasswordEnabled(a)
    },
    isPasswordEnabled: function() {
        return this._textFieldRenderer.isPasswordEnabled()
    },
    setPasswordStyleText: function(a) {
        this._textFieldRenderer.setPasswordStyleText(a);
        this._passwordStyleText = a;
        this.setString(this.getString())
    },
    getPasswordStyleText: function() {
        return this._passwordStyleText
    },
    update: function(a) {
        this.getAttachWithIME() && (this._attachWithIMEEvent(), this.setAttachWithIME(!1));
        this.getDetachWithIME() && (this._detachWithIMEEvent(), this.setDetachWithIME(!1));
        this.getInsertText() && (this._insertTextEvent(), this.setInsertText(!1), this._textFieldRendererAdaptDirty = !0, this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize()));
        this.getDeleteBackward() && (this._deleteBackwardEvent(), this.setDeleteBackward(!1), this._textFieldRendererAdaptDirty = !0, this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize()))
    },
    getAttachWithIME: function() {
        return this._textFieldRenderer.getAttachWithIME()
    },
    setAttachWithIME: function(a) {
        this._textFieldRenderer.setAttachWithIME(a)
    },
    getDetachWithIME: function() {
        return this._textFieldRenderer.getDetachWithIME()
    },
    setDetachWithIME: function(a) {
        this._textFieldRenderer.setDetachWithIME(a)
    },
    getInsertText: function() {
        return this._textFieldRenderer.getInsertText()
    },
    setInsertText: function(a) {
        this._textFieldRenderer.setInsertText(a)
    },
    getDeleteBackward: function() {
        return this._textFieldRenderer.getDeleteBackward()
    },
    setDeleteBackward: function(a) {
        this._textFieldRenderer.setDeleteBackward(a)
    },
    _attachWithIMEEvent: function() {
        this._textFieldEventSelector && (this._textFieldEventListener ? this._textFieldEventSelector.call(this._textFieldEventListener, this, ccui.TextField.EVENT_ATTACH_WITH_IME) : this._textFieldEventSelector(this,
            ccui.TextField.EVENT_ATTACH_WITH_IME))
    },
    _detachWithIMEEvent: function() {
        this._textFieldEventSelector && (this._textFieldEventListener ? this._textFieldEventSelector.call(this._textFieldEventListener, this, ccui.TextField.EVENT_DETACH_WITH_IME) : this._textFieldEventSelector(this, ccui.TextField.EVENT_DETACH_WITH_IME))
    },
    _insertTextEvent: function() {
        this._textFieldEventSelector && (this._textFieldEventListener ? this._textFieldEventSelector.call(this._textFieldEventListener, this, ccui.TextField.EVENT_INSERT_TEXT) :
            this._textFieldEventSelector(this, ccui.TextField.EVENT_INSERT_TEXT))
    },
    _deleteBackwardEvent: function() {
        this._textFieldEventSelector && (this._textFieldEventListener ? this._textFieldEventSelector.call(this._textFieldEventListener, this, ccui.TextField.EVENT_DELETE_BACKWARD) : this._textFieldEventSelector(this, ccui.TextField.EVENT_DELETE_BACKWARD))
    },
    addEventListenerTextField: function(a, b) {
        this.addEventListener(a, b)
    },
    addEventListener: function(a, b) {
        this._textFieldEventSelector = a;
        this._textFieldEventListener =
            b
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this);
        this._textFieldRendererAdaptDirty = !0
    },
    _adaptRenderers: function() {
        this._textFieldRendererAdaptDirty && (this._textfieldRendererScaleChangedWithSize(), this._textFieldRendererAdaptDirty = !1)
    },
    _textfieldRendererScaleChangedWithSize: function() {
        this._ignoreSize || this._textFieldRenderer.setDimensions(this._contentSize);
        this._textFieldRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    },
    getVirtualRendererSize: function() {
        return this._textFieldRenderer.getContentSize()
    },
    getVirtualRenderer: function() {
        return this._textFieldRenderer
    },
    getDescription: function() {
        return "TextField"
    },
    attachWithIME: function() {
        this._textFieldRenderer.attachWithIME()
    },
    _createCloneInstance: function() {
        return new ccui.TextField
    },
    _copySpecialProperties: function(a) {
        this.setString(a._textFieldRenderer.getString());
        this.setPlaceHolder(a.getString());
        this.setFontSize(a._textFieldRenderer.getFontSize());
        this.setFontName(a._textFieldRenderer.getFontName());
        this.setMaxLengthEnabled(a.isMaxLengthEnabled());
        this.setMaxLength(a.getMaxLength());
        this.setPasswordEnabled(a.isPasswordEnabled());
        this.setPasswordStyleText(a._passwordStyleText);
        this.setAttachWithIME(a.getAttachWithIME());
        this.setDetachWithIME(a.getDetachWithIME());
        this.setInsertText(a.getInsertText());
        this.setDeleteBackward(a.getDeleteBackward())
    },
    setTextAreaSize: function(a) {
        this.setContentSize(a)
    },
    setTextHorizontalAlignment: function(a) {
        this._textFieldRenderer.setHorizontalAlignment(a)
    },
    setTextVerticalAlignment: function(a) {
        this._textFieldRenderer.setVerticalAlignment(a)
    },
    _setFont: function(a) {
        this._textFieldRenderer._setFont(a);
        this._textFieldRendererAdaptDirty = !0
    },
    _getFont: function() {
        return this._textFieldRenderer._getFont()
    },
    _transformForRenderer: function() {
        this._adaptRenderers();
        cc._renderType === cc._RENDER_TYPE_CANVAS ? cc.Node.prototype.transform.call(this) : cc.ProtectedNode.prototype._transformForRenderer.call(this);
        this._textFieldRenderer._transformForRenderer()
    }
});
ccui.TextField.create = function(a, b, c) {
    return new ccui.TextField(a, b, c)
};
_p = ccui.TextField.prototype;
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
cc.defineGetterSetter(_p, "placeHolder", _p.getPlaceHolder, _p.setPlaceHolder);
cc.defineGetterSetter(_p, "font", _p._getFont, _p._setFont);
cc.defineGetterSetter(_p, "fontSize", _p.getFontSize, _p.setFontSize);
cc.defineGetterSetter(_p, "fontName", _p.getFontName, _p.setFontName);
cc.defineGetterSetter(_p, "maxLengthEnabled", _p.isMaxLengthEnabled, _p.setMaxLengthEnabled);
cc.defineGetterSetter(_p, "maxLength", _p.getMaxLength, _p.setMaxLength);
cc.defineGetterSetter(_p, "passwordEnabled", _p.isPasswordEnabled, _p.setPasswordEnabled);
_p = null;
ccui.TextField.EVENT_ATTACH_WITH_IME = 0;
ccui.TextField.EVENT_DETACH_WITH_IME = 1;
ccui.TextField.EVENT_INSERT_TEXT = 2;
ccui.TextField.EVENT_DELETE_BACKWARD = 3;
ccui.TextField.RENDERER_ZORDER = -1;
ccui.RichElement = ccui.Class.extend({
    _type: 0,
    _tag: 0,
    _color: null,
    _opacity: 0,
    ctor: function() {
        this._tag = this._type = 0;
        this._color = cc.color(255, 255, 255, 255)
    },
    init: function(a, b, c) {
        this._tag = a;
        this._color.r = b.r;
        this._color.g = b.g;
        this._color.b = b.b;
        this._opacity = c;
        this._color.a = void 0 === c ? b.a : c
    }
});
ccui.RichElementText = ccui.RichElement.extend({
    _text: "",
    _fontName: "",
    _fontSize: 0,
    ctor: function(a, b, c, d, e, f) {
        ccui.RichElement.prototype.ctor.call(this);
        this._type = ccui.RichElement.TEXT;
        this._fontName = this._text = "";
        this._fontSize = 0;
        f && this.init(a, b, c, d, e, f)
    },
    init: function(a, b, c, d, e, f) {
        ccui.RichElement.prototype.init.call(this, a, b, c);
        this._text = d;
        this._fontName = e;
        this._fontSize = f
    }
});
ccui.RichElementText.create = function(a, b, c, d, e, f) {
    return new ccui.RichElementText(a, b, c, d, e, f)
};
ccui.RichElementImage = ccui.RichElement.extend({
    _filePath: "",
    _textureRect: null,
    _textureType: 0,
    ctor: function(a, b, c, d) {
        ccui.RichElement.prototype.ctor.call(this);
        this._type = ccui.RichElement.IMAGE;
        this._filePath = "";
        this._textureRect = cc.rect(0, 0, 0, 0);
        this._textureType = 0;
        void 0 !== d && this.init(a, b, c, d)
    },
    init: function(a, b, c, d) {
        ccui.RichElement.prototype.init.call(this, a, b, c);
        this._filePath = d
    }
});
ccui.RichElementImage.create = function(a, b, c, d) {
    return new ccui.RichElementImage(a, b, c, d)
};
ccui.RichElementCustomNode = ccui.RichElement.extend({
    _customNode: null,
    ctor: function(a, b, c, d) {
        ccui.RichElement.prototype.ctor.call(this);
        this._type = ccui.RichElement.CUSTOM;
        this._customNode = null;
        void 0 !== d && this.init(a, b, c, d)
    },
    init: function(a, b, c, d) {
        ccui.RichElement.prototype.init.call(this, a, b, c);
        this._customNode = d
    }
});
ccui.RichElementCustomNode.create = function(a, b, c, d) {
    return new ccui.RichElementCustomNode(a, b, c, d)
};
ccui.RichText = ccui.Widget.extend({
    _formatTextDirty: !1,
    _richElements: null,
    _elementRenders: null,
    _leftSpaceWidth: 0,
    _verticalSpace: 0,
    _elementRenderersContainer: null,
    ctor: function() {
        ccui.Widget.prototype.ctor.call(this);
        this._formatTextDirty = !1;
        this._richElements = [];
        this._elementRenders = [];
        this._verticalSpace = this._leftSpaceWidth = 0
    },
    _initRenderer: function() {
        this._elementRenderersContainer = new cc.Node;
        this._elementRenderersContainer.setAnchorPoint(0.5, 0.5);
        this.addProtectedChild(this._elementRenderersContainer,
            0, -1)
    },
    insertElement: function(a, b) {
        this._richElements.splice(b, 0, a);
        this._formatTextDirty = !0
    },
    pushBackElement: function(a) {
        this._richElements.push(a);
        this._formatTextDirty = !0
    },
    removeElement: function(a) {
        cc.isNumber(a) ? this._richElements.splice(a, 1) : cc.arrayRemoveObject(this._richElements, a);
        this._formatTextDirty = !0
    },
    formatText: function() {
        if (this._formatTextDirty) {
            this._elementRenderersContainer.removeAllChildren();
            this._elementRenders.length = 0;
            var a, b, c = this._richElements;
            if (this._ignoreSize) {
                this._addNewLine();
                for (a = 0; a < c.length; a++) {
                    b = c[a];
                    var d = null;
                    switch (b._type) {
                        case ccui.RichElement.TEXT:
                            d = new cc.LabelTTF(b._text, b._fontName, b._fontSize);
                            break;
                        case ccui.RichElement.IMAGE:
                            d = new cc.Sprite(b._filePath);
                            break;
                        case ccui.RichElement.CUSTOM:
                            d = b._customNode
                    }
                    d.setColor(b._color);
                    d.setOpacity(b._color.a);
                    this._pushToContainer(d)
                }
            } else {
                this._addNewLine();
                for (a = 0; a < c.length; a++) switch (b = c[a], b._type) {
                    case ccui.RichElement.TEXT:
                        this._handleTextRenderer(b._text, b._fontName, b._fontSize, b._color);
                        break;
                    case ccui.RichElement.IMAGE:
                        this._handleImageRenderer(b._filePath,
                            b._color, b._color.a);
                        break;
                    case ccui.RichElement.CUSTOM:
                        this._handleCustomRenderer(b._customNode)
                }
            }
            this.formatRenderers();
            this._formatTextDirty = !1
        }
    },
    _handleTextRenderer: function(a, b, c, d) {
        var e = new cc.LabelTTF(a, b, c),
            f = e.getContentSize().width;
        this._leftSpaceWidth -= f;
        0 > this._leftSpaceWidth ? (e = a.length * (1 - -this._leftSpaceWidth / f), f = a.substr(0, e), a = a.substr(e, a.length - 1), 0 < e && (e = new cc.LabelTTF(f.substr(0, e), b, c), e.setColor(d), e.setOpacity(d.a), this._pushToContainer(e)), this._addNewLine(), this._handleTextRenderer(a,
            b, c, d)) : (e.setColor(d), e.setOpacity(d.a), this._pushToContainer(e))
    },
    _handleImageRenderer: function(a, b, c) {
        a = new cc.Sprite(a);
        this._handleCustomRenderer(a)
    },
    _handleCustomRenderer: function(a) {
        var b = a.getContentSize();
        this._leftSpaceWidth -= b.width;
        0 > this._leftSpaceWidth ? (this._addNewLine(), this._pushToContainer(a), this._leftSpaceWidth -= b.width) : this._pushToContainer(a)
    },
    _addNewLine: function() {
        this._leftSpaceWidth = this._customSize.width;
        this._elementRenders.push([])
    },
    formatRenderers: function() {
        var a = 0,
            b = this._elementRenderersContainer,
            c = this._elementRenders,
            d, e, f, g, h;
        if (this._ignoreSize) {
            d = 0;
            f = c[0];
            for (e = g = 0; e < f.length; e++) h = f[e], h.setAnchorPoint(cc.p(0, 0)), h.setPosition(g, 0), b.addChild(h, 1, e), h = h.getContentSize(), d += h.width, a = Math.max(a, h.height), g += h.width;
            b.setContentSize(d, a)
        } else {
            var k = [];
            for (d = 0; d < c.length; d++) {
                f = c[d];
                for (e = g = 0; e < f.length; e++) h = f[e], g = Math.max(h.getContentSize().height, g);
                k[d] = g;
                a += k[d]
            }
            a = this._customSize.height;
            for (d = 0; d < c.length; d++) {
                f = c[d];
                g = 0;
                a -= k[d] + this._verticalSpace;
                for (e = 0; e < f.length; e++) h = f[e], h.setAnchorPoint(cc.p(0, 0)), h.setPosition(cc.p(g, a)), b.addChild(h, 1), g += h.getContentSize().width
            }
            b.setContentSize(this._contentSize)
        }
        e = c.length;
        for (d = 0; d < e; d++) c[d].length = 0;
        this._elementRenders.length = 0;
        this.setContentSize(this._ignoreSize ? this.getVirtualRendererSize() : this._customSize);
        this._updateContentSizeWithTextureSize(this._contentSize);
        b.setPosition(0.5 * this._contentSize.width, 0.5 * this._contentSize.height)
    },
    _pushToContainer: function(a) {
        0 >= this._elementRenders.length ||
            this._elementRenders[this._elementRenders.length - 1].push(a)
    },
    visit: function(a) {
        this._enabled && (this.formatText(), ccui.Widget.prototype.visit.call(this, a))
    },
    setVerticalSpace: function(a) {
        this._verticalSpace = a
    },
    setAnchorPoint: function(a) {
        ccui.Widget.prototype.setAnchorPoint.call(this, a);
        this._elementRenderersContainer.setAnchorPoint(a)
    },
    _setAnchorX: function(a) {
        ccui.Widget.prototype._setAnchorX.call(this, a);
        this._elementRenderersContainer._setAnchorX(a)
    },
    _setAnchorY: function(a) {
        ccui.Widget.prototype._setAnchorY.call(this,
            a);
        this._elementRenderersContainer._setAnchorY(a)
    },
    getVirtualRendererSize: function() {
        return this._elementRenderersContainer.getContentSize()
    },
    ignoreContentAdaptWithSize: function(a) {
        this._ignoreSize != a && (this._formatTextDirty = !0, ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this, a))
    },
    getContentSize: function() {
        this.formatText();
        return cc.Node.prototype.getContentSize.call(this)
    },
    _getWidth: function() {
        this.formatText();
        return cc.Node.prototype._getWidth.call(this)
    },
    _getHeight: function() {
        this.formatText();
        return cc.Node.prototype._getHeight.call(this)
    },
    getDescription: function() {
        return "RichText"
    }
});
ccui.RichText.create = function() {
    return new ccui.RichText
};
ccui.RichElement.TEXT = 0;
ccui.RichElement.IMAGE = 1;
ccui.RichElement.CUSTOM = 2;
ccui.ScrollView = ccui.Layout.extend({
    _innerContainer: null,
    direction: null,
    _autoScrollDir: null,
    _topBoundary: 0,
    _bottomBoundary: 0,
    _leftBoundary: 0,
    _rightBoundary: 0,
    _bounceTopBoundary: 0,
    _bounceBottomBoundary: 0,
    _bounceLeftBoundary: 0,
    _bounceRightBoundary: 0,
    _autoScroll: !1,
    _autoScrollAddUpTime: 0,
    _autoScrollOriginalSpeed: 0,
    _autoScrollAcceleration: 0,
    _isAutoScrollSpeedAttenuated: !1,
    _needCheckAutoScrollDestination: !1,
    _autoScrollDestination: null,
    _bePressed: !1,
    _slidTime: 0,
    _moveChildPoint: null,
    _childFocusCancelOffset: 0,
    _leftBounceNeeded: !1,
    _topBounceNeeded: !1,
    _rightBounceNeeded: !1,
    _bottomBounceNeeded: !1,
    bounceEnabled: !1,
    _bouncing: !1,
    _bounceDir: null,
    _bounceOriginalSpeed: 0,
    inertiaScrollEnabled: !1,
    _scrollViewEventListener: null,
    _scrollViewEventSelector: null,
    _className: "ScrollView",
    ctor: function() {
        ccui.Layout.prototype.ctor.call(this);
        this.direction = ccui.ScrollView.DIR_NONE;
        this._autoScrollDir = cc.p(0, 0);
        this._autoScrollAcceleration = -1E3;
        this._autoScrollDestination = cc.p(0, 0);
        this._slidTime = 0;
        this._moveChildPoint = cc.p(0,
            0);
        this._childFocusCancelOffset = 5;
        this._bounceDir = cc.p(0, 0);
        this._bounceOriginalSpeed = 0;
        this.inertiaScrollEnabled = !0;
        this.setTouchEnabled(!0)
    },
    init: function() {
        return ccui.Layout.prototype.init.call(this) ? (this.setClippingEnabled(!0), this._innerContainer.setTouchEnabled(!1), !0) : !1
    },
    onEnter: function() {
        ccui.Layout.prototype.onEnter.call(this);
        this.scheduleUpdate(!0)
    },
    findNextFocusedWidget: function(a, b) {
        return this.getLayoutType() == ccui.Layout.LINEAR_VERTICAL || this.getLayoutType() == ccui.Layout.LINEAR_HORIZONTAL ?
            this._innerContainer.findNextFocusedWidget(a, b) : ccui.Widget.prototype.findNextFocusedWidget.call(this, a, b)
    },
    _initRenderer: function() {
        ccui.Layout.prototype._initRenderer.call(this);
        this._innerContainer = new ccui.Layout;
        this._innerContainer.setColor(cc.color(255, 255, 255));
        this._innerContainer.setOpacity(255);
        this._innerContainer.setCascadeColorEnabled(!0);
        this._innerContainer.setCascadeOpacityEnabled(!0);
        this.addProtectedChild(this._innerContainer, 1, 1)
    },
    _onSizeChanged: function() {
        ccui.Layout.prototype._onSizeChanged.call(this);
        var a = this._contentSize;
        this._topBoundary = a.height;
        this._rightBoundary = a.width;
        var b = a.width / 3,
            c = a.height / 3;
        this._bounceTopBoundary = a.height - c;
        this._bounceBottomBoundary = c;
        this._bounceLeftBoundary = b;
        this._bounceRightBoundary = a.width - b;
        b = this._innerContainer.getContentSize();
        this._innerContainer.setContentSize(cc.size(Math.max(b.width, a.width), Math.max(b.height, a.height)));
        this._innerContainer.setPosition(0, a.height - this._innerContainer.getContentSize().height)
    },
    setInnerContainerSize: function(a) {
        var b =
            this._innerContainer,
            c = this._contentSize,
            d = c.width,
            e = c.height,
            f = b.getContentSize();
        a.width < c.width ? cc.log("Inner width \x3c\x3d ScrollView width, it will be force sized!") : d = a.width;
        a.height < c.height ? cc.log("Inner height \x3c\x3d ScrollView height, it will be force sized!") : e = a.height;
        b.setContentSize(cc.size(d, e));
        switch (this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
                d = b.getContentSize();
                f = f.height - d.height;
                this._scrollChildren(0, f);
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                b.getRightBoundary() <=
                    c.width && (d = b.getContentSize(), f = f.width - d.width, this._scrollChildren(f, 0));
                break;
            case ccui.ScrollView.DIR_BOTH:
                d = b.getContentSize(), a = f.height - d.height, f = b.getRightBoundary() <= c.width ? f.width - d.width : 0, this._scrollChildren(f, a)
        }
        f = b.getContentSize();
        a = b.getPosition();
        d = b.getAnchorPoint();
        0 < b.getLeftBoundary() && b.setPosition(d.x * f.width, a.y);
        b.getRightBoundary() < c.width && b.setPosition(c.width - (1 - d.x) * f.width, a.y);
        0 < a.y && b.setPosition(a.x, d.y * f.height);
        b.getTopBoundary() < c.height && b.setPosition(a.x,
            c.height - (1 - d.y) * f.height)
    },
    _setInnerWidth: function(a) {
        var b = this._contentSize.width,
            c = b,
            d = this._innerContainer,
            e = d.width;
        a < b ? cc.log("Inner width \x3c\x3d scrollview width, it will be force sized!") : c = a;
        d.width = c;
        switch (this.direction) {
            case ccui.ScrollView.DIR_HORIZONTAL:
            case ccui.ScrollView.DIR_BOTH:
                d.getRightBoundary() <= b && this._scrollChildren(e - d.width, 0)
        }
        a = d.anchorX;
        0 < d.getLeftBoundary() && (d.x = a * c);
        d.getRightBoundary() < b && (d.x = b - (1 - a) * c)
    },
    _setInnerHeight: function(a) {
        var b = this._contentSize.height,
            c = b,
            d = this._innerContainer,
            e = d.height;
        a < b ? cc.log("Inner height \x3c\x3d scrollview height, it will be force sized!") : c = a;
        d.height = c;
        switch (this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
            case ccui.ScrollView.DIR_BOTH:
                this._scrollChildren(0, e - c)
        }
        a = d.anchorY;
        0 < d.getLeftBoundary() && (d.y = a * c);
        d.getRightBoundary() < b && (d.y = b - (1 - a) * c)
    },
    getInnerContainerSize: function() {
        return this._innerContainer.getContentSize()
    },
    _getInnerWidth: function() {
        return this._innerContainer.width
    },
    _getInnerHeight: function() {
        return this._innerContainer.height
    },
    addChild: function(a, b, c) {
        if (!a) return !1;
        b = b || a.getLocalZOrder();
        c = c || a.getTag();
        return this._innerContainer.addChild(a, b, c)
    },
    removeAllChildren: function() {
        this.removeAllChildrenWithCleanup(!0)
    },
    removeAllChildrenWithCleanup: function(a) {
        this._innerContainer.removeAllChildrenWithCleanup(a)
    },
    removeChild: function(a, b) {
        return this._innerContainer.removeChild(a, b)
    },
    getChildren: function() {
        return this._innerContainer.getChildren()
    },
    getChildrenCount: function() {
        return this._innerContainer.getChildrenCount()
    },
    getChildByTag: function(a) {
        return this._innerContainer.getChildByTag(a)
    },
    getChildByName: function(a) {
        return this._innerContainer.getChildByName(a)
    },
    _moveChildren: function(a, b) {
        var c = this._innerContainer;
        this._moveChildPoint.x = c.x + a;
        this._moveChildPoint.y = c.y + b;
        this._innerContainer.setPosition(this._moveChildPoint)
    },
    _autoScrollChildren: function(a) {
        var b = this._autoScrollAddUpTime;
        this._autoScrollAddUpTime += a;
        if (this._isAutoScrollSpeedAttenuated) 0 >= this._autoScrollOriginalSpeed + this._autoScrollAcceleration *
            this._autoScrollAddUpTime ? (this._stopAutoScrollChildren(), this._checkNeedBounce()) : (b = (this._autoScrollOriginalSpeed + 0.5 * this._autoScrollAcceleration * (2 * b + a)) * a, this._scrollChildren(b * this._autoScrollDir.x, b * this._autoScrollDir.y) || (this._stopAutoScrollChildren(), this._checkNeedBounce()));
        else if (this._needCheckAutoScrollDestination) {
            var b = this._autoScrollDir.x * a * this._autoScrollOriginalSpeed,
                c = this._autoScrollDir.y * a * this._autoScrollOriginalSpeed;
            a = this._checkCustomScrollDestination(b, c);
            b = this._scrollChildren(b,
                c);
            if (!a || !b) this._stopAutoScrollChildren(), this._checkNeedBounce()
        } else this._scrollChildren(this._autoScrollDir.x * a * this._autoScrollOriginalSpeed, this._autoScrollDir.y * a * this._autoScrollOriginalSpeed) || (this._stopAutoScrollChildren(), this._checkNeedBounce())
    },
    _bounceChildren: function(a) {
        var b = this._bounceOriginalSpeed,
            c = this._bounceDir;
        0 >= b && this._stopBounceChildren();
        this._bounceScrollChildren(c.x * a * b, c.y * a * b) || this._stopBounceChildren()
    },
    _checkNeedBounce: function() {
        if (!this.bounceEnabled) return !1;
        this._checkBounceBoundary();
        var a = this._topBounceNeeded,
            b = this._bottomBounceNeeded,
            c = this._leftBounceNeeded,
            d = this._rightBounceNeeded;
        if (a || b || c || d) {
            var e = this._contentSize,
                f = this._innerContainer;
            a && c ? (a = cc.pSub(cc.p(0, e.height), cc.p(f.getLeftBoundary(), f.getTopBoundary())), b = cc.pLength(a) / 0.2, this._bounceDir = cc.pNormalize(a), this._startBounceChildren(b)) : a && d ? (a = cc.pSub(cc.p(e.width, e.height), cc.p(f.getRightBoundary(), f.getTopBoundary())), b = cc.pLength(a) / 0.2, this._bounceDir = cc.pNormalize(a), this._startBounceChildren(b)) :
                b && c ? (a = cc.pSub(cc.p(0, 0), cc.p(f.getLeftBoundary(), f.getBottomBoundary())), b = cc.pLength(a) / 0.2, this._bounceDir = cc.pNormalize(a), this._startBounceChildren(b)) : b && d ? (a = cc.pSub(cc.p(e.width, 0), cc.p(f.getRightBoundary(), f.getBottomBoundary())), b = cc.pLength(a) / 0.2, this._bounceDir = cc.pNormalize(a), this._startBounceChildren(b)) : a ? (a = cc.pSub(cc.p(0, e.height), cc.p(0, f.getTopBoundary())), b = cc.pLength(a) / 0.2, this._bounceDir = cc.pNormalize(a), this._startBounceChildren(b)) : b ? (a = cc.pSub(cc.p(0, 0), cc.p(0, f.getBottomBoundary())),
                    b = cc.pLength(a) / 0.2, this._bounceDir = cc.pNormalize(a), this._startBounceChildren(b)) : c ? (a = cc.pSub(cc.p(0, 0), cc.p(f.getLeftBoundary(), 0)), b = cc.pLength(a) / 0.2, this._bounceDir = cc.pNormalize(a), this._startBounceChildren(b)) : d && (a = cc.pSub(cc.p(e.width, 0), cc.p(f.getRightBoundary(), 0)), b = cc.pLength(a) / 0.2, this._bounceDir = cc.pNormalize(a), this._startBounceChildren(b));
            return !0
        }
        return !1
    },
    _checkBounceBoundary: function() {
        var a = this._innerContainer;
        a.getBottomBoundary() > this._bottomBoundary ? (this._scrollToBottomEvent(),
            this._bottomBounceNeeded = !0) : this._bottomBounceNeeded = !1;
        a.getTopBoundary() < this._topBoundary ? (this._scrollToTopEvent(), this._topBounceNeeded = !0) : this._topBounceNeeded = !1;
        a.getRightBoundary() < this._rightBoundary ? (this._scrollToRightEvent(), this._rightBounceNeeded = !0) : this._rightBounceNeeded = !1;
        a.getLeftBoundary() > this._leftBoundary ? (this._scrollToLeftEvent(), this._leftBounceNeeded = !0) : this._leftBounceNeeded = !1
    },
    _startBounceChildren: function(a) {
        this._bounceOriginalSpeed = a;
        this._bouncing = !0
    },
    _stopBounceChildren: function() {
        this._bouncing = !1;
        this._bounceOriginalSpeed = 0;
        this._bottomBounceNeeded = this._topBounceNeeded = this._rightBounceNeeded = this._leftBounceNeeded = !1
    },
    _startAutoScrollChildrenWithOriginalSpeed: function(a, b, c, d) {
        this._stopAutoScrollChildren();
        this._autoScrollDir.x = a.x;
        this._autoScrollDir.y = a.y;
        this._isAutoScrollSpeedAttenuated = c;
        this._autoScrollOriginalSpeed = b;
        this._autoScroll = !0;
        this._autoScrollAcceleration = d
    },
    _startAutoScrollChildrenWithDestination: function(a, b, c) {
        this._needCheckAutoScrollDestination = !1;
        this._autoScrollDestination =
            a;
        var d = cc.pSub(a, this._innerContainer.getPosition());
        a = cc.pNormalize(d);
        var e = 0,
            f = -1E3,
            d = cc.pLength(d);
        c ? (f = -(2 * d) / (b * b), e = 2 * d / b) : (this._needCheckAutoScrollDestination = !0, e = d / b);
        this._startAutoScrollChildrenWithOriginalSpeed(a, e, c, f)
    },
    _jumpToDestination: function(a, b) {
        void 0 !== a.x && (b = a.y, a = a.x);
        var c = a,
            d = b;
        switch (this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
                0 >= b && (d = Math.max(b, this._contentSize.height - this._innerContainer.getContentSize().height));
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                0 >=
                    a && (c = Math.max(a, this._contentSize.width - this._innerContainer.getContentSize().width));
                break;
            case ccui.ScrollView.DIR_BOTH:
                0 >= b && (d = Math.max(b, this._contentSize.height - this._innerContainer.getContentSize().height)), 0 >= a && (c = Math.max(a, this._contentSize.width - this._innerContainer.getContentSize().width))
        }
        this._innerContainer.setPosition(c, d)
    },
    _stopAutoScrollChildren: function() {
        this._autoScroll = !1;
        this._autoScrollAddUpTime = this._autoScrollOriginalSpeed = 0
    },
    _bounceScrollChildren: function(a, b) {
        var c = !0,
            d, e, f, g;
        g = this._innerContainer;
        0 < a && 0 < b ? (d = a, e = b, f = g.getRightBoundary(), f + d >= this._rightBoundary && (d = this._rightBoundary - f, this._bounceRightEvent(), c = !1), g = g.getTopBoundary(), g + b >= this._topBoundary && (e = this._topBoundary - g, this._bounceTopEvent(), c = !1), this._moveChildren(d, e)) : 0 > a && 0 < b ? (d = a, e = b, f = g.getLeftBoundary(), f + d <= this._leftBoundary && (d = this._leftBoundary - f, this._bounceLeftEvent(), c = !1), g = g.getTopBoundary(), g + b >= this._topBoundary && (e = this._topBoundary - g, this._bounceTopEvent(), c = !1), this._moveChildren(d,
            e)) : 0 > a && 0 > b ? (d = a, e = b, f = g.getLeftBoundary(), f + d <= this._leftBoundary && (d = this._leftBoundary - f, this._bounceLeftEvent(), c = !1), g = g.getBottomBoundary(), g + b <= this._bottomBoundary && (e = this._bottomBoundary - g, this._bounceBottomEvent(), c = !1), this._moveChildren(d, e)) : 0 < a && 0 > b ? (d = a, e = b, f = g.getRightBoundary(), f + d >= this._rightBoundary && (d = this._rightBoundary - f, this._bounceRightEvent(), c = !1), g = g.getBottomBoundary(), g + b <= this._bottomBoundary && (e = this._bottomBoundary - g, this._bounceBottomEvent(), c = !1), this._moveChildren(d,
            e)) : 0 == a && 0 < b ? (e = b, g = g.getTopBoundary(), g + b >= this._topBoundary && (e = this._topBoundary - g, this._bounceTopEvent(), c = !1), this._moveChildren(0, e)) : 0 == a && 0 > b ? (e = b, g = g.getBottomBoundary(), g + b <= this._bottomBoundary && (e = this._bottomBoundary - g, this._bounceBottomEvent(), c = !1), this._moveChildren(0, e)) : 0 < a && 0 == b ? (d = a, f = g.getRightBoundary(), f + d >= this._rightBoundary && (d = this._rightBoundary - f, this._bounceRightEvent(), c = !1), this._moveChildren(d, 0)) : 0 > a && 0 == b && (d = a, e = g.getLeftBoundary(), e + d <= this._leftBoundary && (d =
            this._leftBoundary - e, this._bounceLeftEvent(), c = !1), this._moveChildren(d, 0));
        return c
    },
    _checkCustomScrollDestination: function(a, b) {
        var c = !0,
            d, e;
        d = this._innerContainer;
        var f = this._autoScrollDestination;
        switch (this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
                0 < this._autoScrollDir.y ? (d = d.getBottomBoundary(), d + b >= f.y && (c = !1)) : (d = d.getBottomBoundary(), d + b <= f.y && (c = !1));
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                0 < this._autoScrollDir.x ? (e = d.getLeftBoundary(), e + a >= f.x && (c = !1)) : (e = d.getLeftBoundary(), e + a <=
                    f.x && (c = !1));
                break;
            case ccui.ScrollView.DIR_BOTH:
                0 < a && 0 < b ? (e = d.getLeftBoundary(), e + a >= f.x && (c = !1), d = d.getBottomBoundary(), d + b >= f.y && (c = !1)) : 0 > a && 0 < b ? (e = d.getRightBoundary(), e + a <= f.x && (c = !1), d = d.getBottomBoundary(), d + b >= f.y && (c = !1)) : 0 > a && 0 > b ? (e = d.getRightBoundary(), e + a <= f.x && (c = !1), d = d.getTopBoundary(), d + b <= f.y && (c = !1)) : 0 < a && 0 > b ? (e = d.getLeftBoundary(), e + a >= f.x && (c = !1), d = d.getTopBoundary(), d + b <= f.y && (c = !1)) : 0 == a && 0 < b ? (d = d.getBottomBoundary(), d + b >= f.y && (c = !1)) : 0 > a && 0 == b ? (e = d.getRightBoundary(), e + a <=
                    f.x && (c = !1)) : 0 == a && 0 > b ? (d = d.getTopBoundary(), d + b <= f.y && (c = !1)) : 0 < a && 0 == b && (e = d.getLeftBoundary(), e + a >= f.x && (c = !1))
        }
        return c
    },
    _scrollChildren: function(a, b) {
        var c = !0;
        this._scrollingEvent();
        switch (this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
                c = this._scrollChildrenVertical(a, b);
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                c = this._scrollChildrenHorizontal(a, b);
                break;
            case ccui.ScrollView.DIR_BOTH:
                c = this._scrollChildrenBoth(a, b)
        }
        return c
    },
    _scrollChildrenVertical: function(a, b) {
        var c = b,
            d = !0,
            e, f = this._innerContainer;
        this.bounceEnabled ? (e = f.getBottomBoundary(), e + b >= this._bounceBottomBoundary && (c = this._bounceBottomBoundary - e, this._scrollToBottomEvent(), d = !1), e = f.getTopBoundary(), e + b <= this._bounceTopBoundary && (c = this._bounceTopBoundary - e, this._scrollToTopEvent(), d = !1)) : (e = f.getBottomBoundary(), e + b >= this._bottomBoundary && (c = this._bottomBoundary - e, this._scrollToBottomEvent(), d = !1), e = f.getTopBoundary(), e + b <= this._topBoundary && (c = this._topBoundary - e, this._scrollToTopEvent(), d = !1));
        this._moveChildren(0, c);
        return d
    },
    _scrollChildrenHorizontal: function(a, b) {
        var c = !0,
            d = a,
            e, f = this._innerContainer;
        this.bounceEnabled ? (e = f.getRightBoundary(), e + a <= this._bounceRightBoundary && (d = this._bounceRightBoundary - e, this._scrollToRightEvent(), c = !1), e = f.getLeftBoundary(), e + a >= this._bounceLeftBoundary && (d = this._bounceLeftBoundary - e, this._scrollToLeftEvent(), c = !1)) : (e = f.getRightBoundary(), e + a <= this._rightBoundary && (d = this._rightBoundary - e, this._scrollToRightEvent(), c = !1), e = f.getLeftBoundary(), e + a >= this._leftBoundary && (d = this._leftBoundary -
            e, this._scrollToLeftEvent(), c = !1));
        this._moveChildren(d, 0);
        return c
    },
    _scrollChildrenBoth: function(a, b) {
        var c = !0,
            d = a,
            e = b,
            f, g;
        g = this._innerContainer;
        this.bounceEnabled ? 0 < a && 0 < b ? (f = g.getLeftBoundary(), f + a >= this._bounceLeftBoundary && (d = this._bounceLeftBoundary - f, this._scrollToLeftEvent(), c = !1), g = g.getBottomBoundary(), g + b >= this._bounceBottomBoundary && (e = this._bounceBottomBoundary - g, this._scrollToBottomEvent(), c = !1)) : 0 > a && 0 < b ? (f = g.getRightBoundary(), f + a <= this._bounceRightBoundary && (d = this._bounceRightBoundary -
            f, this._scrollToRightEvent(), c = !1), g = g.getBottomBoundary(), g + b >= this._bounceBottomBoundary && (e = this._bounceBottomBoundary - g, this._scrollToBottomEvent(), c = !1)) : 0 > a && 0 > b ? (f = g.getRightBoundary(), f + a <= this._bounceRightBoundary && (d = this._bounceRightBoundary - f, this._scrollToRightEvent(), c = !1), g = g.getTopBoundary(), g + b <= this._bounceTopBoundary && (e = this._bounceTopBoundary - g, this._scrollToTopEvent(), c = !1)) : 0 < a && 0 > b ? (f = g.getLeftBoundary(), f + a >= this._bounceLeftBoundary && (d = this._bounceLeftBoundary - f, this._scrollToLeftEvent(),
            c = !1), g = g.getTopBoundary(), g + b <= this._bounceTopBoundary && (e = this._bounceTopBoundary - g, this._scrollToTopEvent(), c = !1)) : 0 == a && 0 < b ? (g = g.getBottomBoundary(), g + b >= this._bounceBottomBoundary && (e = this._bounceBottomBoundary - g, this._scrollToBottomEvent(), c = !1)) : 0 > a && 0 == b ? (f = g.getRightBoundary(), f + a <= this._bounceRightBoundary && (d = this._bounceRightBoundary - f, this._scrollToRightEvent(), c = !1)) : 0 == a && 0 > b ? (g = g.getTopBoundary(), g + b <= this._bounceTopBoundary && (e = this._bounceTopBoundary - g, this._scrollToTopEvent(), c = !1)) : 0 < a && 0 == b && (f = g.getLeftBoundary(), f + a >= this._bounceLeftBoundary && (d = this._bounceLeftBoundary - f, this._scrollToLeftEvent(), c = !1)) : 0 < a && 0 < b ? (f = g.getLeftBoundary(), f + a >= this._leftBoundary && (d = this._leftBoundary - f, this._scrollToLeftEvent(), c = !1), g = g.getBottomBoundary(), g + b >= this._bottomBoundary && (e = this._bottomBoundary - g, this._scrollToBottomEvent(), c = !1)) : 0 > a && 0 < b ? (f = g.getRightBoundary(), f + a <= this._rightBoundary && (d = this._rightBoundary - f, this._scrollToRightEvent(), c = !1), g = g.getBottomBoundary(), g +
            b >= this._bottomBoundary && (e = this._bottomBoundary - g, this._scrollToBottomEvent(), c = !1)) : 0 > a && 0 > b ? (f = g.getRightBoundary(), f + a <= this._rightBoundary && (d = this._rightBoundary - f, this._scrollToRightEvent(), c = !1), g = g.getTopBoundary(), g + b <= this._topBoundary && (e = this._topBoundary - g, this._scrollToTopEvent(), c = !1)) : 0 < a && 0 > b ? (f = g.getLeftBoundary(), f + a >= this._leftBoundary && (d = this._leftBoundary - f, this._scrollToLeftEvent(), c = !1), g = this._innerContainer.getTopBoundary(), g + b <= this._topBoundary && (e = this._topBoundary -
            g, this._scrollToTopEvent(), c = !1)) : 0 == a && 0 < b ? (g = this._innerContainer.getBottomBoundary(), g + b >= this._bottomBoundary && (e = this._bottomBoundary - g, this._scrollToBottomEvent(), c = !1)) : 0 > a && 0 == b ? (f = this._innerContainer.getRightBoundary(), f + a <= this._rightBoundary && (d = this._rightBoundary - f, this._scrollToRightEvent(), c = !1)) : 0 == a && 0 > b ? (g = this._innerContainer.getTopBoundary(), g + b <= this._topBoundary && (e = this._topBoundary - g, this._scrollToTopEvent(), c = !1)) : 0 < a && 0 == b && (f = this._innerContainer.getLeftBoundary(), f + a >=
            this._leftBoundary && (d = this._leftBoundary - f, this._scrollToLeftEvent(), c = !1));
        this._moveChildren(d, e);
        return c
    },
    scrollToBottom: function(a, b) {
        this._startAutoScrollChildrenWithDestination(cc.p(this._innerContainer.getPositionX(), 0), a, b)
    },
    scrollToTop: function(a, b) {
        this._startAutoScrollChildrenWithDestination(cc.p(this._innerContainer.getPositionX(), this._contentSize.height - this._innerContainer.getContentSize().height), a, b)
    },
    scrollToLeft: function(a, b) {
        this._startAutoScrollChildrenWithDestination(cc.p(0,
            this._innerContainer.getPositionY()), a, b)
    },
    scrollToRight: function(a, b) {
        this._startAutoScrollChildrenWithDestination(cc.p(this._contentSize.width - this._innerContainer.getContentSize().width, this._innerContainer.getPositionY()), a, b)
    },
    scrollToTopLeft: function(a, b) {
        this.direction != ccui.ScrollView.DIR_BOTH ? cc.log("Scroll direction is not both!") : this._startAutoScrollChildrenWithDestination(cc.p(0, this._contentSize.height - this._innerContainer.getContentSize().height), a, b)
    },
    scrollToTopRight: function(a, b) {
        if (this.direction !=
            ccui.ScrollView.DIR_BOTH) cc.log("Scroll direction is not both!");
        else {
            var c = this._innerContainer.getContentSize();
            this._startAutoScrollChildrenWithDestination(cc.p(this._contentSize.width - c.width, this._contentSize.height - c.height), a, b)
        }
    },
    scrollToBottomLeft: function(a, b) {
        this.direction != ccui.ScrollView.DIR_BOTH ? cc.log("Scroll direction is not both!") : this._startAutoScrollChildrenWithDestination(cc.p(0, 0), a, b)
    },
    scrollToBottomRight: function(a, b) {
        this.direction != ccui.ScrollView.DIR_BOTH ? cc.log("Scroll direction is not both!") :
            this._startAutoScrollChildrenWithDestination(cc.p(this._contentSize.width - this._innerContainer.getContentSize().width, 0), a, b)
    },
    scrollToPercentVertical: function(a, b, c) {
        var d = this._contentSize.height - this._innerContainer.getContentSize().height,
            e = -d;
        this._startAutoScrollChildrenWithDestination(cc.p(this._innerContainer.getPositionX(), d + a * e / 100), b, c)
    },
    scrollToPercentHorizontal: function(a, b, c) {
        var d = this._innerContainer.getContentSize().width - this._contentSize.width;
        this._startAutoScrollChildrenWithDestination(cc.p(-(a *
            d / 100), this._innerContainer.getPositionY()), b, c)
    },
    scrollToPercentBothDirection: function(a, b, c) {
        if (this.direction == ccui.ScrollView.DIR_BOTH) {
            var d = this._contentSize.height - this._innerContainer.getContentSize().height,
                e = -d,
                f = this._innerContainer.getContentSize().width - this._contentSize.width;
            this._startAutoScrollChildrenWithDestination(cc.p(-(a.x * f / 100), d + a.y * e / 100), b, c)
        }
    },
    jumpToBottom: function() {
        this._jumpToDestination(this._innerContainer.getPositionX(), 0)
    },
    jumpToTop: function() {
        this._jumpToDestination(this._innerContainer.getPositionX(),
            this._contentSize.height - this._innerContainer.getContentSize().height)
    },
    jumpToLeft: function() {
        this._jumpToDestination(0, this._innerContainer.getPositionY())
    },
    jumpToRight: function() {
        this._jumpToDestination(this._contentSize.width - this._innerContainer.getContentSize().width, this._innerContainer.getPositionY())
    },
    jumpToTopLeft: function() {
        this.direction != ccui.ScrollView.DIR_BOTH ? cc.log("Scroll direction is not both!") : this._jumpToDestination(0, this._contentSize.height - this._innerContainer.getContentSize().height)
    },
    jumpToTopRight: function() {
        if (this.direction != ccui.ScrollView.DIR_BOTH) cc.log("Scroll direction is not both!");
        else {
            var a = this._innerContainer.getContentSize();
            this._jumpToDestination(this._contentSize.width - a.width, this._contentSize.height - a.height)
        }
    },
    jumpToBottomLeft: function() {
        this.direction != ccui.ScrollView.DIR_BOTH ? cc.log("Scroll direction is not both!") : this._jumpToDestination(0, 0)
    },
    jumpToBottomRight: function() {
        this.direction != ccui.ScrollView.DIR_BOTH ? cc.log("Scroll direction is not both!") :
            this._jumpToDestination(this._contentSize.width - this._innerContainer.getContentSize().width, 0)
    },
    jumpToPercentVertical: function(a) {
        var b = this._contentSize.height - this._innerContainer.getContentSize().height,
            c = -b;
        this._jumpToDestination(this._innerContainer.getPositionX(), b + a * c / 100)
    },
    jumpToPercentHorizontal: function(a) {
        var b = this._innerContainer.getContentSize().width - this._contentSize.width;
        this._jumpToDestination(-(a * b / 100), this._innerContainer.getPositionY())
    },
    jumpToPercentBothDirection: function(a) {
        if (this.direction ==
            ccui.ScrollView.DIR_BOTH) {
            var b = this._innerContainer.getContentSize(),
                c = this._contentSize.height - b.height;
            this._jumpToDestination(-(a.x * (b.width - this._contentSize.width) / 100), c + a.y * -c / 100)
        }
    },
    _startRecordSlidAction: function() {
        this._autoScroll && this._stopAutoScrollChildren();
        this._bouncing && this._stopBounceChildren();
        this._slidTime = 0
    },
    _endRecordSlidAction: function() {
        if (!this._checkNeedBounce() && this.inertiaScrollEnabled && !(0.016 >= this._slidTime)) {
            var a = 0,
                b;
            switch (this.direction) {
                case ccui.ScrollView.DIR_VERTICAL:
                    a =
                        this._touchEndPosition.y - this._touchBeganPosition.y;
                    b = 0 > a ? ccui.ScrollView.SCROLLDIR_DOWN : ccui.ScrollView.SCROLLDIR_UP;
                    break;
                case ccui.ScrollView.DIR_HORIZONTAL:
                    a = this._touchEndPosition.x - this._touchBeganPosition.x;
                    b = 0 > a ? ccui.ScrollView.SCROLLDIR_LEFT : ccui.ScrollView.SCROLLDIR_RIGHT;
                    break;
                case ccui.ScrollView.DIR_BOTH:
                    b = cc.pSub(this._touchEndPosition, this._touchBeganPosition), a = cc.pLength(b), b = cc.pNormalize(b)
            }
            a = Math.min(Math.abs(a) / this._slidTime, ccui.ScrollView.AUTO_SCROLL_MAX_SPEED);
            this._startAutoScrollChildrenWithOriginalSpeed(b,
                a, !0, -1E3);
            this._slidTime = 0
        }
    },
    _handlePressLogic: function(a) {
        this._startRecordSlidAction();
        this._bePressed = !0
    },
    _handleMoveLogic: function(a) {
        a = cc.pSub(a.getLocation(), a.getPreviousLocation());
        switch (this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
                this._scrollChildren(0, a.y);
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                this._scrollChildren(a.x, 0);
                break;
            case ccui.ScrollView.DIR_BOTH:
                this._scrollChildren(a.x, a.y)
        }
    },
    _handleReleaseLogic: function(a) {
        this._endRecordSlidAction();
        this._bePressed = !1
    },
    onTouchBegan: function(a,
        b) {
        var c = ccui.Layout.prototype.onTouchBegan.call(this, a, b);
        this._isInterceptTouch || this._hit && this._handlePressLogic(a);
        return c
    },
    onTouchMoved: function(a, b) {
        ccui.Layout.prototype.onTouchMoved.call(this, a, b);
        this._isInterceptTouch || this._handleMoveLogic(a)
    },
    onTouchEnded: function(a, b) {
        ccui.Layout.prototype.onTouchEnded.call(this, a, b);
        this._isInterceptTouch || this._handleReleaseLogic(a);
        this._isInterceptTouch = !1
    },
    onTouchCancelled: function(a, b) {
        ccui.Layout.prototype.onTouchCancelled.call(this, a, b);
        this._isInterceptTouch ||
            this.handleReleaseLogic(a);
        this._isInterceptTouch = !1
    },
    update: function(a) {
        this._autoScroll && this._autoScrollChildren(a);
        this._bouncing && this._bounceChildren(a);
        this._recordSlidTime(a)
    },
    _recordSlidTime: function(a) {
        this._bePressed && (this._slidTime += a)
    },
    interceptTouchEvent: function(a, b, c) {
        var d = c.getLocation();
        switch (a) {
            case ccui.Widget.TOUCH_BEGAN:
                this._isInterceptTouch = !0;
                this._touchBeganPosition.x = d.x;
                this._touchBeganPosition.y = d.y;
                this._handlePressLogic(c);
                break;
            case ccui.Widget.TOUCH_MOVED:
                cc.pLength(cc.pSub(b.getTouchBeganPosition(),
                    d)) > this._childFocusCancelOffset && (b.setHighlighted(!1), this._touchMovePosition.x = d.x, this._touchMovePosition.y = d.y, this._handleMoveLogic(c));
                break;
            case ccui.Widget.TOUCH_CANCELED:
            case ccui.Widget.TOUCH_ENDED:
                this._touchEndPosition.x = d.x, this._touchEndPosition.y = d.y, this._handleReleaseLogic(c), b.isSwallowTouches() && (this._isInterceptTouch = !1)
        }
    },
    _scrollToTopEvent: function() {
        this._scrollViewEventSelector && (this._scrollViewEventListener ? this._scrollViewEventSelector.call(this._scrollViewEventListener,
            this, ccui.ScrollView.EVENT_SCROLL_TO_TOP) : this._scrollViewEventSelector(this, ccui.ScrollView.EVENT_SCROLL_TO_TOP))
    },
    _scrollToBottomEvent: function() {
        this._scrollViewEventSelector && (this._scrollViewEventListener ? this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_SCROLL_TO_BOTTOM) : this._scrollViewEventSelector(this, ccui.ScrollView.EVENT_SCROLL_TO_BOTTOM))
    },
    _scrollToLeftEvent: function() {
        this._scrollViewEventSelector && (this._scrollViewEventListener ? this._scrollViewEventSelector.call(this._scrollViewEventListener,
            this, ccui.ScrollView.EVENT_SCROLL_TO_LEFT) : this._scrollViewEventSelector(this, ccui.ScrollView.EVENT_SCROLL_TO_LEFT))
    },
    _scrollToRightEvent: function() {
        this._scrollViewEventSelector && (this._scrollViewEventListener ? this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_SCROLL_TO_RIGHT) : this._scrollViewEventSelector(this, ccui.ScrollView.EVENT_SCROLL_TO_RIGHT))
    },
    _scrollingEvent: function() {
        this._scrollViewEventSelector && (this._scrollViewEventListener ? this._scrollViewEventSelector.call(this._scrollViewEventListener,
            this, ccui.ScrollView.EVENT_SCROLLING) : this._scrollViewEventSelector(this, ccui.ScrollView.EVENT_SCROLLING))
    },
    _bounceTopEvent: function() {
        this._scrollViewEventSelector && (this._scrollViewEventListener ? this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_BOUNCE_TOP) : this._scrollViewEventSelector(this, ccui.ScrollView.EVENT_BOUNCE_TOP))
    },
    _bounceBottomEvent: function() {
        this._scrollViewEventSelector && (this._scrollViewEventListener ? this._scrollViewEventSelector.call(this._scrollViewEventListener,
            this, ccui.ScrollView.EVENT_BOUNCE_BOTTOM) : this._scrollViewEventSelector(this, ccui.ScrollView.EVENT_BOUNCE_BOTTOM))
    },
    _bounceLeftEvent: function() {
        this._scrollViewEventSelector && (this._scrollViewEventListener ? this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_BOUNCE_LEFT) : this._scrollViewEventSelector(this, ccui.ScrollView.EVENT_BOUNCE_LEFT))
    },
    _bounceRightEvent: function() {
        this._scrollViewEventSelector && (this._scrollViewEventListener ? this._scrollViewEventSelector.call(this._scrollViewEventListener,
            this, ccui.ScrollView.EVENT_BOUNCE_RIGHT) : this._scrollViewEventSelector(this, ccui.ScrollView.EVENT_BOUNCE_RIGHT))
    },
    addEventListenerScrollView: function(a, b) {
        this.addEventListener(a, b)
    },
    addEventListener: function(a, b) {
        this._scrollViewEventSelector = a;
        this._scrollViewEventListener = b
    },
    setDirection: function(a) {
        this.direction = a
    },
    getDirection: function() {
        return this.direction
    },
    setBounceEnabled: function(a) {
        this.bounceEnabled = a
    },
    isBounceEnabled: function() {
        return this.bounceEnabled
    },
    setInertiaScrollEnabled: function(a) {
        this.inertiaScrollEnabled =
            a
    },
    isInertiaScrollEnabled: function() {
        return this.inertiaScrollEnabled
    },
    getInnerContainer: function() {
        return this._innerContainer
    },
    setLayoutType: function(a) {
        this._innerContainer.setLayoutType(a)
    },
    getLayoutType: function() {
        return this._innerContainer.getLayoutType()
    },
    _doLayout: function() {
        this._doLayoutDirty && (this._doLayoutDirty = !1)
    },
    getDescription: function() {
        return "ScrollView"
    },
    _createCloneInstance: function() {
        return new ccui.ScrollView
    },
    _copyClonedWidgetChildren: function(a) {
        ccui.Layout.prototype._copyClonedWidgetChildren.call(this,
            a)
    },
    _copySpecialProperties: function(a) {
        a instanceof ccui.ScrollView && (ccui.Layout.prototype._copySpecialProperties.call(this, a), this.setInnerContainerSize(a.getInnerContainerSize()), this.setDirection(a.direction), this.setBounceEnabled(a.bounceEnabled), this.setInertiaScrollEnabled(a.inertiaScrollEnabled), this._scrollViewEventListener = a._scrollViewEventListener, this._scrollViewEventSelector = a._scrollViewEventSelector)
    },
    getNodeByTag: function(a) {
        return this._innerContainer.getNodeByTag(a)
    },
    getNodes: function() {
        return this._innerContainer.getNodes()
    },
    removeNode: function(a) {
        this._innerContainer.removeNode(a)
    },
    removeNodeByTag: function(a) {
        this._innerContainer.removeNodeByTag(a)
    },
    removeAllNodes: function() {
        this._innerContainer.removeAllNodes()
    },
    addNode: function(a, b, c) {
        this._innerContainer.addNode(a, b, c)
    },
    _transformForRenderer: function(a) {
        ccui.Layout.prototype._transformForRenderer.call(this, a);
        this._innerContainer && cc._renderType === cc._RENDER_TYPE_WEBGL && this._innerContainer._transformForRenderer(this._stackMatrix)
    }
});
_p = ccui.ScrollView.prototype;
cc.defineGetterSetter(_p, "innerWidth", _p._getInnerWidth, _p._setInnerWidth);
cc.defineGetterSetter(_p, "innerHeight", _p._getInnerHeight, _p._setInnerHeight);
_p = null;
ccui.ScrollView.create = function() {
    return new ccui.ScrollView
};
ccui.ScrollView.DIR_NONE = 0;
ccui.ScrollView.DIR_VERTICAL = 1;
ccui.ScrollView.DIR_HORIZONTAL = 2;
ccui.ScrollView.DIR_BOTH = 3;
ccui.ScrollView.EVENT_SCROLL_TO_TOP = 0;
ccui.ScrollView.EVENT_SCROLL_TO_BOTTOM = 1;
ccui.ScrollView.EVENT_SCROLL_TO_LEFT = 2;
ccui.ScrollView.EVENT_SCROLL_TO_RIGHT = 3;
ccui.ScrollView.EVENT_SCROLLING = 4;
ccui.ScrollView.EVENT_BOUNCE_TOP = 5;
ccui.ScrollView.EVENT_BOUNCE_BOTTOM = 6;
ccui.ScrollView.EVENT_BOUNCE_LEFT = 7;
ccui.ScrollView.EVENT_BOUNCE_RIGHT = 8;
ccui.ScrollView.AUTO_SCROLL_MAX_SPEED = 1E3;
ccui.ScrollView.SCROLLDIR_UP = cc.p(0, 1);
ccui.ScrollView.SCROLLDIR_DOWN = cc.p(0, -1);
ccui.ScrollView.SCROLLDIR_LEFT = cc.p(-1, 0);
ccui.ScrollView.SCROLLDIR_RIGHT = cc.p(1, 0);
ccui.ListView = ccui.ScrollView.extend({
    _model: null,
    _items: null,
    _gravity: null,
    _itemsMargin: 0,
    _curSelectedIndex: 0,
    _refreshViewDirty: !0,
    _listViewEventListener: null,
    _listViewEventSelector: null,
    ctor: function() {
        ccui.ScrollView.prototype.ctor.call(this);
        this._items = [];
        this._gravity = ccui.ListView.GRAVITY_CENTER_HORIZONTAL;
        this.setTouchEnabled(!0);
        this.init()
    },
    init: function() {
        return ccui.ScrollView.prototype.init.call(this) ? (this.setLayoutType(ccui.Layout.LINEAR_VERTICAL), !0) : !1
    },
    setItemModel: function(a) {
        a &&
            (this._model = a)
    },
    _updateInnerContainerSize: function() {
        var a = this._items,
            b, c;
        switch (this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
                b = a.length;
                var d = (b - 1) * this._itemsMargin;
                for (c = 0; c < b; c++) d += a[c].getContentSize().height;
                this.setInnerContainerSize(cc.size(this._contentSize.width, d));
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                b = a.length;
                d = (b - 1) * this._itemsMargin;
                for (c = 0; c < b; c++) d += a[c].getContentSize().width;
                this.setInnerContainerSize(cc.size(d, this._contentSize.height))
        }
    },
    _remedyLayoutParameter: function(a) {
        if (a) {
            var b;
            switch (this.direction) {
                case ccui.ScrollView.DIR_VERTICAL:
                    if (b = a.getLayoutParameter()) switch (0 == this.getIndex(a) ? b.setMargin(ccui.MarginZero()) : b.setMargin(new ccui.Margin(0, this._itemsMargin, 0, 0)), this._gravity) {
                        case ccui.ListView.GRAVITY_LEFT:
                            b.setGravity(ccui.LinearLayoutParameter.LEFT);
                            break;
                        case ccui.ListView.GRAVITY_RIGHT:
                            b.setGravity(ccui.LinearLayoutParameter.RIGHT);
                            break;
                        case ccui.ListView.GRAVITY_CENTER_HORIZONTAL:
                            b.setGravity(ccui.LinearLayoutParameter.CENTER_HORIZONTAL)
                    } else {
                        b = new ccui.LinearLayoutParameter;
                        switch (this._gravity) {
                            case ccui.ListView.GRAVITY_LEFT:
                                b.setGravity(ccui.LinearLayoutParameter.LEFT);
                                break;
                            case ccui.ListView.GRAVITY_RIGHT:
                                b.setGravity(ccui.LinearLayoutParameter.RIGHT);
                                break;
                            case ccui.ListView.GRAVITY_CENTER_HORIZONTAL:
                                b.setGravity(ccui.LinearLayoutParameter.CENTER_HORIZONTAL)
                        }
                        0 == this.getIndex(a) ? b.setMargin(ccui.MarginZero()) : b.setMargin(new ccui.Margin(0, this._itemsMargin, 0, 0));
                        a.setLayoutParameter(b)
                    }
                    break;
                case ccui.ScrollView.DIR_HORIZONTAL:
                    if (b = a.getLayoutParameter()) switch (0 ==
                        this.getIndex(a) ? b.setMargin(ccui.MarginZero()) : b.setMargin(new ccui.Margin(this._itemsMargin, 0, 0, 0)), this._gravity) {
                        case ccui.ListView.GRAVITY_TOP:
                            b.setGravity(ccui.LinearLayoutParameter.TOP);
                            break;
                        case ccui.ListView.GRAVITY_BOTTOM:
                            b.setGravity(ccui.LinearLayoutParameter.BOTTOM);
                            break;
                        case ccui.ListView.GRAVITY_CENTER_VERTICAL:
                            b.setGravity(ccui.LinearLayoutParameter.CENTER_VERTICAL)
                    } else {
                        b = new ccui.LinearLayoutParameter;
                        switch (this._gravity) {
                            case ccui.ListView.GRAVITY_TOP:
                                b.setGravity(ccui.LinearLayoutParameter.TOP);
                                break;
                            case ccui.ListView.GRAVITY_BOTTOM:
                                b.setGravity(ccui.LinearLayoutParameter.BOTTOM);
                                break;
                            case ccui.ListView.GRAVITY_CENTER_VERTICAL:
                                b.setGravity(ccui.LinearLayoutParameter.CENTER_VERTICAL)
                        }
                        0 == this.getIndex(a) ? b.setMargin(ccui.MarginZero()) : b.setMargin(new ccui.Margin(this._itemsMargin, 0, 0, 0));
                        a.setLayoutParameter(b)
                    }
            }
        }
    },
    pushBackDefaultItem: function() {
        if (this._model) {
            var a = this._model.clone();
            this._remedyLayoutParameter(a);
            this.addChild(a);
            this._refreshViewDirty = !0
        }
    },
    insertDefaultItem: function(a) {
        if (this._model) {
            var b =
                this._model.clone();
            this._items.splice(a, 0, b);
            ccui.ScrollView.prototype.addChild.call(this, b);
            this._remedyLayoutParameter(b);
            this._refreshViewDirty = !0
        }
    },
    pushBackCustomItem: function(a) {
        this._remedyLayoutParameter(a);
        this.addChild(a);
        this._refreshViewDirty = !0
    },
    addChild: function(a, b, c) {
        a && (b = b || a.getLocalZOrder(), c = c || a.getName(), ccui.ScrollView.prototype.addChild.call(this, a, b, c), a instanceof ccui.Widget && this._items.push(a))
    },
    removeChild: function(a, b) {
        if (a) {
            var c = this._items.indexOf(a); - 1 < c && this._items.splice(c,
                1);
            ccui.ScrollView.prototype.removeChild.call(this, a, b)
        }
    },
    removeAllChildren: function() {
        this.removeAllChildrenWithCleanup(!0)
    },
    removeAllChildrenWithCleanup: function(a) {
        ccui.ScrollView.prototype.removeAllChildrenWithCleanup.call(this, a);
        this._items = []
    },
    insertCustomItem: function(a, b) {
        this._items.splice(b, 0, a);
        ccui.ScrollView.prototype.addChild.call(this, a);
        this._remedyLayoutParameter(a);
        this._refreshViewDirty = !0
    },
    removeItem: function(a) {
        if (a = this.getItem(a)) this.removeChild(a, !0), this._refreshViewDirty = !0
    },
    removeLastItem: function() {
        this.removeItem(this._items.length - 1)
    },
    removeAllItems: function() {
        this.removeAllChildren()
    },
    getItem: function(a) {
        return 0 > a || a >= this._items.length ? null : this._items[a]
    },
    getItems: function() {
        return this._items
    },
    getIndex: function(a) {
        return this._items.indexOf(a)
    },
    setGravity: function(a) {
        this._gravity != a && (this._gravity = a, this._refreshViewDirty = !0)
    },
    setItemsMargin: function(a) {
        this._itemsMargin != a && (this._itemsMargin = a, this._refreshViewDirty = !0)
    },
    getItemsMargin: function() {
        return this._itemsMargin
    },
    setDirection: function(a) {
        switch (a) {
            case ccui.ScrollView.DIR_VERTICAL:
                this.setLayoutType(ccui.Layout.LINEAR_VERTICAL);
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                this.setLayoutType(ccui.Layout.LINEAR_HORIZONTAL);
                break;
            case ccui.ScrollView.DIR_BOTH:
                return;
            default:
                return
        }
        ccui.ScrollView.prototype.setDirection.call(this, a)
    },
    requestRefreshView: function() {
        this._refreshViewDirty = !0
    },
    refreshView: function() {
        for (var a = this._items, b = 0; b < a.length; b++) {
            var c = a[b];
            c.setLocalZOrder(b);
            this._remedyLayoutParameter(c)
        }
        this._updateInnerContainerSize()
    },
    doLayout: function() {
        this._doLayout()
    },
    _doLayout: function() {
        ccui.Layout.prototype._doLayout.call(this);
        this._refreshViewDirty && (this.refreshView(), this._refreshViewDirty = !1)
    },
    addEventListenerListView: function(a, b) {
        this.addEventListener(a, b)
    },
    addEventListener: function(a, b) {
        this._listViewEventListener = b;
        this._listViewEventSelector = a
    },
    _selectedItemEvent: function(a) {
        a = a == ccui.Widget.TOUCH_BEGAN ? ccui.ListView.ON_SELECTED_ITEM_START : ccui.ListView.ON_SELECTED_ITEM_END;
        this._listViewEventSelector && (this._listViewEventListener ?
            this._listViewEventSelector.call(this._listViewEventListener, this, a) : this._listViewEventSelector(this, a))
    },
    interceptTouchEvent: function(a, b, c) {
        ccui.ScrollView.prototype.interceptTouchEvent.call(this, a, b, c);
        if (a != ccui.Widget.TOUCH_MOVED) {
            for (c = b; c;) {
                if (c && c.getParent() == this._innerContainer) {
                    this._curSelectedIndex = this.getIndex(c);
                    break
                }
                c = c.getParent()
            }
            b.isHighlighted() && this._selectedItemEvent(a)
        }
    },
    getCurSelectedIndex: function() {
        return this._curSelectedIndex
    },
    _onSizeChanged: function() {
        ccui.ScrollView.prototype._onSizeChanged.call(this);
        this._refreshViewDirty = !0
    },
    getDescription: function() {
        return "ListView"
    },
    _createCloneInstance: function() {
        return new ccui.ListView
    },
    _copyClonedWidgetChildren: function(a) {
        a = a.getItems();
        for (var b = 0; b < a.length; b++) this.pushBackCustomItem(a[b].clone())
    },
    _copySpecialProperties: function(a) {
        a instanceof ccui.ListView && (ccui.ScrollView.prototype._copySpecialProperties.call(this, a), this.setItemModel(a._model), this.setItemsMargin(a._itemsMargin), this.setGravity(a._gravity), this._listViewEventListener = a._listViewEventListener,
            this._listViewEventSelector = a._listViewEventSelector)
    }
});
ccui.ListView.create = function() {
    return new ccui.ListView
};
ccui.ListView.EVENT_SELECTED_ITEM = 0;
ccui.ListView.ON_SELECTED_ITEM_START = 0;
ccui.ListView.ON_SELECTED_ITEM_END = 1;
ccui.ListView.GRAVITY_LEFT = 0;
ccui.ListView.GRAVITY_RIGHT = 1;
ccui.ListView.GRAVITY_CENTER_HORIZONTAL = 2;
ccui.ListView.GRAVITY_TOP = 3;
ccui.ListView.GRAVITY_BOTTOM = 4;
ccui.ListView.GRAVITY_CENTER_VERTICAL = 5;
ccui.PageView = ccui.Layout.extend({
    _curPageIdx: 0,
    _pages: null,
    _touchMoveDirection: null,
    _touchStartLocation: 0,
    _touchMoveStartLocation: 0,
    _movePagePoint: null,
    _leftBoundaryChild: null,
    _rightBoundaryChild: null,
    _leftBoundary: 0,
    _rightBoundary: 0,
    _isAutoScrolling: !1,
    _autoScrollDistance: 0,
    _autoScrollSpeed: 0,
    _autoScrollDirection: 0,
    _childFocusCancelOffset: 0,
    _pageViewEventListener: null,
    _pageViewEventSelector: null,
    _className: "PageView",
    _customScrollThreshold: 0,
    _usingCustomScrollThreshold: !1,
    ctor: function() {
        ccui.Layout.prototype.ctor.call(this);
        this._pages = [];
        this._touchMoveDirection = ccui.PageView.TOUCH_DIR_LEFT;
        this._rightBoundaryChild = this._leftBoundaryChild = this._movePagePoint = null;
        this._childFocusCancelOffset = 5;
        this._pageViewEventSelector = this._pageViewEventListener = null;
        this.setTouchEnabled(!0)
    },
    init: function() {
        return ccui.Layout.prototype.init.call(this) ? (this.setClippingEnabled(!0), !0) : !1
    },
    onEnter: function() {
        ccui.Layout.prototype.onEnter.call(this);
        this.scheduleUpdate(!0)
    },
    addWidgetToPage: function(a, b, c) {
        if (a && !(0 > b)) {
            var d = this._getPageCount();
            0 > b || b >= d ? c && (b > d && cc.log("pageIdx is %d, it will be added as page id [%d]", b, d), b = this._createPage(), b.addChild(a), this.addPage(b)) : (b = this._pages[b]) && b.addChild(a)
        }
    },
    _createPage: function() {
        var a = new ccui.Layout;
        a.setContentSize(this.getContentSize());
        return a
    },
    addPage: function(a) {
        a && -1 == this._pages.indexOf(a) && (this.addChild(a), this._pages.push(a), this._doLayoutDirty = !0)
    },
    insertPage: function(a, b) {
        if (!(0 > b || !a || -1 != this._pages.indexOf(a))) {
            var c = this._getPageCount();
            b >= c ? this.addPage(a) : (this._pages[b] =
                a, this.addChild(a));
            this._doLayoutDirty = !0
        }
    },
    removePage: function(a) {
        a && (this.removeChild(a), a = this._pages.indexOf(a), -1 < a && this._pages.splice(a, 1), this._doLayoutDirty = !0)
    },
    removePageAtIndex: function(a) {
        0 > a || a >= this._pages.length || (a = this._pages[a]) && this.removePage(a)
    },
    removeAllPages: function() {
        for (var a = this._pages, b = 0, c = a.length; b < c; b++) this.removeChild(a[b]);
        this._pages.length = 0
    },
    _updateBoundaryPages: function() {
        var a = this._pages;
        0 >= a.length ? this._rightBoundaryChild = this._leftBoundaryChild = null :
            (this._leftBoundaryChild = a[0], this._rightBoundaryChild = a[a.length - 1])
    },
    _getPageCount: function() {
        return this._pages.length
    },
    _getPositionXByIndex: function(a) {
        return this.getContentSize().width * (a - this._curPageIdx)
    },
    _onSizeChanged: function() {
        ccui.Layout.prototype._onSizeChanged.call(this);
        this._rightBoundary = this.getContentSize().width;
        this._doLayoutDirty = !0
    },
    _updateAllPagesSize: function() {
        for (var a = this.getContentSize(), b = this._pages, c = 0, d = b.length; c < d; c++) b[c].setContentSize(a)
    },
    _updateAllPagesPosition: function() {
        var a =
            this._getPageCount();
        if (0 >= a) this._curPageIdx = 0;
        else {
            this._curPageIdx >= a && (this._curPageIdx = a - 1);
            for (var b = this.getContentSize().width, c = this._pages, d = 0; d < a; d++) c[d].setPosition(cc.p((d - this._curPageIdx) * b, 0))
        }
    },
    scrollToPage: function(a) {
        0 > a || a >= this._pages.length || (this._curPageIdx = a, this._autoScrollDistance = -this._pages[a].getPosition().x, this._autoScrollSpeed = Math.abs(this._autoScrollDistance) / 0.2, this._autoScrollDirection = 0 < this._autoScrollDistance ? ccui.PageView.DIRECTION_RIGHT : ccui.PageView.DIRECTION_LEFT,
            this._isAutoScrolling = !0)
    },
    update: function(a) {
        this._isAutoScrolling && this._autoScroll(a)
    },
    setLayoutType: function(a) {},
    getLayoutType: function() {
        return ccui.Layout.ABSOLUTE
    },
    _autoScroll: function(a) {
        switch (this._autoScrollDirection) {
            case ccui.PageView.DIRECTION_LEFT:
                a *= this._autoScrollSpeed;
                0 <= this._autoScrollDistance + a ? (a = -this._autoScrollDistance, this._autoScrollDistance = 0, this._isAutoScrolling = !1) : this._autoScrollDistance += a;
                this._scrollPages(-a);
                this._isAutoScrolling || this._pageTurningEvent();
                break;
            case ccui.PageView.DIRECTION_RIGHT:
                a *= this._autoScrollSpeed, 0 >= this._autoScrollDistance - a ? (a = this._autoScrollDistance, this._autoScrollDistance = 0, this._isAutoScrolling = !1) : this._autoScrollDistance -= a, this._scrollPages(a), this._isAutoScrolling || this._pageTurningEvent()
        }
    },
    onTouchMoved: function(a, b) {
        ccui.Layout.prototype.onTouchMoved.call(this, a, b);
        this._isInterceptTouch || this._handleMoveLogic(a)
    },
    onTouchEnded: function(a, b) {
        ccui.Layout.prototype.onTouchEnded.call(this, a, b);
        this._isInterceptTouch || this._handleReleaseLogic(a);
        this._isInterceptTouch = !1
    },
    onTouchCancelled: function(a, b) {
        ccui.Layout.prototype.onTouchCancelled.call(this, a, b);
        this._isInterceptTouch || this.handleReleaseLogic(a);
        this._isInterceptTouch = !1
    },
    _doLayout: function() {
        this._doLayoutDirty && (this._updateAllPagesPosition(), this._updateAllPagesSize(), this._updateBoundaryPages(), this._doLayoutDirty = !1)
    },
    _movePages: function(a) {
        for (var b = this._pages, c = b.length, d = 0; d < c; d++) {
            var e = b[d];
            e.setPositionX(e.getPositionX() + a)
        }
    },
    _scrollPages: function(a) {
        if (0 >= this._pages.length ||
            !this._leftBoundaryChild || !this._rightBoundaryChild) return !1;
        var b = a;
        switch (this._touchMoveDirection) {
            case ccui.PageView.TOUCH_DIR_LEFT:
                var c = this._rightBoundaryChild.getRightBoundary();
                if (c + a <= this._rightBoundary) return b = this._rightBoundary - c, this._movePages(b), !1;
                break;
            case ccui.PageView.TOUCH_DIR_RIGHT:
                if (c = this._leftBoundaryChild.getLeftBoundary(), c + a >= this._leftBoundary) return b = this._leftBoundary - c, this._movePages(b), !1
        }
        this._movePages(b);
        return !0
    },
    _handleMoveLogic: function(a) {
        a = a.getLocation().x -
            a.getPreviousLocation().x;
        0 > a ? this._touchMoveDirection = ccui.PageView.TOUCH_DIR_LEFT : 0 < a && (this._touchMoveDirection = ccui.PageView.TOUCH_DIR_RIGHT);
        this._scrollPages(a)
    },
    setCustomScrollThreshold: function(a) {
        cc.assert(0 < a, "Invalid threshold!");
        this._customScrollThreshold = a;
        this.setUsingCustomScrollThreshold(!0)
    },
    getCustomScrollThreshold: function() {
        return this._customScrollThreshold
    },
    setUsingCustomScrollThreshold: function(a) {
        this._usingCustomScrollThreshold = a
    },
    isUsingCustomScrollThreshold: function() {
        return this._usingCustomScrollThreshold
    },
    _handleReleaseLogic: function(a) {
        if (!(0 >= this._pages.length) && (a = this._pages[this._curPageIdx])) {
            var b = a.getPosition();
            a = this._pages.length;
            var b = b.x,
                c = this.getSize().width;
            this._usingCustomScrollThreshold || (this._customScrollThreshold = c / 2);
            c = this._customScrollThreshold;
            b <= -c ? this._curPageIdx >= a - 1 ? this._scrollPages(-b) : this.scrollToPage(this._curPageIdx + 1) : b >= c ? 0 >= this._curPageIdx ? this._scrollPages(-b) : this.scrollToPage(this._curPageIdx - 1) : this.scrollToPage(this._curPageIdx)
        }
    },
    interceptTouchEvent: function(a,
        b, c) {
        var d = c.getLocation();
        switch (a) {
            case ccui.Widget.TOUCH_BEGAN:
                this._touchBeganPosition.x = d.x;
                this._touchBeganPosition.y = d.y;
                this._isInterceptTouch = !0;
                break;
            case ccui.Widget.TOUCH_MOVED:
                this._touchMovePosition.x = d.x;
                this._touchMovePosition.y = d.y;
                a = 0;
                a = Math.abs(b.getTouchBeganPosition().x - d.x);
                a > this._childFocusCancelOffset && (b.setFocused(!1), this._handleMoveLogic(c));
                break;
            case ccui.Widget.TOUCH_ENDED:
            case ccui.Widget.TOUCH_CANCELED:
                this._touchEndPosition.x = d.x, this._touchEndPosition.y = d.y, this._handleReleaseLogic(c),
                    b.isSwallowTouches() && (this._isInterceptTouch = !1)
        }
    },
    _pageTurningEvent: function() {
        this._pageViewEventSelector && (this._pageViewEventListener ? this._pageViewEventSelector.call(this._pageViewEventListener, this, ccui.PageView.EVENT_TURNING) : this._pageViewEventSelector(this, ccui.PageView.EVENT_TURNING))
    },
    addEventListenerPageView: function(a, b) {
        this.addEventListener(a, b)
    },
    addEventListener: function(a, b) {
        this._pageViewEventSelector = a;
        this._pageViewEventListener = b
    },
    getCurPageIndex: function() {
        return this._curPageIdx
    },
    getPages: function() {
        return this._pages
    },
    getPage: function(a) {
        return 0 > a || a >= this.getPages().size() ? null : this._pages[a]
    },
    getDescription: function() {
        return "PageView"
    },
    _createCloneInstance: function() {
        return new ccui.PageView
    },
    _copyClonedWidgetChildren: function(a) {
        a = a.getPages();
        for (var b = 0; b < a.length; b++) this.addPage(a[b].clone())
    },
    _copySpecialProperties: function(a) {
        ccui.Layout.prototype._copySpecialProperties.call(this, a);
        this._pageViewEventListener = a._pageViewEventListener;
        this._pageViewEventSelector =
            a._pageViewEventSelector;
        this._usingCustomScrollThreshold = a._usingCustomScrollThreshold;
        this._customScrollThreshold = a._customScrollThreshold
    }
});
ccui.PageView.create = function() {
    return new ccui.PageView
};
ccui.PageView.EVENT_TURNING = 0;
ccui.PageView.TOUCH_DIR_LEFT = 0;
ccui.PageView.TOUCH_DIR_RIGHT = 1;
ccui.PageView.DIRECTION_LEFT = 0;
ccui.PageView.DIRECTION_RIGHT = 1;
if (cc.sys._supportWebAudio) {
    var _ctx = cc.webAudioContext = new(window.AudioContext || window.webkitAudioContext || window.mozAudioContext);
    cc.WebAudio = cc.Class.extend({
        _events: null,
        _buffer: null,
        _sourceNode: null,
        _volumeNode: null,
        src: null,
        preload: null,
        autoplay: null,
        controls: null,
        mediagroup: null,
        currentTime: 0,
        startTime: 0,
        duration: 0,
        _loop: null,
        _volume: 1,
        _pauseTime: 0,
        _paused: !1,
        _stopped: !0,
        _loadState: -1,
        ctor: function(a) {
            this._events = {};
            this.src = a;
            this._volumeNode = _ctx.createGain ? _ctx.createGain() : _ctx.createGainNode();
            this._onSuccess1 = this._onSuccess.bind(this);
            this._onError1 = this._onError.bind(this)
        },
        _play: function(a) {
            var b = this._sourceNode = _ctx.createBufferSource(),
                c = this._volumeNode;
            a = a || 0;
            b.buffer = this._buffer;
            c.gain.value = this._volume;
            b.connect(c);
            c.connect(_ctx.destination);
            b.loop = this._loop;
            b._stopped = !1;
            b.playbackState || (b.onended = function() {
                this._stopped = !0
            });
            this._stopped = this._paused = !1;
            b.start ? b.start(0, a) : b.noteGrainOn ? (c = b.buffer.duration, this.loop ? b.noteGrainOn(0, a, c) : b.noteGrainOn(0, a, c - a)) : b.noteOn(0);
            this._pauseTime = 0
        },
        _stop: function() {
            var a = this._sourceNode;
            this._stopped || (a.stop ? a.stop(0) : a.noteOff(0), this._stopped = !0)
        },
        play: function() {
            if (-1 == this._loadState) this._loadState = 0;
            else if (1 == this._loadState) {
                var a = this._sourceNode;
                if (this._stopped || !a || 2 != a.playbackState && a._stopped) this.startTime = _ctx.currentTime, this._play(0)
            }
        },
        pause: function() {
            this._pauseTime = _ctx.currentTime;
            this._paused = !0;
            this._stop()
        },
        resume: function() {
            this._paused && this._play(this._buffer ? (this._pauseTime - this.startTime) %
                this._buffer.duration : 0)
        },
        stop: function() {
            this._pauseTime = 0;
            this._paused = !1;
            this._stop()
        },
        load: function() {
            var a = this;
            if (1 != a._loadState) {
                a._loadState = -1;
                a.played = !1;
                a.ended = !0;
                var b = new XMLHttpRequest;
                b.open("GET", a.src, !0);
                b.responseType = "arraybuffer";
                b.onload = function() {
                    _ctx.decodeAudioData(b.response, a._onSuccess1, a._onError1)
                };
                b.send()
            }
        },
        addEventListener: function(a, b) {
            this._events[a] = b.bind(this)
        },
        removeEventListener: function(a) {
            delete this._events[a]
        },
        canplay: function() {
            return cc.sys._supportWebAudio
        },
        _onSuccess: function(a) {
            this._buffer = a;
            a = this._events.success;
            var b = this._events.canplaythrough;
            a && a();
            b && b();
            (0 == this._loadState || "autoplay" == this.autoplay || !0 == this.autoplay) && this._play();
            this._loadState = 1
        },
        _onError: function() {
            var a = this._events.error;
            a && a();
            this._loadState = -2
        },
        cloneNode: function() {
            var a = new cc.WebAudio(this.src);
            a.volume = this.volume;
            a._loadState = this._loadState;
            a._buffer = this._buffer;
            (0 == a._loadState || -1 == a._loadState) && a.load();
            return a
        }
    });
    _p = cc.WebAudio.prototype;
    cc.defineGetterSetter(_p,
        "loop", function() {
            return this._loop
        }, function(a) {
            this._loop = a;
            this._sourceNode && (this._sourceNode.loop = a)
        });
    cc.defineGetterSetter(_p, "volume", function() {
        return this._volume
    }, function(a) {
        this._volume = a;
        this._volumeNode.gain.value = a
    });
    cc.defineGetterSetter(_p, "paused", function() {
        return this._paused
    });
    cc.defineGetterSetter(_p, "ended", function() {
        var a = this._sourceNode;
        return this._paused ? !1 : this._stopped && !a ? !0 : null == a.playbackState ? a._stopped : 3 == a.playbackState
    });
    cc.defineGetterSetter(_p, "played", function() {
        var a =
            this._sourceNode;
        return a && (2 == a.playbackState || !a._stopped)
    })
}
cc.AudioEngine = cc.Class.extend({
    _soundSupported: !1,
    _currMusic: null,
    _currMusicPath: null,
    _musicPlayState: 0,
    _audioID: 0,
    _effects: {},
    _audioPool: {},
    _effectsVolume: 1,
    _maxAudioInstance: 5,
    _effectPauseCb: null,
    _playings: [],
    ctor: function() {
        this._soundSupported = 0 < cc._audioLoader._supportedAudioTypes.length;
        this._effectPauseCb && (this._effectPauseCb = this._effectPauseCb.bind(this))
    },
    willPlayMusic: function() {
        return !1
    },
    getEffectsVolume: function() {
        return this._effectsVolume
    },
    playMusic: function(a, b) {
        if (this._soundSupported) {
            var c =
                this._currMusic;
            c && this._stopAudio(c);
            cc.sys.isMobile && cc.sys.os == cc.sys.OS_IOS ? (c = this._getAudioByUrl(a), this._currMusic = c.cloneNode(), this._currMusicPath = a) : a != this._currMusicPath && (this._currMusic = c = this._getAudioByUrl(a), this._currMusicPath = a);
            this._currMusic && (this._currMusic.loop = b || !1, this._playMusic(this._currMusic))
        }
    },
    _getAudioByUrl: function(a) {
        var b = cc.loader,
            c = b.getRes(a);
        c || (b.load(a), c = b.getRes(a));
        return c
    },
    _playMusic: function(a) {
        a.ended || (a.stop ? a.stop() : (a.pause(), 2 < a.readyState &&
            (a.currentTime = 0)));
        this._musicPlayState = 2;
        a.play()
    },
    stopMusic: function(a) {
        if (0 < this._musicPlayState) {
            var b = this._currMusic;
            b && this._stopAudio(b) && (a && cc.loader.release(this._currMusicPath), this._currMusicPath = this._currMusic = null, this._musicPlayState = 0)
        }
    },
    _stopAudio: function(a) {
        return a && !a.ended ? (a.stop ? a.stop() : (a.pause(), 2 < a.readyState && (a.duration && Infinity != a.duration) && (a.currentTime = a.duration)), !0) : !1
    },
    pauseMusic: function() {
        2 == this._musicPlayState && (this._currMusic.pause(), this._musicPlayState =
            1)
    },
    resumeMusic: function() {
        1 == this._musicPlayState && (this._resumeAudio(this._currMusic), this._musicPlayState = 2)
    },
    _resumeAudio: function(a) {
        a && !a.ended && (a.resume ? a.resume() : a.play())
    },
    rewindMusic: function() {
        this._currMusic && this._playMusic(this._currMusic)
    },
    getMusicVolume: function() {
        return 0 == this._musicPlayState ? 0 : this._currMusic.volume
    },
    setMusicVolume: function(a) {
        0 < this._musicPlayState && (this._currMusic.volume = Math.min(Math.max(a, 0), 1))
    },
    isMusicPlaying: function() {
        return 2 == this._musicPlayState &&
            this._currMusic && !this._currMusic.ended
    },
    _getEffectList: function(a) {
        var b = this._audioPool[a];
        b || (b = this._audioPool[a] = []);
        return b
    },
    _getEffect: function(a) {
        var b;
        if (!this._soundSupported) return null;
        var c = this._getEffectList(a);
        if (cc.sys.isMobile && cc.sys.os == cc.sys.OS_IOS) b = this._getEffectAudio(c, a);
        else {
            for (var d = 0, e = c.length; d < e; d++) {
                var f = c[d];
                if (f.ended) {
                    b = f;
                    2 < b.readyState && (b.currentTime = 0);
                    window.chrome && b.load();
                    break
                }
            }
            b || (b = this._getEffectAudio(c, a)) && c.push(b)
        }
        return b
    },
    _getEffectAudio: function(a,
        b) {
        var c;
        if (a.length >= this._maxAudioInstance) return cc.log("Error: " + b + " greater than " + this._maxAudioInstance), null;
        c = this._getAudioByUrl(b);
        if (!c) return null;
        c = c.cloneNode(!0);
        this._effectPauseCb && cc._addEventListener(c, "pause", this._effectPauseCb);
        c.volume = this._effectsVolume;
        return c
    },
    playEffect: function(a, b) {
        var c = this._getEffect(a);
        if (!c) return null;
        c.loop = b || !1;
        c.play();
        var d = this._audioID++;
        this._effects[d] = c;
        return d
    },
    setEffectsVolume: function(a) {
        a = this._effectsVolume = Math.min(Math.max(a,
            0), 1);
        var b = this._effects,
            c;
        for (c in b) b[c].volume = a
    },
    pauseEffect: function(a) {
        (a = this._effects[a]) && !a.ended && a.pause()
    },
    pauseAllEffects: function() {
        var a = this._effects,
            b;
        for (b in a) {
            var c = a[b];
            c.ended || c.pause()
        }
    },
    resumeEffect: function(a) {
        this._resumeAudio(this._effects[a])
    },
    resumeAllEffects: function() {
        var a = this._effects,
            b;
        for (b in a) this._resumeAudio(a[b])
    },
    stopEffect: function(a) {
        this._stopAudio(this._effects[a]);
        delete this._effects[a]
    },
    stopAllEffects: function() {
        var a = this._effects,
            b;
        for (b in a) this._stopAudio(a[b]),
            delete a[b]
    },
    unloadEffect: function(a) {
        var b = cc.loader,
            c = this._effects,
            d = this._getEffectList(a);
        b.release(a);
        if (0 != d.length) {
            b = d[0].src;
            delete this._audioPool[a];
            for (var e in c) c[e].src == b && (this._stopAudio(c[e]), delete c[e])
        }
    },
    end: function() {
        this.stopMusic();
        this.stopAllEffects()
    },
    _pausePlaying: function() {
        var a = this._effects,
            b, c;
        for (c in a)
            if ((b = a[c]) && !b.ended && !b.paused) this._playings.push(b), b.pause();
        this.isMusicPlaying() && (this._playings.push(this._currMusic), this._currMusic.pause())
    },
    _resumePlaying: function() {
        for (var a =
            this._playings, b = 0, c = a.length; b < c; b++) this._resumeAudio(a[b]);
        a.length = 0
    }
});
!cc.sys._supportWebAudio && !cc.sys._supportMultipleAudio && (cc.AudioEngineForSingle = cc.AudioEngine.extend({
    _waitingEffIds: [],
    _pausedEffIds: [],
    _currEffect: null,
    _maxAudioInstance: 2,
    _effectCache4Single: {},
    _needToResumeMusic: !1,
    _expendTime4Music: 0,
    _isHiddenMode: !1,
    _playMusic: function(a) {
        this._stopAllEffects();
        this._super(a)
    },
    resumeMusic: function() {
        1 == this._musicPlayState && (this._stopAllEffects(), this._needToResumeMusic = !1, this._expendTime4Music = 0, this._super())
    },
    playEffect: function(a, b) {
        var c = this._currEffect,
            d = b ? this._getEffect(a) : this._getSingleEffect(a);
        if (!d) return null;
        d.loop = b || !1;
        var e = this._audioID++;
        this._effects[e] = d;
        this.isMusicPlaying() && (this.pauseMusic(), this._needToResumeMusic = !0);
        c ? (c != d && this._waitingEffIds.push(this._currEffectId), this._waitingEffIds.push(e), c.pause()) : (this._currEffect = d, this._currEffectId = e, d.play());
        return e
    },
    pauseEffect: function(a) {
        cc.log("pauseEffect not supported in single audio mode!")
    },
    pauseAllEffects: function() {
        var a = this._waitingEffIds,
            b = this._pausedEffIds,
            c = this._currEffect;
        if (c) {
            for (var d = 0, e = a.length; d < e; d++) b.push(a[d]);
            a.length = 0;
            b.push(this._currEffectId);
            c.pause()
        }
    },
    resumeEffect: function(a) {
        cc.log("resumeEffect not supported in single audio mode!")
    },
    resumeAllEffects: function() {
        var a = this._waitingEffIds,
            b = this._pausedEffIds;
        this.isMusicPlaying() && (this.pauseMusic(), this._needToResumeMusic = !0);
        for (var c = 0, d = b.length; c < d; c++) a.push(b[c]);
        b.length = 0;
        if (!this._currEffect && 0 <= a.length && (a = a.pop(), b = this._effects[a])) this._currEffectId = a, this._currEffect =
            b, this._resumeAudio(b)
    },
    stopEffect: function(a) {
        var b = this._currEffect,
            c = this._waitingEffIds,
            d = this._pausedEffIds;
        b && this._currEffectId == a ? this._stopAudio(b) : (b = c.indexOf(a), 0 <= b ? c.splice(b, 1) : (b = d.indexOf(a), 0 <= b && d.splice(b, 1)))
    },
    stopAllEffects: function() {
        this._stopAllEffects();
        !this._currEffect && this._needToResumeMusic && (this._resumeAudio(this._currMusic), this._musicPlayState = 2, this._needToResumeMusic = !1, this._expendTime4Music = 0)
    },
    unloadEffect: function(a) {
        var b = cc.loader,
            c = this._effects,
            d = this._effectCache4Single,
            e = this._getEffectList(a),
            f = this._currEffect;
        b.release(a);
        if (0 != e.length || d[a]) {
            b = 0 < e.length ? e[0].src : d[a].src;
            delete this._audioPool[a];
            delete d[a];
            for (var g in c) c[g].src == b && delete c[g];
            f && f.src == b && this._stopAudio(f)
        }
    },
    _getSingleEffect: function(a) {
        var b = this._effectCache4Single[a],
            c = this._waitingEffIds,
            d = this._pausedEffIds,
            e = this._effects;
        if (b) 2 < b.readyState && (b.currentTime = 0);
        else {
            b = this._getAudioByUrl(a);
            if (!b) return null;
            b = b.cloneNode(!0);
            this._effectPauseCb && cc._addEventListener(b, "pause",
                this._effectPauseCb);
            b.volume = this._effectsVolume;
            this._effectCache4Single[a] = b
        }
        a = 0;
        for (var f = c.length; a < f;) e[c[a]] == b ? c.splice(a, 1) : a++;
        a = 0;
        for (f = d.length; a < f;) e[d[a]] == b ? d.splice(a, 1) : a++;
        b._isToPlay = !0;
        return b
    },
    _stopAllEffects: function() {
        var a = this._currEffect,
            b = this._audioPool,
            c = this._effectCache4Single,
            d = this._waitingEffIds,
            e = this._pausedEffIds;
        if (a || !(0 == d.length && 0 == e.length)) {
            for (var f in c) {
                var g = c[f];
                2 < g.readyState && (g.duration && Infinity != g.duration) && (g.currentTime = g.duration)
            }
            d.length =
                0;
            e.length = 0;
            for (f in b) {
                c = b[f];
                d = 0;
                for (e = c.length; d < e; d++) g = c[d], g.loop = !1, 2 < g.readyState && (g.duration && Infinity != g.duration) && (g.currentTime = g.duration)
            }
            a && this._stopAudio(a)
        }
    },
    _effectPauseCb: function() {
        if (!this._isHiddenMode) {
            var a = this._getWaitingEffToPlay();
            if (a) a._isToPlay ? (delete a._isToPlay, a.play()) : this._resumeAudio(a);
            else if (this._needToResumeMusic) {
                a = this._currMusic;
                if (2 < a.readyState && a.duration && Infinity != a.duration) {
                    var b = a.currentTime + this._expendTime4Music,
                        b = b - a.duration * (b / a.duration |
                            0);
                    a.currentTime = b
                }
                this._expendTime4Music = 0;
                this._resumeAudio(a);
                this._musicPlayState = 2;
                this._needToResumeMusic = !1
            }
        }
    },
    _getWaitingEffToPlay: function() {
        var a = this._waitingEffIds,
            b = this._effects,
            c = this._currEffect,
            d = c ? c.currentTime - (c.startTime || 0) : 0;
        for (this._expendTime4Music += d; 0 != a.length;) {
            var e = a.pop();
            if (c = b[e]) {
                if (c._isToPlay || c.loop || c.duration && c.currentTime + d < c.duration) return this._currEffectId = e, this._currEffect = c, !c._isToPlay && (2 < c.readyState && c.duration && Infinity != c.duration) && (a = c.currentTime +
                    d, a -= c.duration * (a / c.duration | 0), c.currentTime = a), c._isToPlay = !1, c;
                2 < c.readyState && (c.duration && Infinity != c.duration) && (c.currentTime = c.duration)
            }
        }
        return this._currEffect = this._currEffectId = null
    },
    _pausePlaying: function() {
        var a = this._currEffect;
        this._isHiddenMode = !0;
        if (a = 2 == this._musicPlayState ? this._currMusic : a) this._playings.push(a), a.pause()
    },
    _resumePlaying: function() {
        var a = this._playings;
        this._isHiddenMode = !1;
        0 < a.length && (this._resumeAudio(a[0]), a.length = 0)
    }
}));
cc._audioLoader = {
    _supportedAudioTypes: null,
    getBasePath: function() {
        return cc.loader.audioPath
    },
    _load: function(a, b, c, d, e, f, g) {
        var h = this,
            k = cc.loader,
            m = cc.path,
            n = this._supportedAudioTypes,
            q = "";
        if (0 == n.length) return g("can not support audio!");
        if (-1 == d) q = (m.extname(a) || "").toLowerCase(), h.audioTypeSupported(q) || (q = n[0], d = 0);
        else if (d < n.length) q = n[d];
        else return g("can not found the resource of audio! Last match url is : " + a); if (0 <= e.indexOf(q)) return h._load(a, b, c, d + 1, e, f, g);
        a = m.changeExtname(a, q);
        e.push(q);
        f = h._loadAudio(a, f, function(q) {
            if (q) return h._load(a, b, c, d + 1, e, f, g);
            g(null, f)
        }, d == n.length - 1);
        k.cache[b] = f
    },
    audioTypeSupported: function(a) {
        return !a ? !1 : 0 <= this._supportedAudioTypes.indexOf(a.toLowerCase())
    },
    _loadAudio: function(a, b, c, d) {
        var e;
        e = !cc.isObject(window.cc) && "firefox" == cc.sys.browserType ? Audio : "file://" == location.origin ? Audio : cc.WebAudio || Audio;
        2 == arguments.length ? (c = b, b = new e) : 3 < arguments.length && !b && (b = new e);
        b.src = a;
        b.preload = "auto";
        e = navigator.userAgent;
        if (/Mobile/.test(e) && (/iPhone OS/.test(e) ||
            /iPad/.test(e) || /Firefox/.test(e)) || /MSIE/.test(e)) b.load(), c(null, b);
        else {
            cc._addEventListener(b, "canplaythrough", function() {
                c(null, b);
                this.removeEventListener("canplaythrough", arguments.callee, !1);
                this.removeEventListener("error", arguments.callee, !1)
            }, !1);
            var f = function() {
                b.removeEventListener("emptied", f);
                b.removeEventListener("error", f);
                c("load " + a + " failed");
                d && (this.removeEventListener("canplaythrough", arguments.callee, !1), this.removeEventListener("error", arguments.callee, !1))
            };
            cc.sys.browserType ===
                cc.sys.BROWSER_TYPE_WECHAT && cc._addEventListener(b, "emptied", f, !1);
            cc._addEventListener(b, "error", f, !1);
            b.load()
        }
        return b
    },
    load: function(a, b, c, d) {
        this._load(a, b, c, -1, [], null, d)
    }
};
cc._audioLoader._supportedAudioTypes = function() {
    var a = cc.newElement("audio"),
        b = [];
    if (a.canPlayType) {
        var c = function(b) {
            b = a.canPlayType(b);
            return "no" != b && "" != b
        };
        c('audio/ogg; codecs\x3d"vorbis"') && b.push(".ogg");
        c("audio/mpeg") && b.push(".mp3");
        c('audio/wav; codecs\x3d"1"') && b.push(".wav");
        c("audio/mp4") && b.push(".mp4");
        (c("audio/x-m4a") || c("audio/aac")) && b.push(".m4a")
    }
    return b
}();
cc.loader.register(["mp3", "ogg", "wav", "mp4", "m4a"], cc._audioLoader);
cc.audioEngine = cc.AudioEngineForSingle ? new cc.AudioEngineForSingle : new cc.AudioEngine;
cc.eventManager.addCustomListener(cc.game.EVENT_HIDE, function() {
    cc.audioEngine._pausePlaying()
});
cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function() {
    cc.audioEngine._resumePlaying()
});
cc.ProgressTimer = cc.Node.extend({
    _type: null,
    _percentage: 0,
    _sprite: null,
    _midPoint: null,
    _barChangeRate: null,
    _reverseDirection: !1,
    _className: "ProgressTimer",
    getMidpoint: function() {
        return cc.p(this._midPoint.x, this._midPoint.y)
    },
    setMidpoint: function(a) {
        this._midPoint = cc.pClamp(a, cc.p(0, 0), cc.p(1, 1))
    },
    getBarChangeRate: function() {
        return cc.p(this._barChangeRate.x, this._barChangeRate.y)
    },
    setBarChangeRate: function(a) {
        this._barChangeRate = cc.pClamp(a, cc.p(0, 0), cc.p(1, 1))
    },
    getType: function() {
        return this._type
    },
    getPercentage: function() {
        return this._percentage
    },
    getSprite: function() {
        return this._sprite
    },
    setPercentage: function(a) {
        this._percentage != a && (this._percentage = cc.clampf(a, 0, 100), this._updateProgress())
    },
    setOpacityModifyRGB: function(a) {},
    isOpacityModifyRGB: function() {
        return !1
    },
    isReverseDirection: function() {
        return this._reverseDirection
    },
    _boundaryTexCoord: function(a) {
        if (a < cc.ProgressTimer.TEXTURE_COORDS_COUNT) {
            var b = cc.ProgressTimer.TEXTURE_COORDS;
            return this._reverseDirection ? cc.p(b >> 7 - (a << 1) & 1, b >> 7 -
                ((a << 1) + 1) & 1) : cc.p(b >> (a << 1) + 1 & 1, b >> (a << 1) & 1)
        }
        return cc.p(0, 0)
    },
    _vertexDataCount: 0,
    _vertexData: null,
    _vertexArrayBuffer: null,
    _vertexWebGLBuffer: null,
    _vertexDataDirty: !1,
    ctor: null,
    _ctorForCanvas: function(a) {
        cc.Node.prototype.ctor.call(this);
        this._type = cc.ProgressTimer.TYPE_RADIAL;
        this._percentage = 0;
        this._midPoint = cc.p(0, 0);
        this._barChangeRate = cc.p(0, 0);
        this._reverseDirection = !1;
        this._sprite = null;
        this._rendererCmd = new cc.ProgressRenderCmdCanvas(this);
        a && this._initWithSpriteForCanvas(a)
    },
    _ctorForWebGL: function(a) {
        cc.Node.prototype.ctor.call(this);
        this._type = cc.ProgressTimer.TYPE_RADIAL;
        this._percentage = 0;
        this._midPoint = cc.p(0, 0);
        this._barChangeRate = cc.p(0, 0);
        this._reverseDirection = !1;
        this._sprite = null;
        this._vertexWebGLBuffer = cc._renderContext.createBuffer();
        this._vertexDataCount = 0;
        this._vertexArrayBuffer = this._vertexData = null;
        this._vertexDataDirty = !1;
        this._rendererCmd = new cc.ProgressRenderCmdWebGL(this);
        a && this._initWithSpriteForWebGL(a)
    },
    setColor: function(a) {
        this._sprite.color = a;
        this._updateColor()
    },
    setOpacity: function(a) {
        this._sprite.opacity =
            a;
        this._updateColor()
    },
    getColor: function() {
        return this._sprite.color
    },
    getOpacity: function() {
        return this._sprite.opacity
    },
    setReverseProgress: null,
    _setReverseProgressForCanvas: function(a) {
        this._reverseDirection !== a && (this._reverseDirection = a)
    },
    _setReverseProgressForWebGL: function(a) {
        this._reverseDirection !== a && (this._reverseDirection = a, this._vertexArrayBuffer = this._vertexData = null, this._vertexDataCount = 0)
    },
    setSprite: null,
    _setSpriteForCanvas: function(a) {
        this._sprite != a && (this._sprite = a, this._rendererCmd._sprite =
            a, this.width = this._sprite.width, this.height = this._sprite.height)
    },
    _setSpriteForWebGL: function(a) {
        a && this._sprite != a && (this._sprite = a, this.width = a.width, this.height = a.height, this._vertexData && (this._vertexArrayBuffer = this._vertexData = null, this._vertexDataCount = 0))
    },
    setType: null,
    _setTypeForCanvas: function(a) {
        a !== this._type && (this._type = a, this._rendererCmd._type = a)
    },
    _setTypeForWebGL: function(a) {
        a !== this._type && (this._vertexData && (this._vertexArrayBuffer = this._vertexData = null, this._vertexDataCount = 0),
            this._type = a)
    },
    setReverseDirection: null,
    _setReverseDirectionForCanvas: function(a) {
        this._reverseDirection !== a && (this._reverseDirection = a)
    },
    _setReverseDirectionForWebGL: function(a) {
        this._reverseDirection !== a && (this._reverseDirection = a, this._vertexArrayBuffer = this._vertexData = null, this._vertexDataCount = 0)
    },
    _textureCoordFromAlphaPoint: function(a) {
        var b = this._sprite;
        if (!b) return {
            u: 0,
            v: 0
        };
        var c = b.quad,
            d = cc.p(c.bl.texCoords.u, c.bl.texCoords.v),
            c = cc.p(c.tr.texCoords.u, c.tr.texCoords.v);
        b.textureRectRotated &&
            (b = a.x, a.x = a.y, a.y = b);
        return {
            u: d.x * (1 - a.x) + c.x * a.x,
            v: d.y * (1 - a.y) + c.y * a.y
        }
    },
    _vertexFromAlphaPoint: function(a) {
        if (!this._sprite) return {
            x: 0,
            y: 0
        };
        var b = this._sprite.quad,
            c = cc.p(b.bl.vertices.x, b.bl.vertices.y),
            b = cc.p(b.tr.vertices.x, b.tr.vertices.y);
        return {
            x: c.x * (1 - a.x) + b.x * a.x,
            y: c.y * (1 - a.y) + b.y * a.y
        }
    },
    initWithSprite: null,
    _initWithSpriteForCanvas: function(a) {
        this.percentage = 0;
        this.anchorY = this.anchorX = 0.5;
        this._type = cc.ProgressTimer.TYPE_RADIAL;
        this._reverseDirection = !1;
        this.midPoint = cc.p(0.5, 0.5);
        this.barChangeRate =
            cc.p(1, 1);
        this.sprite = a;
        return !0
    },
    _initWithSpriteForWebGL: function(a) {
        this.percentage = 0;
        this._vertexArrayBuffer = this._vertexData = null;
        this._vertexDataCount = 0;
        this.anchorY = this.anchorX = 0.5;
        this._type = cc.ProgressTimer.TYPE_RADIAL;
        this._reverseDirection = !1;
        this.midPoint = cc.p(0.5, 0.5);
        this.barChangeRate = cc.p(1, 1);
        this.sprite = a;
        this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
        return !0
    },
    draw: null,
    _drawForWebGL: function(a) {
        a = a || cc._renderContext;
        if (this._vertexData && this._sprite) {
            cc.nodeDrawSetup(this);
            var b = this._sprite.getBlendFunc();
            cc.glBlendFunc(b.src, b.dst);
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
            cc.glBindTexture2D(this._sprite.texture);
            a.bindBuffer(a.ARRAY_BUFFER, this._vertexWebGLBuffer);
            this._vertexDataDirty && (a.bufferData(a.ARRAY_BUFFER, this._vertexArrayBuffer, a.DYNAMIC_DRAW), this._vertexDataDirty = !1);
            b = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
            a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, b, 0);
            a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0,
                b, 8);
            a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, b, 12);
            this._type === cc.ProgressTimer.TYPE_RADIAL ? a.drawArrays(a.TRIANGLE_FAN, 0, this._vertexDataCount) : this._type == cc.ProgressTimer.TYPE_BAR && (this._reverseDirection ? (a.drawArrays(a.TRIANGLE_STRIP, 0, this._vertexDataCount / 2), a.drawArrays(a.TRIANGLE_STRIP, 4, this._vertexDataCount / 2), cc.g_NumberOfDraws++) : a.drawArrays(a.TRIANGLE_STRIP, 0, this._vertexDataCount));
            cc.g_NumberOfDraws++
        }
    },
    _updateRadial: function() {
        if (this._sprite) {
            var a, b = this._midPoint;
            a = this._percentage / 100;
            var c = 2 * cc.PI * (this._reverseDirection ? a : 1 - a),
                d = cc.p(b.x, 1),
                e = cc.pRotateByAngle(d, b, c),
                c = 0;
            if (0 == a) e = d, c = 0;
            else if (1 == a) e = d, c = 4;
            else {
                var f = cc.FLT_MAX,
                    g = cc.ProgressTimer.TEXTURE_COORDS_COUNT;
                for (a = 0; a <= g; ++a) {
                    var h = (a + (g - 1)) % g,
                        k = this._boundaryTexCoord(a % g),
                        h = this._boundaryTexCoord(h);
                    0 == a ? h = cc.pLerp(k, h, 1 - b.x) : 4 == a && (k = cc.pLerp(k, h, 1 - b.x));
                    var m = cc.p(0, 0);
                    if (cc.pLineIntersect(k, h, b, e, m) && (!(0 == a || 4 == a) || 0 <= m.x && 1 >= m.x) && 0 <= m.y && m.y < f) f = m.y, c = a
                }
                e = cc.pAdd(b, cc.pMult(cc.pSub(e, b),
                    f))
            }
            f = !0;
            this._vertexDataCount != c + 3 && (f = !1, this._vertexArrayBuffer = this._vertexData = null, this._vertexDataCount = 0);
            if (!this._vertexData) {
                g = this._vertexDataCount = c + 3;
                k = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
                this._vertexArrayBuffer = new ArrayBuffer(g * k);
                h = [];
                for (a = 0; a < g; a++) h[a] = new cc.V2F_C4B_T2F(null, null, null, this._vertexArrayBuffer, a * k);
                this._vertexData = h;
                if (!this._vertexData) {
                    cc.log("cc.ProgressTimer._updateRadial() : Not enough memory");
                    return
                }
            }
            this._updateColor();
            g = this._vertexData;
            if (!f) {
                g[0].texCoords =
                    this._textureCoordFromAlphaPoint(b);
                g[0].vertices = this._vertexFromAlphaPoint(b);
                g[1].texCoords = this._textureCoordFromAlphaPoint(d);
                g[1].vertices = this._vertexFromAlphaPoint(d);
                for (a = 0; a < c; a++) b = this._boundaryTexCoord(a), g[a + 2].texCoords = this._textureCoordFromAlphaPoint(b), g[a + 2].vertices = this._vertexFromAlphaPoint(b)
            }
            g[this._vertexDataCount - 1].texCoords = this._textureCoordFromAlphaPoint(e);
            g[this._vertexDataCount - 1].vertices = this._vertexFromAlphaPoint(e)
        }
    },
    _updateBar: function() {
        if (this._sprite) {
            var a,
                b = this._percentage / 100,
                c = this._barChangeRate,
                c = cc.pMult(cc.p(1 - c.x + b * c.x, 1 - c.y + b * c.y), 0.5),
                b = cc.pSub(this._midPoint, c),
                c = cc.pAdd(this._midPoint, c);
            0 > b.x && (c.x += -b.x, b.x = 0);
            1 < c.x && (b.x -= c.x - 1, c.x = 1);
            0 > b.y && (c.y += -b.y, b.y = 0);
            1 < c.y && (b.y -= c.y - 1, c.y = 1);
            if (this._reverseDirection) {
                if (!this._vertexData) {
                    this._vertexDataCount = 8;
                    var d = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
                    this._vertexArrayBuffer = new ArrayBuffer(8 * d);
                    var e = [];
                    for (a = 0; 8 > a; a++) e[a] = new cc.V2F_C4B_T2F(null, null, null, this._vertexArrayBuffer, a * d);
                    e[0].texCoords =
                        this._textureCoordFromAlphaPoint(cc.p(0, 1));
                    e[0].vertices = this._vertexFromAlphaPoint(cc.p(0, 1));
                    e[1].texCoords = this._textureCoordFromAlphaPoint(cc.p(0, 0));
                    e[1].vertices = this._vertexFromAlphaPoint(cc.p(0, 0));
                    e[6].texCoords = this._textureCoordFromAlphaPoint(cc.p(1, 1));
                    e[6].vertices = this._vertexFromAlphaPoint(cc.p(1, 1));
                    e[7].texCoords = this._textureCoordFromAlphaPoint(cc.p(1, 0));
                    e[7].vertices = this._vertexFromAlphaPoint(cc.p(1, 0));
                    this._vertexData = e
                }
                a = this._vertexData;
                a[2].texCoords = this._textureCoordFromAlphaPoint(cc.p(b.x,
                    c.y));
                a[2].vertices = this._vertexFromAlphaPoint(cc.p(b.x, c.y));
                a[3].texCoords = this._textureCoordFromAlphaPoint(cc.p(b.x, b.y));
                a[3].vertices = this._vertexFromAlphaPoint(cc.p(b.x, b.y));
                a[4].texCoords = this._textureCoordFromAlphaPoint(cc.p(c.x, c.y));
                a[4].vertices = this._vertexFromAlphaPoint(cc.p(c.x, c.y));
                a[5].texCoords = this._textureCoordFromAlphaPoint(cc.p(c.x, b.y));
                a[5].vertices = this._vertexFromAlphaPoint(cc.p(c.x, b.y))
            } else {
                if (!this._vertexData) {
                    this._vertexDataCount = 4;
                    d = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
                    this._vertexArrayBuffer = new ArrayBuffer(4 * d);
                    this._vertexData = [];
                    for (a = 0; 4 > a; a++) this._vertexData[a] = new cc.V2F_C4B_T2F(null, null, null, this._vertexArrayBuffer, a * d)
                }
                a = this._vertexData;
                a[0].texCoords = this._textureCoordFromAlphaPoint(cc.p(b.x, c.y));
                a[0].vertices = this._vertexFromAlphaPoint(cc.p(b.x, c.y));
                a[1].texCoords = this._textureCoordFromAlphaPoint(cc.p(b.x, b.y));
                a[1].vertices = this._vertexFromAlphaPoint(cc.p(b.x, b.y));
                a[2].texCoords = this._textureCoordFromAlphaPoint(cc.p(c.x, c.y));
                a[2].vertices = this._vertexFromAlphaPoint(cc.p(c.x,
                    c.y));
                a[3].texCoords = this._textureCoordFromAlphaPoint(cc.p(c.x, b.y));
                a[3].vertices = this._vertexFromAlphaPoint(cc.p(c.x, b.y))
            }
            this._updateColor()
        }
    },
    _updateColor: function() {
        if (this._sprite && this._vertexData) {
            for (var a = this._sprite.quad.tl.colors, b = this._vertexData, c = 0, d = this._vertexDataCount; c < d; ++c) b[c].colors = a;
            this._vertexDataDirty = !0
        }
    },
    _updateProgress: null,
    _updateProgressForCanvas: function() {
        var a = this._sprite,
            b = a.width,
            c = a.height,
            d = this._midPoint,
            e = this._rendererCmd;
        if (this._type == cc.ProgressTimer.TYPE_RADIAL) {
            e._radius =
                Math.round(Math.sqrt(b * b + c * c));
            var f, g = !1,
                h = e._origin;
            h.x = b * d.x;
            h.y = -c * d.y;
            this._reverseDirection ? (f = 270, d = 270 - 3.6 * this._percentage) : (d = -90, f = -90 + 3.6 * this._percentage);
            a._flippedX && (h.x -= b * 2 * this._midPoint.x, d = -d - 180, f = -f - 180, g = !g);
            a._flippedY && (h.y += c * 2 * this._midPoint.y, g = !g, d = -d, f = -f);
            e._startAngle = d;
            e._endAngle = f;
            e._counterClockWise = g
        } else h = this._barChangeRate, g = this._percentage / 100, e = e._barRect, h = cc.size(b * (1 - h.x), c * (1 - h.y)), g = cc.size((b - h.width) * g, (c - h.height) * g), g = cc.size(h.width + g.width, h.height +
            g.height), f = cc.p(b * d.x, c * d.y), h = f.x - g.width / 2, 0.5 < d.x && g.width / 2 >= b - f.x && (h = b - g.width), b = f.y - g.height / 2, 0.5 < d.y && g.height / 2 >= c - f.y && (b = c - g.height), e.x = 0, c = 1, a._flippedX && (e.x -= g.width, c = -1), 0 < h && (e.x += h * c), e.y = 0, c = 1, a._flippedY && (e.y += g.height, c = -1), 0 < b && (e.y -= b * c), e.width = g.width, e.height = -g.height
    },
    _updateProgressForWebGL: function() {
        var a = this._type;
        a === cc.ProgressTimer.TYPE_RADIAL ? this._updateRadial() : a === cc.ProgressTimer.TYPE_BAR && this._updateBar();
        this._vertexDataDirty = !0
    }
});
_p = cc.ProgressTimer.prototype;
cc._renderType == cc._RENDER_TYPE_WEBGL ? (_p.ctor = _p._ctorForWebGL, _p.setReverseProgress = _p._setReverseProgressForWebGL, _p.setSprite = _p._setSpriteForWebGL, _p.setType = _p._setTypeForWebGL, _p.setReverseDirection = _p._setReverseDirectionForWebGL, _p.initWithSprite = _p._initWithSpriteForWebGL, _p.draw = _p._drawForWebGL, _p._updateProgress = _p._updateProgressForWebGL) : (_p.ctor = _p._ctorForCanvas, _p.setReverseProgress = _p._setReverseProgressForCanvas, _p.setSprite = _p._setSpriteForCanvas, _p.setType = _p._setTypeForCanvas,
    _p.setReverseDirection = _p._setReverseDirectionForCanvas, _p.initWithSprite = _p._initWithSpriteForCanvas, _p.draw = _p._drawForCanvas, _p._updateProgress = cc.ProgressTimer.prototype._updateProgressForCanvas);
cc.defineGetterSetter(_p, "midPoint", _p.getMidpoint, _p.setMidpoint);
cc.defineGetterSetter(_p, "barChangeRate", _p.getBarChangeRate, _p.setBarChangeRate);
cc.defineGetterSetter(_p, "type", _p.getType, _p.setType);
cc.defineGetterSetter(_p, "percentage", _p.getPercentage, _p.setPercentage);
cc.defineGetterSetter(_p, "sprite", _p.getSprite, _p.setSprite);
cc.defineGetterSetter(_p, "reverseDir", _p.isReverseDirection, _p.setReverseDirection);
cc.ProgressTimer.create = function(a) {
    return new cc.ProgressTimer(a)
};
cc.ProgressTimer.TEXTURE_COORDS_COUNT = 4;
cc.ProgressTimer.TEXTURE_COORDS = 75;
cc.ProgressTimer.TYPE_RADIAL = 0;
cc.ProgressTimer.TYPE_BAR = 1;
cc.ProgressTo = cc.ActionInterval.extend({
    _to: 0,
    _from: 0,
    ctor: function(a, b) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._from = this._to = 0;
        void 0 !== b && this.initWithDuration(a, b)
    },
    initWithDuration: function(a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._to = b, !0) : !1
    },
    clone: function() {
        var a = new cc.ProgressTo;
        a.initWithDuration(this._duration, this._to);
        return a
    },
    reverse: function() {
        cc.log("cc.ProgressTo.reverse(): reverse hasn't been supported.");
        return null
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this,
            a);
        this._from = a.percentage
    },
    update: function(a) {
        this.target instanceof cc.ProgressTimer && (this.target.percentage = this._from + (this._to - this._from) * a)
    }
});
cc.progressTo = function(a, b) {
    return new cc.ProgressTo(a, b)
};
cc.ProgressTo.create = cc.progressTo;
cc.ProgressFromTo = cc.ActionInterval.extend({
    _to: 0,
    _from: 0,
    ctor: function(a, b, c) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._from = this._to = 0;
        void 0 !== c && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._to = c, this._from = b, !0) : !1
    },
    clone: function() {
        var a = new cc.ProgressFromTo;
        a.initWithDuration(this._duration, this._from, this._to);
        return a
    },
    reverse: function() {
        return cc.progressFromTo(this._duration, this._to, this._from)
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a)
    },
    update: function(a) {
        this.target instanceof cc.ProgressTimer && (this.target.percentage = this._from + (this._to - this._from) * a)
    }
});
cc.progressFromTo = function(a, b, c) {
    return new cc.ProgressFromTo(a, b, c)
};
cc.ProgressFromTo.create = cc.progressFromTo;
cc.IMAGE_FORMAT_JPEG = 0;
cc.IMAGE_FORMAT_PNG = 1;
cc.IMAGE_FORMAT_RAWDATA = 9;
cc.NextPOT = function(a) {
    a -= 1;
    a |= a >> 1;
    a |= a >> 2;
    a |= a >> 4;
    a |= a >> 8;
    return (a | a >> 16) + 1
};
cc.RenderTexture = cc.Node.extend({
    sprite: null,
    clearFlags: 0,
    clearDepthVal: 0,
    autoDraw: !1,
    _cacheCanvas: null,
    _cacheContext: null,
    _fBO: 0,
    _depthRenderBuffer: 0,
    _oldFBO: 0,
    _texture: null,
    _textureCopy: null,
    _uITextureImage: null,
    _pixelFormat: cc.Texture2D.PIXEL_FORMAT_RGBA8888,
    _clearColor: null,
    clearStencilVal: 0,
    _clearColorStr: null,
    _className: "RenderTexture",
    _beginWithClearCommand: null,
    _clearDepthCommand: null,
    _clearCommand: null,
    _beginCommand: null,
    _endCommand: null,
    ctor: null,
    _ctorForCanvas: function(a, b, c, d) {
        cc.Node.prototype.ctor.call(this);
        this._cascadeOpacityEnabled = this._cascadeColorEnabled = !0;
        this._clearColor = cc.color(255, 255, 255, 255);
        this._clearColorStr = "rgba(255,255,255,1)";
        this._cacheCanvas = cc.newElement("canvas");
        this._cacheContext = this._cacheCanvas.getContext("2d");
        this.anchorY = this.anchorX = 0;
        void 0 !== a && void 0 !== b && (c = c || cc.Texture2D.PIXEL_FORMAT_RGBA8888, this.initWithWidthAndHeight(a, b, c, d || 0))
    },
    _initRendererCmd: function() {
        cc._renderType === cc._RENDER_TYPE_WEBGL && (this._rendererCmd = new cc.RenderTextureRenderCmdWebGL(this))
    },
    _ctorForWebGL: function(a, b, c, d) {
        cc.Node.prototype.ctor.call(this);
        this._cascadeOpacityEnabled = this._cascadeColorEnabled = !0;
        this._clearColor = cc.color(0, 0, 0, 0);
        void 0 !== a && void 0 !== b && (c = c || cc.Texture2D.PIXEL_FORMAT_RGBA8888, this.initWithWidthAndHeight(a, b, c, d || 0))
    },
    cleanup: null,
    _cleanupForCanvas: function() {
        cc.Node.prototype.onExit.call(this);
        this._cacheCanvas = this._cacheContext = null
    },
    _cleanupForWebGL: function() {
        cc.Node.prototype.onExit.call(this);
        this._textureCopy = null;
        var a = cc._renderContext;
        a.deleteFramebuffer(this._fBO);
        this._depthRenderBuffer && a.deleteRenderbuffer(this._depthRenderBuffer);
        this._uITextureImage = null
    },
    getSprite: function() {
        return this.sprite
    },
    setSprite: function(a) {
        this.sprite = a
    },
    initWithWidthAndHeight: null,
    _initWithWidthAndHeightForCanvas: function(a, b, c, d) {
        c = this._cacheCanvas;
        d = cc.contentScaleFactor();
        c.width = 0 | a * d;
        c.height = 0 | b * d;
        this._cacheContext.translate(0, c.height);
        a = new cc.Texture2D;
        a.initWithElement(c);
        a.handleLoadedTexture();
        a = this.sprite = new cc.Sprite(a);
        a.setBlendFunc(cc.ONE, cc.ONE_MINUS_SRC_ALPHA);
        this.autoDraw = !1;
        this.addChild(a);
        return !0
    },
    _initWithWidthAndHeightForWebGL: function(a, b, c, d) {
        c == cc.Texture2D.PIXEL_FORMAT_A8 && cc.log("cc.RenderTexture._initWithWidthAndHeightForWebGL() : only RGB and RGBA formats are valid for a render texture;");
        var e = cc._renderContext,
            f = cc.contentScaleFactor();
        a = 0 | a * f;
        b = 0 | b * f;
        this._oldFBO = e.getParameter(e.FRAMEBUFFER_BINDING);
        var g;
        cc.configuration.supportsNPOT() ? (f = a, g = b) : (f = cc.NextPOT(a), g = cc.NextPOT(b));
        for (var h = new Uint8Array(4 * f * g), k = 0; k < 4 * f * g; k++) h[k] = 0;
        this._pixelFormat = c;
        this._texture = new cc.Texture2D;
        if (!this._texture) return !1;
        k = this._texture;
        k.initWithData(h, this._pixelFormat, f, g, cc.size(a, b));
        c = e.getParameter(e.RENDERBUFFER_BINDING);
        if (cc.configuration.checkForGLExtension("GL_QCOM")) {
            this._textureCopy = new cc.Texture2D;
            if (!this._textureCopy) return !1;
            this._textureCopy.initWithData(h, this._pixelFormat, f, g, cc.size(a, b))
        }
        this._fBO = e.createFramebuffer();
        e.bindFramebuffer(e.FRAMEBUFFER, this._fBO);
        e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0,
            e.TEXTURE_2D, k._webTextureObj, 0);
        0 != d && (this._depthRenderBuffer = e.createRenderbuffer(), e.bindRenderbuffer(e.RENDERBUFFER, this._depthRenderBuffer), e.renderbufferStorage(e.RENDERBUFFER, d, f, g), d == e.DEPTH_STENCIL ? e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.RENDERBUFFER, this._depthRenderBuffer) : d == e.STENCIL_INDEX || d == e.STENCIL_INDEX8 ? e.framebufferRenderbuffer(e.FRAMEBUFFER, e.STENCIL_ATTACHMENT, e.RENDERBUFFER, this._depthRenderBuffer) : d == e.DEPTH_COMPONENT16 && e.framebufferRenderbuffer(e.FRAMEBUFFER,
            e.DEPTH_ATTACHMENT, e.RENDERBUFFER, this._depthRenderBuffer));
        e.checkFramebufferStatus(e.FRAMEBUFFER) !== e.FRAMEBUFFER_COMPLETE && cc.log("Could not attach texture to the framebuffer");
        k.setAliasTexParameters();
        a = this.sprite = new cc.Sprite(k);
        a.scaleY = -1;
        a.setBlendFunc(e.ONE, e.ONE_MINUS_SRC_ALPHA);
        e.bindRenderbuffer(e.RENDERBUFFER, c);
        e.bindFramebuffer(e.FRAMEBUFFER, this._oldFBO);
        this.autoDraw = !1;
        this.addChild(a);
        return !0
    },
    begin: null,
    _beginForCanvas: function() {
        cc.renderer._turnToCacheMode(this.__instanceId)
    },
    _beginForWebGL: function() {
        cc.renderer._turnToCacheMode(this.__instanceId);
        cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
        cc.kmGLPushMatrix();
        cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
        cc.kmGLPushMatrix();
        var a = cc.director;
        a.setProjection(a.getProjection());
        var b = this._texture.getContentSizeInPixels(),
            c = cc.director.getWinSizeInPixels(),
            a = c.width / b.width,
            c = c.height / b.height,
            d = cc._renderContext;
        d.viewport(0, 0, b.width, b.height);
        b = new cc.kmMat4;
        cc.kmMat4OrthographicProjection(b, -1 / a, 1 / a, -1 / c, 1 / c, -1, 1);
        cc.kmGLMultMatrix(b);
        this._oldFBO = d.getParameter(d.FRAMEBUFFER_BINDING);
        d.bindFramebuffer(d.FRAMEBUFFER, this._fBO);
        cc.configuration.checkForGLExtension("GL_QCOM") && (d.framebufferTexture2D(d.FRAMEBUFFER, d.COLOR_ATTACHMENT0, d.TEXTURE_2D, this._textureCopy._webTextureObj, 0), d.clear(d.COLOR_BUFFER_BIT | d.DEPTH_BUFFER_BIT), d.framebufferTexture2D(d.FRAMEBUFFER, d.COLOR_ATTACHMENT0, d.TEXTURE_2D, this._texture._webTextureObj, 0))
    },
    beginWithClear: function(a, b, c, d, e, f) {
        var g = cc._renderContext;
        e = e || g.COLOR_BUFFER_BIT;
        f = f || g.COLOR_BUFFER_BIT |
            g.DEPTH_BUFFER_BIT;
        this._beginWithClear(a, b, c, d, e, f, g.COLOR_BUFFER_BIT | g.DEPTH_BUFFER_BIT | g.STENCIL_BUFFER_BIT)
    },
    _beginWithClear: null,
    _beginWithClearForCanvas: function(a, b, c, d, e, f, g) {
        this.begin();
        a = a || 0;
        b = b || 0;
        c = c || 0;
        d = isNaN(d) ? 1 : d;
        e = this._cacheContext;
        f = this._cacheCanvas;
        e.save();
        e.fillStyle = "rgba(" + (0 | a) + "," + (0 | b) + "," + (0 | c) + "," + d / 255 + ")";
        e.clearRect(0, 0, f.width, -f.height);
        e.fillRect(0, 0, f.width, -f.height);
        e.restore()
    },
    _beginWithClearForWebGL: function(a, b, c, d, e, f, g) {
        a /= 255;
        b /= 255;
        c /= 255;
        d /= 255;
        this.begin();
        var h = cc._renderContext,
            k = [0, 0, 0, 0],
            m = 0,
            n = 0;
        g & h.COLOR_BUFFER_BIT && (k = h.getParameter(h.COLOR_CLEAR_VALUE), h.clearColor(a, b, c, d));
        g & h.DEPTH_BUFFER_BIT && (m = h.getParameter(h.DEPTH_CLEAR_VALUE), h.clearDepth(e));
        g & h.STENCIL_BUFFER_BIT && (n = h.getParameter(h.STENCIL_CLEAR_VALUE), h.clearStencil(f));
        h.clear(g);
        g & h.COLOR_BUFFER_BIT && h.clearColor(k[0], k[1], k[2], k[3]);
        g & h.DEPTH_BUFFER_BIT && h.clearDepth(m);
        g & h.STENCIL_BUFFER_BIT && h.clearStencil(n)
    },
    end: null,
    _endForCanvas: function() {
        cc.renderer._renderingToCacheCanvas(this._cacheContext,
            this.__instanceId)
    },
    _endForWebGL: function() {
        cc.renderer._renderingToBuffer(this.__instanceId);
        var a = cc._renderContext,
            b = cc.director;
        a.bindFramebuffer(a.FRAMEBUFFER, this._oldFBO);
        b.setViewport();
        cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
        cc.kmGLPopMatrix();
        cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
        cc.kmGLPopMatrix()
    },
    clear: function(a, b, c, d) {
        this.beginWithClear(a, b, c, d);
        this.end()
    },
    clearRect: null,
    _clearRectForCanvas: function(a, b, c, d) {
        this._cacheContext.clearRect(a, b, c, -d)
    },
    _clearRectForWebGL: function(a, b, c,
        d) {},
    clearDepth: null,
    _clearDepthForCanvas: function(a) {
        cc.log("clearDepth isn't supported on Cocos2d-Html5")
    },
    _clearDepthForWebGL: function(a) {
        this.begin();
        var b = cc._renderContext,
            c = b.getParameter(b.DEPTH_CLEAR_VALUE);
        b.clearDepth(a);
        b.clear(b.DEPTH_BUFFER_BIT);
        b.clearDepth(c);
        this.end()
    },
    clearStencil: null,
    _clearStencilForCanvas: function(a) {
        cc.log("clearDepth isn't supported on Cocos2d-Html5")
    },
    _clearStencilForWebGL: function(a) {
        var b = cc._renderContext,
            c = b.getParameter(b.STENCIL_CLEAR_VALUE);
        b.clearStencil(a);
        b.clear(b.STENCIL_BUFFER_BIT);
        b.clearStencil(c)
    },
    visit: null,
    _visitForCanvas: function(a) {
        this._visible && (a = a || cc._renderContext, this.transform(a), this.sprite.visit(a))
    },
    _visitForWebGL: function(a) {
        this._visible && (cc.kmGLPushMatrix(), this.transform(a), this.sprite.visit(), this._rendererCmd && cc.renderer.pushRenderCommand(this._rendererCmd), cc.kmGLPopMatrix())
    },
    draw: null,
    _drawForCanvas: function(a) {
        a = a || cc._renderContext;
        if (this.autoDraw) {
            this.begin();
            if (this.clearFlags) {
                var b = this._cacheCanvas;
                a.save();
                a.fillStyle = this._clearColorStr;
                a.clearRect(0, 0, b.width, -b.height);
                a.fillRect(0, 0, b.width, -b.height);
                a.restore()
            }
            this.sortAllChildren();
            a = this._children;
            for (var b = a.length, c = this.sprite, d = 0; d < b; d++) {
                var e = a[d];
                e != c && e.visit()
            }
            this.end()
        }
    },
    _drawForWebGL: function(a) {
        a = cc._renderContext;
        if (this.autoDraw) {
            this.begin();
            var b = this.clearFlags;
            if (b) {
                var c = [0, 0, 0, 0],
                    d = 0,
                    e = 0;
                b & a.COLOR_BUFFER_BIT && (c = a.getParameter(a.COLOR_CLEAR_VALUE), a.clearColor(this._clearColor.r / 255, this._clearColor.g / 255, this._clearColor.b /
                    255, this._clearColor.a / 255));
                b & a.DEPTH_BUFFER_BIT && (d = a.getParameter(a.DEPTH_CLEAR_VALUE), a.clearDepth(this.clearDepthVal));
                b & a.STENCIL_BUFFER_BIT && (e = a.getParameter(a.STENCIL_CLEAR_VALUE), a.clearStencil(this.clearStencilVal));
                a.clear(b);
                b & a.COLOR_BUFFER_BIT && a.clearColor(c[0], c[1], c[2], c[3]);
                b & a.DEPTH_BUFFER_BIT && a.clearDepth(d);
                b & a.STENCIL_BUFFER_BIT && a.clearStencil(e)
            }
            this.sortAllChildren();
            a = this._children;
            for (b = 0; b < a.length; b++) c = a[b], c != this.sprite && c.visit();
            this.end()
        }
    },
    newCCImage: function(a) {
        cc.log("saveToFile isn't supported on cocos2d-html5");
        return null
    },
    _memcpy: function(a, b, c, d, e) {
        for (var f = 0; f < e; f++) a[b + f] = c[d + f]
    },
    saveToFile: function(a, b) {
        cc.log("saveToFile isn't supported on Cocos2d-Html5")
    },
    listenToBackground: function(a) {
        cc.log("listenToBackground isn't supported on Cocos2d-Html5")
    },
    listenToForeground: function(a) {
        cc.log("listenToForeground isn't supported on Cocos2d-Html5")
    },
    getClearFlags: function() {
        return this.clearFlags
    },
    setClearFlags: function(a) {
        this.clearFlags = a
    },
    getClearColor: function() {
        return this._clearColor
    },
    setClearColor: null,
    _setClearColorForCanvas: function(a) {
        var b = this._clearColor;
        b.r = a.r;
        b.g = a.g;
        b.b = a.b;
        b.a = a.a;
        this._clearColorStr = "rgba(" + (0 | a.r) + "," + (0 | a.g) + "," + (0 | a.b) + "," + a.a / 255 + ")"
    },
    _setClearColorForWebGL: function(a) {
        var b = this._clearColor;
        b.r = a.r;
        b.g = a.g;
        b.b = a.b;
        b.a = a.a
    },
    getClearDepth: function() {
        return this.clearDepthVal
    },
    setClearDepth: function(a) {
        this.clearDepthVal = a
    },
    getClearStencil: function() {
        return this.clearStencilVal
    },
    setClearStencil: function(a) {
        this.clearStencilVal = a
    },
    isAutoDraw: function() {
        return this.autoDraw
    },
    setAutoDraw: function(a) {
        this.autoDraw = a
    }
});
_p = cc.RenderTexture.prototype;
cc._renderType == cc._RENDER_TYPE_WEBGL ? (_p.ctor = _p._ctorForWebGL, _p.cleanup = _p._cleanupForWebGL, _p.initWithWidthAndHeight = _p._initWithWidthAndHeightForWebGL, _p.begin = _p._beginForWebGL, _p._beginWithClear = _p._beginWithClearForWebGL, _p.end = _p._endForWebGL, _p.clearRect = _p._clearRectForWebGL, _p.clearDepth = _p._clearDepthForWebGL, _p.clearStencil = _p._clearStencilForWebGL, _p.visit = _p._visitForWebGL, _p.draw = _p._drawForWebGL, _p.setClearColor = _p._setClearColorForWebGL) : (_p.ctor = _p._ctorForCanvas, _p.cleanup = _p._cleanupForCanvas,
    _p.initWithWidthAndHeight = _p._initWithWidthAndHeightForCanvas, _p.begin = _p._beginForCanvas, _p._beginWithClear = _p._beginWithClearForCanvas, _p.end = _p._endForCanvas, _p.clearRect = _p._clearRectForCanvas, _p.clearDepth = _p._clearDepthForCanvas, _p.clearStencil = _p._clearStencilForCanvas, _p.visit = _p._visitForCanvas, _p.draw = _p._drawForCanvas, _p.setClearColor = _p._setClearColorForCanvas);
cc.defineGetterSetter(_p, "clearColorVal", _p.getClearColor, _p.setClearColor);
cc.RenderTexture.create = function(a, b, c, d) {
    return new cc.RenderTexture(a, b, c, d)
};
cc.SCENE_FADE = 4208917214;
cc.TRANSITION_ORIENTATION_LEFT_OVER = 0;
cc.TRANSITION_ORIENTATION_RIGHT_OVER = 1;
cc.TRANSITION_ORIENTATION_UP_OVER = 0;
cc.TRANSITION_ORIENTATION_DOWN_OVER = 1;
cc.TransitionScene = cc.Scene.extend({
    _inScene: null,
    _outScene: null,
    _duration: null,
    _isInSceneOnTop: !1,
    _isSendCleanupToScene: !1,
    _className: "TransitionScene",
    ctor: function(a, b) {
        cc.Scene.prototype.ctor.call(this);
        void 0 !== a && void 0 !== b && this.initWithDuration(a, b)
    },
    _setNewScene: function(a) {
        this.unschedule(this._setNewScene);
        a = cc.director;
        this._isSendCleanupToScene = a.isSendCleanupToScene();
        a.runScene(this._inScene);
        cc.eventManager.setEnabled(!0);
        this._outScene.visible = !0
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !0
    },
    visit: function() {
        this._isInSceneOnTop ? (this._outScene.visit(), this._inScene.visit()) : (this._inScene.visit(), this._outScene.visit());
        cc.Node.prototype.visit.call(this)
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this);
        cc.eventManager.setEnabled(!1);
        this._outScene.onExitTransitionDidStart();
        this._inScene.onEnter()
    },
    onExit: function() {
        cc.Node.prototype.onExit.call(this);
        cc.eventManager.setEnabled(!0);
        this._outScene.onExit();
        this._inScene.onEnterTransitionDidFinish()
    },
    cleanup: function() {
        cc.Node.prototype.cleanup.call(this);
        this._isSendCleanupToScene && this._outScene.cleanup()
    },
    initWithDuration: function(a, b) {
        if (!b) throw "cc.TransitionScene.initWithDuration(): Argument scene must be non-nil";
        if (this.init()) {
            this._duration = a;
            this.attr({
                x: 0,
                y: 0,
                anchorX: 0,
                anchorY: 0
            });
            this._inScene = b;
            this._outScene = cc.director.getRunningScene();
            this._outScene || (this._outScene = new cc.Scene, this._outScene.init());
            if (this._inScene == this._outScene) throw "cc.TransitionScene.initWithDuration(): Incoming scene must be different from the outgoing scene";
            this._sceneOrder();
            return !0
        }
        return !1
    },
    finish: function() {
        this._inScene.attr({
            visible: !0,
            x: 0,
            y: 0,
            scale: 1,
            rotation: 0
        });
        cc._renderType === cc._RENDER_TYPE_WEBGL && this._inScene.getCamera().restore();
        this._outScene.attr({
            visible: !1,
            x: 0,
            y: 0,
            scale: 1,
            rotation: 0
        });
        cc._renderType === cc._RENDER_TYPE_WEBGL && this._outScene.getCamera().restore();
        this.schedule(this._setNewScene, 0)
    },
    hideOutShowIn: function() {
        this._inScene.visible = !0;
        this._outScene.visible = !1
    }
});
cc.TransitionScene.create = function(a, b) {
    return new cc.TransitionScene(a, b)
};
cc.TransitionSceneOriented = cc.TransitionScene.extend({
    _orientation: 0,
    ctor: function(a, b, c) {
        cc.TransitionScene.prototype.ctor.call(this);
        void 0 != c && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        cc.TransitionScene.prototype.initWithDuration.call(this, a, b) && (this._orientation = c);
        return !0
    }
});
cc.TransitionSceneOriented.create = function(a, b, c) {
    return new cc.TransitionSceneOriented(a, b, c)
};
cc.TransitionRotoZoom = cc.TransitionScene.extend({
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        this._inScene.attr({
            scale: 0.0010,
            anchorX: 0.5,
            anchorY: 0.5
        });
        this._outScene.attr({
            scale: 1,
            anchorX: 0.5,
            anchorY: 0.5
        });
        var a = cc.sequence(cc.spawn(cc.scaleBy(this._duration / 2, 0.0010), cc.rotateBy(this._duration / 2, 720)), cc.delayTime(this._duration / 2));
        this._outScene.runAction(a);
        this._inScene.runAction(cc.sequence(a.reverse(),
            cc.callFunc(this.finish, this)))
    }
});
cc.TransitionRotoZoom.create = function(a, b) {
    return new cc.TransitionRotoZoom(a, b)
};
cc.TransitionJumpZoom = cc.TransitionScene.extend({
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a = cc.director.getWinSize();
        this._inScene.attr({
            scale: 0.5,
            x: a.width,
            y: 0,
            anchorX: 0.5,
            anchorY: 0.5
        });
        this._outScene.anchorX = 0.5;
        this._outScene.anchorY = 0.5;
        var b = cc.jumpBy(this._duration / 4, cc.p(-a.width, 0), a.width / 4, 2),
            c = cc.scaleTo(this._duration / 4, 1),
            a = cc.scaleTo(this._duration / 4, 0.5),
            a = cc.sequence(a,
                b),
            b = cc.sequence(b, c),
            c = cc.delayTime(this._duration / 2);
        this._outScene.runAction(a);
        this._inScene.runAction(cc.sequence(c, b, cc.callFunc(this.finish, this)))
    }
});
cc.TransitionJumpZoom.create = function(a, b) {
    return new cc.TransitionJumpZoom(a, b)
};
cc.TransitionMoveInL = cc.TransitionScene.extend({
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        this.initScenes();
        var a = this.action();
        this._inScene.runAction(cc.sequence(this.easeActionWithAction(a), cc.callFunc(this.finish, this)))
    },
    initScenes: function() {
        this._inScene.setPosition(-cc.director.getWinSize().width, 0)
    },
    action: function() {
        return cc.moveTo(this._duration, cc.p(0, 0))
    },
    easeActionWithAction: function(a) {
        return new cc.EaseOut(a,
            2)
    }
});
cc.TransitionMoveInL.create = function(a, b) {
    return new cc.TransitionMoveInL(a, b)
};
cc.TransitionMoveInR = cc.TransitionMoveInL.extend({
    ctor: function(a, b) {
        cc.TransitionMoveInL.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    initScenes: function() {
        this._inScene.setPosition(cc.director.getWinSize().width, 0)
    }
});
cc.TransitionMoveInR.create = function(a, b) {
    return new cc.TransitionMoveInR(a, b)
};
cc.TransitionMoveInT = cc.TransitionMoveInL.extend({
    ctor: function(a, b) {
        cc.TransitionMoveInL.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    initScenes: function() {
        this._inScene.setPosition(0, cc.director.getWinSize().height)
    }
});
cc.TransitionMoveInT.create = function(a, b) {
    return new cc.TransitionMoveInT(a, b)
};
cc.TransitionMoveInB = cc.TransitionMoveInL.extend({
    ctor: function(a, b) {
        cc.TransitionMoveInL.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    initScenes: function() {
        this._inScene.setPosition(0, -cc.director.getWinSize().height)
    }
});
cc.TransitionMoveInB.create = function(a, b) {
    return new cc.TransitionMoveInB(a, b)
};
cc.ADJUST_FACTOR = 0.5;
cc.TransitionSlideInL = cc.TransitionScene.extend({
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !1
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        this.initScenes();
        var a = this.action(),
            b = this.action(),
            a = this.easeActionWithAction(a),
            b = cc.sequence(this.easeActionWithAction(b), cc.callFunc(this.finish, this));
        this._inScene.runAction(a);
        this._outScene.runAction(b)
    },
    initScenes: function() {
        this._inScene.setPosition(-cc.director.getWinSize().width +
            cc.ADJUST_FACTOR, 0)
    },
    action: function() {
        return cc.moveBy(this._duration, cc.p(cc.director.getWinSize().width - cc.ADJUST_FACTOR, 0))
    },
    easeActionWithAction: function(a) {
        return new cc.EaseInOut(a, 2)
    }
});
cc.TransitionSlideInL.create = function(a, b) {
    return new cc.TransitionSlideInL(a, b)
};
cc.TransitionSlideInR = cc.TransitionSlideInL.extend({
    ctor: function(a, b) {
        cc.TransitionSlideInL.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !0
    },
    initScenes: function() {
        this._inScene.setPosition(cc.director.getWinSize().width - cc.ADJUST_FACTOR, 0)
    },
    action: function() {
        return cc.moveBy(this._duration, cc.p(-(cc.director.getWinSize().width - cc.ADJUST_FACTOR), 0))
    }
});
cc.TransitionSlideInR.create = function(a, b) {
    return new cc.TransitionSlideInR(a, b)
};
cc.TransitionSlideInB = cc.TransitionSlideInL.extend({
    ctor: function(a, b) {
        cc.TransitionSlideInL.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !1
    },
    initScenes: function() {
        this._inScene.setPosition(0, -(cc.director.getWinSize().height - cc.ADJUST_FACTOR))
    },
    action: function() {
        return cc.moveBy(this._duration, cc.p(0, cc.director.getWinSize().height - cc.ADJUST_FACTOR))
    }
});
cc.TransitionSlideInB.create = function(a, b) {
    return new cc.TransitionSlideInB(a, b)
};
cc.TransitionSlideInT = cc.TransitionSlideInL.extend({
    ctor: function(a, b) {
        cc.TransitionSlideInL.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !0
    },
    initScenes: function() {
        this._inScene.setPosition(0, cc.director.getWinSize().height - cc.ADJUST_FACTOR)
    },
    action: function() {
        return cc.moveBy(this._duration, cc.p(0, -(cc.director.getWinSize().height - cc.ADJUST_FACTOR)))
    }
});
cc.TransitionSlideInT.create = function(a, b) {
    return new cc.TransitionSlideInT(a, b)
};
cc.TransitionShrinkGrow = cc.TransitionScene.extend({
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        this._inScene.attr({
            scale: 0.0010,
            anchorX: 2 / 3,
            anchorY: 0.5
        });
        this._outScene.attr({
            scale: 1,
            anchorX: 1 / 3,
            anchorY: 0.5
        });
        var a = cc.scaleTo(this._duration, 0.01),
            b = cc.scaleTo(this._duration, 1);
        this._inScene.runAction(this.easeActionWithAction(b));
        this._outScene.runAction(cc.sequence(this.easeActionWithAction(a),
            cc.callFunc(this.finish, this)))
    },
    easeActionWithAction: function(a) {
        return new cc.EaseOut(a, 2)
    }
});
cc.TransitionShrinkGrow.create = function(a, b) {
    return new cc.TransitionShrinkGrow(a, b)
};
cc.TransitionFlipX = cc.TransitionSceneOriented.extend({
    ctor: function(a, b, c) {
        cc.TransitionSceneOriented.prototype.ctor.call(this);
        null == c && (c = cc.TRANSITION_ORIENTATION_RIGHT_OVER);
        b && this.initWithDuration(a, b, c)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, b;
        this._inScene.visible = !1;
        var c;
        this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (a = 90, c = 270, b = 90) : (a = -90, c = 90, b = -90);
        a = cc.sequence(cc.delayTime(this._duration / 2), cc.show(), cc.orbitCamera(this._duration / 2, 1, 0,
            c, a, 0, 0), cc.callFunc(this.finish, this));
        b = cc.sequence(cc.orbitCamera(this._duration / 2, 1, 0, 0, b, 0, 0), cc.hide(), cc.delayTime(this._duration / 2));
        this._inScene.runAction(a);
        this._outScene.runAction(b)
    }
});
cc.TransitionFlipX.create = function(a, b, c) {
    return new cc.TransitionFlipX(a, b, c)
};
cc.TransitionFlipY = cc.TransitionSceneOriented.extend({
    ctor: function(a, b, c) {
        cc.TransitionSceneOriented.prototype.ctor.call(this);
        null == c && (c = cc.TRANSITION_ORIENTATION_UP_OVER);
        b && this.initWithDuration(a, b, c)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, b;
        this._inScene.visible = !1;
        var c;
        this._orientation == cc.TRANSITION_ORIENTATION_UP_OVER ? (a = 90, c = 270, b = 90) : (a = -90, c = 90, b = -90);
        a = cc.sequence(cc.delayTime(this._duration / 2), cc.show(), cc.orbitCamera(this._duration / 2, 1, 0, c, a, 90,
            0), cc.callFunc(this.finish, this));
        b = cc.sequence(cc.orbitCamera(this._duration / 2, 1, 0, 0, b, 90, 0), cc.hide(), cc.delayTime(this._duration / 2));
        this._inScene.runAction(a);
        this._outScene.runAction(b)
    }
});
cc.TransitionFlipY.create = function(a, b, c) {
    return new cc.TransitionFlipY(a, b, c)
};
cc.TransitionFlipAngular = cc.TransitionSceneOriented.extend({
    ctor: function(a, b, c) {
        cc.TransitionSceneOriented.prototype.ctor.call(this);
        null == c && (c = cc.TRANSITION_ORIENTATION_RIGHT_OVER);
        b && this.initWithDuration(a, b, c)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, b;
        this._inScene.visible = !1;
        var c;
        this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (a = 90, c = 270, b = 90) : (a = -90, c = 90, b = -90);
        a = cc.sequence(cc.delayTime(this._duration / 2), cc.show(), cc.orbitCamera(this._duration /
            2, 1, 0, c, a, -45, 0), cc.callFunc(this.finish, this));
        b = cc.sequence(cc.orbitCamera(this._duration / 2, 1, 0, 0, b, 45, 0), cc.hide(), cc.delayTime(this._duration / 2));
        this._inScene.runAction(a);
        this._outScene.runAction(b)
    }
});
cc.TransitionFlipAngular.create = function(a, b, c) {
    return new cc.TransitionFlipAngular(a, b, c)
};
cc.TransitionZoomFlipX = cc.TransitionSceneOriented.extend({
    ctor: function(a, b, c) {
        cc.TransitionSceneOriented.prototype.ctor.call(this);
        null == c && (c = cc.TRANSITION_ORIENTATION_RIGHT_OVER);
        b && this.initWithDuration(a, b, c)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, b;
        this._inScene.visible = !1;
        var c;
        this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (a = 90, c = 270, b = 90) : (a = -90, c = 90, b = -90);
        a = cc.sequence(cc.delayTime(this._duration / 2), cc.spawn(cc.orbitCamera(this._duration / 2,
            1, 0, c, a, 0, 0), cc.scaleTo(this._duration / 2, 1), cc.show()), cc.callFunc(this.finish, this));
        b = cc.sequence(cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, 0, b, 0, 0), cc.scaleTo(this._duration / 2, 0.5)), cc.hide(), cc.delayTime(this._duration / 2));
        this._inScene.scale = 0.5;
        this._inScene.runAction(a);
        this._outScene.runAction(b)
    }
});
cc.TransitionZoomFlipX.create = function(a, b, c) {
    return new cc.TransitionZoomFlipX(a, b, c)
};
cc.TransitionZoomFlipY = cc.TransitionSceneOriented.extend({
    ctor: function(a, b, c) {
        cc.TransitionSceneOriented.prototype.ctor.call(this);
        null == c && (c = cc.TRANSITION_ORIENTATION_UP_OVER);
        b && this.initWithDuration(a, b, c)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, b;
        this._inScene.visible = !1;
        var c;
        this._orientation === cc.TRANSITION_ORIENTATION_UP_OVER ? (a = 90, c = 270, b = 90) : (a = -90, c = 90, b = -90);
        a = cc.sequence(cc.delayTime(this._duration / 2), cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, c,
            a, 90, 0), cc.scaleTo(this._duration / 2, 1), cc.show()), cc.callFunc(this.finish, this));
        b = cc.sequence(cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, 0, b, 90, 0), cc.scaleTo(this._duration / 2, 0.5)), cc.hide(), cc.delayTime(this._duration / 2));
        this._inScene.scale = 0.5;
        this._inScene.runAction(a);
        this._outScene.runAction(b)
    }
});
cc.TransitionZoomFlipY.create = function(a, b, c) {
    return new cc.TransitionZoomFlipY(a, b, c)
};
cc.TransitionZoomFlipAngular = cc.TransitionSceneOriented.extend({
    ctor: function(a, b, c) {
        cc.TransitionSceneOriented.prototype.ctor.call(this);
        null == c && (c = cc.TRANSITION_ORIENTATION_RIGHT_OVER);
        b && this.initWithDuration(a, b, c)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, b;
        this._inScene.visible = !1;
        var c;
        this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (a = 90, c = 270, b = 90) : (a = -90, c = 90, b = -90);
        a = cc.sequence(cc.delayTime(this._duration / 2), cc.spawn(cc.orbitCamera(this._duration /
            2, 1, 0, c, a, -45, 0), cc.scaleTo(this._duration / 2, 1), cc.show()), cc.show(), cc.callFunc(this.finish, this));
        b = cc.sequence(cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, 0, b, 45, 0), cc.scaleTo(this._duration / 2, 0.5)), cc.hide(), cc.delayTime(this._duration / 2));
        this._inScene.scale = 0.5;
        this._inScene.runAction(a);
        this._outScene.runAction(b)
    }
});
cc.TransitionZoomFlipAngular.create = function(a, b, c) {
    return new cc.TransitionZoomFlipAngular(a, b, c)
};
cc.TransitionFade = cc.TransitionScene.extend({
    _color: null,
    ctor: function(a, b, c) {
        cc.TransitionScene.prototype.ctor.call(this);
        this._color = cc.color();
        b && this.initWithDuration(a, b, c)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a = new cc.LayerColor(this._color);
        this._inScene.visible = !1;
        this.addChild(a, 2, cc.SCENE_FADE);
        var a = this.getChildByTag(cc.SCENE_FADE),
            b = cc.sequence(cc.fadeIn(this._duration / 2), cc.callFunc(this.hideOutShowIn, this), cc.fadeOut(this._duration / 2), cc.callFunc(this.finish,
                this));
        a.runAction(b)
    },
    onExit: function() {
        cc.TransitionScene.prototype.onExit.call(this);
        this.removeChildByTag(cc.SCENE_FADE, !1)
    },
    initWithDuration: function(a, b, c) {
        c = c || cc.color.BLACK;
        cc.TransitionScene.prototype.initWithDuration.call(this, a, b) && (this._color.r = c.r, this._color.g = c.g, this._color.b = c.b, this._color.a = 0);
        return !0
    }
});
cc.TransitionFade.create = function(a, b, c) {
    return new cc.TransitionFade(a, b, c)
};
cc.TransitionCrossFade = cc.TransitionScene.extend({
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a = cc.color(0, 0, 0, 0),
            b = cc.director.getWinSize(),
            a = new cc.LayerColor(a),
            c = new cc.RenderTexture(b.width, b.height);
        if (null != c) {
            c.sprite.anchorX = 0.5;
            c.sprite.anchorY = 0.5;
            c.attr({
                x: b.width / 2,
                y: b.height / 2,
                anchorX: 0.5,
                anchorY: 0.5
            });
            c.begin();
            this._inScene.visit();
            c.end();
            var d = new cc.RenderTexture(b.width,
                b.height);
            d.setPosition(b.width / 2, b.height / 2);
            d.sprite.anchorX = d.anchorX = 0.5;
            d.sprite.anchorY = d.anchorY = 0.5;
            d.begin();
            this._outScene.visit();
            d.end();
            c.sprite.setBlendFunc(cc.ONE, cc.ONE);
            d.sprite.setBlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA);
            a.addChild(c);
            a.addChild(d);
            c.sprite.opacity = 255;
            d.sprite.opacity = 255;
            b = cc.sequence(cc.fadeTo(this._duration, 0), cc.callFunc(this.hideOutShowIn, this), cc.callFunc(this.finish, this));
            d.sprite.runAction(b);
            this.addChild(a, 2, cc.SCENE_FADE)
        }
    },
    onExit: function() {
        this.removeChildByTag(cc.SCENE_FADE, !1);
        cc.TransitionScene.prototype.onExit.call(this)
    },
    visit: function() {
        cc.Node.prototype.visit.call(this)
    },
    draw: function() {}
});
cc.TransitionCrossFade.create = function(a, b) {
    return new cc.TransitionCrossFade(a, b)
};
cc.TransitionTurnOffTiles = cc.TransitionScene.extend({
    _gridProxy: null,
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this);
        this._gridProxy = new cc.NodeGrid;
        b && this.initWithDuration(a, b)
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !1
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        this._gridProxy.setTarget(this._outScene);
        this._gridProxy.onEnter();
        var a = cc.director.getWinSize(),
            a = cc.turnOffTiles(this._duration, cc.size(0 | 12 * (a.width / a.height), 12)),
            a = this.easeActionWithAction(a);
        this._gridProxy.runAction(cc.sequence(a, cc.callFunc(this.finish, this), cc.stopGrid()))
    },
    visit: function() {
        this._inScene.visit();
        this._gridProxy.visit()
    },
    easeActionWithAction: function(a) {
        return a
    }
});
cc.TransitionTurnOffTiles.create = function(a, b) {
    return new cc.TransitionTurnOffTiles(a, b)
};
cc.TransitionSplitCols = cc.TransitionScene.extend({
    _gridProxy: null,
    _switchTargetToInscene: function() {
        this._gridProxy.setTarget(this._inScene)
    },
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this);
        this._gridProxy = new cc.NodeGrid;
        b && this.initWithDuration(a, b)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        this._gridProxy.setTarget(this._outScene);
        this._gridProxy.onEnter();
        var a = this.action(),
            a = cc.sequence(a, cc.callFunc(this._switchTargetToInscene, this), a.reverse());
        this._gridProxy.runAction(cc.sequence(this.easeActionWithAction(a),
            cc.callFunc(this.finish, this), cc.stopGrid()))
    },
    onExit: function() {
        this._gridProxy.setTarget(null);
        this._gridProxy.onExit();
        cc.TransitionScene.prototype.onExit.call(this)
    },
    visit: function() {
        this._gridProxy.visit()
    },
    easeActionWithAction: function(a) {
        return new cc.EaseInOut(a, 3)
    },
    action: function() {
        return cc.splitCols(this._duration / 2, 3)
    }
});
cc.TransitionSplitCols.create = function(a, b) {
    return new cc.TransitionSplitCols(a, b)
};
cc.TransitionSplitRows = cc.TransitionSplitCols.extend({
    ctor: function(a, b) {
        cc.TransitionSplitCols.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    action: function() {
        return cc.splitRows(this._duration / 2, 3)
    }
});
cc.TransitionSplitRows.create = function(a, b) {
    return new cc.TransitionSplitRows(a, b)
};
cc.TransitionFadeTR = cc.TransitionScene.extend({
    _gridProxy: null,
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this);
        this._gridProxy = new cc.NodeGrid;
        b && this.initWithDuration(a, b)
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !1
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        this._gridProxy.setTarget(this._outScene);
        this._gridProxy.onEnter();
        var a = cc.director.getWinSize(),
            a = this.actionWithSize(cc.size(0 | 12 * (a.width / a.height), 12));
        this._gridProxy.runAction(cc.sequence(this.easeActionWithAction(a),
            cc.callFunc(this.finish, this), cc.stopGrid()))
    },
    visit: function() {
        this._inScene.visit();
        this._gridProxy.visit()
    },
    easeActionWithAction: function(a) {
        return a
    },
    actionWithSize: function(a) {
        return cc.fadeOutTRTiles(this._duration, a)
    }
});
cc.TransitionFadeTR.create = function(a, b) {
    return new cc.TransitionFadeTR(a, b)
};
cc.TransitionFadeBL = cc.TransitionFadeTR.extend({
    ctor: function(a, b) {
        cc.TransitionFadeTR.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    actionWithSize: function(a) {
        return cc.fadeOutBLTiles(this._duration, a)
    }
});
cc.TransitionFadeBL.create = function(a, b) {
    return new cc.TransitionFadeBL(a, b)
};
cc.TransitionFadeUp = cc.TransitionFadeTR.extend({
    ctor: function(a, b) {
        cc.TransitionFadeTR.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    actionWithSize: function(a) {
        return new cc.FadeOutUpTiles(this._duration, a)
    }
});
cc.TransitionFadeUp.create = function(a, b) {
    return new cc.TransitionFadeUp(a, b)
};
cc.TransitionFadeDown = cc.TransitionFadeTR.extend({
    ctor: function(a, b) {
        cc.TransitionFadeTR.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    actionWithSize: function(a) {
        return cc.fadeOutDownTiles(this._duration, a)
    }
});
cc.TransitionFadeDown.create = function(a, b) {
    return new cc.TransitionFadeDown(a, b)
};
cc.SCENE_RADIAL = 49153;
cc.TransitionProgress = cc.TransitionScene.extend({
    _to: 0,
    _from: 0,
    _sceneToBeModified: null,
    _className: "TransitionProgress",
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    _setAttrs: function(a, b, c) {
        a.attr({
            x: b,
            y: c,
            anchorX: 0.5,
            anchorY: 0.5
        })
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        this._setupTransition();
        var a = cc.director.getWinSize(),
            b = new cc.RenderTexture(a.width, a.height);
        b.sprite.anchorX = 0.5;
        b.sprite.anchorY = 0.5;
        this._setAttrs(b,
            a.width / 2, a.height / 2);
        b.clear(0, 0, 0, 1);
        b.begin();
        this._sceneToBeModified.visit();
        b.end();
        this._sceneToBeModified == this._outScene && this.hideOutShowIn();
        a = this._progressTimerNodeWithRenderTexture(b);
        b = cc.sequence(cc.progressFromTo(this._duration, this._from, this._to), cc.callFunc(this.finish, this));
        a.runAction(b);
        this.addChild(a, 2, cc.SCENE_RADIAL)
    },
    onExit: function() {
        this.removeChildByTag(cc.SCENE_RADIAL, !0);
        cc.TransitionScene.prototype.onExit.call(this)
    },
    _setupTransition: function() {
        this._sceneToBeModified =
            this._outScene;
        this._from = 100;
        this._to = 0
    },
    _progressTimerNodeWithRenderTexture: function(a) {
        cc.log("cc.TransitionProgress._progressTimerNodeWithRenderTexture(): should be overridden in subclass");
        return null
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !1
    }
});
cc.TransitionProgress.create = function(a, b) {
    return new cc.TransitionProgress(a, b)
};
cc.TransitionProgressRadialCCW = cc.TransitionProgress.extend({
    ctor: function(a, b) {
        cc.TransitionProgress.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    _progressTimerNodeWithRenderTexture: function(a) {
        var b = cc.director.getWinSize();
        a = new cc.ProgressTimer(a.sprite);
        cc._renderType === cc._RENDER_TYPE_WEBGL && (a.sprite.flippedY = !0);
        a.type = cc.ProgressTimer.TYPE_RADIAL;
        a.reverseDir = !1;
        a.percentage = 100;
        this._setAttrs(a, b.width / 2, b.height / 2);
        return a
    }
});
cc.TransitionProgressRadialCCW.create = function(a, b) {
    return new cc.TransitionProgressRadialCCW(a, b)
};
cc.TransitionProgressRadialCW = cc.TransitionProgress.extend({
    ctor: function(a, b) {
        cc.TransitionProgress.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    _progressTimerNodeWithRenderTexture: function(a) {
        var b = cc.director.getWinSize();
        a = new cc.ProgressTimer(a.sprite);
        cc._renderType === cc._RENDER_TYPE_WEBGL && (a.sprite.flippedY = !0);
        a.type = cc.ProgressTimer.TYPE_RADIAL;
        a.reverseDir = !0;
        a.percentage = 100;
        this._setAttrs(a, b.width / 2, b.height / 2);
        return a
    }
});
cc.TransitionProgressRadialCW.create = function(a, b) {
    var c = new cc.TransitionProgressRadialCW;
    return null != c && c.initWithDuration(a, b) ? c : new cc.TransitionProgressRadialCW(a, b)
};
cc.TransitionProgressHorizontal = cc.TransitionProgress.extend({
    ctor: function(a, b) {
        cc.TransitionProgress.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    _progressTimerNodeWithRenderTexture: function(a) {
        var b = cc.director.getWinSize();
        a = new cc.ProgressTimer(a.sprite);
        cc._renderType === cc._RENDER_TYPE_WEBGL && (a.sprite.flippedY = !0);
        a.type = cc.ProgressTimer.TYPE_BAR;
        a.midPoint = cc.p(1, 0);
        a.barChangeRate = cc.p(1, 0);
        a.percentage = 100;
        this._setAttrs(a, b.width / 2, b.height / 2);
        return a
    }
});
cc.TransitionProgressHorizontal.create = function(a, b) {
    return new cc.TransitionProgressHorizontal(a, b)
};
cc.TransitionProgressVertical = cc.TransitionProgress.extend({
    ctor: function(a, b) {
        cc.TransitionProgress.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    _progressTimerNodeWithRenderTexture: function(a) {
        var b = cc.director.getWinSize();
        a = new cc.ProgressTimer(a.sprite);
        cc._renderType === cc._RENDER_TYPE_WEBGL && (a.sprite.flippedY = !0);
        a.type = cc.ProgressTimer.TYPE_BAR;
        a.midPoint = cc.p(0, 0);
        a.barChangeRate = cc.p(0, 1);
        a.percentage = 100;
        this._setAttrs(a, b.width / 2, b.height / 2);
        return a
    }
});
cc.TransitionProgressVertical.create = function(a, b) {
    return new cc.TransitionProgressVertical(a, b)
};
cc.TransitionProgressInOut = cc.TransitionProgress.extend({
    ctor: function(a, b) {
        cc.TransitionProgress.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    _progressTimerNodeWithRenderTexture: function(a) {
        var b = cc.director.getWinSize();
        a = new cc.ProgressTimer(a.sprite);
        cc._renderType === cc._RENDER_TYPE_WEBGL && (a.sprite.flippedY = !0);
        a.type = cc.ProgressTimer.TYPE_BAR;
        a.midPoint = cc.p(0.5, 0.5);
        a.barChangeRate = cc.p(1, 1);
        a.percentage = 0;
        this._setAttrs(a, b.width / 2, b.height / 2);
        return a
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !1
    },
    _setupTransition: function() {
        this._sceneToBeModified = this._inScene;
        this._from = 0;
        this._to = 100
    }
});
cc.TransitionProgressInOut.create = function(a, b) {
    return new cc.TransitionProgressInOut(a, b)
};
cc.TransitionProgressOutIn = cc.TransitionProgress.extend({
    ctor: function(a, b) {
        cc.TransitionProgress.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    _progressTimerNodeWithRenderTexture: function(a) {
        var b = cc.director.getWinSize();
        a = new cc.ProgressTimer(a.sprite);
        cc._renderType === cc._RENDER_TYPE_WEBGL && (a.sprite.flippedY = !0);
        a.type = cc.ProgressTimer.TYPE_BAR;
        a.midPoint = cc.p(0.5, 0.5);
        a.barChangeRate = cc.p(1, 1);
        a.percentage = 100;
        this._setAttrs(a, b.width / 2, b.height / 2);
        return a
    }
});
cc.TransitionProgressOutIn.create = function(a, b) {
    return new cc.TransitionProgressOutIn(a, b)
};
cc.TransitionPageTurn = cc.TransitionScene.extend({
    ctor: function(a, b, c) {
        cc.TransitionScene.prototype.ctor.call(this);
        this._gridProxy = new cc.NodeGrid;
        this.initWithDuration(a, b, c)
    },
    _back: !0,
    _gridProxy: null,
    _className: "TransitionPageTurn",
    initWithDuration: function(a, b, c) {
        this._back = c;
        cc.TransitionScene.prototype.initWithDuration.call(this, a, b);
        return !0
    },
    actionWithSize: function(a) {
        return this._back ? cc.reverseTime(cc.pageTurn3D(this._duration, a)) : cc.pageTurn3D(this._duration, a)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a = cc.director.getWinSize(),
            b;
        a.width > a.height ? (a = 16, b = 12) : (a = 12, b = 16);
        a = this.actionWithSize(cc.size(a, b));
        b = this._gridProxy;
        this._back ? (b.setTarget(this._inScene), b.onEnter(), this._inScene.visible = !1, b.runAction(cc.sequence(a, cc.callFunc(this.finish, this), cc.stopGrid())), this._inScene.runAction(cc.show())) : (b.setTarget(this._outScene), b.onEnter(), b.runAction(cc.sequence(a, cc.callFunc(this.finish, this), cc.stopGrid())))
    },
    visit: function() {
        this._back ? this._outScene.visit() : this._inScene.visit();
        this._gridProxy.visit()
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = this._back
    }
});
cc.TransitionPageTurn.create = function(a, b, c) {
    return new cc.TransitionPageTurn(a, b, c)
};
cc.Codec = {
    name: "Jacob__Codec"
};
cc.unzip = function() {
    return cc.Codec.GZip.gunzip.apply(cc.Codec.GZip, arguments)
};
cc.unzipBase64 = function() {
    var a = cc.Codec.Base64.decode.apply(cc.Codec.Base64, arguments);
    return cc.Codec.GZip.gunzip.apply(cc.Codec.GZip, [a])
};
cc.unzipBase64AsArray = function(a, b) {
    b = b || 1;
    var c = this.unzipBase64(a),
        d = [],
        e, f, g;
    e = 0;
    for (g = c.length / b; e < g; e++) {
        d[e] = 0;
        for (f = b - 1; 0 <= f; --f) d[e] += c.charCodeAt(e * b + f) << 8 * f
    }
    return d
};
cc.unzipAsArray = function(a, b) {
    b = b || 1;
    var c = this.unzip(a),
        d = [],
        e, f, g;
    e = 0;
    for (g = c.length / b; e < g; e++) {
        d[e] = 0;
        for (f = b - 1; 0 <= f; --f) d[e] += c.charCodeAt(e * b + f) << 8 * f
    }
    return d
};
cc.StringToArray = function(a) {
    a = a.split(",");
    var b = [],
        c;
    for (c = 0; c < a.length; c++) b.push(parseInt(a[c]));
    return b
};
cc.Codec.Base64 = {
    name: "Jacob__Codec__Base64"
};
cc.Codec.Base64._keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\x3d";
cc.Codec.Base64.decode = function(a) {
    var b = [],
        c, d, e, f, g, h = 0;
    for (a = a.replace(/[^A-Za-z0-9\+\/\=]/g, ""); h < a.length;) c = this._keyStr.indexOf(a.charAt(h++)), d = this._keyStr.indexOf(a.charAt(h++)), f = this._keyStr.indexOf(a.charAt(h++)), g = this._keyStr.indexOf(a.charAt(h++)), c = c << 2 | d >> 4, d = (d & 15) << 4 | f >> 2, e = (f & 3) << 6 | g, b.push(String.fromCharCode(c)), 64 != f && b.push(String.fromCharCode(d)), 64 != g && b.push(String.fromCharCode(e));
    return b = b.join("")
};
cc.Codec.Base64.decodeAsArray = function(a, b) {
    var c = this.decode(a),
        d = [],
        e, f, g;
    e = 0;
    for (g = c.length / b; e < g; e++) {
        d[e] = 0;
        for (f = b - 1; 0 <= f; --f) d[e] += c.charCodeAt(e * b + f) << 8 * f
    }
    return d
};
cc.uint8ArrayToUint32Array = function(a) {
    if (0 != a.length % 4) return null;
    for (var b = a.length / 4, c = window.Uint32Array ? new Uint32Array(b) : [], d = 0; d < b; d++) {
        var e = 4 * d;
        c[d] = a[e] + 256 * a[e + 1] + 65536 * a[e + 2] + 16777216 * a[e + 3]
    }
    return c
};
cc.Codec.GZip = function(a) {
    this.data = a;
    this.debug = !1;
    this.gpflags = void 0;
    this.files = 0;
    this.unzipped = [];
    this.buf32k = Array(32768);
    this.bIdx = 0;
    this.modeZIP = !1;
    this.bytepos = 0;
    this.bb = 1;
    this.bits = 0;
    this.nameBuf = [];
    this.fileout = void 0;
    this.literalTree = Array(cc.Codec.GZip.LITERALS);
    this.distanceTree = Array(32);
    this.treepos = 0;
    this.Places = null;
    this.len = 0;
    this.fpos = Array(17);
    this.fpos[0] = 0;
    this.fmax = this.flens = void 0
};
cc.Codec.GZip.gunzip = function(a) {
    return (new cc.Codec.GZip(a)).gunzip()[0][0]
};
cc.Codec.GZip.HufNode = function() {
    this.b1 = this.b0 = 0;
    this.jump = null;
    this.jumppos = -1
};
cc.Codec.GZip.LITERALS = 288;
cc.Codec.GZip.NAMEMAX = 256;
cc.Codec.GZip.bitReverse = [0, 128, 64, 192, 32, 160, 96, 224, 16, 144, 80, 208, 48, 176, 112, 240, 8, 136, 72, 200, 40, 168, 104, 232, 24, 152, 88, 216, 56, 184, 120, 248, 4, 132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52, 180, 116, 244, 12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, 226, 18, 146, 82, 210, 50, 178, 114, 242, 10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250, 6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246, 14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254, 1, 129, 65, 193, 33, 161,
    97, 225, 17, 145, 81, 209, 49, 177, 113, 241, 9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249, 5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245, 13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253, 3, 131, 67, 195, 35, 163, 99, 227, 19, 147, 83, 211, 51, 179, 115, 243, 11, 139, 75, 203, 43, 171, 107, 235, 27, 155, 91, 219, 59, 187, 123, 251, 7, 135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247, 15, 143, 79, 207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127, 255
];
cc.Codec.GZip.cplens = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];
cc.Codec.GZip.cplext = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99];
cc.Codec.GZip.cpdist = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
cc.Codec.GZip.cpdext = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
cc.Codec.GZip.border = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
cc.Codec.GZip.prototype.gunzip = function() {
    this.outputArr = [];
    this.nextFile();
    return this.unzipped
};
cc.Codec.GZip.prototype.readByte = function() {
    this.bits += 8;
    return this.bytepos < this.data.length ? this.data.charCodeAt(this.bytepos++) : -1
};
cc.Codec.GZip.prototype.byteAlign = function() {
    this.bb = 1
};
cc.Codec.GZip.prototype.readBit = function() {
    var a;
    this.bits++;
    a = this.bb & 1;
    this.bb >>= 1;
    0 == this.bb && (this.bb = this.readByte(), a = this.bb & 1, this.bb = this.bb >> 1 | 128);
    return a
};
cc.Codec.GZip.prototype.readBits = function(a) {
    for (var b = 0, c = a; c--;) b = b << 1 | this.readBit();
    a && (b = cc.Codec.GZip.bitReverse[b] >> 8 - a);
    return b
};
cc.Codec.GZip.prototype.flushBuffer = function() {
    this.bIdx = 0
};
cc.Codec.GZip.prototype.addBuffer = function(a) {
    this.buf32k[this.bIdx++] = a;
    this.outputArr.push(String.fromCharCode(a));
    32768 == this.bIdx && (this.bIdx = 0)
};
cc.Codec.GZip.prototype.IsPat = function() {
    for (;;) {
        if (this.fpos[this.len] >= this.fmax) return -1;
        if (this.flens[this.fpos[this.len]] == this.len) return this.fpos[this.len]++;
        this.fpos[this.len]++
    }
};
cc.Codec.GZip.prototype.Rec = function() {
    var a = this.Places[this.treepos],
        b;
    if (17 == this.len) return -1;
    this.treepos++;
    this.len++;
    b = this.IsPat();
    if (0 <= b) a.b0 = b;
    else if (a.b0 = 32768, this.Rec()) return -1;
    b = this.IsPat();
    if (0 <= b) a.b1 = b, a.jump = null;
    else if (a.b1 = 32768, a.jump = this.Places[this.treepos], a.jumppos = this.treepos, this.Rec()) return -1;
    this.len--;
    return 0
};
cc.Codec.GZip.prototype.CreateTree = function(a, b, c, d) {
    this.Places = a;
    this.treepos = 0;
    this.flens = c;
    this.fmax = b;
    for (a = 0; 17 > a; a++) this.fpos[a] = 0;
    this.len = 0;
    return this.Rec() ? -1 : 0
};
cc.Codec.GZip.prototype.DecodeValue = function(a) {
    for (var b, c, d = 0, e = a[d];;)
        if (b = this.readBit()) {
            if (!(e.b1 & 32768)) return e.b1;
            e = e.jump;
            b = a.length;
            for (c = 0; c < b; c++)
                if (a[c] === e) {
                    d = c;
                    break
                }
        } else {
            if (!(e.b0 & 32768)) return e.b0;
            d++;
            e = a[d]
        }
    return -1
};
cc.Codec.GZip.prototype.DeflateLoop = function() {
    var a, b, c, d, e;
    do
        if (a = this.readBit(), c = this.readBits(2), 0 == c) {
            this.byteAlign();
            c = this.readByte();
            c |= this.readByte() << 8;
            b = this.readByte();
            b |= this.readByte() << 8;
            for ((c ^ ~b) & 65535 && document.write("BlockLen checksum mismatch\n"); c--;) b = this.readByte(), this.addBuffer(b)
        } else if (1 == c)
        for (;;)
            if (c = cc.Codec.GZip.bitReverse[this.readBits(7)] >> 1, 23 < c ? (c = c << 1 | this.readBit(), 199 < c ? (c -= 128, c = c << 1 | this.readBit()) : (c -= 48, 143 < c && (c += 136))) : c += 256, 256 > c) this.addBuffer(c);
            else if (256 == c) break;
    else {
        var f;
        c -= 257;
        e = this.readBits(cc.Codec.GZip.cplext[c]) + cc.Codec.GZip.cplens[c];
        c = cc.Codec.GZip.bitReverse[this.readBits(5)] >> 3;
        8 < cc.Codec.GZip.cpdext[c] ? (f = this.readBits(8), f |= this.readBits(cc.Codec.GZip.cpdext[c] - 8) << 8) : f = this.readBits(cc.Codec.GZip.cpdext[c]);
        f += cc.Codec.GZip.cpdist[c];
        for (c = 0; c < e; c++) b = this.buf32k[this.bIdx - f & 32767], this.addBuffer(b)
    } else if (2 == c) {
        var g = Array(320);
        b = 257 + this.readBits(5);
        f = 1 + this.readBits(5);
        d = 4 + this.readBits(4);
        for (c = 0; 19 > c; c++) g[c] = 0;
        for (c = 0; c < d; c++) g[cc.Codec.GZip.border[c]] = this.readBits(3);
        e = this.distanceTree.length;
        for (d = 0; d < e; d++) this.distanceTree[d] = new cc.Codec.GZip.HufNode;
        if (this.CreateTree(this.distanceTree, 19, g, 0)) return this.flushBuffer(), 1;
        e = b + f;
        d = 0;
        for (var h = -1; d < e;)
            if (h++, c = this.DecodeValue(this.distanceTree), 16 > c) g[d++] = c;
            else if (16 == c) {
            var k;
            c = 3 + this.readBits(2);
            if (d + c > e) return this.flushBuffer(), 1;
            for (k = d ? g[d - 1] : 0; c--;) g[d++] = k
        } else {
            c = 17 == c ? 3 + this.readBits(3) : 11 + this.readBits(7);
            if (d + c > e) return this.flushBuffer(),
                1;
            for (; c--;) g[d++] = 0
        }
        e = this.literalTree.length;
        for (d = 0; d < e; d++) this.literalTree[d] = new cc.Codec.GZip.HufNode;
        if (this.CreateTree(this.literalTree, b, g, 0)) return this.flushBuffer(), 1;
        e = this.literalTree.length;
        for (d = 0; d < e; d++) this.distanceTree[d] = new cc.Codec.GZip.HufNode;
        c = [];
        for (d = b; d < g.length; d++) c[d - b] = g[d];
        if (this.CreateTree(this.distanceTree, f, c, 0)) return this.flushBuffer(), 1;
        for (;;)
            if (c = this.DecodeValue(this.literalTree), 256 <= c) {
                c -= 256;
                if (0 == c) break;
                c--;
                e = this.readBits(cc.Codec.GZip.cplext[c]) +
                    cc.Codec.GZip.cplens[c];
                c = this.DecodeValue(this.distanceTree);
                8 < cc.Codec.GZip.cpdext[c] ? (f = this.readBits(8), f |= this.readBits(cc.Codec.GZip.cpdext[c] - 8) << 8) : f = this.readBits(cc.Codec.GZip.cpdext[c]);
                for (f += cc.Codec.GZip.cpdist[c]; e--;) b = this.buf32k[this.bIdx - f & 32767], this.addBuffer(b)
            } else this.addBuffer(c)
    }
    while (!a);
    this.flushBuffer();
    this.byteAlign();
    return 0
};
cc.Codec.GZip.prototype.unzipFile = function(a) {
    var b;
    this.gunzip();
    for (b = 0; b < this.unzipped.length; b++)
        if (this.unzipped[b][1] == a) return this.unzipped[b][0]
};
cc.Codec.GZip.prototype.nextFile = function() {
    this.outputArr = [];
    this.modeZIP = !1;
    var a = [];
    a[0] = this.readByte();
    a[1] = this.readByte();
    120 == a[0] && 218 == a[1] && (this.DeflateLoop(), this.unzipped[this.files] = [this.outputArr.join(""), "geonext.gxt"], this.files++);
    31 == a[0] && 139 == a[1] && (this.skipdir(), this.unzipped[this.files] = [this.outputArr.join(""), "file"], this.files++);
    if (80 == a[0] && 75 == a[1] && (this.modeZIP = !0, a[2] = this.readByte(), a[3] = this.readByte(), 3 == a[2] && 4 == a[3])) {
        a[0] = this.readByte();
        a[1] = this.readByte();
        this.gpflags = this.readByte();
        this.gpflags |= this.readByte() << 8;
        a = this.readByte();
        a |= this.readByte() << 8;
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        var b = this.readByte(),
            b = b | this.readByte() << 8,
            c = this.readByte(),
            c = c | this.readByte() << 8,
            d = 0;
        for (this.nameBuf = []; b--;) {
            var e = this.readByte();
            "/" == e | ":" == e ? d = 0 : d < cc.Codec.GZip.NAMEMAX - 1 && (this.nameBuf[d++] = String.fromCharCode(e))
        }
        this.fileout ||
            (this.fileout = this.nameBuf);
        for (var d = 0; d < c;) this.readByte(), d++;
        8 == a && (this.DeflateLoop(), this.unzipped[this.files] = [this.outputArr.join(""), this.nameBuf.join("")], this.files++);
        this.skipdir()
    }
};
cc.Codec.GZip.prototype.skipdir = function() {
    var a = [],
        b;
    this.gpflags & 8 && (a[0] = this.readByte(), a[1] = this.readByte(), a[2] = this.readByte(), a[3] = this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte());
    this.modeZIP && this.nextFile();
    a[0] = this.readByte();
    if (8 != a[0]) return 0;
    this.gpflags = this.readByte();
    this.readByte();
    this.readByte();
    this.readByte();
    this.readByte();
    this.readByte();
    this.readByte();
    if (this.gpflags & 4) {
        a[0] =
            this.readByte();
        a[2] = this.readByte();
        this.len = a[0] + 256 * a[1];
        for (a = 0; a < this.len; a++) this.readByte()
    }
    if (this.gpflags & 8) {
        a = 0;
        for (this.nameBuf = []; b = this.readByte();) {
            if ("7" == b || ":" == b) a = 0;
            a < cc.Codec.GZip.NAMEMAX - 1 && (this.nameBuf[a++] = b)
        }
    }
    if (this.gpflags & 16)
        for (; this.readByte(););
    this.gpflags & 2 && (this.readByte(), this.readByte());
    this.DeflateLoop();
    this.readByte();
    this.readByte();
    this.readByte();
    this.readByte();
    this.modeZIP && this.nextFile()
};
/*
 zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */
(function() {
    function a(a) {
        throw a;
    }

    function b(a, b) {
        var c = a.split("."),
            d = C;
        !(c[0] in d) && d.execScript && d.execScript("var " + c[0]);
        for (var e; c.length && (e = c.shift());)!c.length && b !== y ? d[e] = b : d = d[e] ? d[e] : d[e] = {}
    }

    function c(a) {
        if ("string" === typeof a) {
            a = a.split("");
            var b, c;
            b = 0;
            for (c = a.length; b < c; b++) a[b] = (a[b].charCodeAt(0) & 255) >>> 0
        }
        b = 1;
        c = 0;
        for (var d = a.length, e, f = 0; 0 < d;) {
            e = 1024 < d ? 1024 : d;
            d -= e;
            do b += a[f++], c += b; while (--e);
            b %= 65521;
            c %= 65521
        }
        return (c << 16 | b) >>> 0
    }

    function d(b, c) {
        this.index = "number" === typeof c ?
            c : 0;
        this.i = 0;
        this.buffer = b instanceof(z ? Uint8Array : Array) ? b : new(z ? Uint8Array : Array)(32768);
        2 * this.buffer.length <= this.index && a(Error("invalid index"));
        this.buffer.length <= this.index && this.f()
    }

    function e(a) {
        this.buffer = new(z ? Uint16Array : Array)(2 * a);
        this.length = 0
    }

    function f(a) {
        var b = a.length,
            c = 0,
            d = Number.POSITIVE_INFINITY,
            e, f, g, q, h, r, k, m, n;
        for (m = 0; m < b; ++m) a[m] > c && (c = a[m]), a[m] < d && (d = a[m]);
        e = 1 << c;
        f = new(z ? Uint32Array : Array)(e);
        g = 1;
        q = 0;
        for (h = 2; g <= c;) {
            for (m = 0; m < b; ++m)
                if (a[m] === g) {
                    r = 0;
                    k = q;
                    for (n = 0; n < g; ++n) r =
                        r << 1 | k & 1, k >>= 1;
                    for (n = r; n < e; n += h) f[n] = g << 16 | m;
                    ++q
                }++g;
            q <<= 1;
            h <<= 1
        }
        return [f, c, d]
    }

    function g(a, b) {
        this.h = L;
        this.w = 0;
        this.input = a;
        this.b = 0;
        b && (b.lazy && (this.w = b.lazy), "number" === typeof b.compressionType && (this.h = b.compressionType), b.outputBuffer && (this.a = z && b.outputBuffer instanceof Array ? new Uint8Array(b.outputBuffer) : b.outputBuffer), "number" === typeof b.outputIndex && (this.b = b.outputIndex));
        this.a || (this.a = new(z ? Uint8Array : Array)(32768))
    }

    function h(a, b) {
        this.length = a;
        this.G = b
    }

    function k() {
        var b = E;
        switch (D) {
            case 3 ===
            b:
                return [257, b - 3, 0];
            case 4 === b:
                return [258, b - 4, 0];
            case 5 === b:
                return [259, b - 5, 0];
            case 6 === b:
                return [260, b - 6, 0];
            case 7 === b:
                return [261, b - 7, 0];
            case 8 === b:
                return [262, b - 8, 0];
            case 9 === b:
                return [263, b - 9, 0];
            case 10 === b:
                return [264, b - 10, 0];
            case 12 >= b:
                return [265, b - 11, 1];
            case 14 >= b:
                return [266, b - 13, 1];
            case 16 >= b:
                return [267, b - 15, 1];
            case 18 >= b:
                return [268, b - 17, 1];
            case 22 >= b:
                return [269, b - 19, 2];
            case 26 >= b:
                return [270, b - 23, 2];
            case 30 >= b:
                return [271, b - 27, 2];
            case 34 >= b:
                return [272, b - 31, 2];
            case 42 >= b:
                return [273, b - 35, 3];
            case 50 >=
            b:
                return [274, b - 43, 3];
            case 58 >= b:
                return [275, b - 51, 3];
            case 66 >= b:
                return [276, b - 59, 3];
            case 82 >= b:
                return [277, b - 67, 4];
            case 98 >= b:
                return [278, b - 83, 4];
            case 114 >= b:
                return [279, b - 99, 4];
            case 130 >= b:
                return [280, b - 115, 4];
            case 162 >= b:
                return [281, b - 131, 5];
            case 194 >= b:
                return [282, b - 163, 5];
            case 226 >= b:
                return [283, b - 195, 5];
            case 257 >= b:
                return [284, b - 227, 5];
            case 258 === b:
                return [285, b - 258, 0];
            default:
                a("invalid length: " + b)
        }
    }

    function m(b, c) {
        function d(b, c) {
            var e = b.G,
                f = [],
                g = 0,
                q;
            q = H[b.length];
            f[g++] = q & 65535;
            f[g++] = q >> 16 & 255;
            f[g++] =
                q >> 24;
            var h;
            switch (D) {
                case 1 === e:
                    h = [0, e - 1, 0];
                    break;
                case 2 === e:
                    h = [1, e - 2, 0];
                    break;
                case 3 === e:
                    h = [2, e - 3, 0];
                    break;
                case 4 === e:
                    h = [3, e - 4, 0];
                    break;
                case 6 >= e:
                    h = [4, e - 5, 1];
                    break;
                case 8 >= e:
                    h = [5, e - 7, 1];
                    break;
                case 12 >= e:
                    h = [6, e - 9, 2];
                    break;
                case 16 >= e:
                    h = [7, e - 13, 2];
                    break;
                case 24 >= e:
                    h = [8, e - 17, 3];
                    break;
                case 32 >= e:
                    h = [9, e - 25, 3];
                    break;
                case 48 >= e:
                    h = [10, e - 33, 4];
                    break;
                case 64 >= e:
                    h = [11, e - 49, 4];
                    break;
                case 96 >= e:
                    h = [12, e - 65, 5];
                    break;
                case 128 >= e:
                    h = [13, e - 97, 5];
                    break;
                case 192 >= e:
                    h = [14, e - 129, 6];
                    break;
                case 256 >= e:
                    h = [15, e - 193, 6];
                    break;
                case 384 >= e:
                    h = [16, e - 257, 7];
                    break;
                case 512 >= e:
                    h = [17, e - 385, 7];
                    break;
                case 768 >= e:
                    h = [18, e - 513, 8];
                    break;
                case 1024 >= e:
                    h = [19, e - 769, 8];
                    break;
                case 1536 >= e:
                    h = [20, e - 1025, 9];
                    break;
                case 2048 >= e:
                    h = [21, e - 1537, 9];
                    break;
                case 3072 >= e:
                    h = [22, e - 2049, 10];
                    break;
                case 4096 >= e:
                    h = [23, e - 3073, 10];
                    break;
                case 6144 >= e:
                    h = [24, e - 4097, 11];
                    break;
                case 8192 >= e:
                    h = [25, e - 6145, 11];
                    break;
                case 12288 >= e:
                    h = [26, e - 8193, 12];
                    break;
                case 16384 >= e:
                    h = [27, e - 12289, 12];
                    break;
                case 24576 >= e:
                    h = [28, e - 16385, 13];
                    break;
                case 32768 >= e:
                    h = [29, e - 24577, 13];
                    break;
                default:
                    a("invalid distance")
            }
            q =
                h;
            f[g++] = q[0];
            f[g++] = q[1];
            f[g++] = q[2];
            e = 0;
            for (g = f.length; e < g; ++e) n[s++] = f[e];
            v[f[0]]++;
            u[f[3]]++;
            t = b.length + c - 1;
            m = null
        }
        var e, f, g, q, r, k = {},
            m, n = z ? new Uint16Array(2 * c.length) : [],
            s = 0,
            t = 0,
            v = new(z ? Uint32Array : Array)(286),
            u = new(z ? Uint32Array : Array)(30),
            w = b.w,
            C;
        if (!z) {
            for (g = 0; 285 >= g;) v[g++] = 0;
            for (g = 0; 29 >= g;) u[g++] = 0
        }
        v[256] = 1;
        e = 0;
        for (f = c.length; e < f; ++e) {
            g = r = 0;
            for (q = 3; g < q && e + g !== f; ++g) r = r << 8 | c[e + g];
            k[r] === y && (k[r] = []);
            g = k[r];
            if (!(0 < t--)) {
                for (; 0 < g.length && 32768 < e - g[0];) g.shift();
                if (e + 3 >= f) {
                    m && d(m, -1);
                    g = 0;
                    for (q = f - e; g < q; ++g) C = c[e + g], n[s++] = C, ++v[C];
                    break
                }
                if (0 < g.length) {
                    r = q = y;
                    var E = 0,
                        A = y,
                        x = y,
                        B = A = y,
                        J = c.length,
                        x = 0,
                        B = g.length;
                    a: for (; x < B; x++) {
                        q = g[B - x - 1];
                        A = 3;
                        if (3 < E) {
                            for (A = E; 3 < A; A--)
                                if (c[q + A - 1] !== c[e + A - 1]) continue a;
                            A = E
                        }
                        for (; 258 > A && e + A < J && c[q + A] === c[e + A];)++A;
                        A > E && (r = q, E = A);
                        if (258 === A) break
                    }
                    q = new h(E, e - r);
                    m ? m.length < q.length ? (C = c[e - 1], n[s++] = C, ++v[C], d(q, 0)) : d(m, -1) : q.length < w ? m = q : d(q, 0)
                } else m ? d(m, -1) : (C = c[e], n[s++] = C, ++v[C])
            }
            g.push(e)
        }
        n[s++] = 256;
        v[256]++;
        b.L = v;
        b.K = u;
        return z ? n.subarray(0, s) : n
    }

    function n(a,
        b) {
        function c(a) {
            var b = n[a][s[a]];
            b === k ? (c(a + 1), c(a + 1)) : --m[b];
            ++s[a]
        }
        var d = a.length,
            f = new e(572),
            g = new(z ? Uint8Array : Array)(d),
            q, h, r;
        if (!z)
            for (h = 0; h < d; h++) g[h] = 0;
        for (h = 0; h < d; ++h) 0 < a[h] && f.push(h, a[h]);
        d = Array(f.length / 2);
        q = new(z ? Uint32Array : Array)(f.length / 2);
        if (1 === d.length) return g[f.pop().index] = 1, g;
        h = 0;
        for (r = f.length / 2; h < r; ++h) d[h] = f.pop(), q[h] = d[h].value;
        var k = q.length;
        h = new(z ? Uint16Array : Array)(b);
        var f = new(z ? Uint8Array : Array)(b),
            m = new(z ? Uint8Array : Array)(k);
        r = Array(b);
        var n = Array(b),
            s =
            Array(b),
            t = (1 << b) - k,
            v = 1 << b - 1,
            u, y, D;
        h[b - 1] = k;
        for (u = 0; u < b; ++u) t < v ? f[u] = 0 : (f[u] = 1, t -= v), t <<= 1, h[b - 2 - u] = (h[b - 1 - u] / 2 | 0) + k;
        h[0] = f[0];
        r[0] = Array(h[0]);
        n[0] = Array(h[0]);
        for (u = 1; u < b; ++u) h[u] > 2 * h[u - 1] + f[u] && (h[u] = 2 * h[u - 1] + f[u]), r[u] = Array(h[u]), n[u] = Array(h[u]);
        for (t = 0; t < k; ++t) m[t] = b;
        for (v = 0; v < h[b - 1]; ++v) r[b - 1][v] = q[v], n[b - 1][v] = v;
        for (t = 0; t < b; ++t) s[t] = 0;
        1 === f[b - 1] && (--m[0], ++s[b - 1]);
        for (u = b - 2; 0 <= u; --u) {
            y = t = 0;
            D = s[u + 1];
            for (v = 0; v < h[u]; v++) y = r[u + 1][D] + r[u + 1][D + 1], y > q[t] ? (r[u][v] = y, n[u][v] = k, D += 2) : (r[u][v] = q[t],
                n[u][v] = t, ++t);
            s[u] = 0;
            1 === f[u] && c(u)
        }
        q = m;
        h = 0;
        for (r = d.length; h < r; ++h) g[d[h].index] = q[h];
        return g
    }

    function q(b) {
        var c = new(z ? Uint16Array : Array)(b.length),
            d = [],
            e = [],
            f = 0,
            g, q, h;
        g = 0;
        for (q = b.length; g < q; g++) d[b[g]] = (d[b[g]] | 0) + 1;
        g = 1;
        for (q = 16; g <= q; g++) e[g] = f, f += d[g] | 0, f > 1 << g && a("overcommitted"), f <<= 1;
        65536 > f && a("undercommitted");
        g = 0;
        for (q = b.length; g < q; g++) {
            f = e[b[g]];
            e[b[g]] += 1;
            d = c[g] = 0;
            for (h = b[g]; d < h; d++) c[g] = c[g] << 1 | f & 1, f >>>= 1
        }
        return c
    }

    function r(a, b) {
        this.input = a;
        this.a = new(z ? Uint8Array : Array)(32768);
        this.h =
            G.j;
        var c = {},
            d;
        if ((b || !(b = {})) && "number" === typeof b.compressionType) this.h = b.compressionType;
        for (d in b) c[d] = b[d];
        c.outputBuffer = this.a;
        this.z = new g(this.input, c)
    }

    function s(b, c) {
        this.k = [];
        this.l = 32768;
        this.e = this.g = this.c = this.q = 0;
        this.input = z ? new Uint8Array(b) : b;
        this.s = !1;
        this.m = O;
        this.B = !1;
        if (c || !(c = {})) c.index && (this.c = c.index), c.bufferSize && (this.l = c.bufferSize), c.bufferType && (this.m = c.bufferType), c.resize && (this.B = c.resize);
        switch (this.m) {
            case J:
                this.b = 32768;
                this.a = new(z ? Uint8Array : Array)(32768 +
                    this.l + 258);
                break;
            case O:
                this.b = 0;
                this.a = new(z ? Uint8Array : Array)(this.l);
                this.f = this.J;
                this.t = this.H;
                this.o = this.I;
                break;
            default:
                a(Error("invalid inflate mode"))
        }
    }

    function t(b, c) {
        for (var d = b.g, e = b.e, f = b.input, g = b.c, q; e < c;) q = f[g++], q === y && a(Error("input buffer is broken")), d |= q << e, e += 8;
        b.g = d >>> c;
        b.e = e - c;
        b.c = g;
        return d & (1 << c) - 1
    }

    function u(b, c) {
        for (var d = b.g, e = b.e, f = b.input, g = b.c, q = c[0], h = c[1], r; e < h;) r = f[g++], r === y && a(Error("input buffer is broken")), d |= r << e, e += 8;
        f = q[d & (1 << h) - 1];
        q = f >>> 16;
        b.g = d >> q;
        b.e =
            e - q;
        b.c = g;
        return f & 65535
    }

    function w(a) {
        function b(a, c, d) {
            var e, f, g, q;
            for (q = 0; q < a;) switch (e = u(this, c), e) {
                case 16:
                    for (g = 3 + t(this, 2); g--;) d[q++] = f;
                    break;
                case 17:
                    for (g = 3 + t(this, 3); g--;) d[q++] = 0;
                    f = 0;
                    break;
                case 18:
                    for (g = 11 + t(this, 7); g--;) d[q++] = 0;
                    f = 0;
                    break;
                default:
                    f = d[q++] = e
            }
            return d
        }
        var c = t(a, 5) + 257,
            d = t(a, 5) + 1,
            e = t(a, 4) + 4,
            g = new(z ? Uint8Array : Array)(R.length),
            q;
        for (q = 0; q < e; ++q) g[R[q]] = t(a, 3);
        e = f(g);
        g = new(z ? Uint8Array : Array)(c);
        q = new(z ? Uint8Array : Array)(d);
        a.o(f(b.call(a, c, e, g)), f(b.call(a, d, e, q)))
    }

    function v(b,
        c) {
        var d, e;
        this.input = b;
        this.c = 0;
        if (c || !(c = {})) c.index && (this.c = c.index), c.verify && (this.M = c.verify);
        d = b[this.c++];
        e = b[this.c++];
        switch (d & 15) {
            case N:
                this.method = N;
                break;
            default:
                a(Error("unsupported compression method"))
        }
        0 !== ((d << 8) + e) % 31 && a(Error("invalid fcheck flag:" + ((d << 8) + e) % 31));
        e & 32 && a(Error("fdict flag is not supported"));
        this.A = new s(b, {
            index: this.c,
            bufferSize: c.bufferSize,
            bufferType: c.bufferType,
            resize: c.resize
        })
    }
    var y = void 0,
        D = !0,
        C = this,
        z = "undefined" !== typeof Uint8Array && "undefined" !==
        typeof Uint16Array && "undefined" !== typeof Uint32Array;
    d.prototype.f = function() {
        var a = this.buffer,
            b, c = a.length,
            d = new(z ? Uint8Array : Array)(c << 1);
        if (z) d.set(a);
        else
            for (b = 0; b < c; ++b) d[b] = a[b];
        return this.buffer = d
    };
    d.prototype.d = function(a, b, c) {
        var d = this.buffer,
            e = this.index,
            f = this.i,
            g = d[e];
        c && 1 < b && (a = 8 < b ? (F[a & 255] << 24 | F[a >>> 8 & 255] << 16 | F[a >>> 16 & 255] << 8 | F[a >>> 24 & 255]) >> 32 - b : F[a] >> 8 - b);
        if (8 > b + f) g = g << b | a, f += b;
        else
            for (c = 0; c < b; ++c) g = g << 1 | a >> b - c - 1 & 1, 8 === ++f && (f = 0, d[e++] = F[g], g = 0, e === d.length && (d = this.f()));
        d[e] = g;
        this.buffer = d;
        this.i = f;
        this.index = e
    };
    d.prototype.finish = function() {
        var a = this.buffer,
            b = this.index,
            c;
        0 < this.i && (a[b] <<= 8 - this.i, a[b] = F[a[b]], b++);
        z ? c = a.subarray(0, b) : (a.length = b, c = a);
        return c
    };
    var A = new(z ? Uint8Array : Array)(256),
        x;
    for (x = 0; 256 > x; ++x) {
        for (var B = x, I = B, K = 7, B = B >>> 1; B; B >>>= 1) I <<= 1, I |= B & 1, --K;
        A[x] = (I << K & 255) >>> 0
    }
    var F = A,
        A = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049,
            498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275,
            3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277,
            2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143,
            2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112,
            2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918E3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746,
            711928724, 3020668471, 3272380065, 1510334235, 755167117
        ];
    z && new Uint32Array(A);
    e.prototype.getParent = function(a) {
        return 2 * ((a - 2) / 4 | 0)
    };
    e.prototype.push = function(a, b) {
        var c, d, e = this.buffer,
            f;
        c = this.length;
        e[this.length++] = b;
        for (e[this.length++] = a; 0 < c;)
            if (d = this.getParent(c), e[c] > e[d]) f = e[c], e[c] = e[d], e[d] = f, f = e[c + 1], e[c + 1] = e[d + 1], e[d + 1] = f, c = d;
            else break;
        return this.length
    };
    e.prototype.pop = function() {
        var a, b, c = this.buffer,
            d, e, f;
        b = c[0];
        a = c[1];
        this.length -= 2;
        c[0] = c[this.length];
        c[1] = c[this.length + 1];
        for (f =
            0;;) {
            e = 2 * f + 2;
            if (e >= this.length) break;
            e + 2 < this.length && c[e + 2] > c[e] && (e += 2);
            if (c[e] > c[f]) d = c[f], c[f] = c[e], c[e] = d, d = c[f + 1], c[f + 1] = c[e + 1], c[e + 1] = d;
            else break;
            f = e
        }
        return {
            index: a,
            value: b,
            length: this.length
        }
    };
    var L = 2,
        A = {
            NONE: 0,
            r: 1,
            j: L,
            N: 3
        },
        M = [];
    for (x = 0; 288 > x; x++) switch (D) {
        case 143 >= x:
            M.push([x + 48, 8]);
            break;
        case 255 >= x:
            M.push([x - 144 + 400, 9]);
            break;
        case 279 >= x:
            M.push([x - 256 + 0, 7]);
            break;
        case 287 >= x:
            M.push([x - 280 + 192, 8]);
            break;
        default:
            a("invalid literal: " + x)
    }
    g.prototype.n = function() {
        var b, c, e, f, g = this.input;
        switch (this.h) {
            case 0:
                e = 0;
                for (f = g.length; e < f;) {
                    c = z ? g.subarray(e, e + 65535) : g.slice(e, e + 65535);
                    e += c.length;
                    var h = e === f,
                        r = y,
                        k = r = y,
                        k = r = y,
                        s = this.a,
                        t = this.b;
                    if (z) {
                        for (s = new Uint8Array(this.a.buffer); s.length <= t + c.length + 5;) s = new Uint8Array(s.length << 1);
                        s.set(this.a)
                    }
                    r = h ? 1 : 0;
                    s[t++] = r | 0;
                    r = c.length;
                    k = ~r + 65536 & 65535;
                    s[t++] = r & 255;
                    s[t++] = r >>> 8 & 255;
                    s[t++] = k & 255;
                    s[t++] = k >>> 8 & 255;
                    if (z) s.set(c, t), t += c.length, s = s.subarray(0, t);
                    else {
                        r = 0;
                        for (k = c.length; r < k; ++r) s[t++] = c[r];
                        s.length = t
                    }
                    this.b = t;
                    this.a = s
                }
                break;
            case 1:
                e =
                    new d(new Uint8Array(this.a.buffer), this.b);
                e.d(1, 1, D);
                e.d(1, 2, D);
                g = m(this, g);
                c = 0;
                for (h = g.length; c < h; c++)
                    if (f = g[c], d.prototype.d.apply(e, M[f]), 256 < f) e.d(g[++c], g[++c], D), e.d(g[++c], 5), e.d(g[++c], g[++c], D);
                    else if (256 === f) break;
                this.a = e.finish();
                this.b = this.a.length;
                break;
            case L:
                f = new d(new Uint8Array(this.a), this.b);
                var v, u, w, C = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
                    A, E, r = Array(19),
                    x, s = L;
                f.d(1, 1, D);
                f.d(s, 2, D);
                g = m(this, g);
                k = n(this.L, 15);
                A = q(k);
                s = n(this.K, 7);
                t = q(s);
                for (v = 286; 257 < v && 0 === k[v -
                    1]; v--);
                for (u = 30; 1 < u && 0 === s[u - 1]; u--);
                var B = v,
                    J = u;
                b = new(z ? Uint32Array : Array)(B + J);
                var G = new(z ? Uint32Array : Array)(316),
                    F, H;
                E = new(z ? Uint8Array : Array)(19);
                for (x = w = 0; x < B; x++) b[w++] = k[x];
                for (x = 0; x < J; x++) b[w++] = s[x];
                if (!z) {
                    x = 0;
                    for (J = E.length; x < J; ++x) E[x] = 0
                }
                x = F = 0;
                for (J = b.length; x < J; x += w) {
                    for (w = 1; x + w < J && b[x + w] === b[x]; ++w);
                    B = w;
                    if (0 === b[x])
                        if (3 > B)
                            for (; 0 < B--;) G[F++] = 0, E[0]++;
                        else
                            for (; 0 < B;) H = 138 > B ? B : 138, H > B - 3 && H < B && (H = B - 3), 10 >= H ? (G[F++] = 17, G[F++] = H - 3, E[17]++) : (G[F++] = 18, G[F++] = H - 11, E[18]++), B -= H;
                    else if (G[F++] =
                        b[x], E[b[x]]++, B--, 3 > B)
                        for (; 0 < B--;) G[F++] = b[x], E[b[x]]++;
                    else
                        for (; 0 < B;) H = 6 > B ? B : 6, H > B - 3 && H < B && (H = B - 3), G[F++] = 16, G[F++] = H - 3, E[16]++, B -= H
                }
                b = z ? G.subarray(0, F) : G.slice(0, F);
                E = n(E, 7);
                for (x = 0; 19 > x; x++) r[x] = E[C[x]];
                for (w = 19; 4 < w && 0 === r[w - 1]; w--);
                C = q(E);
                f.d(v - 257, 5, D);
                f.d(u - 1, 5, D);
                f.d(w - 4, 4, D);
                for (x = 0; x < w; x++) f.d(r[x], 3, D);
                x = 0;
                for (r = b.length; x < r; x++)
                    if (c = b[x], f.d(C[c], E[c], D), 16 <= c) {
                        x++;
                        switch (c) {
                            case 16:
                                h = 2;
                                break;
                            case 17:
                                h = 3;
                                break;
                            case 18:
                                h = 7;
                                break;
                            default:
                                a("invalid code: " + c)
                        }
                        f.d(b[x], h, D)
                    }
                h = [A, k];
                t = [t,
                    s
                ];
                c = h[0];
                h = h[1];
                s = t[0];
                A = t[1];
                t = 0;
                for (r = g.length; t < r; ++t)
                    if (e = g[t], f.d(c[e], h[e], D), 256 < e) f.d(g[++t], g[++t], D), k = g[++t], f.d(s[k], A[k], D), f.d(g[++t], g[++t], D);
                    else if (256 === e) break;
                this.a = f.finish();
                this.b = this.a.length;
                break;
            default:
                a("invalid compression type")
        }
        return this.a
    };
    x = [];
    var E;
    for (E = 3; 258 >= E; E++) B = k(), x[E] = B[2] << 24 | B[1] << 16 | B[0];
    var H = z ? new Uint32Array(x) : x,
        G = A;
    r.prototype.n = function() {
        var b, d, e, f, g = 0;
        f = this.a;
        b = N;
        switch (b) {
            case N:
                d = Math.LOG2E * Math.log(32768) - 8;
                break;
            default:
                a(Error("invalid compression method"))
        }
        d =
            d << 4 | b;
        f[g++] = d;
        switch (b) {
            case N:
                switch (this.h) {
                    case G.NONE:
                        e = 0;
                        break;
                    case G.r:
                        e = 1;
                        break;
                    case G.j:
                        e = 2;
                        break;
                    default:
                        a(Error("unsupported compression type"))
                }
                break;
            default:
                a(Error("invalid compression method"))
        }
        b = e << 6 | 0;
        f[g++] = b | 31 - (256 * d + b) % 31;
        b = c(this.input);
        this.z.b = g;
        f = this.z.n();
        g = f.length;
        z && (f = new Uint8Array(f.buffer), f.length <= g + 4 && (this.a = new Uint8Array(f.length + 4), this.a.set(f), f = this.a), f = f.subarray(0, g + 4));
        f[g++] = b >> 24 & 255;
        f[g++] = b >> 16 & 255;
        f[g++] = b >> 8 & 255;
        f[g++] = b & 255;
        return f
    };
    b("Zlib.Deflate",
        r);
    b("Zlib.Deflate.compress", function(a, b) {
        return (new r(a, b)).n()
    });
    b("Zlib.Deflate.CompressionType", G);
    b("Zlib.Deflate.CompressionType.NONE", G.NONE);
    b("Zlib.Deflate.CompressionType.FIXED", G.r);
    b("Zlib.Deflate.CompressionType.DYNAMIC", G.j);
    var J = 0,
        O = 1,
        A = {
            D: J,
            C: O
        };
    s.prototype.p = function() {
        for (; !this.s;) {
            var b = t(this, 3);
            b & 1 && (this.s = D);
            b >>>= 1;
            switch (b) {
                case 0:
                    var b = this.input,
                        c = this.c,
                        d = this.a,
                        e = this.b,
                        f = y,
                        g = y,
                        q = y,
                        h = d.length,
                        f = y;
                    this.e = this.g = 0;
                    f = b[c++];
                    f === y && a(Error("invalid uncompressed block header: LEN (first byte)"));
                    g = f;
                    f = b[c++];
                    f === y && a(Error("invalid uncompressed block header: LEN (second byte)"));
                    g |= f << 8;
                    f = b[c++];
                    f === y && a(Error("invalid uncompressed block header: NLEN (first byte)"));
                    q = f;
                    f = b[c++];
                    f === y && a(Error("invalid uncompressed block header: NLEN (second byte)"));
                    q |= f << 8;
                    g === ~q && a(Error("invalid uncompressed block header: length verify"));
                    c + g > b.length && a(Error("input buffer is broken"));
                    switch (this.m) {
                        case J:
                            for (; e + g > d.length;) {
                                f = h - e;
                                g -= f;
                                if (z) d.set(b.subarray(c, c + f), e), e += f, c += f;
                                else
                                    for (; f--;) d[e++] =
                                        b[c++];
                                this.b = e;
                                d = this.f();
                                e = this.b
                            }
                            break;
                        case O:
                            for (; e + g > d.length;) d = this.f({
                                v: 2
                            });
                            break;
                        default:
                            a(Error("invalid inflate mode"))
                    }
                    if (z) d.set(b.subarray(c, c + g), e), e += g, c += g;
                    else
                        for (; g--;) d[e++] = b[c++];
                    this.c = c;
                    this.b = e;
                    this.a = d;
                    break;
                case 1:
                    this.o(U, V);
                    break;
                case 2:
                    w(this);
                    break;
                default:
                    a(Error("unknown BTYPE: " + b))
            }
        }
        return this.t()
    };
    x = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var R = z ? new Uint16Array(x) : x;
    x = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227,
        258, 258, 258
    ];
    var S = z ? new Uint16Array(x) : x;
    x = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0];
    var P = z ? new Uint8Array(x) : x;
    x = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
    var T = z ? new Uint16Array(x) : x;
    x = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
    var Q = z ? new Uint8Array(x) : x;
    x = new(z ? Uint8Array : Array)(288);
    B = 0;
    for (I = x.length; B < I; ++B) x[B] = 143 >= B ? 8 : 255 >= B ? 9 : 279 >= B ? 7 : 8;
    var U = f(x);
    x = new(z ? Uint8Array :
        Array)(30);
    B = 0;
    for (I = x.length; B < I; ++B) x[B] = 5;
    var V = f(x);
    s.prototype.o = function(a, b) {
        var c = this.a,
            d = this.b;
        this.u = a;
        for (var e = c.length - 258, f, g, q; 256 !== (f = u(this, a));)
            if (256 > f) d >= e && (this.b = d, c = this.f(), d = this.b), c[d++] = f;
            else {
                f -= 257;
                q = S[f];
                0 < P[f] && (q += t(this, P[f]));
                f = u(this, b);
                g = T[f];
                0 < Q[f] && (g += t(this, Q[f]));
                for (d >= e && (this.b = d, c = this.f(), d = this.b); q--;) c[d] = c[d++-g]
            }
        for (; 8 <= this.e;) this.e -= 8, this.c--;
        this.b = d
    };
    s.prototype.I = function(a, b) {
        var c = this.a,
            d = this.b;
        this.u = a;
        for (var e = c.length, f, g, q; 256 !==
            (f = u(this, a));)
            if (256 > f) d >= e && (c = this.f(), e = c.length), c[d++] = f;
            else {
                f -= 257;
                q = S[f];
                0 < P[f] && (q += t(this, P[f]));
                f = u(this, b);
                g = T[f];
                0 < Q[f] && (g += t(this, Q[f]));
                for (d + q > e && (c = this.f(), e = c.length); q--;) c[d] = c[d++-g]
            }
        for (; 8 <= this.e;) this.e -= 8, this.c--;
        this.b = d
    };
    s.prototype.f = function() {
        var a = new(z ? Uint8Array : Array)(this.b - 32768),
            b = this.b - 32768,
            c, d, e = this.a;
        if (z) a.set(e.subarray(32768, a.length));
        else {
            c = 0;
            for (d = a.length; c < d; ++c) a[c] = e[c + 32768]
        }
        this.k.push(a);
        this.q += a.length;
        if (z) e.set(e.subarray(b, b + 32768));
        else
            for (c = 0; 32768 > c; ++c) e[c] = e[b + c];
        this.b = 32768;
        return e
    };
    s.prototype.J = function(a) {
        var b, c = this.input.length / this.c + 1 | 0,
            d, e, f, g = this.input,
            q = this.a;
        a && ("number" === typeof a.v && (c = a.v), "number" === typeof a.F && (c += a.F));
        2 > c ? (d = (g.length - this.c) / this.u[2], f = 258 * (d / 2) | 0, e = f < q.length ? q.length + f : q.length << 1) : e = q.length * c;
        z ? (b = new Uint8Array(e), b.set(q)) : b = q;
        return this.a = b
    };
    s.prototype.t = function() {
        var a = 0,
            b = this.a,
            c = this.k,
            d, e = new(z ? Uint8Array : Array)(this.q + (this.b - 32768)),
            f, g, q, h;
        if (0 === c.length) return z ?
            this.a.subarray(32768, this.b) : this.a.slice(32768, this.b);
        f = 0;
        for (g = c.length; f < g; ++f) {
            d = c[f];
            q = 0;
            for (h = d.length; q < h; ++q) e[a++] = d[q]
        }
        f = 32768;
        for (g = this.b; f < g; ++f) e[a++] = b[f];
        this.k = [];
        return this.buffer = e
    };
    s.prototype.H = function() {
        var a, b = this.b;
        z ? this.B ? (a = new Uint8Array(b), a.set(this.a.subarray(0, b))) : a = this.a.subarray(0, b) : (this.a.length > b && (this.a.length = b), a = this.a);
        return this.buffer = a
    };
    v.prototype.p = function() {
        var b = this.input,
            d, e;
        d = this.A.p();
        this.c = this.A.c;
        this.M && (e = (b[this.c++] << 24 | b[this.c++] <<
            16 | b[this.c++] << 8 | b[this.c++]) >>> 0, e !== c(d) && a(Error("invalid adler-32 checksum")));
        return d
    };
    b("Zlib.Inflate", v);
    b("Zlib.Inflate.BufferType", A);
    A.ADAPTIVE = A.C;
    A.BLOCK = A.D;
    b("Zlib.Inflate.prototype.decompress", v.prototype.p);
    A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    z && new Uint16Array(A);
    A = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258];
    z && new Uint16Array(A);
    A = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0];
    z && new Uint8Array(A);
    A = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
    z && new Uint16Array(A);
    A = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
    z && new Uint8Array(A);
    A = new(z ? Uint8Array : Array)(288);
    x = 0;
    for (B = A.length; x < B; ++x) A[x] = 143 >= x ? 8 : 255 >= x ? 9 : 279 >= x ? 7 : 8;
    f(A);
    A = new(z ? Uint8Array : Array)(30);
    x = 0;
    for (B = A.length; x < B; ++x) A[x] = 5;
    f(A);
    var N = 8
}).call(this);
_p = window;
_p = _p.Zlib = _p.Zlib;
_p.Deflate = _p.Deflate;
_p.Deflate.compress = _p.Deflate.compress;
_p.Inflate = _p.Inflate;
_p.Inflate.BufferType = _p.Inflate.BufferType;
_p.Inflate.prototype.decompress = _p.Inflate.prototype.decompress;
cc.TGA_OK = 0;
cc.TGA_ERROR_FILE_OPEN = 1;
cc.TGA_ERROR_READING_FILE = 2;
cc.TGA_ERROR_INDEXED_COLOR = 3;
cc.TGA_ERROR_MEMORY = 4;
cc.TGA_ERROR_COMPRESSED_FILE = 5;
cc.ImageTGA = function(a, b, c, d, e, f, g) {
    this.status = a || 0;
    this.type = b || 0;
    this.pixelDepth = c || 0;
    this.width = d || 0;
    this.height = e || 0;
    this.imageData = f || [];
    this.flipped = g || 0
};
cc.tgaLoadHeader = function(a, b, c) {
    var d = 2;
    if (d + 1 > b) return !1;
    a = new cc.BinaryStreamReader(a);
    a.setOffset(d);
    c.type = a.readByte();
    d += 10;
    if (d + 4 + 1 > b) return !1;
    a.setOffset(d);
    c.width = a.readUnsignedShort();
    c.height = a.readUnsignedInteger();
    c.pixelDepth = a.readByte();
    if (d + 5 + 1 > b) return !1;
    b = a.readByte();
    c.flipped = 0;
    b & 32 && (c.flipped = 1);
    return !0
};
cc.tgaLoadImageData = function(a, b, c) {
    var d, e;
    d = 0 | c.pixelDepth / 2;
    e = c.height * c.width * d;
    if (18 + e > b) return !1;
    c.imageData = cc.__getSubArray(a, 18, 18 + e);
    if (3 <= d)
        for (a = 0; a < e; a += d) b = c.imageData[a], c.imageData[a] = c.imageData[a + 2], c.imageData[a + 2] = b;
    return !0
};
cc.tgaRGBtogreyscale = function(a) {
    var b, c;
    if (8 !== a.pixelDepth) {
        var d = a.pixelDepth / 8,
            e = new Uint8Array(a.height * a.width);
        if (null !== e) {
            for (c = b = 0; c < a.width * a.height; b += d, c++) e[c] = 0.3 * a.imageData[b] + 0.59 * a.imageData[b + 1] + 0.11 * a.imageData[b + 2];
            a.pixelDepth = 8;
            a.type = 3;
            a.imageData = e
        }
    }
};
cc.tgaDestroy = function(a) {
    a && (a.imageData = null)
};
cc.tgaLoadRLEImageData = function(a, b, c) {
    var d, e, f, g = 0,
        h = 0,
        k = 0,
        m = [],
        n = 0,
        q = 18;
    d = c.pixelDepth / 8;
    e = c.height * c.width;
    for (f = 0; f < e; f++) {
        if (0 != n) n--, h = 0 != k;
        else {
            if (q + 1 > b) break;
            n = a[q];
            q += 1;
            (k = n & 128) && (n -= 128);
            h = 0
        } if (!h) {
            if (q + d > b) break;
            m = cc.__getSubArray(a, q, q + d);
            q += d;
            3 <= d && (h = m[0], m[0] = m[2], m[2] = h)
        }
        for (h = 0; h < d; h++) c.imageData[g + h] = m[h];
        g += d
    }
    return !0
};
cc.tgaFlipImage = function(a) {
    for (var b = a.width * (a.pixelDepth / 8), c = 0; c < a.height / 2; c++) {
        var d = cc.__getSubArray(a.imageData, c * b, c * b + b);
        cc.__setDataToArray(cc.__getSubArray(a.imageData, (a.height - (c + 1)) * b, b), a.imageData, c * b);
        cc.__setDataToArray(d, a.imageData, (a.height - (c + 1)) * b)
    }
    a.flipped = 0
};
cc.__getSubArray = function(a, b, c) {
    return a instanceof Array ? a.slice(b, c) : a.subarray(b, c)
};
cc.__setDataToArray = function(a, b, c) {
    for (var d = 0; d < a.length; d++) b[c + d] = a[d]
};
cc.BinaryStreamReader = cc.Class.extend({
    _binaryData: null,
    _offset: 0,
    ctor: function(a) {
        this._binaryData = a
    },
    setBinaryData: function(a) {
        this._binaryData = a;
        this._offset = 0
    },
    getBinaryData: function() {
        return this._binaryData
    },
    _checkSize: function(a) {
        if (!(this._offset + Math.ceil(a / 8) < this._data.length)) throw Error("Index out of bound");
    },
    _decodeFloat: function(a, b) {
        var c = a + b + 1,
            d = c >> 3;
        this._checkSize(c);
        var c = Math.pow(2, b - 1) - 1,
            e = this._readBits(a + b, 1, d),
            f = this._readBits(a, b, d),
            g = 0,
            h = 2,
            k = 0;
        do
            for (var m = this._readByte(++k,
                d), n = a % 8 || 8, q = 1 << n; q >>= 1;) m & q && (g += 1 / h), h *= 2; while (a -= n);
        this._offset += d;
        return f == (c << 1) + 1 ? g ? NaN : e ? -Infinity : Infinity : (1 + -2 * e) * (f || g ? !f ? Math.pow(2, -c + 1) * g : Math.pow(2, f - c) * (1 + g) : 0)
    },
    _readByte: function(a, b) {
        return this._data[this._offset + b - a - 1]
    },
    _decodeInt: function(a, b) {
        var c = this._readBits(0, a, a / 8),
            d = Math.pow(2, a);
        this._offset += a / 8;
        return b && c >= d / 2 ? c - d : c
    },
    _shl: function(a, b) {
        for (++b; --b; a = 1073741824 == ((a %= 2147483648) & 1073741824) ? 2 * a : 2 * (a - 1073741824) + 2147483648);
        return a
    },
    _readBits: function(a, b, c) {
        var d =
            (a + b) % 8,
            e = a % 8,
            f = c - (a >> 3) - 1;
        a = c + (-(a + b) >> 3);
        var g = f - a;
        b = this._readByte(f, c) >> e & (1 << (g ? 8 - e : b)) - 1;
        for (g && d && (b += (this._readByte(a++, c) & (1 << d) - 1) << (g-- << 3) - e); g;) b += this._shl(this._readByte(a++, c), (g-- << 3) - e);
        return b
    },
    readInteger: function() {
        return this._decodeInt(32, !0)
    },
    readUnsignedInteger: function() {
        return this._decodeInt(32, !1)
    },
    readSingle: function() {
        return this._decodeFloat(23, 8)
    },
    readShort: function() {
        return this._decodeInt(16, !0)
    },
    readUnsignedShort: function() {
        return this._decodeInt(16, !1)
    },
    readByte: function() {
        var a =
            this._data[this._offset];
        this._offset += 1;
        return a
    },
    readData: function(a, b) {
        return this._binaryData instanceof Array ? this._binaryData.slice(a, b) : this._binaryData.subarray(a, b)
    },
    setOffset: function(a) {
        this._offset = a
    },
    getOffset: function() {
        return this._offset
    }
});
cc.TMX_ORIENTATION_ORTHO = 0;
cc.TMX_ORIENTATION_HEX = 1;
cc.TMX_ORIENTATION_ISO = 2;
cc.TMXTiledMap = cc.Node.extend({
    properties: null,
    mapOrientation: null,
    objectGroups: null,
    _mapSize: null,
    _tileSize: null,
    _tileProperties: null,
    _className: "TMXTiledMap",
    ctor: function(a, b) {
        cc.Node.prototype.ctor.call(this);
        this._mapSize = cc.size(0, 0);
        this._tileSize = cc.size(0, 0);
        void 0 !== b ? this.initWithXML(a, b) : void 0 !== a && this.initWithTMXFile(a)
    },
    getMapSize: function() {
        return cc.size(this._mapSize.width, this._mapSize.height)
    },
    setMapSize: function(a) {
        this._mapSize.width = a.width;
        this._mapSize.height = a.height
    },
    _getMapWidth: function() {
        return this._mapSize.width
    },
    _setMapWidth: function(a) {
        this._mapSize.width = a
    },
    _getMapHeight: function() {
        return this._mapSize.height
    },
    _setMapHeight: function(a) {
        this._mapSize.height = a
    },
    getTileSize: function() {
        return cc.size(this._tileSize.width, this._tileSize.height)
    },
    setTileSize: function(a) {
        this._tileSize.width = a.width;
        this._tileSize.height = a.height
    },
    _getTileWidth: function() {
        return this._tileSize.width
    },
    _setTileWidth: function(a) {
        this._tileSize.width = a
    },
    _getTileHeight: function() {
        return this._tileSize.height
    },
    _setTileHeight: function(a) {
        this._tileSize.height =
            a
    },
    getMapOrientation: function() {
        return this.mapOrientation
    },
    setMapOrientation: function(a) {
        this.mapOrientation = a
    },
    getObjectGroups: function() {
        return this.objectGroups
    },
    setObjectGroups: function(a) {
        this.objectGroups = a
    },
    getProperties: function() {
        return this.properties
    },
    setProperties: function(a) {
        this.properties = a
    },
    initWithTMXFile: function(a) {
        if (!a || 0 == a.length) throw "cc.TMXTiledMap.initWithTMXFile(): tmxFile should be non-null or non-empty string.";
        this.height = this.width = 0;
        a = new cc.TMXMapInfo(a);
        if (!a) return !1;
        var b = a.getTilesets();
        (!b || 0 === b.length) && cc.log("cc.TMXTiledMap.initWithTMXFile(): Map not found. Please check the filename.");
        this._buildWithMapInfo(a);
        return !0
    },
    initWithXML: function(a, b) {
        this.height = this.width = 0;
        var c = new cc.TMXMapInfo(a, b),
            d = c.getTilesets();
        (!d || 0 === d.length) && cc.log("cc.TMXTiledMap.initWithXML(): Map not found. Please check the filename.");
        this._buildWithMapInfo(c);
        return !0
    },
    _buildWithMapInfo: function(a) {
        this._mapSize = a.getMapSize();
        this._tileSize = a.getTileSize();
        this.mapOrientation =
            a.orientation;
        this.objectGroups = a.getObjectGroups();
        this.properties = a.properties;
        this._tileProperties = a.getTileProperties();
        var b = 0,
            c = a.getLayers();
        if (c)
            for (var d = null, e = 0, f = c.length; e < f; e++)
                if ((d = c[e]) && d.visible) d = this._parseLayer(d, a), this.addChild(d, b, b), this.width = Math.max(this.width, d.width), this.height = Math.max(this.height, d.height), b++
    },
    allLayers: function() {
        for (var a = [], b = this._children, c = 0, d = b.length; c < d; c++) {
            var e = b[c];
            e && e instanceof cc.TMXLayer && a.push(e)
        }
        return a
    },
    getLayer: function(a) {
        if (!a ||
            0 === a.length) throw "cc.TMXTiledMap.getLayer(): layerName should be non-null or non-empty string.";
        for (var b = this._children, c = 0; c < b.length; c++) {
            var d = b[c];
            if (d && d.layerName == a) return d
        }
        return null
    },
    getObjectGroup: function(a) {
        if (!a || 0 === a.length) throw "cc.TMXTiledMap.getObjectGroup(): groupName should be non-null or non-empty string.";
        if (this.objectGroups)
            for (var b = 0; b < this.objectGroups.length; b++) {
                var c = this.objectGroups[b];
                if (c && c.groupName == a) return c
            }
        return null
    },
    getProperty: function(a) {
        return this.properties[a.toString()]
    },
    propertiesForGID: function(a) {
        cc.log("propertiesForGID is deprecated. Please use getPropertiesForGID instead.");
        return this.getPropertiesForGID[a]
    },
    getPropertiesForGID: function(a) {
        return this._tileProperties[a]
    },
    _parseLayer: function(a, b) {
        var c = this._tilesetForLayer(a, b),
            c = new cc.TMXLayer(c, a, b);
        a.ownTiles = !1;
        c.setupTiles();
        return c
    },
    _tilesetForLayer: function(a, b) {
        var c = a._layerSize,
            d = b.getTilesets();
        if (d)
            for (var e = d.length - 1; 0 <= e; e--) {
                var f = d[e];
                if (f)
                    for (var g = 0; g < c.height; g++)
                        for (var h = 0; h < c.width; h++) {
                            var k =
                                a._tiles[h + c.width * g];
                            if (0 != k && (k & cc.TMX_TILE_FLIPPED_MASK) >>> 0 >= f.firstGid) return f
                        }
            }
        cc.log("cocos2d: Warning: TMX Layer " + a.name + " has no tiles");
        return null
    }
});
_p = cc.TMXTiledMap.prototype;
cc.defineGetterSetter(_p, "mapWidth", _p._getMapWidth, _p._setMapWidth);
cc.defineGetterSetter(_p, "mapHeight", _p._getMapHeight, _p._setMapHeight);
cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth);
cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight);
cc.TMXTiledMap.create = function(a, b) {
    return new cc.TMXTiledMap(a, b)
};
cc.TMX_PROPERTY_NONE = 0;
cc.TMX_PROPERTY_MAP = 1;
cc.TMX_PROPERTY_LAYER = 2;
cc.TMX_PROPERTY_OBJECTGROUP = 3;
cc.TMX_PROPERTY_OBJECT = 4;
cc.TMX_PROPERTY_TILE = 5;
cc.TMX_TILE_HORIZONTAL_FLAG = 2147483648;
cc.TMX_TILE_VERTICAL_FLAG = 1073741824;
cc.TMX_TILE_DIAGONAL_FLAG = 536870912;
cc.TMX_TILE_FLIPPED_ALL = (cc.TMX_TILE_HORIZONTAL_FLAG | cc.TMX_TILE_VERTICAL_FLAG | cc.TMX_TILE_DIAGONAL_FLAG) >>> 0;
cc.TMX_TILE_FLIPPED_MASK = ~cc.TMX_TILE_FLIPPED_ALL >>> 0;
cc.TMXLayerInfo = cc.Class.extend({
    properties: null,
    name: "",
    _layerSize: null,
    _tiles: null,
    visible: null,
    _opacity: null,
    ownTiles: !0,
    _minGID: 1E5,
    _maxGID: 0,
    offset: null,
    ctor: function() {
        this.properties = [];
        this.name = "";
        this._layerSize = null;
        this._tiles = [];
        this.visible = !0;
        this._opacity = 0;
        this.ownTiles = !0;
        this._minGID = 1E5;
        this._maxGID = 0;
        this.offset = cc.p(0, 0)
    },
    getProperties: function() {
        return this.properties
    },
    setProperties: function(a) {
        this.properties = a
    }
});
cc.TMXTilesetInfo = cc.Class.extend({
    name: "",
    firstGid: 0,
    _tileSize: null,
    spacing: 0,
    margin: 0,
    sourceImage: "",
    imageSize: null,
    ctor: function() {
        this._tileSize = cc.size(0, 0);
        this.imageSize = cc.size(0, 0)
    },
    rectForGID: function(a) {
        var b = cc.rect(0, 0, 0, 0);
        b.width = this._tileSize.width;
        b.height = this._tileSize.height;
        a &= cc.TMX_TILE_FLIPPED_MASK;
        a -= parseInt(this.firstGid, 10);
        var c = parseInt((this.imageSize.width - 2 * this.margin + this.spacing) / (this._tileSize.width + this.spacing), 10);
        b.x = parseInt(a % c * (this._tileSize.width + this.spacing) +
            this.margin, 10);
        b.y = parseInt(parseInt(a / c, 10) * (this._tileSize.height + this.spacing) + this.margin, 10);
        return b
    }
});
cc.TMXMapInfo = cc.SAXParser.extend({
    properties: null,
    orientation: null,
    parentElement: null,
    parentGID: null,
    layerAttrs: 0,
    storingCharacters: !1,
    tmxFileName: null,
    currentString: null,
    _objectGroups: null,
    _mapSize: null,
    _tileSize: null,
    _layers: null,
    _tilesets: null,
    _tileProperties: null,
    _resources: "",
    _currentFirstGID: 0,
    ctor: function(a, b) {
        cc.SAXParser.prototype.ctor.apply(this);
        this._mapSize = cc.size(0, 0);
        this._tileSize = cc.size(0, 0);
        this._layers = [];
        this._tilesets = [];
        this._objectGroups = [];
        this.properties = [];
        this._tileProperties = {};
        this._currentFirstGID = 0;
        void 0 !== b ? this.initWithXML(a, b) : void 0 !== a && this.initWithTMXFile(a)
    },
    getOrientation: function() {
        return this.orientation
    },
    setOrientation: function(a) {
        this.orientation = a
    },
    getMapSize: function() {
        return cc.size(this._mapSize.width, this._mapSize.height)
    },
    setMapSize: function(a) {
        this._mapSize.width = a.width;
        this._mapSize.height = a.height
    },
    _getMapWidth: function() {
        return this._mapSize.width
    },
    _setMapWidth: function(a) {
        this._mapSize.width = a
    },
    _getMapHeight: function() {
        return this._mapSize.height
    },
    _setMapHeight: function(a) {
        this._mapSize.height = a
    },
    getTileSize: function() {
        return cc.size(this._tileSize.width, this._tileSize.height)
    },
    setTileSize: function(a) {
        this._tileSize.width = a.width;
        this._tileSize.height = a.height
    },
    _getTileWidth: function() {
        return this._tileSize.width
    },
    _setTileWidth: function(a) {
        this._tileSize.width = a
    },
    _getTileHeight: function() {
        return this._tileSize.height
    },
    _setTileHeight: function(a) {
        this._tileSize.height = a
    },
    getLayers: function() {
        return this._layers
    },
    setLayers: function(a) {
        this._layers.push(a)
    },
    getTilesets: function() {
        return this._tilesets
    },
    setTilesets: function(a) {
        this._tilesets.push(a)
    },
    getObjectGroups: function() {
        return this._objectGroups
    },
    setObjectGroups: function(a) {
        this._objectGroups.push(a)
    },
    getParentElement: function() {
        return this.parentElement
    },
    setParentElement: function(a) {
        this.parentElement = a
    },
    getParentGID: function() {
        return this.parentGID
    },
    setParentGID: function(a) {
        this.parentGID = a
    },
    getLayerAttribs: function() {
        return this.layerAttrs
    },
    setLayerAttribs: function(a) {
        this.layerAttrs = a
    },
    getStoringCharacters: function() {
        return this.storingCharacters
    },
    setStoringCharacters: function(a) {
        this.storingCharacters = a
    },
    getProperties: function() {
        return this.properties
    },
    setProperties: function(a) {
        this.properties = a
    },
    initWithTMXFile: function(a) {
        this._internalInit(a, null);
        return this.parseXMLFile(a)
    },
    initWithXML: function(a, b) {
        this._internalInit(null, b);
        return this.parseXMLString(a)
    },
    parseXMLFile: function(a, b) {
        var c = (b = b || !1) ? a : cc.loader.getRes(a);
        if (!c) throw "Please load the resource first : " + a;
        var d, e, c = this._parseXML(c).documentElement;
        d = c.getAttribute("version");
        e = c.getAttribute("orientation");
        if ("map" == c.nodeName && ("1.0" != d && null !== d && cc.log("cocos2d: TMXFormat: Unsupported TMX version:" + d), "orthogonal" == e ? this.orientation = cc.TMX_ORIENTATION_ORTHO : "isometric" == e ? this.orientation = cc.TMX_ORIENTATION_ISO : "hexagonal" == e ? this.orientation = cc.TMX_ORIENTATION_HEX : null !== e && cc.log("cocos2d: TMXFomat: Unsupported orientation:" + e), d = cc.size(0, 0), d.width = parseFloat(c.getAttribute("width")), d.height = parseFloat(c.getAttribute("height")), this.setMapSize(d), d = cc.size(0,
            0), d.width = parseFloat(c.getAttribute("tilewidth")), d.height = parseFloat(c.getAttribute("tileheight")), this.setTileSize(d), e = c.querySelectorAll("map \x3e properties \x3e  property"))) {
            var f = {};
            for (d = 0; d < e.length; d++) f[e[d].getAttribute("name")] = e[d].getAttribute("value");
            this.properties = f
        }
        f = c.getElementsByTagName("tileset");
        "map" !== c.nodeName && (f = [], f.push(c));
        for (d = 0; d < f.length; d++) {
            e = f[d];
            var g = e.getAttribute("source");
            if (g) e = b ? cc.path.join(this._resources, g) : cc.path.changeBasename(a, g), this.parseXMLFile(e);
            else {
                g = new cc.TMXTilesetInfo;
                g.name = e.getAttribute("name") || "";
                g.firstGid = parseInt(e.getAttribute("firstgid")) || 0;
                g.spacing = parseInt(e.getAttribute("spacing")) || 0;
                g.margin = parseInt(e.getAttribute("margin")) || 0;
                var h = cc.size(0, 0);
                h.width = parseFloat(e.getAttribute("tilewidth"));
                h.height = parseFloat(e.getAttribute("tileheight"));
                g._tileSize = h;
                var h = e.getElementsByTagName("image")[0].getAttribute("source"),
                    k = -1;
                this.tmxFileName && (k = this.tmxFileName.lastIndexOf("/")); - 1 !== k ? (k = this.tmxFileName.substr(0,
                    k + 1), g.sourceImage = k + h) : g.sourceImage = this._resources + (this._resources ? "/" : "") + h;
                this.setTilesets(g);
                if (h = e.getElementsByTagName("tile"))
                    for (k = 0; k < h.length; k++) {
                        e = h[k];
                        this.parentGID = parseInt(g.firstGid) + parseInt(e.getAttribute("id") || 0);
                        var m = e.querySelectorAll("properties \x3e property");
                        if (m) {
                            var n = {};
                            for (e = 0; e < m.length; e++) {
                                var q = m[e].getAttribute("name");
                                n[q] = m[e].getAttribute("value")
                            }
                            this._tileProperties[this.parentGID] = n
                        }
                    }
            }
        }
        if (f = c.getElementsByTagName("layer"))
            for (d = 0; d < f.length; d++) {
                h = f[d];
                k = h.getElementsByTagName("data")[0];
                g = new cc.TMXLayerInfo;
                g.name = h.getAttribute("name");
                e = cc.size(0, 0);
                e.width = parseFloat(h.getAttribute("width"));
                e.height = parseFloat(h.getAttribute("height"));
                g._layerSize = e;
                e = h.getAttribute("visible");
                g.visible = "0" != e;
                e = h.getAttribute("opacity") || 1;
                g._opacity = e ? parseInt(255 * parseFloat(e)) : 255;
                g.offset = cc.p(parseFloat(h.getAttribute("x")) || 0, parseFloat(h.getAttribute("y")) || 0);
                m = "";
                for (e = 0; e < k.childNodes.length; e++) m += k.childNodes[e].nodeValue;
                m = m.trim();
                e = k.getAttribute("compression");
                n = k.getAttribute("encoding");
                if (e && "gzip" !== e && "zlib" !== e) return cc.log("cc.TMXMapInfo.parseXMLFile(): unsupported compression method"), null;
                switch (e) {
                    case "gzip":
                        g._tiles = cc.unzipBase64AsArray(m, 4);
                        break;
                    case "zlib":
                        e = new Zlib.Inflate(cc.Codec.Base64.decodeAsArray(m, 1));
                        g._tiles = cc.uint8ArrayToUint32Array(e.decompress());
                        break;
                    case null:
                    case "":
                        if ("base64" == n) g._tiles = cc.Codec.Base64.decodeAsArray(m, 4);
                        else if ("csv" === n) {
                            g._tiles = [];
                            e = m.split(",");
                            for (k = 0; k < e.length; k++) g._tiles.push(parseInt(e[k]))
                        } else {
                            e =
                                k.getElementsByTagName("tile");
                            g._tiles = [];
                            for (k = 0; k < e.length; k++) g._tiles.push(parseInt(e[k].getAttribute("gid")))
                        }
                        break;
                    default:
                        this.layerAttrs == cc.TMXLayerInfo.ATTRIB_NONE && cc.log("cc.TMXMapInfo.parseXMLFile(): Only base64 and/or gzip/zlib maps are supported")
                }
                if (h = h.querySelectorAll("properties \x3e property")) {
                    k = {};
                    for (e = 0; e < h.length; e++) k[h[e].getAttribute("name")] = h[e].getAttribute("value");
                    g.properties = k
                }
                this.setLayers(g)
            }
        if (f = c.getElementsByTagName("objectgroup"))
            for (d = 0; d < f.length; d++) {
                h =
                    f[d];
                g = new cc.TMXObjectGroup;
                g.groupName = h.getAttribute("name");
                g.setPositionOffset(cc.p(parseFloat(h.getAttribute("x")) * this.getTileSize().width || 0, parseFloat(h.getAttribute("y")) * this.getTileSize().height || 0));
                if (k = h.querySelectorAll("objectgroup \x3e properties \x3e property"))
                    for (e = 0; e < k.length; e++) m = {}, m[k[e].getAttribute("name")] = k[e].getAttribute("value"), g.properties = m;
                if (h = h.querySelectorAll("object"))
                    for (e = 0; e < h.length; e++) {
                        m = h[e];
                        k = {};
                        k.name = m.getAttribute("name") || "";
                        k.type = m.getAttribute("type") ||
                            "";
                        k.x = parseInt(m.getAttribute("x") || 0) + g.getPositionOffset().x;
                        n = parseInt(m.getAttribute("y") || 0) + g.getPositionOffset().y;
                        k.width = parseInt(m.getAttribute("width")) || 0;
                        k.height = parseInt(m.getAttribute("height")) || 0;
                        k.y = parseInt(this.getMapSize().height * this.getTileSize().height) - n - k.height;
                        k.rotation = parseInt(m.getAttribute("rotation")) || 0;
                        if (n = m.querySelectorAll("properties \x3e property"))
                            for (q = 0; q < n.length; q++) k[n[q].getAttribute("name")] = n[q].getAttribute("value");
                        if ((n = m.querySelectorAll("polygon")) &&
                            0 < n.length)(n = n[0].getAttribute("points")) && (k.polygonPoints = this._parsePointsString(n));
                        if ((m = m.querySelectorAll("polyline")) && 0 < m.length)(m = m[0].getAttribute("points")) && (k.polylinePoints = this._parsePointsString(m));
                        g.setObjects(k)
                    }
                this.setObjectGroups(g)
            }
        return c
    },
    _parsePointsString: function(a) {
        if (!a) return null;
        var b = [];
        a = a.split(" ");
        for (var c = 0; c < a.length; c++) {
            var d = a[c].split(",");
            b.push({
                x: d[0],
                y: d[1]
            })
        }
        return b
    },
    parseXMLString: function(a) {
        return this.parseXMLFile(a, !0)
    },
    getTileProperties: function() {
        return this._tileProperties
    },
    setTileProperties: function(a) {
        this._tileProperties.push(a)
    },
    getCurrentString: function() {
        return this.currentString
    },
    setCurrentString: function(a) {
        this.currentString = a
    },
    getTMXFileName: function() {
        return this.tmxFileName
    },
    setTMXFileName: function(a) {
        this.tmxFileName = a
    },
    _internalInit: function(a, b) {
        this._tilesets.length = 0;
        this._layers.length = 0;
        this.tmxFileName = a;
        b && (this._resources = b);
        this._objectGroups.length = 0;
        this.properties.length = 0;
        this._tileProperties.length = 0;
        this.currentString = "";
        this.storingCharacters = !1;
        this.layerAttrs = cc.TMXLayerInfo.ATTRIB_NONE;
        this.parentElement = cc.TMX_PROPERTY_NONE;
        this._currentFirstGID = 0
    }
});
_p = cc.TMXMapInfo.prototype;
cc.defineGetterSetter(_p, "mapWidth", _p._getMapWidth, _p._setMapWidth);
cc.defineGetterSetter(_p, "mapHeight", _p._getMapHeight, _p._setMapHeight);
cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth);
cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight);
cc.TMXMapInfo.create = function(a, b) {
    return new cc.TMXMapInfo(a, b)
};
cc.loader.register(["tmx", "tsx"], cc._txtLoader);
cc.TMXLayerInfo.ATTRIB_NONE = 1;
cc.TMXLayerInfo.ATTRIB_BASE64 = 2;
cc.TMXLayerInfo.ATTRIB_GZIP = 4;
cc.TMXLayerInfo.ATTRIB_ZLIB = 8;
cc.TMXObjectGroup = cc.Class.extend({
    properties: null,
    groupName: "",
    _positionOffset: null,
    _objects: null,
    ctor: function() {
        this.groupName = "";
        this._positionOffset = cc.p(0, 0);
        this.properties = [];
        this._objects = []
    },
    getPositionOffset: function() {
        return cc.p(this._positionOffset)
    },
    setPositionOffset: function(a) {
        this._positionOffset.x = a.x;
        this._positionOffset.y = a.y
    },
    getProperties: function() {
        return this.properties
    },
    setProperties: function(a) {
        this.properties.push(a)
    },
    getGroupName: function() {
        return this.groupName.toString()
    },
    setGroupName: function(a) {
        this.groupName = a
    },
    propertyNamed: function(a) {
        return this.properties[a]
    },
    objectNamed: function(a) {
        if (this._objects && 0 < this._objects.length)
            for (var b = this._objects, c = 0, d = b.length; c < d; c++) {
                var e = b[c].name;
                if (e && e == a) return b[c]
            }
        return null
    },
    getObjects: function() {
        return this._objects
    },
    setObjects: function(a) {
        this._objects.push(a)
    }
});
cc.TMXLayer = cc.SpriteBatchNode.extend({
    tiles: null,
    tileset: null,
    layerOrientation: null,
    properties: null,
    layerName: "",
    _layerSize: null,
    _mapTileSize: null,
    _opacity: 255,
    _minGID: null,
    _maxGID: null,
    _vertexZvalue: null,
    _useAutomaticVertexZ: null,
    _reusedTile: null,
    _atlasIndexArray: null,
    _contentScaleFactor: null,
    _cacheCanvas: null,
    _cacheContext: null,
    _cacheTexture: null,
    _className: "TMXLayer",
    ctor: function(a, b, c) {
        cc.SpriteBatchNode.prototype.ctor.call(this);
        this._descendants = [];
        this._layerSize = cc.size(0, 0);
        this._mapTileSize =
            cc.size(0, 0);
        if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
            var d = cc._canvas,
                e = cc.newElement("canvas");
            e.width = d.width;
            e.height = d.height;
            this._cacheCanvas = e;
            this._cacheContext = this._cacheCanvas.getContext("2d");
            var f = new cc.Texture2D;
            f.initWithElement(e);
            f.handleLoadedTexture();
            this._cacheTexture = f;
            this.width = d.width;
            this.height = d.height;
            this._cachedParent = this
        }
        void 0 !== c && this.initWithTilesetInfo(a, b, c)
    },
    _initRendererCmd: function() {
        this._rendererCmd = cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.TMXLayerRenderCmdCanvas(this) :
            new cc.TMXLayerRenderCmdWebGL(this)
    },
    setContentSize: function(a, b) {
        var c = this._contentSize;
        cc.Node.prototype.setContentSize.call(this, a, b);
        if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
            var d = this._cacheCanvas,
                e = cc.contentScaleFactor();
            d.width = 0 | 1.5 * c.width * e;
            d.height = 0 | 1.5 * c.height * e;
            this.layerOrientation === cc.TMX_ORIENTATION_HEX ? this._cacheContext.translate(0, d.height - 0.5 * this._mapTileSize.height) : this._cacheContext.translate(0, d.height);
            c = this._cacheTexture._contentSize;
            c.width = d.width;
            c.height = d.height;
            c = d.width * d.height;
            if (c > this._maxCachePixel) {
                this._subCacheCanvas || (this._subCacheCanvas = []);
                this._subCacheContext || (this._subCacheContext = []);
                this._subCacheCount = Math.ceil(c / this._maxCachePixel);
                c = this._subCacheCanvas;
                for (e = 0; e < this._subCacheCount; e++) {
                    c[e] || (c[e] = document.createElement("canvas"), this._subCacheContext[e] = c[e].getContext("2d"));
                    var f = c[e];
                    f.width = this._subCacheWidth = Math.round(d.width / this._subCacheCount);
                    f.height = d.height
                }
                for (e = this._subCacheCount; e < c.length; e++) f.width = 0, f.height =
                    0
            } else this._subCacheCount = 0
        }
    },
    getTexture: null,
    _getTextureForCanvas: function() {
        return this._cacheTexture
    },
    visit: null,
    _visitForCanvas: function(a) {
        var b, c, d = this._children;
        if (this._visible && d && 0 !== d.length) {
            this._parent && (this._curLevel = this._parent._curLevel + 1);
            this.transform();
            if (this._cacheDirty) {
                a = this._cacheContext;
                var e = this._cacheCanvas,
                    f = cc.view,
                    g = this.__instanceId,
                    h = cc.renderer;
                h._turnToCacheMode(g);
                this.sortAllChildren();
                b = 0;
                for (c = d.length; b < c; b++) d[b] && (d[b].visit(), d[b]._cacheDirty = !1);
                this._rendererCmd._copyRendererCmds(h._cacheToCanvasCmds[g]);
                a.save();
                a.clearRect(0, 0, e.width, -e.height);
                b = cc.affineTransformInvert(this._transformWorld);
                a.transform(b.a, b.c, b.b, b.d, b.tx * f.getScaleX(), -b.ty * f.getScaleY());
                h._renderingToCacheCanvas(a, g);
                a.restore();
                this._cacheDirty = !1
            }
            cc.renderer.pushRenderCommand(this._rendererCmd)
        }
    },
    _setNodeDirtyForCache: function() {
        this._cacheDirty = !0; - 1 === cc.renderer._transformNodePool.indexOf(this) && cc.renderer.pushDirtyNode(this);
        this._renderCmdDiry = !0
    },
    draw: null,
    _drawForCanvas: function(a) {
        a = a || cc._renderContext;
        var b = 0 | -this._anchorPointInPoints.x,
            c = 0 | -this._anchorPointInPoints.y,
            d = cc.view,
            e = this._cacheCanvas;
        if (e) {
            var f = this._subCacheCount,
                g = e.height * d._scaleY,
                h = 0.5 * this._mapTileSize.height * d._scaleY;
            if (0 < f)
                for (var e = this._subCacheCanvas, k = 0; k < f; k++) {
                    var m = e[k];
                    this.layerOrientation === cc.TMX_ORIENTATION_HEX ? a.drawImage(e[k], 0, 0, m.width, m.height, b + k * this._subCacheWidth * d._scaleX, -(c + g) + h, m.width * d._scaleX, g) : a.drawImage(e[k], 0, 0, m.width, m.height, b + k * this._subCacheWidth *
                        d._scaleX, -(c + g), m.width * d._scaleX, g)
                } else this.layerOrientation === cc.TMX_ORIENTATION_HEX ? a.drawImage(e, 0, 0, e.width, e.height, b, -(c + g) + h, e.width * d._scaleX, g) : a.drawImage(e, 0, 0, e.width, e.height, b, -(c + g), e.width * d._scaleX, g)
        }
    },
    getLayerSize: function() {
        return cc.size(this._layerSize.width, this._layerSize.height)
    },
    setLayerSize: function(a) {
        this._layerSize.width = a.width;
        this._layerSize.height = a.height
    },
    _getLayerWidth: function() {
        return this._layerSize.width
    },
    _setLayerWidth: function(a) {
        this._layerSize.width =
            a
    },
    _getLayerHeight: function() {
        return this._layerSize.height
    },
    _setLayerHeight: function(a) {
        this._layerSize.height = a
    },
    getMapTileSize: function() {
        return cc.size(this._mapTileSize.width, this._mapTileSize.height)
    },
    setMapTileSize: function(a) {
        this._mapTileSize.width = a.width;
        this._mapTileSize.height = a.height
    },
    _getTileWidth: function() {
        return this._mapTileSize.width
    },
    _setTileWidth: function(a) {
        this._mapTileSize.width = a
    },
    _getTileHeight: function() {
        return this._mapTileSize.height
    },
    _setTileHeight: function(a) {
        this._mapTileSize.height =
            a
    },
    getTiles: function() {
        return this.tiles
    },
    setTiles: function(a) {
        this.tiles = a
    },
    getTileset: function() {
        return this.tileset
    },
    setTileset: function(a) {
        this.tileset = a
    },
    getLayerOrientation: function() {
        return this.layerOrientation
    },
    setLayerOrientation: function(a) {
        this.layerOrientation = a
    },
    getProperties: function() {
        return this.properties
    },
    setProperties: function(a) {
        this.properties = a
    },
    initWithTilesetInfo: function(a, b, c) {
        var d = b._layerSize,
            e = 0.35 * parseInt(d.width * d.height) + 1,
            f;
        a && (f = cc.textureCache.addImage(a.sourceImage));
        return this.initWithTexture(f, e) ? (this.layerName = b.name, this._layerSize = d, this.tiles = b._tiles, this._minGID = b._minGID, this._maxGID = b._maxGID, this._opacity = b._opacity, this.properties = b.properties, this._contentScaleFactor = cc.director.getContentScaleFactor(), this.tileset = a, this._mapTileSize = c.getTileSize(), this.layerOrientation = c.orientation, a = this._calculateLayerOffset(b.offset), this.setPosition(cc.pointPixelsToPoints(a)), this._atlasIndexArray = [], this.setContentSize(cc.sizePixelsToPoints(cc.size(this._layerSize.width *
            this._mapTileSize.width, this._layerSize.height * this._mapTileSize.height))), this._useAutomaticVertexZ = !1, this._vertexZvalue = 0, !0) : !1
    },
    releaseMap: function() {
        this.tiles && (this.tiles = null);
        this._atlasIndexArray && (this._atlasIndexArray = null)
    },
    getTileAt: function(a, b) {
        if (!a) throw "cc.TMXLayer.getTileAt(): pos should be non-null";
        void 0 !== b && (a = cc.p(a, b));
        if (a.x >= this._layerSize.width || a.y >= this._layerSize.height || 0 > a.x || 0 > a.y) throw "cc.TMXLayer.getTileAt(): invalid position";
        if (!this.tiles || !this._atlasIndexArray) return cc.log("cc.TMXLayer.getTileAt(): TMXLayer: the tiles map has been released"),
            null;
        var c = null,
            d = this.getTileGIDAt(a);
        if (0 === d) return c;
        var e = 0 | a.x + a.y * this._layerSize.width,
            c = this.getChildByTag(e);
        c || (d = this.tileset.rectForGID(d), d = cc.rectPixelsToPoints(d), c = new cc.Sprite, c.initWithTexture(this.texture, d), c.batchNode = this, c.setPosition(this.getPositionAt(a)), c.vertexZ = this._vertexZForPos(a), c.anchorX = 0, c.anchorY = 0, c.opacity = this._opacity, d = this._atlasIndexForExistantZ(e), this.addSpriteWithoutQuad(c, d, e));
        return c
    },
    getTileGIDAt: function(a, b) {
        if (!a) throw "cc.TMXLayer.getTileGIDAt(): pos should be non-null";
        void 0 !== b && (a = cc.p(a, b));
        if (a.x >= this._layerSize.width || a.y >= this._layerSize.height || 0 > a.x || 0 > a.y) throw "cc.TMXLayer.getTileGIDAt(): invalid position";
        return !this.tiles || !this._atlasIndexArray ? (cc.log("cc.TMXLayer.getTileGIDAt(): TMXLayer: the tiles map has been released"), null) : (this.tiles[0 | a.x + a.y * this._layerSize.width] & cc.TMX_TILE_FLIPPED_MASK) >>> 0
    },
    getTileFlagsAt: function(a, b) {
        if (!a) throw "cc.TMXLayer.getTileFlagsAt(): pos should be non-null";
        void 0 !== b && (a = cc.p(a, b));
        if (a.x >= this._layerSize.width ||
            a.y >= this._layerSize.height || 0 > a.x || 0 > a.y) throw "cc.TMXLayer.getTileFlagsAt(): invalid position";
        return !this.tiles || !this._atlasIndexArray ? (cc.log("cc.TMXLayer.getTileFlagsAt(): TMXLayer: the tiles map has been released"), null) : (this.tiles[0 | a.x + a.y * this._layerSize.width] & cc.TMX_TILE_FLIPPED_ALL) >>> 0
    },
    setTileGID: function(a, b, c, d) {
        if (!b) throw "cc.TMXLayer.setTileGID(): pos should be non-null";
        void 0 !== d ? b = cc.p(b, c) : d = c;
        if (b.x >= this._layerSize.width || b.y >= this._layerSize.height || 0 > b.x || 0 > b.y) throw "cc.TMXLayer.setTileGID(): invalid position";
        if (!this.tiles || !this._atlasIndexArray) cc.log("cc.TMXLayer.setTileGID(): TMXLayer: the tiles map has been released");
        else if (0 !== a && a < this.tileset.firstGid) cc.log("cc.TMXLayer.setTileGID(): invalid gid:" + a);
        else {
            d = d || 0;
            this._setNodeDirtyForCache();
            c = this.getTileFlagsAt(b);
            var e = this.getTileGIDAt(b);
            if (e != a || c != d)
                if (c = (a | d) >>> 0, 0 === a) this.removeTileAt(b);
                else if (0 === e) this._insertTileForGID(c, b);
            else {
                var e = b.x + b.y * this._layerSize.width,
                    f = this.getChildByTag(e);
                f ? (a = this.tileset.rectForGID(a), a = cc.rectPixelsToPoints(a),
                    f.setTextureRect(a, !1), null != d && this._setupTileSprite(f, b, c), this.tiles[e] = c) : this._updateTileForGID(c, b)
            }
        }
    },
    removeTileAt: function(a, b) {
        if (!a) throw "cc.TMXLayer.removeTileAt(): pos should be non-null";
        void 0 !== b && (a = cc.p(a, b));
        if (a.x >= this._layerSize.width || a.y >= this._layerSize.height || 0 > a.x || 0 > a.y) throw "cc.TMXLayer.removeTileAt(): invalid position";
        if (!this.tiles || !this._atlasIndexArray) cc.log("cc.TMXLayer.removeTileAt(): TMXLayer: the tiles map has been released");
        else if (0 !== this.getTileGIDAt(a)) {
            cc._renderType ===
                cc._RENDER_TYPE_CANVAS && this._setNodeDirtyForCache();
            var c = 0 | a.x + a.y * this._layerSize.width,
                d = this._atlasIndexForExistantZ(c);
            this.tiles[c] = 0;
            this._atlasIndexArray.splice(d, 1);
            if (c = this.getChildByTag(c)) cc.SpriteBatchNode.prototype.removeChild.call(this, c, !0);
            else if (cc._renderType === cc._RENDER_TYPE_WEBGL && this.textureAtlas.removeQuadAtIndex(d), this._children)
                for (var c = this._children, e = 0, f = c.length; e < f; e++) {
                    var g = c[e];
                    if (g) {
                        var h = g.atlasIndex;
                        h >= d && (g.atlasIndex = h - 1)
                    }
                }
        }
    },
    getPositionAt: function(a, b) {
        void 0 !==
            b && (a = cc.p(a, b));
        var c = cc.p(0, 0);
        switch (this.layerOrientation) {
            case cc.TMX_ORIENTATION_ORTHO:
                c = this._positionForOrthoAt(a);
                break;
            case cc.TMX_ORIENTATION_ISO:
                c = this._positionForIsoAt(a);
                break;
            case cc.TMX_ORIENTATION_HEX:
                c = this._positionForHexAt(a)
        }
        return cc.pointPixelsToPoints(c)
    },
    getProperty: function(a) {
        return this.properties[a]
    },
    setupTiles: function() {
        cc._renderType === cc._RENDER_TYPE_CANVAS ? this.tileset.imageSize = this._originalTexture.getContentSizeInPixels() : (this.tileset.imageSize = this.textureAtlas.texture.getContentSizeInPixels(),
            this.textureAtlas.texture.setAliasTexParameters());
        this._parseInternalProperties();
        cc._renderType === cc._RENDER_TYPE_CANVAS && this._setNodeDirtyForCache();
        for (var a = this._layerSize.height, b = this._layerSize.width, c = 0; c < a; c++)
            for (var d = 0; d < b; d++) {
                var e = this.tiles[d + b * c];
                0 !== e && (this._appendTileForGID(e, cc.p(d, c)), this._minGID = Math.min(e, this._minGID), this._maxGID = Math.max(e, this._maxGID))
            }
        this._maxGID >= this.tileset.firstGid && this._minGID >= this.tileset.firstGid || cc.log("cocos2d:TMX: Only 1 tileset per layer is supported")
    },
    addChild: function(a, b, c) {
        cc.log("addChild: is not supported on cc.TMXLayer. Instead use setTileGID or tileAt.")
    },
    removeChild: function(a, b) {
        if (a)
            if (-1 === this._children.indexOf(a)) cc.log("cc.TMXLayer.removeChild(): Tile does not belong to TMXLayer");
            else {
                cc._renderType === cc._RENDER_TYPE_CANVAS && this._setNodeDirtyForCache();
                var c = a.atlasIndex;
                this.tiles[this._atlasIndexArray[c]] = 0;
                this._atlasIndexArray.splice(c, 1);
                cc.SpriteBatchNode.prototype.removeChild.call(this, a, b);
                cc.renderer.childrenOrderDirty = !0
            }
    },
    getLayerName: function() {
        return this.layerName
    },
    setLayerName: function(a) {
        this.layerName = a
    },
    _positionForIsoAt: function(a) {
        return cc.p(this._mapTileSize.width / 2 * (this._layerSize.width + a.x - a.y - 1), this._mapTileSize.height / 2 * (2 * this._layerSize.height - a.x - a.y - 2))
    },
    _positionForOrthoAt: function(a) {
        return cc.p(a.x * this._mapTileSize.width, (this._layerSize.height - a.y - 1) * this._mapTileSize.height)
    },
    _positionForHexAt: function(a) {
        return cc.p(3 * a.x * this._mapTileSize.width / 4, (this._layerSize.height - a.y - 1) * this._mapTileSize.height +
            (1 == a.x % 2 ? -this._mapTileSize.height / 2 : 0))
    },
    _calculateLayerOffset: function(a) {
        var b = cc.p(0, 0);
        switch (this.layerOrientation) {
            case cc.TMX_ORIENTATION_ORTHO:
                b = cc.p(a.x * this._mapTileSize.width, -a.y * this._mapTileSize.height);
                break;
            case cc.TMX_ORIENTATION_ISO:
                b = cc.p(this._mapTileSize.width / 2 * (a.x - a.y), this._mapTileSize.height / 2 * (-a.x - a.y));
                break;
            case cc.TMX_ORIENTATION_HEX:
                (0 !== a.x || 0 !== a.y) && cc.log("offset for hexagonal map not implemented yet")
        }
        return b
    },
    _appendTileForGID: function(a, b) {
        var c = this.tileset.rectForGID(a),
            c = cc.rectPixelsToPoints(c),
            d = 0 | b.x + b.y * this._layerSize.width,
            c = this._reusedTileWithRect(c);
        this._setupTileSprite(c, b, a);
        var e = this._atlasIndexArray.length;
        this.insertQuadFromSprite(c, e);
        this._atlasIndexArray.splice(e, 0, d);
        return c
    },
    _insertTileForGID: function(a, b) {
        var c = this.tileset.rectForGID(a),
            c = cc.rectPixelsToPoints(c),
            d = 0 | b.x + b.y * this._layerSize.width,
            c = this._reusedTileWithRect(c);
        this._setupTileSprite(c, b, a);
        var e = this._atlasIndexForNewZ(d);
        this.insertQuadFromSprite(c, e);
        this._atlasIndexArray.splice(e,
            0, d);
        if (this._children)
            for (var f = this._children, g = 0, h = f.length; g < h; g++) {
                var k = f[g];
                if (k) {
                    var m = k.atlasIndex;
                    m >= e && (k.atlasIndex = m + 1)
                }
            }
        this.tiles[d] = a;
        return c
    },
    _updateTileForGID: function(a, b) {
        var c = this.tileset.rectForGID(a),
            d = this._contentScaleFactor,
            c = cc.rect(c.x / d, c.y / d, c.width / d, c.height / d),
            d = b.x + b.y * this._layerSize.width,
            c = this._reusedTileWithRect(c);
        this._setupTileSprite(c, b, a);
        c.atlasIndex = this._atlasIndexForExistantZ(d);
        c.dirty = !0;
        c.updateTransform();
        this.tiles[d] = a;
        return c
    },
    _parseInternalProperties: function() {
        var a =
            this.getProperty("cc_vertexz");
        if (a)
            if ("automatic" == a) {
                this._useAutomaticVertexZ = !0;
                var b = this.getProperty("cc_alpha_func"),
                    a = 0;
                b && (a = parseFloat(b));
                cc._renderType === cc._RENDER_TYPE_WEBGL && (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST), b = cc._renderContext.getUniformLocation(this.shaderProgram.getProgram(), cc.UNIFORM_ALPHA_TEST_VALUE_S), this.shaderProgram.use(), this.shaderProgram.setUniformLocationWith1f(b, a))
            } else this._vertexZvalue = parseInt(a, 10)
    },
    _setupTileSprite: function(a,
        b, c) {
        var d = b.x + b.y * this._layerSize.width;
        a.setPosition(this.getPositionAt(b));
        cc._renderType === cc._RENDER_TYPE_WEBGL ? a.vertexZ = this._vertexZForPos(b) : a.tag = d;
        a.anchorX = 0;
        a.anchorY = 0;
        a.opacity = this._opacity;
        cc._renderType === cc._RENDER_TYPE_WEBGL && (a.rotation = 0);
        a.setFlippedX(!1);
        a.setFlippedY(!1);
        (c & cc.TMX_TILE_DIAGONAL_FLAG) >>> 0 ? (a.anchorX = 0.5, a.anchorY = 0.5, a.x = this.getPositionAt(b).x + a.width / 2, a.y = this.getPositionAt(b).y + a.height / 2, b = (c & (cc.TMX_TILE_HORIZONTAL_FLAG | cc.TMX_TILE_VERTICAL_FLAG) >>> 0) >>>
            0, b == cc.TMX_TILE_HORIZONTAL_FLAG ? a.rotation = 90 : b == cc.TMX_TILE_VERTICAL_FLAG ? a.rotation = 270 : (a.rotation = b == (cc.TMX_TILE_VERTICAL_FLAG | cc.TMX_TILE_HORIZONTAL_FLAG) >>> 0 ? 90 : 270, a.setFlippedX(!0))) : ((c & cc.TMX_TILE_HORIZONTAL_FLAG) >>> 0 && a.setFlippedX(!0), (c & cc.TMX_TILE_VERTICAL_FLAG) >>> 0 && a.setFlippedY(!0))
    },
    _reusedTileWithRect: function(a) {
        cc._renderType === cc._RENDER_TYPE_WEBGL ? (this._reusedTile ? (this._reusedTile.batchNode = null, this._reusedTile.setTextureRect(a, !1)) : (this._reusedTile = new cc.Sprite, this._reusedTile.initWithTexture(this.texture,
            a, !1)), this._reusedTile.batchNode = this) : (this._reusedTile = new cc.Sprite, this._reusedTile.initWithTexture(this._textureForCanvas, a, !1), this._reusedTile.batchNode = this, this._reusedTile.parent = this, this._reusedTile._cachedParent = this);
        return this._reusedTile
    },
    _vertexZForPos: function(a) {
        var b = 0,
            c = 0;
        if (this._useAutomaticVertexZ) switch (this.layerOrientation) {
            case cc.TMX_ORIENTATION_ISO:
                c = this._layerSize.width + this._layerSize.height;
                b = -(c - (a.x + a.y));
                break;
            case cc.TMX_ORIENTATION_ORTHO:
                b = -(this._layerSize.height -
                    a.y);
                break;
            case cc.TMX_ORIENTATION_HEX:
                cc.log("TMX Hexa zOrder not supported");
                break;
            default:
                cc.log("TMX invalid value")
        } else b = this._vertexZvalue;
        return b
    },
    _atlasIndexForExistantZ: function(a) {
        var b;
        if (this._atlasIndexArray)
            for (var c = this._atlasIndexArray, d = 0, e = c.length; d < e && !(b = c[d], b == a); d++);
        cc.isNumber(b) || cc.log("cc.TMXLayer._atlasIndexForExistantZ(): TMX atlas index not found. Shall not happen");
        return d
    },
    _atlasIndexForNewZ: function(a) {
        for (var b = this._atlasIndexArray, c = 0, d = b.length; c < d && !(a <
            b[c]); c++);
        return c
    }
});
_p = cc.TMXLayer.prototype;
cc._renderType == cc._RENDER_TYPE_WEBGL ? (_p.draw = cc.SpriteBatchNode.prototype.draw, _p.visit = cc.SpriteBatchNode.prototype.visit, _p.getTexture = cc.SpriteBatchNode.prototype.getTexture) : (_p.draw = _p._drawForCanvas, _p.visit = _p._visitForCanvas, _p.getTexture = _p._getTextureForCanvas);
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.defineGetterSetter(_p, "layerWidth", _p._getLayerWidth, _p._setLayerWidth);
cc.defineGetterSetter(_p, "layerHeight", _p._getLayerHeight, _p._setLayerHeight);
cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth);
cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight);
cc.TMXLayer.create = function(a, b, c) {
    return new cc.TMXLayer(a, b, c)
};
cc.PNGReader = cc.Class.extend({
    ctor: function(a) {
        var b, c, d, e;
        this.data = a;
        this.pos = 8;
        this.palette = [];
        this.imgData = [];
        this.transparency = {};
        this.animation = null;
        this.text = {};
        for (d = null;;) {
            b = this.readUInt32();
            e = a = void 0;
            e = [];
            for (a = 0; 4 > a; ++a) e.push(String.fromCharCode(this.data[this.pos++]));
            a = e.join("");
            switch (a) {
                case "IHDR":
                    this.width = this.readUInt32();
                    this.height = this.readUInt32();
                    this.bits = this.data[this.pos++];
                    this.colorType = this.data[this.pos++];
                    this.compressionMethod = this.data[this.pos++];
                    this.filterMethod =
                        this.data[this.pos++];
                    this.interlaceMethod = this.data[this.pos++];
                    break;
                case "acTL":
                    this.animation = {
                        numFrames: this.readUInt32(),
                        numPlays: this.readUInt32() || Infinity,
                        frames: []
                    };
                    break;
                case "PLTE":
                    this.palette = this.read(b);
                    break;
                case "fcTL":
                    d && this.animation.frames.push(d);
                    this.pos += 4;
                    d = {
                        width: this.readUInt32(),
                        height: this.readUInt32(),
                        xOffset: this.readUInt32(),
                        yOffset: this.readUInt32()
                    };
                    a = this.readUInt16();
                    b = this.readUInt16() || 100;
                    d.delay = 1E3 * a / b;
                    d.disposeOp = this.data[this.pos++];
                    d.blendOp = this.data[this.pos++];
                    d.data = [];
                    break;
                case "IDAT":
                case "fdAT":
                    "fdAT" === a && (this.pos += 4, b -= 4);
                    a = (null != d ? d.data : void 0) || this.imgData;
                    for (e = 0; 0 <= b ? e < b : e > b; 0 <= b ? ++e : --e) a.push(this.data[this.pos++]);
                    break;
                case "tRNS":
                    this.transparency = {};
                    switch (this.colorType) {
                        case 3:
                            this.transparency.indexed = this.read(b);
                            b = 255 - this.transparency.indexed.length;
                            if (0 < b)
                                for (a = 0; 0 <= b ? a < b : a > b; 0 <= b ? ++a : --a) this.transparency.indexed.push(255);
                            break;
                        case 0:
                            this.transparency.grayscale = this.read(b)[0];
                            break;
                        case 2:
                            this.transparency.rgb = this.read(b)
                    }
                    break;
                case "tEXt":
                    e = this.read(b);
                    b = e.indexOf(0);
                    a = String.fromCharCode.apply(String, e.slice(0, b));
                    this.text[a] = String.fromCharCode.apply(String, e.slice(b + 1));
                    break;
                case "IEND":
                    d && this.animation.frames.push(d);
                    a: {
                        switch (this.colorType) {
                            case 0:
                            case 3:
                            case 4:
                                d = 1;
                                break a;
                            case 2:
                            case 6:
                                d = 3;
                                break a
                        }
                        d = void 0
                    }
                    this.colors = d;
                    this.hasAlphaChannel = 4 === (c = this.colorType) || 6 === c;
                    c = this.colors + (this.hasAlphaChannel ? 1 : 0);
                    this.pixelBitlength = this.bits * c;
                    a: {
                        switch (this.colors) {
                            case 1:
                                c = "DeviceGray";
                                break a;
                            case 3:
                                c = "DeviceRGB";
                                break a
                        }
                        c = void 0
                    }
                    this.colorSpace = c;
                    Uint8Array != Array && (this.imgData = new Uint8Array(this.imgData));
                    return;
                default:
                    this.pos += b
            }
            this.pos += 4;
            if (this.pos > this.data.length) throw Error("Incomplete or corrupt PNG file");
        }
    },
    read: function(a) {
        var b, c;
        c = [];
        for (b = 0; 0 <= a ? b < a : b > a; 0 <= a ? ++b : --b) c.push(this.data[this.pos++]);
        return c
    },
    readUInt32: function() {
        var a, b, c, d;
        a = this.data[this.pos++] << 24;
        b = this.data[this.pos++] << 16;
        c = this.data[this.pos++] << 8;
        d = this.data[this.pos++];
        return a | b | c | d
    },
    readUInt16: function() {
        var a,
            b;
        a = this.data[this.pos++] << 8;
        b = this.data[this.pos++];
        return a | b
    },
    decodePixels: function(a) {
        var b, c, d, e, f, g, h, k, m, n, q, r, s, t, u;
        null == a && (a = this.imgData);
        if (0 === a.length) return new Uint8Array(0);
        a = (new Zlib.Inflate(a, {
            index: 0,
            verify: !1
        })).decompress();
        k = this.pixelBitlength / 8;
        r = k * this.width;
        m = new Uint8Array(r * this.height);
        g = a.length;
        for (c = n = q = 0; n < g;) {
            switch (a[n++]) {
                case 0:
                    for (b = 0; b < r; b += 1) m[c++] = a[n++];
                    break;
                case 1:
                    for (e = s = 0; s < r; e = s += 1) b = a[n++], f = e < k ? 0 : m[c - k], m[c++] = (b + f) % 256;
                    break;
                case 2:
                    for (e = f = 0; f <
                        r; e = f += 1) b = a[n++], d = (e - e % k) / k, s = q && m[(q - 1) * r + d * k + e % k], m[c++] = (s + b) % 256;
                    break;
                case 3:
                    for (e = u = 0; u < r; e = u += 1) b = a[n++], d = (e - e % k) / k, f = e < k ? 0 : m[c - k], s = q && m[(q - 1) * r + d * k + e % k], m[c++] = (b + Math.floor((f + s) / 2)) % 256;
                    break;
                case 4:
                    for (e = u = 0; u < r; e = u += 1) b = a[n++], d = (e - e % k) / k, f = e < k ? 0 : m[c - k], 0 === q ? s = t = 0 : (s = m[(q - 1) * r + d * k + e % k], t = d && m[(q - 1) * r + (d - 1) * k + e % k]), h = f + s - t, e = Math.abs(h - f), d = Math.abs(h - s), h = Math.abs(h - t), f = e <= d && e <= h ? f : d <= h ? s : t, m[c++] = (b + f) % 256;
                    break;
                default:
                    throw Error("Invalid filter algorithm: " + a[n - 1]);
            }
            q++
        }
        return m
    },
    copyToImageData: function(a, b) {
        var c, d, e, f, g, h, k, m;
        d = this.colors;
        m = null;
        c = this.hasAlphaChannel;
        this.palette.length && (m = null != (e = this._decodedPalette) ? e : this._decodedPalette = this.decodePalette(), d = 4, c = !0);
        e = a.data || a;
        k = e.length;
        g = m || b;
        f = h = 0;
        if (1 === d)
            for (; f < k;) d = m ? 4 * b[f / 4] : h, h = g[d++], e[f++] = h, e[f++] = h, e[f++] = h, e[f++] = c ? g[d++] : 255, h = d;
        else
            for (; f < k;) d = m ? 4 * b[f / 4] : h, e[f++] = g[d++], e[f++] = g[d++], e[f++] = g[d++], e[f++] = c ? g[d++] : 255, h = d
    },
    decodePalette: function() {
        var a, b, c, d, e, f, g, h, k;
        c = this.palette;
        f = this.transparency.indexed || [];
        e = new Uint8Array((f.length || 0) + c.length);
        b = g = a = d = 0;
        for (h = c.length; g < h; b = g += 3) e[d++] = c[b], e[d++] = c[b + 1], e[d++] = c[b + 2], e[d++] = null != (k = f[a++]) ? k : 255;
        return e
    },
    render: function(a) {
        var b;
        a.width = this.width;
        a.height = this.height;
        a = a.getContext("2d");
        b = a.createImageData(this.width, this.height);
        this.copyToImageData(b, this.decodePixels());
        return a.putImageData(b, 0, 0)
    }
});
cc.tiffReader = {
    _littleEndian: !1,
    _tiffData: null,
    _fileDirectories: [],
    getUint8: function(a) {
        return this._tiffData[a]
    },
    getUint16: function(a) {
        return this._littleEndian ? this._tiffData[a + 1] << 8 | this._tiffData[a] : this._tiffData[a] << 8 | this._tiffData[a + 1]
    },
    getUint32: function(a) {
        var b = this._tiffData;
        return this._littleEndian ? b[a + 3] << 24 | b[a + 2] << 16 | b[a + 1] << 8 | b[a] : b[a] << 24 | b[a + 1] << 16 | b[a + 2] << 8 | b[a + 3]
    },
    checkLittleEndian: function() {
        var a = this.getUint16(0);
        if (18761 === a) this.littleEndian = !0;
        else if (19789 === a) this.littleEndian = !1;
        else throw console.log(a), TypeError("Invalid byte order value.");
        return this.littleEndian
    },
    hasTowel: function() {
        if (42 !== this.getUint16(2)) throw RangeError("You forgot your towel!");
        return !0
    },
    getFieldTypeName: function(a) {
        var b = this.fieldTypeNames;
        return a in b ? b[a] : null
    },
    getFieldTagName: function(a) {
        var b = this.fieldTagNames;
        if (a in b) return b[a];
        console.log("Unknown Field Tag:", a);
        return "Tag" + a
    },
    getFieldTypeLength: function(a) {
        return -1 !== ["BYTE", "ASCII", "SBYTE", "UNDEFINED"].indexOf(a) ? 1 : -1 !== ["SHORT",
            "SSHORT"
        ].indexOf(a) ? 2 : -1 !== ["LONG", "SLONG", "FLOAT"].indexOf(a) ? 4 : -1 !== ["RATIONAL", "SRATIONAL", "DOUBLE"].indexOf(a) ? 8 : null
    },
    getFieldValues: function(a, b, c, d) {
        a = [];
        var e = this.getFieldTypeLength(b);
        if (4 >= e * c)!1 === this.littleEndian ? a.push(d >>> 8 * (4 - e)) : a.push(d);
        else
            for (var f = 0; f < c; f++) {
                var g = e * f;
                8 <= e ? -1 !== ["RATIONAL", "SRATIONAL"].indexOf(b) ? (a.push(this.getUint32(d + g)), a.push(this.getUint32(d + g + 4))) : cc.log("Can't handle this field type or size") : a.push(this.getBytes(e, d + g))
            }
        "ASCII" === b && a.forEach(function(a,
            b, c) {
            c[b] = String.fromCharCode(a)
        });
        return a
    },
    getBytes: function(a, b) {
        if (0 >= a) cc.log("No bytes requested");
        else {
            if (1 >= a) return this.getUint8(b);
            if (2 >= a) return this.getUint16(b);
            if (3 >= a) return this.getUint32(b) >>> 8;
            if (4 >= a) return this.getUint32(b);
            cc.log("Too many bytes requested")
        }
    },
    getBits: function(a, b, c) {
        c = c || 0;
        b += Math.floor(c / 8);
        var d = c + a;
        a = 32 - a;
        var e, f;
        0 >= d ? console.log("No bits requested") : 8 >= d ? (e = 24 + c, f = this.getUint8(b)) : 16 >= d ? (e = 16 + c, f = this.getUint16(b)) : 32 >= d ? (e = c, f = this.getUint32(b)) : console.log("Too many bits requested");
        return {
            bits: f << e >>> a,
            byteOffset: b + Math.floor(d / 8),
            bitOffset: d % 8
        }
    },
    parseFileDirectory: function(a) {
        var b = this.getUint16(a),
            c = [];
        a += 2;
        for (var d = 0; d < b; a += 12, d++) {
            var e = this.getUint16(a),
                f = this.getUint16(a + 2),
                g = this.getUint32(a + 4),
                h = this.getUint32(a + 8),
                e = this.getFieldTagName(e),
                f = this.getFieldTypeName(f),
                g = this.getFieldValues(e, f, g, h);
            c[e] = {
                type: f,
                values: g
            }
        }
        this._fileDirectories.push(c);
        b = this.getUint32(a);
        0 !== b && this.parseFileDirectory(b)
    },
    clampColorSample: function(a, b) {
        var c = Math.pow(2, 8 - b);
        return Math.floor(a *
            c + (c - 1))
    },
    parseTIFF: function(a, b) {
        b = b || cc.newElement("canvas");
        this._tiffData = a;
        this.canvas = b;
        this.checkLittleEndian();
        if (this.hasTowel()) {
            var c = this.getUint32(4);
            this._fileDirectories.length = 0;
            this.parseFileDirectory(c);
            var d = this._fileDirectories[0],
                c = d.ImageWidth.values[0],
                e = d.ImageLength.values[0];
            this.canvas.width = c;
            this.canvas.height = e;
            var f = [],
                g = d.Compression ? d.Compression.values[0] : 1,
                h = d.SamplesPerPixel.values[0],
                k = [],
                m = 0,
                n = !1;
            d.BitsPerSample.values.forEach(function(a, b, c) {
                k[b] = {
                    bitsPerSample: a,
                    hasBytesPerSample: !1,
                    bytesPerSample: void 0
                };
                0 === a % 8 && (k[b].hasBytesPerSample = !0, k[b].bytesPerSample = a / 8);
                m += a
            }, this);
            if (0 === m % 8) var n = !0,
                q = m / 8;
            var r = d.StripOffsets.values,
                s = r.length;
            if (d.StripByteCounts) var t = d.StripByteCounts.values;
            else if (cc.log("Missing StripByteCounts!"), 1 === s) t = [Math.ceil(c * e * m / 8)];
            else throw Error("Cannot recover from missing StripByteCounts");
            for (var u = 0; u < s; u++) {
                var w = r[u];
                f[u] = [];
                for (var v = t[u], y = 0, D = 0, C = 1, z = !0, A = [], x = 0, B = 0, I = 0; y < v; y += C) switch (g) {
                    case 1:
                        C = 0;
                        for (A = []; C < h; C++)
                            if (k[C].hasBytesPerSample) A.push(this.getBytes(k[C].bytesPerSample,
                                w + y + k[C].bytesPerSample * C));
                            else {
                                var K = this.getBits(k[C].bitsPerSample, w + y, D);
                                A.push(K.bits);
                                y = K.byteOffset - w;
                                D = K.bitOffset;
                                throw RangeError("Cannot handle sub-byte bits per sample");
                            }
                        f[u].push(A);
                        if (n) C = q;
                        else throw C = 0, RangeError("Cannot handle sub-byte bits per pixel");
                        break;
                    case 32773:
                        if (z) {
                            var z = !1,
                                F = 1,
                                L = 1,
                                C = this.getInt8(w + y);
                            0 <= C && 127 >= C ? F = C + 1 : -127 <= C && -1 >= C ? L = -C + 1 : z = !0
                        } else {
                            for (var M = this.getUint8(w + y), C = 0; C < L; C++) {
                                if (k[B].hasBytesPerSample) I = I << 8 * x | M, x++, x === k[B].bytesPerSample && (A.push(I),
                                    I = x = 0, B++);
                                else throw RangeError("Cannot handle sub-byte bits per sample");
                                B === h && (f[u].push(A), A = [], B = 0)
                            }
                            F--;
                            0 === F && (z = !0)
                        }
                        C = 1
                }
            }
            if (b.getContext) {
                q = this.canvas.getContext("2d");
                q.fillStyle = "rgba(255, 255, 255, 0)";
                u = d.RowsPerStrip ? d.RowsPerStrip.values[0] : e;
                w = f.length;
                e %= u;
                e = 0 === e ? u : e;
                y = u;
                g = 0;
                A = d.PhotometricInterpretation.values[0];
                F = [];
                L = 0;
                d.ExtraSamples && (F = d.ExtraSamples.values, L = F.length);
                if (d.ColorMap) var K = d.ColorMap.values,
                    E = Math.pow(2, k[0].bitsPerSample);
                for (u = 0; u < w; u++) {
                    u + 1 === w && (y = e);
                    d =
                        f[u].length;
                    g *= u;
                    for (n = h = 0; h < y, n < d; h++)
                        for (r = 0; r < c; r++, n++) {
                            t = f[u][n];
                            z = D = v = 0;
                            s = 1;
                            if (0 < L)
                                for (v = 0; v < L; v++)
                                    if (1 === F[v] || 2 === F[v]) {
                                        s = t[3 + v] / 256;
                                        break
                                    }
                            switch (A) {
                                case 0:
                                    if (k[0].hasBytesPerSample) var H = Math.pow(16, 2 * k[0].bytesPerSample);
                                    t.forEach(function(a, b, c) {
                                        c[b] = H - a
                                    });
                                case 1:
                                    v = D = z = this.clampColorSample(t[0], k[0].bitsPerSample);
                                    break;
                                case 2:
                                    v = this.clampColorSample(t[0], k[0].bitsPerSample);
                                    D = this.clampColorSample(t[1], k[1].bitsPerSample);
                                    z = this.clampColorSample(t[2], k[2].bitsPerSample);
                                    break;
                                case 3:
                                    if (void 0 ===
                                        K) throw Error("Palette image missing color map");
                                    t = t[0];
                                    v = this.clampColorSample(K[t], 16);
                                    D = this.clampColorSample(K[E + t], 16);
                                    z = this.clampColorSample(K[2 * E + t], 16);
                                    break;
                                default:
                                    throw RangeError("Unknown Photometric Interpretation:", A);
                            }
                            q.fillStyle = "rgba(" + v + ", " + D + ", " + z + ", " + s + ")";
                            q.fillRect(r, g + h, 1, 1)
                        }
                    g = y
                }
            }
            return this.canvas
        }
    },
    fieldTagNames: {
        315: "Artist",
        258: "BitsPerSample",
        265: "CellLength",
        264: "CellWidth",
        320: "ColorMap",
        259: "Compression",
        33432: "Copyright",
        306: "DateTime",
        338: "ExtraSamples",
        266: "FillOrder",
        289: "FreeByteCounts",
        288: "FreeOffsets",
        291: "GrayResponseCurve",
        290: "GrayResponseUnit",
        316: "HostComputer",
        270: "ImageDescription",
        257: "ImageLength",
        256: "ImageWidth",
        271: "Make",
        281: "MaxSampleValue",
        280: "MinSampleValue",
        272: "Model",
        254: "NewSubfileType",
        274: "Orientation",
        262: "PhotometricInterpretation",
        284: "PlanarConfiguration",
        296: "ResolutionUnit",
        278: "RowsPerStrip",
        277: "SamplesPerPixel",
        305: "Software",
        279: "StripByteCounts",
        273: "StripOffsets",
        255: "SubfileType",
        263: "Threshholding",
        282: "XResolution",
        283: "YResolution",
        326: "BadFaxLines",
        327: "CleanFaxData",
        343: "ClipPath",
        328: "ConsecutiveBadFaxLines",
        433: "Decode",
        434: "DefaultImageColor",
        269: "DocumentName",
        336: "DotRange",
        321: "HalftoneHints",
        346: "Indexed",
        347: "JPEGTables",
        285: "PageName",
        297: "PageNumber",
        317: "Predictor",
        319: "PrimaryChromaticities",
        532: "ReferenceBlackWhite",
        339: "SampleFormat",
        559: "StripRowCounts",
        330: "SubIFDs",
        292: "T4Options",
        293: "T6Options",
        325: "TileByteCounts",
        323: "TileLength",
        324: "TileOffsets",
        322: "TileWidth",
        301: "TransferFunction",
        318: "WhitePoint",
        344: "XClipPathUnits",
        286: "XPosition",
        529: "YCbCrCoefficients",
        531: "YCbCrPositioning",
        530: "YCbCrSubSampling",
        345: "YClipPathUnits",
        287: "YPosition",
        37378: "ApertureValue",
        40961: "ColorSpace",
        36868: "DateTimeDigitized",
        36867: "DateTimeOriginal",
        34665: "Exif IFD",
        36864: "ExifVersion",
        33434: "ExposureTime",
        41728: "FileSource",
        37385: "Flash",
        40960: "FlashpixVersion",
        33437: "FNumber",
        42016: "ImageUniqueID",
        37384: "LightSource",
        37500: "MakerNote",
        37377: "ShutterSpeedValue",
        37510: "UserComment",
        33723: "IPTC",
        34675: "ICC Profile",
        700: "XMP",
        42112: "GDAL_METADATA",
        42113: "GDAL_NODATA",
        34377: "Photoshop"
    },
    fieldTypeNames: {
        1: "BYTE",
        2: "ASCII",
        3: "SHORT",
        4: "LONG",
        5: "RATIONAL",
        6: "SBYTE",
        7: "UNDEFINED",
        8: "SSHORT",
        9: "SLONG",
        10: "SRATIONAL",
        11: "FLOAT",
        12: "DOUBLE"
    }
};
cc.Particle = function(a, b, c, d, e, f, g, h, k, m, n, q) {
    this.pos = a ? a : cc.p(0, 0);
    this.startPos = b ? b : cc.p(0, 0);
    this.color = c ? c : {
        r: 0,
        g: 0,
        b: 0,
        a: 255
    };
    this.deltaColor = d ? d : {
        r: 0,
        g: 0,
        b: 0,
        a: 255
    };
    this.size = e || 0;
    this.deltaSize = f || 0;
    this.rotation = g || 0;
    this.deltaRotation = h || 0;
    this.timeToLive = k || 0;
    this.atlasIndex = m || 0;
    this.modeA = n ? n : new cc.Particle.ModeA;
    this.modeB = q ? q : new cc.Particle.ModeB;
    this.isChangeColor = !1;
    this.drawPos = cc.p(0, 0)
};
cc.Particle.ModeA = function(a, b, c) {
    this.dir = a ? a : cc.p(0, 0);
    this.radialAccel = b || 0;
    this.tangentialAccel = c || 0
};
cc.Particle.ModeB = function(a, b, c, d) {
    this.angle = a || 0;
    this.degreesPerSecond = b || 0;
    this.radius = c || 0;
    this.deltaRadius = d || 0
};
cc.Particle.TemporaryPoints = [cc.p(), cc.p(), cc.p(), cc.p()];
cc.ParticleSystem = cc.Node.extend({
    _plistFile: "",
    _elapsed: 0,
    _dontTint: !1,
    modeA: null,
    modeB: null,
    _className: "ParticleSystem",
    _pointZeroForParticle: cc.p(0, 0),
    _particles: null,
    _emitCounter: 0,
    _particleIdx: 0,
    _batchNode: null,
    atlasIndex: 0,
    _transformSystemDirty: !1,
    _allocatedParticles: 0,
    drawMode: null,
    shapeType: null,
    _isActive: !1,
    particleCount: 0,
    duration: 0,
    _sourcePosition: null,
    _posVar: null,
    life: 0,
    lifeVar: 0,
    angle: 0,
    angleVar: 0,
    startSize: 0,
    startSizeVar: 0,
    endSize: 0,
    endSizeVar: 0,
    _startColor: null,
    _startColorVar: null,
    _endColor: null,
    _endColorVar: null,
    startSpin: 0,
    startSpinVar: 0,
    endSpin: 0,
    endSpinVar: 0,
    emissionRate: 0,
    _totalParticles: 0,
    _texture: null,
    _blendFunc: null,
    _opacityModifyRGB: !1,
    positionType: null,
    autoRemoveOnFinish: !1,
    emitterMode: 0,
    _quads: null,
    _indices: null,
    _buffersVBO: null,
    _pointRect: null,
    _textureLoaded: null,
    _quadsArrayBuffer: null,
    ctor: function(a) {
        cc.Node.prototype.ctor.call(this);
        this.emitterMode = cc.ParticleSystem.MODE_GRAVITY;
        this.modeA = new cc.ParticleSystem.ModeA;
        this.modeB = new cc.ParticleSystem.ModeB;
        this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        };
        this._particles = [];
        this._sourcePosition = cc.p(0, 0);
        this._posVar = cc.p(0, 0);
        this._startColor = cc.color(255, 255, 255, 255);
        this._startColorVar = cc.color(255, 255, 255, 255);
        this._endColor = cc.color(255, 255, 255, 255);
        this._endColorVar = cc.color(255, 255, 255, 255);
        this._plistFile = "";
        this._elapsed = 0;
        this._dontTint = !1;
        this._pointZeroForParticle = cc.p(0, 0);
        this._particleIdx = this._emitCounter = 0;
        this._batchNode = null;
        this.atlasIndex = 0;
        this._transformSystemDirty = !1;
        this._allocatedParticles =
            0;
        this.drawMode = cc.ParticleSystem.SHAPE_MODE;
        this.shapeType = cc.ParticleSystem.BALL_SHAPE;
        this._isActive = !1;
        this._totalParticles = this.emissionRate = this.endSpinVar = this.endSpin = this.startSpinVar = this.startSpin = this.endSizeVar = this.endSize = this.startSizeVar = this.startSize = this.angleVar = this.angle = this.lifeVar = this.life = this.duration = this.particleCount = 0;
        this._texture = null;
        this._opacityModifyRGB = !1;
        this.positionType = cc.ParticleSystem.TYPE_FREE;
        this.autoRemoveOnFinish = !1;
        this._buffersVBO = [0, 0];
        this._quads = [];
        this._indices = [];
        this._pointRect = cc.rect(0, 0, 0, 0);
        this._textureLoaded = !0;
        cc._renderType === cc._RENDER_TYPE_WEBGL && (this._quadsArrayBuffer = null);
        !a || cc.isNumber(a) ? (a = a || 100, this.setDrawMode(cc.ParticleSystem.TEXTURE_MODE), this.initWithTotalParticles(a)) : a && this.initWithFile(a)
    },
    _initRendererCmd: function() {
        this._rendererCmd = cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.ParticleRenderCmdCanvas(this) : new cc.ParticleRenderCmdWebGL(this)
    },
    initIndices: function() {
        for (var a = this._indices, b = 0, c = this._totalParticles; b <
            c; ++b) {
            var d = 6 * b,
                e = 4 * b;
            a[d + 0] = e + 0;
            a[d + 1] = e + 1;
            a[d + 2] = e + 2;
            a[d + 5] = e + 1;
            a[d + 4] = e + 2;
            a[d + 3] = e + 3
        }
    },
    initTexCoordsWithRect: function(a) {
        var b = cc.contentScaleFactor(),
            c = cc.rect(a.x * b, a.y * b, a.width * b, a.height * b),
            d = a.width,
            e = a.height;
        this._texture && (d = this._texture.pixelsWidth, e = this._texture.pixelsHeight);
        if (cc._renderType !== cc._RENDER_TYPE_CANVAS) {
            cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (a = (2 * c.x + 1) / (2 * d), b = (2 * c.y + 1) / (2 * e), d = a + (2 * c.width - 2) / (2 * d), c = b + (2 * c.height - 2) / (2 * e)) : (a = c.x / d, b = c.y / e, d = a + c.width / d, c = b + c.height /
                e);
            var e = c,
                c = b,
                b = e,
                f = 0,
                g = 0;
            this._batchNode ? (e = this._batchNode.textureAtlas.quads, f = this.atlasIndex, g = this.atlasIndex + this._totalParticles) : (e = this._quads, f = 0, g = this._totalParticles);
            for (; f < g; f++) {
                e[f] || (e[f] = cc.V3F_C4B_T2F_QuadZero());
                var h = e[f];
                h.bl.texCoords.u = a;
                h.bl.texCoords.v = b;
                h.br.texCoords.u = d;
                h.br.texCoords.v = b;
                h.tl.texCoords.u = a;
                h.tl.texCoords.v = c;
                h.tr.texCoords.u = d;
                h.tr.texCoords.v = c
            }
        }
    },
    getBatchNode: function() {
        return this._batchNode
    },
    setBatchNode: function(a) {
        if (this._batchNode != a) {
            var b =
                this._batchNode;
            if (this._batchNode = a)
                for (var c = this._particles, d = 0; d < this._totalParticles; d++) c[d].atlasIndex = d;
            a ? b || (this._batchNode.textureAtlas._copyQuadsToTextureAtlas(this._quads, this.atlasIndex), cc._renderContext.deleteBuffer(this._buffersVBO[1])) : (this._allocMemory(), this.initIndices(), this.setTexture(b.getTexture()), this._setupVBO())
        }
    },
    getAtlasIndex: function() {
        return this.atlasIndex
    },
    setAtlasIndex: function(a) {
        this.atlasIndex = a
    },
    getDrawMode: function() {
        return this.drawMode
    },
    setDrawMode: function(a) {
        this.drawMode =
            a;
        this._rendererCmd && (this._rendererCmd._drawMode = a)
    },
    getShapeType: function() {
        return this.shapeType
    },
    setShapeType: function(a) {
        this.shapeType = a;
        this._rendererCmd && (this._rendererCmd._shapeType = a)
    },
    isActive: function() {
        return this._isActive
    },
    getParticleCount: function() {
        return this.particleCount
    },
    setParticleCount: function(a) {
        this.particleCount = a
    },
    getDuration: function() {
        return this.duration
    },
    setDuration: function(a) {
        this.duration = a
    },
    getSourcePosition: function() {
        return {
            x: this._sourcePosition.x,
            y: this._sourcePosition.y
        }
    },
    setSourcePosition: function(a) {
        this._sourcePosition = a
    },
    getPosVar: function() {
        return {
            x: this._posVar.x,
            y: this._posVar.y
        }
    },
    setPosVar: function(a) {
        this._posVar = a
    },
    getLife: function() {
        return this.life
    },
    setLife: function(a) {
        this.life = a
    },
    getLifeVar: function() {
        return this.lifeVar
    },
    setLifeVar: function(a) {
        this.lifeVar = a
    },
    getAngle: function() {
        return this.angle
    },
    setAngle: function(a) {
        this.angle = a
    },
    getAngleVar: function() {
        return this.angleVar
    },
    setAngleVar: function(a) {
        this.angleVar = a
    },
    getGravity: function() {
        this.emitterMode !==
            cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getGravity() : Particle Mode should be Gravity");
        var a = this.modeA.gravity;
        return cc.p(a.x, a.y)
    },
    setGravity: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setGravity() : Particle Mode should be Gravity");
        this.modeA.gravity = a
    },
    getSpeed: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getSpeed() : Particle Mode should be Gravity");
        return this.modeA.speed
    },
    setSpeed: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setSpeed() : Particle Mode should be Gravity");
        this.modeA.speed = a
    },
    getSpeedVar: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getSpeedVar() : Particle Mode should be Gravity");
        return this.modeA.speedVar
    },
    setSpeedVar: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setSpeedVar() : Particle Mode should be Gravity");
        this.modeA.speedVar = a
    },
    getTangentialAccel: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getTangentialAccel() : Particle Mode should be Gravity");
        return this.modeA.tangentialAccel
    },
    setTangentialAccel: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setTangentialAccel() : Particle Mode should be Gravity");
        this.modeA.tangentialAccel = a
    },
    getTangentialAccelVar: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY &&
            cc.log("cc.ParticleBatchNode.getTangentialAccelVar() : Particle Mode should be Gravity");
        return this.modeA.tangentialAccelVar
    },
    setTangentialAccelVar: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setTangentialAccelVar() : Particle Mode should be Gravity");
        this.modeA.tangentialAccelVar = a
    },
    getRadialAccel: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getRadialAccel() : Particle Mode should be Gravity");
        return this.modeA.radialAccel
    },
    setRadialAccel: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setRadialAccel() : Particle Mode should be Gravity");
        this.modeA.radialAccel = a
    },
    getRadialAccelVar: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getRadialAccelVar() : Particle Mode should be Gravity");
        return this.modeA.radialAccelVar
    },
    setRadialAccelVar: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setRadialAccelVar() : Particle Mode should be Gravity");
        this.modeA.radialAccelVar = a
    },
    getRotationIsDir: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getRotationIsDir() : Particle Mode should be Gravity");
        return this.modeA.rotationIsDir
    },
    setRotationIsDir: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setRotationIsDir() : Particle Mode should be Gravity");
        this.modeA.rotationIsDir = a
    },
    getStartRadius: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getStartRadius() : Particle Mode should be Radius");
        return this.modeB.startRadius
    },
    setStartRadius: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setStartRadius() : Particle Mode should be Radius");
        this.modeB.startRadius = a
    },
    getStartRadiusVar: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getStartRadiusVar() : Particle Mode should be Radius");
        return this.modeB.startRadiusVar
    },
    setStartRadiusVar: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setStartRadiusVar() : Particle Mode should be Radius");
        this.modeB.startRadiusVar = a
    },
    getEndRadius: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getEndRadius() : Particle Mode should be Radius");
        return this.modeB.endRadius
    },
    setEndRadius: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setEndRadius() : Particle Mode should be Radius");
        this.modeB.endRadius = a
    },
    getEndRadiusVar: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getEndRadiusVar() : Particle Mode should be Radius");
        return this.modeB.endRadiusVar
    },
    setEndRadiusVar: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setEndRadiusVar() : Particle Mode should be Radius");
        this.modeB.endRadiusVar = a
    },
    getRotatePerSecond: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getRotatePerSecond() : Particle Mode should be Radius");
        return this.modeB.rotatePerSecond
    },
    setRotatePerSecond: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setRotatePerSecond() : Particle Mode should be Radius");
        this.modeB.rotatePerSecond = a
    },
    getRotatePerSecondVar: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getRotatePerSecondVar() : Particle Mode should be Radius");
        return this.modeB.rotatePerSecondVar
    },
    setRotatePerSecondVar: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setRotatePerSecondVar() : Particle Mode should be Radius");
        this.modeB.rotatePerSecondVar = a
    },
    setScale: function(a, b) {
        this._transformSystemDirty = !0;
        cc.Node.prototype.setScale.call(this,
            a, b)
    },
    setRotation: function(a) {
        this._transformSystemDirty = !0;
        cc.Node.prototype.setRotation.call(this, a)
    },
    setScaleX: function(a) {
        this._transformSystemDirty = !0;
        cc.Node.prototype.setScaleX.call(this, a)
    },
    setScaleY: function(a) {
        this._transformSystemDirty = !0;
        cc.Node.prototype.setScaleY.call(this, a)
    },
    getStartSize: function() {
        return this.startSize
    },
    setStartSize: function(a) {
        this.startSize = a
    },
    getStartSizeVar: function() {
        return this.startSizeVar
    },
    setStartSizeVar: function(a) {
        this.startSizeVar = a
    },
    getEndSize: function() {
        return this.endSize
    },
    setEndSize: function(a) {
        this.endSize = a
    },
    getEndSizeVar: function() {
        return this.endSizeVar
    },
    setEndSizeVar: function(a) {
        this.endSizeVar = a
    },
    getStartColor: function() {
        return cc.color(this._startColor.r, this._startColor.g, this._startColor.b, this._startColor.a)
    },
    setStartColor: function(a) {
        this._startColor = cc.color(a)
    },
    getStartColorVar: function() {
        return cc.color(this._startColorVar.r, this._startColorVar.g, this._startColorVar.b, this._startColorVar.a)
    },
    setStartColorVar: function(a) {
        this._startColorVar = cc.color(a)
    },
    getEndColor: function() {
        return cc.color(this._endColor.r, this._endColor.g, this._endColor.b, this._endColor.a)
    },
    setEndColor: function(a) {
        this._endColor = cc.color(a)
    },
    getEndColorVar: function() {
        return cc.color(this._endColorVar.r, this._endColorVar.g, this._endColorVar.b, this._endColorVar.a)
    },
    setEndColorVar: function(a) {
        this._endColorVar = cc.color(a)
    },
    getStartSpin: function() {
        return this.startSpin
    },
    setStartSpin: function(a) {
        this.startSpin = a
    },
    getStartSpinVar: function() {
        return this.startSpinVar
    },
    setStartSpinVar: function(a) {
        this.startSpinVar =
            a
    },
    getEndSpin: function() {
        return this.endSpin
    },
    setEndSpin: function(a) {
        this.endSpin = a
    },
    getEndSpinVar: function() {
        return this.endSpinVar
    },
    setEndSpinVar: function(a) {
        this.endSpinVar = a
    },
    getEmissionRate: function() {
        return this.emissionRate
    },
    setEmissionRate: function(a) {
        this.emissionRate = a
    },
    getTotalParticles: function() {
        return this._totalParticles
    },
    setTotalParticles: function(a) {
        if (cc._renderType === cc._RENDER_TYPE_CANVAS) this._totalParticles = 200 > a ? a : 200;
        else {
            if (a > this._allocatedParticles) {
                var b = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
                this._indices = new Uint16Array(6 * a);
                var c = new ArrayBuffer(a * b),
                    d = this._particles;
                d.length = 0;
                for (var e = this._quads, f = e.length = 0; f < a; f++) d[f] = new cc.Particle, e[f] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, c, f * b);
                this._totalParticles = this._allocatedParticles = a;
                if (this._batchNode)
                    for (b = 0; b < a; b++) d[b].atlasIndex = b;
                this._quadsArrayBuffer = c;
                this.initIndices();
                this._setupVBO();
                this._texture && this.initTexCoordsWithRect(cc.rect(0, 0, this._texture.width, this._texture.height))
            } else this._totalParticles = a;
            this.resetSystem()
        }
    },
    getTexture: function() {
        return this._texture
    },
    setTexture: function(a) {
        a.isLoaded() ? this.setTextureWithRect(a, cc.rect(0, 0, a.width, a.height)) : (this._textureLoaded = !1, a.addEventListener("load", function(a) {
            this._textureLoaded = !0;
            this.setTextureWithRect(a, cc.rect(0, 0, a.width, a.height))
        }, this))
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    setBlendFunc: function(a, b) {
        if (void 0 === b) this._blendFunc != a && (this._blendFunc = a, this._updateBlendFunc());
        else if (this._blendFunc.src != a || this._blendFunc.dst != b) this._blendFunc = {
            src: a,
            dst: b
        }, this._updateBlendFunc()
    },
    isOpacityModifyRGB: function() {
        return this._opacityModifyRGB
    },
    setOpacityModifyRGB: function(a) {
        this._opacityModifyRGB = a
    },
    isBlendAdditive: function() {
        return this._blendFunc.src == cc.SRC_ALPHA && this._blendFunc.dst == cc.ONE || this._blendFunc.src == cc.ONE && this._blendFunc.dst == cc.ONE
    },
    setBlendAdditive: function(a) {
        var b = this._blendFunc;
        a ? (b.src = cc.SRC_ALPHA, b.dst = cc.ONE) : cc._renderType === cc._RENDER_TYPE_WEBGL ? this._texture && !this._texture.hasPremultipliedAlpha() ? (b.src =
            cc.SRC_ALPHA, b.dst = cc.ONE_MINUS_SRC_ALPHA) : (b.src = cc.BLEND_SRC, b.dst = cc.BLEND_DST) : (b.src = cc.BLEND_SRC, b.dst = cc.BLEND_DST)
    },
    getPositionType: function() {
        return this.positionType
    },
    setPositionType: function(a) {
        this.positionType = a
    },
    isAutoRemoveOnFinish: function() {
        return this.autoRemoveOnFinish
    },
    setAutoRemoveOnFinish: function(a) {
        this.autoRemoveOnFinish = a
    },
    getEmitterMode: function() {
        return this.emitterMode
    },
    setEmitterMode: function(a) {
        this.emitterMode = a
    },
    init: function() {
        return this.initWithTotalParticles(150)
    },
    initWithFile: function(a) {
        this._plistFile = a;
        a = cc.loader.getRes(a);
        return !a ? (cc.log("cc.ParticleSystem.initWithFile(): Particles: file not found"), !1) : this.initWithDictionary(a, "")
    },
    getBoundingBoxToWorld: function() {
        return cc.rect(0, 0, cc._canvas.width, cc._canvas.height)
    },
    initWithDictionary: function(a, b) {
        var c = !1,
            d = null,
            d = this._valueForKey,
            e = parseInt(d("maxParticles", a));
        if (this.initWithTotalParticles(e)) {
            this.angle = parseFloat(d("angle", a));
            this.angleVar = parseFloat(d("angleVariance", a));
            this.duration =
                parseFloat(d("duration", a));
            this._blendFunc.src = parseInt(d("blendFuncSource", a));
            this._blendFunc.dst = parseInt(d("blendFuncDestination", a));
            c = this._startColor;
            c.r = 255 * parseFloat(d("startColorRed", a));
            c.g = 255 * parseFloat(d("startColorGreen", a));
            c.b = 255 * parseFloat(d("startColorBlue", a));
            c.a = 255 * parseFloat(d("startColorAlpha", a));
            c = this._startColorVar;
            c.r = 255 * parseFloat(d("startColorVarianceRed", a));
            c.g = 255 * parseFloat(d("startColorVarianceGreen", a));
            c.b = 255 * parseFloat(d("startColorVarianceBlue", a));
            c.a =
                255 * parseFloat(d("startColorVarianceAlpha", a));
            c = this._endColor;
            c.r = 255 * parseFloat(d("finishColorRed", a));
            c.g = 255 * parseFloat(d("finishColorGreen", a));
            c.b = 255 * parseFloat(d("finishColorBlue", a));
            c.a = 255 * parseFloat(d("finishColorAlpha", a));
            c = this._endColorVar;
            c.r = 255 * parseFloat(d("finishColorVarianceRed", a));
            c.g = 255 * parseFloat(d("finishColorVarianceGreen", a));
            c.b = 255 * parseFloat(d("finishColorVarianceBlue", a));
            c.a = 255 * parseFloat(d("finishColorVarianceAlpha", a));
            this.startSize = parseFloat(d("startParticleSize",
                a));
            this.startSizeVar = parseFloat(d("startParticleSizeVariance", a));
            this.endSize = parseFloat(d("finishParticleSize", a));
            this.endSizeVar = parseFloat(d("finishParticleSizeVariance", a));
            this.setPosition(parseFloat(d("sourcePositionx", a)), parseFloat(d("sourcePositiony", a)));
            this._posVar.x = parseFloat(d("sourcePositionVariancex", a));
            this._posVar.y = parseFloat(d("sourcePositionVariancey", a));
            this.startSpin = parseFloat(d("rotationStart", a));
            this.startSpinVar = parseFloat(d("rotationStartVariance", a));
            this.endSpin =
                parseFloat(d("rotationEnd", a));
            this.endSpinVar = parseFloat(d("rotationEndVariance", a));
            this.emitterMode = parseInt(d("emitterType", a));
            if (this.emitterMode == cc.ParticleSystem.MODE_GRAVITY) c = this.modeA, c.gravity.x = parseFloat(d("gravityx", a)), c.gravity.y = parseFloat(d("gravityy", a)), c.speed = parseFloat(d("speed", a)), c.speedVar = parseFloat(d("speedVariance", a)), e = d("radialAcceleration", a), c.radialAccel = e ? parseFloat(e) : 0, e = d("radialAccelVariance", a), c.radialAccelVar = e ? parseFloat(e) : 0, e = d("tangentialAcceleration",
                a), c.tangentialAccel = e ? parseFloat(e) : 0, e = d("tangentialAccelVariance", a), c.tangentialAccelVar = e ? parseFloat(e) : 0, e = d("rotationIsDir", a).toLowerCase(), c.rotationIsDir = null != e && ("true" === e || "1" === e);
            else if (this.emitterMode == cc.ParticleSystem.MODE_RADIUS) c = this.modeB, c.startRadius = parseFloat(d("maxRadius", a)), c.startRadiusVar = parseFloat(d("maxRadiusVariance", a)), c.endRadius = parseFloat(d("minRadius", a)), c.endRadiusVar = 0, c.rotatePerSecond = parseFloat(d("rotatePerSecond", a)), c.rotatePerSecondVar = parseFloat(d("rotatePerSecondVariance",
                a));
            else return cc.log("cc.ParticleSystem.initWithDictionary(): Invalid emitterType in config file"), !1;
            this.life = parseFloat(d("particleLifespan", a));
            this.lifeVar = parseFloat(d("particleLifespanVariance", a));
            this.emissionRate = this._totalParticles / this.life;
            if (!this._batchNode)
                if (this._opacityModifyRGB = !1, c = d("textureFileName", a), c = cc.path.changeBasename(this._plistFile, c), e = cc.textureCache.getTextureForKey(c)) this.setTexture(e);
                else if (d = d("textureImageData", a), !d || 0 === d.length) {
                e = cc.textureCache.addImage(c);
                if (!e) return !1;
                this.setTexture(e)
            } else {
                d = cc.unzipBase64AsArray(d, 1);
                if (!d) return cc.log("cc.ParticleSystem: error decoding or ungzipping textureImageData"), !1;
                e = cc.getImageFormatByData(d);
                if (e !== cc.FMT_TIFF && e !== cc.FMT_PNG) return cc.log("cc.ParticleSystem: unknown image format with Data"), !1;
                var f = cc.newElement("canvas");
                e === cc.FMT_PNG ? (new cc.PNGReader(d)).render(f) : cc.tiffReader.parseTIFF(d, f);
                cc.textureCache.cacheImage(c, f);
                (d = cc.textureCache.getTextureForKey(c)) || cc.log("cc.ParticleSystem.initWithDictionary() : error loading the texture");
                this.setTexture(d)
            }
            c = !0
        }
        return c
    },
    initWithTotalParticles: function(a) {
        this._totalParticles = a;
        var b, c = this._particles;
        for (b = c.length = 0; b < a; b++) c[b] = new cc.Particle;
        if (!c) return cc.log("Particle system: not enough memory"), !1;
        this._allocatedParticles = a;
        if (this._batchNode)
            for (b = 0; b < this._totalParticles; b++) c[b].atlasIndex = b;
        this._isActive = !0;
        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;
        this.positionType = cc.ParticleSystem.TYPE_FREE;
        this.emitterMode = cc.ParticleSystem.MODE_GRAVITY;
        this._transformSystemDirty =
            this.autoRemoveOnFinish = !1;
        this.scheduleUpdateWithPriority(1);
        if (cc._renderType === cc._RENDER_TYPE_WEBGL) {
            if (!this._allocMemory()) return !1;
            this.initIndices();
            this._setupVBO();
            this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)
        }
        return !0
    },
    destroyParticleSystem: function() {
        this.unscheduleUpdate()
    },
    addParticle: function() {
        if (this.isFull()) return !1;
        var a, b = this._particles;
        cc._renderType === cc._RENDER_TYPE_CANVAS ? this.particleCount < b.length ? a = b[this.particleCount] : (a = new cc.Particle,
            b.push(a)) : a = b[this.particleCount];
        this.initParticle(a);
        ++this.particleCount;
        return !0
    },
    initParticle: function(a) {
        var b = cc.randomMinus1To1;
        a.timeToLive = this.life + this.lifeVar * b();
        a.timeToLive = Math.max(0, a.timeToLive);
        a.pos.x = this._sourcePosition.x + this._posVar.x * b();
        a.pos.y = this._sourcePosition.y + this._posVar.y * b();
        var c, d;
        c = this._startColor;
        var e = this._startColorVar,
            f = this._endColor;
        d = this._endColorVar;
        cc._renderType === cc._RENDER_TYPE_CANVAS ? (c = cc.color(cc.clampf(c.r + e.r * b(), 0, 255), cc.clampf(c.g + e.g *
            b(), 0, 255), cc.clampf(c.b + e.b * b(), 0, 255), cc.clampf(c.a + e.a * b(), 0, 255)), d = cc.color(cc.clampf(f.r + d.r * b(), 0, 255), cc.clampf(f.g + d.g * b(), 0, 255), cc.clampf(f.b + d.b * b(), 0, 255), cc.clampf(f.a + d.a * b(), 0, 255))) : (c = {
            r: cc.clampf(c.r + e.r * b(), 0, 255),
            g: cc.clampf(c.g + e.g * b(), 0, 255),
            b: cc.clampf(c.b + e.b * b(), 0, 255),
            a: cc.clampf(c.a + e.a * b(), 0, 255)
        }, d = {
            r: cc.clampf(f.r + d.r * b(), 0, 255),
            g: cc.clampf(f.g + d.g * b(), 0, 255),
            b: cc.clampf(f.b + d.b * b(), 0, 255),
            a: cc.clampf(f.a + d.a * b(), 0, 255)
        });
        a.color = c;
        e = a.deltaColor;
        f = a.timeToLive;
        e.r =
            (d.r - c.r) / f;
        e.g = (d.g - c.g) / f;
        e.b = (d.b - c.b) / f;
        e.a = (d.a - c.a) / f;
        c = this.startSize + this.startSizeVar * b();
        c = Math.max(0, c);
        a.size = c;
        this.endSize === cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE ? a.deltaSize = 0 : (d = this.endSize + this.endSizeVar * b(), d = Math.max(0, d), a.deltaSize = (d - c) / f);
        c = this.startSpin + this.startSpinVar * b();
        d = this.endSpin + this.endSpinVar * b();
        a.rotation = c;
        a.deltaRotation = (d - c) / f;
        this.positionType == cc.ParticleSystem.TYPE_FREE ? a.startPos = this.convertToWorldSpace(this._pointZeroForParticle) : this.positionType ==
            cc.ParticleSystem.TYPE_RELATIVE && (a.startPos.x = this._position.x, a.startPos.y = this._position.y);
        c = cc.degreesToRadians(this.angle + this.angleVar * b());
        if (this.emitterMode === cc.ParticleSystem.MODE_GRAVITY) f = this.modeA, d = a.modeA, e = f.speed + f.speedVar * b(), d.dir.x = Math.cos(c), d.dir.y = Math.sin(c), cc.pMultIn(d.dir, e), d.radialAccel = f.radialAccel + f.radialAccelVar * b(), d.tangentialAccel = f.tangentialAccel + f.tangentialAccelVar * b(), f.rotationIsDir && (a.rotation = -cc.radiansToDegrees(cc.pToAngle(d.dir)));
        else {
            d = this.modeB;
            a = a.modeB;
            var e = d.startRadius + d.startRadiusVar * b(),
                g = d.endRadius + d.endRadiusVar * b();
            a.radius = e;
            a.deltaRadius = d.endRadius === cc.ParticleSystem.START_RADIUS_EQUAL_TO_END_RADIUS ? 0 : (g - e) / f;
            a.angle = c;
            a.degreesPerSecond = cc.degreesToRadians(d.rotatePerSecond + d.rotatePerSecondVar * b())
        }
    },
    stopSystem: function() {
        this._isActive = !1;
        this._elapsed = this.duration;
        this._emitCounter = 0
    },
    resetSystem: function() {
        this._isActive = !0;
        this._elapsed = 0;
        var a = this._particles;
        for (this._particleIdx = 0; this._particleIdx < this.particleCount; ++this._particleIdx) a[this._particleIdx].timeToLive =
            0
    },
    isFull: function() {
        return this.particleCount >= this._totalParticles
    },
    updateQuadWithParticle: function(a, b) {
        var c = null;
        this._batchNode ? (c = this._batchNode.textureAtlas.quads[this.atlasIndex + a.atlasIndex], this._batchNode.textureAtlas.dirty = !0) : c = this._quads[this._particleIdx];
        var d, e, f, g;
        this._opacityModifyRGB ? (d = 0 | a.color.r * a.color.a / 255, e = 0 | a.color.g * a.color.a / 255, f = 0 | a.color.b * a.color.a / 255) : (d = 0 | a.color.r, e = 0 | a.color.g, f = 0 | a.color.b);
        g = 0 | a.color.a;
        var h = c.bl.colors;
        h.r = d;
        h.g = e;
        h.b = f;
        h.a = g;
        h = c.br.colors;
        h.r = d;
        h.g = e;
        h.b = f;
        h.a = g;
        h = c.tl.colors;
        h.r = d;
        h.g = e;
        h.b = f;
        h.a = g;
        h = c.tr.colors;
        h.r = d;
        h.g = e;
        h.b = f;
        h.a = g;
        d = a.size / 2;
        if (a.rotation) {
            e = -d;
            f = -d;
            g = b.x;
            var h = b.y,
                k = -cc.degreesToRadians(a.rotation),
                m = Math.cos(k),
                k = Math.sin(k);
            c.bl.vertices.x = e * m - f * k + g;
            c.bl.vertices.y = e * k + f * m + h;
            c.br.vertices.x = d * m - f * k + g;
            c.br.vertices.y = d * k + f * m + h;
            c.tl.vertices.x = e * m - d * k + g;
            c.tl.vertices.y = e * k + d * m + h;
            c.tr.vertices.x = d * m - d * k + g;
            c.tr.vertices.y = d * k + d * m + h
        } else c.bl.vertices.x = b.x - d, c.bl.vertices.y = b.y - d, c.br.vertices.x = b.x + d, c.br.vertices.y =
            b.y - d, c.tl.vertices.x = b.x - d, c.tl.vertices.y = b.y + d, c.tr.vertices.x = b.x + d, c.tr.vertices.y = b.y + d
    },
    postStep: function() {
        if (cc._renderType === cc._RENDER_TYPE_WEBGL) {
            var a = cc._renderContext;
            a.bindBuffer(a.ARRAY_BUFFER, this._buffersVBO[0]);
            a.bufferData(a.ARRAY_BUFFER, this._quadsArrayBuffer, a.DYNAMIC_DRAW)
        }
    },
    update: function(a) {
        if (this._isActive && this.emissionRate) {
            var b = 1 / this.emissionRate;
            this.particleCount < this._totalParticles && (this._emitCounter += a);
            for (; this.particleCount < this._totalParticles && this._emitCounter >
                b;) this.addParticle(), this._emitCounter -= b;
            this._elapsed += a; - 1 != this.duration && this.duration < this._elapsed && this.stopSystem()
        }
        this._particleIdx = 0;
        b = cc.Particle.TemporaryPoints[0];
        this.positionType == cc.ParticleSystem.TYPE_FREE ? cc.pIn(b, this.convertToWorldSpace(this._pointZeroForParticle)) : this.positionType == cc.ParticleSystem.TYPE_RELATIVE && (b.x = this._position.x, b.y = this._position.y);
        if (this._visible) {
            for (var c = cc.Particle.TemporaryPoints[1], d = cc.Particle.TemporaryPoints[2], e = cc.Particle.TemporaryPoints[3],
                f = this._particles; this._particleIdx < this.particleCount;) {
                cc.pZeroIn(c);
                cc.pZeroIn(d);
                cc.pZeroIn(e);
                var g = f[this._particleIdx];
                g.timeToLive -= a;
                if (0 < g.timeToLive) {
                    if (this.emitterMode == cc.ParticleSystem.MODE_GRAVITY) {
                        var h = e,
                            k = c,
                            m = d;
                        g.pos.x || g.pos.y ? (cc.pIn(k, g.pos), cc.pNormalizeIn(k)) : cc.pZeroIn(k);
                        cc.pIn(m, k);
                        cc.pMultIn(k, g.modeA.radialAccel);
                        var n = m.x;
                        m.x = -m.y;
                        m.y = n;
                        cc.pMultIn(m, g.modeA.tangentialAccel);
                        cc.pIn(h, k);
                        cc.pAddIn(h, m);
                        cc.pAddIn(h, this.modeA.gravity);
                        cc.pMultIn(h, a);
                        cc.pAddIn(g.modeA.dir,
                            h);
                        cc.pIn(h, g.modeA.dir);
                        cc.pMultIn(h, a);
                        cc.pAddIn(g.pos, h)
                    } else h = g.modeB, h.angle += h.degreesPerSecond * a, h.radius += h.deltaRadius * a, g.pos.x = -Math.cos(h.angle) * h.radius, g.pos.y = -Math.sin(h.angle) * h.radius; if (!this._dontTint || cc._renderType === cc._RENDER_TYPE_WEBGL) g.color.r += g.deltaColor.r * a, g.color.g += g.deltaColor.g * a, g.color.b += g.deltaColor.b * a, g.color.a += g.deltaColor.a * a, g.isChangeColor = !0;
                    g.size += g.deltaSize * a;
                    g.size = Math.max(0, g.size);
                    g.rotation += g.deltaRotation * a;
                    h = c;
                    this.positionType == cc.ParticleSystem.TYPE_FREE ||
                        this.positionType == cc.ParticleSystem.TYPE_RELATIVE ? (k = d, cc.pIn(k, b), cc.pSubIn(k, g.startPos), cc.pIn(h, g.pos), cc.pSubIn(h, k)) : cc.pIn(h, g.pos);
                    this._batchNode && (h.x += this._position.x, h.y += this._position.y);
                    cc._renderType == cc._RENDER_TYPE_WEBGL ? this.updateQuadWithParticle(g, h) : cc.pIn(g.drawPos, h);
                    ++this._particleIdx
                } else if (g = g.atlasIndex, this._particleIdx !== this.particleCount - 1 && (h = f[this._particleIdx], f[this._particleIdx] = f[this.particleCount - 1], f[this.particleCount - 1] = h), this._batchNode && (this._batchNode.disableParticle(this.atlasIndex +
                    g), f[this.particleCount - 1].atlasIndex = g), --this.particleCount, 0 == this.particleCount && this.autoRemoveOnFinish) {
                    this.unscheduleUpdate();
                    this._parent.removeChild(this, !0);
                    return
                }
            }
            this._transformSystemDirty = !1
        }
        this._batchNode || this.postStep()
    },
    updateWithNoTime: function() {
        this.update(0)
    },
    _valueForKey: function(a, b) {
        if (b) {
            var c = b[a];
            return null != c ? c : ""
        }
        return ""
    },
    _updateBlendFunc: function() {
        if (this._batchNode) cc.log("Can't change blending functions when the particle is being batched");
        else {
            var a = this._texture;
            if (a && a instanceof cc.Texture2D) {
                this._opacityModifyRGB = !1;
                var b = this._blendFunc;
                b.src == cc.BLEND_SRC && b.dst == cc.BLEND_DST && (a.hasPremultipliedAlpha() ? this._opacityModifyRGB = !0 : (b.src = cc.SRC_ALPHA, b.dst = cc.ONE_MINUS_SRC_ALPHA))
            }
        }
    },
    clone: function() {
        var a = new cc.ParticleSystem;
        if (a.initWithTotalParticles(this.getTotalParticles())) {
            a.setAngle(this.getAngle());
            a.setAngleVar(this.getAngleVar());
            a.setDuration(this.getDuration());
            var b = this.getBlendFunc();
            a.setBlendFunc(b.src, b.dst);
            a.setStartColor(this.getStartColor());
            a.setStartColorVar(this.getStartColorVar());
            a.setEndColor(this.getEndColor());
            a.setEndColorVar(this.getEndColorVar());
            a.setStartSize(this.getStartSize());
            a.setStartSizeVar(this.getStartSizeVar());
            a.setEndSize(this.getEndSize());
            a.setEndSizeVar(this.getEndSizeVar());
            a.setPosition(cc.p(this.x, this.y));
            a.setPosVar(cc.p(this.getPosVar().x, this.getPosVar().y));
            a.setStartSpin(this.getStartSpin() || 0);
            a.setStartSpinVar(this.getStartSpinVar() || 0);
            a.setEndSpin(this.getEndSpin() || 0);
            a.setEndSpinVar(this.getEndSpinVar() ||
                0);
            a.setEmitterMode(this.getEmitterMode());
            this.getEmitterMode() == cc.ParticleSystem.MODE_GRAVITY ? (b = this.getGravity(), a.setGravity(cc.p(b.x, b.y)), a.setSpeed(this.getSpeed()), a.setSpeedVar(this.getSpeedVar()), a.setRadialAccel(this.getRadialAccel()), a.setRadialAccelVar(this.getRadialAccelVar()), a.setTangentialAccel(this.getTangentialAccel()), a.setTangentialAccelVar(this.getTangentialAccelVar())) : this.getEmitterMode() == cc.ParticleSystem.MODE_RADIUS && (a.setStartRadius(this.getStartRadius()), a.setStartRadiusVar(this.getStartRadiusVar()),
                a.setEndRadius(this.getEndRadius()), a.setEndRadiusVar(this.getEndRadiusVar()), a.setRotatePerSecond(this.getRotatePerSecond()), a.setRotatePerSecondVar(this.getRotatePerSecondVar()));
            a.setLife(this.getLife());
            a.setLifeVar(this.getLifeVar());
            a.setEmissionRate(this.getEmissionRate());
            if (!this.getBatchNode() && (a.setOpacityModifyRGB(this.isOpacityModifyRGB()), b = this.getTexture())) {
                var c = b.getContentSize();
                a.setTextureWithRect(b, cc.rect(0, 0, c.width, c.height))
            }
        }
        return a
    },
    setDisplayFrame: function(a) {
        var b =
            a.getOffsetInPixels();
        (0 != b.x || 0 != b.y) && cc.log("cc.ParticleSystem.setDisplayFrame(): QuadParticle only supports SpriteFrames with no offsets");
        cc._renderType === cc._RENDER_TYPE_WEBGL && (!this._texture || a.getTexture()._webTextureObj != this._texture._webTextureObj) && this.setTexture(a.getTexture())
    },
    setTextureWithRect: function(a, b) {
        var c = this._texture;
        if (cc._renderType === cc._RENDER_TYPE_WEBGL) {
            if ((!c || a._webTextureObj != c._webTextureObj) && c != a) this._texture = a, this._updateBlendFunc()
        } else if ((!c || a != c) &&
            c != a) this._texture = a, this._updateBlendFunc();
        this._pointRect = b;
        this.initTexCoordsWithRect(b)
    },
    draw: function(a) {
        this._textureLoaded && !this._batchNode && (cc._renderType === cc._RENDER_TYPE_CANVAS ? this._drawForCanvas(a) : this._drawForWebGL(a), cc.g_NumberOfDraws++)
    },
    _drawForCanvas: function(a) {
        a = a || cc._renderContext;
        a.save();
        this.isBlendAdditive() ? a.globalCompositeOperation = "lighter" : a.globalCompositeOperation = "source-over";
        for (var b = this._texture.getHtmlElementObj(), c = cc.view.getScaleX(), d = cc.view.getScaleY(),
            e = 0; e < this.particleCount; e++) {
            var f = this._particles[e],
                g = 0 | 0.5 * f.size;
            if (this.drawMode == cc.ParticleSystem.TEXTURE_MODE) {
                if (b.width && b.height) {
                    a.save();
                    a.globalAlpha = f.color.a / 255;
                    a.translate(0 | f.drawPos.x, -(0 | f.drawPos.y));
                    var g = 4 * Math.floor(f.size / 4),
                        h = this._pointRect.width,
                        k = this._pointRect.height;
                    a.scale(Math.max(g * c / h, 1E-6), Math.max(g * d / k, 1E-6));
                    f.rotation && a.rotate(cc.degreesToRadians(f.rotation));
                    a.translate(-(0 | h / 2), -(0 | k / 2));
                    (f = f.isChangeColor ? this._changeTextureColor(b, f.color, this._pointRect) :
                        b) && a.drawImage(f, 0, 0);
                    a.restore()
                }
            } else a.save(), a.globalAlpha = f.color.a / 255, a.translate(0 | f.drawPos.x, -(0 | f.drawPos.y)), this.shapeType == cc.ParticleSystem.STAR_SHAPE ? (f.rotation && a.rotate(cc.degreesToRadians(f.rotation)), cc._drawingUtil.drawStar(a, g, f.color)) : cc._drawingUtil.drawColorBall(a, g, f.color), a.restore()
        }
        a.restore()
    },
    _changeTextureColor: function(a, b, c) {
        a.tintCache || (a.tintCache = document.createElement("canvas"), a.tintCache.width = a.width, a.tintCache.height = a.height);
        return cc.generateTintImageWithMultiply(a,
            b, c, a.tintCache)
    },
    _drawForWebGL: function(a) {
        this._texture && (a = a || cc._renderContext, this._shaderProgram.use(), this._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glBindTexture2D(this._texture), cc.glBlendFuncForParticle(this._blendFunc.src, this._blendFunc.dst), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), a.bindBuffer(a.ARRAY_BUFFER, this._buffersVBO[0]), a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, a.FLOAT, !1, 24, 0), a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR,
            4, a.UNSIGNED_BYTE, !0, 24, 12), a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, 24, 16), a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]), a.drawElements(a.TRIANGLES, 6 * this._particleIdx, a.UNSIGNED_SHORT, 0))
    },
    listenBackToForeground: function(a) {
        cc.TEXTURE_ATLAS_USE_VAO ? this._setupVBOandVAO() : this._setupVBO()
    },
    _setupVBOandVAO: function() {},
    _setupVBO: function() {
        if (cc._renderType != cc._RENDER_TYPE_CANVAS) {
            var a = cc._renderContext;
            this._buffersVBO[0] = a.createBuffer();
            a.bindBuffer(a.ARRAY_BUFFER,
                this._buffersVBO[0]);
            a.bufferData(a.ARRAY_BUFFER, this._quadsArrayBuffer, a.DYNAMIC_DRAW);
            this._buffersVBO[1] = a.createBuffer();
            a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
            a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indices, a.STATIC_DRAW)
        }
    },
    _allocMemory: function() {
        if (cc._renderType === cc._RENDER_TYPE_CANVAS) return !0;
        if (this._batchNode) return cc.log("cc.ParticleSystem._allocMemory(): Memory should not be allocated when not using batchNode"), !1;
        var a = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
            b = this._totalParticles,
            c = this._quads;
        c.length = 0;
        this._indices = new Uint16Array(6 * b);
        for (var d = new ArrayBuffer(a * b), e = 0; e < b; e++) c[e] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, d, e * a);
        if (!c || !this._indices) return cc.log("cocos2d: Particle system: not enough memory"), !1;
        this._quadsArrayBuffer = d;
        return !0
    }
});
_p = cc.ParticleSystem.prototype;
cc._renderType === cc._RENDER_TYPE_CANVAS && !cc.sys._supportCanvasNewBlendModes && (_p._changeTextureColor = function(a, b, c) {
    var d = cc.textureCache.getTextureColors(a);
    return d ? (d.tintCache || (d.tintCache = document.createElement("canvas"), d.tintCache.width = a.width, d.tintCache.height = a.height), cc.generateTintImage(a, d, b, c, d.tintCache), d.tintCache) : null
});
cc.defineGetterSetter(_p, "opacityModifyRGB", _p.isOpacityModifyRGB, _p.setOpacityModifyRGB);
cc.defineGetterSetter(_p, "batchNode", _p.getBatchNode, _p.setBatchNode);
cc.defineGetterSetter(_p, "active", _p.isActive);
cc.defineGetterSetter(_p, "sourcePos", _p.getSourcePosition, _p.setSourcePosition);
cc.defineGetterSetter(_p, "posVar", _p.getPosVar, _p.setPosVar);
cc.defineGetterSetter(_p, "gravity", _p.getGravity, _p.setGravity);
cc.defineGetterSetter(_p, "speed", _p.getSpeed, _p.setSpeed);
cc.defineGetterSetter(_p, "speedVar", _p.getSpeedVar, _p.setSpeedVar);
cc.defineGetterSetter(_p, "tangentialAccel", _p.getTangentialAccel, _p.setTangentialAccel);
cc.defineGetterSetter(_p, "tangentialAccelVar", _p.getTangentialAccelVar, _p.setTangentialAccelVar);
cc.defineGetterSetter(_p, "radialAccel", _p.getRadialAccel, _p.setRadialAccel);
cc.defineGetterSetter(_p, "radialAccelVar", _p.getRadialAccelVar, _p.setRadialAccelVar);
cc.defineGetterSetter(_p, "rotationIsDir", _p.getRotationIsDir, _p.setRotationIsDir);
cc.defineGetterSetter(_p, "startRadius", _p.getStartRadius, _p.setStartRadius);
cc.defineGetterSetter(_p, "startRadiusVar", _p.getStartRadiusVar, _p.setStartRadiusVar);
cc.defineGetterSetter(_p, "endRadius", _p.getEndRadius, _p.setEndRadius);
cc.defineGetterSetter(_p, "endRadiusVar", _p.getEndRadiusVar, _p.setEndRadiusVar);
cc.defineGetterSetter(_p, "rotatePerS", _p.getRotatePerSecond, _p.setRotatePerSecond);
cc.defineGetterSetter(_p, "rotatePerSVar", _p.getRotatePerSecondVar, _p.setRotatePerSecondVar);
cc.defineGetterSetter(_p, "startColor", _p.getStartColor, _p.setStartColor);
cc.defineGetterSetter(_p, "startColorVar", _p.getStartColorVar, _p.setStartColorVar);
cc.defineGetterSetter(_p, "endColor", _p.getEndColor, _p.setEndColor);
cc.defineGetterSetter(_p, "endColorVar", _p.getEndColorVar, _p.setEndColorVar);
cc.defineGetterSetter(_p, "totalParticles", _p.getTotalParticles, _p.setTotalParticles);
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.ParticleSystem.create = function(a) {
    return new cc.ParticleSystem(a)
};
cc.ParticleSystem.createWithTotalParticles = cc.ParticleSystem.create;
cc.ParticleSystem.ModeA = function(a, b, c, d, e, f, g, h) {
    this.gravity = a ? a : cc.p(0, 0);
    this.speed = b || 0;
    this.speedVar = c || 0;
    this.tangentialAccel = d || 0;
    this.tangentialAccelVar = e || 0;
    this.radialAccel = f || 0;
    this.radialAccelVar = g || 0;
    this.rotationIsDir = h || !1
};
cc.ParticleSystem.ModeB = function(a, b, c, d, e, f) {
    this.startRadius = a || 0;
    this.startRadiusVar = b || 0;
    this.endRadius = c || 0;
    this.endRadiusVar = d || 0;
    this.rotatePerSecond = e || 0;
    this.rotatePerSecondVar = f || 0
};
cc.ParticleSystem.SHAPE_MODE = 0;
cc.ParticleSystem.TEXTURE_MODE = 1;
cc.ParticleSystem.STAR_SHAPE = 0;
cc.ParticleSystem.BALL_SHAPE = 1;
cc.ParticleSystem.DURATION_INFINITY = -1;
cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE = -1;
cc.ParticleSystem.START_RADIUS_EQUAL_TO_END_RADIUS = -1;
cc.ParticleSystem.MODE_GRAVITY = 0;
cc.ParticleSystem.MODE_RADIUS = 1;
cc.ParticleSystem.TYPE_FREE = 0;
cc.ParticleSystem.TYPE_RELATIVE = 1;
cc.ParticleSystem.TYPE_GROUPED = 2;
cc.ParticleFire = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 300 : 150)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(60), this.setSpeedVar(20), this.setAngle(90), this.setAngleVar(10),
            a = cc.director.getWinSize(), this.setPosition(a.width / 2, 60), this.setPosVar(cc.p(40, 20)), this.setLife(3), this.setLifeVar(0.25), this.setStartSize(54), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(194, 64, 31, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!0), !0) : !1
    }
});
cc.ParticleFire.create = function() {
    return new cc.ParticleFire
};
cc.ParticleFireworks = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 1500 : 150)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, -90)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(180), this.setSpeedVar(50), a = cc.director.getWinSize(),
            this.setPosition(a.width / 2, a.height / 2), this.setAngle(90), this.setAngleVar(20), this.setLife(3.5), this.setLifeVar(1), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(128, 128, 128, 255)), this.setStartColorVar(cc.color(128, 128, 128, 255)), this.setEndColor(cc.color(26, 26, 26, 51)), this.setEndColorVar(cc.color(26, 26, 26, 51)), this.setStartSize(8), this.setStartSizeVar(2), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setBlendAdditive(!1), !0) : !1
    }
});
cc.ParticleFireworks.create = function() {
    return new cc.ParticleFireworks
};
cc.ParticleSun = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 350 : 150)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setBlendAdditive(!0), this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(20), this.setSpeedVar(5),
            this.setAngle(90), this.setAngleVar(360), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(1), this.setLifeVar(0.5), this.setStartSize(30), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(194, 64, 31, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), !0) : !1
    }
});
cc.ParticleSun.create = function() {
    return new cc.ParticleSun
};
cc.ParticleGalaxy = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 200 : 100)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(60), this.setSpeedVar(10), this.setRadialAccel(-80), this.setRadialAccelVar(0), this.setTangentialAccel(80),
            this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(360), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(4), this.setLifeVar(1), this.setStartSize(37), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(31, 64, 194, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0,
                0, 0, 0)), this.setBlendAdditive(!0), !0) : !1
    }
});
cc.ParticleGalaxy.create = function() {
    return new cc.ParticleGalaxy
};
cc.ParticleFlower = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 250 : 100)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(80), this.setSpeedVar(10), this.setRadialAccel(-60), this.setRadialAccelVar(0), this.setTangentialAccel(15),
            this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(360), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(4), this.setLifeVar(1), this.setStartSize(30), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(128, 128, 128, 255)), this.setStartColorVar(cc.color(128, 128, 128, 128)), this.setEndColor(cc.color(0, 0, 0, 255)),
            this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!0), !0) : !1
    }
});
cc.ParticleFlower.create = function() {
    return new cc.ParticleFlower
};
cc.ParticleMeteor = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 150 : 100)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(-200, 200)), this.setSpeed(15), this.setSpeedVar(5), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setTangentialAccel(0),
            this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(360), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(2), this.setLifeVar(1), this.setStartSize(60), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(51, 102, 179)), this.setStartColorVar(cc.color(0, 0, 51, 26)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0,
                0, 0, 0)), this.setBlendAdditive(!0), !0) : !1
    }
});
cc.ParticleMeteor.create = function() {
    return new cc.ParticleMeteor
};
cc.ParticleSpiral = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 500 : 100)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(150), this.setSpeedVar(0), this.setRadialAccel(-380), this.setRadialAccelVar(0), this.setTangentialAccel(45),
            this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(0), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(12), this.setLifeVar(0), this.setStartSize(20), this.setStartSizeVar(0), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(128, 128, 128, 255)), this.setStartColorVar(cc.color(128, 128, 128, 0)), this.setEndColor(cc.color(128, 128, 128, 255)),
            this.setEndColorVar(cc.color(128, 128, 128, 0)), this.setBlendAdditive(!1), !0) : !1
    }
});
cc.ParticleSpiral.create = function() {
    return new cc.ParticleSpiral
};
cc.ParticleExplosion = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 700 : 300)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(0.1), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(70), this.setSpeedVar(40), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setTangentialAccel(0), this.setTangentialAccelVar(0),
            this.setAngle(90), this.setAngleVar(360), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(5), this.setLifeVar(2), this.setStartSize(15), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getDuration()), this.setStartColor(cc.color(179, 26, 51, 255)), this.setStartColorVar(cc.color(128, 128, 128, 0)), this.setEndColor(cc.color(128, 128, 128, 0)), this.setEndColorVar(cc.color(128,
                128, 128, 0)), this.setBlendAdditive(!1), !0) : !1
    }
});
cc.ParticleExplosion.create = function() {
    return new cc.ParticleExplosion
};
cc.ParticleSmoke = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 200 : 100)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(25), this.setSpeedVar(10), this.setAngle(90), this.setAngleVar(5),
            a = cc.director.getWinSize(), this.setPosition(a.width / 2, 0), this.setPosVar(cc.p(20, 0)), this.setLife(4), this.setLifeVar(1), this.setStartSize(60), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(204, 204, 204, 255)), this.setStartColorVar(cc.color(5, 5, 5, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!1), !0) : !1
    }
});
cc.ParticleSmoke.create = function() {
    return new cc.ParticleSmoke
};
cc.ParticleSnow = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 700 : 250)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, -1)), this.setSpeed(5), this.setSpeedVar(1), this.setRadialAccel(0), this.setRadialAccelVar(1), this.setTangentialAccel(0),
            this.setTangentialAccelVar(1), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height + 10), this.setPosVar(cc.p(a.width / 2, 0)), this.setAngle(-90), this.setAngleVar(5), this.setLife(45), this.setLifeVar(15), this.setStartSize(10), this.setStartSizeVar(5), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(10), this.setStartColor(cc.color(255, 255, 255, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(255, 255, 255, 0)), this.setEndColorVar(cc.color(0,
                0, 0, 0)), this.setBlendAdditive(!1), !0) : !1
    }
});
cc.ParticleSnow.create = function() {
    return new cc.ParticleSnow
};
cc.ParticleRain = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 1E3 : 300)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(10, -10)), this.setRadialAccel(0), this.setRadialAccelVar(1), this.setTangentialAccel(0), this.setTangentialAccelVar(1), this.setSpeed(130),
            this.setSpeedVar(30), this.setAngle(-90), this.setAngleVar(5), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height), this.setPosVar(cc.p(a.width / 2, 0)), this.setLife(4.5), this.setLifeVar(0), this.setStartSize(4), this.setStartSizeVar(2), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(20), this.setStartColor(cc.color(179, 204, 255, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(179, 204, 255, 128)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!1), !0) : !1
    }
});
cc.ParticleRain.create = function() {
    return new cc.ParticleRain
};
cc.PARTICLE_DEFAULT_CAPACITY = 500;
cc.ParticleBatchNode = cc.Node.extend({
    textureAtlas: null,
    TextureProtocol: !0,
    _blendFunc: null,
    _className: "ParticleBatchNode",
    ctor: function(a, b) {
        cc.Node.prototype.ctor.call(this);
        this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        };
        cc.isString(a) ? this.init(a, b) : a instanceof cc.Texture2D && this.initWithTexture(a, b)
    },
    initWithTexture: function(a, b) {
        this.textureAtlas = new cc.TextureAtlas;
        this.textureAtlas.initWithTexture(a, b);
        this._children.length = 0;
        cc._renderType === cc._RENDER_TYPE_WEBGL && (this.shaderProgram =
            cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR));
        return !0
    },
    initWithFile: function(a, b) {
        var c = cc.textureCache.addImage(a);
        return this.initWithTexture(c, b)
    },
    init: function(a, b) {
        var c = cc.TextureCache.getInstance().addImage(a);
        return this.initWithTexture(c, b)
    },
    addChild: function(a, b, c) {
        if (!a) throw "cc.ParticleBatchNode.addChild() : child should be non-null";
        if (!(a instanceof cc.ParticleSystem)) throw "cc.ParticleBatchNode.addChild() : only supports cc.ParticleSystem as children";
        b = null == b ? a.zIndex :
            b;
        c = null == c ? a.tag : c;
        if (a.getTexture() != this.textureAtlas.texture) throw "cc.ParticleSystem.addChild() : the child is not using the same texture id";
        var d = a.getBlendFunc();
        if (0 === this._children.length) this.setBlendFunc(d);
        else if (d.src != this._blendFunc.src || d.dst != this._blendFunc.dst) {
            cc.log("cc.ParticleSystem.addChild() : Can't add a ParticleSystem that uses a different blending function");
            return
        }
        b = this._addChildHelper(a, b, c);
        c = 0;
        0 != b ? (b = this._children[b - 1], c = b.getAtlasIndex() + b.getTotalParticles()) :
            c = 0;
        this.insertChild(a, c);
        a.setBatchNode(this)
    },
    insertChild: function(a, b) {
        var c = a.getTotalParticles(),
            d = this.textureAtlas,
            e = d.totalQuads;
        a.setAtlasIndex(b);
        e + c > d.getCapacity() && (this._increaseAtlasCapacityTo(e + c), d.fillWithEmptyQuadsFromIndex(d.getCapacity() - c, c));
        a.getAtlasIndex() + c != e && d.moveQuadsFromIndex(b, b + c);
        d.increaseTotalQuadsWith(c);
        this._updateAllAtlasIndexes()
    },
    removeChild: function(a, b) {
        if (null != a) {
            if (!(a instanceof cc.ParticleSystem)) throw "cc.ParticleBatchNode.removeChild(): only supports cc.ParticleSystem as children";
            if (-1 == this._children.indexOf(a)) cc.log("cc.ParticleBatchNode.removeChild(): doesn't contain the sprite. Can't remove it");
            else {
                cc.Node.prototype.removeChild.call(this, a, b);
                var c = this.textureAtlas;
                c.removeQuadsAtIndex(a.getAtlasIndex(), a.getTotalParticles());
                c.fillWithEmptyQuadsFromIndex(c.totalQuads, a.getTotalParticles());
                a.setBatchNode(null);
                this._updateAllAtlasIndexes()
            }
        }
    },
    reorderChild: function(a, b) {
        if (!a) throw "cc.ParticleBatchNode.reorderChild(): child should be non-null";
        if (!(a instanceof cc.ParticleSystem)) throw "cc.ParticleBatchNode.reorderChild(): only supports cc.QuadParticleSystems as children";
        if (-1 === this._children.indexOf(a)) cc.log("cc.ParticleBatchNode.reorderChild(): Child doesn't belong to batch");
        else if (b != a.zIndex) {
            if (1 < this._children.length) {
                var c = this._getCurrentIndex(a, b);
                if (c.oldIndex != c.newIndex) {
                    this._children.splice(c.oldIndex, 1);
                    this._children.splice(c.newIndex, 0, a);
                    c = a.getAtlasIndex();
                    this._updateAllAtlasIndexes();
                    for (var d = 0, e = this._children, f = 0; f < e.length; f++)
                        if (e[f] == a) {
                            d = a.getAtlasIndex();
                            break
                        }
                    this.textureAtlas.moveQuadsFromIndex(c, a.getTotalParticles(), d);
                    a.updateWithNoTime()
                }
            }
            a._setLocalZOrder(b)
        }
    },
    removeChildAtIndex: function(a, b) {
        this.removeChild(this._children[i], b)
    },
    removeAllChildren: function(a) {
        for (var b = this._children, c = 0; c < b.length; c++) b[c].setBatchNode(null);
        cc.Node.prototype.removeAllChildren.call(this, a);
        this.textureAtlas.removeAllQuads()
    },
    disableParticle: function(a) {
        a = this.textureAtlas.quads[a];
        a.br.vertices.x = a.br.vertices.y = a.tr.vertices.x = a.tr.vertices.y = a.tl.vertices.x = a.tl.vertices.y = a.bl.vertices.x = a.bl.vertices.y = 0;
        this.textureAtlas._setDirty(!0)
    },
    draw: function(a) {
        cc._renderType !==
            cc._RENDER_TYPE_CANVAS && 0 != this.textureAtlas.totalQuads && (cc.nodeDrawSetup(this), cc.glBlendFuncForParticle(this._blendFunc.src, this._blendFunc.dst), this.textureAtlas.drawQuads())
    },
    getTexture: function() {
        return this.textureAtlas.texture
    },
    setTexture: function(a) {
        this.textureAtlas.texture = a;
        var b = this._blendFunc;
        a && (!a.hasPremultipliedAlpha() && b.src == cc.BLEND_SRC && b.dst == cc.BLEND_DST) && (b.src = cc.SRC_ALPHA, b.dst = cc.ONE_MINUS_SRC_ALPHA)
    },
    setBlendFunc: function(a, b) {
        void 0 === b ? (this._blendFunc.src = a.src, this._blendFunc.dst =
            a.dst) : (this._blendFunc.src = a, this._blendFunc.src = b)
    },
    getBlendFunc: function() {
        return {
            src: this._blendFunc.src,
            dst: this._blendFunc.dst
        }
    },
    visit: function(a) {
        if (cc._renderType !== cc._RENDER_TYPE_CANVAS && this._visible) {
            var b = cc.current_stack;
            b.stack.push(b.top);
            cc.kmMat4Assign(this._stackMatrix, b.top);
            b.top = this._stackMatrix;
            this.transform(a);
            this._rendererCmd && cc.renderer.pushRenderCommand(this._rendererCmd);
            cc.kmGLPopMatrix()
        }
    },
    _updateAllAtlasIndexes: function() {
        for (var a = 0, b = this._children, c = 0; c < b.length; c++) {
            var d =
                b[c];
            d.setAtlasIndex(a);
            a += d.getTotalParticles()
        }
    },
    _increaseAtlasCapacityTo: function(a) {
        cc.log("cocos2d: cc.ParticleBatchNode: resizing TextureAtlas capacity from [" + this.textureAtlas.getCapacity() + "] to [" + a + "].");
        this.textureAtlas.resizeCapacity(a) || cc.log("cc.ParticleBatchNode._increaseAtlasCapacityTo() : WARNING: Not enough memory to resize the atlas")
    },
    _searchNewPositionInChildrenForZ: function(a) {
        for (var b = this._children, c = b.length, d = 0; d < c; d++)
            if (b[d].zIndex > a) return d;
        return c
    },
    _getCurrentIndex: function(a,
        b) {
        for (var c = !1, d = !1, e = 0, f = 0, g = 0, h = this._children, k = h.length, m = 0; m < k; m++) {
            var n = h[m];
            if (n.zIndex > b && !d && (e = m, d = !0, c && d)) break;
            if (a == n && (f = m, c = !0, d || (g = -1), c && d)) break
        }
        d || (e = k);
        return {
            newIndex: e + g,
            oldIndex: f
        }
    },
    _addChildHelper: function(a, b, c) {
        if (!a) throw "cc.ParticleBatchNode._addChildHelper(): child should be non-null";
        if (a.parent) return cc.log("cc.ParticleBatchNode._addChildHelper(): child already added. It can't be added again"), null;
        this._children || (this._children = []);
        var d = this._searchNewPositionInChildrenForZ(b);
        this._children.splice(d, 0, a);
        a.tag = c;
        a._setLocalZOrder(b);
        a.parent = this;
        this._running && (a.onEnter(), a.onEnterTransitionDidFinish());
        return d
    },
    _updateBlendFunc: function() {
        this.textureAtlas.texture.hasPremultipliedAlpha() || (this._blendFunc.src = cc.SRC_ALPHA, this._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA)
    },
    getTextureAtlas: function() {
        return this.textureAtlas
    },
    setTextureAtlas: function(a) {
        this.textureAtlas = a
    },
    _initRendererCmd: function() {
        cc._renderType === cc._RENDER_TYPE_WEBGL && (this._rendererCmd = new cc.ParticleBatchNodeRenderCmdWebGL(this))
    }
});
_p = cc.ParticleBatchNode.prototype;
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.ParticleBatchNode.create = function(a, b) {
    return new cc.ParticleBatchNode(a, b)
};
(function(a) {
    function b(a) {
        function b(a, c, e) {
            "undefined" === typeof a && (a = b.DEFAULT_CAPACITY);
            "undefined" === typeof c && (c = b.DEFAULT_ENDIAN);
            "undefined" === typeof e && (e = b.DEFAULT_NOASSERT);
            if (!e) {
                a |= 0;
                if (0 > a) throw RangeError("Illegal capacity");
                c = !!c;
                e = !!e
            }
            this.buffer = 0 === a ? h : new ArrayBuffer(a);
            this.view = 0 === a ? null : new DataView(this.buffer);
            this.offset = 0;
            this.markedOffset = -1;
            this.limit = a;
            this.littleEndian = "undefined" !== typeof c ? !!c : !1;
            this.noAssert = !!e
        }

        function e(a) {
            var b = 0;
            return function() {
                return b <
                    a.length ? a.charCodeAt(b++) : null
            }
        }

        function f() {
            var a = [],
                b = [];
            return function() {
                if (0 === arguments.length) return b.join("") + k.apply(String, a);
                1024 < a.length + arguments.length && (b.push(k.apply(String, a)), a.length = 0);
                Array.prototype.push.apply(a, arguments)
            }
        }
        b.VERSION = "3.4.0";
        b.LITTLE_ENDIAN = !0;
        b.BIG_ENDIAN = !1;
        b.DEFAULT_CAPACITY = 16;
        b.DEFAULT_ENDIAN = b.BIG_ENDIAN;
        b.DEFAULT_NOASSERT = !1;
        b.Long = a || null;
        var g = b.prototype,
            h = new ArrayBuffer(0),
            k = String.fromCharCode;
        b.allocate = function(a, c, e) {
            return new b(a, c, e)
        };
        b.concat = function(a, c, e, f) {
            if ("boolean" === typeof c || "string" !== typeof c) f = e, e = c, c = void 0;
            for (var g = 0, h = 0, k = a.length, m; h < k; ++h) b.isByteBuffer(a[h]) || (a[h] = b.wrap(a[h], c)), m = a[h].limit - a[h].offset, 0 < m && (g += m);
            if (0 === g) return new b(0, e, f);
            c = new b(g, e, f);
            f = new Uint8Array(c.buffer);
            for (h = 0; h < k;) e = a[h++], m = e.limit - e.offset, 0 >= m || (f.set((new Uint8Array(e.buffer)).subarray(e.offset, e.limit), c.offset), c.offset += m);
            c.limit = c.offset;
            c.offset = 0;
            return c
        };
        b.isByteBuffer = function(a) {
            return !0 === (a && a instanceof b)
        };
        b.type = function() {
            return ArrayBuffer
        };
        b.wrap = function(a, c, e, f) {
            "string" !== typeof c && (f = e, e = c, c = void 0);
            if ("string" === typeof a) switch ("undefined" === typeof c && (c = "utf8"), c) {
                case "base64":
                    return b.fromBase64(a, e);
                case "hex":
                    return b.fromHex(a, e);
                case "binary":
                    return b.fromBinary(a, e);
                case "utf8":
                    return b.fromUTF8(a, e);
                case "debug":
                    return b.fromDebug(a, e);
                default:
                    throw Error("Unsupported encoding: " + c);
            }
            if (null === a || "object" !== typeof a) throw TypeError("Illegal buffer");
            if (b.isByteBuffer(a)) return c =
                g.clone.call(a), c.markedOffset = -1, c;
            if (a instanceof Uint8Array) c = new b(0, e, f), 0 < a.length && (c.buffer = a.buffer, c.offset = a.byteOffset, c.limit = a.byteOffset + a.length, c.view = 0 < a.length ? new DataView(a.buffer) : null);
            else if (a instanceof ArrayBuffer) c = new b(0, e, f), 0 < a.byteLength && (c.buffer = a, c.offset = 0, c.limit = a.byteLength, c.view = 0 < a.byteLength ? new DataView(a) : null);
            else if ("[object Array]" === Object.prototype.toString.call(a)) {
                c = new b(a.length, e, f);
                c.limit = a.length;
                for (i = 0; i < a.length; ++i) c.view.setUint8(i,
                    a[i])
            } else throw TypeError("Illegal buffer");
            return c
        };
        g.writeInt8 = function(a, b) {
            var c = "undefined" === typeof b;
            c && (b = this.offset);
            if (!this.noAssert) {
                if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal value: " + a + " (not an integer)");
                a |= 0;
                if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");
                b >>>= 0;
                if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 \x3c\x3d " + b + " (+0) \x3c\x3d " + this.buffer.byteLength);
            }
            b += 1;
            var d = this.buffer.byteLength;
            b >
                d && this.resize((d *= 2) > b ? d : b);
            this.view.setInt8(b - 1, a);
            c && (this.offset += 1);
            return this
        };
        g.writeByte = g.writeInt8;
        g.readInt8 = function(a) {
            var b = "undefined" === typeof a;
            b && (a = this.offset);
            if (!this.noAssert) {
                if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");
                a >>>= 0;
                if (0 > a || a + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 \x3c\x3d " + a + " (+1) \x3c\x3d " + this.buffer.byteLength);
            }
            a = this.view.getInt8(a);
            b && (this.offset += 1);
            return a
        };
        g.readByte = g.readInt8;
        g.writeUint8 =
            function(a, b) {
                var c = "undefined" === typeof b;
                c && (b = this.offset);
                if (!this.noAssert) {
                    if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal value: " + a + " (not an integer)");
                    a >>>= 0;
                    if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");
                    b >>>= 0;
                    if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 \x3c\x3d " + b + " (+0) \x3c\x3d " + this.buffer.byteLength);
                }
                b += 1;
                var d = this.buffer.byteLength;
                b > d && this.resize((d *= 2) > b ? d : b);
                this.view.setUint8(b - 1, a);
                c && (this.offset +=
                    1);
                return this
            };
        g.readUint8 = function(a) {
            var b = "undefined" === typeof a;
            b && (a = this.offset);
            if (!this.noAssert) {
                if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");
                a >>>= 0;
                if (0 > a || a + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 \x3c\x3d " + a + " (+1) \x3c\x3d " + this.buffer.byteLength);
            }
            a = this.view.getUint8(a);
            b && (this.offset += 1);
            return a
        };
        g.writeInt16 = function(a, b) {
            var c = "undefined" === typeof b;
            c && (b = this.offset);
            if (!this.noAssert) {
                if ("number" !== typeof a ||
                    0 !== a % 1) throw TypeError("Illegal value: " + a + " (not an integer)");
                a |= 0;
                if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");
                b >>>= 0;
                if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 \x3c\x3d " + b + " (+0) \x3c\x3d " + this.buffer.byteLength);
            }
            b += 2;
            var d = this.buffer.byteLength;
            b > d && this.resize((d *= 2) > b ? d : b);
            this.view.setInt16(b - 2, a, this.littleEndian);
            c && (this.offset += 2);
            return this
        };
        g.writeShort = g.writeInt16;
        g.readInt16 = function(a) {
            var b = "undefined" ===
                typeof a;
            b && (a = this.offset);
            if (!this.noAssert) {
                if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");
                a >>>= 0;
                if (0 > a || a + 2 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 \x3c\x3d " + a + " (+2) \x3c\x3d " + this.buffer.byteLength);
            }
            a = this.view.getInt16(a, this.littleEndian);
            b && (this.offset += 2);
            return a
        };
        g.readShort = g.readInt16;
        g.writeUint16 = function(a, b) {
            var c = "undefined" === typeof b;
            c && (b = this.offset);
            if (!this.noAssert) {
                if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal value: " +
                    a + " (not an integer)");
                a >>>= 0;
                if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");
                b >>>= 0;
                if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 \x3c\x3d " + b + " (+0) \x3c\x3d " + this.buffer.byteLength);
            }
            b += 2;
            var d = this.buffer.byteLength;
            b > d && this.resize((d *= 2) > b ? d : b);
            this.view.setUint16(b - 2, a, this.littleEndian);
            c && (this.offset += 2);
            return this
        };
        g.readUint16 = function(a) {
            var b = "undefined" === typeof a;
            b && (a = this.offset);
            if (!this.noAssert) {
                if ("number" !==
                    typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");
                a >>>= 0;
                if (0 > a || a + 2 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 \x3c\x3d " + a + " (+2) \x3c\x3d " + this.buffer.byteLength);
            }
            a = this.view.getUint16(a, this.littleEndian);
            b && (this.offset += 2);
            return a
        };
        g.writeInt32 = function(a, b) {
            var c = "undefined" === typeof b;
            c && (b = this.offset);
            if (!this.noAssert) {
                if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal value: " + a + " (not an integer)");
                a |= 0;
                if ("number" !== typeof b || 0 !== b %
                    1) throw TypeError("Illegal offset: " + b + " (not an integer)");
                b >>>= 0;
                if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 \x3c\x3d " + b + " (+0) \x3c\x3d " + this.buffer.byteLength);
            }
            b += 4;
            var d = this.buffer.byteLength;
            b > d && this.resize((d *= 2) > b ? d : b);
            this.view.setInt32(b - 4, a, this.littleEndian);
            c && (this.offset += 4);
            return this
        };
        g.writeInt = g.writeInt32;
        g.readInt32 = function(a) {
            var b = "undefined" === typeof a;
            b && (a = this.offset);
            if (!this.noAssert) {
                if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " +
                    a + " (not an integer)");
                a >>>= 0;
                if (0 > a || a + 4 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 \x3c\x3d " + a + " (+4) \x3c\x3d " + this.buffer.byteLength);
            }
            a = this.view.getInt32(a, this.littleEndian);
            b && (this.offset += 4);
            return a
        };
        g.readInt = g.readInt32;
        g.writeUint32 = function(a, b) {
            var c = "undefined" === typeof b;
            c && (b = this.offset);
            if (!this.noAssert) {
                if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal value: " + a + " (not an integer)");
                a >>>= 0;
                if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " +
                    b + " (not an integer)");
                b >>>= 0;
                if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 \x3c\x3d " + b + " (+0) \x3c\x3d " + this.buffer.byteLength);
            }
            b += 4;
            var d = this.buffer.byteLength;
            b > d && this.resize((d *= 2) > b ? d : b);
            this.view.setUint32(b - 4, a, this.littleEndian);
            c && (this.offset += 4);
            return this
        };
        g.readUint32 = function(a) {
            var b = "undefined" === typeof a;
            b && (a = this.offset);
            if (!this.noAssert) {
                if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");
                a >>>= 0;
                if (0 > a || a + 4 >
                    this.buffer.byteLength) throw RangeError("Illegal offset: 0 \x3c\x3d " + a + " (+4) \x3c\x3d " + this.buffer.byteLength);
            }
            a = this.view.getUint32(a, this.littleEndian);
            b && (this.offset += 4);
            return a
        };
        a && (g.writeInt64 = function(b, d) {
            var e = "undefined" === typeof d;
            e && (d = this.offset);
            if (!this.noAssert) {
                if ("number" === typeof b) b = a.fromNumber(b);
                else if (!(b && b instanceof a)) throw TypeError("Illegal value: " + b + " (not an integer or Long)");
                if ("number" !== typeof d || 0 !== d % 1) throw TypeError("Illegal offset: " + d + " (not an integer)");
                d >>>= 0;
                if (0 > d || d + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 \x3c\x3d " + d + " (+0) \x3c\x3d " + this.buffer.byteLength);
            }
            "number" === typeof b && (b = a.fromNumber(b));
            d += 8;
            var f = this.buffer.byteLength;
            d > f && this.resize((f *= 2) > d ? f : d);
            d -= 8;
            this.littleEndian ? (this.view.setInt32(d, b.low, !0), this.view.setInt32(d + 4, b.high, !0)) : (this.view.setInt32(d, b.high, !1), this.view.setInt32(d + 4, b.low, !1));
            e && (this.offset += 8);
            return this
        }, g.writeLong = g.writeInt64, g.readInt64 = function(b) {
            var d = "undefined" === typeof b;
            d && (b = this.offset);
            if (!this.noAssert) {
                if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");
                b >>>= 0;
                if (0 > b || b + 8 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 \x3c\x3d " + b + " (+8) \x3c\x3d " + this.buffer.byteLength);
            }
            b = this.littleEndian ? new a(this.view.getInt32(b, !0), this.view.getInt32(b + 4, !0), !1) : new a(this.view.getInt32(b + 4, !1), this.view.getInt32(b, !1), !1);
            d && (this.offset += 8);
            return b
        }, g.readLong = g.readInt64, g.writeUint64 = function(b, d) {
            var e = "undefined" ===
                typeof d;
            e && (d = this.offset);
            if (!this.noAssert) {
                if ("number" === typeof b) b = a.fromNumber(b);
                else if (!(b && b instanceof a)) throw TypeError("Illegal value: " + b + " (not an integer or Long)");
                if ("number" !== typeof d || 0 !== d % 1) throw TypeError("Illegal offset: " + d + " (not an integer)");
                d >>>= 0;
                if (0 > d || d + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 \x3c\x3d " + d + " (+0) \x3c\x3d " + this.buffer.byteLength);
            }
            "number" === typeof b && (b = a.fromNumber(b));
            d += 8;
            var f = this.buffer.byteLength;
            d > f && this.resize((f *=
                2) > d ? f : d);
            d -= 8;
            this.littleEndian ? (this.view.setInt32(d, b.low, !0), this.view.setInt32(d + 4, b.high, !0)) : (this.view.setInt32(d, b.high, !1), this.view.setInt32(d + 4, b.low, !1));
            e && (this.offset += 8);
            return this
        }, g.readUint64 = function(b) {
            var d = "undefined" === typeof b;
            d && (b = this.offset);
            if (!this.noAssert) {
                if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");
                b >>>= 0;
                if (0 > b || b + 8 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 \x3c\x3d " + b + " (+8) \x3c\x3d " + this.buffer.byteLength);
            }
            b = this.littleEndian ? new a(this.view.getInt32(b, !0), this.view.getInt32(b + 4, !0), !0) : new a(this.view.getInt32(b + 4, !1), this.view.getInt32(b, !1), !0);
            d && (this.offset += 8);
            return b
        });
        g.writeFloat32 = function(a, b) {
            var c = "undefined" === typeof b;
            c && (b = this.offset);
            if (!this.noAssert) {
                if ("number" !== typeof a) throw TypeError("Illegal value: " + a + " (not a number)");
                if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");
                b >>>= 0;
                if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 \x3c\x3d " +
                    b + " (+0) \x3c\x3d " + this.buffer.byteLength);
            }
            b += 4;
            var d = this.buffer.byteLength;
            b > d && this.resize((d *= 2) > b ? d : b);
            this.view.setFloat32(b - 4, a, this.littleEndian);
            c && (this.offset += 4);
            return this
        };
        g.writeFloat = g.writeFloat32;
        g.readFloat32 = function(a) {
            var b = "undefined" === typeof a;
            b && (a = this.offset);
            if (!this.noAssert) {
                if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");
                a >>>= 0;
                if (0 > a || a + 4 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 \x3c\x3d " + a + " (+4) \x3c\x3d " +
                    this.buffer.byteLength);
            }
            a = this.view.getFloat32(a, this.littleEndian);
            b && (this.offset += 4);
            return a
        };
        g.readFloat = g.readFloat32;
        g.writeFloat64 = function(a, b) {
            var c = "undefined" === typeof b;
            c && (b = this.offset);
            if (!this.noAssert) {
                if ("number" !== typeof a) throw TypeError("Illegal value: " + a + " (not a number)");
                if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");
                b >>>= 0;
                if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 \x3c\x3d " + b + " (+0) \x3c\x3d " + this.buffer.byteLength);
            }
            b += 8;
            var d = this.buffer.byteLength;
            b > d && this.resize((d *= 2) > b ? d : b);
            this.view.setFloat64(b - 8, a, this.littleEndian);
            c && (this.offset += 8);
            return this
        };
        g.writeDouble = g.writeFloat64;
        g.readFloat64 = function(a) {
            var b = "undefined" === typeof a;
            b && (a = this.offset);
            if (!this.noAssert) {
                if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");
                a >>>= 0;
                if (0 > a || a + 8 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 \x3c\x3d " + a + " (+8) \x3c\x3d " + this.buffer.byteLength);
            }
            a = this.view.getFloat64(a,
                this.littleEndian);
            b && (this.offset += 8);
            return a
        };
        g.readDouble = g.readFloat64;
        b.MAX_VARINT32_BYTES = 5;
        b.calculateVarint32 = function(a) {
            a >>>= 0;
            return 128 > a ? 1 : 16384 > a ? 2 : 2097152 > a ? 3 : 268435456 > a ? 4 : 5
        };
        b.zigZagEncode32 = function(a) {
            return ((a |= 0) << 1 ^ a >> 31) >>> 0
        };
        b.zigZagDecode32 = function(a) {
            return a >>> 1 ^ -(a & 1) | 0
        };
        g.writeVarint32 = function(a, c) {
            var e = "undefined" === typeof c;
            e && (c = this.offset);
            if (!this.noAssert) {
                if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal value: " + a + " (not an integer)");
                a |= 0;
                if ("number" !==
                    typeof c || 0 !== c % 1) throw TypeError("Illegal offset: " + c + " (not an integer)");
                c >>>= 0;
                if (0 > c || c + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 \x3c\x3d " + c + " (+0) \x3c\x3d " + this.buffer.byteLength);
            }
            var f = b.calculateVarint32(a);
            c += f;
            var g = this.buffer.byteLength;
            c > g && this.resize((g *= 2) > c ? g : c);
            c -= f;
            this.view.setUint8(c, f = a | 128);
            a >>>= 0;
            128 <= a ? (f = a >> 7 | 128, this.view.setUint8(c + 1, f), 16384 <= a ? (f = a >> 14 | 128, this.view.setUint8(c + 2, f), 2097152 <= a ? (f = a >> 21 | 128, this.view.setUint8(c + 3, f), 268435456 <= a ?
                (this.view.setUint8(c + 4, a >> 28 & 15), f = 5) : (this.view.setUint8(c + 3, f & 127), f = 4)) : (this.view.setUint8(c + 2, f & 127), f = 3)) : (this.view.setUint8(c + 1, f & 127), f = 2)) : (this.view.setUint8(c, f & 127), f = 1);
            return e ? (this.offset += f, this) : f
        };
        g.writeVarint32ZigZag = function(a, c) {
            return this.writeVarint32(b.zigZagEncode32(a), c)
        };
        g.readVarint32 = function(a) {
            var b = "undefined" === typeof a;
            b && (a = this.offset);
            if (!this.noAssert) {
                if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");
                a >>>= 0;
                if (0 > a ||
                    a + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 \x3c\x3d " + a + " (+1) \x3c\x3d " + this.buffer.byteLength);
            }
            var c = 0,
                d = 0,
                e;
            do {
                e = a + c;
                if (!this.noAssert && e > this.limit) throw a = Error("Truncated"), a.truncated = !0, a;
                e = this.view.getUint8(e);
                5 > c && (d |= (e & 127) << 7 * c >>> 0);
                ++c
            } while (128 === (e & 128));
            d |= 0;
            return b ? (this.offset += c, d) : {
                value: d,
                length: c
            }
        };
        g.readVarint32ZigZag = function(a) {
            a = this.readVarint32(a);
            "object" === typeof a ? a.value = b.zigZagDecode32(a.value) : a = b.zigZagDecode32(a);
            return a
        };
        a && (b.MAX_VARINT64_BYTES =
            10, b.calculateVarint64 = function(b) {
                "number" === typeof b && (b = a.fromNumber(b));
                var d = b.toInt() >>> 0,
                    e = b.shiftRightUnsigned(28).toInt() >>> 0;
                b = b.shiftRightUnsigned(56).toInt() >>> 0;
                return 0 == b ? 0 == e ? 16384 > d ? 128 > d ? 1 : 2 : 2097152 > d ? 3 : 4 : 16384 > e ? 128 > e ? 5 : 6 : 2097152 > e ? 7 : 8 : 128 > b ? 9 : 10
            }, b.zigZagEncode64 = function(b) {
                "number" === typeof b ? b = a.fromNumber(b, !1) : !1 !== b.unsigned && (b = b.toSigned());
                return b.shiftLeft(1).xor(b.shiftRight(63)).toUnsigned()
            }, b.zigZagDecode64 = function(b) {
                "number" === typeof b ? b = a.fromNumber(b, !1) : !1 !==
                    b.unsigned && (b = b.toSigned());
                return b.shiftRightUnsigned(1).xor(b.and(a.ONE).toSigned().negate()).toSigned()
            }, g.writeVarint64 = function(e, f) {
                var g = "undefined" === typeof f;
                g && (f = this.offset);
                if (!this.noAssert) {
                    if ("number" === typeof e) e = a.fromNumber(e);
                    else if (!(e && e instanceof a)) throw TypeError("Illegal value: " + e + " (not an integer or Long)");
                    if ("number" !== typeof f || 0 !== f % 1) throw TypeError("Illegal offset: " + f + " (not an integer)");
                    f >>>= 0;
                    if (0 > f || f + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 \x3c\x3d " +
                        f + " (+0) \x3c\x3d " + this.buffer.byteLength);
                }
                "number" === typeof e ? e = a.fromNumber(e, !1) : !1 !== e.unsigned && (e = e.toSigned());
                var h = b.calculateVarint64(e),
                    k = e.toInt() >>> 0,
                    m = e.shiftRightUnsigned(28).toInt() >>> 0,
                    n = e.shiftRightUnsigned(56).toInt() >>> 0;
                f += h;
                var y = this.buffer.byteLength;
                f > y && this.resize((y *= 2) > f ? y : f);
                f -= h;
                switch (h) {
                    case 10:
                        this.view.setUint8(f + 9, n >>> 7 & 1);
                    case 9:
                        this.view.setUint8(f + 8, 9 !== h ? n | 128 : n & 127);
                    case 8:
                        this.view.setUint8(f + 7, 8 !== h ? m >>> 21 | 128 : m >>> 21 & 127);
                    case 7:
                        this.view.setUint8(f + 6,
                            7 !== h ? m >>> 14 | 128 : m >>> 14 & 127);
                    case 6:
                        this.view.setUint8(f + 5, 6 !== h ? m >>> 7 | 128 : m >>> 7 & 127);
                    case 5:
                        this.view.setUint8(f + 4, 5 !== h ? m | 128 : m & 127);
                    case 4:
                        this.view.setUint8(f + 3, 4 !== h ? k >>> 21 | 128 : k >>> 21 & 127);
                    case 3:
                        this.view.setUint8(f + 2, 3 !== h ? k >>> 14 | 128 : k >>> 14 & 127);
                    case 2:
                        this.view.setUint8(f + 1, 2 !== h ? k >>> 7 | 128 : k >>> 7 & 127);
                    case 1:
                        this.view.setUint8(f, 1 !== h ? k | 128 : k & 127)
                }
                return g ? (this.offset += h, this) : h
            }, g.writeVarint64ZigZag = function(a, c) {
                return this.writeVarint64(b.zigZagEncode64(a), c)
            }, g.readVarint64 = function(b) {
                var d =
                    "undefined" === typeof b;
                d && (b = this.offset);
                if (!this.noAssert) {
                    if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");
                    b >>>= 0;
                    if (0 > b || b + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 \x3c\x3d " + b + " (+1) \x3c\x3d " + this.buffer.byteLength);
                }
                var e = b,
                    f = 0,
                    g = 0,
                    h = 0,
                    k = 0,
                    k = this.view.getUint8(b++),
                    f = k & 127;
                if (k & 128 && (k = this.view.getUint8(b++), f |= (k & 127) << 7, k & 128 && (k = this.view.getUint8(b++), f |= (k & 127) << 14, k & 128 && (k = this.view.getUint8(b++), f |= (k & 127) << 21, k & 128 && (k =
                    this.view.getUint8(b++), g = k & 127, k & 128 && (k = this.view.getUint8(b++), g |= (k & 127) << 7, k & 128 && (k = this.view.getUint8(b++), g |= (k & 127) << 14, k & 128 && (k = this.view.getUint8(b++), g |= (k & 127) << 21, k & 128 && (k = this.view.getUint8(b++), h = k & 127, k & 128 && (k = this.view.getUint8(b++), h |= (k & 127) << 7, k & 128)))))))))) throw Error("Buffer overrun");
                f = a.fromBits(f | g << 28, g >>> 4 | h << 24, !1);
                return d ? (this.offset = b, f) : {
                    value: f,
                    length: b - e
                }
            }, g.readVarint64ZigZag = function(e) {
                (e = this.readVarint64(e)) && e.value instanceof a ? e.value = b.zigZagDecode64(e.value) :
                    e = b.zigZagDecode64(e);
                return e
            });
        g.writeCString = function(a, b) {
            var c = "undefined" === typeof b;
            c && (b = this.offset);
            var d, f = a.length;
            if (!this.noAssert) {
                if ("string" !== typeof a) throw TypeError("Illegal str: Not a string");
                for (d = 0; d < f; ++d)
                    if (0 === a.charCodeAt(d)) throw RangeError("Illegal str: Contains NULL-characters");
                if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");
                b >>>= 0;
                if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 \x3c\x3d " + b + " (+0) \x3c\x3d " +
                    this.buffer.byteLength);
            }
            d = b;
            f = n.a(e(a))[1];
            b += f + 1;
            var g = this.buffer.byteLength;
            b > g && this.resize((g *= 2) > b ? g : b);
            b -= f + 1;
            n.c(e(a), function(a) {
                this.view.setUint8(b++, a)
            }.bind(this));
            this.view.setUint8(b++, 0);
            return c ? (this.offset = b - d, this) : f
        };
        g.readCString = function(a) {
            var b = "undefined" === typeof a;
            b && (a = this.offset);
            if (!this.noAssert) {
                if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");
                a >>>= 0;
                if (0 > a || a + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 \x3c\x3d " +
                    a + " (+1) \x3c\x3d " + this.buffer.byteLength);
            }
            var c = a,
                d, e = -1;
            n.b(function() {
                if (0 === e) return null;
                if (a >= this.limit) throw RangeError("Illegal range: Truncated data, " + a + " \x3c " + this.limit);
                return 0 === (e = this.view.getUint8(a++)) ? null : e
            }.bind(this), d = f(), !0);
            return b ? (this.offset = a, d()) : {
                string: d(),
                length: a - c
            }
        };
        g.writeIString = function(a, b) {
            var c = "undefined" === typeof b;
            c && (b = this.offset);
            if (!this.noAssert) {
                if ("string" !== typeof a) throw TypeError("Illegal str: Not a string");
                if ("number" !== typeof b || 0 !==
                    b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");
                b >>>= 0;
                if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 \x3c\x3d " + b + " (+0) \x3c\x3d " + this.buffer.byteLength);
            }
            var d = b,
                f;
            f = n.a(e(a), this.noAssert)[1];
            b += 4 + f;
            var g = this.buffer.byteLength;
            b > g && this.resize((g *= 2) > b ? g : b);
            b -= 4 + f;
            this.view.setUint32(b, f, this.littleEndian);
            b += 4;
            n.c(e(a), function(a) {
                this.view.setUint8(b++, a)
            }.bind(this));
            if (b !== d + 4 + f) throw RangeError("Illegal range: Truncated data, " + b + " \x3d\x3d " + (b + 4 +
                f));
            return c ? (this.offset = b, this) : b - d
        };
        g.readIString = function(a) {
            var b = "undefined" === typeof a;
            b && (a = this.offset);
            if (!this.noAssert) {
                if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");
                a >>>= 0;
                if (0 > a || a + 4 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 \x3c\x3d " + a + " (+4) \x3c\x3d " + this.buffer.byteLength);
            }
            var c = 0,
                d = a,
                c = this.view.getUint32(a, this.littleEndian);
            a += 4;
            var e = a + c;
            n.b(function() {
                return a < e ? this.view.getUint8(a++) : null
            }.bind(this), c = f(), this.noAssert);
            c = c();
            return b ? (this.offset = a, c) : {
                string: c,
                length: a - d
            }
        };
        b.METRICS_CHARS = "c";
        b.METRICS_BYTES = "b";
        g.writeUTF8String = function(a, b) {
            var c = "undefined" === typeof b;
            c && (b = this.offset);
            if (!this.noAssert) {
                if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: " + b + " (not an integer)");
                b >>>= 0;
                if (0 > b || b + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 \x3c\x3d " + b + " (+0) \x3c\x3d " + this.buffer.byteLength);
            }
            var d, f = b;
            d = n.a(e(a))[1];
            b += d;
            var g = this.buffer.byteLength;
            b > g && this.resize((g *= 2) >
                b ? g : b);
            b -= d;
            n.c(e(a), function(a) {
                this.view.setUint8(b++, a)
            }.bind(this));
            return c ? (this.offset = b, this) : b - f
        };
        g.writeString = g.writeUTF8String;
        b.calculateUTF8Chars = function(a) {
            return n.a(e(a))[0]
        };
        b.calculateUTF8Bytes = function(a) {
            return n.a(e(a))[1]
        };
        g.readUTF8String = function(a, c, e) {
            "number" === typeof c && (e = c, c = void 0);
            var g = "undefined" === typeof e;
            g && (e = this.offset);
            "undefined" === typeof c && (c = b.METRICS_CHARS);
            if (!this.noAssert) {
                if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal length: " + a + " (not an integer)");
                a |= 0;
                if ("number" !== typeof e || 0 !== e % 1) throw TypeError("Illegal offset: " + e + " (not an integer)");
                e >>>= 0;
                if (0 > e || e + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 \x3c\x3d " + e + " (+0) \x3c\x3d " + this.buffer.byteLength);
            }
            var h = 0,
                k = e,
                m;
            if (c === b.METRICS_CHARS) {
                m = f();
                n.g(function() {
                    return h < a && e < this.limit ? this.view.getUint8(e++) : null
                }.bind(this), function(a) {
                    ++h;
                    n.e(a, m)
                }.bind(this));
                if (h !== a) throw RangeError("Illegal range: Truncated data, " + h + " \x3d\x3d " + a);
                return g ? (this.offset = e, m()) : {
                    string: m(),
                    length: e - k
                }
            }
            if (c === b.METRICS_BYTES) {
                if (!this.noAssert) {
                    if ("number" !== typeof e || 0 !== e % 1) throw TypeError("Illegal offset: " + e + " (not an integer)");
                    e >>>= 0;
                    if (0 > e || e + a > this.buffer.byteLength) throw RangeError("Illegal offset: 0 \x3c\x3d " + e + " (+" + a + ") \x3c\x3d " + this.buffer.byteLength);
                }
                var y = e + a;
                n.b(function() {
                    return e < y ? this.view.getUint8(e++) : null
                }.bind(this), m = f(), this.noAssert);
                if (e !== y) throw RangeError("Illegal range: Truncated data, " + e + " \x3d\x3d " + y);
                return g ? (this.offset = e, m()) : {
                    string: m(),
                    length: e -
                        k
                }
            }
            throw TypeError("Unsupported metrics: " + c);
        };
        g.readString = g.readUTF8String;
        g.writeVString = function(a, c) {
            var f = "undefined" === typeof c;
            f && (c = this.offset);
            if (!this.noAssert) {
                if ("string" !== typeof a) throw TypeError("Illegal str: Not a string");
                if ("number" !== typeof c || 0 !== c % 1) throw TypeError("Illegal offset: " + c + " (not an integer)");
                c >>>= 0;
                if (0 > c || c + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 \x3c\x3d " + c + " (+0) \x3c\x3d " + this.buffer.byteLength);
            }
            var g = c,
                h, k;
            h = n.a(e(a), this.noAssert)[1];
            k = b.calculateVarint32(h);
            c += k + h;
            var m = this.buffer.byteLength;
            c > m && this.resize((m *= 2) > c ? m : c);
            c -= k + h;
            c += this.writeVarint32(h, c);
            n.c(e(a), function(a) {
                this.view.setUint8(c++, a)
            }.bind(this));
            if (c !== g + h + k) throw RangeError("Illegal range: Truncated data, " + c + " \x3d\x3d " + (c + h + k));
            return f ? (this.offset = c, this) : c - g
        };
        g.readVString = function(a) {
            var b = "undefined" === typeof a;
            b && (a = this.offset);
            if (!this.noAssert) {
                if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " + a + " (not an integer)");
                a >>>= 0;
                if (0 >
                    a || a + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 \x3c\x3d " + a + " (+1) \x3c\x3d " + this.buffer.byteLength);
            }
            var c = this.readVarint32(a),
                d = a;
            a += c.length;
            var c = c.value,
                e = a + c,
                c = f();
            n.b(function() {
                return a < e ? this.view.getUint8(a++) : null
            }.bind(this), c, this.noAssert);
            c = c();
            return b ? (this.offset = a, c) : {
                string: c,
                length: a - d
            }
        };
        g.append = function(a, c, e) {
            if ("number" === typeof c || "string" !== typeof c) e = c, c = void 0;
            var f = "undefined" === typeof e;
            f && (e = this.offset);
            if (!this.noAssert) {
                if ("number" !== typeof e ||
                    0 !== e % 1) throw TypeError("Illegal offset: " + e + " (not an integer)");
                e >>>= 0;
                if (0 > e || e + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 \x3c\x3d " + e + " (+0) \x3c\x3d " + this.buffer.byteLength);
            }
            a instanceof b || (a = b.wrap(a, c));
            c = a.limit - a.offset;
            if (0 >= c) return this;
            e += c;
            var g = this.buffer.byteLength;
            e > g && this.resize((g *= 2) > e ? g : e);
            (new Uint8Array(this.buffer, e - c)).set((new Uint8Array(a.buffer)).subarray(a.offset, a.limit));
            a.offset += c;
            f && (this.offset += c);
            return this
        };
        g.appendTo = function(a, b) {
            a.append(this,
                b);
            return this
        };
        g.assert = function(a) {
            this.noAssert = !a;
            return this
        };
        g.capacity = function() {
            return this.buffer.byteLength
        };
        g.clear = function() {
            this.offset = 0;
            this.limit = this.buffer.byteLength;
            this.markedOffset = -1;
            return this
        };
        g.clone = function(a) {
            var c = new b(0, this.littleEndian, this.noAssert);
            a ? (a = new ArrayBuffer(this.buffer.byteLength), (new Uint8Array(a)).set(this.buffer), c.buffer = a, c.view = new DataView(a)) : (c.buffer = this.buffer, c.view = this.view);
            c.offset = this.offset;
            c.markedOffset = this.markedOffset;
            c.limit =
                this.limit;
            return c
        };
        g.compact = function(a, b) {
            "undefined" === typeof a && (a = this.offset);
            "undefined" === typeof b && (b = this.limit);
            if (!this.noAssert) {
                if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal begin: Not an integer");
                a >>>= 0;
                if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal end: Not an integer");
                b >>>= 0;
                if (0 > a || a > b || b > this.buffer.byteLength) throw RangeError("Illegal range: 0 \x3c\x3d " + a + " \x3c\x3d " + b + " \x3c\x3d " + this.buffer.byteLength);
            }
            if (0 === a && b === this.buffer.byteLength) return this;
            var c = b - a;
            if (0 === c) return this.buffer = h, this.view = null, 0 <= this.markedOffset && (this.markedOffset -= a), this.limit = this.offset = 0, this;
            var d = new ArrayBuffer(c);
            (new Uint8Array(d)).set((new Uint8Array(this.buffer)).subarray(a, b));
            this.buffer = d;
            this.view = new DataView(d);
            0 <= this.markedOffset && (this.markedOffset -= a);
            this.offset = 0;
            this.limit = c;
            return this
        };
        g.copy = function(a, c) {
            "undefined" === typeof a && (a = this.offset);
            "undefined" === typeof c && (c = this.limit);
            if (!this.noAssert) {
                if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal begin: Not an integer");
                a >>>= 0;
                if ("number" !== typeof c || 0 !== c % 1) throw TypeError("Illegal end: Not an integer");
                c >>>= 0;
                if (0 > a || a > c || c > this.buffer.byteLength) throw RangeError("Illegal range: 0 \x3c\x3d " + a + " \x3c\x3d " + c + " \x3c\x3d " + this.buffer.byteLength);
            }
            if (a === c) return new b(0, this.littleEndian, this.noAssert);
            var e = c - a,
                f = new b(e, this.littleEndian, this.noAssert);
            f.offset = 0;
            f.limit = e;
            0 <= f.markedOffset && (f.markedOffset -= a);
            this.copyTo(f, 0, a, c);
            return f
        };
        g.copyTo = function(a, c, e, f) {
            var g, h;
            if (!this.noAssert && !b.isByteBuffer(a)) throw TypeError("Illegal target: Not a ByteBuffer");
            c = (h = "undefined" === typeof c) ? a.offset : c | 0;
            e = (g = "undefined" === typeof e) ? this.offset : e | 0;
            f = "undefined" === typeof f ? this.limit : f | 0;
            if (0 > c || c > a.buffer.byteLength) throw RangeError("Illegal target range: 0 \x3c\x3d " + c + " \x3c\x3d " + a.buffer.byteLength);
            if (0 > e || f > this.buffer.byteLength) throw RangeError("Illegal source range: 0 \x3c\x3d " + e + " \x3c\x3d " + this.buffer.byteLength);
            var k = f - e;
            if (0 === k) return a;
            a.ensureCapacity(c + k);
            (new Uint8Array(a.buffer)).set((new Uint8Array(this.buffer)).subarray(e, f), c);
            g &&
                (this.offset += k);
            h && (a.offset += k);
            return this
        };
        g.ensureCapacity = function(a) {
            var b = this.buffer.byteLength;
            return b < a ? this.resize((b *= 2) > a ? b : a) : this
        };
        g.fill = function(a, b, c) {
            var d = "undefined" === typeof b;
            d && (b = this.offset);
            "string" === typeof a && 0 < a.length && (a = a.charCodeAt(0));
            "undefined" === typeof b && (b = this.offset);
            "undefined" === typeof c && (c = this.limit);
            if (!this.noAssert) {
                if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal value: " + a + " (not an integer)");
                a |= 0;
                if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal begin: Not an integer");
                b >>>= 0;
                if ("number" !== typeof c || 0 !== c % 1) throw TypeError("Illegal end: Not an integer");
                c >>>= 0;
                if (0 > b || b > c || c > this.buffer.byteLength) throw RangeError("Illegal range: 0 \x3c\x3d " + b + " \x3c\x3d " + c + " \x3c\x3d " + this.buffer.byteLength);
            }
            if (b >= c) return this;
            for (; b < c;) this.view.setUint8(b++, a);
            d && (this.offset = b);
            return this
        };
        g.flip = function() {
            this.limit = this.offset;
            this.offset = 0;
            return this
        };
        g.mark = function(a) {
            a = "undefined" === typeof a ? this.offset : a;
            if (!this.noAssert) {
                if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal offset: " +
                    a + " (not an integer)");
                a >>>= 0;
                if (0 > a || a + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 \x3c\x3d " + a + " (+0) \x3c\x3d " + this.buffer.byteLength);
            }
            this.markedOffset = a;
            return this
        };
        g.order = function(a) {
            if (!this.noAssert && "boolean" !== typeof a) throw TypeError("Illegal littleEndian: Not a boolean");
            this.littleEndian = !!a;
            return this
        };
        g.LE = function(a) {
            this.littleEndian = "undefined" !== typeof a ? !!a : !0;
            return this
        };
        g.BE = function(a) {
            this.littleEndian = "undefined" !== typeof a ? !a : !1;
            return this
        };
        g.prepend =
            function(a, c, e) {
                if ("number" === typeof c || "string" !== typeof c) e = c, c = void 0;
                var f = "undefined" === typeof e;
                f && (e = this.offset);
                if (!this.noAssert) {
                    if ("number" !== typeof e || 0 !== e % 1) throw TypeError("Illegal offset: " + e + " (not an integer)");
                    e >>>= 0;
                    if (0 > e || e + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 \x3c\x3d " + e + " (+0) \x3c\x3d " + this.buffer.byteLength);
                }
                a instanceof b || (a = b.wrap(a, c));
                c = a.limit - a.offset;
                if (0 >= c) return this;
                var g = c - e,
                    h;
                if (0 < g) {
                    var k = new ArrayBuffer(this.buffer.byteLength + g);
                    h = new Uint8Array(k);
                    h.set((new Uint8Array(this.buffer)).subarray(e, this.buffer.byteLength), c);
                    this.buffer = k;
                    this.view = new DataView(k);
                    this.offset += g;
                    0 <= this.markedOffset && (this.markedOffset += g);
                    this.limit += g;
                    e += g
                } else h = new Uint8Array(this.buffer);
                h.set((new Uint8Array(a.buffer)).subarray(a.offset, a.limit), e - c);
                a.offset = a.limit;
                f && (this.offset -= c);
                return this
            };
        g.prependTo = function(a, b) {
            a.prepend(this, b);
            return this
        };
        g.printDebug = function(a) {
            "function" !== typeof a && (a = console.log.bind(console));
            a(this.toString() +
                "\n-------------------------------------------------------------------\n" + this.toDebug(!0))
        };
        g.remaining = function() {
            return this.limit - this.offset
        };
        g.reset = function() {
            0 <= this.markedOffset ? (this.offset = this.markedOffset, this.markedOffset = -1) : this.offset = 0;
            return this
        };
        g.resize = function(a) {
            if (!this.noAssert) {
                if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal capacity: " + a + " (not an integer)");
                a |= 0;
                if (0 > a) throw RangeError("Illegal capacity: 0 \x3c\x3d " + a);
            }
            this.buffer.byteLength < a && (a = new ArrayBuffer(a), (new Uint8Array(a)).set(new Uint8Array(this.buffer)), this.buffer = a, this.view = new DataView(a));
            return this
        };
        g.reverse = function(a, b) {
            "undefined" === typeof a && (a = this.offset);
            "undefined" === typeof b && (b = this.limit);
            if (!this.noAssert) {
                if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal begin: Not an integer");
                a >>>= 0;
                if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal end: Not an integer");
                b >>>= 0;
                if (0 > a || a > b || b > this.buffer.byteLength) throw RangeError("Illegal range: 0 \x3c\x3d " + a + " \x3c\x3d " +
                    b + " \x3c\x3d " + this.buffer.byteLength);
            }
            if (a === b) return this;
            Array.prototype.reverse.call((new Uint8Array(this.buffer)).subarray(a, b));
            this.view = new DataView(this.buffer);
            return this
        };
        g.skip = function(a) {
            if (!this.noAssert) {
                if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal length: " + a + " (not an integer)");
                a |= 0
            }
            var b = this.offset + a;
            if (!this.noAssert && (0 > b || b > this.buffer.byteLength)) throw RangeError("Illegal length: 0 \x3c\x3d " + this.offset + " + " + a + " \x3c\x3d " + this.buffer.byteLength);
            this.offset =
                b;
            return this
        };
        g.slice = function(a, b) {
            "undefined" === typeof a && (a = this.offset);
            "undefined" === typeof b && (b = this.limit);
            if (!this.noAssert) {
                if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal begin: Not an integer");
                a >>>= 0;
                if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal end: Not an integer");
                b >>>= 0;
                if (0 > a || a > b || b > this.buffer.byteLength) throw RangeError("Illegal range: 0 \x3c\x3d " + a + " \x3c\x3d " + b + " \x3c\x3d " + this.buffer.byteLength);
            }
            var c = this.clone();
            c.offset = a;
            c.limit = b;
            return c
        };
        g.toBuffer =
            function(a) {
                var b = this.offset,
                    c = this.limit;
                if (b > c) var d = b,
                    b = c,
                    c = d;
                if (!this.noAssert) {
                    if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal offset: Not an integer");
                    b >>>= 0;
                    if ("number" !== typeof c || 0 !== c % 1) throw TypeError("Illegal limit: Not an integer");
                    c >>>= 0;
                    if (0 > b || b > c || c > this.buffer.byteLength) throw RangeError("Illegal range: 0 \x3c\x3d " + b + " \x3c\x3d " + c + " \x3c\x3d " + this.buffer.byteLength);
                }
                if (!a && 0 === b && c === this.buffer.byteLength) return this.buffer;
                if (b === c) return h;
                a = new ArrayBuffer(c - b);
                (new Uint8Array(a)).set((new Uint8Array(this.buffer)).subarray(b, c), 0);
                return a
            };
        g.toArrayBuffer = g.toBuffer;
        g.toString = function(a, b, c) {
            if ("undefined" === typeof a) return "ByteBufferAB(offset\x3d" + this.offset + ",markedOffset\x3d" + this.markedOffset + ",limit\x3d" + this.limit + ",capacity\x3d" + this.capacity() + ")";
            "number" === typeof a && (c = b = a = "utf8");
            switch (a) {
                case "utf8":
                    return this.toUTF8(b, c);
                case "base64":
                    return this.toBase64(b, c);
                case "hex":
                    return this.toHex(b, c);
                case "binary":
                    return this.toBinary(b, c);
                case "debug":
                    return this.toDebug();
                case "columns":
                    return this.m();
                default:
                    throw Error("Unsupported encoding: " + a);
            }
        };
        var m = function() {
            for (var a = {}, b = [65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47], c = [], d = 0, e = b.length; d < e; ++d) c[b[d]] = d;
            a.i = function(a, c) {
                for (var d, e; null !== (d = a());) c(b[d >> 2 & 63]), e = (d & 3) << 4, null !== (d = a()) ? (e |= d >> 4 & 15, c(b[(e | d >> 4 & 15) & 63]), e = (d & 15) << 2, null !==
                    (d = a()) ? (c(b[(e | d >> 6 & 3) & 63]), c(b[d & 63])) : (c(b[e & 63]), c(61))) : (c(b[e & 63]), c(61), c(61))
            };
            a.h = function(a, b) {
                function d(a) {
                    throw Error("Illegal character code: " + a);
                }
                for (var e, f, g; null !== (e = a());)
                    if (f = c[e], "undefined" === typeof f && d(e), null !== (e = a()) && (g = c[e], "undefined" === typeof g && d(e), b(f << 2 >>> 0 | (g & 48) >> 4), null !== (e = a()))) {
                        f = c[e];
                        if ("undefined" === typeof f)
                            if (61 === e) break;
                            else d(e);
                        b((g & 15) << 4 >>> 0 | (f & 60) >> 2);
                        if (null !== (e = a())) {
                            g = c[e];
                            if ("undefined" === typeof g)
                                if (61 === e) break;
                                else d(e);
                            b((f & 3) << 6 >>> 0 |
                                g)
                        }
                    }
            };
            a.test = function(a) {
                return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(a)
            };
            return a
        }();
        g.toBase64 = function(a, b) {
            "undefined" === typeof a && (a = this.offset);
            "undefined" === typeof b && (b = this.limit);
            if (!this.noAssert) {
                if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal begin: Not an integer");
                a >>>= 0;
                if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal end: Not an integer");
                b >>>= 0;
                if (0 > a || a > b || b > this.buffer.byteLength) throw RangeError("Illegal range: 0 \x3c\x3d " + a +
                    " \x3c\x3d " + b + " \x3c\x3d " + this.buffer.byteLength);
            }
            var c;
            m.i(function() {
                return a < b ? this.view.getUint8(a++) : null
            }.bind(this), c = f());
            return c()
        };
        b.fromBase64 = function(a, c, f) {
            if (!f) {
                if ("string" !== typeof a) throw TypeError("Illegal str: Not a string");
                if (0 !== a.length % 4) throw TypeError("Illegal str: Length not a multiple of 4");
            }
            var g = new b(3 * (a.length / 4), c, f),
                h = 0;
            m.h(e(a), function(a) {
                g.view.setUint8(h++, a)
            });
            g.limit = h;
            return g
        };
        b.btoa = function(a) {
            return b.fromBinary(a).toBase64()
        };
        b.atob = function(a) {
            return b.fromBase64(a).toBinary()
        };
        g.toBinary = function(a, b) {
            a = "undefined" === typeof a ? this.offset : a;
            b = "undefined" === typeof b ? this.limit : b;
            if (!this.noAssert) {
                if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal begin: Not an integer");
                a >>>= 0;
                if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal end: Not an integer");
                b >>>= 0;
                if (0 > a || a > b || b > this.buffer.byteLength) throw RangeError("Illegal range: 0 \x3c\x3d " + a + " \x3c\x3d " + b + " \x3c\x3d " + this.buffer.byteLength);
            }
            if (a === b) return "";
            for (var c = [], d = []; a < b;) c.push(this.view.getUint8(a++)),
                1024 <= c.length && (d.push(String.fromCharCode.apply(String, c)), c = []);
            return d.join("") + String.fromCharCode.apply(String, c)
        };
        b.fromBinary = function(a, c, e) {
            if (!e && "string" !== typeof a) throw TypeError("Illegal str: Not a string");
            for (var f = 0, g = a.length, h = new b(g, c, e); f < g;) {
                c = a.charCodeAt(f);
                if (!e && 255 < c) throw RangeError("Illegal charCode at " + f + ": 0 \x3c\x3d " + c + " \x3c\x3d 255");
                h.view.setUint8(f++, c)
            }
            h.limit = g;
            return h
        };
        g.toDebug = function(a) {
            for (var b = -1, c = this.buffer.byteLength, d, e = "", f = "", g = ""; b < c;) {
                -1 !==
                    b && (d = this.view.getUint8(b), e = 16 > d ? e + ("0" + d.toString(16).toUpperCase()) : e + d.toString(16).toUpperCase(), a && (f += 32 < d && 127 > d ? String.fromCharCode(d) : "."));
                ++b;
                if (a && 0 < b && 0 === b % 16 && b !== c) {
                    for (; 51 > e.length;) e += " ";
                    g += e + f + "\n";
                    e = f = ""
                }
                e = b === this.offset && b === this.limit ? e + (b === this.markedOffset ? "!" : "|") : b === this.offset ? e + (b === this.markedOffset ? "[" : "\x3c") : b === this.limit ? e + (b === this.markedOffset ? "]" : "\x3e") : e + (b === this.markedOffset ? "'" : a || 0 !== b && b !== c ? " " : "")
            }
            if (a && " " !== e) {
                for (; 51 > e.length;) e += " ";
                g += e + f + "\n"
            }
            return a ?
                g : e
        };
        b.fromDebug = function(a, c, e) {
            var f = a.length;
            c = new b((f + 1) / 3 | 0, c, e);
            for (var g = 0, h = 0, k, m = !1, n = !1, C = !1, z = !1, A = !1; g < f;) {
                switch (k = a.charAt(g++)) {
                    case "!":
                        if (!e) {
                            if (n || C || z) {
                                A = !0;
                                break
                            }
                            n = C = z = !0
                        }
                        c.offset = c.markedOffset = c.limit = h;
                        m = !1;
                        break;
                    case "|":
                        if (!e) {
                            if (n || z) {
                                A = !0;
                                break
                            }
                            n = z = !0
                        }
                        c.offset = c.limit = h;
                        m = !1;
                        break;
                    case "[":
                        if (!e) {
                            if (n || C) {
                                A = !0;
                                break
                            }
                            n = C = !0
                        }
                        c.offset = c.markedOffset = h;
                        m = !1;
                        break;
                    case "\x3c":
                        if (!e) {
                            if (n) {
                                A = !0;
                                break
                            }
                            n = !0
                        }
                        c.offset = h;
                        m = !1;
                        break;
                    case "]":
                        if (!e) {
                            if (z || C) {
                                A = !0;
                                break
                            }
                            z = C = !0
                        }
                        c.limit =
                            c.markedOffset = h;
                        m = !1;
                        break;
                    case "\x3e":
                        if (!e) {
                            if (z) {
                                A = !0;
                                break
                            }
                            z = !0
                        }
                        c.limit = h;
                        m = !1;
                        break;
                    case "'":
                        if (!e) {
                            if (C) {
                                A = !0;
                                break
                            }
                            C = !0
                        }
                        c.markedOffset = h;
                        m = !1;
                        break;
                    case " ":
                        m = !1;
                        break;
                    default:
                        if (!e && m) {
                            A = !0;
                            break
                        }
                        k = parseInt(k + a.charAt(g++), 16);
                        if (!e && (isNaN(k) || 0 > k || 255 < k)) throw TypeError("Illegal str: Not a debug encoded string");
                        c.view.setUint8(h++, k);
                        m = !0
                }
                if (A) throw TypeError("Illegal str: Invalid symbol at " + g);
            }
            if (!e) {
                if (!n || !z) throw TypeError("Illegal str: Missing offset or limit");
                if (h < c.buffer.byteLength) throw TypeError("Illegal str: Not a debug encoded string (is it hex?) " +
                    h + " \x3c " + f);
            }
            return c
        };
        g.toHex = function(a, b) {
            a = "undefined" === typeof a ? this.offset : a;
            b = "undefined" === typeof b ? this.limit : b;
            if (!this.noAssert) {
                if ("number" !== typeof a || 0 !== a % 1) throw TypeError("Illegal begin: Not an integer");
                a >>>= 0;
                if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal end: Not an integer");
                b >>>= 0;
                if (0 > a || a > b || b > this.buffer.byteLength) throw RangeError("Illegal range: 0 \x3c\x3d " + a + " \x3c\x3d " + b + " \x3c\x3d " + this.buffer.byteLength);
            }
            for (var c = Array(b - a), d; a < b;) d = this.view.getUint8(a++),
                16 > d ? c.push("0", d.toString(16)) : c.push(d.toString(16));
            return c.join("")
        };
        b.fromHex = function(a, c, e) {
            if (!e) {
                if ("string" !== typeof a) throw TypeError("Illegal str: Not a string");
                if (0 !== a.length % 2) throw TypeError("Illegal str: Length not a multiple of 2");
            }
            var f = a.length;
            c = new b(f / 2 | 0, c);
            for (var g, h = 0, k = 0; h < f; h += 2) {
                g = parseInt(a.substring(h, h + 2), 16);
                if (!e && (!isFinite(g) || 0 > g || 255 < g)) throw TypeError("Illegal str: Contains non-hex characters");
                c.view.setUint8(k++, g)
            }
            c.limit = k;
            return c
        };
        var n = function() {
            var a = {
                k: 1114111,
                j: function(a, b) {
                    var c = null;
                    for ("number" === typeof a && (c = a, a = function() {
                        return null
                    }); null !== c || null !== (c = a());) 128 > c ? b(c & 127) : (2048 > c ? b(c >> 6 & 31 | 192) : (65536 > c ? b(c >> 12 & 15 | 224) : (b(c >> 18 & 7 | 240), b(c >> 12 & 63 | 128)), b(c >> 6 & 63 | 128)), b(c & 63 | 128)), c = null
                },
                g: function(a, b) {
                    function c(a) {
                        a = a.slice(0, a.indexOf(null));
                        var b = Error(a.toString());
                        b.name = "TruncatedError";
                        b.bytes = a;
                        throw b;
                    }
                    for (var d, e, f, g; null !== (d = a());)
                        if (0 === (d & 128)) b(d);
                        else if (192 === (d & 224)) null === (e = a()) && c([d, e]), b((d & 31) << 6 | e & 63);
                    else if (224 ===
                        (d & 240)) null !== (e = a()) && null !== (f = a()) || c([d, e, f]), b((d & 15) << 12 | (e & 63) << 6 | f & 63);
                    else if (240 === (d & 248)) null !== (e = a()) && null !== (f = a()) && null !== (g = a()) || c([d, e, f, g]), b((d & 7) << 18 | (e & 63) << 12 | (f & 63) << 6 | g & 63);
                    else throw RangeError("Illegal starting byte: " + d);
                },
                d: function(a, b) {
                    for (var c, d = null; null !== (c = null !== d ? d : a());) 55296 <= c && 57343 >= c && null !== (d = a()) && 56320 <= d && 57343 >= d ? (b(1024 * (c - 55296) + d - 56320 + 65536), d = null) : b(c);
                    null !== d && b(d)
                },
                e: function(a, b) {
                    var c = null;
                    for ("number" === typeof a && (c = a, a = function() {
                            return null
                        }); null !==
                        c || null !== (c = a());) 65535 >= c ? b(c) : (c -= 65536, b((c >> 10) + 55296), b(c % 1024 + 56320)), c = null
                },
                c: function(b, c) {
                    a.d(b, function(b) {
                        a.j(b, c)
                    })
                },
                b: function(b, c) {
                    a.g(b, function(b) {
                        a.e(b, c)
                    })
                },
                f: function(a) {
                    return 128 > a ? 1 : 2048 > a ? 2 : 65536 > a ? 3 : 4
                },
                l: function(b) {
                    for (var c, d = 0; null !== (c = b());) d += a.f(c);
                    return d
                },
                a: function(b) {
                    var c = 0,
                        d = 0;
                    a.d(b, function(b) {
                        ++c;
                        d += a.f(b)
                    });
                    return [c, d]
                }
            };
            return a
        }();
        g.toUTF8 = function(a, b) {
            "undefined" === typeof a && (a = this.offset);
            "undefined" === typeof b && (b = this.limit);
            if (!this.noAssert) {
                if ("number" !==
                    typeof a || 0 !== a % 1) throw TypeError("Illegal begin: Not an integer");
                a >>>= 0;
                if ("number" !== typeof b || 0 !== b % 1) throw TypeError("Illegal end: Not an integer");
                b >>>= 0;
                if (0 > a || a > b || b > this.buffer.byteLength) throw RangeError("Illegal range: 0 \x3c\x3d " + a + " \x3c\x3d " + b + " \x3c\x3d " + this.buffer.byteLength);
            }
            var c;
            try {
                n.b(function() {
                    return a < b ? this.view.getUint8(a++) : null
                }.bind(this), c = f())
            } catch (d) {
                if (a !== b) throw RangeError("Illegal range: Truncated data, " + a + " !\x3d " + b);
            }
            return c()
        };
        b.fromUTF8 = function(a,
            c, f) {
            if (!f && "string" !== typeof a) throw TypeError("Illegal str: Not a string");
            var g = new b(n.a(e(a), !0)[1], c, f),
                h = 0;
            n.c(e(a), function(a) {
                g.view.setUint8(h++, a)
            });
            g.limit = h;
            return g
        };
        return b
    }
    "undefined" !== typeof module && module.exports ? module.exports = b(require("long")) : "function" === typeof define && define.amd ? define("ByteBuffer", ["Long"], function(a) {
        return b(a)
    }) : (a.dcodeIO = a.dcodeIO || {}).ByteBuffer = b(a.dcodeIO.Long)
})(this);
(function() {
    (function(a) {
        function b(a, b, c) {
            this.low = a | 0;
            this.high = b | 0;
            this.unsigned = !!c
        }
        b.isLong = function(a) {
            return !0 === (a && a instanceof b)
        };
        var c = {},
            d = {};
        b.fromInt = function(a, e) {
            var f;
            if (e) {
                a >>>= 0;
                if (0 <= a && 256 > a && (f = d[a])) return f;
                f = new b(a, 0 > (a | 0) ? -1 : 0, !0);
                0 <= a && 256 > a && (d[a] = f)
            } else {
                a |= 0;
                if (-128 <= a && 128 > a && (f = c[a])) return f;
                f = new b(a, 0 > a ? -1 : 0, !1); - 128 <= a && 128 > a && (c[a] = f)
            }
            return f
        };
        b.fromNumber = function(a, c) {
            c = !!c;
            return isNaN(a) || !isFinite(a) ? b.ZERO : !c && a <= -g ? b.MIN_VALUE : !c && a + 1 >= g ? b.MAX_VALUE :
                c && a >= f ? b.MAX_UNSIGNED_VALUE : 0 > a ? b.fromNumber(-a, c).negate() : new b(a % e | 0, a / e | 0, c)
        };
        b.fromBits = function(a, c, d) {
            return new b(a, c, d)
        };
        b.fromString = function(a, c, d) {
            if (0 === a.length) throw Error("number format error: empty string");
            if ("NaN" === a || "Infinity" === a || "+Infinity" === a || "-Infinity" === a) return b.ZERO;
            "number" === typeof c && (d = c, c = !1);
            d = d || 10;
            if (2 > d || 36 < d) throw Error("radix out of range: " + d);
            var e;
            if (0 < (e = a.indexOf("-"))) throw Error('number format error: interior "-" character: ' + a);
            if (0 === e) return b.fromString(a.substring(1),
                c, d).negate();
            e = b.fromNumber(Math.pow(d, 8));
            for (var f = b.ZERO, g = 0; g < a.length; g += 8) {
                var h = Math.min(8, a.length - g),
                    u = parseInt(a.substring(g, g + h), d);
                8 > h ? (h = b.fromNumber(Math.pow(d, h)), f = f.multiply(h).add(b.fromNumber(u))) : (f = f.multiply(e), f = f.add(b.fromNumber(u)))
            }
            f.unsigned = c;
            return f
        };
        b.fromValue = function(a) {
            return "number" === typeof a ? b.fromNumber(a) : "string" === typeof a ? b.fromString(a) : b.isLong(a) ? a : new b(a.low, a.high, a.unsigned)
        };
        var e = 4294967296,
            f = e * e,
            g = f / 2,
            h = b.fromInt(16777216);
        b.ZERO = b.fromInt(0);
        b.UZERO = b.fromInt(0, !0);
        b.ONE = b.fromInt(1);
        b.UONE = b.fromInt(1, !0);
        b.NEG_ONE = b.fromInt(-1);
        b.MAX_VALUE = b.fromBits(-1, 2147483647, !1);
        b.MAX_UNSIGNED_VALUE = b.fromBits(-1, -1, !0);
        b.MIN_VALUE = b.fromBits(0, -2147483648, !1);
        b.prototype.toInt = function() {
            return this.unsigned ? this.low >>> 0 : this.low
        };
        b.prototype.toNumber = function() {
            return this.unsigned ? (this.high >>> 0) * e + (this.low >>> 0) : this.high * e + (this.low >>> 0)
        };
        b.prototype.toString = function(a) {
            a = a || 10;
            if (2 > a || 36 < a) throw RangeError("radix out of range: " + a);
            if (this.isZero()) return "0";
            var c;
            if (this.isNegative()) {
                if (this.equals(b.MIN_VALUE)) {
                    c = b.fromNumber(a);
                    var d = this.div(c);
                    c = d.multiply(c).subtract(this);
                    return d.toString(a) + c.toInt().toString(a)
                }
                return "-" + this.negate().toString(a)
            }
            d = b.fromNumber(Math.pow(a, 6), this.unsigned);
            c = this;
            for (var e = "";;) {
                var f = c.div(d),
                    g = (c.subtract(f.multiply(d)).toInt() >>> 0).toString(a);
                c = f;
                if (c.isZero()) return g + e;
                for (; 6 > g.length;) g = "0" + g;
                e = "" + g + e
            }
        };
        b.prototype.getHighBits = function() {
            return this.high
        };
        b.prototype.getHighBitsUnsigned = function() {
            return this.high >>>
                0
        };
        b.prototype.getLowBits = function() {
            return this.low
        };
        b.prototype.getLowBitsUnsigned = function() {
            return this.low >>> 0
        };
        b.prototype.getNumBitsAbs = function() {
            if (this.isNegative()) return this.equals(b.MIN_VALUE) ? 64 : this.negate().getNumBitsAbs();
            for (var a = 0 != this.high ? this.high : this.low, c = 31; 0 < c && 0 == (a & 1 << c); c--);
            return 0 != this.high ? c + 33 : c + 1
        };
        b.prototype.isZero = function() {
            return 0 === this.high && 0 === this.low
        };
        b.prototype.isNegative = function() {
            return !this.unsigned && 0 > this.high
        };
        b.prototype.isPositive = function() {
            return this.unsigned ||
                0 <= this.high
        };
        b.prototype.isOdd = function() {
            return 1 === (this.low & 1)
        };
        b.prototype.equals = function(a) {
            b.isLong(a) || (a = b.fromValue(a));
            return this.unsigned !== a.unsigned && this.high >>> 31 !== a.high >>> 31 ? !1 : this.high === a.high && this.low === a.low
        };
        b.prototype.notEquals = function(a) {
            b.isLong(a) || (a = b.fromValue(a));
            return !this.equals(a)
        };
        b.prototype.lessThan = function(a) {
            b.isLong(a) || (a = b.fromValue(a));
            return 0 > this.compare(a)
        };
        b.prototype.lessThanOrEqual = function(a) {
            b.isLong(a) || (a = b.fromValue(a));
            return 0 >= this.compare(a)
        };
        b.prototype.greaterThan = function(a) {
            b.isLong(a) || (a = b.fromValue(a));
            return 0 < this.compare(a)
        };
        b.prototype.greaterThanOrEqual = function(a) {
            return 0 <= this.compare(a)
        };
        b.prototype.compare = function(a) {
            if (this.equals(a)) return 0;
            var b = this.isNegative(),
                c = a.isNegative();
            return b && !c ? -1 : !b && c ? 1 : this.unsigned ? a.high >>> 0 > this.high >>> 0 || a.high === this.high && a.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.subtract(a).isNegative() ? -1 : 1
        };
        b.prototype.negate = function() {
            return !this.unsigned && this.equals(b.MIN_VALUE) ? b.MIN_VALUE :
                this.not().add(b.ONE)
        };
        b.prototype.add = function(a) {
            b.isLong(a) || (a = b.fromValue(a));
            var c = this.high >>> 16,
                d = this.high & 65535,
                e = this.low >>> 16,
                f = a.high >>> 16,
                g = a.high & 65535,
                h = a.low >>> 16,
                u;
            u = 0 + ((this.low & 65535) + (a.low & 65535));
            a = 0 + (u >>> 16) + (e + h);
            e = 0 + (a >>> 16);
            e += d + g;
            d = 0 + (e >>> 16) + (c + f) & 65535;
            return b.fromBits((a & 65535) << 16 | u & 65535, d << 16 | e & 65535, this.unsigned)
        };
        b.prototype.subtract = function(a) {
            b.isLong(a) || (a = b.fromValue(a));
            return this.add(a.negate())
        };
        b.prototype.multiply = function(a) {
            if (this.isZero()) return b.ZERO;
            b.isLong(a) || (a = b.fromValue(a));
            if (a.isZero()) return b.ZERO;
            if (this.equals(b.MIN_VALUE)) return a.isOdd() ? b.MIN_VALUE : b.ZERO;
            if (a.equals(b.MIN_VALUE)) return this.isOdd() ? b.MIN_VALUE : b.ZERO;
            if (this.isNegative()) return a.isNegative() ? this.negate().multiply(a.negate()) : this.negate().multiply(a).negate();
            if (a.isNegative()) return this.multiply(a.negate()).negate();
            if (this.lessThan(h) && a.lessThan(h)) return b.fromNumber(this.toNumber() * a.toNumber(), this.unsigned);
            var c = this.high >>> 16,
                d = this.high & 65535,
                e =
                this.low >>> 16,
                f = this.low & 65535,
                g = a.high >>> 16,
                t = a.high & 65535,
                u = a.low >>> 16;
            a = a.low & 65535;
            var w, v, y, D;
            D = 0 + f * a;
            y = 0 + (D >>> 16) + e * a;
            v = 0 + (y >>> 16);
            y = (y & 65535) + f * u;
            v += y >>> 16;
            y &= 65535;
            v += d * a;
            w = 0 + (v >>> 16);
            v = (v & 65535) + e * u;
            w += v >>> 16;
            v = (v & 65535) + f * t;
            w += v >>> 16;
            v &= 65535;
            return b.fromBits(y << 16 | D & 65535, (w + (c * a + d * u + e * t + f * g) & 65535) << 16 | v, this.unsigned)
        };
        b.prototype.div = function(a) {
            b.isLong(a) || (a = b.fromValue(a));
            if (a.isZero()) throw Error("division by zero");
            if (this.isZero()) return this.unsigned ? b.UZERO : b.ZERO;
            var c, d,
                e;
            if (this.equals(b.MIN_VALUE)) {
                if (a.equals(b.ONE) || a.equals(b.NEG_ONE)) return b.MIN_VALUE;
                if (a.equals(b.MIN_VALUE)) return b.ONE;
                c = this.shiftRight(1).div(a).shiftLeft(1);
                if (c.equals(b.ZERO)) return a.isNegative() ? b.ONE : b.NEG_ONE;
                d = this.subtract(a.multiply(c));
                return c.add(d.div(a))
            }
            if (a.equals(b.MIN_VALUE)) return this.unsigned ? b.UZERO : b.ZERO;
            if (this.isNegative()) return a.isNegative() ? this.negate().div(a.negate()) : this.negate().div(a).negate();
            if (a.isNegative()) return this.div(a.negate()).negate();
            e =
                b.ZERO;
            for (d = this; d.greaterThanOrEqual(a);) {
                c = Math.max(1, Math.floor(d.toNumber() / a.toNumber()));
                for (var f = Math.ceil(Math.log(c) / Math.LN2), f = 48 >= f ? 1 : Math.pow(2, f - 48), g = b.fromNumber(c), h = g.multiply(a); h.isNegative() || h.greaterThan(d);) c -= f, g = b.fromNumber(c, this.unsigned), h = g.multiply(a);
                g.isZero() && (g = b.ONE);
                e = e.add(g);
                d = d.subtract(h)
            }
            return e
        };
        b.prototype.modulo = function(a) {
            b.isLong(a) || (a = b.fromValue(a));
            return this.subtract(this.div(a).multiply(a))
        };
        b.prototype.not = function() {
            return b.fromBits(~this.low, ~this.high, this.unsigned)
        };
        b.prototype.and = function(a) {
            b.isLong(a) || (a = b.fromValue(a));
            return b.fromBits(this.low & a.low, this.high & a.high, this.unsigned)
        };
        b.prototype.or = function(a) {
            b.isLong(a) || (a = b.fromValue(a));
            return b.fromBits(this.low | a.low, this.high | a.high, this.unsigned)
        };
        b.prototype.xor = function(a) {
            b.isLong(a) || (a = b.fromValue(a));
            return b.fromBits(this.low ^ a.low, this.high ^ a.high, this.unsigned)
        };
        b.prototype.shiftLeft = function(a) {
            b.isLong(a) && (a = a.toInt());
            return 0 === (a &= 63) ? this : 32 > a ? b.fromBits(this.low <<
                a, this.high << a | this.low >>> 32 - a, this.unsigned) : b.fromBits(0, this.low << a - 32, this.unsigned)
        };
        b.prototype.shiftRight = function(a) {
            b.isLong(a) && (a = a.toInt());
            return 0 === (a &= 63) ? this : 32 > a ? b.fromBits(this.low >>> a | this.high << 32 - a, this.high >> a, this.unsigned) : b.fromBits(this.high >> a - 32, 0 <= this.high ? 0 : -1, this.unsigned)
        };
        b.prototype.shiftRightUnsigned = function(a) {
            b.isLong(a) && (a = a.toInt());
            a &= 63;
            if (0 === a) return this;
            var c = this.high;
            return 32 > a ? b.fromBits(this.low >>> a | c << 32 - a, c >>> a, this.unsigned) : 32 === a ? b.fromBits(c,
                0, this.unsigned) : b.fromBits(c >>> a - 32, 0, this.unsigned)
        };
        b.prototype.toSigned = function() {
            return this.unsigned ? new b(this.low, this.high, !1) : this
        };
        b.prototype.toUnsigned = function() {
            return this.unsigned ? this : new b(this.low, this.high, !0)
        };
        "undefined" !== typeof module && module.exports ? module.exports = b : "function" === typeof define && define.amd ? define(function() {
            return b
        }) : (a.dcodeIO = a.dcodeIO || {}).Long = b
    })(this)
})();
(function(a) {
    function b(a) {
        var b = {
            VERSION: "3.7.0",
            WIRE_TYPES: {}
        };
        b.WIRE_TYPES.VARINT = 0;
        b.WIRE_TYPES.BITS64 = 1;
        b.WIRE_TYPES.LDELIM = 2;
        b.WIRE_TYPES.STARTGROUP = 3;
        b.WIRE_TYPES.ENDGROUP = 4;
        b.WIRE_TYPES.BITS32 = 5;
        b.PACKABLE_WIRE_TYPES = [b.WIRE_TYPES.VARINT, b.WIRE_TYPES.BITS64, b.WIRE_TYPES.BITS32];
        b.TYPES = {
            int32: {
                name: "int32",
                wireType: b.WIRE_TYPES.VARINT
            },
            uint32: {
                name: "uint32",
                wireType: b.WIRE_TYPES.VARINT
            },
            sint32: {
                name: "sint32",
                wireType: b.WIRE_TYPES.VARINT
            },
            int64: {
                name: "int64",
                wireType: b.WIRE_TYPES.VARINT
            },
            uint64: {
                name: "uint64",
                wireType: b.WIRE_TYPES.VARINT
            },
            sint64: {
                name: "sint64",
                wireType: b.WIRE_TYPES.VARINT
            },
            bool: {
                name: "bool",
                wireType: b.WIRE_TYPES.VARINT
            },
            "double": {
                name: "double",
                wireType: b.WIRE_TYPES.BITS64
            },
            string: {
                name: "string",
                wireType: b.WIRE_TYPES.LDELIM
            },
            bytes: {
                name: "bytes",
                wireType: b.WIRE_TYPES.LDELIM
            },
            fixed32: {
                name: "fixed32",
                wireType: b.WIRE_TYPES.BITS32
            },
            sfixed32: {
                name: "sfixed32",
                wireType: b.WIRE_TYPES.BITS32
            },
            fixed64: {
                name: "fixed64",
                wireType: b.WIRE_TYPES.BITS64
            },
            sfixed64: {
                name: "sfixed64",
                wireType: b.WIRE_TYPES.BITS64
            },
            "float": {
                name: "float",
                wireType: b.WIRE_TYPES.BITS32
            },
            "enum": {
                name: "enum",
                wireType: b.WIRE_TYPES.VARINT
            },
            message: {
                name: "message",
                wireType: b.WIRE_TYPES.LDELIM
            },
            group: {
                name: "group",
                wireType: b.WIRE_TYPES.STARTGROUP
            }
        };
        b.ID_MIN = 1;
        b.ID_MAX = 536870911;
        b.ByteBuffer = a;
        b.Long = a.Long || null;
        b.convertFieldsToCamelCase = !1;
        b.populateAccessors = !0;
        b.Util = function() {
            Object.create || (Object.create = function(a) {
                function b() {}
                if (1 < arguments.length) throw Error("Object.create polyfill only accepts the first parameter.");
                b.prototype =
                    a;
                return new b
            });
            var a = {
                IS_NODE: !1
            };
            try {
                a.IS_NODE = "function" === typeof require && "function" === typeof require("fs").readFileSync && "function" === typeof require("path").resolve
            } catch (b) {}
            a.XHR = function() {
                for (var a = [
                    function() {
                        return new XMLHttpRequest
                    },
                    function() {
                        return new ActiveXObject("Msxml2.XMLHTTP")
                    },
                    function() {
                        return new ActiveXObject("Msxml3.XMLHTTP")
                    },
                    function() {
                        return new ActiveXObject("Microsoft.XMLHTTP")
                    }
                ], b = null, c = 0; c < a.length; c++) {
                    try {
                        b = a[c]()
                    } catch (d) {
                        continue
                    }
                    break
                }
                if (!b) throw Error("XMLHttpRequest is not supported");
                return b
            };
            a.fetch = function(b, c) {
                c && "function" != typeof c && (c = null);
                if (a.IS_NODE)
                    if (c) require("fs").readFile(b, function(a, b) {
                        a ? c(null) : c("" + b)
                    });
                    else try {
                        return require("fs").readFileSync(b)
                    } catch (d) {
                        return null
                    } else {
                        var f = a.XHR();
                        f.open("GET", b, c ? !0 : !1);
                        f.setRequestHeader("Accept", "text/plain");
                        "function" === typeof f.overrideMimeType && f.overrideMimeType("text/plain");
                        if (c) f.onreadystatechange = function() {
                            4 == f.readyState && (200 == f.status || 0 == f.status && "string" === typeof f.responseText ? c(f.responseText) :
                                c(null))
                        }, 4 != f.readyState && f.send(null);
                        else return f.send(null), 200 == f.status || 0 == f.status && "string" === typeof f.responseText ? f.responseText : null
                    }
            };
            a.isArray = Array.isArray || function(a) {
                return "[object Array]" === Object.prototype.toString.call(a)
            };
            return a
        }();
        b.Lang = {
            OPEN: "{",
            CLOSE: "}",
            OPTOPEN: "[",
            OPTCLOSE: "]",
            OPTEND: ",",
            EQUAL: "\x3d",
            END: ";",
            STRINGOPEN: '"',
            STRINGCLOSE: '"',
            STRINGOPEN_SQ: "'",
            STRINGCLOSE_SQ: "'",
            COPTOPEN: "(",
            COPTCLOSE: ")",
            DELIM: /[\s\{\}=;\[\],'"\(\)]/g,
            RULE: /^(?:required|optional|repeated)$/,
            TYPE: /^(?:double|float|int32|uint32|sint32|int64|uint64|sint64|fixed32|sfixed32|fixed64|sfixed64|bool|string|bytes)$/,
            NAME: /^[a-zA-Z_][a-zA-Z_0-9]*$/,
            TYPEDEF: /^[a-zA-Z][a-zA-Z_0-9]*$/,
            TYPEREF: /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)+$/,
            FQTYPEREF: /^(?:\.[a-zA-Z][a-zA-Z_0-9]*)+$/,
            NUMBER: /^-?(?:[1-9][0-9]*|0|0x[0-9a-fA-F]+|0[0-7]+|([0-9]*\.[0-9]+([Ee][+-]?[0-9]+)?))$/,
            NUMBER_DEC: /^(?:[1-9][0-9]*|0)$/,
            NUMBER_HEX: /^0x[0-9a-fA-F]+$/,
            NUMBER_OCT: /^0[0-7]+$/,
            NUMBER_FLT: /^[0-9]*\.[0-9]+([Ee][+-]?[0-9]+)?$/,
            ID: /^(?:[1-9][0-9]*|0|0x[0-9a-fA-F]+|0[0-7]+)$/,
            NEGID: /^\-?(?:[1-9][0-9]*|0|0x[0-9a-fA-F]+|0[0-7]+)$/,
            WHITESPACE: /\s/,
            STRING: /['"]([^'"\\]*(\\.[^"\\]*)*)['"]/g,
            BOOL: /^(?:true|false)$/i
        };
        b.DotProto = function(a, b) {
            var c = {},
                d = function(a) {
                    this.source = "" + a;
                    this.index = 0;
                    this.line = 1;
                    this.stack = [];
                    this.readingString = !1;
                    this.stringEndsWith = b.STRINGCLOSE
                },
                k = d.prototype;
            k._readString = function() {
                b.STRING.lastIndex = this.index - 1;
                var a;
                if (null !== (a = b.STRING.exec(this.source))) return a = a[1], this.index = b.STRING.lastIndex, this.stack.push(this.stringEndsWith), a;
                throw Error("Unterminated string at line " +
                    this.line + ", index " + this.index);
            };
            k.next = function() {
                if (0 < this.stack.length) return this.stack.shift();
                if (this.index >= this.source.length) return null;
                if (this.readingString) return this.readingString = !1, this._readString();
                var a, c;
                do {
                    for (a = !1; b.WHITESPACE.test(c = this.source.charAt(this.index));)
                        if (this.index++, "\n" === c && this.line++, this.index === this.source.length) return null;
                    if ("/" === this.source.charAt(this.index))
                        if ("/" === this.source.charAt(++this.index)) {
                            for (;
                                "\n" !== this.source.charAt(this.index);)
                                if (this.index++,
                                    this.index == this.source.length) return null;
                            this.index++;
                            this.line++;
                            a = !0
                        } else if ("*" === this.source.charAt(this.index)) {
                        for (c = "";
                            "*/" !== c + (c = this.source.charAt(this.index));)
                            if (this.index++, "\n" === c && this.line++, this.index === this.source.length) return null;
                        this.index++;
                        a = !0
                    } else throw Error("Unterminated comment at line " + this.line + ": /" + this.source.charAt(this.index));
                } while (a);
                if (this.index === this.source.length) return null;
                a = this.index;
                b.DELIM.lastIndex = 0;
                if (b.DELIM.test(this.source.charAt(a)))++a;
                else
                    for (++a; a < this.source.length && !b.DELIM.test(this.source.charAt(a));) a++;
                a = this.source.substring(this.index, this.index = a);
                a === b.STRINGOPEN ? (this.readingString = !0, this.stringEndsWith = b.STRINGCLOSE) : a === b.STRINGOPEN_SQ && (this.readingString = !0, this.stringEndsWith = b.STRINGCLOSE_SQ);
                return a
            };
            k.peek = function() {
                if (0 === this.stack.length) {
                    var a = this.next();
                    if (null === a) return null;
                    this.stack.push(a)
                }
                return this.stack[0]
            };
            k.toString = function() {
                return "Tokenizer(" + this.index + "/" + this.source.length + " at line " +
                    this.line + ")"
            };
            c.Tokenizer = d;
            var k = function(a) {
                    this.tn = new d(a)
                },
                m = k.prototype;
            m.parse = function() {
                for (var a = {
                    name: "[ROOT]",
                    "package": null,
                    messages: [],
                    enums: [],
                    imports: [],
                    options: {},
                    services: []
                }, b, c = !0; b = this.tn.next();) switch (b) {
                    case "package":
                        if (!c || null !== a["package"]) throw Error("Unexpected package at line " + this.tn.line);
                        a["package"] = this._parsePackage(b);
                        break;
                    case "import":
                        if (!c) throw Error("Unexpected import at line " + this.tn.line);
                        a.imports.push(this._parseImport(b));
                        break;
                    case "message":
                        this._parseMessage(a,
                            null, b);
                        c = !1;
                        break;
                    case "enum":
                        this._parseEnum(a, b);
                        c = !1;
                        break;
                    case "option":
                        if (!c) throw Error("Unexpected option at line " + this.tn.line);
                        this._parseOption(a, b);
                        break;
                    case "service":
                        this._parseService(a, b);
                        break;
                    case "extend":
                        this._parseExtend(a, b);
                        break;
                    case "syntax":
                        this._parseIgnoredStatement(a, b);
                        break;
                    default:
                        throw Error("Unexpected token at line " + this.tn.line + ": " + b);
                }
                delete a.name;
                return a
            };
            m._parseNumber = function(a) {
                var c = 1;
                "-" == a.charAt(0) && (c = -1, a = a.substring(1));
                if (b.NUMBER_DEC.test(a)) return c *
                    parseInt(a, 10);
                if (b.NUMBER_HEX.test(a)) return c * parseInt(a.substring(2), 16);
                if (b.NUMBER_OCT.test(a)) return c * parseInt(a.substring(1), 8);
                if (b.NUMBER_FLT.test(a)) return c * parseFloat(a);
                throw Error("Illegal number at line " + this.tn.line + ": " + (0 > c ? "-" : "") + a);
            };
            m._parseString = function() {
                var a = "",
                    c;
                do {
                    this.tn.next();
                    a += this.tn.next();
                    c = this.tn.next();
                    if (c !== this.tn.stringEndsWith) throw Error("Illegal end of string at line " + this.tn.line + ": " + c);
                    c = this.tn.peek()
                } while (c === b.STRINGOPEN || c === b.STRINGOPEN_SQ);
                return a
            };
            m._parseId = function(a, c) {
                var d = -1,
                    e = 1;
                "-" == a.charAt(0) && (e = -1, a = a.substring(1));
                if (b.NUMBER_DEC.test(a)) d = parseInt(a);
                else if (b.NUMBER_HEX.test(a)) d = parseInt(a.substring(2), 16);
                else if (b.NUMBER_OCT.test(a)) d = parseInt(a.substring(1), 8);
                else throw Error("Illegal id at line " + this.tn.line + ": " + (0 > e ? "-" : "") + a);
                d = e * d | 0;
                if (!c && 0 > d) throw Error("Illegal id at line " + this.tn.line + ": " + (0 > e ? "-" : "") + a);
                return d
            };
            m._parsePackage = function(a) {
                a = this.tn.next();
                if (!b.TYPEREF.test(a)) throw Error("Illegal package name at line " +
                    this.tn.line + ": " + a);
                var c = a;
                a = this.tn.next();
                if (a != b.END) throw Error("Illegal end of package at line " + this.tn.line + ": " + a);
                return c
            };
            m._parseImport = function(a) {
                a = this.tn.peek();
                "public" === a && (this.tn.next(), a = this.tn.peek());
                if (a !== b.STRINGOPEN && a !== b.STRINGOPEN_SQ) throw Error("Illegal start of import at line " + this.tn.line + ": " + a);
                var c = this._parseString();
                a = this.tn.next();
                if (a !== b.END) throw Error("Illegal end of import at line " + this.tn.line + ": " + a);
                return c
            };
            m._parseOption = function(a, c) {
                c = this.tn.next();
                var d = !1;
                c == b.COPTOPEN && (d = !0, c = this.tn.next());
                if (!b.TYPEREF.test(c) && !/google\.protobuf\./.test(c)) throw Error("Illegal option name in message " + a.name + " at line " + this.tn.line + ": " + c);
                var e = c;
                c = this.tn.next();
                if (d) {
                    if (c !== b.COPTCLOSE) throw Error("Illegal end in message " + a.name + ", option " + e + " at line " + this.tn.line + ": " + c);
                    e = "(" + e + ")";
                    c = this.tn.next();
                    b.FQTYPEREF.test(c) && (e += c, c = this.tn.next())
                }
                if (c !== b.EQUAL) throw Error("Illegal operator in message " + a.name + ", option " + e + " at line " + this.tn.line +
                    ": " + c);
                c = this.tn.peek();
                if (c === b.STRINGOPEN || c === b.STRINGOPEN_SQ) d = this._parseString();
                else if (this.tn.next(), b.NUMBER.test(c)) d = this._parseNumber(c, !0);
                else if (b.BOOL.test(c)) d = "true" === c;
                else if (b.TYPEREF.test(c)) d = c;
                else throw Error("Illegal option value in message " + a.name + ", option " + e + " at line " + this.tn.line + ": " + c);
                c = this.tn.next();
                if (c !== b.END) throw Error("Illegal end of option in message " + a.name + ", option " + e + " at line " + this.tn.line + ": " + c);
                a.options[e] = d
            };
            m._parseIgnoredStatement = function(a,
                c) {
                var d;
                do {
                    d = this.tn.next();
                    if (null === d) throw Error("Unexpected EOF in " + a.name + ", " + c + " at line " + this.tn.line);
                    if (d === b.END) break
                } while (1)
            };
            m._parseService = function(a, c) {
                c = this.tn.next();
                if (!b.NAME.test(c)) throw Error("Illegal service name at line " + this.tn.line + ": " + c);
                var d = c,
                    e = {
                        name: d,
                        rpc: {},
                        options: {}
                    };
                c = this.tn.next();
                if (c !== b.OPEN) throw Error("Illegal start of service " + d + " at line " + this.tn.line + ": " + c);
                do
                    if (c = this.tn.next(), "option" === c) this._parseOption(e, c);
                    else if ("rpc" === c) this._parseServiceRPC(e,
                    c);
                else if (c !== b.CLOSE) throw Error("Illegal type of service " + d + " at line " + this.tn.line + ": " + c);
                while (c !== b.CLOSE);
                a.services.push(e)
            };
            m._parseServiceRPC = function(a, c) {
                var d = c;
                c = this.tn.next();
                if (!b.NAME.test(c)) throw Error("Illegal method name in service " + a.name + " at line " + this.tn.line + ": " + c);
                var e = c,
                    g = {
                        request: null,
                        response: null,
                        options: {}
                    };
                c = this.tn.next();
                if (c !== b.COPTOPEN) throw Error("Illegal start of request type in service " + a.name + "#" + e + " at line " + this.tn.line + ": " + c);
                c = this.tn.next();
                if (!b.TYPEREF.test(c)) throw Error("Illegal request type in service " + a.name + "#" + e + " at line " + this.tn.line + ": " + c);
                g.request = c;
                c = this.tn.next();
                if (c != b.COPTCLOSE) throw Error("Illegal end of request type in service " + a.name + "#" + e + " at line " + this.tn.line + ": " + c);
                c = this.tn.next();
                if ("returns" !== c.toLowerCase()) throw Error("Illegal delimiter in service " + a.name + "#" + e + " at line " + this.tn.line + ": " + c);
                c = this.tn.next();
                if (c != b.COPTOPEN) throw Error("Illegal start of response type in service " + a.name + "#" +
                    e + " at line " + this.tn.line + ": " + c);
                c = this.tn.next();
                g.response = c;
                c = this.tn.next();
                if (c !== b.COPTCLOSE) throw Error("Illegal end of response type in service " + a.name + "#" + e + " at line " + this.tn.line + ": " + c);
                c = this.tn.next();
                if (c === b.OPEN) {
                    do
                        if (c = this.tn.next(), "option" === c) this._parseOption(g, c);
                        else if (c !== b.CLOSE) throw Error("Illegal start of option inservice " + a.name + "#" + e + " at line " + this.tn.line + ": " + c); while (c !== b.CLOSE);
                    this.tn.peek() === b.END && this.tn.next()
                } else if (c !== b.END) throw Error("Illegal delimiter in service " +
                    a.name + "#" + e + " at line " + this.tn.line + ": " + c);
                "undefined" === typeof a[d] && (a[d] = {});
                a[d][e] = g
            };
            m._parseMessage = function(a, c, d) {
                var e = {},
                    g = "group" === d;
                d = this.tn.next();
                if (!b.NAME.test(d)) throw Error("Illegal " + (g ? "group" : "message") + " name" + (a ? " in message " + a.name : "") + " at line " + this.tn.line + ": " + d);
                e.name = d;
                if (g) {
                    d = this.tn.next();
                    if (d !== b.EQUAL) throw Error("Illegal id assignment after group " + e.name + " at line " + this.tn.line + ": " + d);
                    d = this.tn.next();
                    try {
                        c.id = this._parseId(d)
                    } catch (h) {
                        throw Error("Illegal field id value for group " +
                            e.name + "#" + c.name + " at line " + this.tn.line + ": " + d);
                    }
                    e.isGroup = !0
                }
                e.fields = [];
                e.enums = [];
                e.messages = [];
                e.options = {};
                e.oneofs = {};
                d = this.tn.next();
                d === b.OPTOPEN && c && (this._parseFieldOptions(e, c, d), d = this.tn.next());
                if (d !== b.OPEN) throw Error("Illegal start of " + (g ? "group" : "message") + " " + e.name + " at line " + this.tn.line + ": " + d);
                do
                    if (d = this.tn.next(), d === b.CLOSE) {
                        d = this.tn.peek();
                        d === b.END && this.tn.next();
                        break
                    } else if (b.RULE.test(d)) this._parseMessageField(e, d);
                else if ("oneof" === d) this._parseMessageOneOf(e,
                    d);
                else if ("enum" === d) this._parseEnum(e, d);
                else if ("message" === d) this._parseMessage(e, null, d);
                else if ("option" === d) this._parseOption(e, d);
                else if ("extensions" === d) e.extensions = this._parseExtensions(e, d);
                else if ("extend" === d) this._parseExtend(e, d);
                else throw Error("Illegal token in message " + e.name + " at line " + this.tn.line + ": " + d);
                while (1);
                a.messages.push(e);
                return e
            };
            m._parseMessageField = function(a, c) {
                var d = {},
                    e = null;
                d.rule = c;
                d.options = {};
                c = this.tn.next();
                if ("group" === c) {
                    e = this._parseMessage(a, d,
                        c);
                    if (!/^[A-Z]/.test(e.name)) throw Error("Group names must start with a capital letter");
                    d.type = e.name;
                    d.name = e.name.toLowerCase();
                    c = this.tn.peek();
                    c === b.END && this.tn.next()
                } else {
                    if (!b.TYPE.test(c) && !b.TYPEREF.test(c)) throw Error("Illegal field type in message " + a.name + " at line " + this.tn.line + ": " + c);
                    d.type = c;
                    c = this.tn.next();
                    if (!b.NAME.test(c)) throw Error("Illegal field name in message " + a.name + " at line " + this.tn.line + ": " + c);
                    d.name = c;
                    c = this.tn.next();
                    if (c !== b.EQUAL) throw Error("Illegal token in field " +
                        a.name + "#" + d.name + " at line " + this.tn.line + ": " + c);
                    c = this.tn.next();
                    try {
                        d.id = this._parseId(c)
                    } catch (g) {
                        throw Error("Illegal field id in message " + a.name + "#" + d.name + " at line " + this.tn.line + ": " + c);
                    }
                    c = this.tn.next();
                    c === b.OPTOPEN && (this._parseFieldOptions(a, d, c), c = this.tn.next());
                    if (c !== b.END) throw Error("Illegal delimiter in message " + a.name + "#" + d.name + " at line " + this.tn.line + ": " + c);
                }
                a.fields.push(d);
                return d
            };
            m._parseMessageOneOf = function(a, c) {
                c = this.tn.next();
                if (!b.NAME.test(c)) throw Error("Illegal oneof name in message " +
                    a.name + " at line " + this.tn.line + ": " + c);
                var d = c,
                    e, g = [];
                c = this.tn.next();
                if (c !== b.OPEN) throw Error("Illegal start of oneof " + d + " at line " + this.tn.line + ": " + c);
                for (; this.tn.peek() !== b.CLOSE;) e = this._parseMessageField(a, "optional"), e.oneof = d, g.push(e.id);
                this.tn.next();
                a.oneofs[d] = g
            };
            m._parseFieldOptions = function(a, c, d) {
                var e = !0;
                do {
                    d = this.tn.next();
                    if (d === b.OPTCLOSE) break;
                    else if (d === b.OPTEND) {
                        if (e) throw Error("Illegal start of options in message " + a.name + "#" + c.name + " at line " + this.tn.line + ": " + d);
                        d = this.tn.next()
                    }
                    this._parseFieldOption(a, c, d);
                    e = !1
                } while (1)
            };
            m._parseFieldOption = function(a, c, d) {
                var e = !1;
                d === b.COPTOPEN && (d = this.tn.next(), e = !0);
                if (!b.TYPEREF.test(d)) throw Error("Illegal field option in " + a.name + "#" + c.name + " at line " + this.tn.line + ": " + d);
                var g = d;
                d = this.tn.next();
                if (e) {
                    if (d !== b.COPTCLOSE) throw Error("Illegal delimiter in " + a.name + "#" + c.name + " at line " + this.tn.line + ": " + d);
                    g = "(" + g + ")";
                    d = this.tn.next();
                    b.FQTYPEREF.test(d) && (g += d, d = this.tn.next())
                }
                if (d !== b.EQUAL) throw Error("Illegal token in " +
                    a.name + "#" + c.name + " at line " + this.tn.line + ": " + d);
                d = this.tn.peek();
                if (d === b.STRINGOPEN || d === b.STRINGOPEN_SQ) a = this._parseString();
                else if (b.NUMBER.test(d, !0)) a = this._parseNumber(this.tn.next(), !0);
                else if (b.BOOL.test(d)) a = "true" === this.tn.next().toLowerCase();
                else if (b.TYPEREF.test(d)) a = this.tn.next();
                else throw Error("Illegal value in message " + a.name + "#" + c.name + ", option " + g + " at line " + this.tn.line + ": " + d);
                c.options[g] = a
            };
            m._parseEnum = function(a, c) {
                var d = {};
                c = this.tn.next();
                if (!b.NAME.test(c)) throw Error("Illegal enum name in message " +
                    a.name + " at line " + this.tn.line + ": " + c);
                d.name = c;
                c = this.tn.next();
                if (c !== b.OPEN) throw Error("Illegal start of enum " + d.name + " at line " + this.tn.line + ": " + c);
                d.values = [];
                d.options = {};
                do {
                    c = this.tn.next();
                    if (c === b.CLOSE) {
                        c = this.tn.peek();
                        c === b.END && this.tn.next();
                        break
                    }
                    if ("option" == c) this._parseOption(d, c);
                    else {
                        if (!b.NAME.test(c)) throw Error("Illegal name in enum " + d.name + " at line " + this.tn.line + ": " + c);
                        this._parseEnumValue(d, c)
                    }
                } while (1);
                a.enums.push(d)
            };
            m._parseEnumValue = function(a, c) {
                var d = {};
                d.name =
                    c;
                c = this.tn.next();
                if (c !== b.EQUAL) throw Error("Illegal token in enum " + a.name + " at line " + this.tn.line + ": " + c);
                c = this.tn.next();
                try {
                    d.id = this._parseId(c, !0)
                } catch (e) {
                    throw Error("Illegal id in enum " + a.name + " at line " + this.tn.line + ": " + c);
                }
                a.values.push(d);
                c = this.tn.next();
                c === b.OPTOPEN && (this._parseFieldOptions(a, {
                    options: {}
                }, c), c = this.tn.next());
                if (c !== b.END) throw Error("Illegal delimiter in enum " + a.name + " at line " + this.tn.line + ": " + c);
            };
            m._parseExtensions = function(c, d) {
                var g = [];
                d = this.tn.next();
                "min" === d ? g.push(a.ID_MIN) : "max" === d ? g.push(a.ID_MAX) : g.push(this._parseNumber(d));
                d = this.tn.next();
                if ("to" !== d) throw Error("Illegal extensions delimiter in message " + c.name + " at line " + this.tn.line + ": " + d);
                d = this.tn.next();
                "min" === d ? g.push(a.ID_MIN) : "max" === d ? g.push(a.ID_MAX) : g.push(this._parseNumber(d));
                d = this.tn.next();
                if (d !== b.END) throw Error("Illegal extensions delimiter in message " + c.name + " at line " + this.tn.line + ": " + d);
                return g
            };
            m._parseExtend = function(a, c) {
                c = this.tn.next();
                if (!b.TYPEREF.test(c)) throw Error("Illegal message name at line " +
                    this.tn.line + ": " + c);
                var d = {};
                d.ref = c;
                d.fields = [];
                c = this.tn.next();
                if (c !== b.OPEN) throw Error("Illegal start of extend " + d.name + " at line " + this.tn.line + ": " + c);
                do
                    if (c = this.tn.next(), c === b.CLOSE) {
                        c = this.tn.peek();
                        c == b.END && this.tn.next();
                        break
                    } else if (b.RULE.test(c)) this._parseMessageField(d, c);
                else throw Error("Illegal token in extend " + d.name + " at line " + this.tn.line + ": " + c);
                while (1);
                a.messages.push(d);
                return d
            };
            m.toString = function() {
                return "Parser"
            };
            c.Parser = k;
            return c
        }(b, b.Lang);
        b.Reflect = function(b) {
            function d(a,
                c) {
                var g = c.readVarint32(),
                    h = g & 7,
                    g = g >> 3;
                switch (h) {
                    case b.WIRE_TYPES.VARINT:
                        do g = c.readUint8(); while (128 === (g & 128));
                        break;
                    case b.WIRE_TYPES.BITS64:
                        c.offset += 8;
                        break;
                    case b.WIRE_TYPES.LDELIM:
                        g = c.readVarint32();
                        c.offset += g;
                        break;
                    case b.WIRE_TYPES.STARTGROUP:
                        d(g, c);
                        break;
                    case b.WIRE_TYPES.ENDGROUP:
                        if (g === a) return !1;
                        throw Error("Illegal GROUPEND after unknown group: " + g + " (" + a + " expected)");
                    case b.WIRE_TYPES.BITS32:
                        c.offset += 4;
                        break;
                    default:
                        throw Error("Illegal wire type in unknown group " + a + ": " + h);
                }
                return !0
            }

            function g(a, c) {
                if (a && "number" === typeof a.low && "number" === typeof a.high && "boolean" === typeof a.unsigned && a.low === a.low && a.high === a.high) return new b.Long(a.low, a.high, "undefined" === typeof c ? a.unsigned : c);
                if ("string" === typeof a) return b.Long.fromString(a, c || !1, 10);
                if ("number" === typeof a) return b.Long.fromNumber(a, c || !1);
                throw Error("not convertible to Long");
            }
            var h = {},
                k = function(a, b, c) {
                    this.builder = a;
                    this.parent = b;
                    this.name = c
                },
                m = k.prototype;
            m.fqn = function() {
                var a = this.name,
                    b = this;
                do {
                    b = b.parent;
                    if (null ==
                        b) break;
                    a = b.name + "." + a
                } while (1);
                return a
            };
            m.toString = function(a) {
                return (a ? this.className + " " : "") + this.fqn()
            };
            m.build = function() {
                throw Error(this.toString(!0) + " cannot be built directly");
            };
            h.T = k;
            var n = function(a, b, c, d) {
                    k.call(this, a, b, c);
                    this.className = "Namespace";
                    this.children = [];
                    this.options = d || {}
                },
                m = n.prototype = Object.create(k.prototype);
            m.getChildren = function(a) {
                a = a || null;
                if (null == a) return this.children.slice();
                for (var b = [], c = 0, d = this.children.length; c < d; ++c) this.children[c] instanceof a && b.push(this.children[c]);
                return b
            };
            m.addChild = function(a) {
                var b;
                if (b = this.getChild(a.name))
                    if (b instanceof q.Field && b.name !== b.originalName && null === this.getChild(b.originalName)) b.name = b.originalName;
                    else if (a instanceof q.Field && a.name !== a.originalName && null === this.getChild(a.originalName)) a.name = a.originalName;
                else throw Error("Duplicate name in namespace " + this.toString(!0) + ": " + a.name);
                this.children.push(a)
            };
            m.getChild = function(a) {
                for (var b = "number" === typeof a ? "id" : "name", c = 0, d = this.children.length; c < d; ++c)
                    if (this.children[c][b] ===
                        a) return this.children[c];
                return null
            };
            m.resolve = function(a, b) {
                var c = a.split("."),
                    d = this,
                    e = 0;
                if ("" === c[e]) {
                    for (; null !== d.parent;) d = d.parent;
                    e++
                }
                do {
                    do {
                        d = d.getChild(c[e]);
                        if (!(d && d instanceof h.T) || b && d instanceof h.Message.Field) {
                            d = null;
                            break
                        }
                        e++
                    } while (e < c.length);
                    if (null != d) break;
                    if (null !== this.parent) return this.parent.resolve(a, b)
                } while (null != d);
                return d
            };
            m.build = function() {
                for (var a = {}, b = this.children, c = 0, d = b.length, e; c < d; ++c) e = b[c], e instanceof n && (a[e.name] = e.build());
                Object.defineProperty &&
                    Object.defineProperty(a, "$options", {
                        value: this.buildOpt()
                    });
                return a
            };
            m.buildOpt = function() {
                for (var a = {}, b = Object.keys(this.options), c = 0, d = b.length; c < d; ++c) a[b[c]] = this.options[b[c]];
                return a
            };
            m.getOption = function(a) {
                return "undefined" === typeof a ? this.options : "undefined" !== typeof this.options[a] ? this.options[a] : null
            };
            h.Namespace = n;
            var q = function(a, c, d, f, g) {
                    n.call(this, a, c, d, f);
                    this.className = "Message";
                    this.extensions = [b.ID_MIN, b.ID_MAX];
                    this.clazz = null;
                    this.isGroup = !!g;
                    this._fieldsByName = this._fieldsById =
                        this._fields = null
                },
                r = q.prototype = Object.create(n.prototype);
            r.build = function(d) {
                if (this.clazz && !d) return this.clazz;
                d = function(b, d) {
                    function e(b, d) {
                        var f = {},
                            g;
                        for (g in b) b.hasOwnProperty(g) && (null === b[g] || "object" !== typeof b[g] ? f[g] = b[g] : b[g] instanceof a ? d && (f[g] = b.toBuffer()) : f[g] = e(b[g], d));
                        return f
                    }
                    var f = d.getChildren(b.Reflect.Message.Field),
                        g = d.getChildren(b.Reflect.Message.OneOf),
                        h = function(d, e) {
                            b.Builder.Message.call(this);
                            for (var h = 0, k = g.length; h < k; ++h) this[g[h].name] = null;
                            h = 0;
                            for (k = f.length; h <
                                k; ++h) {
                                var m = f[h];
                                this[m.name] = m.repeated ? [] : null;
                                m.required && null !== m.defaultValue && (this[m.name] = m.defaultValue)
                            }
                            if (0 < arguments.length)
                                if (1 !== arguments.length || "object" !== typeof d || "function" === typeof d.encode || b.Util.isArray(d) || d instanceof a || d instanceof ArrayBuffer || b.Long && d instanceof b.Long) {
                                    h = 0;
                                    for (k = arguments.length; h < k; ++h) this.$set(f[h].name, arguments[h])
                                } else {
                                    m = Object.keys(d);
                                    h = 0;
                                    for (k = m.length; h < k; ++h) this.$set(m[h], d[m[h]])
                                }
                        },
                        k = h.prototype = Object.create(b.Builder.Message.prototype);
                    k.add = function(a, c, e) {
                        var f = d._fieldsByName[a];
                        if (!e) {
                            if (!f) throw Error(this + "#" + a + " is undefined");
                            if (!(f instanceof b.Reflect.Message.Field)) throw Error(this + "#" + a + " is not a field: " + f.toString(!0));
                            if (!f.repeated) throw Error(this + "#" + a + " is not a repeated field");
                        }
                        null === this[f.name] && (this[f.name] = []);
                        this[f.name].push(e ? c : f.verifyValue(c, !0))
                    };
                    k.$add = k.add;
                    k.set = function(a, c, e) {
                        if (a && "object" === typeof a) {
                            for (var f in a) a.hasOwnProperty(f) && this.$set(f, a[f], e);
                            return this
                        }
                        f = d._fieldsByName[a];
                        if (e) this[f.name] = c;
                        else {
                            if (!f) throw Error(this + "#" + a + " is not a field: undefined");
                            if (!(f instanceof b.Reflect.Message.Field)) throw Error(this + "#" + a + " is not a field: " + f.toString(!0));
                            this[f.name] = c = f.verifyValue(c)
                        }
                        f.oneof && (null !== c ? (null !== this[f.oneof.name] && (this[this[f.oneof.name]] = null), this[f.oneof.name] = f.name) : f.oneof.name === a && (this[f.oneof.name] = null));
                        return this
                    };
                    k.$set = k.set;
                    k.get = function(a, c) {
                        if (c) return this[a];
                        var e = d._fieldsByName[a];
                        if (!(e && e instanceof b.Reflect.Message.Field)) throw Error(this +
                            "#" + a + " is not a field: undefined");
                        if (!(e instanceof b.Reflect.Message.Field)) throw Error(this + "#" + a + " is not a field: " + e.toString(!0));
                        return this[e.name]
                    };
                    k.$get = k.get;
                    for (var m = 0; m < f.length; m++) {
                        var q = f[m];
                        q instanceof b.Reflect.Message.ExtensionField || d.builder.options.populateAccessors && function(a) {
                            var b = a.originalName.replace(/(_[a-zA-Z])/g, function(a) {
                                    return a.toUpperCase().replace("_", "")
                                }),
                                b = b.substring(0, 1).toUpperCase() + b.substring(1),
                                c = a.originalName.replace(/([A-Z])/g, function(a) {
                                    return "_" +
                                        a
                                }),
                                e = function(b, c) {
                                    this[a.name] = c ? b : a.verifyValue(b);
                                    return this
                                },
                                f = function() {
                                    return this[a.name]
                                };
                            null === d.getChild("set" + b) && (k["set" + b] = e);
                            null === d.getChild("set_" + c) && (k["set_" + c] = e);
                            null === d.getChild("get" + b) && (k["get" + b] = f);
                            null === d.getChild("get_" + c) && (k["get_" + c] = f)
                        }(q)
                    }
                    k.encode = function(b, e) {
                        "boolean" === typeof b && (e = b, b = void 0);
                        var f = !1;
                        b || (b = new a, f = !0);
                        var g = b.littleEndian;
                        try {
                            return d.encode(this, b.LE(), e), (f ? b.flip() : b).LE(g)
                        } catch (h) {
                            throw b.LE(g), h;
                        }
                    };
                    k.calculate = function() {
                        return d.calculate(this)
                    };
                    k.encodeDelimited = function(b) {
                        var e = !1;
                        b || (b = new a, e = !0);
                        var f = (new a).LE();
                        d.encode(this, f).flip();
                        b.writeVarint32(f.remaining());
                        b.append(f);
                        return e ? b.flip() : b
                    };
                    k.encodeAB = function() {
                        try {
                            return this.encode().toArrayBuffer()
                        } catch (a) {
                            throw a.encoded && (a.encoded = a.encoded.toArrayBuffer()), a;
                        }
                    };
                    k.toArrayBuffer = k.encodeAB;
                    k.encodeNB = function() {
                        try {
                            return this.encode().toBuffer()
                        } catch (a) {
                            throw a.encoded && (a.encoded = a.encoded.toBuffer()), a;
                        }
                    };
                    k.toBuffer = k.encodeNB;
                    k.encode64 = function() {
                        try {
                            return this.encode().toBase64()
                        } catch (a) {
                            throw a.encoded &&
                                (a.encoded = a.encoded.toBase64()), a;
                        }
                    };
                    k.toBase64 = k.encode64;
                    k.encodeHex = function() {
                        try {
                            return this.encode().toHex()
                        } catch (a) {
                            throw a.encoded && (a.encoded = a.encoded.toHex()), a;
                        }
                    };
                    k.toHex = k.encodeHex;
                    k.toRaw = function(a) {
                        return e(this, !!a)
                    };
                    h.decode = function(b, e) {
                        "string" === typeof b && (b = a.wrap(b, e ? e : "base64"));
                        b = b instanceof a ? b : a.wrap(b);
                        var f = b.littleEndian;
                        try {
                            var g = d.decode(b.LE());
                            b.LE(f);
                            return g
                        } catch (h) {
                            throw b.LE(f), h;
                        }
                    };
                    h.decodeDelimited = function(b, e) {
                        "string" === typeof b && (b = a.wrap(b, e ? e : "base64"));
                        b = b instanceof a ? b : a.wrap(b);
                        if (1 > b.remaining()) return null;
                        var f = b.offset,
                            g = b.readVarint32();
                        if (b.remaining() < g) return b.offset = f, null;
                        try {
                            var h = d.decode(b.slice(b.offset, b.offset + g).LE());
                            b.offset += g;
                            return h
                        } catch (k) {
                            throw b.offset += g, k;
                        }
                    };
                    h.decode64 = function(a) {
                        return h.decode(a, "base64")
                    };
                    h.decodeHex = function(a) {
                        return h.decode(a, "hex")
                    };
                    k.toString = function() {
                        return d.toString()
                    };
                    Object.defineProperty && (Object.defineProperty(h, "$options", {
                        value: d.buildOpt()
                    }), Object.defineProperty(k, "$type", {
                        get: function() {
                            return d
                        }
                    }));
                    return h
                }(b, this);
                this._fields = [];
                this._fieldsById = {};
                this._fieldsByName = {};
                for (var f = 0, g = this.children.length, h; f < g; f++)
                    if (h = this.children[f], h instanceof t) d[h.name] = h.build();
                    else if (h instanceof q) d[h.name] = h.build();
                else if (h instanceof q.Field) h.build(), this._fields.push(h), this._fieldsById[h.id] = h, this._fieldsByName[h.name] = h;
                else if (!(h instanceof q.OneOf || h instanceof u)) throw Error("Illegal reflect child of " + this.toString(!0) + ": " + children[f].toString(!0));
                return this.clazz = d
            };
            r.encode = function(a, b, c) {
                for (var d = null, e, f = 0, g = this._fields.length, h; f < g; ++f) e = this._fields[f], h = a[e.name], e.required && null === h ? null === d && (d = e) : e.encode(c ? h : e.verifyValue(h), b);
                if (null !== d) throw a = Error("Missing at least one required field for " + this.toString(!0) + ": " + d), a.encoded = b, a;
                return b
            };
            r.calculate = function(a) {
                for (var b = 0, c = 0, d = this._fields.length, e, f; c < d; ++c) {
                    e = this._fields[c];
                    f = a[e.name];
                    if (e.required && null === f) throw Error("Missing at least one required field for " +
                        this.toString(!0) + ": " + e);
                    b += e.calculate(f)
                }
                return b
            };
            r.decode = function(a, c, g) {
                c = "number" === typeof c ? c : -1;
                for (var h = a.offset, k = new this.clazz, m, q, n; a.offset < h + c || -1 === c && 0 < a.remaining();) {
                    m = a.readVarint32();
                    q = m & 7;
                    n = m >> 3;
                    if (q === b.WIRE_TYPES.ENDGROUP) {
                        if (n !== g) throw Error("Illegal group end indicator for " + this.toString(!0) + ": " + n + " (" + (g ? g + " expected" : "not a group") + ")");
                        break
                    }
                    if (m = this._fieldsById[n]) m.repeated && !m.options.packed ? k[m.name].push(m.decode(q, a)) : (k[m.name] = m.decode(q, a), m.oneof && (null !==
                        this[m.oneof.name] && (this[this[m.oneof.name]] = null), k[m.oneof.name] = m.name));
                    else switch (q) {
                        case b.WIRE_TYPES.VARINT:
                            a.readVarint32();
                            break;
                        case b.WIRE_TYPES.BITS32:
                            a.offset += 4;
                            break;
                        case b.WIRE_TYPES.BITS64:
                            a.offset += 8;
                            break;
                        case b.WIRE_TYPES.LDELIM:
                            m = a.readVarint32();
                            a.offset += m;
                            break;
                        case b.WIRE_TYPES.STARTGROUP:
                            for (; d(n, a););
                            break;
                        default:
                            throw Error("Illegal wire type for unknown field " + n + " in " + this.toString(!0) + "#decode: " + q);
                    }
                }
                a = 0;
                for (c = this._fields.length; a < c; ++a)
                    if (m = this._fields[a], null ===
                        k[m.name]) {
                        if (m.required) throw a = Error("Missing at least one required field for " + this.toString(!0) + ": " + m.name), a.decoded = k, a;
                        null !== m.defaultValue && (k[m.name] = m.defaultValue)
                    }
                return k
            };
            h.Message = q;
            var s = function(a, b, c, d, e, f, g, h) {
                k.call(this, a, b, e);
                this.className = "Message.Field";
                this.required = "required" === c;
                this.repeated = "repeated" === c;
                this.type = d;
                this.resolvedType = null;
                this.id = f;
                this.options = g || {};
                this.defaultValue = null;
                this.oneof = h || null;
                this.originalName = this.name;
                !this.builder.options.convertFieldsToCamelCase ||
                    this instanceof q.ExtensionField || (this.name = s._toCamelCase(this.name))
            };
            s._toCamelCase = function(a) {
                return a.replace(/_([a-zA-Z])/g, function(a, b) {
                    return b.toUpperCase()
                })
            };
            r = s.prototype = Object.create(k.prototype);
            r.build = function() {
                this.defaultValue = "undefined" !== typeof this.options["default"] ? this.verifyValue(this.options["default"]) : null
            };
            r.verifyValue = function(d, f) {
                f = f || !1;
                var h = function(a, b) {
                    throw Error("Illegal value for " + this.toString(!0) + " of type " + this.type.name + ": " + a + " (" + b + ")");
                }.bind(this);
                if (null === d) return this.required && h(typeof d, "required"), null;
                var k;
                if (this.repeated && !f) {
                    b.Util.isArray(d) || (d = [d]);
                    h = [];
                    for (k = 0; k < d.length; k++) h.push(this.verifyValue(d[k], !0));
                    return h
                }!this.repeated && b.Util.isArray(d) && h(typeof d, "no array expected");
                switch (this.type) {
                    case b.TYPES.int32:
                    case b.TYPES.sint32:
                    case b.TYPES.sfixed32:
                        return ("number" !== typeof d || d === d && 0 !== d % 1) && h(typeof d, "not an integer"), 4294967295 < d ? d | 0 : d;
                    case b.TYPES.uint32:
                    case b.TYPES.fixed32:
                        return ("number" !== typeof d || d === d &&
                            0 !== d % 1) && h(typeof d, "not an integer"), 0 > d ? d >>> 0 : d;
                    case b.TYPES.int64:
                    case b.TYPES.sint64:
                    case b.TYPES.sfixed64:
                        if (b.Long) try {
                            return g(d, !1)
                        } catch (m) {
                            h(typeof d, m.message)
                        } else h(typeof d, "requires Long.js");
                    case b.TYPES.uint64:
                    case b.TYPES.fixed64:
                        if (b.Long) try {
                            return g(d, !0)
                        } catch (q) {
                            h(typeof d, q.message)
                        } else h(typeof d, "requires Long.js");
                    case b.TYPES.bool:
                        return "boolean" !== typeof d && h(typeof d, "not a boolean"), d;
                    case b.TYPES["float"]:
                    case b.TYPES["double"]:
                        return "number" !== typeof d && h(typeof d,
                            "not a number"), d;
                    case b.TYPES.string:
                        return "string" === typeof d || d && d instanceof String || h(typeof d, "not a string"), "" + d;
                    case b.TYPES.bytes:
                        return d && d instanceof a ? d : a.wrap(d);
                    case b.TYPES["enum"]:
                        var n = this.resolvedType.getChildren(t.Value);
                        for (k = 0; k < n.length; k++)
                            if (n[k].name == d || n[k].id == d) return n[k].id;
                        h(d, "not a valid enum value");
                    case b.TYPES.group:
                    case b.TYPES.message:
                        d && "object" === typeof d || h(typeof d, "object expected");
                        if (d instanceof this.resolvedType.clazz) return d;
                        if (d instanceof b.Builder.Message) {
                            h = {};
                            for (k in d) d.hasOwnProperty(k) && (h[k] = d[k]);
                            d = h
                        }
                        return new this.resolvedType.clazz(d)
                }
                throw Error("[INTERNAL] Illegal value for " + this.toString(!0) + ": " + d + " (undefined type " + this.type + ")");
            };
            r.encode = function(d, f) {
                if (null === this.type || "object" !== typeof this.type) throw Error("[INTERNAL] Unresolved type in " + this.toString(!0) + ": " + this.type);
                if (null === d || this.repeated && 0 == d.length) return f;
                try {
                    if (this.repeated) {
                        var g;
                        if (this.options.packed && 0 <= b.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType)) {
                            f.writeVarint32(this.id <<
                                3 | b.WIRE_TYPES.LDELIM);
                            f.ensureCapacity(f.offset += 1);
                            var h = f.offset;
                            for (g = 0; g < d.length; g++) this.encodeValue(d[g], f);
                            var k = f.offset - h,
                                m = a.calculateVarint32(k);
                            if (1 < m) {
                                var q = f.slice(h, f.offset),
                                    h = h + (m - 1);
                                f.offset = h;
                                f.append(q)
                            }
                            f.writeVarint32(k, h - m)
                        } else
                            for (g = 0; g < d.length; g++) f.writeVarint32(this.id << 3 | this.type.wireType), this.encodeValue(d[g], f)
                    } else f.writeVarint32(this.id << 3 | this.type.wireType), this.encodeValue(d, f)
                } catch (n) {
                    throw Error("Illegal value for " + this.toString(!0) + ": " + d + " (" + n + ")");
                }
                return f
            };
            r.encodeValue = function(d, f) {
                if (null === d) return f;
                switch (this.type) {
                    case b.TYPES.int32:
                        0 > d ? f.writeVarint64(d) : f.writeVarint32(d);
                        break;
                    case b.TYPES.uint32:
                        f.writeVarint32(d);
                        break;
                    case b.TYPES.sint32:
                        f.writeVarint32ZigZag(d);
                        break;
                    case b.TYPES.fixed32:
                        f.writeUint32(d);
                        break;
                    case b.TYPES.sfixed32:
                        f.writeInt32(d);
                        break;
                    case b.TYPES.int64:
                    case b.TYPES.uint64:
                        f.writeVarint64(d);
                        break;
                    case b.TYPES.sint64:
                        f.writeVarint64ZigZag(d);
                        break;
                    case b.TYPES.fixed64:
                        f.writeUint64(d);
                        break;
                    case b.TYPES.sfixed64:
                        f.writeInt64(d);
                        break;
                    case b.TYPES.bool:
                        "string" === typeof d ? f.writeVarint32("false" === d.toLowerCase() ? 0 : !!d) : f.writeVarint32(d ? 1 : 0);
                        break;
                    case b.TYPES["enum"]:
                        f.writeVarint32(d);
                        break;
                    case b.TYPES["float"]:
                        f.writeFloat32(d);
                        break;
                    case b.TYPES["double"]:
                        f.writeFloat64(d);
                        break;
                    case b.TYPES.string:
                        f.writeVString(d);
                        break;
                    case b.TYPES.bytes:
                        if (0 > d.remaining()) throw Error("Illegal value for " + this.toString(!0) + ": " + d.remaining() + " bytes remaining");
                        var g = d.offset;
                        f.writeVarint32(d.remaining());
                        f.append(d);
                        d.offset = g;
                        break;
                    case b.TYPES.message:
                        g = (new a).LE();
                        this.resolvedType.encode(d, g);
                        f.writeVarint32(g.offset);
                        f.append(g.flip());
                        break;
                    case b.TYPES.group:
                        this.resolvedType.encode(d, f);
                        f.writeVarint32(this.id << 3 | b.WIRE_TYPES.ENDGROUP);
                        break;
                    default:
                        throw Error("[INTERNAL] Illegal value to encode in " + this.toString(!0) + ": " + d + " (unknown type)");
                }
                return f
            };
            r.calculate = function(d) {
                d = this.verifyValue(d);
                if (null === this.type || "object" !== typeof this.type) throw Error("[INTERNAL] Unresolved type in " + this.toString(!0) +
                    ": " + this.type);
                if (null === d || this.repeated && 0 == d.length) return 0;
                var f = 0;
                try {
                    if (this.repeated) {
                        var g, h;
                        if (this.options.packed && 0 <= b.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType)) {
                            f += a.calculateVarint32(this.id << 3 | b.WIRE_TYPES.LDELIM);
                            for (g = h = 0; g < d.length; g++) h += this.calculateValue(d[g]);
                            f += a.calculateVarint32(h);
                            f += h
                        } else
                            for (g = 0; g < d.length; g++) f += a.calculateVarint32(this.id << 3 | this.type.wireType), f += this.calculateValue(d[g])
                    } else f += a.calculateVarint32(this.id << 3 | this.type.wireType), f += this.calculateValue(d)
                } catch (k) {
                    throw Error("Illegal value for " +
                        this.toString(!0) + ": " + d + " (" + k + ")");
                }
                return f
            };
            r.calculateValue = function(d) {
                if (null === d) return 0;
                switch (this.type) {
                    case b.TYPES.int32:
                        return 0 > d ? a.calculateVarint64(d) : a.calculateVarint32(d);
                    case b.TYPES.uint32:
                        return a.calculateVarint32(d);
                    case b.TYPES.sint32:
                        return a.calculateVarint32(a.zigZagEncode32(d));
                    case b.TYPES.fixed32:
                    case b.TYPES.sfixed32:
                    case b.TYPES["float"]:
                        return 4;
                    case b.TYPES.int64:
                    case b.TYPES.uint64:
                        return a.calculateVarint64(d);
                    case b.TYPES.sint64:
                        return a.calculateVarint64(a.zigZagEncode64(d));
                    case b.TYPES.fixed64:
                    case b.TYPES.sfixed64:
                        return 8;
                    case b.TYPES.bool:
                        return 1;
                    case b.TYPES["enum"]:
                        return a.calculateVarint32(d);
                    case b.TYPES["double"]:
                        return 8;
                    case b.TYPES.string:
                        return d = a.calculateUTF8Bytes(d), a.calculateVarint32(d) + d;
                    case b.TYPES.bytes:
                        if (0 > d.remaining()) throw Error("Illegal value for " + this.toString(!0) + ": " + d.remaining() + " bytes remaining");
                        return a.calculateVarint32(d.remaining()) + d.remaining();
                    case b.TYPES.message:
                        return d = this.resolvedType.calculate(d), a.calculateVarint32(d) +
                            d;
                    case b.TYPES.group:
                        return d = this.resolvedType.calculate(d), d + a.calculateVarint32(this.id << 3 | b.WIRE_TYPES.ENDGROUP)
                }
                throw Error("[INTERNAL] Illegal value to encode in " + this.toString(!0) + ": " + d + " (unknown type)");
            };
            r.decode = function(a, c, d) {
                if (a != this.type.wireType && (d || a != b.WIRE_TYPES.LDELIM || !this.repeated)) throw Error("Illegal wire type for field " + this.toString(!0) + ": " + a + " (" + this.type.wireType + " expected)");
                if (a == b.WIRE_TYPES.LDELIM && this.repeated && this.options.packed && 0 <= b.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) &&
                    !d) {
                    a = c.readVarint32();
                    a = c.offset + a;
                    for (d = []; c.offset < a;) d.push(this.decode(this.type.wireType, c, !0));
                    return d
                }
                switch (this.type) {
                    case b.TYPES.int32:
                        return c.readVarint32() | 0;
                    case b.TYPES.uint32:
                        return c.readVarint32() >>> 0;
                    case b.TYPES.sint32:
                        return c.readVarint32ZigZag() | 0;
                    case b.TYPES.fixed32:
                        return c.readUint32() >>> 0;
                    case b.TYPES.sfixed32:
                        return c.readInt32() | 0;
                    case b.TYPES.int64:
                        return c.readVarint64();
                    case b.TYPES.uint64:
                        return c.readVarint64().toUnsigned();
                    case b.TYPES.sint64:
                        return c.readVarint64ZigZag();
                    case b.TYPES.fixed64:
                        return c.readUint64();
                    case b.TYPES.sfixed64:
                        return c.readInt64();
                    case b.TYPES.bool:
                        return !!c.readVarint32();
                    case b.TYPES["enum"]:
                        return c.readVarint32();
                    case b.TYPES["float"]:
                        return c.readFloat();
                    case b.TYPES["double"]:
                        return c.readDouble();
                    case b.TYPES.string:
                        return c.readVString();
                    case b.TYPES.bytes:
                        a = c.readVarint32();
                        if (c.remaining() < a) throw Error("Illegal number of bytes for " + this.toString(!0) + ": " + a + " required but got only " + c.remaining());
                        d = c.clone();
                        d.limit = d.offset + a;
                        c.offset += a;
                        return d;
                    case b.TYPES.message:
                        return a = c.readVarint32(), this.resolvedType.decode(c, a);
                    case b.TYPES.group:
                        return this.resolvedType.decode(c, -1, this.id)
                }
                throw Error("[INTERNAL] Illegal wire type for " + this.toString(!0) + ": " + a);
            };
            h.Message.Field = s;
            r = function(a, b, c, d, e, f, g) {
                s.call(this, a, b, c, d, e, f, g)
            };
            r.prototype = Object.create(s.prototype);
            h.Message.ExtensionField = r;
            h.Message.OneOf = function(a, b, c) {
                k.call(this, a, b, c);
                this.fields = []
            };
            var t = function(a, b, c, d) {
                n.call(this, a, b, c, d);
                this.className =
                    "Enum";
                this.object = null
            };
            (t.prototype = Object.create(n.prototype)).build = function() {
                for (var a = {}, b = this.getChildren(t.Value), c = 0, d = b.length; c < d; ++c) a[b[c].name] = b[c].id;
                Object.defineProperty && Object.defineProperty(a, "$options", {
                    value: this.buildOpt()
                });
                return this.object = a
            };
            h.Enum = t;
            r = function(a, b, c, d) {
                k.call(this, a, b, c);
                this.className = "Enum.Value";
                this.id = d
            };
            r.prototype = Object.create(k.prototype);
            h.Enum.Value = r;
            var u = function(a, b, c, d) {
                k.call(this, a, b, c);
                this.field = d
            };
            u.prototype = Object.create(k.prototype);
            h.Extension = u;
            r = function(a, b, c, d) {
                n.call(this, a, b, c, d);
                this.className = "Service";
                this.clazz = null
            };
            (r.prototype = Object.create(n.prototype)).build = function(a) {
                return this.clazz && !a ? this.clazz : this.clazz = function(a, b) {
                    var c = function(b) {
                            a.Builder.Service.call(this);
                            this.rpcImpl = b || function(a, b, c) {
                                setTimeout(c.bind(this, Error("Not implemented, see: https://github.com/dcodeIO/ProtoBuf.js/wiki/Services")), 0)
                            }
                        },
                        d = c.prototype = Object.create(a.Builder.Service.prototype);
                    Object.defineProperty && (Object.defineProperty(c,
                        "$options", {
                            value: b.buildOpt()
                        }), Object.defineProperty(d, "$options", {
                        value: c.$options
                    }));
                    for (var e = b.getChildren(a.Reflect.Service.RPCMethod), f = 0; f < e.length; f++)(function(a) {
                        d[a.name] = function(c, d) {
                            try {
                                c && c instanceof a.resolvedRequestType.clazz ? this.rpcImpl(a.fqn(), c, function(c, e) {
                                    if (c) d(c);
                                    else {
                                        try {
                                            e = a.resolvedResponseType.clazz.decode(e)
                                        } catch (f) {}
                                        e && e instanceof a.resolvedResponseType.clazz ? d(null, e) : d(Error("Illegal response type received in service method " + b.name + "#" + a.name))
                                    }
                                }) : setTimeout(d.bind(this,
                                    Error("Illegal request type provided to service method " + b.name + "#" + a.name)), 0)
                            } catch (e) {
                                setTimeout(d.bind(this, e), 0)
                            }
                        };
                        c[a.name] = function(b, d, e) {
                            (new c(b))[a.name](d, e)
                        };
                        Object.defineProperty && (Object.defineProperty(c[a.name], "$options", {
                            value: a.buildOpt()
                        }), Object.defineProperty(d[a.name], "$options", {
                            value: c[a.name].$options
                        }))
                    })(e[f]);
                    return c
                }(b, this)
            };
            h.Service = r;
            var w = function(a, b, c, d) {
                k.call(this, a, b, c);
                this.className = "Service.Method";
                this.options = d || {}
            };
            (w.prototype = Object.create(k.prototype)).buildOpt =
                m.buildOpt;
            h.Service.Method = w;
            m = function(a, b, c, d, e, f) {
                w.call(this, a, b, c, f);
                this.className = "Service.RPCMethod";
                this.requestName = d;
                this.responseName = e;
                this.resolvedResponseType = this.resolvedRequestType = null
            };
            m.prototype = Object.create(w.prototype);
            h.Service.RPCMethod = m;
            return h
        }(b);
        b.Builder = function(a, b, c) {
            var d = function(a) {
                    this.ptr = this.ns = new c.Namespace(this, null, "");
                    this.resolved = !1;
                    this.result = null;
                    this.files = {};
                    this.importRoot = null;
                    this.options = a || {}
                },
                k = d.prototype;
            k.reset = function() {
                this.ptr =
                    this.ns
            };
            k.define = function(a, d) {
                if ("string" !== typeof a || !b.TYPEREF.test(a)) throw Error("Illegal package: " + a);
                var e = a.split("."),
                    h;
                for (h = 0; h < e.length; h++)
                    if (!b.NAME.test(e[h])) throw Error("Illegal package: " + e[h]);
                for (h = 0; h < e.length; h++) null === this.ptr.getChild(e[h]) && this.ptr.addChild(new c.Namespace(this, this.ptr, e[h], d)), this.ptr = this.ptr.getChild(e[h]);
                return this
            };
            d.isValidMessage = function(c) {
                if ("string" !== typeof c.name || !b.NAME.test(c.name) || "undefined" !== typeof c.values || "undefined" !== typeof c.rpc) return !1;
                var g;
                if ("undefined" !== typeof c.fields) {
                    if (!a.Util.isArray(c.fields)) return !1;
                    var k = [],
                        r;
                    for (g = 0; g < c.fields.length; g++) {
                        if (!d.isValidMessageField(c.fields[g])) return !1;
                        r = parseInt(c.fields[g].id, 10);
                        if (0 <= k.indexOf(r)) return !1;
                        k.push(r)
                    }
                }
                if ("undefined" !== typeof c.enums) {
                    if (!a.Util.isArray(c.enums)) return !1;
                    for (g = 0; g < c.enums.length; g++)
                        if (!d.isValidEnum(c.enums[g])) return !1
                }
                if ("undefined" !== typeof c.messages) {
                    if (!a.Util.isArray(c.messages)) return !1;
                    for (g = 0; g < c.messages.length; g++)
                        if (!d.isValidMessage(c.messages[g]) &&
                            !d.isValidExtend(c.messages[g])) return !1
                }
                return "undefined" === typeof c.extensions || a.Util.isArray(c.extensions) && 2 === c.extensions.length && "number" === typeof c.extensions[0] && "number" === typeof c.extensions[1] ? !0 : !1
            };
            d.isValidMessageField = function(a) {
                if ("string" !== typeof a.rule || "string" !== typeof a.name || "string" !== typeof a.type || "undefined" === typeof a.id || !b.RULE.test(a.rule) || !b.NAME.test(a.name) || !b.TYPEREF.test(a.type) || !b.ID.test("" + a.id)) return !1;
                if ("undefined" !== typeof a.options) {
                    if ("object" !==
                        typeof a.options) return !1;
                    for (var c = Object.keys(a.options), d = 0, e; d < c.length; d++)
                        if ("string" !== typeof(e = c[d]) || "string" !== typeof a.options[e] && "number" !== typeof a.options[e] && "boolean" !== typeof a.options[e]) return !1
                }
                return !0
            };
            d.isValidEnum = function(c) {
                if ("string" !== typeof c.name || !b.NAME.test(c.name) || "undefined" === typeof c.values || !a.Util.isArray(c.values) || 0 == c.values.length) return !1;
                for (var d = 0; d < c.values.length; d++)
                    if ("object" != typeof c.values[d] || "string" !== typeof c.values[d].name || "undefined" ===
                        typeof c.values[d].id || !b.NAME.test(c.values[d].name) || !b.NEGID.test("" + c.values[d].id)) return !1;
                return !0
            };
            k.create = function(b) {
                if (!b) return this;
                a.Util.isArray(b) || (b = [b]);
                if (0 == b.length) return this;
                var f = [];
                for (f.push(b); 0 < f.length;) {
                    b = f.pop();
                    if (a.Util.isArray(b))
                        for (; 0 < b.length;) {
                            var k = b.shift();
                            if (d.isValidMessage(k)) {
                                var r = new c.Message(this, this.ptr, k.name, k.options, k.isGroup),
                                    s = {};
                                if (k.oneofs)
                                    for (var t = Object.keys(k.oneofs), u = 0, w = t.length; u < w; ++u) r.addChild(s[t[u]] = new c.Message.OneOf(this,
                                        r, t[u]));
                                if (k.fields && 0 < k.fields.length) {
                                    u = 0;
                                    for (w = k.fields.length; u < w; ++u) {
                                        t = k.fields[u];
                                        if (null !== r.getChild(t.id)) throw Error("Duplicate field id in message " + r.name + ": " + t.id);
                                        if (t.options)
                                            for (var v = Object.keys(t.options), y = 0, D = v.length; y < D; ++y) {
                                                if ("string" !== typeof v[y]) throw Error("Illegal field option name in message " + r.name + "#" + t.name + ": " + v[y]);
                                                if ("string" !== typeof t.options[v[y]] && "number" !== typeof t.options[v[y]] && "boolean" !== typeof t.options[v[y]]) throw Error("Illegal field option value in message " +
                                                    r.name + "#" + t.name + "#" + v[y] + ": " + t.options[v[y]]);
                                            }
                                        v = null;
                                        if ("string" === typeof t.oneof && (v = s[t.oneof], "undefined" === typeof v)) throw Error("Illegal oneof in message " + r.name + "#" + t.name + ": " + t.oneof);
                                        t = new c.Message.Field(this, r, t.rule, t.type, t.name, t.id, t.options, v);
                                        v && v.fields.push(t);
                                        r.addChild(t)
                                    }
                                }
                                s = [];
                                if ("undefined" !== typeof k.enums && 0 < k.enums.length)
                                    for (u = 0; u < k.enums.length; u++) s.push(k.enums[u]);
                                if (k.messages && 0 < k.messages.length)
                                    for (u = 0; u < k.messages.length; u++) s.push(k.messages[u]);
                                k.extensions &&
                                    (r.extensions = k.extensions, r.extensions[0] < a.ID_MIN && (r.extensions[0] = a.ID_MIN), r.extensions[1] > a.ID_MAX && (r.extensions[1] = a.ID_MAX));
                                this.ptr.addChild(r);
                                0 < s.length && (f.push(b), b = s, this.ptr = r)
                            } else if (d.isValidEnum(k)) {
                                r = new c.Enum(this, this.ptr, k.name, k.options);
                                for (u = 0; u < k.values.length; u++) r.addChild(new c.Enum.Value(this, r, k.values[u].name, k.values[u].id));
                                this.ptr.addChild(r)
                            } else if (d.isValidService(k)) {
                                r = new c.Service(this, this.ptr, k.name, k.options);
                                for (u in k.rpc) k.rpc.hasOwnProperty(u) &&
                                    r.addChild(new c.Service.RPCMethod(this, r, u, k.rpc[u].request, k.rpc[u].response, k.rpc[u].options));
                                this.ptr.addChild(r)
                            } else if (d.isValidExtend(k))
                                if (r = this.ptr.resolve(k.ref))
                                    for (u = 0; u < k.fields.length; u++) {
                                        if (null !== r.getChild(k.fields[u].id)) throw Error("Duplicate extended field id in message " + r.name + ": " + k.fields[u].id);
                                        if (k.fields[u].id < r.extensions[0] || k.fields[u].id > r.extensions[1]) throw Error("Illegal extended field id in message " + r.name + ": " + k.fields[u].id + " (" + r.extensions.join(" to ") +
                                            " expected)");
                                        s = k.fields[u].name;
                                        this.options.convertFieldsToCamelCase && (s = c.Message.Field._toCamelCase(k.fields[u].name));
                                        t = new c.Message.ExtensionField(this, r, k.fields[u].rule, k.fields[u].type, this.ptr.fqn() + "." + s, k.fields[u].id, k.fields[u].options);
                                        s = new c.Extension(this, this.ptr, k.fields[u].name, t);
                                        t.extension = s;
                                        this.ptr.addChild(s);
                                        r.addChild(t)
                                    } else {
                                        if (!/\.?google\.protobuf\./.test(k.ref)) throw Error("Extended message " + k.ref + " is not defined");
                                    } else throw Error("Not a valid definition: " + JSON.stringify(k));
                        } else throw Error("Not a valid namespace: " + JSON.stringify(b));
                    this.ptr = this.ptr.parent
                }
                this.resolved = !1;
                this.result = null;
                return this
            };
            k["import"] = function(b, c) {
                if ("string" === typeof c) {
                    a.Util.IS_NODE && (c = require("path").resolve(c));
                    if (!0 === this.files[c]) return this.reset(), this;
                    this.files[c] = !0
                }
                if (b.imports && 0 < b.imports.length) {
                    var d, f = "/",
                        g = !1;
                    if ("object" === typeof c) {
                        if (this.importRoot = c.root, g = !0, d = this.importRoot, c = c.file, 0 <= d.indexOf("\\") || 0 <= c.indexOf("\\")) f = "\\"
                    } else "string" === typeof c ? this.importRoot ?
                        d = this.importRoot : 0 <= c.indexOf("/") ? (d = c.replace(/\/[^\/]*$/, ""), "" === d && (d = "/")) : 0 <= c.indexOf("\\") ? (d = c.replace(/\\[^\\]*$/, ""), f = "\\") : d = "." : d = null;
                    for (var h = 0; h < b.imports.length; h++)
                        if ("string" === typeof b.imports[h]) {
                            if (!d) throw Error("Cannot determine import root: File name is unknown");
                            var k = b.imports[h];
                            if (!/^google\/protobuf\//.test(k) && (k = d + f + k, !0 !== this.files[k])) {
                                /\.proto$/i.test(k) && !a.DotProto && (k = k.replace(/\.proto$/, ".json"));
                                var w = a.Util.fetch(k);
                                if (null === w) throw Error("Failed to import '" +
                                    k + "' in '" + c + "': File not found");
                                if (/\.json$/i.test(k)) this["import"](JSON.parse(w + ""), k);
                                else this["import"]((new a.DotProto.Parser(w + "")).parse(), k)
                            }
                        } else if (c)
                        if (/\.(\w+)$/.test(c)) this["import"](b.imports[h], c.replace(/^(.+)\.(\w+)$/, function(a, b, c) {
                            return b + "_import" + h + "." + c
                        }));
                        else this["import"](b.imports[h], c + "_import" + h);
                    else this["import"](b.imports[h]);
                    g && (this.importRoot = null)
                }
                b.messages && (b["package"] && this.define(b["package"], b.options), this.create(b.messages), this.reset());
                b.enums &&
                    (b["package"] && this.define(b["package"], b.options), this.create(b.enums), this.reset());
                b.services && (b["package"] && this.define(b["package"], b.options), this.create(b.services), this.reset());
                b["extends"] && (b["package"] && this.define(b["package"], b.options), this.create(b["extends"]), this.reset());
                return this
            };
            d.isValidService = function(a) {
                return !("string" !== typeof a.name || !b.NAME.test(a.name) || "object" !== typeof a.rpc)
            };
            d.isValidExtend = function(c) {
                if ("string" !== typeof c.ref || !b.TYPEREF.test(c.ref)) return !1;
                var g;
                if ("undefined" !== typeof c.fields) {
                    if (!a.Util.isArray(c.fields)) return !1;
                    var k = [],
                        r;
                    for (g = 0; g < c.fields.length; g++) {
                        if (!d.isValidMessageField(c.fields[g])) return !1;
                        r = parseInt(c.id, 10);
                        if (0 <= k.indexOf(r)) return !1;
                        k.push(r)
                    }
                }
                return !0
            };
            k.resolveAll = function() {
                var d;
                if (null != this.ptr && "object" !== typeof this.ptr.type) {
                    if (this.ptr instanceof c.Namespace) {
                        d = this.ptr.children;
                        for (var h = 0, k = d.length; h < k; ++h) this.ptr = d[h], this.resolveAll()
                    } else if (this.ptr instanceof c.Message.Field)
                        if (b.TYPE.test(this.ptr.type)) this.ptr.type =
                            a.TYPES[this.ptr.type];
                        else {
                            if (!b.TYPEREF.test(this.ptr.type)) throw Error("Illegal type reference in " + this.ptr.toString(!0) + ": " + this.ptr.type);
                            d = (this.ptr instanceof c.Message.ExtensionField ? this.ptr.extension.parent : this.ptr.parent).resolve(this.ptr.type, !0);
                            if (!d) throw Error("Unresolvable type reference in " + this.ptr.toString(!0) + ": " + this.ptr.type);
                            this.ptr.resolvedType = d;
                            if (d instanceof c.Enum) this.ptr.type = a.TYPES["enum"];
                            else if (d instanceof c.Message) this.ptr.type = d.isGroup ? a.TYPES.group :
                                a.TYPES.message;
                            else throw Error("Illegal type reference in " + this.ptr.toString(!0) + ": " + this.ptr.type);
                        } else if (!(this.ptr instanceof a.Reflect.Enum.Value))
                        if (this.ptr instanceof a.Reflect.Service.Method)
                            if (this.ptr instanceof a.Reflect.Service.RPCMethod) {
                                d = this.ptr.parent.resolve(this.ptr.requestName);
                                if (!(d && d instanceof a.Reflect.Message)) throw Error("Illegal type reference in " + this.ptr.toString(!0) + ": " + this.ptr.requestName);
                                this.ptr.resolvedRequestType = d;
                                d = this.ptr.parent.resolve(this.ptr.responseName);
                                if (!(d && d instanceof a.Reflect.Message)) throw Error("Illegal type reference in " + this.ptr.toString(!0) + ": " + this.ptr.responseName);
                                this.ptr.resolvedResponseType = d
                            } else throw Error("Illegal service type in " + this.ptr.toString(!0));
                    else if (!(this.ptr instanceof a.Reflect.Message.OneOf || this.ptr instanceof a.Reflect.Extension)) throw Error("Illegal object in namespace: " + typeof this.ptr + ":" + this.ptr);
                    this.reset()
                }
            };
            k.build = function(a) {
                this.reset();
                this.resolved || (this.resolveAll(), this.resolved = !0, this.result =
                    null);
                null == this.result && (this.result = this.ns.build());
                if (a) {
                    a = a.split(".");
                    for (var b = this.result, c = 0; c < a.length; c++)
                        if (b[a[c]]) b = b[a[c]];
                        else {
                            b = null;
                            break
                        }
                    return b
                }
                return this.result
            };
            k.lookup = function(a) {
                return a ? this.ns.resolve(a) : this.ns
            };
            k.toString = function() {
                return "Builder"
            };
            d.Message = function() {};
            d.Service = function() {};
            return d
        }(b, b.Lang, b.Reflect);
        b.loadProto = function(a, c, g) {
            if ("string" === typeof c || c && "string" === typeof c.file && "string" === typeof c.root) g = c, c = void 0;
            return b.loadJson((new b.DotProto.Parser(a)).parse(),
                c, g)
        };
        b.protoFromString = b.loadProto;
        b.loadProtoFile = function(a, c, g) {
            c && "object" === typeof c ? (g = c, c = null) : c && "function" === typeof c || (c = null);
            if (c) return b.Util.fetch("string" === typeof a ? a : a.root + "/" + a.file, function(h) {
                if (null === h) c(Error("Failed to fetch file"));
                else try {
                    c(null, b.loadProto(h, g, a))
                } catch (m) {
                    c(m)
                }
            });
            var h = b.Util.fetch("object" === typeof a ? a.root + "/" + a.file : a);
            return null === h ? null : b.loadProto(h, g, a)
        };
        b.protoFromFile = b.loadProtoFile;
        b.newBuilder = function(a) {
            a = a || {};
            "undefined" === typeof a.convertFieldsToCamelCase &&
                (a.convertFieldsToCamelCase = b.convertFieldsToCamelCase);
            "undefined" === typeof a.populateAccessors && (a.populateAccessors = b.populateAccessors);
            return new b.Builder(a)
        };
        b.loadJson = function(a, c, g) {
            if ("string" === typeof c || c && "string" === typeof c.file && "string" === typeof c.root) g = c, c = null;
            c && "object" === typeof c || (c = b.newBuilder());
            "string" === typeof a && (a = JSON.parse(a));
            c["import"](a, g);
            c.resolveAll();
            c.build();
            return c
        };
        b.loadJsonFile = function(a, c, g) {
            c && "object" === typeof c ? (g = c, c = null) : c && "function" === typeof c ||
                (c = null);
            if (c) return b.Util.fetch("string" === typeof a ? a : a.root + "/" + a.file, function(h) {
                if (null === h) c(Error("Failed to fetch file"));
                else try {
                    c(null, b.loadJson(JSON.parse(h), g, a))
                } catch (m) {
                    c(m)
                }
            });
            var h = b.Util.fetch("object" === typeof a ? a.root + "/" + a.file : a);
            return null === h ? null : b.loadJson(JSON.parse(h), g, a)
        };
        return b
    }
    "undefined" !== typeof module && module.exports ? module.exports = b(require("bytebuffer")) : "function" === typeof define && define.amd ? define(["ByteBuffer"], b) : (a.dcodeIO = a.dcodeIO || {}).ProtoBuf = b(a.dcodeIO.ByteBuffer)
})(this);
var CSParseBinary = "\npackage protocolbuffers;\n\noption optimize_for \x3d LITE_RUNTIME; \n\nmessage CSParseBinary\n{\n    optional string version \x3d 1; \n    optional string cocos2dVersion \x3d 2;\n\toptional string editorType \x3d 3;\n    optional float dataScale \x3d 4;\n    optional int32 designHeight \x3d 5;\n    optional int32 designWidth \x3d 6;    \n    repeated string textures \x3d 7;\n    repeated string texturesPng \x3d 8;\n    optional NodeTree nodeTree \x3d 9;\n    optional NodeAction action \x3d 10;\n}\n\n\n// nodeTree\nmessage NodeTree\n{\n    optional string classname \x3d 1;\n    optional string name \x3d 2;\n\n    repeated NodeTree children \x3d 3;\n\n    optional WidgetOptions widgetOptions \x3d 4;\n    optional ButtonOptions buttonOptions \x3d 5;\n    optional CheckBoxOptions checkBoxOptions \x3d 6;\n    optional ImageViewOptions imageViewOptions \x3d 7;\n    \n    optional TextAtlasOptions textAtlasOptions \x3d 8;\n    optional TextBMFontOptions textBMFontOptions \x3d 9;\n    optional TextOptions textOptions \x3d 10;\n    optional LoadingBarOptions loadingBarOptions \x3d 11;\n    optional SliderOptions sliderOptions \x3d 12;\n    optional TextFieldOptions textFieldOptions \x3d 13;\n    optional ScrollViewOptions scrollViewOptions \x3d 14;\n    optional PageViewOptions pageViewOptions \x3d 15;\n    optional ListViewOptions listViewOptions \x3d 16;\n    optional PanelOptions PanelOptions \x3d 17;\n\n    optional SpriteOptions spriteOptions \x3d 18;\n    optional TMXTiledMapOptions tmxTiledMapOptions \x3d 19;\n    optional ParticleSystemOptions particleSystemOptions \x3d 20;\n    optional ProjectNodeOptions projectNodeOptions \x3d 21;\n}\n\n\n// WidgetOptions\nmessage WidgetOptions\n{\n    optional float x \x3d 1;\n    optional float y \x3d 2;\n    optional float scaleX \x3d 3;\n    optional float scaleY \x3d 4;\n    optional float rotation \x3d 5;\n    optional bool flipX \x3d 6;\n    optional bool flipY \x3d 7;\n    optional int32 colorB \x3d 8;\n    optional int32 colorG \x3d 9;\n    optional int32 colorR \x3d 10;\n    optional int32 opacity \x3d 11;\n    optional bool touchAble \x3d 12;\n    optional bool visible \x3d 13;\n    optional int32 zorder \x3d 14;\n    optional string classType \x3d 15;\n    optional float width \x3d 16;\n    optional float height \x3d 17;\n    optional int32 positionType \x3d 18;\n    optional float positionPercentX \x3d 19;\n    optional float positionPercentY \x3d 20;\n    optional int32 sizeType \x3d 21;\n    optional float sizePercentX \x3d 22;\n    optional float sizePercentY \x3d 23;\n    optional bool useMergedTexture \x3d 24;\n    optional int32 actionTag \x3d 25;\n    optional int32 tag \x3d 26;\n    optional float anchorPointX \x3d 27;\n    optional float anchorPointY \x3d 28;\n    optional bool ignoreSize \x3d 29;\n    optional float rotationSkewX \x3d 30;\n    optional float rotationSkewY \x3d 31;\n    optional LayoutParameter layoutParameter \x3d 32;\n    optional string customProperty \x3d 33;\n    optional string frameEvent \x3d 34;   \n    optional string name \x3d 35;\n    optional int32 Alpha \x3d 37;\n    repeated ComponentOptions componentOptions \x3d 36;\n}\n\n// LayoutParameter\nmessage LayoutParameter\n{\n    optional int32 type \x3d 1;\n    optional int32 gravity \x3d 2;\n    optional string relativeName \x3d 3;\n    optional string relativeToName \x3d 4;\n    optional int32 align \x3d 5;\n    optional int32 marginLeft \x3d 6;\n    optional int32 marginTop \x3d 7;\n    optional int32 marginRight \x3d 8;\n    optional int32 marginDown \x3d 9;\n    optional int32 layoutEageType \x3d 10;\n    optional int32 layoutNormalHorizontal \x3d 11;\n    optional int32 layoutNormalVertical \x3d 12;\n    optional int32 layoutParentHorizontal \x3d 13;\n    optional int32 layoutParentVertical \x3d 14;\n}\n\n// ButtonOptions\nmessage ButtonOptions\n{\n    optional string name \x3d 1;\n    optional string classname \x3d 2;\n    optional string normal \x3d 3;\n    optional string pressed \x3d 4;\n    optional string disabled \x3d 5;\n    optional ResourceData normalData \x3d 6;\n    optional ResourceData pressedData \x3d 7;\n    optional ResourceData disabledData \x3d 8;\n    optional string text \x3d 9;\n    optional string fontName \x3d 10;\n    optional int32 fontSize \x3d 11;\n    optional int32 textColorR \x3d 12;\n    optional int32 textColorG \x3d 13;\n    optional int32 textColorB \x3d 14;\n    optional float capInsetsX \x3d 15;\n    optional float capInsetsY \x3d 16;\n    optional float capInsetsWidth \x3d 17;\n    optional float capInsetsHeight \x3d 18;\n    optional float scale9Width \x3d 19;\n    optional float scale9Height \x3d 20;\n    optional bool  scale9Enable \x3d 21; \n    optional bool  displaystate \x3d 22;\n    optional ResourceData   fontResource \x3d 23;\n}\n\nmessage ResourceData\n{\n    optional string path \x3d 1;\n    optional string plistFile \x3d 2;\n    optional int32 resourceType \x3d 3;\n}\n\n// CheckBoxOptions\nmessage CheckBoxOptions\n{\n    optional string name \x3d 1;\n    optional string classname \x3d 2;\n    optional string backGroundBox \x3d 3;\n    optional string backGroundBoxSelected \x3d 4;\n    optional string backGroundBoxDisabled \x3d 5;\n    optional string frontCross \x3d 6;\n    optional string frontCrossDisabled \x3d 7;\n    optional ResourceData backGroundBoxData \x3d 8;\n    optional ResourceData backGroundBoxSelectedData \x3d 9;\n    optional ResourceData frontCrossData \x3d 10;\n    optional ResourceData backGroundBoxDisabledData \x3d 11;\n    optional ResourceData frontCrossDisabledData \x3d 12;\n    optional bool selectedState \x3d 13;\n\toptional bool displaystate \x3d 14;\n}\n\n// ImageOptions\nmessage ImageViewOptions\n{\n    optional string name \x3d 1;\n    optional string classname \x3d 2;\n    optional string fileName \x3d 3;\n    optional ResourceData fileNameData \x3d 4;\n    optional float capInsetsX \x3d 5;\n    optional float capInsetsY \x3d 6;\n    optional float capInsetsHeight \x3d 7;\n    optional float capInsetsWidth \x3d 8;\n    optional float scale9Width \x3d 9;\n    optional float scale9Height \x3d 10;\n    optional bool scale9Enable \x3d 11;\n\toptional bool flippedX \x3d 12;\n\toptional bool flippedY \x3d 13;\n}\n\n// TextAtlasOptions\nmessage TextAtlasOptions\n{\n    optional string name \x3d 1;\n    optional string classname \x3d 2;\n    optional string stringValue \x3d 3;\n    optional string charMapFile \x3d 4;\n    optional ResourceData charMapFileData \x3d 5;\n    optional string startCharMap \x3d 6;\n    optional int32 itemWidth \x3d 7;\n    optional int32 itemHeight \x3d 8;\n}\n\n// TextBMFontOptions\nmessage TextBMFontOptions\n{\n    optional string name \x3d 1;\n    optional string classname \x3d 2;\n    optional string text \x3d 3;\n    optional ResourceData fileNameData \x3d 4;\n}\n\n// TextOptions\nmessage TextOptions\n{\n    optional string name \x3d 1;\n    optional string classname \x3d 2;\n    optional string fontName \x3d 3;\n    optional ResourceData fontFile \x3d 4;\n    optional int32 fontSize \x3d 5;\n    optional string text \x3d 6;\n    optional float areaWidth \x3d 7;\n    optional float areaHeight \x3d 8;\n    optional int32 hAlignment \x3d 9;\n    optional int32 vAlignment \x3d 10;\n    optional bool touchScaleEnable \x3d 11;\n\toptional ResourceData fontResource \x3d 12;\n\toptional bool IsCustomSize \x3d 13;\n}\n\n// LoadingBarOptions\nmessage LoadingBarOptions\n{\n    optional string name \x3d 1;\n    optional string classname \x3d 2;\n    optional string texture \x3d 3;\n    optional ResourceData textureData \x3d 4;\n    optional int32 percent \x3d 5;\n    optional int32 direction \x3d 6;\n    optional float capInsetsX \x3d 7;\n    optional float capInsetsY \x3d 8;\n    optional float capInsetsWidth \x3d 9;\n    optional float capInsetsHeight \x3d 10;\n    optional bool scale9Enable \x3d 11;\n\toptional float scale9Width \x3d 12;\n    optional float scale9Height \x3d 13;\n}\n\n// ListViewOptions\nmessage ListViewOptions\n{\n    optional string name \x3d 1;\n    optional string classname \x3d 2;\n    optional string backGroundImage \x3d 3;\n    optional ResourceData backGroundImageData \x3d 4;\n    optional int32 bgColorR \x3d 5;\n    optional int32 bgColorG \x3d 6;\n    optional int32 bgColorB \x3d 7;\n    optional int32 bgStartColorR \x3d 8;\n    optional int32 bgStartColorG \x3d 9;\n    optional int32 bgStartColorB \x3d 10;\n    optional int32 bgEndColorR \x3d 11;\n    optional int32 bgEndColorG \x3d 12;\n    optional int32 bgEndColorB \x3d 13;\n    optional int32 colorType \x3d 14;\n    optional int32 bgColorOpacity \x3d 15;\n    optional float vectorX \x3d 16;\n    optional float vectorY \x3d 17;\n    optional float capInsetsX \x3d 18;\n    optional float capInsetsY \x3d 19;\n    optional float capInsetsWidth \x3d 20;\n    optional float capInsetsHeight \x3d 21;\n    optional bool backGroundScale9Enable \x3d 22;\n    optional float innerWidth \x3d 23;\n    optional float innerHeight \x3d 24;\n    optional bool clipAble \x3d 25;\n    optional bool bounceEnable \x3d 26;\n    optional int32 direction \x3d 27;\n    optional int32 gravity \x3d 28;\n    optional int32 itemMargin \x3d 29;\n\toptional float scale9Width \x3d 30;\n    optional float scale9Height \x3d 31;\n}\n\n// PageViewOptions\nmessage PageViewOptions\n{\n    optional string name \x3d 1;\n    optional string classname \x3d 2;\n    optional string backGroundImage \x3d 3;\n    optional ResourceData backGroundImageData \x3d 4;\n    optional bool clipAble \x3d 5;\n    optional int32 bgColorR \x3d 6;\n    optional int32 bgColorG \x3d 7;\n    optional int32 bgColorB \x3d 8;\n    optional int32 bgStartColorR \x3d 9;\n    optional int32 bgStartColorG \x3d 10;\n    optional int32 bgStartColorB \x3d 11;\n    optional int32 bgEndColorR \x3d 12;\n    optional int32 bgEndColorG \x3d 13;\n    optional int32 bgEndColorB \x3d 14;\n    optional int32 colorType \x3d 15;\n    optional int32 bgColorOpacity \x3d 16;\n    optional float vectorX \x3d 17;\n    optional float vectorY \x3d 18;\n    optional float capInsetsX \x3d 19;\n    optional float capInsetsY \x3d 20;\n    optional float capInsetsWidth \x3d 21;\n    optional float capInsetsHeight \x3d 22;\n    optional bool backGroundScale9Enable \x3d 23;\n\toptional float scale9Width \x3d 24;\n    optional float scale9Height \x3d 25;\n}\n\n// PanelOptions\nmessage PanelOptions\n{\n    optional string name \x3d 1;\n    optional string classname \x3d 2;\n    optional string backGroundImage \x3d 3;\n    optional ResourceData backGroundImageData \x3d 4;\n    optional bool clipAble \x3d 5;\n    optional int32 bgColorR \x3d 6;\n    optional int32 bgColorG \x3d 7;\n    optional int32 bgColorB \x3d 8;\n    optional int32 bgStartColorR \x3d 9;\n    optional int32 bgStartColorG \x3d 10;\n    optional int32 bgStartColorB \x3d 11;\n    optional int32 bgEndColorR \x3d 12;\n    optional int32 bgEndColorG \x3d 13;\n    optional int32 bgEndColorB \x3d 14;\n    optional int32 colorType \x3d 15;\n    optional int32 bgColorOpacity \x3d 16;\n    optional float vectorX \x3d 17;\n    optional float vectorY \x3d 18;\n    optional float capInsetsX \x3d 19;\n    optional float capInsetsY \x3d 20;\n    optional float capInsetsWidth \x3d 21;\n    optional float capInsetsHeight \x3d 22;\n    optional bool backGroundScale9Enable \x3d 23;\n    optional int32 layoutType \x3d 24;\n    optional bool adaptScreen \x3d 25;\n\toptional float scale9Width \x3d 26;\n    optional float scale9Height \x3d 27;\n}\n\n// ScrollViewOptions\nmessage ScrollViewOptions\n{\n    optional string name \x3d 1;\n    optional string classname \x3d 2;\n    optional string backGroundImage \x3d 3;\n    optional ResourceData backGroundImageData \x3d 4;\n    optional int32 bgColorR \x3d 5;\n    optional int32 bgColorG \x3d 6;\n    optional int32 bgColorB \x3d 7;\n    optional int32 bgStartColorR \x3d 8;\n    optional int32 bgStartColorG \x3d 9;\n    optional int32 bgStartColorB \x3d 10;\n    optional int32 bgEndColorR \x3d 11;\n    optional int32 bgEndColorG \x3d 12;\n    optional int32 bgEndColorB \x3d 13;\n    optional int32 colorType \x3d 14;\n    optional int32 bgColorOpacity \x3d 15;\n    optional float vectorX \x3d 16;\n    optional float vectorY \x3d 17;\n    optional float capInsetsX \x3d 18;\n    optional float capInsetsY \x3d 19;\n    optional float capInsetsWidth \x3d 20;\n    optional float capInsetsHeight \x3d 21;\n    optional bool backGroundScale9Enable \x3d 22;\n    optional float innerWidth \x3d 23;\n    optional float innerHeight \x3d 24;\n    optional int32 direction \x3d 25;\n    optional bool clipAble \x3d 26;\n    optional bool bounceEnable \x3d 27;\n    optional int32 layoutType \x3d 28;\n\toptional float scale9Width \x3d 29;\n    optional float scale9Height \x3d 30;\n}\n\n// SliderOptions\nmessage SliderOptions\n{\n    optional string name \x3d 1;\n    optional string classname \x3d 2;\n    optional string barFileName \x3d 3;\n    optional string ballNormal \x3d 4;\n    optional string ballPressed \x3d 5;\n    optional string ballDisabled \x3d 6;\n    optional ResourceData barFileNameData \x3d 7;\n    optional ResourceData ballNormalData \x3d 8;\n    optional ResourceData ballPressedData \x3d 9;\n    optional ResourceData ballDisabledData \x3d 10;\n    optional ResourceData progressBarData \x3d 11;\n    optional int32 percent \x3d 12;\n    optional float capInsetsX \x3d 13;\n    optional float capInsetsY \x3d 14;\n    optional float capInsetsWidth \x3d 15;\n    optional float capInsetsHeight \x3d 16;\n    optional float barCapInsetsX \x3d 17;\n    optional float barCapInsetsY \x3d 18;\n    optional float barCapInsetsWidth \x3d 19;\n    optional float barCapInsetsHeight \x3d 20;\n    optional float progressBarCapInsetsX \x3d 21;\n    optional float progressBarCapInsetsY \x3d 22;\n    optional float progressBarCapInsetsWidth \x3d 23;\n    optional float progressBarCapInsetsHeight \x3d 24;\n    optional float scale9Width \x3d 25;\n    optional float scale9Height \x3d 26;\n    optional bool scale9Enable \x3d 27;\n    optional float slidBallAnchorPointX \x3d 28;\n    optional float slidBallAnchorPointY \x3d 29;\n    optional float length \x3d 30;\n\toptional bool  displaystate \x3d 31;\n}\n\n// SpriteOptions\nmessage SpriteOptions\n{\n    optional string name \x3d 1;\n    optional string classname \x3d 2;\n    optional bool touchAble \x3d 3;\n    optional int32 positionType \x3d 4;\n    optional float positionPercentX \x3d 5;\n    optional float positionPercentY \x3d 6;\n    optional int32 sizeType \x3d 7;\n    optional float sizePercentX \x3d 8;\n    optional float sizePercentY \x3d 9;\n    optional bool useMergedTexture \x3d 10;\n    optional bool ignoreSize \x3d 11;\n    optional LayoutParameter layoutParameter \x3d 12;\n    optional string customProperty \x3d 13;\n    optional string fileName \x3d 14;\n\toptional bool flippedX \x3d 15;\n\toptional bool flippedY \x3d 16;\n\t\n    optional ResourceData fileNameData \x3d 17;\n}\n\n// TextFieldOptions\nmessage TextFieldOptions\n{\n    optional string name \x3d 1;\n    optional string classname \x3d 2;\n    optional string fontName \x3d 3;\n    optional ResourceData fontFile \x3d 4;\n    optional int32 fontSize \x3d 5;\n    optional string text \x3d 6;\n    optional string placeHolder \x3d 7;\n    optional bool passwordEnable \x3d 8;\n    optional string passwordStyleText \x3d 9;\n    optional bool maxLengthEnable \x3d 10;\n    optional int32 maxLength \x3d 11;\n    optional float areaWidth \x3d 12;\n    optional float areaHeight \x3d 13;\n\toptional float anchorPointX \x3d 15;\n    optional float anchorPointY \x3d 16;\n\toptional ResourceData fontResource \x3d 14;\n\toptional bool IsCustomSize \x3d 17;\n}\n\n// TMXTiledMapOptions\nmessage TMXTiledMapOptions\n{\n    optional string tmxFile \x3d 1;\n    optional string tmxString \x3d 2;\n    optional string resourcePath \x3d 3;\n\n    optional ResourceData fileNameData \x3d 4;\n}\n\n// ParticleSystemOptions\nmessage ParticleSystemOptions\n{\n    optional string plistFile \x3d 1;\n    optional int32 totalParticles \x3d 2;  \n\n    optional ResourceData fileNameData \x3d 3;\n}\n\n// ProjectNodeOptions\nmessage ProjectNodeOptions\n{\n    optional string fileName \x3d 1;\n}\n\n// ComponentOptions\nmessage ComponentOptions\n{\n    optional string type \x3d 1;\n\n    optional ComAudioOptions comAudioOptions \x3d 2;\n}\n\n// ComAudioOptions\nmessage ComAudioOptions\n{\n    optional string name \x3d 1;\n    optional bool enabled \x3d 2;\n    optional bool loop \x3d 3;\n    optional int32 volume \x3d 4;\n    optional ResourceData fileNameData \x3d 5;\n}\n\n\n// action\nmessage NodeAction\n{\n    optional string name \x3d 1;\n    optional string classname \x3d 2;\n    optional int32 duration \x3d 3;\n    optional float speed \x3d 4;\n\n    repeated TimeLine timelines \x3d 5;\n}\n\n// Timeline\nmessage TimeLine\n{\n    optional string name \x3d 1;\n    optional string classname \x3d 2;\n    optional string frameType \x3d 3;\n    optional int32 actionTag \x3d 4;\n    repeated Frame frames \x3d 5;\n}\n\n//Frames\nmessage Frame\n{\n    optional TimeLineBoolFrame visibleFrame \x3d 5;\n    optional TimeLineIntFrame zOrderFrame \x3d 6;\n    optional TimeLinePointFrame rotationSkewFrame \x3d 7;\n    optional TimeLineStringFrame eventFrame \x3d 8;\n    optional TimeLinePointFrame anchorPointFrame \x3d 9;\n    optional TimeLinePointFrame positionFrame \x3d 10;\n    optional TimeLinePointFrame scaleFrame \x3d 11;\n    optional TimeLineColorFrame colorFrame \x3d 12;\n    optional TimeLineTextureFrame textureFrame \x3d 13;\n}\n\n//VisibleFrame\nmessage TimeLineBoolFrame\n{\n    optional string name \x3d 1;\n    optional string classname \x3d 2;\n    optional int32 frameIndex \x3d 3;\n    optional bool tween \x3d 4;\n    optional bool value \x3d 5;\n}\n\n//ZOrderFrame RotationFrame\nmessage TimeLineIntFrame\n{\n    optional string name \x3d 1;\n    optional string classname \x3d 2;\n    optional int32 frameIndex \x3d 3;\n    optional bool tween \x3d 4;\n    optional int32 value \x3d 5;\n}\n\n//EventFrame\nmessage TimeLineStringFrame\n{\n    optional string name \x3d 1;\n    optional string classname \x3d 2;\n    optional int32 frameIndex \x3d 3;\n    optional bool tween \x3d 4;\n    optional string value \x3d 5;\n}\n\n//AnchorPointFrame PositionFrame ScaleFrame\nmessage TimeLinePointFrame\n{\n    optional string name \x3d 1;\n    optional string classname \x3d 2;\n    optional int32 frameIndex \x3d 3;\n    optional bool tween \x3d 4;\n    optional float x \x3d 5;\n\toptional float y \x3d 6;\n}\n\n//ColorFrame\nmessage TimeLineColorFrame\n{\n    optional string name \x3d 1;\n    optional string classname \x3d 2;\n    optional int32 frameIndex \x3d 3;\n    optional bool tween \x3d 4;\n    optional int32 alpha \x3d 5;\n    optional int32 red \x3d 6;\n    optional int32 green \x3d 7;\n    optional int32 blue \x3d 8;\n}\n\n//TextureFrame\nmessage TimeLineTextureFrame\n{\n    optional string name \x3d 1;\n    optional string classname \x3d 2;\n    optional int32 frameIndex \x3d 3;\n    optional bool tween \x3d 4;\n    optional string filePath \x3d 5;\n\toptional string plistFile \x3d 6;\n}";
cc.Component = cc.Class.extend({
    _owner: null,
    _name: "",
    _enabled: !0,
    ctor: function() {
        this._owner = null;
        this._name = "";
        this._enabled = !0
    },
    init: function() {
        return !0
    },
    onEnter: function() {},
    onExit: function() {},
    update: function(a) {},
    serialize: function(a) {},
    isEnabled: function() {
        return this._enabled
    },
    setEnabled: function(a) {
        this._enabled = a
    },
    getName: function() {
        return this._name
    },
    setName: function(a) {
        this._name = a
    },
    setOwner: function(a) {
        this._owner = a
    },
    getOwner: function() {
        return this._owner
    }
});
cc.Component.create = function() {
    return new cc.Component
};
cc.ComponentContainer = cc.Class.extend({
    _components: null,
    _owner: null,
    ctor: function(a) {
        this._components = null;
        this._owner = a
    },
    getComponent: function(a) {
        if (!a) throw "cc.ComponentContainer.getComponent(): name should be non-null";
        a = a.trim();
        this._components || (this._components = {});
        return this._components[a]
    },
    add: function(a) {
        if (!a) throw "cc.ComponentContainer.add(): component should be non-null";
        if (a.getOwner()) return cc.log("cc.ComponentContainer.add(): Component already added. It can't be added again"), !1;
        null == this._components && (this._components = {}, this._owner.scheduleUpdate());
        if (this._components[a.getName()]) return cc.log("cc.ComponentContainer.add(): Component already added. It can't be added again"), !1;
        a.setOwner(this._owner);
        this._components[a.getName()] = a;
        a.onEnter();
        return !0
    },
    remove: function(a) {
        if (!a) throw "cc.ComponentContainer.remove(): name should be non-null";
        if (!this._components) return !1;
        if (a instanceof cc.Component) return this._removeByComponent(a);
        a = a.trim();
        return this._removeByComponent(this._components[a])
    },
    _removeByComponent: function(a) {
        if (!a) return !1;
        a.onExit();
        a.setOwner(null);
        delete this._components[a.getName()];
        return !0
    },
    removeAll: function() {
        if (this._components) {
            var a = this._components,
                b;
            for (b in a) {
                var c = a[b];
                c.onExit();
                c.setOwner(null);
                delete a[b]
            }
            this._owner.unscheduleUpdate();
            this._components = null
        }
    },
    _alloc: function() {
        this._components = {}
    },
    visit: function(a) {
        if (this._components) {
            var b = this._components,
                c;
            for (c in b) b[c].update(a)
        }
    },
    isEmpty: function() {
        return !this._components ? !0 : 0 == this._components.length
    }
});
ccui.LayoutComponent_ReferencePoint = {
    BOTTOM_LEFT: 0,
    TOP_LEFT: 1,
    BOTTOM_RIGHT: 2,
    TOP_RIGHT: 3
};
ccui.LayoutComponent_PositionType = {
    Position: 0,
    RelativePosition: 1,
    PreRelativePosition: 2,
    PreRelativePositionEnable: 3
};
ccui.LayoutComponent_SizeType = {
    Size: 0,
    PreSize: 1,
    PreSizeEnable: 2
};
ccui.LayoutComponent = cc.Component.extend({
    _percentContentSize: null,
    _usingPercentContentSize: !1,
    _referencePoint: ccui.LayoutComponent_ReferencePoint.BOTTOM_LEFT,
    _relativePosition: null,
    _percentPosition: null,
    _usingPercentPosition: !1,
    _actived: !0,
    init: function() {
        var a = !0;
        cc.Component.prototype.init.call(this) || (a = !1);
        return a
    },
    isUsingPercentPosition: function() {
        return this._usingPercentPosition
    },
    setUsingPercentPosition: function(a) {
        this._usingPercentPosition = a;
        this.RefreshLayoutPosition(ccui.LayoutComponent_PositionType.PreRelativePositionEnable,
            cc.p(0, 0))
    },
    getPercentPosition: function() {
        return this._percentPosition
    },
    setPercentPosition: function(a) {
        this.RefreshLayoutPosition(ccui.LayoutComponent_PositionType.PreRelativePosition, a)
    },
    getRelativePosition: function() {
        return this._relativePosition
    },
    setRelativePosition: function(a) {
        this.RefreshLayoutPosition(ccui.LayoutComponent_PositionType.RelativePosition, a)
    },
    setReferencePoint: function(a) {
        this._referencePoint = a;
        this.RefreshLayoutPosition(ccui.LayoutComponent_PositionType.RelativePosition, this._relativePosition)
    },
    getReferencePoint: function() {
        return this._referencePoint
    },
    getOwnerPosition: function() {
        return this.getOwner().getPosition()
    },
    setOwnerPosition: function(a) {
        this.RefreshLayoutPosition(ccui.LayoutComponent_PositionType.Position, a)
    },
    RefreshLayoutPosition: function(a, b) {
        var c = this.getOwner().getParent(),
            d = b;
        if (null != c && this._actived) {
            c = c.getContentSize();
            a == ccui.LayoutComponent_PositionType.PreRelativePosition ? (this._percentPosition = b, d = cc.p(this._percentPosition.x * c.width, this._percentPosition.y * c.height)) :
                a == ccui.LayoutComponent_PositionType.PreRelativePositionEnable && (this._usingPercentPosition && (0 != c.width ? this._percentPosition.x = this._relativePosition.x / c.width : (this._percentPosition.x = 0, this._relativePosition.x = 0), 0 != c.height ? this._percentPosition.y = this._relativePosition.y / c.height : (this._percentPosition.y = 0, this._relativePosition.y = 0)), d = this._relativePosition);
            var e = d;
            switch (this._referencePoint) {
                case ccui.LayoutComponent_ReferencePoint.TOP_LEFT:
                    e.y = c.height - e.y;
                    break;
                case ccui.LayoutComponent_ReferencePoint.BOTTOM_RIGHT:
                    e.x =
                        c.width - e.x;
                    break;
                case ccui.LayoutComponent_ReferencePoint.TOP_RIGHT:
                    e.x = c.width - e.x, e.y = c.height - e.y
            }
            switch (a) {
                case ccui.LayoutComponent_PositionType.Position:
                    this.getOwner().setPosition(d);
                    this._relativePosition = e;
                    this._percentPosition = 0 != c.width && 0 != c.height ? cc.p(this._relativePosition.x / c.width, this._relativePosition.y / c.height) : cc.p(0, 0);
                    break;
                case ccui.LayoutComponent_PositionType.RelativePosition:
                    this.getOwner().setPosition(e);
                    this._relativePosition = d;
                    this._percentPosition = 0 != c.width && 0 != c.height ?
                        cc.p(this._relativePosition.x / c.width, this._relativePosition.y / c.height) : cc.p(0, 0);
                    break;
                case ccui.LayoutComponent_PositionType.PreRelativePosition:
                    this.getOwner().setPosition(e);
                    this._relativePosition = d;
                    break;
                case ccui.LayoutComponent_PositionType.PreRelativePositionEnable:
                    this.getOwner().setPosition(e), this._relativePosition = d
            }
        } else switch (a) {
            case ccui.LayoutComponent_PositionType.Position:
                this.getOwner().setPosition(d);
                this._referencePoint == ccui.LayoutComponent_ReferencePoint.BOTTOM_LEFT && (this._relativePosition =
                    d);
                break;
            case ccui.LayoutComponent_PositionType.RelativePosition:
                this._relativePosition = d;
                break;
            case ccui.LayoutComponent_PositionType.PreRelativePosition:
                this._percentPosition = d
        }
    },
    getOwnerContentSize: function() {
        return this.getOwner().getContentSize()
    },
    setOwnerContentSize: function(a) {
        this.RefreshLayoutSize(ccui.LayoutComponent_SizeType.Size, a)
    },
    getPercentContentSize: function() {
        return this._percentContentSize
    },
    setPercentContentSize: function(a) {
        this.RefreshLayoutSize(ccui.LayoutComponent_SizeType.PreSize,
            a)
    },
    isUsingPercentContentSize: function() {
        return this._usingPercentContentSize
    },
    setUsingPercentContentSize: function(a) {
        this._usingPercentContentSize = a;
        this.RefreshLayoutSize(ccui.LayoutComponent_SizeType.PreSizeEnable, cc.p(0, 0))
    },
    RefreshLayoutSize: function(a, b) {
        var c = this.getOwner().getParent();
        if (null != c && this._actived) switch (c = c.getContentSize(), a) {
            case ccui.LayoutComponent_SizeType.Size:
                this._percentContentSize = 0 != c.width && 0 != c.height ? cc.p(b.x / c.width, b.y / c.height) : cc.p(0, 0);
                this.getOwner().setContentSize(cc.size(b.x,
                    b.y));
                break;
            case ccui.LayoutComponent_SizeType.PreSize:
                cc.p_percentContentSize = b;
                this._usingPercentContentSize && this.getOwner().setContentSize(cc.size(b.x * c.width, b.y * c.height));
                break;
            case ccui.LayoutComponent_SizeType.PreSizeEnable:
                if (this._usingPercentContentSize) {
                    var d = this.getOwner().getContentSize();
                    0 != c.width ? this._percentContentSize.x = d.width / c.width : (this._percentContentSize.x = 0, d.width = 0);
                    0 != c.height ? this._percentContentSize.y = d.height / c.height : (this._percentContentSize.y = 0, d.height = 0);
                    this.getOwner().setContentSize(d)
                }
        } else switch (a) {
            case ccui.LayoutComponent_SizeType.Size:
                this.getOwner().setContentSize(cc.size(b.x,
                    b.y));
                break;
            case ccui.LayoutComponent_SizeType.PreSize:
                this._percentContentSize = b
        }
    },
    SetActiveEnable: function(a) {
        this._actived = a
    }
});
var ccs = ccs || {};
ccs.Class = ccs.Class || cc.Class;
ccs.Class.extend = ccs.Class.extend || cc.Class.extend;
ccs.Node = ccs.Node || cc.Node;
ccs.Node.extend = ccs.Node.extend || cc.Node.extend;
ccs.Sprite = ccs.Sprite || cc.Sprite;
ccs.Sprite.extend = ccs.Sprite.extend || cc.Sprite.extend;
ccs.Component = ccs.Component || cc.Component;
ccs.Component.extend = ccs.Component.extend || cc.Component.extend;
ccs.cocostudioVersion = "v1.3.0.0";
ccs.VERSION_COMBINED = 0.3;
ccs.VERSION_CHANGE_ROTATION_RANGE = 1;
ccs.VERSION_COLOR_READING = 1.1;
ccs.MAX_VERTEXZ_VALUE = 5E6;
ccs.ARMATURE_MAX_CHILD = 50;
ccs.ARMATURE_MAX_ZORDER = 100;
ccs.ARMATURE_MAX_COUNT = ccs.MAX_VERTEXZ_VALUE / ccs.ARMATURE_MAX_CHILD / ccs.ARMATURE_MAX_ZORDER;
ccs.AUTO_ADD_SPRITE_FRAME_NAME_PREFIX = !1;
ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT = !1;
ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX = !1;
ccs.armatureVersion = function() {
    return "v1.1.0.0"
};
ccs.CONST_VERSION = "version";
ccs.CONST_VERSION_2_0 = 2;
ccs.CONST_VERSION_COMBINED = 0.3;
ccs.CONST_ARMATURES = "armatures";
ccs.CONST_ARMATURE = "armature";
ccs.CONST_BONE = "b";
ccs.CONST_DISPLAY = "d";
ccs.CONST_ANIMATIONS = "animations";
ccs.CONST_ANIMATION = "animation";
ccs.CONST_MOVEMENT = "mov";
ccs.CONST_FRAME = "f";
ccs.CONST_TEXTURE_ATLAS = "TextureAtlas";
ccs.CONST_SUB_TEXTURE = "SubTexture";
ccs.CONST_SKELETON = "skeleton";
ccs.CONST_A_NAME = "name";
ccs.CONST_A_DURATION = "dr";
ccs.CONST_A_FRAME_INDEX = "fi";
ccs.CONST_A_DURATION_TO = "to";
ccs.CONST_A_DURATION_TWEEN = "drTW";
ccs.CONST_A_LOOP = "lp";
ccs.CONST_A_MOVEMENT_SCALE = "sc";
ccs.CONST_A_MOVEMENT_DELAY = "dl";
ccs.CONST_A_DISPLAY_INDEX = "dI";
ccs.CONST_A_PLIST = "plist";
ccs.CONST_A_PARENT = "parent";
ccs.CONST_A_SKEW_X = "kX";
ccs.CONST_A_SKEW_Y = "kY";
ccs.CONST_A_SCALE_X = "cX";
ccs.CONST_A_SCALE_Y = "cY";
ccs.CONST_A_Z = "z";
ccs.CONST_A_EVENT = "evt";
ccs.CONST_A_SOUND = "sd";
ccs.CONST_A_SOUND_EFFECT = "sdE";
ccs.CONST_A_TWEEN_EASING = "twE";
ccs.CONST_A_EASING_PARAM = "twEP";
ccs.CONST_A_TWEEN_ROTATE = "twR";
ccs.CONST_A_IS_ARMATURE = "isArmature";
ccs.CONST_A_DISPLAY_TYPE = "displayType";
ccs.CONST_A_MOVEMENT = "mov";
ccs.CONST_A_X = "x";
ccs.CONST_A_Y = "y";
ccs.CONST_A_COCOS2DX_X = "cocos2d_x";
ccs.CONST_A_COCOS2DX_Y = "cocos2d_y";
ccs.CONST_A_WIDTH = "width";
ccs.CONST_A_HEIGHT = "height";
ccs.CONST_A_PIVOT_X = "pX";
ccs.CONST_A_PIVOT_Y = "pY";
ccs.CONST_A_COCOS2D_PIVOT_X = "cocos2d_pX";
ccs.CONST_A_COCOS2D_PIVOT_Y = "cocos2d_pY";
ccs.CONST_A_BLEND_TYPE = "bd";
ccs.CONST_A_BLEND_SRC = "bd_src";
ccs.CONST_A_BLEND_DST = "bd_dst";
ccs.CONST_A_ALPHA = "a";
ccs.CONST_A_RED = "r";
ccs.CONST_A_GREEN = "g";
ccs.CONST_A_BLUE = "b";
ccs.CONST_A_ALPHA_OFFSET = "aM";
ccs.CONST_A_RED_OFFSET = "rM";
ccs.CONST_A_GREEN_OFFSET = "gM";
ccs.CONST_A_BLUE_OFFSET = "bM";
ccs.CONST_A_COLOR_TRANSFORM = "colorTransform";
ccs.CONST_A_TWEEN_FRAME = "tweenFrame";
ccs.CONST_CONTOUR = "con";
ccs.CONST_CONTOUR_VERTEX = "con_vt";
ccs.CONST_FL_NAN = "NaN";
ccs.CONST_FRAME_DATA = "frame_data";
ccs.CONST_MOVEMENT_BONE_DATA = "mov_bone_data";
ccs.CONST_MOVEMENT_DATA = "mov_data";
ccs.CONST_ANIMATION_DATA = "animation_data";
ccs.CONST_DISPLAY_DATA = "display_data";
ccs.CONST_SKIN_DATA = "skin_data";
ccs.CONST_BONE_DATA = "bone_data";
ccs.CONST_ARMATURE_DATA = "armature_data";
ccs.CONST_CONTOUR_DATA = "contour_data";
ccs.CONST_TEXTURE_DATA = "texture_data";
ccs.CONST_VERTEX_POINT = "vertex";
ccs.CONST_COLOR_INFO = "color";
ccs.CONST_CONFIG_FILE_PATH = "config_file_path";
ccs.CONST_CONTENT_SCALE = "content_scale";
ccs.DataInfo = function() {
    this.asyncStruct = null;
    this.configFileQueue = [];
    this.contentScale = 1;
    this.baseFilePath = this.filename = "";
    this.cocoStudioVersion = this.flashToolVersion = 0
};
ccs.dataReaderHelper = {
    ConfigType: {
        DragonBone_XML: 0,
        CocoStudio_JSON: 1,
        CocoStudio_Binary: 2
    },
    _configFileList: [],
    _flashToolVersion: ccs.CONST_VERSION_2_0,
    _positionReadScale: 1,
    _asyncRefCount: 0,
    _asyncRefTotalCount: 0,
    _dataQueue: null,
    setPositionReadScale: function(a) {
        this._positionReadScale = a
    },
    getPositionReadScale: function() {
        return this._positionReadScale
    },
    addDataFromFile: function(a) {
        if (-1 == this._configFileList.indexOf(a)) {
            this._configFileList.push(a);
            var b = this._initBaseFilePath(a),
                c = cc.path.extname(a).toLowerCase(),
                d = new ccs.DataInfo;
            d.filename = a;
            d.basefilePath = b;
            ".xml" == c ? ccs.dataReaderHelper.addDataFromXML(a, d) : ".json" == c || ".exportjson" == c ? ccs.dataReaderHelper.addDataFromJson(a, d) : ".csb" == c && ccs.dataReaderHelper.addDataFromBinaryCache(a, d)
        }
    },
    addDataFromFileAsync: function(a, b, c, d, e) {
        if (-1 != this._configFileList.indexOf(c)) e && d && (0 == this._asyncRefTotalCount && 0 == this._asyncRefCount ? this._asyncCallBack(d, e, 1) : this._asyncCallBack(d, e, (this._asyncRefTotalCount - this._asyncRefCount) / this._asyncRefTotalCount));
        else {
            this._asyncRefTotalCount++;
            this._asyncRefCount++;
            var f = this;
            cc.director.getScheduler().scheduleCallbackForTarget(this, function() {
                f.addDataFromFile(c);
                f._asyncRefCount--;
                f._asyncCallBack(d, e, (f._asyncRefTotalCount - f._asyncRefCount) / f._asyncRefTotalCount)
            }, 0.1, !1)
        }
    },
    removeConfigFile: function(a) {
        for (var b = this._configFileList, c = b.length, d = b[c], e = 0; e < c; e++) b[e] == a && (d = e);
        d != b[c] && cc.arrayRemoveObject(b, a)
    },
    addDataFromCache: function(a, b) {
        if (a) {
            b.flashToolVersion = parseFloat(a.getAttribute(ccs.CONST_VERSION));
            var c = a.querySelectorAll(ccs.CONST_SKELETON +
                    " \x3e " + ccs.CONST_ARMATURES + " \x3e  " + ccs.CONST_ARMATURE + ""),
                d = ccs.armatureDataManager,
                e;
            for (e = 0; e < c.length; e++) {
                var f = this.decodeArmature(c[e], b);
                d.addArmatureData(f.name, f, b.filename)
            }
            c = a.querySelectorAll(ccs.CONST_SKELETON + " \x3e " + ccs.CONST_ANIMATIONS + " \x3e  " + ccs.CONST_ANIMATION + "");
            for (e = 0; e < c.length; e++) f = this.decodeAnimation(c[e], b), d.addAnimationData(f.name, f, b.filename);
            c = a.querySelectorAll(ccs.CONST_SKELETON + " \x3e " + ccs.CONST_TEXTURE_ATLAS + " \x3e  " + ccs.CONST_SUB_TEXTURE + "");
            for (e = 0; e <
                c.length; e++) f = this.decodeTexture(c[e], b), d.addTextureData(f.name, f, b.filename)
        } else cc.log("XML error  or  XML is empty.")
    },
    decodeArmature: function(a, b) {
        var c = new ccs.ArmatureData;
        c.init();
        c.name = a.getAttribute(ccs.CONST_A_NAME);
        for (var d = a.querySelectorAll(ccs.CONST_ARMATURE + " \x3e " + ccs.CONST_BONE), e = 0; e < d.length; e++) {
            var f = d[e],
                g = f.getAttribute(ccs.CONST_A_PARENT),
                h = null;
            if (g)
                for (var k = 0; k < d.length && !(h = d[k], g == d[k].getAttribute(ccs.CONST_A_NAME)); k++);
            f = this.decodeBone(f, h, b);
            c.addBoneData(f)
        }
        return c
    },
    decodeArmatureFromJSON: function(a, b) {
        var c = new ccs.ArmatureData;
        c.init();
        var d = a[ccs.CONST_A_NAME];
        d && (c.name = d);
        b.cocoStudioVersion = c.dataVersion = a[ccs.CONST_VERSION] || 0.1;
        for (var d = a[ccs.CONST_BONE_DATA], e = 0; e < d.length; e++) {
            var f = this.decodeBoneFromJson(d[e], b);
            c.addBoneData(f)
        }
        return c
    },
    decodeBone: function(a, b, c) {
        b = new ccs.BoneData;
        b.init();
        b.name = a.getAttribute(ccs.CONST_A_NAME);
        b.parentName = a.getAttribute(ccs.CONST_A_PARENT) || "";
        b.zOrder = parseInt(a.getAttribute(ccs.CONST_A_Z)) || 0;
        a = a.querySelectorAll(ccs.CONST_BONE +
            " \x3e " + ccs.CONST_DISPLAY);
        for (var d = 0; d < a.length; d++) {
            var e = this.decodeBoneDisplay(a[d], c);
            b.addDisplayData(e)
        }
        return b
    },
    decodeBoneFromJson: function(a, b) {
        var c = new ccs.BoneData;
        c.init();
        this.decodeNodeFromJson(c, a, b);
        c.name = a[ccs.CONST_A_NAME] || "";
        c.parentName = a[ccs.CONST_A_PARENT] || "";
        for (var d = a[ccs.CONST_DISPLAY_DATA] || [], e = 0; e < d.length; e++) {
            var f = this.decodeBoneDisplayFromJson(d[e], b);
            c.addDisplayData(f)
        }
        return c
    },
    decodeBoneDisplay: function(a, b) {
        var c = null;
        1 == (parseFloat(a.getAttribute(ccs.CONST_A_IS_ARMATURE)) ||
            0) ? (c = new ccs.ArmatureDisplayData, c.displayType = ccs.DISPLAY_TYPE_ARMATURE) : (c = new ccs.SpriteDisplayData, c.displayType = ccs.DISPLAY_TYPE_SPRITE);
        var d = a.getAttribute(ccs.CONST_A_NAME) || "";
        d && (c.displayName = d);
        return c
    },
    decodeBoneDisplayFromJson: function(a, b) {
        var c = a[ccs.CONST_A_DISPLAY_TYPE] || ccs.DISPLAY_TYPE_SPRITE,
            d = null;
        switch (c) {
            case ccs.DISPLAY_TYPE_SPRITE:
                var d = new ccs.SpriteDisplayData,
                    e = a[ccs.CONST_A_NAME];
                null != e && (d.displayName = e);
                if (e = (a[ccs.CONST_SKIN_DATA] || [])[0]) {
                    var f = d.skinData;
                    f.x =
                        e[ccs.CONST_A_X] * this._positionReadScale;
                    f.y = e[ccs.CONST_A_Y] * this._positionReadScale;
                    f.scaleX = null == e[ccs.CONST_A_SCALE_X] ? 1 : e[ccs.CONST_A_SCALE_X];
                    f.scaleY = null == e[ccs.CONST_A_SCALE_Y] ? 1 : e[ccs.CONST_A_SCALE_Y];
                    f.skewX = null == e[ccs.CONST_A_SKEW_X] ? 1 : e[ccs.CONST_A_SKEW_X];
                    f.skewY = null == e[ccs.CONST_A_SKEW_Y] ? 1 : e[ccs.CONST_A_SKEW_Y];
                    f.x *= b.contentScale;
                    f.y *= b.contentScale
                }
                break;
            case ccs.DISPLAY_TYPE_ARMATURE:
                d = new ccs.ArmatureDisplayData;
                e = a[ccs.CONST_A_NAME];
                null != e && (d.displayName = a[ccs.CONST_A_NAME]);
                break;
            case ccs.DISPLAY_TYPE_PARTICLE:
                d = new ccs.ParticleDisplayData;
                e = a[ccs.CONST_A_PLIST];
                null != e && (d.displayName = b.asyncStruct ? b.asyncStruct.basefilePath + e : b.basefilePath + e);
                break;
            default:
                d = new ccs.SpriteDisplayData
        }
        d.displayType = c;
        return d
    },
    decodeAnimation: function(a, b) {
        var c = new ccs.AnimationData,
            d = a.getAttribute(ccs.CONST_A_NAME),
            e = ccs.armatureDataManager.getArmatureData(d);
        c.name = d;
        for (var d = a.querySelectorAll(ccs.CONST_ANIMATION + " \x3e " + ccs.CONST_MOVEMENT), f = null, g = 0; g < d.length; g++) f = d[g],
            f = this.decodeMovement(f, e, b), c.addMovement(f);
        return c
    },
    decodeAnimationFromJson: function(a, b) {
        var c = new ccs.AnimationData;
        a[ccs.CONST_A_NAME] && (c.name = a[ccs.CONST_A_NAME]);
        for (var d = a[ccs.CONST_MOVEMENT_DATA] || [], e = 0; e < d.length; e++) {
            var f = this.decodeMovementFromJson(d[e], b);
            c.addMovement(f)
        }
        return c
    },
    decodeMovement: function(a, b, c) {
        var d = new ccs.MovementData;
        d.name = a.getAttribute(ccs.CONST_A_NAME);
        var e;
        e = 0;
        e = a.getAttribute(ccs.CONST_A_DURATION);
        d.duration = null == e ? 0 : parseFloat(e);
        e = a.getAttribute(ccs.CONST_A_DURATION_TO);
        d.durationTo = null == e ? 0 : parseFloat(e);
        e = a.getAttribute(ccs.CONST_A_DURATION_TWEEN);
        d.durationTween = null == e ? 0 : parseFloat(e);
        e = a.getAttribute(ccs.CONST_A_LOOP);
        d.loop = e ? Boolean(parseFloat(e)) : !0;
        if (e = a.getAttribute(ccs.CONST_A_TWEEN_EASING)) e != ccs.CONST_FL_NAN ? (e = null == e ? 0 : parseFloat(e), d.tweenEasing = 2 == e ? ccs.TweenType.sineEaseInOut : e) : d.tweenEasing = ccs.TweenType.linear;
        a = a.querySelectorAll(ccs.CONST_MOVEMENT + " \x3e " + ccs.CONST_BONE);
        var f = null;
        for (e = 0; e < a.length; e++) {
            var f = a[e],
                g = f.getAttribute(ccs.CONST_A_NAME);
            if (!d.getMovementBoneData(g)) {
                var g = b.getBoneData(g),
                    h = g.parentName,
                    k = null;
                if ("" != h)
                    for (var m = 0; m < a.length && !(k = a[m], h == k.getAttribute(ccs.CONST_A_NAME)); m++);
                f = this.decodeMovementBone(f, k, g, c);
                d.addMovementBoneData(f)
            }
        }
        return d
    },
    decodeMovementFromJson: function(a, b) {
        var c = new ccs.MovementData;
        c.loop = null == a[ccs.CONST_A_LOOP] ? !1 : a[ccs.CONST_A_LOOP];
        c.durationTween = a[ccs.CONST_A_DURATION_TWEEN] || 0;
        c.durationTo = a[ccs.CONST_A_DURATION_TO] || 0;
        c.duration = a[ccs.CONST_A_DURATION] || 0;
        c.scale = null == a[ccs.CONST_A_DURATION] ?
            1 : null == a[ccs.CONST_A_MOVEMENT_SCALE] ? 1 : a[ccs.CONST_A_MOVEMENT_SCALE];
        c.tweenEasing = null == a[ccs.CONST_A_TWEEN_EASING] ? ccs.TweenType.linear : a[ccs.CONST_A_TWEEN_EASING];
        var d = a[ccs.CONST_A_NAME];
        d && (c.name = d);
        for (var d = a[ccs.CONST_MOVEMENT_BONE_DATA] || [], e = 0; e < d.length; e++) {
            var f = this.decodeMovementBoneFromJson(d[e], b);
            c.addMovementBoneData(f)
        }
        return c
    },
    decodeMovementBone: function(a, b, c, d) {
        var e = new ccs.MovementBoneData;
        e.init();
        var f;
        a && (f = parseFloat(a.getAttribute(ccs.CONST_A_MOVEMENT_SCALE)) || 0,
            e.scale = f, f = parseFloat(a.getAttribute(ccs.CONST_A_MOVEMENT_DELAY)) || 0, 0 < f && (f -= 1), e.delay = f);
        var g = 0,
            h = f = 0,
            k = null,
            m = [];
        if (null != b) {
            for (var n = b.querySelectorAll(ccs.CONST_BONE + " \x3e " + ccs.CONST_FRAME), g = 0; g < n.length; g++) m.push(n[g]);
            g = m.length
        }
        e.name = a.getAttribute(ccs.CONST_A_NAME);
        a = a.querySelectorAll(ccs.CONST_BONE + " \x3e " + ccs.CONST_FRAME);
        for (var q = n = 0, r = 0; r < a.length; r++) {
            var s = a[r];
            if (b)
                for (; n < g && (k ? q < f || q >= f + h : 1);) k = m[n], f += h, h = parseFloat(k.getAttribute(ccs.CONST_A_DURATION)), n++;
            s = this.decodeFrame(s,
                k, c, d);
            e.addFrameData(s);
            s.frameID = q;
            q += s.duration;
            e.duration = q
        }
        b = e.frameList;
        c = Math.PI;
        for (g = b.length - 1; 0 <= g; g--)
            if (0 < g) {
                d = b[g].skewX - b[g - 1].skewX;
                f = b[g].skewY - b[g - 1].skewY;
                if (d < -c || d > c) b[g - 1].skewX = 0 > d ? b[g - 1].skewX - 2 * c : b[g - 1].skewX + 2 * c;
                if (f < -c || f > c) b[g - 1].skewY = 0 > f ? b[g - 1].skewY - 2 * c : b[g - 1].skewY + 2 * c
            }
        b = new ccs.FrameData;
        b.copy(e.frameList[e.frameList.length - 1]);
        b.frameID = e.duration;
        e.addFrameData(b);
        return e
    },
    decodeMovementBoneFromJson: function(a, b) {
        var c = new ccs.MovementBoneData;
        c.init();
        c.delay =
            a[ccs.CONST_A_MOVEMENT_DELAY] || 0;
        var d = a[ccs.CONST_A_NAME];
        d && (c.name = d);
        for (var e = (a[ccs.CONST_FRAME_DATA] || []).length, d = 0; d < e; d++) {
            var f = this.decodeFrameFromJson(a[ccs.CONST_FRAME_DATA][d], b);
            c.addFrameData(f);
            b.cocoStudioVersion < ccs.CONST_VERSION_COMBINED && (f.frameID = c.duration, c.duration += f.duration)
        }
        if (b.cocoStudioVersion < ccs.VERSION_CHANGE_ROTATION_RANGE) {
            e = c.frameList;
            f = Math.PI;
            for (d = e.length - 1; 0 <= d; d--)
                if (0 < d) {
                    var g = e[d].skewX - e[d - 1].skewX,
                        h = e[d].skewY - e[d - 1].skewY;
                    if (g < -f || g > f) e[d - 1].skewX =
                        0 > g ? e[d - 1].skewX - 2 * f : e[d - 1].skewX + 2 * f;
                    if (h < -f || h > f) e[d - 1].skewY = 0 > h ? e[d - 1].skewY - 2 * f : e[d - 1].skewY + 2 * f
                }
        }
        b.cocoStudioVersion < ccs.CONST_VERSION_COMBINED && 0 < c.frameList.length && (f = new ccs.FrameData, f.copy(c.frameList[c.frameList.length - 1]), c.addFrameData(f), f.frameID = c.duration);
        return c
    },
    decodeFrame: function(a, b, c, d) {
        var e = 0,
            e = e = e = e = e = e = e = e = e = e = e = 0;
        c = new ccs.FrameData;
        c.strMovement = a.getAttribute(ccs.CONST_A_MOVEMENT) || "";
        c.movement = c.strMovement;
        c.strEvent = a.getAttribute(ccs.CONST_A_EVENT) || "";
        c.event =
            c.strEvent;
        c.strSound = a.getAttribute(ccs.CONST_A_SOUND) || "";
        c.sound = c.strSound;
        c.strSoundEffect = a.getAttribute(ccs.CONST_A_SOUND_EFFECT) || "";
        c.soundEffect = c.strSoundEffect;
        e = a.getAttribute(ccs.CONST_A_TWEEN_FRAME);
        c.isTween = !(void 0 != e && "false" == e);
        if (d.flashToolVersion >= ccs.CONST_VERSION_2_0) {
            if (e = a.getAttribute(ccs.CONST_A_COCOS2DX_X)) c.x = parseFloat(e), c.x *= this._positionReadScale;
            e = a.getAttribute(ccs.CONST_A_COCOS2DX_Y)
        } else {
            if (e = a.getAttribute(ccs.CONST_A_X)) c.x = parseFloat(e), c.x *= this._positionReadScale;
            e = a.getAttribute(ccs.CONST_A_Y)
        }
        e && (c.y = -parseFloat(e), c.y *= this._positionReadScale);
        e = a.getAttribute(ccs.CONST_A_SCALE_X);
        null != e && (c.scaleX = parseFloat(e));
        e = a.getAttribute(ccs.CONST_A_SCALE_Y);
        null != e && (c.scaleY = parseFloat(e));
        e = a.getAttribute(ccs.CONST_A_SKEW_X);
        null != e && (c.skewX = cc.degreesToRadians(parseFloat(e)));
        e = a.getAttribute(ccs.CONST_A_SKEW_Y);
        null != e && (c.skewY = cc.degreesToRadians(-parseFloat(e)));
        e = a.getAttribute(ccs.CONST_A_DURATION);
        null != e && (c.duration = parseFloat(e));
        e = a.getAttribute(ccs.CONST_A_DISPLAY_INDEX);
        null != e && (c.displayIndex = parseFloat(e));
        e = a.getAttribute(ccs.CONST_A_Z);
        null != e && (c.zOrder = parseInt(e));
        e = a.getAttribute(ccs.CONST_A_TWEEN_ROTATE);
        null != e && (c.tweenRotate = parseFloat(e));
        e = a.getAttribute(ccs.CONST_A_BLEND_TYPE);
        if (null != e) {
            var f = c.blendFunc;
            switch (e) {
                case ccs.BLEND_TYPE_NORMAL:
                    f.src = cc.BLEND_SRC;
                    f.dst = cc.BLEND_DST;
                    break;
                case ccs.BLEND_TYPE_ADD:
                    f.src = cc.SRC_ALPHA;
                    f.dst = cc.ONE;
                    break;
                case ccs.BLEND_TYPE_MULTIPLY:
                    f.src = cc.DST_COLOR;
                    f.dst = cc.ONE_MINUS_SRC_ALPHA;
                    break;
                case ccs.BLEND_TYPE_SCREEN:
                    f.src =
                        cc.ONE;
                    f.dst = cc.ONE_MINUS_DST_COLOR;
                    break;
                default:
                    c.blendFunc.src = cc.BLEND_SRC, c.blendFunc.dst = cc.BLEND_DST
            }
        }
        var g = a.querySelectorAll(ccs.CONST_FRAME + " \x3e " + ccs.CONST_A_COLOR_TRANSFORM);
        if (g && 0 < g.length) {
            var g = g[0],
                h, k, m, n, q, e = parseFloat(g.getAttribute(ccs.CONST_A_ALPHA)) || 0,
                f = parseFloat(g.getAttribute(ccs.CONST_A_RED)) || 0;
            h = parseFloat(g.getAttribute(ccs.CONST_A_GREEN)) || 0;
            k = parseFloat(g.getAttribute(ccs.CONST_A_BLUE)) || 0;
            m = parseFloat(g.getAttribute(ccs.CONST_A_ALPHA_OFFSET)) || 0;
            n = parseFloat(g.getAttribute(ccs.CONST_A_RED_OFFSET)) ||
                0;
            q = parseFloat(g.getAttribute(ccs.CONST_A_GREEN_OFFSET)) || 0;
            g = parseFloat(g.getAttribute(ccs.CONST_A_BLUE_OFFSET)) || 0;
            c.a = 2.55 * m + e;
            c.r = 2.55 * n + f;
            c.g = 2.55 * q + h;
            c.b = 2.55 * g + k;
            c.isUseColorInfo = !0
        }
        e = a.getAttribute(ccs.CONST_A_TWEEN_EASING);
        null != e && (e != ccs.CONST_FL_NAN ? (e = a.getAttribute(ccs.CONST_A_TWEEN_EASING)) && (c.tweenEasing = 2 == e ? ccs.TweenType.sineEaseInOut : e) : c.tweenEasing = ccs.TweenType.linear);
        b && (a = new ccs.BaseData, d.flashToolVersion >= ccs.CONST_VERSION_2_0 ? (a.x = parseFloat(b.getAttribute(ccs.CONST_A_COCOS2DX_X)),
            a.y = parseFloat(b.getAttribute(ccs.CONST_A_COCOS2DX_Y))) : (a.x = parseFloat(b.getAttribute(ccs.CONST_A_X)), a.y = parseFloat(b.getAttribute(ccs.CONST_A_Y))), a.skewX = parseFloat(b.getAttribute(ccs.CONST_A_SKEW_X)), a.skewY = parseFloat(b.getAttribute(ccs.CONST_A_SKEW_Y)), a.y = -a.y, a.skewX = cc.degreesToRadians(a.skewX), a.skewY = cc.degreesToRadians(-a.skewY), ccs.TransformHelp.transformFromParent(c, a));
        return c
    },
    decodeFrameFromJson: function(a, b) {
        var c = new ccs.FrameData;
        this.decodeNodeFromJson(c, a, b);
        c.tweenEasing =
            a[ccs.CONST_A_TWEEN_EASING] || ccs.TweenType.linear;
        c.displayIndex = a[ccs.CONST_A_DISPLAY_INDEX];
        var d = null == a[ccs.CONST_A_BLEND_DST] ? cc.BLEND_DST : a[ccs.CONST_A_BLEND_DST];
        c.blendFunc.src = null == a[ccs.CONST_A_BLEND_SRC] ? cc.BLEND_SRC : a[ccs.CONST_A_BLEND_SRC];
        c.blendFunc.dst = d;
        c.isTween = null == a[ccs.CONST_A_TWEEN_FRAME] ? !0 : a[ccs.CONST_A_TWEEN_FRAME];
        d = a[ccs.CONST_A_EVENT];
        null != d && (c.strEvent = d, c.event = d);
        b.cocoStudioVersion < ccs.CONST_VERSION_COMBINED ? c.duration = null == a[ccs.CONST_A_DURATION] ? 1 : a[ccs.CONST_A_DURATION] :
            c.frameID = a[ccs.CONST_A_FRAME_INDEX];
        for (var d = a[ccs.CONST_A_EASING_PARAM] || [], e = 0; e < d.length; e++) c.easingParams[e] = d[e];
        return c
    },
    decodeTexture: function(a, b) {
        var c = new ccs.TextureData;
        c.init();
        a.getAttribute(ccs.CONST_A_NAME) && (c.name = a.getAttribute(ccs.CONST_A_NAME));
        var d, e;
        b.flashToolVersion >= ccs.CONST_VERSION_2_0 ? (d = parseFloat(a.getAttribute(ccs.CONST_A_COCOS2D_PIVOT_X)) || 0, e = parseFloat(a.getAttribute(ccs.CONST_A_COCOS2D_PIVOT_Y)) || 0) : (d = parseFloat(a.getAttribute(ccs.CONST_A_PIVOT_X)) || 0, e = parseFloat(a.getAttribute(ccs.CONST_A_PIVOT_Y)) ||
            0);
        var f = parseFloat(a.getAttribute(ccs.CONST_A_WIDTH)) || 0,
            g = parseFloat(a.getAttribute(ccs.CONST_A_HEIGHT)) || 0;
        c.pivotX = d / f;
        c.pivotY = (g - e) / g;
        d = a.querySelectorAll(ccs.CONST_SUB_TEXTURE + " \x3e " + ccs.CONST_CONTOUR);
        for (e = 0; e < d.length; e++) c.addContourData(this.decodeContour(d[e], b));
        return c
    },
    decodeTextureFromJson: function(a) {
        var b = new ccs.TextureData;
        b.init();
        var c = a[ccs.CONST_A_NAME];
        null != c && (b.name = c);
        b.width = a[ccs.CONST_A_WIDTH] || 0;
        b.height = a[ccs.CONST_A_HEIGHT] || 0;
        b.pivotX = a[ccs.CONST_A_PIVOT_X] ||
            0;
        b.pivotY = a[ccs.CONST_A_PIVOT_Y] || 0;
        a = a[ccs.CONST_CONTOUR_DATA] || [];
        for (c = 0; c < a.length; c++) b.contourDataList.push(this.decodeContourFromJson(a[c]));
        return b
    },
    decodeContour: function(a, b) {
        var c = new ccs.ContourData;
        c.init();
        for (var d = a.querySelectorAll(ccs.CONST_CONTOUR + " \x3e " + ccs.CONST_CONTOUR_VERTEX), e, f = 0; f < d.length; f++) {
            e = d[f];
            var g = cc.p(0, 0);
            g.x = parseFloat(e.getAttribute(ccs.CONST_A_X)) || 0;
            g.y = parseFloat(e.getAttribute(ccs.CONST_A_Y)) || 0;
            g.y = -g.y;
            c.vertexList.push(g)
        }
        return c
    },
    decodeContourFromJson: function(a) {
        var b =
            new ccs.ContourData;
        b.init();
        a = a[ccs.CONST_VERTEX_POINT] || [];
        for (var c = a.length, d = 0; d < c; d++) {
            var e = a[d],
                f = cc.p(0, 0);
            f.x = e[ccs.CONST_A_X] || 0;
            f.y = e[ccs.CONST_A_Y] || 0;
            b.vertexList.push(f)
        }
        return b
    },
    addDataFromJsonCache: function(a, b) {
        b.contentScale = null == a[ccs.CONST_CONTENT_SCALE] ? 1 : a[ccs.CONST_CONTENT_SCALE];
        var c = a[ccs.CONST_ARMATURE_DATA] || [],
            d, e;
        for (d = 0; d < c.length; d++) e = this.decodeArmatureFromJSON(c[d], b), ccs.armatureDataManager.addArmatureData(e.name, e, b.filename);
        c = a[ccs.CONST_ANIMATION_DATA] || [];
        for (d = 0; d < c.length; d++) e = this.decodeAnimationFromJson(c[d], b), ccs.armatureDataManager.addAnimationData(e.name, e, b.filename);
        c = a[ccs.CONST_TEXTURE_DATA] || [];
        for (d = 0; d < c.length; d++) e = this.decodeTextureFromJson(c[d], b), ccs.armatureDataManager.addTextureData(e.name, e, b.filename);
        if (null == b.asyncStruct ? ccs.armatureDataManager.isAutoLoadSpriteFile() : b.asyncStruct.autoLoadSpriteFile) {
            var c = a[ccs.CONST_CONFIG_FILE_PATH] || [],
                f;
            for (d = 0; d < c.length; d++) e = c[d], f = e.lastIndexOf("."), e = e.substring(0, f), f = b.basefilePath +
                e + ".plist", e = b.basefilePath + e + ".png", ccs.armatureDataManager.addSpriteFrameFromFile(f, e, b.filename)
        }
    },
    decodeNodeFromJson: function(a, b, c) {
        a.x = b[ccs.CONST_A_X] * this._positionReadScale;
        a.y = b[ccs.CONST_A_Y] * this._positionReadScale;
        a.x *= c.contentScale;
        a.y *= c.contentScale;
        a.zOrder = b[ccs.CONST_A_Z];
        a.skewX = b[ccs.CONST_A_SKEW_X] || 0;
        a.skewY = b[ccs.CONST_A_SKEW_Y] || 0;
        a.scaleX = null == b[ccs.CONST_A_SCALE_X] ? 1 : b[ccs.CONST_A_SCALE_X];
        a.scaleY = null == b[ccs.CONST_A_SCALE_Y] ? 1 : b[ccs.CONST_A_SCALE_Y];
        if (b = c.cocoStudioVersion <
            ccs.VERSION_COLOR_READING ? b[0] : b[ccs.CONST_COLOR_INFO] || null) a.a = null == b[ccs.CONST_A_ALPHA] ? 255 : b[ccs.CONST_A_ALPHA], a.r = null == b[ccs.CONST_A_RED] ? 255 : b[ccs.CONST_A_RED], a.g = null == b[ccs.CONST_A_GREEN] ? 255 : b[ccs.CONST_A_GREEN], a.b = null == b[ccs.CONST_A_BLUE] ? 255 : b[ccs.CONST_A_BLUE], a.isUseColorInfo = !0
    },
    clear: function() {
        this._configFileList = [];
        this._asyncRefTotalCount = this._asyncRefCount = 0
    },
    _asyncCallBack: function(a, b, c) {
        a && cc.isFunction(a) && a.call(b, c);
        if (b && a && "string" === typeof a) b[a](c)
    },
    _initBaseFilePath: function(a) {
        var b =
            a.lastIndexOf("/");
        return a = -1 < b ? a.substr(0, b + 1) : ""
    },
    addDataFromXML: function(a, b) {
        var c = cc.loader.getRes(a);
        if (!c) throw "Please load the resource first : " + a;
        (c = cc.saxParser.parse(c).documentElement) && this.addDataFromCache(c, b)
    },
    addDataFromJson: function(a, b) {
        var c = cc.loader.getRes(a);
        this.addDataFromJsonCache(c, b)
    }
};
ccs.spriteFrameCacheHelper = {
    _textureAtlasDic: {},
    _imagePaths: [],
    addSpriteFrameFromFile: function(a, b) {
        cc.spriteFrameCache.addSpriteFrames(a, b)
    },
    getTextureAtlasWithTexture: function(a) {
        return null
    },
    clear: function() {
        this._textureAtlasDic = {};
        this._imagePaths = []
    }
};
ccs.TransformHelp = ccs.TransformHelp || ccs.Class.extend({});
ccs.TransformHelp.helpMatrix1 = cc.affineTransformMake(1, 0, 0, 1, 0, 0);
ccs.TransformHelp.helpMatrix2 = cc.affineTransformMake(1, 0, 0, 1, 0, 0);
ccs.TransformHelp.helpPoint1 = cc.p(0, 0);
ccs.TransformHelp.helpPoint2 = cc.p(0, 0);
ccs.TransformHelp.helpParentNode = {};
ccs.TransformHelp.transformFromParent = function(a, b) {
    this.nodeToMatrix(a, this.helpMatrix1);
    this.nodeToMatrix(b, this.helpMatrix2);
    this.helpMatrix2 = cc.affineTransformInvert(this.helpMatrix2);
    this.helpMatrix1 = cc.affineTransformConcat(this.helpMatrix1, this.helpMatrix2);
    this.matrixToNode(this.helpMatrix1, a)
};
ccs.TransformHelp.transformToParent = function(a, b) {
    this.nodeToMatrix(a, this.helpMatrix1);
    this.nodeToMatrix(b, this.helpMatrix2);
    this.helpMatrix1 = cc.affineTransformConcat(this.helpMatrix1, this.helpMatrix2);
    this.matrixToNode(this.helpMatrix1, a)
};
ccs.TransformHelp.transformFromParentWithoutScale = function(a, b) {
    for (var c in b) this.helpParentNode[c] = b[c];
    this.helpParentNode.scaleX = 1;
    this.helpParentNode.scaleY = 1;
    this.nodeToMatrix(a, this.helpMatrix1);
    this.nodeToMatrix(this.helpParentNode, this.helpMatrix2);
    this.helpMatrix2 = cc.affineTransformInvert(this.helpMatrix2);
    this.helpMatrix1 = cc.affineTransformConcat(this.helpMatrix1, this.helpMatrix2);
    this.matrixToNode(this.helpMatrix1, a)
};
ccs.TransformHelp.transformToParentWithoutScale = function(a, b) {
    for (var c in b) this.helpParentNode[c] = b[c];
    this.helpParentNode.scaleX = 1;
    this.helpParentNode.scaleY = 1;
    this.nodeToMatrix(a, this.helpMatrix1);
    this.nodeToMatrix(this.helpParentNode, this.helpMatrix2);
    this.helpMatrix1 = cc.affineTransformConcat(this.helpMatrix1, this.helpMatrix2);
    this.matrixToNode(this.helpMatrix1, a)
};
ccs.TransformHelp.nodeToMatrix = function(a, b) {
    if (a.skewX == -a.skewY) {
        var c = Math.sin(a.skewX),
            d = Math.cos(a.skewX);
        b.a = a.scaleX * d;
        b.b = a.scaleX * -c;
        b.c = a.scaleY * c;
        b.d = a.scaleY * d
    } else b.a = a.scaleX * Math.cos(a.skewY), b.b = a.scaleX * Math.sin(a.skewY), b.c = a.scaleY * Math.sin(a.skewX), b.d = a.scaleY * Math.cos(a.skewX);
    b.tx = a.x;
    b.ty = a.y
};
ccs.TransformHelp.matrixToNode = function(a, b) {
    this.helpPoint1.x = 0;
    this.helpPoint1.y = 1;
    this.helpPoint1 = cc.pointApplyAffineTransform(this.helpPoint1, a);
    this.helpPoint1.x -= a.tx;
    this.helpPoint1.y -= a.ty;
    this.helpPoint2.x = 1;
    this.helpPoint2.y = 0;
    this.helpPoint2 = cc.pointApplyAffineTransform(this.helpPoint2, a);
    this.helpPoint2.x -= a.tx;
    this.helpPoint2.y -= a.ty;
    b.skewX = -(Math.atan2(this.helpPoint1.y, this.helpPoint1.x) - 1.5707964);
    b.skewY = Math.atan2(this.helpPoint2.y, this.helpPoint2.x);
    b.scaleX = Math.sqrt(a.a * a.a +
        a.b * a.b);
    b.scaleY = Math.sqrt(a.c * a.c + a.d * a.d);
    b.x = a.tx;
    b.y = a.ty
};
ccs.TransformHelp.nodeConcat = function(a, b) {
    a.x += b.x;
    a.y += b.y;
    a.skewX += b.skewX;
    a.skewY += b.skewY;
    a.scaleX += b.scaleX;
    a.scaleY += b.scaleY
};
ccs.TransformHelp.nodeSub = function(a, b) {
    a.x -= b.x;
    a.y -= b.y;
    a.skewX -= b.skewX;
    a.skewY -= b.skewY;
    a.scaleX -= b.scaleX;
    a.scaleY -= b.scaleY
};
ccs.TweenType = {
    customEasing: -1,
    linear: 0,
    sineEaseIn: 1,
    sineEaseOut: 2,
    sineEaseInOut: 3,
    quadEaseIn: 4,
    quadEaseOut: 5,
    quadEaseInOut: 6,
    cubicEaseIn: 7,
    cubicEaseOut: 8,
    cubicEaseInOut: 9,
    quartEaseIn: 10,
    quartEaseOut: 11,
    quartEaseInOut: 12,
    quintEaseIn: 13,
    quintEaseOut: 14,
    quintEaseInOut: 15,
    expoEaseIn: 16,
    expoEaseOut: 17,
    expoEaseInOut: 18,
    circEaseIn: 19,
    eircEaseOut: 20,
    circEaseInOut: 21,
    elasticEaseIn: 22,
    elasticEaseOut: 23,
    elasticEaseInOut: 24,
    backEaseIn: 25,
    backEaseOut: 26,
    backEaseInOut: 27,
    bounceEaseIn: 28,
    bounceEaseOut: 29,
    bounceEaseInOut: 30,
    tweenEasingMax: 1E4
};
ccs.TweenFunction = ccs.TweenFunction || ccs.Class.extend({});
ccs.DOUBLE_PI = ccs.M_PI_X_2 = 2 * Math.PI;
ccs.HALF_PI = ccs.M_PI_2 = Math.PI / 2;
ccs.M_PI = Math.PI;
ccs.TweenFunction.tweenTo = function(a, b, c) {
    var d = 0;
    switch (b) {
        case ccs.TweenType.customEasing:
            d = this.customEase(a, c);
            break;
        case ccs.TweenType.linear:
            d = this.linear(a);
            break;
        case ccs.TweenType.sineEaseIn:
            d = this.sineEaseIn(a);
            break;
        case ccs.TweenType.sineEaseOut:
            d = this.sineEaseOut(a);
            break;
        case ccs.TweenType.sineEaseInOut:
            d = this.sineEaseInOut(a);
            break;
        case ccs.TweenType.quadEaseIn:
            d = this.quadEaseIn(a);
            break;
        case ccs.TweenType.quadEaseOut:
            d = this.quadEaseOut(a);
            break;
        case ccs.TweenType.quadEaseInOut:
            d = this.quadEaseInOut(a);
            break;
        case ccs.TweenType.cubicEaseIn:
            d = this.cubicEaseIn(a);
            break;
        case ccs.TweenType.cubicEaseOut:
            d = this.cubicEaseOut(a);
            break;
        case ccs.TweenType.cubicEaseInOut:
            d = this.cubicEaseInOut(a);
            break;
        case ccs.TweenType.quartEaseIn:
            d = this.quartEaseIn(a);
            break;
        case ccs.TweenType.quartEaseOut:
            d = this.quartEaseOut(a);
            break;
        case ccs.TweenType.quartEaseInOut:
            d = this.quartEaseInOut(a);
            break;
        case ccs.TweenType.quintEaseIn:
            d = this.quintEaseIn(a);
            break;
        case ccs.TweenType.quintEaseOut:
            d = this.quintEaseOut(a);
            break;
        case ccs.TweenType.quintEaseInOut:
            d =
                this.quintEaseInOut(a);
            break;
        case ccs.TweenType.expoEaseIn:
            d = this.expoEaseIn(a);
            break;
        case ccs.TweenType.expoEaseOut:
            d = this.expoEaseOut(a);
            break;
        case ccs.TweenType.expoEaseInOut:
            d = this.expoEaseInOut(a);
            break;
        case ccs.TweenType.circEaseIn:
            d = this.circEaseIn(a);
            break;
        case ccs.TweenType.eircEaseOut:
            d = this.circEaseOut(a);
            break;
        case ccs.TweenType.circEaseInOut:
            d = this.circEaseInOut(a);
            break;
        case ccs.TweenType.elasticEaseIn:
            b = 0.3;
            null != c && 0 < c.length && (b = c[0]);
            d = this.elasticEaseIn(a, b);
            break;
        case ccs.TweenType.elasticEaseOut:
            b =
                0.3;
            null != c && 0 < c.length && (b = c[0]);
            d = this.elasticEaseOut(a, b);
            break;
        case ccs.TweenType.elasticEaseInOut:
            b = 0.3;
            null != c && 0 < c.length && (b = c[0]);
            d = this.elasticEaseInOut(a, b);
            break;
        case ccs.TweenType.backEaseIn:
            d = this.backEaseIn(a);
            break;
        case ccs.TweenType.backEaseOut:
            d = this.backEaseOut(a);
            break;
        case ccs.TweenType.backEaseInOut:
            d = this.backEaseInOut(a);
            break;
        case ccs.TweenType.bounceEaseIn:
            d = this.bounceEaseIn(a);
            break;
        case ccs.TweenType.bounceEaseOut:
            d = this.bounceEaseOut(a);
            break;
        case ccs.TweenType.bounceEaseInOut:
            d =
                this.bounceEaseInOut(a);
            break;
        default:
            d = this.sineEaseInOut(a)
    }
    return d
};
ccs.TweenFunction.linear = function(a) {
    return a
};
ccs.TweenFunction.sineEaseIn = function(a) {
    return -1 * Math.cos(a * ccs.HALF_PI) + 1
};
ccs.TweenFunction.sineEaseOut = function(a) {
    return Math.sin(a * ccs.HALF_PI)
};
ccs.TweenFunction.sineEaseInOut = function(a) {
    return -0.5 * (Math.cos(ccs.M_PI * a) - 1)
};
ccs.TweenFunction.quadEaseIn = function(a) {
    return a * a
};
ccs.TweenFunction.quadEaseOut = function(a) {
    return -1 * a * (a - 2)
};
ccs.TweenFunction.quadEaseInOut = function(a) {
    a *= 2;
    if (1 > a) return 0.5 * a * a;
    --a;
    return -0.5 * (a * (a - 2) - 1)
};
ccs.TweenFunction.cubicEaseIn = function(a) {
    return a * a * a
};
ccs.TweenFunction.cubicEaseOut = function(a) {
    a -= 1;
    return a * a * a + 1
};
ccs.TweenFunction.cubicEaseInOut = function(a) {
    a *= 2;
    if (1 > a) return 0.5 * a * a * a;
    a -= 2;
    return 0.5 * (a * a * a + 2)
};
ccs.TweenFunction.quartEaseIn = function(a) {
    return a * a * a * a
};
ccs.TweenFunction.quartEaseOut = function(a) {
    a -= 1;
    return -(a * a * a * a - 1)
};
ccs.TweenFunction.quartEaseInOut = function(a) {
    a *= 2;
    if (1 > a) return 0.5 * a * a * a * a;
    a -= 2;
    return -0.5 * (a * a * a * a - 2)
};
ccs.TweenFunction.quintEaseIn = function(a) {
    return a * a * a * a * a
};
ccs.TweenFunction.quintEaseOut = function(a) {
    a -= 1;
    return a * a * a * a * a + 1
};
ccs.TweenFunction.quintEaseInOut = function(a) {
    a *= 2;
    if (1 > a) return 0.5 * a * a * a * a * a;
    a -= 2;
    return 0.5 * (a * a * a * a * a + 2)
};
ccs.TweenFunction.expoEaseIn = function(a) {
    return 0 == a ? 0 : Math.pow(2, 10 * (a - 1)) - 0.0010
};
ccs.TweenFunction.expoEaseOut = function(a) {
    return 1 == a ? 1 : -Math.pow(2, -10 * a) + 1
};
ccs.TweenFunction.expoEaseInOut = function(a) {
    a /= 0.5;
    return a = 1 > a ? 0.5 * Math.pow(2, 10 * (a - 1)) : 0.5 * (-Math.pow(2, -10 * (a - 1)) + 2)
};
ccs.TweenFunction.circEaseIn = function(a) {
    return -1 * (Math.sqrt(1 - a * a) - 1)
};
ccs.TweenFunction.circEaseOut = function(a) {
    a -= 1;
    return Math.sqrt(1 - a * a)
};
ccs.TweenFunction.circEaseInOut = function(a) {
    a *= 2;
    if (1 > a) return -0.5 * (Math.sqrt(1 - a * a) - 1);
    a -= 2;
    return 0.5 * (Math.sqrt(1 - a * a) + 1)
};
ccs.TweenFunction.elasticEaseIn = function(a, b) {
    var c = 0.3;
    0 < b.length && (c = b[0]);
    var d = 0;
    0 == a || 1 == a ? d = a : (d = c / 4, a -= 1, d = -Math.pow(2, 10 * a) * Math.sin((a - d) * ccs.DOUBLE_PI / c));
    return d
};
ccs.TweenFunction.elasticEaseOut = function(a, b) {
    var c = 0.3;
    0 < b.length && (c = b[0]);
    var d = 0;
    0 == a || 1 == a ? d = a : (d = c / 4, d = Math.pow(2, -10 * a) * Math.sin((a - d) * ccs.DOUBLE_PI / c) + 1);
    return d
};
ccs.TweenFunction.elasticEaseInOut = function(a, b) {
    var c = 0.3;
    0 < b.length && (c = b[0]);
    var d = 0;
    0 == a || 1 == a ? d = a : (c || (c = 0.3 * 1.5), d = c / 4, a = 2 * a - 1, d = 0 > a ? -0.5 * Math.pow(2, 10 * a) * Math.sin((a - d) * ccs.DOUBLE_PI / c) : 0.5 * Math.pow(2, -10 * a) * Math.sin((a - d) * ccs.DOUBLE_PI / c) + 1);
    return d
};
ccs.TweenFunction.backEaseIn = function(a) {
    return a * a * (2.70158 * a - 1.70158)
};
ccs.TweenFunction.backEaseOut = function(a) {
    a -= 1;
    return a * a * (2.70158 * a + 1.70158) + 1
};
ccs.TweenFunction.backEaseInOut = function(a) {
    a *= 2;
    if (1 > a) return a * a * (3.5949095 * a - 2.5949095) / 2;
    a -= 2;
    return a * a * (3.5949095 * a + 2.5949095) / 2 + 1
};
ccs.bounceTime = function(a) {
    if (a < 1 / 2.75) return 7.5625 * a * a;
    if (a < 2 / 2.75) return a -= 1.5 / 2.75, 7.5625 * a * a + 0.75;
    if (a < 2.5 / 2.75) return a -= 2.25 / 2.75, 7.5625 * a * a + 0.9375;
    a -= 2.625 / 2.75;
    return 7.5625 * a * a + 0.984375
};
ccs.TweenFunction.bounceEaseIn = function(a) {
    return 1 - ccs.bounceTime(1 - a)
};
ccs.TweenFunction.bounceEaseOut = function(a) {
    return ccs.bounceTime(a)
};
ccs.TweenFunction.bounceEaseInOut = function(a) {
    var b = 0;
    return b = 0.5 > a ? 0.5 * (1 - ccs.bounceTime(1 - 2 * a)) : 0.5 * ccs.bounceTime(2 * a - 1) + 0.5
};
ccs.TweenFunction.customEase = function(a, b) {
    if (0 < b.length) {
        var c = 1 - a;
        return b[1] * c * c * c + 3 * b[3] * a * c * c + 3 * b[5] * a * a * c + b[7] * a * a * a
    }
    return a
};
ccs.TweenFunction.easeIn = function(a, b) {
    return Math.pow(a, b)
};
ccs.TweenFunction.easeOut = function(a, b) {
    return Math.pow(a, 1 / b)
};
ccs.TweenFunction.easeInOut = function(a, b) {
    a *= 2;
    return 1 > a ? 0.5 * Math.pow(a, b) : 1 - 0.5 * Math.pow(2 - a, b)
};
ccs.TweenFunction.quadraticIn = function(a) {
    return Math.pow(a, 2)
};
ccs.TweenFunction.quadraticOut = function(a) {
    return -a * (a - 2)
};
ccs.TweenFunction.bezieratFunction = function(a, b, c, d, e) {
    return Math.pow(1 - e, 3) * a + 3 * e * Math.pow(1 - e, 2) * b + 3 * Math.pow(e, 2) * (1 - e) * c + Math.pow(e, 3) * d
};
var ENABLE_PHYSICS_DETECT = !1;
ccs.fmodf = function(a, b) {
    for (; a > b;) a -= b;
    return a
};
var CC_SAFE_RELEASE = function(a) {
    a && a.release && a.release()
};
ccs.isSpriteContainPoint = function(a, b, c) {
    b = a.convertToNodeSpace(b);
    c && (c.x = b.x, c.y = b.y);
    a = a.getContentSize();
    return cc.rectContainsPoint(cc.rect(0, 0, a.width, a.height), b)
};
ccs.SPRITE_CONTAIN_POINT = ccs.isSpriteContainPoint;
ccs.SPRITE_CONTAIN_POINT_WITH_RETURN = ccs.isSpriteContainPoint;
ccs.extBezierTo = function(a, b, c, d, e) {
    var f = cc.p(0, 0);
    d && !e && (f.x = Math.pow(1 - a, 2) * b.x + 2 * a * (1 - a) * c.x + Math.pow(a, 2) * d.x, f.y = Math.pow(1 - a, 2) * b.y + 2 * a * (1 - a) * c.y + Math.pow(a, 2) * d.y);
    e && (f.x = b.x * Math.pow(1 - a, 3) + 3 * a * c.x * Math.pow(1 - a, 2) + 3 * d.x * Math.pow(a, 2) * (1 - a) + e.x * Math.pow(a, 3), f.y = b.y * Math.pow(1 - a, 3) + 3 * a * c.y * Math.pow(1 - a, 2) + 3 * d.y * Math.pow(a, 2) * (1 - a) + e.y * Math.pow(a, 3));
    return f
};
ccs.extCircleTo = function(a, b, c, d, e) {
    var f = cc.p(0, 0);
    f.x = b.x + c * Math.cos(d + e * a);
    f.y = b.y + c * Math.sin(d + e * a);
    return f
};
ccs.RelativeData = function() {
    this.plistFiles = [];
    this.armatures = [];
    this.animations = [];
    this.textures = []
};
ccs.armatureDataManager = {
    _animationDatas: {},
    _armatureDatas: {},
    _textureDatas: {},
    _autoLoadSpriteFile: !1,
    _relativeDatas: {},
    s_sharedArmatureDataManager: null,
    removeArmatureFileInfo: function(a) {
        var b = this.getRelativeData(a);
        if (b) {
            var c, d;
            for (c = 0; c < b.armatures.length; c++) d = b.armatures[c], this.removeArmatureData(d);
            for (c = 0; c < b.animations.length; c++) d = b.animations[c], this.removeAnimationData(d);
            for (c = 0; c < b.textures.length; c++) d = b.textures[c], this.removeTextureData(d);
            for (c = 0; c < b.plistFiles.length; c++) d = b.plistFiles[c],
                cc.spriteFrameCache.removeSpriteFramesFromFile(d);
            delete this._relativeDatas[a];
            ccs.dataReaderHelper.removeConfigFile(a)
        }
    },
    addArmatureData: function(a, b, c) {
        (c = this.getRelativeData(c)) && c.armatures.push(a);
        this._armatureDatas[a] = b
    },
    getArmatureData: function(a) {
        var b = null;
        this._armatureDatas && (b = this._armatureDatas[a]);
        return b
    },
    removeArmatureData: function(a) {
        this._armatureDatas[a] && delete this._armatureDatas[a]
    },
    addAnimationData: function(a, b, c) {
        (c = this.getRelativeData(c)) && c.animations.push(a);
        this._animationDatas[a] =
            b
    },
    getAnimationData: function(a) {
        var b = null;
        this._animationDatas[a] && (b = this._animationDatas[a]);
        return b
    },
    removeAnimationData: function(a) {
        this._animationDatas[a] && delete this._animationDatas[a]
    },
    addTextureData: function(a, b, c) {
        (c = this.getRelativeData(c)) && c.textures.push(a);
        this._textureDatas[a] = b
    },
    getTextureData: function(a) {
        var b = null;
        this._textureDatas && (b = this._textureDatas[a]);
        return b
    },
    removeTextureData: function(a) {
        this._textureDatas[a] && delete this._textureDatas[a]
    },
    addArmatureFileInfo: function() {
        var a,
            b, c;
        switch (arguments.length) {
            case 1:
                c = arguments[0];
                this.addRelativeData(c);
                this._autoLoadSpriteFile = !0;
                ccs.dataReaderHelper.addDataFromFile(c);
                break;
            case 3:
                a = arguments[0], b = arguments[1], c = arguments[2], this.addRelativeData(c), this._autoLoadSpriteFile = !1, ccs.dataReaderHelper.addDataFromFile(c), this.addSpriteFrameFromFile(b, a)
        }
    },
    addArmatureFileInfoAsync: function() {
        var a, b, c, d, e;
        switch (arguments.length) {
            case 3:
                c = arguments[0];
                d = arguments[2];
                e = arguments[1];
                this.addRelativeData(c);
                this._autoLoadSpriteFile = !0;
                ccs.dataReaderHelper.addDataFromFileAsync("", "", c, e, d);
                break;
            case 5:
                a = arguments[0], b = arguments[1], c = arguments[2], d = arguments[4], e = arguments[3], this.addRelativeData(c), this._autoLoadSpriteFile = !1, ccs.dataReaderHelper.addDataFromFileAsync(a, b, c, e, d), this.addSpriteFrameFromFile(b, a)
        }
    },
    addSpriteFrameFromFile: function(a, b, c) {
        (c = this.getRelativeData(c)) && c.plistFiles.push(a);
        ccs.spriteFrameCacheHelper.addSpriteFrameFromFile(a, b)
    },
    isAutoLoadSpriteFile: function() {
        return this._autoLoadSpriteFile
    },
    getArmatureDatas: function() {
        return this._armatureDatas
    },
    getAnimationDatas: function() {
        return this._animationDatas
    },
    getTextureDatas: function() {
        return this._textureDatas
    },
    addRelativeData: function(a) {
        this._relativeDatas[a] || (this._relativeDatas[a] = new ccs.RelativeData)
    },
    getRelativeData: function(a) {
        return this._relativeDatas[a]
    },
    clear: function() {
        this._animationDatas = {};
        this._armatureDatas = {};
        this._textureDatas = {};
        ccs.spriteFrameCacheHelper.clear();
        ccs.dataReaderHelper.clear()
    }
};
ccs.BLEND_TYPE_NORMAL = 0;
ccs.BLEND_TYPE_LAYER = 1;
ccs.BLEND_TYPE_DARKEN = 2;
ccs.BLEND_TYPE_MULTIPLY = 3;
ccs.BLEND_TYPE_LIGHTEN = 4;
ccs.BLEND_TYPE_SCREEN = 5;
ccs.BLEND_TYPE_OVERLAY = 6;
ccs.BLEND_TYPE_HIGHLIGHT = 7;
ccs.BLEND_TYPE_ADD = 8;
ccs.BLEND_TYPE_SUBTRACT = 9;
ccs.BLEND_TYPE_DIFFERENCE = 10;
ccs.BLEND_TYPE_INVERT = 11;
ccs.BLEND_TYPE_ALPHA = 12;
ccs.BLEND_TYPE_ERASE = 13;
ccs.DISPLAY_TYPE_SPRITE = 0;
ccs.DISPLAY_TYPE_ARMATURE = 1;
ccs.DISPLAY_TYPE_PARTICLE = 2;
ccs.DISPLAY_TYPE_MAX = 3;
ccs.BaseData = ccs.Class.extend({
    x: 0,
    y: 0,
    zOrder: 0,
    skewX: 0,
    skewY: 0,
    scaleX: 1,
    scaleY: 1,
    tweenRotate: 0,
    isUseColorInfo: !1,
    r: 255,
    g: 255,
    b: 255,
    a: 255,
    ctor: function() {
        this.skewY = this.skewX = this.zOrder = this.y = this.x = 0;
        this.scaleY = this.scaleX = 1;
        this.tweenRotate = 0;
        this.isUseColorInfo = !1;
        this.a = this.b = this.g = this.r = 255
    },
    copy: function(a) {
        this.x = a.x;
        this.y = a.y;
        this.zOrder = a.zOrder;
        this.scaleX = a.scaleX;
        this.scaleY = a.scaleY;
        this.skewX = a.skewX;
        this.skewY = a.skewY;
        this.tweenRotate = a.tweenRotate;
        this.isUseColorInfo = a.isUseColorInfo;
        this.r = a.r;
        this.g = a.g;
        this.b = a.b;
        this.a = a.a
    },
    setColor: function(a) {
        this.r = a.r;
        this.g = a.g;
        this.b = a.b;
        this.a = a.a
    },
    getColor: function() {
        return cc.color(this.r, this.g, this.b, this.a)
    },
    subtract: function(a, b, c) {
        this.x = b.x - a.x;
        this.y = b.y - a.y;
        this.scaleX = b.scaleX - a.scaleX;
        this.scaleY = b.scaleY - a.scaleY;
        this.skewX = b.skewX - a.skewX;
        this.skewY = b.skewY - a.skewY;
        this.isUseColorInfo || a.isUseColorInfo || b.isUseColorInfo ? (this.a = b.a - a.a, this.r = b.r - a.r, this.g = b.g - a.g, this.b = b.b - a.b, this.isUseColorInfo = !0) : (this.a = this.r =
            this.g = this.b = 0, this.isUseColorInfo = !1);
        c && (this.skewX > ccs.M_PI && (this.skewX -= ccs.DOUBLE_PI), this.skewX < -ccs.M_PI && (this.skewX += ccs.DOUBLE_PI), this.skewY > ccs.M_PI && (this.skewY -= ccs.DOUBLE_PI), this.skewY < -ccs.M_PI && (this.skewY += ccs.DOUBLE_PI));
        b.tweenRotate && (this.skewX += 2 * b.tweenRotate * ccs.PI, this.skewY -= 2 * b.tweenRotate * ccs.PI)
    }
});
ccs.DisplayData = ccs.Class.extend({
    displayType: ccs.DISPLAY_TYPE_MAX,
    displayName: "",
    ctor: function() {
        this.displayType = ccs.DISPLAY_TYPE_MAX
    },
    changeDisplayToTexture: function(a) {
        var b = a.lastIndexOf("."); - 1 != b && (a = a.substring(0, b));
        return a
    },
    copy: function(a) {
        this.displayName = a.displayName;
        this.displayType = a.displayType
    }
});
ccs.SpriteDisplayData = ccs.DisplayData.extend({
    skinData: null,
    ctor: function() {
        this.skinData = new ccs.BaseData;
        this.displayType = ccs.DISPLAY_TYPE_SPRITE
    },
    copy: function(a) {
        ccs.DisplayData.prototype.copy.call(this, a);
        this.skinData = a.skinData
    }
});
ccs.ArmatureDisplayData = ccs.DisplayData.extend({
    ctor: function() {
        this.displayName = "";
        this.displayType = ccs.DISPLAY_TYPE_ARMATURE
    }
});
ccs.ParticleDisplayData = ccs.DisplayData.extend({
    ctor: function() {
        this.displayType = ccs.DISPLAY_TYPE_PARTICLE
    }
});
ccs.BoneData = ccs.BaseData.extend({
    displayDataList: null,
    name: "",
    parentName: "",
    boneDataTransform: null,
    ctor: function() {
        this.displayDataList = [];
        this.parentName = this.name = "";
        this.boneDataTransform = null
    },
    init: function() {
        this.displayDataList.length = 0;
        return !0
    },
    addDisplayData: function(a) {
        this.displayDataList.push(a)
    },
    getDisplayData: function(a) {
        return this.displayDataList[a]
    }
});
ccs.ArmatureData = ccs.Class.extend({
    boneDataDic: null,
    name: "",
    dataVersion: 0.1,
    ctor: function() {
        this.boneDataDic = {};
        this.name = "";
        this.dataVersion = 0.1
    },
    init: function() {
        return !0
    },
    addBoneData: function(a) {
        this.boneDataDic[a.name] = a
    },
    getBoneDataDic: function() {
        return this.boneDataDic
    },
    getBoneData: function(a) {
        return this.boneDataDic[a]
    }
});
ccs.FrameData = ccs.BaseData.extend({
    duration: 0,
    tweenEasing: 0,
    easingParamNumber: 0,
    easingParams: null,
    displayIndex: -1,
    movement: "",
    event: "",
    sound: "",
    soundEffect: "",
    blendFunc: null,
    frameID: 0,
    isTween: !0,
    ctor: function() {
        ccs.BaseData.prototype.ctor.call(this);
        this.duration = 1;
        this.tweenEasing = ccs.TweenType.linear;
        this.easingParamNumber = 0;
        this.easingParams = [];
        this.displayIndex = 0;
        this.soundEffect = this.sound = this.event = this.movement = "";
        this.blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
        this.frameID = 0;
        this.isTween = !0
    },
    copy: function(a) {
        ccs.BaseData.prototype.copy.call(this, a);
        this.duration = a.duration;
        this.displayIndex = a.displayIndex;
        this.tweenEasing = a.tweenEasing;
        this.easingParamNumber = a.easingParamNumber;
        if (0 != this.easingParamNumber)
            for (var b = this.easingParams.length = 0; b < this.easingParamNumber; b++) this.easingParams[b] = a.easingParams[b];
        this.blendFunc = a.blendFunc;
        this.isTween = a.isTween
    }
});
ccs.MovementBoneData = ccs.Class.extend({
    delay: 0,
    scale: 1,
    duration: 0,
    frameList: null,
    name: "",
    ctor: function() {
        this.delay = 0;
        this.scale = 1;
        this.duration = 0;
        this.frameList = [];
        this.name = ""
    },
    init: function() {
        return !0
    },
    addFrameData: function(a) {
        this.frameList.push(a)
    },
    getFrameData: function(a) {
        return this.frameList[a]
    }
});
ccs.MovementData = function() {
    this.name = "";
    this.duration = 0;
    this.scale = 1;
    this.durationTween = this.durationTo = 0;
    this.loop = !0;
    this.tweenEasing = ccs.TweenType.linear;
    this.movBoneDataDic = {}
};
ccs.MovementData.prototype.addMovementBoneData = function(a) {
    this.movBoneDataDic[a.name] = a
};
ccs.MovementData.prototype.getMovementBoneData = function(a) {
    return this.movBoneDataDic[a]
};
ccs.AnimationData = function() {
    this.movementDataDic = {};
    this.movementNames = [];
    this.name = ""
};
ccs.AnimationData.prototype.addMovement = function(a) {
    this.movementDataDic[a.name] = a;
    this.movementNames.push(a.name)
};
ccs.AnimationData.prototype.getMovement = function(a) {
    return this.movementDataDic[a]
};
ccs.AnimationData.prototype.getMovementCount = function() {
    return Object.keys(this.movementDataDic).length
};
ccs.ContourVertex2 = function(a, b) {
    this.x = a || 0;
    this.y = b || 0
};
ccs.ContourData = function() {
    this.vertexList = []
};
ccs.ContourData.prototype.init = function() {
    this.vertexList.length = 0;
    return !0
};
ccs.ContourData.prototype.addVertex = function(a) {
    this.vertexList.push(a)
};
ccs.TextureData = function() {
    this.width = this.height = 0;
    this.pivotY = this.pivotX = 0.5;
    this.name = "";
    this.contourDataList = []
};
ccs.TextureData.prototype.init = function() {
    this.contourDataList.length = 0
};
ccs.TextureData.prototype.addContourData = function(a) {
    this.contourDataList.push(a)
};
ccs.TextureData.prototype.getContourData = function(a) {
    return this.contourDataList[a]
};
ccs.DecorativeDisplay = ccs.Class.extend({
    _display: null,
    _colliderDetector: null,
    _displayData: null,
    ctor: function() {
        this._displayData = this._colliderDetector = this._display = null
    },
    init: function() {
        return !0
    },
    setDisplay: function(a) {
        a._parent && (a._parent.removeChild(a), delete a._parent);
        this._display = a
    },
    getDisplay: function() {
        return this._display
    },
    setColliderDetector: function(a) {
        this._colliderDetector = a
    },
    getColliderDetector: function() {
        return this._colliderDetector
    },
    setDisplayData: function(a) {
        this._displayData =
            a
    },
    getDisplayData: function() {
        return this._displayData
    },
    release: function() {
        this._colliderDetector = this._displayData = this._display = null
    }
});
ccs.DecorativeDisplay.create = function() {
    return new ccs.DecorativeDisplay
};
ccs.displayFactory = {
    addDisplay: function(a, b, c) {
        switch (c.displayType) {
            case ccs.DISPLAY_TYPE_SPRITE:
                this.addSpriteDisplay(a, b, c);
                break;
            case ccs.DISPLAY_TYPE_PARTICLE:
                this.addParticleDisplay(a, b, c);
                break;
            case ccs.DISPLAY_TYPE_ARMATURE:
                this.addArmatureDisplay(a, b, c)
        }
    },
    createDisplay: function(a, b) {
        switch (b.getDisplayData().displayType) {
            case ccs.DISPLAY_TYPE_SPRITE:
                this.createSpriteDisplay(a, b);
                break;
            case ccs.DISPLAY_TYPE_PARTICLE:
                this.createParticleDisplay(a, b);
                break;
            case ccs.DISPLAY_TYPE_ARMATURE:
                this.createArmatureDisplay(a,
                    b)
        }
    },
    _helpTransform: {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
    },
    updateDisplay: function(a, b, c) {
        var d = a.getDisplayRenderNode();
        if (d) {
            switch (a.getDisplayRenderNodeType()) {
                case ccs.DISPLAY_TYPE_SPRITE:
                    c && d.updateArmatureTransform();
                    break;
                case ccs.DISPLAY_TYPE_PARTICLE:
                    this.updateParticleDisplay(a, d, b);
                    break;
                case ccs.DISPLAY_TYPE_ARMATURE:
                    this.updateArmatureDisplay(a, d, b);
                    break;
                default:
                    b = a.getNodeToArmatureTransform(), d.setAdditionalTransform(b)
            }
            if ((ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT || ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) &&
                c)
                if (d = a.getDisplayManager().getCurrentDecorativeDisplay(), c = d.getColliderDetector()) {
                    b = d.getDisplay();
                    var e = b.nodeToParentTransform(),
                        d = this._helpTransform;
                    d.a = e.a;
                    d.b = e.b;
                    d.c = e.c;
                    d.d = e.d;
                    d.tx = e.tx;
                    d.ty = e.ty;
                    b = cc.pointApplyAffineTransform(b.getAnchorPointInPoints(), d);
                    d.tx = b.x;
                    d.ty = b.y;
                    a = cc.affineTransformConcat(d, a.getArmature().nodeToParentTransform());
                    c.updateTransform(a)
                }
        }
    },
    addSpriteDisplay: function(a, b, c) {
        var d = new ccs.SpriteDisplayData;
        d.copy(c);
        b.setDisplayData(d);
        this.createSpriteDisplay(a,
            b)
    },
    createSpriteDisplay: function(a, b) {
        var c = null,
            d = b.getDisplayData(),
            c = d.displayName,
            e = c.lastIndexOf("."); - 1 != e && (c = c.substring(0, e));
        c = "" == c ? new ccs.Skin : new ccs.Skin("#" + c + ".png");
        b.setDisplay(c);
        null != c && (c.setBone(a), this.initSpriteDisplay(a, b, d.displayName, c), (e = a.getArmature()) && (e.getArmatureData().dataVersion >= ccs.CONST_VERSION_COMBINED ? c.setSkinData(d.skinData) : c.setSkinData(a.boneData)))
    },
    initSpriteDisplay: function(a, b, c, d) {
        var e = c.lastIndexOf("."); - 1 != e && (c = c.substring(0, e));
        (c = ccs.armatureDataManager.getTextureData(c)) &&
        d.setAnchorPoint(cc.p(c.pivotX, c.pivotY));
        if ((ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT || ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) && c && 0 < c.contourDataList.length) a = new ccs.ColliderDetector(a), a.addContourDataList(c.contourDataList), b.setColliderDetector(a)
    },
    addArmatureDisplay: function(a, b, c) {
        var d = new ccs.ArmatureDisplayData;
        d.copy(c);
        b.setDisplayData(d);
        this.createArmatureDisplay(a, b)
    },
    createArmatureDisplay: function(a, b) {
        var c = b.getDisplayData(),
            c = new ccs.Armature(c.displayName, a);
        b.setDisplay(c)
    },
    updateArmatureDisplay: function(a,
        b, c) {
        b && (b.sortAllChildren(), b.update(c))
    },
    addParticleDisplay: function(a, b, c) {
        var d = new ccs.ParticleDisplayData;
        d.copy(c);
        b.setDisplayData(d);
        this.createParticleDisplay(a, b)
    },
    createParticleDisplay: function(a, b) {
        var c = b.getDisplayData(),
            c = new cc.ParticleSystem(c.displayName);
        c.removeFromParent();
        c.cleanup();
        a.getArmature() && c.setParent(a.getArmature());
        b.setDisplay(c)
    },
    updateParticleDisplay: function(a, b, c) {
        var d = new ccs.BaseData;
        ccs.TransformHelp.matrixToNode(a.nodeToArmatureTransform(), d);
        b.setPosition(d.x,
            d.y);
        b.setScaleX(d.scaleX);
        b.setScaleY(d.scaleY);
        b.update(c)
    }
};
ccs.DisplayManager = ccs.Class.extend({
    _decoDisplayList: null,
    _currentDecoDisplay: null,
    _displayRenderNode: null,
    _displayIndex: null,
    _forceChangeDisplay: !1,
    _bone: null,
    _visible: !0,
    _displayType: null,
    ctor: function(a) {
        this._decoDisplayList = [];
        this._displayIndex = this._displayRenderNode = this._currentDecoDisplay = null;
        this._forceChangeDisplay = !1;
        this._bone = null;
        this._visible = !0;
        this._displayType = ccs.DISPLAY_TYPE_MAX;
        a && ccs.DisplayManager.prototype.init.call(this, a)
    },
    init: function(a) {
        this._bone = a;
        this.initDisplayList(a.getBoneData());
        return !0
    },
    addDisplay: function(a, b) {
        var c, d = this._decoDisplayList;
        0 <= b && b < d.length ? c = d[b] : (c = new ccs.DecorativeDisplay, d.push(c));
        if (a instanceof ccs.DisplayData) cc.displayFactory.addDisplay(this._bone, c, a);
        else {
            var e = null;
            if (a instanceof ccs.Skin) {
                a.setBone(this._bone);
                e = new ccs.SpriteDisplayData;
                ccs.displayFactory.initSpriteDisplay(this._bone, c, a.getDisplayName(), a);
                var f = c.getDisplayData();
                if (f instanceof ccs.SpriteDisplayData) a.setSkinData(f.skinData), e.skinData = f.skinData;
                else {
                    for (var f = !1, g =
                        d.length - 2; 0 <= g; g--) {
                        var h = d[g].getDisplayData();
                        if (h instanceof ccs.SpriteDisplayData) {
                            f = !0;
                            a.setSkinData(h.skinData);
                            e.skinData = h.skinData;
                            break
                        }
                    }
                    f || a.setSkinData(new ccs.BaseData)
                }
            } else a instanceof cc.ParticleSystem ? (e = new ccs.ParticleDisplayData, a.removeFromParent(), a.cleanup(), (d = this._bone.getArmature()) && a.setParent(d)) : a instanceof ccs.Armature ? (e = new ccs.ArmatureDisplayData, e.displayName = a.getName(), a.setParentBone(this._bone)) : e = new ccs.DisplayData;
            c.setDisplay(a);
            c.setDisplayData(e)
        }
        b ==
            this._displayIndex && (this._displayIndex = -1, this.changeDisplayWithIndex(b, !1))
    },
    _addDisplayOther: function(a, b) {
        var c = null;
        if (b instanceof ccs.Skin) {
            b.setBone(this._bone);
            c = new ccs.SpriteDisplayData;
            c.displayName = b.getDisplayName();
            ccs.displayFactory.initSpriteDisplay(this._bone, a, b.getDisplayName(), b);
            var d = a.getDisplayData();
            if (d instanceof ccs.SpriteDisplayData) b.setSkinData(d.skinData);
            else {
                for (var d = !1, e = this._decoDisplayList.length - 2; 0 <= e; e--) {
                    var f = this._decoDisplayList[e].getDisplayData();
                    if (f) {
                        d = !0;
                        b.setSkinData(f.skinData);
                        c.skinData = f.skinData;
                        break
                    }
                }
                d || b.setSkinData(new ccs.BaseData);
                b.setSkinData(new ccs.BaseData)
            }
        } else b instanceof cc.ParticleSystem ? (c = new ccs.ParticleDisplayData, c.displayName = b._plistFile) : b instanceof ccs.Armature ? (c = new ccs.ArmatureDisplayData, c.displayName = b.getName(), b.setParentBone(this._bone)) : c = new ccs.DisplayData;
        a.setDisplay(b);
        a.setDisplayData(c)
    },
    removeDisplay: function(a) {
        this._decoDisplayList.splice(a, 1);
        a === this._displayIndex && (this.setCurrentDecorativeDisplay(null),
            this._displayIndex = -1)
    },
    getDecorativeDisplayList: function() {
        return this._decoDisplayList
    },
    changeDisplayWithIndex: function(a, b) {
        a >= this._decoDisplayList.length ? cc.log("the index value is out of range") : (this._forceChangeDisplay = b, this._displayIndex != a && (this._displayIndex = a, 0 > a ? this._displayRenderNode && (this._displayRenderNode.removeFromParent(!0), this.setCurrentDecorativeDisplay(null)) : this.setCurrentDecorativeDisplay(this._decoDisplayList[a])))
    },
    changeDisplayWithName: function(a, b) {
        for (var c = this._decoDisplayList,
            d = 0; d < c.length; d++)
            if (c[d].getDisplayData().displayName == a) {
                this.changeDisplayWithIndex(d, b);
                break
            }
    },
    setCurrentDecorativeDisplay: function(a) {
        var b = this._currentDecoDisplay;
        (ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT || ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) && b && b.getColliderDetector() && b.getColliderDetector().setActive(!1);
        b = this._currentDecoDisplay = a;
        (ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT || ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) && b && b.getColliderDetector() && b.getColliderDetector().setActive(!0);
        a = !b ? null :
            b.getDisplay();
        var b = this._displayRenderNode,
            c = this._bone;
        b && (b instanceof ccs.Armature && c.setChildArmature(null), b.removeFromParent(!0));
        (this._displayRenderNode = a) ? (a instanceof ccs.Armature ? (this._bone.setChildArmature(a), a.setParentBone(this._bone)) : a instanceof cc.ParticleSystem && (a instanceof ccs.Armature ? (c.setChildArmature(a), a.setParentBone(c)) : a instanceof cc.ParticleSystem && a.resetSystem()), a.setColor(c.getDisplayedColor()), a.setOpacity(c.getDisplayedOpacity()), this._displayRenderNode.setVisible(this._visible),
            this._displayType = this._currentDecoDisplay.getDisplayData().displayType) : this._displayType = ccs.DISPLAY_TYPE_MAX;
        cc.renderer.childrenOrderDirty = !0
    },
    getDisplayRenderNode: function() {
        return this._displayRenderNode
    },
    getDisplayRenderNodeType: function() {
        return this._displayType
    },
    getCurrentDisplayIndex: function() {
        return this._displayIndex
    },
    getCurrentDecorativeDisplay: function() {
        return this._currentDecoDisplay
    },
    getDecorativeDisplayByIndex: function(a) {
        return this._decoDisplayList[a]
    },
    initDisplayList: function(a) {
        this._decoDisplayList.length =
            0;
        if (a) {
            a = a.displayDataList;
            for (var b = this._decoDisplayList, c = this._bone, d = 0; d < a.length; d++) {
                var e = a[d],
                    f = new ccs.DecorativeDisplay;
                f.setDisplayData(e);
                ccs.displayFactory.createDisplay(c, f);
                b.push(f)
            }
        }
    },
    containPoint: function(a, b) {
        if (!this._visible || 0 > this._displayIndex) return !1;
        void 0 !== b && (a = cc.p(a, b));
        if (this._currentDecoDisplay.getDisplayData().displayType == ccs.DISPLAY_TYPE_SPRITE) {
            var c = this._currentDecoDisplay.getDisplay(),
                c = c.getChildByTag(0);
            return ccs.SPRITE_CONTAIN_POINT_WITH_RETURN(c, a)
        }
        return !1
    },
    setVisible: function(a) {
        this._displayRenderNode && (this._visible = a, this._displayRenderNode.setVisible(a))
    },
    isVisible: function() {
        return this._visible
    },
    getContentSize: function() {
        return !this._displayRenderNode ? cc.size(0, 0) : this._displayRenderNode.getContentSize()
    },
    getBoundingBox: function() {
        return !this._displayRenderNode ? cc.rect(0, 0, 0, 0) : this._displayRenderNode.getBoundingBox()
    },
    getAnchorPoint: function() {
        return !this._displayRenderNode ? cc.p(0, 0) : this._displayRenderNode.getAnchorPoint()
    },
    getAnchorPointInPoints: function() {
        return !this._displayRenderNode ?
            cc.p(0, 0) : this._displayRenderNode.getAnchorPointInPoints()
    },
    getForceChangeDisplay: function() {
        return this._forceChangeDisplay
    },
    release: function() {
        this._decoDisplayList = null;
        this._displayRenderNode && (this._displayRenderNode.removeFromParent(!0), this._displayRenderNode = null)
    }
});
ccs.DisplayManager.create = function(a) {
    return new ccs.DisplayManager(a)
};
ccs.Skin = ccs.Sprite.extend({
    _skinData: null,
    bone: null,
    _skinTransform: null,
    _displayName: "",
    _armature: null,
    _className: "Skin",
    ctor: function(a, b) {
        cc.Sprite.prototype.ctor.call(this);
        this.bone = this._skinData = null;
        this._displayName = "";
        this._skinTransform = cc.affineTransformIdentity();
        this._armature = null;
        null == a || "" == a ? ccs.Skin.prototype.init.call(this) : "#" == a[0] ? ccs.Skin.prototype.initWithSpriteFrameName.call(this, a.substr(1)) : ccs.Skin.prototype.initWithFile.call(this, a, b)
    },
    initWithSpriteFrameName: function(a) {
        if ("" ==
            a) return !1;
        var b = cc.spriteFrameCache.getSpriteFrame(a),
            c = !0;
        b ? this.initWithSpriteFrame(b) : (cc.log("Can't find CCSpriteFrame with %s. Please check your .plist file", a), c = !1);
        this._displayName = a;
        return c
    },
    initWithFile: function(a, b) {
        var c = b ? cc.Sprite.prototype.initWithFile.call(this, a, b) : cc.Sprite.prototype.initWithFile.call(this, a);
        this._displayName = a;
        return c
    },
    setSkinData: function(a) {
        this._skinData = a;
        this.setScaleX(a.scaleX);
        this.setScaleY(a.scaleY);
        this.setRotationX(cc.radiansToDegrees(a.skewX));
        this.setRotationY(cc.radiansToDegrees(-a.skewY));
        this.setPosition(a.x, a.y);
        a = this.getNodeToParentTransform ? this.getNodeToParentTransform() : this.nodeToParentTransform();
        var b = this._skinTransform;
        b.a = a.a;
        b.b = a.b;
        b.c = a.c;
        b.d = a.d;
        b.tx = a.tx;
        b.ty = a.ty;
        this.updateArmatureTransform()
    },
    getSkinData: function() {
        return this._skinData
    },
    updateArmatureTransform: function() {
        this._transform = cc.affineTransformConcat(this._skinTransform, this.bone.getNodeToArmatureTransform())
    },
    _updateTransformForWebGL: function() {
        var a =
            this._quad;
        if (this._visible) {
            var b = this.getNodeToParentTransform ? this.getNodeToParentTransform() : this.nodeToParentTransform(),
                c = this._rect,
                d = this._offsetPosition.x,
                e = this._offsetPosition.y,
                f = d + c.width,
                g = e + c.height,
                h = b.tx,
                k = b.ty,
                m = b.a,
                n = b.b,
                q = b.d,
                r = -b.c,
                b = d * m - e * r + h,
                c = d * n + e * q + k,
                s = f * m - e * r + h,
                e = f * n + e * q + k,
                t = f * m - g * r + h,
                f = f * n + g * q + k,
                h = d * m - g * r + h,
                d = d * n + g * q + k,
                g = this._vertexZ;
            cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (b |= 0, c |= 0, s |= 0, e |= 0, t |= 0, f |= 0, h |= 0, d |= 0);
            this.SET_VERTEX3F(a.bl.vertices, b, c, g);
            this.SET_VERTEX3F(a.br.vertices,
                s, e, g);
            this.SET_VERTEX3F(a.tl.vertices, h, d, g);
            this.SET_VERTEX3F(a.tr.vertices, t, f, g)
        } else a.br.vertices = a.tl.vertices = a.tr.vertices = a.bl.vertices = {
            x: 0,
            y: 0,
            z: 0
        };
        this._textureAtlas && this._textureAtlas.updateQuad(a, this._textureAtlas.getTotalQuads());
        this._quadDirty = !0
    },
    SET_VERTEX3F: function(a, b, c, d) {
        a.x = b;
        a.y = c;
        a.z = d
    },
    RENDER_IN_SUBPIXEL: function(a) {
        return cc.SPRITEBATCHNODE_RENDER_SUBPIXEL ? a : Math.ceil(a)
    },
    getNodeToWorldTransform: function() {
        return cc.affineTransformConcat(this._transform, this.bone.getArmature().getNodeToWorldTransform())
    },
    getNodeToWorldTransformAR: function() {
        var a = this._transform;
        this._anchorPointInPoints = cc.pointApplyAffineTransform(this._anchorPointInPoints, a);
        a.tx = this._anchorPointInPoints.x;
        a.ty = this._anchorPointInPoints.y;
        return cc.affineTransformConcat(a, this.bone.getArmature().nodeToWorldTransform())
    },
    setBone: function(a) {
        this.bone = a;
        if (a = this.bone.getArmature()) this._armature = a
    },
    getBone: function() {
        return this.bone
    },
    getDisplayName: function() {
        return this._displayName
    }
});
cc._renderType == cc._RENDER_TYPE_WEBGL && (ccs.Skin.prototype.updateTransform = ccs.Skin.prototype._updateTransformForWebGL);
_p = ccs.Skin.prototype;
cc.defineGetterSetter(_p, "skinData", _p.getSkinData, _p.setSkinData);
cc.defineGetterSetter(_p, "displayName", _p.getDisplayName);
_p = null;
ccs.Skin.create = function(a, b) {
    return new ccs.Skin(a, b)
};
ccs.Skin.createWithSpriteFrameName = function(a) {
    return new ccs.Skin("#" + a)
};
ccs.ANIMATION_TYPE_SINGLE_FRAME = -4;
ccs.ANIMATION_TYPE_NO_LOOP = -3;
ccs.ANIMATION_TYPE_TO_LOOP_FRONT = -2;
ccs.ANIMATION_TYPE_TO_LOOP_BACK = -1;
ccs.ANIMATION_TYPE_LOOP_FRONT = 0;
ccs.ANIMATION_TYPE_LOOP_BACK = 1;
ccs.ANIMATION_TYPE_MAX = 2;
ccs.ProcessBase = ccs.Class.extend({
    _processScale: 1,
    _isComplete: !0,
    _isPause: !0,
    _isPlaying: !1,
    _currentPercent: 0,
    _rawDuration: 0,
    _loopType: 0,
    _tweenEasing: 0,
    animationInternal: null,
    _currentFrame: 0,
    _durationTween: 0,
    _nextFrameIndex: 0,
    _curFrameIndex: null,
    _isLoopBack: !1,
    ctor: function() {
        this._processScale = 1;
        this._isPause = this._isComplete = !0;
        this._isPlaying = !1;
        this._rawDuration = this._durationTween = this._currentPercent = this._currentFrame = 0;
        this._loopType = ccs.ANIMATION_TYPE_LOOP_BACK;
        this._tweenEasing = ccs.TweenType.linear;
        this.animationInternal = 1 / 60;
        this._durationTween = this._curFrameIndex = 0;
        this._isLoopBack = !1
    },
    pause: function() {
        this._isPause = !0;
        this._isPlaying = !1
    },
    resume: function() {
        this._isPause = !1;
        this._isPlaying = !0
    },
    stop: function() {
        this._isComplete = !0;
        this._isPlaying = !1
    },
    play: function(a, b, c, d) {
        this._isPause = this._isComplete = !1;
        this._isPlaying = !0;
        this._currentFrame = 0;
        this._nextFrameIndex = a;
        this._tweenEasing = d
    },
    update: function(a) {
        if (!this._isComplete && !this._isPause && !(0 >= this._rawDuration || 1 < a)) {
            var b = void 0 === this._nextFrameIndex ?
                0 : this._nextFrameIndex,
                c = this._currentFrame;
            0 >= b ? (this._currentPercent = 1, c = 0) : (c += this._processScale * (a / this.animationInternal), this._currentPercent = c / b, c = ccs.fmodf(c, b));
            this._currentFrame = c;
            this.updateHandler()
        }
    },
    gotoFrame: function(a) {
        var b = this._loopType;
        b == ccs.ANIMATION_TYPE_NO_LOOP ? b = ccs.ANIMATION_TYPE_MAX : b == ccs.ANIMATION_TYPE_TO_LOOP_FRONT && (b = ccs.ANIMATION_TYPE_LOOP_FRONT);
        this._loopType = b;
        this._curFrameIndex = a;
        this._nextFrameIndex = this._durationTween
    },
    getCurrentFrameIndex: function() {
        return this._curFrameIndex =
            (this._rawDuration - 1) * this._currentPercent
    },
    updateHandler: function() {},
    isPause: function() {
        return this._isPause
    },
    isComplete: function() {
        return this._isComplete
    },
    getCurrentPercent: function() {
        return this._currentPercent
    },
    getRawDuration: function() {
        return this._rawDuration
    },
    getLoop: function() {
        return this._loopType
    },
    getTweenEasing: function() {
        return this._tweenEasing
    },
    getAnimationInternal: function() {
        return this.animationInternal
    },
    setAnimationInternal: function(a) {
        this.animationInternal = a
    },
    getProcessScale: function() {
        return this._processScale
    },
    setProcessScale: function(a) {
        this._processScale = a
    },
    isPlaying: function() {
        return this._isPlaying
    }
});
_p = ccs.ProcessBase.prototype;
cc.defineGetterSetter(_p, "currentFrameIndex", _p.getCurrentFrameIndex);
cc.defineGetterSetter(_p, "paused", _p.isPause);
cc.defineGetterSetter(_p, "completed", _p.isComplete);
cc.defineGetterSetter(_p, "currentPercent", _p.getCurrentPercent);
cc.defineGetterSetter(_p, "rawDuration", _p.getRawDuration);
cc.defineGetterSetter(_p, "loop", _p.getLoop);
cc.defineGetterSetter(_p, "tweenEasing", _p.getTweenEasing);
cc.defineGetterSetter(_p, "playing", _p.isPlaying);
_p = null;
ccs.MovementEventType = {
    start: 0,
    complete: 1,
    loopComplete: 2
};
ccs.AnimationEvent = ccs.Class.extend({
    _arguments: null,
    _callFunc: null,
    _selectorTarget: null,
    ctor: function(a, b, c) {
        this._data = c;
        this._callFunc = a;
        this._selectorTarget = b
    },
    call: function() {
        this._callFunc && this._callFunc.apply(this._selectorTarget, this._arguments)
    },
    setArguments: function(a) {
        this._arguments = a
    }
});
ccs.MovementEvent = function() {
    this.armature = null;
    this.movementType = ccs.MovementEventType.start;
    this.movementID = ""
};
ccs.FrameEvent = function() {
    this.bone = null;
    this.frameEventName = "";
    this.currentFrameIndex = this.originFrameIndex = 0
};
ccs.ArmatureAnimation = ccs.ProcessBase.extend({
    _animationData: null,
    _movementData: null,
    _armature: null,
    _movementID: "",
    _toIndex: 0,
    _tweenList: null,
    _speedScale: 1,
    _ignoreFrameEvent: !1,
    _frameEventQueue: null,
    _movementEventQueue: null,
    _movementList: null,
    _onMovementList: !1,
    _movementListLoop: !1,
    _movementIndex: 0,
    _movementListDurationTo: -1,
    _movementEventCallFunc: null,
    _frameEventCallFunc: null,
    _movementEventTarget: null,
    _frameEventTarget: null,
    _movementEventListener: null,
    _frameEventListener: null,
    ctor: function(a) {
        ccs.ProcessBase.prototype.ctor.call(this);
        this._tweenList = [];
        this._movementList = [];
        this._frameEventQueue = [];
        this._movementEventQueue = [];
        this._armature = null;
        a && ccs.ArmatureAnimation.prototype.init.call(this, a)
    },
    init: function(a) {
        this._armature = a;
        this._tweenList.length = 0;
        return !0
    },
    pause: function() {
        for (var a = this._tweenList, b = 0; b < a.length; b++) a[b].pause();
        ccs.ProcessBase.prototype.pause.call(this)
    },
    resume: function() {
        for (var a = this._tweenList, b = 0; b < a.length; b++) a[b].resume();
        ccs.ProcessBase.prototype.resume.call(this)
    },
    stop: function() {
        for (var a =
            this._tweenList, b = 0; b < a.length; b++) a[b].stop();
        a.length = 0;
        ccs.ProcessBase.prototype.stop.call(this)
    },
    setAnimationScale: function(a) {
        this.setSpeedScale(a)
    },
    getAnimationScale: function() {
        return this.getSpeedScale()
    },
    setSpeedScale: function(a) {
        if (a != this._speedScale) {
            this._speedScale = a;
            this._processScale = !this._movementData ? this._speedScale : this._speedScale * this._movementData.scale;
            a = this._armature.getBoneDic();
            for (var b in a) {
                var c = a[b];
                c.getTween().setProcessScale(this._processScale);
                c.getChildArmature() &&
                    c.getChildArmature().getAnimation().setSpeedScale(this._processScale)
            }
        }
    },
    getSpeedScale: function() {
        return this._speedScale
    },
    play: function(a, b, c) {
        cc.assert(this._animationData, "this.animationData can not be null");
        this._movementData = this._animationData.getMovement(a);
        cc.assert(this._movementData, "this._movementData can not be null");
        b = void 0 === b ? -1 : b;
        c = void 0 === c ? -1 : c;
        this._rawDuration = this._movementData.duration;
        this._movementID = a;
        this._processScale = this._speedScale * this._movementData.scale;
        b = -1 ==
            b ? this._movementData.durationTo : b;
        a = 0 == this._movementData.durationTween ? this._rawDuration : this._movementData.durationTween;
        var d = this._movementData.tweenEasing;
        c = 0 > c ? this._movementData.loop : c;
        this._onMovementList = !1;
        ccs.ProcessBase.prototype.play.call(this, b, a, c, d);
        0 == this._rawDuration ? this._loopType = ccs.ANIMATION_TYPE_SINGLE_FRAME : (this._loopType = c ? ccs.ANIMATION_TYPE_TO_LOOP_FRONT : ccs.ANIMATION_TYPE_NO_LOOP, this._durationTween = a);
        var e;
        this._tweenList = [];
        var f = this._armature.getBoneDic(),
            g;
        for (g in f) {
            var h =
                f[g];
            e = this._movementData.movBoneDataDic[h.getName()];
            var k = h.getTween();
            e && 0 < e.frameList.length ? (this._tweenList.push(k), e.duration = this._movementData.duration, k.play(e, b, a, c, d), k.setProcessScale(this._processScale), h.getChildArmature() && h.getChildArmature().getAnimation().setSpeedScale(this._processScale)) : h.isIgnoreMovementBoneData() || (h.getDisplayManager().changeDisplayWithIndex(-1, !1), k.stop())
        }
        this._armature.update(0)
    },
    playByIndex: function(a, b, c, d, e) {
        cc.log("playByIndex is deprecated. Use playWithIndex instead.");
        this.playWithIndex(a, b, d)
    },
    playWithIndex: function(a, b, c) {
        var d = this._animationData.movementNames;
        cc.assert(-1 < a && a < d.length);
        this.play(d[a], b, c)
    },
    playWithNames: function(a, b, c) {
        this._movementListLoop = void 0 === c ? !0 : c;
        this._movementListDurationTo = void 0 === b ? -1 : b;
        this._onMovementList = !0;
        this._movementIndex = 0;
        a instanceof Array ? this._movementList = a : this._movementList.length = 0;
        this.updateMovementList()
    },
    playWithIndexes: function(a, b, c) {
        this._movementList.length = 0;
        this._movementListLoop = void 0 === c ? !0 : c;
        this._movementListDurationTo =
            void 0 === b ? -1 : b;
        this._onMovementList = !0;
        this._movementIndex = 0;
        b = this._animationData.movementNames;
        for (c = 0; c < a.length; c++) this._movementList.push(b[a[c]]);
        this.updateMovementList()
    },
    gotoAndPlay: function(a) {
        if (!this._movementData || 0 > a || a >= this._movementData.duration) cc.log("Please ensure you have played a movement, and the frameIndex is in the range.");
        else {
            var b = this._ignoreFrameEvent;
            this._isPlaying = this._ignoreFrameEvent = !0;
            this._isComplete = this._isPause = !1;
            ccs.ProcessBase.prototype.gotoFrame.call(this,
                a);
            this._currentPercent = this._curFrameIndex / (this._movementData.duration - 1);
            this._currentFrame = this._nextFrameIndex * this._currentPercent;
            for (var c = this._tweenList, d = 0; d < c.length; d++) c[d].gotoAndPlay(a);
            this._armature.update(0);
            this._ignoreFrameEvent = b
        }
    },
    gotoAndPause: function(a) {
        this.gotoAndPlay(a);
        this.pause()
    },
    getMovementCount: function() {
        return this._animationData.getMovementCount()
    },
    update: function(a) {
        ccs.ProcessBase.prototype.update.call(this, a);
        for (var b = this._tweenList, c = 0; c < b.length; c++) b[c].update(a);
        for (b = this._frameEventQueue; 0 < b.length;) a = b.shift(), this._ignoreFrameEvent = !0, this._frameEventCallFunc && this._frameEventCallFunc.call(this._frameEventTarget, a.bone, a.frameEventName, a.originFrameIndex, a.currentFrameIndex), this._frameEventListener && this._frameEventListener(a.bone, a.frameEventName, a.originFrameIndex, a.currentFrameIndex), this._ignoreFrameEvent = !1;
        for (b = this._movementEventQueue; 0 < b.length;) a = b.shift(), this._movementEventCallFunc && this._movementEventCallFunc.call(this._movementEventTarget,
            a.armature, a.movementType, a.movementID), this._movementEventListener && this._movementEventListener(a.armature, a.movementType, a.movementID)
    },
    updateHandler: function() {
        var a = this._currentPercent;
        if (1 <= a) {
            switch (this._loopType) {
                case ccs.ANIMATION_TYPE_NO_LOOP:
                    this._loopType = ccs.ANIMATION_TYPE_MAX;
                    this._currentFrame = (a - 1) * this._nextFrameIndex;
                    a = this._currentFrame / this._durationTween;
                    if (1 > a) {
                        this._nextFrameIndex = this._durationTween;
                        this.movementEvent(this._armature, ccs.MovementEventType.start, this._movementID);
                        break
                    }
                    break;
                case ccs.ANIMATION_TYPE_MAX:
                case ccs.ANIMATION_TYPE_SINGLE_FRAME:
                    a = 1;
                    this._isComplete = !0;
                    this._isPlaying = !1;
                    this.movementEvent(this._armature, ccs.MovementEventType.complete, this._movementID);
                    this.updateMovementList();
                    break;
                case ccs.ANIMATION_TYPE_TO_LOOP_FRONT:
                    this._loopType = ccs.ANIMATION_TYPE_LOOP_FRONT;
                    a = ccs.fmodf(a, 1);
                    this._currentFrame = 0 == this._nextFrameIndex ? 0 : ccs.fmodf(this._currentFrame, this._nextFrameIndex);
                    this._nextFrameIndex = 0 < this._durationTween ? this._durationTween : 1;
                    this.movementEvent(this,
                        ccs.MovementEventType.start, this._movementID);
                    break;
                default:
                    this._currentFrame = ccs.fmodf(this._currentFrame, this._nextFrameIndex), this._toIndex = 0, this.movementEvent(this._armature, ccs.MovementEventType.loopComplete, this._movementID)
            }
            this._currentPercent = a
        }
    },
    getCurrentMovementID: function() {
        return this._isComplete ? "" : this._movementID
    },
    setMovementEventCallFunc: function(a, b) {
        1 == arguments.length ? this._frameEventListener = b : 2 == arguments.length && (this._movementEventTarget = b, this._movementEventCallFunc = a)
    },
    setFrameEventCallFunc: function(a, b) {
        1 == arguments.length ? this._frameEventListener = b : 2 == arguments.length && (this._frameEventTarget = b, this._frameEventCallFunc = a)
    },
    setUserObject: function(a) {
        this._userObject = a
    },
    frameEvent: function(a, b, c, d) {
        if (this._frameEventTarget && this._frameEventCallFunc || this._frameEventListener) {
            var e = new ccs.FrameEvent;
            e.bone = a;
            e.frameEventName = b;
            e.originFrameIndex = c;
            e.currentFrameIndex = d;
            this._frameEventQueue.push(e)
        }
    },
    movementEvent: function(a, b, c) {
        if (this._movementEventTarget &&
            this._movementEventCallFunc || this._movementEventListener) {
            var d = new ccs.MovementEvent;
            d.armature = a;
            d.movementType = b;
            d.movementID = c;
            this._movementEventQueue.push(d)
        }
    },
    updateMovementList: function() {
        if (this._onMovementList) {
            var a, b = this._movementList;
            this._movementListLoop ? (a = b[this._movementIndex], this.play(a, a.durationTo, 0), this._movementIndex++, this._movementIndex >= b.length && (this._movementIndex = 0)) : this._movementIndex < b.length ? (a = b[this._movementIndex], this.play(a, a.durationTo, 0), this._movementIndex++) :
                this._onMovementList = !1;
            this._onMovementList = !0
        }
    },
    setAnimationData: function(a) {
        this._animationData != a && (this._animationData = a)
    },
    getAnimationData: function() {
        return this._animationData
    },
    getUserObject: function() {
        return this._userObject
    },
    isIgnoreFrameEvent: function() {
        return this._ignoreFrameEvent
    }
});
_p = ccs.ArmatureAnimation.prototype;
cc.defineGetterSetter(_p, "speedScale", _p.getSpeedScale, _p.setSpeedScale);
cc.defineGetterSetter(_p, "animationScale", _p.getAnimationScale, _p.setAnimationScale);
_p = null;
ccs.ArmatureAnimation.create = function(a) {
    return new ccs.ArmatureAnimation(a)
};
ccs.Tween = ccs.ProcessBase.extend({
    _tweenData: null,
    _to: null,
    _from: null,
    _between: null,
    _movementBoneData: null,
    _bone: null,
    _frameTweenEasing: 0,
    _betweenDuration: 0,
    _totalDuration: 0,
    _toIndex: 0,
    _fromIndex: 0,
    _animation: null,
    _passLastFrame: !1,
    ctor: function(a) {
        ccs.ProcessBase.prototype.ctor.call(this);
        this._frameTweenEasing = ccs.TweenType.linear;
        ccs.Tween.prototype.init.call(this, a)
    },
    init: function(a) {
        this._from = new ccs.FrameData;
        this._between = new ccs.FrameData;
        this._bone = a;
        this._tweenData = this._bone.getTweenData();
        this._tweenData.displayIndex = -1;
        this._animation = null != this._bone && null != this._bone.getArmature() ? this._bone.getArmature().getAnimation() : null;
        return !0
    },
    play: function(a, b, c, d, e) {
        ccs.ProcessBase.prototype.play.call(this, b, c, d, e);
        this._loopType = d ? ccs.ANIMATION_TYPE_TO_LOOP_FRONT : ccs.ANIMATION_TYPE_NO_LOOP;
        this._fromIndex = this._toIndex = this._betweenDuration = this._totalDuration = 0;
        e = a != this._movementBoneData;
        this.setMovementBoneData(a);
        this._rawDuration = this._movementBoneData.duration;
        a = this._movementBoneData.getFrameData(0);
        this._tweenData.displayIndex = a.displayIndex;
        this._bone.getArmature().getArmatureData().dataVersion >= ccs.CONST_VERSION_COMBINED && (ccs.TransformHelp.nodeSub(this._tweenData, this._bone.getBoneData()), this._tweenData.scaleX += 1, this._tweenData.scaleY += 1);
        0 == this._rawDuration ? (this._loopType = ccs.ANIMATION_TYPE_SINGLE_FRAME, 0 == b ? this.setBetween(a, a) : this.setBetween(this._tweenData, a), this._frameTweenEasing = ccs.TweenType.linear) : 1 < this._movementBoneData.frameList.length && (this._durationTween = c * this._movementBoneData.scale,
            d && 0 != this._movementBoneData.delay ? this.setBetween(this._tweenData, this.tweenNodeTo(this.updateFrameData(1 - this._movementBoneData.delay), this._between)) : !e || 0 == b ? this.setBetween(a, a) : this.setBetween(this._tweenData, a));
        this.tweenNodeTo(0)
    },
    gotoAndPlay: function(a) {
        ccs.ProcessBase.prototype.gotoFrame.call(this, a);
        this._fromIndex = this._toIndex = this._betweenDuration = this._totalDuration = 0;
        this._isPlaying = !0;
        this._isComplete = this._isPause = !1;
        this._currentPercent = this._curFrameIndex / (this._rawDuration - 1);
        this._currentFrame = this._nextFrameIndex * this._currentPercent
    },
    gotoAndPause: function(a) {
        this.gotoAndPlay(a);
        this.pause()
    },
    updateHandler: function() {
        var a = this._currentPercent || 1,
            b = this._loopType;
        if (1 <= a) switch (b) {
            case ccs.ANIMATION_TYPE_SINGLE_FRAME:
                a = 1;
                this._isComplete = !0;
                this._isPlaying = !1;
                break;
            case ccs.ANIMATION_TYPE_NO_LOOP:
                b = ccs.ANIMATION_TYPE_MAX;
                a = 0 >= this._durationTween ? 1 : (a - 1) * this._nextFrameIndex / this._durationTween;
                1 <= a ? (a = 1, this._isComplete = !0, this._isPlaying = !1) : (this._nextFrameIndex = this._durationTween,
                    this._currentFrame = a * this._nextFrameIndex, this._fromIndex = this._toIndex = this._betweenDuration = this._totalDuration = 0);
                break;
            case ccs.ANIMATION_TYPE_TO_LOOP_FRONT:
                b = ccs.ANIMATION_TYPE_LOOP_FRONT;
                this._nextFrameIndex = 0 < this._durationTween ? this._durationTween : 1;
                0 != this._movementBoneData.delay ? (this._currentFrame = (1 - this._movementBoneData.delay) * this._nextFrameIndex, a = this._currentFrame / this._nextFrameIndex) : this._currentFrame = a = 0;
                this._fromIndex = this._toIndex = this._betweenDuration = this._totalDuration =
                    0;
                break;
            case ccs.ANIMATION_TYPE_MAX:
                a = 1;
                this._isComplete = !0;
                this._isPlaying = !1;
                break;
            default:
                this._currentFrame = ccs.fmodf(this._currentFrame, this._nextFrameIndex)
        }
        1 > a && b < ccs.ANIMATION_TYPE_TO_LOOP_BACK && (a = Math.sin(a * cc.PI / 2));
        this._currentPercent = a;
        this._loopType = b;
        b > ccs.ANIMATION_TYPE_TO_LOOP_BACK && (a = this.updateFrameData(a));
        this._frameTweenEasing != ccs.TweenType.tweenEasingMax && this.tweenNodeTo(a)
    },
    setBetween: function(a, b, c) {
        void 0 === c && (c = !0);
        0 > a.displayIndex && 0 <= b.displayIndex ? (this._from.copy(b),
            this._between.subtract(b, b, c)) : 0 > b.displayIndex && 0 <= a.displayIndex ? (this._from.copy(a), this._between.subtract(b, b, c)) : (this._from.copy(a), this._between.subtract(a, b, c));
        a.isTween || (this._tweenData.copy(a), this._tweenData.isTween = !0);
        this.arriveKeyFrame(a)
    },
    arriveKeyFrame: function(a) {
        if (a) {
            var b = this._bone,
                c = b.getDisplayManager(),
                d = a.displayIndex;
            c.getForceChangeDisplay() || c.changeDisplayWithIndex(d, !1);
            this._tweenData.zOrder = a.zOrder;
            b.updateZOrder();
            this._bone.setBlendFunc(a.blendFunc);
            (b = b.getChildArmature()) &&
            "" != a.movement && b.getAnimation().play(a.movement)
        }
    },
    tweenNodeTo: function(a, b) {
        b || (b = this._tweenData);
        var c = this._from,
            d = this._between;
        c.isTween || (a = 0);
        b.x = c.x + a * d.x;
        b.y = c.y + a * d.y;
        b.scaleX = c.scaleX + a * d.scaleX;
        b.scaleY = c.scaleY + a * d.scaleY;
        b.skewX = c.skewX + a * d.skewX;
        b.skewY = c.skewY + a * d.skewY;
        this._bone.setTransformDirty(!0);
        b && d.isUseColorInfo && this.tweenColorTo(a, b);
        return b
    },
    tweenColorTo: function(a, b) {
        var c = this._from,
            d = this._between;
        b.a = c.a + a * d.a;
        b.r = c.r + a * d.r;
        b.g = c.g + a * d.g;
        b.b = c.b + a * d.b;
        this._bone.updateColor()
    },
    updateFrameData: function(a) {
        1 < a && 0 != this._movementBoneData.delay && (a = ccs.fmodf(a, 1));
        a *= this._rawDuration - 1;
        var b, c, d = this._totalDuration,
            e = this._betweenDuration,
            f = this._toIndex;
        if (a < d || a >= d + e) {
            var e = this._movementBoneData.frameList,
                g = e.length;
            if (a < e[0].frameID) return b = c = e[0], this.setBetween(b, c), this._currentPercent;
            if (a >= e[g - 1].frameID) {
                if (this._passLastFrame) return b = c = e[g - 1], this.setBetween(b, c), this._currentPercent;
                this._passLastFrame = !0
            } else this._passLastFrame = !1;
            do
                if (this._fromIndex = f, b =
                    e[this._fromIndex], d = b.frameID, f = this._fromIndex + 1, f >= g && (f = 0), c = e[f], b.strEvent && !this._animation.isIgnoreFrameEvent() && this._animation.frameEvent(this._bone, b.strEvent, b.frameID, a), a == b.frameID || this._passLastFrame && this._fromIndex == g - 1) break;
            while (a < b.frameID || a >= c.frameID);
            e = c.frameID - b.frameID;
            this._frameTweenEasing = b.tweenEasing;
            this.setBetween(b, c, !1);
            this._totalDuration = d;
            this._betweenDuration = e;
            this._toIndex = f
        }
        a = 0 == e ? 0 : (a - this._totalDuration) / this._betweenDuration;
        b = this._frameTweenEasing !=
            ccs.TweenType.linear ? this._frameTweenEasing : this._tweenEasing;
        b != ccs.TweenType.tweenEasingMax && (b != ccs.TweenType.linear && !this._passLastFrame) && (a = ccs.TweenFunction.tweenTo(a, b, this._from.easingParams));
        return a
    },
    setAnimation: function(a) {
        this._animation = a
    },
    getAnimation: function() {
        return this._animation
    },
    setMovementBoneData: function(a) {
        this._movementBoneData = a
    }
});
_p = ccs.Tween.prototype;
cc.defineGetterSetter(_p, "animation", _p.getAnimation, _p.setAnimation);
_p = null;
ccs.Tween.create = function(a) {
    return new ccs.Tween(a)
};
ccs.PT_RATIO = 32;
ccs.ColliderFilter = ccs.Class.extend({
    _collisionType: 0,
    _group: 0,
    _categoryBits: 0,
    _groupIndex: 0,
    _maskBits: 0,
    ctor: function(a, b) {
        this._collisionType = a || 0;
        this._group = b || 0
    },
    updateShape: function(a) {
        if (a instanceof cp.Shape) a.collision_type = this._collisionType, a.group = this._group;
        else if (a instanceof Box2D.b2FilterData) {
            var b = new Box2D.b2FilterData;
            b.categoryBits = this._categoryBits;
            b.groupIndex = this._groupIndex;
            b.maskBits = this._maskBits;
            a.SetFilterData(b)
        }
    }
});
ccs.ColliderBody = ccs.Class.extend({
    shape: null,
    coutourData: null,
    colliderFilter: null,
    _calculatedVertexList: null,
    ctor: function(a) {
        this.shape = null;
        this.coutourData = a;
        this.colliderFilter = new ccs.ColliderFilter;
        ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX && (this._calculatedVertexList = [])
    },
    getContourData: function() {
        return this.coutourData
    },
    setColliderFilter: function(a) {
        this.colliderFilter = a
    },
    getCalculatedVertexList: function() {
        return this._calculatedVertexList
    },
    setB2Fixture: function(a) {
        this._fixture = a
    },
    getB2Fixture: function() {
        return this._fixture
    },
    setShape: function(a) {
        this.shape = a
    },
    getShape: function() {
        return this.shape
    },
    setContourData: function(a) {
        this.coutourData = a
    },
    getColliderFilter: function() {
        return this.colliderFilter
    }
});
ccs.ColliderDetector = ccs.Class.extend({
    _colliderBodyList: null,
    _bone: null,
    _body: null,
    _active: !1,
    _filter: null,
    helpPoint: cc.p(0, 0),
    ctor: function(a) {
        this._colliderBodyList = [];
        this._body = this._bone = null;
        this._active = !1;
        this._filter = null;
        ccs.ColliderDetector.prototype.init.call(this, a)
    },
    init: function(a) {
        this._colliderBodyList.length = 0;
        a && (this._bone = a);
        this._filter = new ccs.ColliderFilter;
        return !0
    },
    addContourData: function(a) {
        var b = new ccs.ColliderBody(a);
        this._colliderBodyList.push(b);
        if (ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) {
            b =
                b.getCalculatedVertexList();
            a = a.vertexList;
            for (var c = 0; c < a.length; c++) {
                var d = new ccs.ContourVertex2(0, 0);
                b.push(d)
            }
        }
    },
    addContourDataList: function(a) {
        for (var b = 0; b < a.length; b++) this.addContourData(a[b])
    },
    removeContourData: function(a) {
        var b = [],
            c, d = this._colliderBodyList;
        for (c = 0; c < d.length; c++) {
            var e = d[c];
            e && e.getContourData() == a && b.push(e)
        }
        for (c = 0; c < b.length; c++) cc.arrayRemoveObject(d, b[c])
    },
    removeAll: function() {
        this._colliderBodyList.length = 0
    },
    setActive: function(a) {
        if (this._active != a) {
            this._active =
                a;
            a = this._body;
            var b;
            if (a)
                if (b = null, this._active)
                    for (var c = 0; c < this._colliderBodyList.length; c++) b = this._colliderBodyList[c], b = b.getShape(), a.space.addShape(b);
                else
                    for (c = 0; c < this._colliderBodyList.length; c++) b = this._colliderBodyList[c], b = b.getShape(), a.space.removeShape(b)
        }
    },
    getActive: function() {
        return this._active
    },
    getColliderBodyList: function() {
        return this._colliderBodyList
    },
    setColliderFilter: function(a) {
        this._filter = a;
        for (var b = this._colliderBodyList, c = 0; c < b.length; c++) {
            var d = b[c];
            d.setColliderFilter(a);
            d.getShape() && d.getColliderFilter().updateShape(d.getShape())
        }
    },
    getColliderFilter: function() {
        return this._filter
    },
    updateTransform: function(a) {
        if (this._active)
            for (var b = null, c = this._body, d = this.helpPoint, e = 0; e < this._colliderBodyList.length; e++) {
                var b = this._colliderBodyList[e],
                    f = b.getContourData(),
                    g = null;
                c && (g = b.getShape());
                for (var f = f.vertexList, h = b.getCalculatedVertexList(), b = 0; b < f.length; b++) {
                    d.x = f[b].x;
                    d.y = f[b].y;
                    d = cc.pointApplyAffineTransform(d, a);
                    if (ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) {
                        var k =
                            cc.p(0, 0);
                        k.x = d.x;
                        k.y = d.y;
                        h[b] = k
                    }
                    g && (g.verts[2 * b] = d.x, g.verts[2 * b + 1] = d.y)
                }
                if (g)
                    for (b = 0; b < f.length; b++) h = cp.v.normalize(cp.v.perp(cp.v.sub(g.verts[(b + 1) % g.verts.length], g.verts[b]))), g.planes && (g.planes[b].n = h, g.planes[b].d = cp.v.dot(h, g.verts[b]))
            }
    },
    setBody: function(a) {
        this._body = a;
        for (var b = this._colliderBodyList, c = 0; c < b.length; c++) {
            a = b[c];
            for (var d = [], e = a.getContourData().vertexList, f = 0; f < e.length; f++) {
                var g = e[f];
                d.push(g.x);
                d.push(g.y)
            }
            d = new cp.PolyShape(this._body, d, cp.vzero);
            d.sensor = !0;
            d.data =
                this._bone;
            this._active && this._body.space.addShape(d);
            a.setShape(d);
            a.getColliderFilter().updateShape(d)
        }
    },
    getBody: function() {
        return this._body
    }
});
_p = ccs.ColliderDetector.prototype;
cc.defineGetterSetter(_p, "colliderFilter", _p.getColliderFilter, _p.setColliderFilter);
cc.defineGetterSetter(_p, "active", _p.getActive, _p.setActive);
cc.defineGetterSetter(_p, "body", _p.getBody, _p.setBody);
_p = null;
ccs.ColliderDetector.create = function(a) {
    return new ccs.ColliderDetector(a)
};
ccs.Armature = ccs.Node.extend({
    animation: null,
    armatureData: null,
    batchNode: null,
    _textureAtlas: null,
    _parentBone: null,
    _boneDic: null,
    _topBoneList: null,
    _armatureIndexDic: null,
    _offsetPoint: null,
    version: 0,
    _armatureTransformDirty: !0,
    _body: null,
    _blendFunc: null,
    _className: "Armature",
    _realAnchorPointInPoints: null,
    ctor: function(a, b) {
        cc.Node.prototype.ctor.call(this);
        this._name = "";
        this._topBoneList = [];
        this._armatureIndexDic = {};
        this._offsetPoint = cc.p(0, 0);
        this._armatureTransformDirty = !0;
        this._realAnchorPointInPoints =
            cc.p(0, 0);
        a && ccs.Armature.prototype.init.call(this, a, b)
    },
    _initRendererCmd: function() {
        cc._renderType === cc._RENDER_TYPE_CANVAS ? (this._rendererStartCmd = new cc.CustomRenderCmdCanvas(this, this._startRendererCmdForCanvas), this._rendererEndCmd = new cc.CustomRenderCmdCanvas(this, this._endRendererCmdForCanvas)) : this._rendererCmd = new cc.ArmatureRenderCmdWebGL(this)
    },
    init: function(a, b) {
        cc.Node.prototype.init.call(this);
        b && (this._parentBone = b);
        this.removeAllChildren();
        this.animation = new ccs.ArmatureAnimation;
        this.animation.init(this);
        this._boneDic = {};
        this._topBoneList.length = 0;
        this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        };
        this._name = a || "";
        var c = ccs.armatureDataManager,
            d;
        if ("" != a) {
            d = c.getAnimationData(a);
            cc.assert(d, "AnimationData not exist!");
            this.animation.setAnimationData(d);
            c = c.getArmatureData(a);
            cc.assert(c, "ArmatureData not exist!");
            this.armatureData = c;
            var c = c.getBoneDataDic(),
                e;
            for (e in c) {
                var c = this.createBone(String(e)),
                    f = d.getMovement(d.movementNames[0]);
                if (f && (f = f.getMovementBoneData(c.getName())) &&
                    !(0 >= f.frameList.length))
                    if (f = f.getFrameData(0)) c.getTweenData().copy(f), c.changeDisplayWithIndex(f.displayIndex, !1)
            }
            this.update(0);
            this.updateOffsetPoint()
        } else this._name = "new_armature", this.armatureData = new ccs.ArmatureData, this.armatureData.name = this._name, d = new ccs.AnimationData, d.name = this._name, c.addArmatureData(this._name, this.armatureData), c.addAnimationData(this._name, d), this.animation.setAnimationData(d);
        cc._renderType === cc._RENDER_TYPE_WEBGL && this.setShaderProgram(cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR));
        this.setCascadeOpacityEnabled(!0);
        this.setCascadeColorEnabled(!0);
        return !0
    },
    createBone: function(a) {
        var b = this.getBone(a);
        if (b) return b;
        var b = this.armatureData.getBoneData(a),
            c = b.parentName,
            d = null;
        c ? (this.createBone(c), d = new ccs.Bone(a), this.addBone(d, c)) : (d = new ccs.Bone(a), this.addBone(d, ""));
        d.setBoneData(b);
        d.getDisplayManager().changeDisplayWithIndex(-1, !1);
        return d
    },
    addBone: function(a, b) {
        cc.assert(a, "Argument must be non-nil");
        var c = this._boneDic;
        a.getName() && cc.assert(!c[a.getName()], "bone already added. It can't be added again");
        if (b) {
            var d = c[b];
            d ? d.addChildBone(a) : this._topBoneList.push(a)
        } else this._topBoneList.push(a);
        a.setArmature(this);
        c[a.getName()] = a;
        this.addChild(a)
    },
    removeBone: function(a, b) {
        cc.assert(a, "bone must be added to the bone dictionary!");
        a.setArmature(null);
        a.removeFromParent(b);
        cc.arrayRemoveObject(this._topBoneList, a);
        delete this._boneDic[a.getName()];
        this.removeChild(a, !0)
    },
    getBone: function(a) {
        return this._boneDic[a]
    },
    changeBoneParent: function(a, b) {
        cc.assert(a, "bone must be added to the bone dictionary!");
        var c = a.getParentBone();
        c && (cc.arrayRemoveObject(c.getChildren(), a), a.setParentBone(null));
        b && ((c = this._boneDic[b]) ? (c.addChildBone(a), cc.arrayRemoveObject(this._topBoneList, a)) : this._topBoneList.push(a))
    },
    getBoneDic: function() {
        return this._boneDic
    },
    updateOffsetPoint: function() {
        var a = this.getBoundingBox();
        this.setContentSize(a);
        var b = this._offsetPoint;
        b.x = -a.x;
        b.y = -a.y;
        0 != a.width && 0 != a.height && this.setAnchorPoint(b.x / a.width, b.y / a.height)
    },
    setAnchorPoint: function(a, b) {
        var c, d;
        void 0 !== b ? (c = a, d = b) :
            (c = a.x, d = a.y);
        var e = this._anchorPoint;
        if (c != e.x || d != e.y) {
            var f = this._contentSize;
            e.x = c;
            e.y = d;
            this._anchorPointInPoints.x = f.width * e.x - this._offsetPoint.x;
            this._anchorPointInPoints.y = f.height * e.y - this._offsetPoint.y;
            this._realAnchorPointInPoints.x = f.width * e.x;
            this._realAnchorPointInPoints.y = f.height * e.y;
            this.setNodeDirty()
        }
    },
    _setAnchorX: function(a) {
        this._anchorPoint.x !== a && (this._anchorPoint.x = a, this._anchorPointInPoints.x = this._contentSize.width * a - this._offsetPoint.x, this._realAnchorPointInPoints.x =
            this._contentSize.width * a, this.setNodeDirty())
    },
    _setAnchorY: function(a) {
        this._anchorPoint.y !== a && (this._anchorPoint.y = a, this._anchorPointInPoints.y = this._contentSize.height * a - this._offsetPoint.y, this._realAnchorPointInPoints.y = this._contentSize.height * a, this.setNodeDirty())
    },
    getAnchorPointInPoints: function() {
        return this._realAnchorPointInPoints
    },
    getOffsetPoints: function() {
        return {
            x: this._offsetPoint.x,
            y: this._offsetPoint.y
        }
    },
    setAnimation: function(a) {
        this.animation = a
    },
    getAnimation: function() {
        return this.animation
    },
    getArmatureTransformDirty: function() {
        return this._armatureTransformDirty
    },
    update: function(a) {
        this.animation.update(a);
        for (var b = this._topBoneList, c = 0; c < b.length; c++) b[c].update(a);
        this._armatureTransformDirty = !1
    },
    draw: function(a) {
        for (var b = this._children, c = cc.BlendFunc.ALPHA_PREMULTIPLIED, d = cc.BlendFunc.ALPHA_NON_PREMULTIPLIED, e = 0, f = b.length; e < f; e++) {
            var g = b[e];
            if (g && g.getDisplayRenderNode) {
                var h = g.getDisplayRenderNode();
                if (null != h) switch (cc._renderType === cc._RENDER_TYPE_WEBGL && h.setShaderProgram(this._shaderProgram),
                    g.getDisplayRenderNodeType()) {
                    case ccs.DISPLAY_TYPE_SPRITE:
                        if (h instanceof ccs.Skin)
                            if (cc._renderType === cc._RENDER_TYPE_WEBGL) {
                                h.updateTransform();
                                var k = g.getBlendFunc();
                                k.src != c.src || k.dst != c.dst ? h.setBlendFunc(g.getBlendFunc()) : this._blendFunc.src == c.src && this._blendFunc.dst == c.dst && !h.getTexture().hasPremultipliedAlpha() ? h.setBlendFunc(d) : h.setBlendFunc(this._blendFunc);
                                h.draw(a)
                            } else h.visit(a);
                        break;
                    case ccs.DISPLAY_TYPE_ARMATURE:
                        h.draw(a);
                        break;
                    default:
                        h.visit(a)
                }
            } else g instanceof cc.Node &&
                (cc._renderType === cc._RENDER_TYPE_WEBGL && g.setShaderProgram(this._shaderProgram), g.visit(a))
        }
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this);
        this.scheduleUpdate()
    },
    onExit: function() {
        cc.Node.prototype.onExit.call(this);
        this.unscheduleUpdate()
    },
    visit: null,
    _visitForCanvas: function(a) {
        var b = a || cc._renderContext;
        this._visible && (b.save(), this.transform(b), this.sortAllChildren(), this._rendererStartCmd && cc.renderer.pushRenderCommand(this._rendererStartCmd), this.draw(a), this._rendererEndCmd && cc.renderer.pushRenderCommand(this._rendererEndCmd),
            this._cacheDirty = !1, b.restore())
    },
    _startRendererCmdForCanvas: function(a, b, c) {
        var d = a || cc._renderContext;
        d.save();
        this.transform(d);
        d = this._transformWorld;
        a.transform(d.a, d.b, d.c, d.d, d.tx * b, -d.ty * c);
        a = this._children;
        b = 0;
        for (c = a.length; b < c; b++)
            if ((d = a[b]) && d.getDisplayRenderNode) d = d.getDisplayRenderNode(), null != d && d._transformForRenderer()
    },
    _endRendererCmdForCanvas: function(a) {
        a = a || cc._renderContext;
        this._cacheDirty = !1;
        a.restore()
    },
    _visitForWebGL: function() {
        if (this._visible) {
            var a = cc.current_stack;
            a.stack.push(a.top);
            cc.kmMat4Assign(this._stackMatrix, a.top);
            a.top = this._stackMatrix;
            this.transform();
            this.sortAllChildren();
            cc.renderer.pushRenderCommand(this._rendererCmd);
            a.top = a.stack.pop()
        }
    },
    getBoundingBox: function() {
        for (var a, b, c, d = 0, e = !0, f = cc.rect(0, 0, 0, 0), g = this._children, h = g.length, k = 0; k < h; k++)
            if (a = g[k]) d = a.getDisplayManager().getBoundingBox(), 0 == d.x && 0 == d.y && 0 == d.width && 0 == d.height || (e ? (a = d.x, b = d.y, c = d.x + d.width, d = d.y + d.height, e = !1) : (a = d.x < f.x ? d.x : f.x, b = d.y < f.y ? d.y : f.y, c = d.x + d.width > f.x +
                f.width ? d.x + d.width : f.x + f.width, d = d.y + d.height > f.y + f.height ? d.y + d.height : f.y + f.height), f.x = a, f.y = b, f.width = c - a, f.height = d - b);
        return cc.rectApplyAffineTransform(f, this.getNodeToParentTransform())
    },
    getBoneAtPoint: function(a, b) {
        for (var c = this._children, d = c.length - 1; 0 <= d; d--) {
            var e = c[d];
            if (e instanceof ccs.Bone && e.getDisplayManager().containPoint(a, b)) return e
        }
        return null
    },
    setParentBone: function(a) {
        this._parentBone = a;
        a = this._boneDic;
        for (var b in a) a[b].setArmature(this)
    },
    getParentBone: function() {
        return this._parentBone
    },
    drawContour: function() {
        cc._drawingUtil.setDrawColor(255, 255, 255, 255);
        cc._drawingUtil.setLineWidth(1);
        var a = this._boneDic,
            b;
        for (b in a) {
            var c = a[b].getColliderDetector();
            if (c)
                for (var c = c.getColliderBodyList(), d = 0; d < c.length; d++) {
                    var e = c[d].getCalculatedVertexList();
                    cc._drawingUtil.drawPoly(e, e.length, !0)
                }
        }
    },
    setBody: function(a) {
        if (this._body != a) {
            this._body = a;
            this._body.data = this;
            var b, c;
            a = this._children;
            for (var d = 0; d < a.length; d++)
                if (b = a[d], b instanceof ccs.Bone) {
                    b = b.getDisplayManager().getDecorativeDisplayList();
                    for (var e = 0; e < b.length; e++) c = b[e], (c = c.getColliderDetector()) && c.setBody(this._body)
                }
        }
    },
    getShapeList: function() {
        return this._body ? this._body.shapeList : null
    },
    getBody: function() {
        return this._body
    },
    setBlendFunc: function(a) {
        this._blendFunc = a
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    setColliderFilter: function(a) {
        var b = this._boneDic,
            c;
        for (c in b) b[c].setColliderFilter(a)
    },
    getArmatureData: function() {
        return this.armatureData
    },
    setArmatureData: function(a) {
        this.armatureData = a
    },
    getBatchNode: function() {
        return this.batchNode
    },
    setBatchNode: function(a) {
        this.batchNode = a
    },
    getVersion: function() {
        return this.version
    },
    setVersion: function(a) {
        this.version = a
    },
    _transformForRenderer: function() {
        ccs.Node.prototype._transformForRenderer.call(this);
        for (var a = this._children, b = 0, c = a.length; b < c; b++) {
            var d = a[b];
            d && d.getDisplayRenderNode && (d = d.getDisplayRenderNode(), null != d && d._transformForRenderer())
        }
    }
});
ccs.Armature.prototype.visit = cc._renderType == cc._RENDER_TYPE_WEBGL ? ccs.Armature.prototype._visitForWebGL : ccs.Armature.prototype._visitForCanvas;
_p = ccs.Armature.prototype;
cc.defineGetterSetter(_p, "parentBone", _p.getParentBone, _p.setParentBone);
cc.defineGetterSetter(_p, "body", _p.getBody, _p.setBody);
cc.defineGetterSetter(_p, "colliderFilter", null, _p.setColliderFilter);
_p = null;
ccs.Armature.create = function(a, b) {
    return new ccs.Armature(a, b)
};
ccs.Bone = ccs.Node.extend({
    _boneData: null,
    _armature: null,
    _childArmature: null,
    _displayManager: null,
    ignoreMovementBoneData: !1,
    _tween: null,
    _tweenData: null,
    _parentBone: null,
    _boneTransformDirty: !1,
    _worldTransform: null,
    _blendFunc: null,
    blendDirty: !1,
    _worldInfo: null,
    _armatureParentBone: null,
    _dataVersion: 0,
    _className: "Bone",
    ctor: function(a) {
        cc.Node.prototype.ctor.call(this);
        this._displayManager = this._tween = this._boneData = this._childArmature = this._armature = this._parentBone = this._tweenData = null;
        this.ignoreMovementBoneData = !1;
        this._worldTransform = cc.affineTransformMake(1, 0, 0, 1, 0, 0);
        this._boneTransformDirty = !0;
        this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
        this.blendDirty = !1;
        this._armatureParentBone = this._worldInfo = null;
        this._dataVersion = 0;
        ccs.Bone.prototype.init.call(this, a)
    },
    init: function(a) {
        a && (this._name = a);
        this._tweenData = new ccs.FrameData;
        this._tween = new ccs.Tween(this);
        this._displayManager = new ccs.DisplayManager(this);
        this._worldInfo = new ccs.BaseData;
        this._boneData = new ccs.BaseData;
        return !0
    },
    setBoneData: function(a) {
        cc.assert(a,
            "_boneData must not be null");
        this._boneData != a && (this._boneData = a);
        this.setName(this._boneData.name);
        this._localZOrder = this._boneData.zOrder;
        this._displayManager.initDisplayList(a)
    },
    getBoneData: function() {
        return this._boneData
    },
    setArmature: function(a) {
        (this._armature = a) ? (this._tween.setAnimation(this._armature.getAnimation()), this._dataVersion = this._armature.getArmatureData().dataVersion, this._armatureParentBone = this._armature.getParentBone()) : this._armatureParentBone = null
    },
    getArmature: function() {
        return this._armature
    },
    update: function(a) {
        this._parentBone && (this._boneTransformDirty = this._boneTransformDirty || this._parentBone.isTransformDirty());
        this._armatureParentBone && !this._boneTransformDirty && (this._boneTransformDirty = this._armatureParentBone.isTransformDirty());
        if (this._boneTransformDirty) {
            var b = this._tweenData;
            this._dataVersion >= ccs.CONST_VERSION_COMBINED && (ccs.TransformHelp.nodeConcat(b, this._boneData), b.scaleX -= 1, b.scaleY -= 1);
            var c = this._worldInfo;
            c.copy(b);
            c.x = b.x + this._position.x;
            c.y = b.y + this._position.y;
            c.scaleX = b.scaleX * this._scaleX;
            c.scaleY = b.scaleY * this._scaleY;
            c.skewX = b.skewX + this._skewX + cc.degreesToRadians(this._rotationX);
            c.skewY = b.skewY + this._skewY - cc.degreesToRadians(this._rotationY);
            this._parentBone ? this._applyParentTransform(this._parentBone) : this._armatureParentBone && this._applyParentTransform(this._armatureParentBone);
            ccs.TransformHelp.nodeToMatrix(c, this._worldTransform);
            this._armatureParentBone && (this._worldTransform = cc.affineTransformConcat(this._worldTransform, this._armature.getNodeToParentTransform()))
        }
        ccs.displayFactory.updateDisplay(this,
            a, this._boneTransformDirty || this._armature.getArmatureTransformDirty());
        for (b = 0; b < this._children.length; b++) this._children[b].update(a);
        this._boneTransformDirty = !1
    },
    _applyParentTransform: function(a) {
        var b = this._worldInfo,
            c = a._worldTransform;
        a = a._worldInfo;
        var d = b.x,
            e = b.y;
        b.x = d * c.a + e * c.c + a.x;
        b.y = d * c.b + e * c.d + a.y;
        b.scaleX *= a.scaleX;
        b.scaleY *= a.scaleY;
        b.skewX += a.skewX;
        b.skewY += a.skewY
    },
    setBlendFunc: function(a, b) {
        var c = this._blendFunc,
            d, e;
        void 0 === b ? (d = a.src, e = a.dst) : (d = a, e = b);
        if (c.src != d || c.dst != e) c.src =
            d, c.dst = e, this.blendDirty = !0
    },
    updateDisplayedColor: function(a) {
        this._realColor = cc.color(255, 255, 255);
        cc.Node.prototype.updateDisplayedColor.call(this, a);
        this.updateColor()
    },
    updateDisplayedOpacity: function(a) {
        this._realOpacity = 255;
        cc.Node.prototype.updateDisplayedOpacity.call(this, a);
        this.updateColor()
    },
    updateColor: function() {
        var a = this._displayManager.getDisplayRenderNode();
        null != a && (a.setColor(cc.color(this._displayedColor.r * this._tweenData.r / 255, this._displayedColor.g * this._tweenData.g / 255, this._displayedColor.b *
            this._tweenData.b / 255)), a.setOpacity(this._displayedOpacity * this._tweenData.a / 255))
    },
    updateZOrder: function() {
        this._armature.getArmatureData().dataVersion >= ccs.CONST_VERSION_COMBINED ? this.setLocalZOrder(this._tweenData.zOrder + this._boneData.zOrder) : this.setLocalZOrder(this._tweenData.zOrder)
    },
    addChildBone: function(a) {
        cc.assert(a, "Argument must be non-nil");
        cc.assert(!a.parentBone, "child already added. It can't be added again");
        0 > this._children.indexOf(a) && (this._children.push(a), a.setParentBone(this))
    },
    removeChildBone: function(a, b) {
        if (0 < this._children.length && -1 != this._children.getIndex(a)) {
            if (b)
                for (var c = a._children, d = 0; d < c.length; d++) a.removeChildBone(c[d], b);
            a.setParentBone(null);
            a.getDisplayManager().setCurrentDecorativeDisplay(null);
            cc.arrayRemoveObject(this._children, a)
        }
    },
    removeFromParent: function(a) {
        this._parentBone && this._parentBone.removeChildBone(this, a)
    },
    setParentBone: function(a) {
        this._parentBone = a
    },
    getParentBone: function() {
        return this._parentBone
    },
    setChildArmature: function(a) {
        this._childArmature !=
            a && (null == a && this._childArmature && this._childArmature.setParentBone(null), this._childArmature = a)
    },
    getChildArmature: function() {
        return this._childArmature
    },
    getTween: function() {
        return this._tween
    },
    setLocalZOrder: function(a) {
        this._localZOrder != a && cc.Node.prototype.setLocalZOrder.call(this, a)
    },
    getNodeToArmatureTransform: function() {
        return this._worldTransform
    },
    getNodeToWorldTransform: function() {
        return cc.affineTransformConcat(this._worldTransform, this._armature.getNodeToWorldTransform())
    },
    getDisplayRenderNode: function() {
        return this._displayManager.getDisplayRenderNode()
    },
    getDisplayRenderNodeType: function() {
        return this._displayManager.getDisplayRenderNodeType()
    },
    addDisplay: function(a, b) {
        return this._displayManager.addDisplay(a, b || 0)
    },
    removeDisplay: function(a) {
        this._displayManager.removeDisplay(a)
    },
    changeDisplayByIndex: function(a, b) {
        cc.log("changeDisplayByIndex is deprecated. Use changeDisplayWithIndex instead.");
        this.changeDisplayWithIndex(a, b)
    },
    changeDisplayByName: function(a, b) {
        cc.log("changeDisplayByName is deprecated. Use changeDisplayWithName instead.");
        this.changeDisplayWithName(a,
            b)
    },
    changeDisplayWithIndex: function(a, b) {
        this._displayManager.changeDisplayWithIndex(a, b)
    },
    changeDisplayWithName: function(a, b) {
        this._displayManager.changeDisplayWithName(a, b)
    },
    getColliderDetector: function() {
        var a = this._displayManager.getCurrentDecorativeDisplay();
        return a && (a = a.getColliderDetector()) ? a : null
    },
    setColliderFilter: function(a) {
        for (var b = this._displayManager.getDecorativeDisplayList(), c = 0; c < b.length; c++) {
            var d = b[c].getColliderDetector();
            d && d.setColliderFilter(a)
        }
    },
    getColliderFilter: function() {
        var a =
            this.displayManager.getCurrentDecorativeDisplay();
        return a && (a = a.getColliderDetector()) ? a.getColliderFilter() : null
    },
    setTransformDirty: function(a) {
        this._boneTransformDirty = a
    },
    isTransformDirty: function() {
        return this._boneTransformDirty
    },
    getDisplayManager: function() {
        return this._displayManager
    },
    setIgnoreMovementBoneData: function(a) {
        this._ignoreMovementBoneData = a
    },
    isIgnoreMovementBoneData: function() {
        return this._ignoreMovementBoneData
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    setBlendDirty: function(a) {
        this._blendDirty =
            a
    },
    isBlendDirty: function() {
        return this._blendDirty
    },
    getTweenData: function() {
        return this._tweenData
    },
    getWorldInfo: function() {
        return this._worldInfo
    },
    getChildrenBone: function() {
        return this._children
    },
    nodeToArmatureTransform: function() {
        return this.getNodeToArmatureTransform()
    },
    nodeToWorldTransform: function() {
        return this.getNodeToWorldTransform()
    },
    getColliderBodyList: function() {
        var a = this.getColliderDetector();
        return a ? a.getColliderBodyList() : null
    },
    getIgnoreMovementBoneData: function() {
        return this.isIgnoreMovementBoneData()
    }
});
_p = ccs.Bone.prototype;
cc.defineGetterSetter(_p, "boneData", _p.getBoneData, _p.setBoneData);
cc.defineGetterSetter(_p, "armature", _p.getArmature, _p.setArmature);
cc.defineGetterSetter(_p, "childArmature", _p.getChildArmature, _p.setChildArmature);
cc.defineGetterSetter(_p, "childrenBone", _p.getChildrenBone);
cc.defineGetterSetter(_p, "tween", _p.getTween);
cc.defineGetterSetter(_p, "tweenData", _p.getTweenData);
cc.defineGetterSetter(_p, "colliderFilter", _p.getColliderFilter, _p.setColliderFilter);
_p = null;
ccs.Bone.create = function(a) {
    return new ccs.Bone(a)
};
ccs.FRAME_TYPE_MOVE = 0;
ccs.FRAME_TYPE_SCALE = 1;
ccs.FRAME_TYPE_ROTATE = 2;
ccs.FRAME_TYPE_TINT = 3;
ccs.FRAME_TYPE_FADE = 4;
ccs.FRAME_TYPE_MAX = 5;
ccs.FrameEaseType = {
    Custom: -1,
    Linear: 0,
    Sine_EaseIn: 1,
    Sine_EaseOut: 2,
    Sine_EaseInOut: 3,
    Quad_EaseIn: 4,
    Quad_EaseOut: 5,
    Quad_EaseInOut: 6,
    Cubic_EaseIn: 7,
    Cubic_EaseOut: 8,
    Cubic_EaseInOut: 9,
    Quart_EaseIn: 10,
    Quart_EaseOut: 11,
    Quart_EaseInOut: 12,
    Quint_EaseIn: 13,
    Quint_EaseOut: 14,
    Quint_EaseInOut: 15,
    Expo_EaseIn: 16,
    Expo_EaseOut: 17,
    Expo_EaseInOut: 18,
    Circ_EaseIn: 19,
    Circ_EaseOut: 20,
    Circ_EaseInOut: 21,
    Elastic_EaesIn: 22,
    Elastic_EaesOut: 23,
    Elastic_EaesInOut: 24,
    Back_EaseIn: 25,
    Back_EaseOut: 26,
    Back_EaseInOut: 27,
    Bounce_EaseIn: 28,
    Bounce_EaseOut: 29,
    Bounce_EaseInOut: 30
};
ccs.ActionFrame = ccs.Class.extend({
    frameType: 0,
    easingType: 0,
    frameIndex: 0,
    _Parameter: null,
    time: 0,
    ctor: function() {
        this.frameType = 0;
        this.easingType = ccs.FrameEaseType.Linear;
        this.time = this.frameIndex = 0
    },
    getAction: function(a, b) {
        cc.log("Need a definition of \x3cgetAction\x3e for ActionFrame");
        return null
    },
    _getEasingAction: function(a) {
        if (null === a) return console.error("Action cannot be null!"), null;
        var b;
        switch (this.easingType) {
            case ccs.FrameEaseType.Linear:
                b = a;
                break;
            case ccs.FrameEaseType.Sine_EaseIn:
                b = a.easing(cc.easeSineIn());
                break;
            case ccs.FrameEaseType.Sine_EaseOut:
                b = a.easing(cc.easeSineOut());
                break;
            case ccs.FrameEaseType.Sine_EaseInOut:
                b = a.easing(cc.easeSineInOut());
                break;
            case ccs.FrameEaseType.Quad_EaseIn:
                b = a.easing(cc.easeQuadraticActionIn());
                break;
            case ccs.FrameEaseType.Quad_EaseOut:
                b = a.easing(cc.easeQuadraticActionOut());
                break;
            case ccs.FrameEaseType.Quad_EaseInOut:
                b = a.easing(cc.easeQuadraticActionInOut());
                break;
            case ccs.FrameEaseType.Cubic_EaseIn:
                b = a.easing(cc.easeCubicActionIn());
                break;
            case ccs.FrameEaseType.Cubic_EaseOut:
                b =
                    a.easing(cc.easeCubicActionOut());
                break;
            case ccs.FrameEaseType.Cubic_EaseInOut:
                b = a.easing(cc.easeCubicActionInOut());
                break;
            case ccs.FrameEaseType.Quart_EaseIn:
                b = a.easing(cc.easeQuarticActionIn());
                break;
            case ccs.FrameEaseType.Quart_EaseOut:
                b = a.easing(cc.easeQuarticActionOut());
                break;
            case ccs.FrameEaseType.Quart_EaseInOut:
                b = a.easing(cc.easeQuarticActionInOut());
                break;
            case ccs.FrameEaseType.Quint_EaseIn:
                b = a.easing(cc.easeQuinticActionIn());
                break;
            case ccs.FrameEaseType.Quint_EaseOut:
                b = a.easing(cc.easeQuinticActionOut());
                break;
            case ccs.FrameEaseType.Quint_EaseInOut:
                b = a.easing(cc.easeQuinticActionInOut());
                break;
            case ccs.FrameEaseType.Expo_EaseIn:
                b = a.easing(cc.easeExponentialIn());
                break;
            case ccs.FrameEaseType.Expo_EaseOut:
                b = a.easing(cc.easeExponentialOut());
                break;
            case ccs.FrameEaseType.Expo_EaseInOut:
                b = a.easing(cc.easeExponentialInOut());
                break;
            case ccs.FrameEaseType.Circ_EaseIn:
                b = a.easing(cc.easeCircleActionIn());
                break;
            case ccs.FrameEaseType.Circ_EaseOut:
                b = a.easing(cc.easeCircleActionOut());
                break;
            case ccs.FrameEaseType.Circ_EaseInOut:
                b =
                    a.easing(cc.easeCircleActionInOut());
                break;
            case ccs.FrameEaseType.Elastic_EaesIn:
                b = a.easing(cc.easeElasticIn());
                break;
            case ccs.FrameEaseType.Elastic_EaesOut:
                b = a.easing(cc.easeElasticOut());
                break;
            case ccs.FrameEaseType.Elastic_EaesInOut:
                b = a.easing(cc.easeElasticInOut());
                break;
            case ccs.FrameEaseType.Back_EaseIn:
                b = a.easing(cc.easeBackIn());
                break;
            case ccs.FrameEaseType.Back_EaseOut:
                b = a.easing(cc.easeBackOut());
                break;
            case ccs.FrameEaseType.Back_EaseInOut:
                b = a.easing(cc.easeBackInOut());
                break;
            case ccs.FrameEaseType.Bounce_EaseIn:
                b =
                    a.easing(cc.easeBounceIn());
                break;
            case ccs.FrameEaseType.Bounce_EaseOut:
                b = a.easing(cc.easeBounceOut());
                break;
            case ccs.FrameEaseType.Bounce_EaseInOut:
                b = a.easing(cc.easeBounceInOut())
        }
        return b
    },
    setEasingParameter: function(a) {
        this._Parameter = [];
        for (var b = 0; b < a.length; b++) this._Parameter.push(a[b])
    },
    setEasingType: function(a) {
        this.easingType = a
    }
});
ccs.ActionMoveFrame = ccs.ActionFrame.extend({
    _position: null,
    ctor: function() {
        ccs.ActionFrame.prototype.ctor.call(this);
        this._position = cc.p(0, 0);
        this.frameType = ccs.FRAME_TYPE_MOVE
    },
    setPosition: function(a, b) {
        void 0 === b ? (this._position.x = a.x, this._position.y = a.y) : (this._position.x = a, this._position.y = b)
    },
    getPosition: function() {
        return this._position
    },
    getAction: function(a) {
        return this._getEasingAction(cc.moveTo(a, this._position))
    }
});
ccs.ActionScaleFrame = ccs.ActionFrame.extend({
    _scaleX: 1,
    _scaleY: 1,
    ctor: function() {
        ccs.ActionFrame.prototype.ctor.call(this);
        this._scaleY = this._scaleX = 1;
        this.frameType = ccs.FRAME_TYPE_SCALE
    },
    setScaleX: function(a) {
        this._scaleX = a
    },
    getScaleX: function() {
        return this._scaleX
    },
    setScaleY: function(a) {
        this._scaleY = a
    },
    getScaleY: function() {
        return this._scaleY
    },
    getAction: function(a) {
        return this._getEasingAction(cc.scaleTo(a, this._scaleX, this._scaleY))
    }
});
ccs.ActionRotationFrame = ccs.ActionFrame.extend({
    _rotation: 0,
    ctor: function() {
        ccs.ActionFrame.prototype.ctor.call(this);
        this._rotation = 0;
        this.frameType = ccs.FRAME_TYPE_ROTATE
    },
    setRotation: function(a) {
        this._rotation = a
    },
    getRotation: function() {
        return this._rotation
    },
    getAction: function(a, b) {
        return void 0 === b ? this._getEasingAction(cc.rotateTo(a, this._rotation)) : b instanceof cc.ActionRotationFrame ? this._getEasingAction(cc.rotateBy(a, this._rotation - b._rotation)) : this.getAction(a)
    }
});
ccs.ActionFadeFrame = ccs.ActionFrame.extend({
    _opacity: 255,
    ctor: function() {
        ccs.ActionFrame.prototype.ctor.call(this);
        this._opacity = 255;
        this.frameType = ccs.FRAME_TYPE_FADE
    },
    setOpacity: function(a) {
        this._opacity = a
    },
    getOpacity: function() {
        return this._opacity
    },
    getAction: function(a) {
        return this._getEasingAction(cc.fadeTo(a, this._opacity))
    }
});
ccs.ActionTintFrame = ccs.ActionFrame.extend({
    _color: null,
    ctor: function() {
        ccs.ActionFrame.prototype.ctor.call(this);
        this._color = cc.color(255, 255, 255, 255);
        this.frameType = ccs.FRAME_TYPE_TINT
    },
    setColor: function(a) {
        var b = this._color;
        b.r = a.r;
        b.g = a.g;
        b.b = a.b
    },
    getColor: function() {
        var a = this._color;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    getAction: function(a) {
        return this._getEasingAction(cc.tintTo(a, this._color.r, this._color.g, this._color.b))
    }
});
ccs.actionManager = {
    _actionDic: {},
    initWithDictionary: function(a, b, c) {
        var d = a.lastIndexOf("/");
        a = a.substr(d + 1, a.length);
        b = b.actionlist;
        for (var d = [], e = 0; e < b.length; e++) {
            var f = new ccs.ActionObject;
            f.initWithDictionary(b[e], c);
            d.push(f)
        }
        this._actionDic[a] = d
    },
    getActionByName: function(a, b) {
        var c = this._actionDic[a];
        if (!c) return null;
        for (var d = 0; d < c.length; d++) {
            var e = c[d];
            if (b == e.getName()) return e
        }
        return null
    },
    playActionByName: function(a, b, c) {
        (a = this.getActionByName(a, b)) && a.play(c)
    },
    releaseActions: function() {
        this._actionDic = {}
    },
    clear: function() {
        this._actionDic = {}
    }
};
ccs.ActionNode = ccs.Class.extend({
    _currentFrameIndex: 0,
    _destFrameIndex: 0,
    _unitTime: 0,
    _actionTag: 0,
    _object: null,
    _actionSpawn: null,
    _action: null,
    _frameArray: null,
    _frameArrayNum: 0,
    ctor: function() {
        this._destFrameIndex = this._currentFrameIndex = 0;
        this._unitTime = 0.1;
        this._actionTag = 0;
        this._action = this._actionSpawn = this._object = null;
        this._frameArray = [];
        this._frameArrayNum = ccs.FRAME_TYPE_MAX;
        for (var a = 0; a < this._frameArrayNum; a++) this._frameArray.push([])
    },
    initWithDictionary: function(a, b) {
        this.setActionTag(a.ActionTag);
        for (var c = a.actionframelist, d = 0; d < c.length; d++) {
            var e = c[d],
                f = e.frameid,
                g = e.tweenType;
            null == g && (g = 0);
            for (var h = e.tweenParameter, k = [], m = 0; m < h; m++) k.push(e.tweenParameter[m]);
            if (void 0 !== e.positionx) {
                var m = e.positionx,
                    n = e.positiony,
                    h = new ccs.ActionMoveFrame;
                h.frameIndex = f;
                h.setEasingType(g);
                h.setEasingParameter(k);
                h.setPosition(m, n);
                m = this._frameArray[ccs.FRAME_TYPE_MOVE];
                m.push(h)
            }
            void 0 !== e.scalex && (m = e.scalex, n = e.scaley, h = new ccs.ActionScaleFrame, h.frameIndex = f, h.setEasingType(g), h.setEasingParameter(k),
                h.setScaleX(m), h.setScaleY(n), m = this._frameArray[ccs.FRAME_TYPE_SCALE], m.push(h));
            void 0 !== e.rotation && (m = e.rotation, h = new ccs.ActionRotationFrame, h.frameIndex = f, h.setEasingType(g), h.setEasingParameter(k), h.setRotation(m), m = this._frameArray[ccs.FRAME_TYPE_ROTATE], m.push(h));
            void 0 !== e.opacity && (m = e.opacity, h = new ccs.ActionFadeFrame, h.frameIndex = f, h.setEasingType(g), h.setEasingParameter(k), h.setOpacity(m), m = this._frameArray[ccs.FRAME_TYPE_FADE], m.push(h));
            void 0 !== e.colorr && (m = e.colorr, n = e.colorg,
                e = e.colorb, h = new ccs.ActionTintFrame, h.frameIndex = f, h.setEasingType(g), h.setEasingParameter(k), h.setColor(cc.color(m, n, e)), m = this._frameArray[ccs.FRAME_TYPE_TINT], m.push(h))
        }
        this._initActionNodeFromRoot(b)
    },
    _initActionNodeFromRoot: function(a) {
        a instanceof ccui.Widget && (a = ccui.helper.seekActionWidgetByActionTag(a, this.getActionTag())) && this.setObject(a)
    },
    setUnitTime: function(a) {
        this._unitTime = a;
        this._refreshActionProperty()
    },
    getUnitTime: function() {
        return this._unitTime
    },
    setActionTag: function(a) {
        this._actionTag =
            a
    },
    getActionTag: function() {
        return this._actionTag
    },
    setObject: function(a) {
        this._object = a
    },
    getObject: function() {
        return this._object
    },
    getActionNode: function() {
        return this._object instanceof cc.Node ? this._object : null
    },
    insertFrame: function(a, b) {
        null != b && this._frameArray[b.frameType].splice(a, 0, b)
    },
    addFrame: function(a) {
        a && this._frameArray[a.frameType].push(a)
    },
    deleteFrame: function(a) {
        null != a && cc.arrayRemoveObject(this._frameArray[a.frameType], a)
    },
    clearAllFrame: function() {
        for (var a = 0; a < this._frameArrayNum; a++) this._frameArray[a].length =
            0
    },
    _refreshActionProperty: function() {
        if (null == this._object) return null;
        for (var a = [], b = 0; b < this._frameArrayNum; b++) {
            var c = this._frameArray[b];
            if (!(0 >= c.length)) {
                for (var d = [], e = 0; e < c.length; e++) {
                    var f = c[e];
                    if (0 != e) {
                        var g = (f.frameIndex - c[e - 1].frameIndex) * this.getUnitTime();
                        (f = f.getAction(g)) && d.push(f)
                    }
                }
                d && (c = cc.sequence(d), null != c && a.push(c))
            }
        }
        this._action = null;
        return this._actionSpawn = cc.spawn(a)
    },
    playAction: function(a) {
        null == this._object || null == this._actionSpawn || (this._action = a ? cc.sequence(this._actionSpawn,
            a) : cc.sequence(this._actionSpawn), this._runAction())
    },
    _runAction: function() {
        var a = this.getActionNode();
        null != a && null != this._action && a.runAction(this._action)
    },
    stopAction: function() {
        var a = this.getActionNode();
        null != a && null != this._action && (this._action.isDone() || a.stopAction(this._action))
    },
    getFirstFrameIndex: function() {
        for (var a = 99999, b = !1, c = this._frameArray, d = 0, e = this._frameArrayNum; d < e; d++) {
            var f = c[d];
            0 >= f.length || (b = !0, f = f[0].frameIndex, a = a > f ? f : a)
        }
        b || (a = 0);
        return a
    },
    getLastFrameIndex: function() {
        for (var a = -1, b = !1, c = this._frameArray, d = 0, e = this._frameArrayNum; d < e; d++) {
            var f = c[d];
            0 >= f.length || (b = !0, f = f[f.length - 1].frameIndex, a = a < f ? f : a)
        }
        b || (a = 0);
        return a
    },
    updateActionToTimeLine: function(a) {
        for (var b = !1, c = this.getUnitTime(), d = 0; d < this._frameArrayNum; d++) {
            var e = this._frameArray[d];
            if (null != e)
                for (var f = 0; f < e.length; f++) {
                    var g = e[f];
                    if (g.frameIndex * c == a) {
                        this._easingToFrame(1, 1, g);
                        b = !0;
                        break
                    } else if (g.frameIndex * c > a) {
                        0 == f ? (this._easingToFrame(1, 1, g), b = !1) : (b = e[f - 1], e = (g.frameIndex - b.frameIndex) * c, f = a - b.frameIndex *
                            c, this._easingToFrame(e, 1, b), this._easingToFrame(e, f / e, g), b = !0);
                        break
                    }
                }
        }
        return b
    },
    _easingToFrame: function(a, b, c) {
        a = c.getAction(a);
        c = this.getActionNode();
        null == a || null == c || (a.startWithTarget(c), a.update(b))
    },
    isActionDoneOnce: function() {
        return null == this._action ? !0 : this._action.isDone()
    }
});
ccs.ActionObject = ccs.Class.extend({
    _actionNodeList: null,
    _name: "",
    _loop: !1,
    _pause: !1,
    _playing: !1,
    _unitTime: 0,
    _currentTime: 0,
    _scheduler: null,
    _callback: null,
    _fTotalTime: 0,
    ctor: function() {
        this._actionNodeList = [];
        this._name = "";
        this._playing = this._pause = this._loop = !1;
        this._unitTime = 0.1;
        this._fTotalTime = this._currentTime = 0;
        this._scheduler = cc.director.getScheduler()
    },
    setName: function(a) {
        this._name = a
    },
    getName: function() {
        return this._name
    },
    setLoop: function(a) {
        this._loop = a
    },
    getLoop: function() {
        return this._loop
    },
    setUnitTime: function(a) {
        this._unitTime = a;
        a = this._actionNodeList.length;
        for (var b = 0; b < a; b++) this._actionNodeList[b].setUnitTime(this._unitTime)
    },
    getUnitTime: function() {
        return this._unitTime
    },
    getCurrentTime: function() {
        return this._currentTime
    },
    setCurrentTime: function(a) {
        this._currentTime = a
    },
    getTotalTime: function() {
        return this._fTotalTime
    },
    isPlaying: function() {
        return this._playing
    },
    initWithDictionary: function(a, b) {
        this.setName(a.name);
        this.setLoop(a.loop);
        this.setUnitTime(a.unittime);
        for (var c = a.actionnodelist,
            d = 0, e = 0; e < c.length; e++) {
            var f = new ccs.ActionNode;
            f.initWithDictionary(c[e], b);
            f.setUnitTime(this.getUnitTime());
            this._actionNodeList.push(f);
            f = f.getLastFrameIndex() - f.getFirstFrameIndex();
            f > d && (d = f)
        }
        this._fTotalTime = d * this._unitTime
    },
    addActionNode: function(a) {
        a && (this._actionNodeList.push(a), a.setUnitTime(this._unitTime))
    },
    removeActionNode: function(a) {
        null != a && cc.arrayRemoveObject(this._actionNodeList, a)
    },
    play: function(a) {
        this.stop();
        this.updateToFrameByTime(0);
        for (var b = this._actionNodeList, c = b.length,
            d = 0; d < c; d++) b[d].playAction(a);
        this._loop && this._scheduler.scheduleCallbackForTarget(this, this.simulationActionUpdate, 0, cc.REPEAT_FOREVER, 0, !1);
        void 0 !== a && (this._callback = a)
    },
    pause: function() {
        this._pause = !0;
        this._playing = !1
    },
    stop: function() {
        for (var a = this._actionNodeList, b = 0; b < a.length; b++) a[b].stopAction();
        this._scheduler.unscheduleCallbackForTarget(this, this.simulationActionUpdate);
        this._playing = this._pause = !1
    },
    updateToFrameByTime: function(a) {
        this._currentTime = a;
        for (var b = 0; b < this._actionNodeList.length; b++) this._actionNodeList[b].updateActionToTimeLine(a)
    },
    simulationActionUpdate: function(a) {
        a = !0;
        for (var b = this._actionNodeList, c = 0, d = b.length; c < d; c++)
            if (!b[c].isActionDoneOnce()) {
                a = !1;
                break
            }
        a && (null != this._callback && this._callback.execute(), this._loop ? this.play() : (this._playing = !1, this._scheduler.unschedule(this.simulationActionUpdate, this)))
    }
});
ccs.ComAttribute = ccs.Component.extend({
    _jsonDict: null,
    _filePath: "",
    ctor: function() {
        cc.Component.prototype.ctor.call(this);
        this._jsonDict = {};
        this._filePath = "";
        this._name = "CCComAttribute";
        ccs.ComAttribute.prototype.init.call(this)
    },
    init: function() {
        this._jsonDict = {};
        return !0
    },
    setInt: function(a, b) {
        a ? this._jsonDict[a] = b : cc.log("Argument must be non-nil")
    },
    setDouble: function(a, b) {
        a ? this._jsonDict[a] = b : cc.log("Argument must be non-nil")
    },
    setFloat: function(a, b) {
        a ? this._jsonDict[a] = b : cc.log("Argument must be non-nil")
    },
    setBool: function(a, b) {
        a ? this._jsonDict[a] = b : cc.log("Argument must be non-nil")
    },
    setString: function(a, b) {
        a ? this._jsonDict[a] = b : cc.log("Argument must be non-nil")
    },
    setObject: function(a, b) {
        a ? this._jsonDict[a] = b : cc.log("Argument must be non-nil")
    },
    getInt: function(a) {
        return parseInt(this._jsonDict[a] || 0)
    },
    getDouble: function(a) {
        return parseFloat(this._jsonDict[a] || 0)
    },
    getFloat: function(a) {
        return parseFloat(this._jsonDict[a] || 0)
    },
    getBool: function(a) {
        return Boolean(this._jsonDict[a] || !1)
    },
    getString: function(a) {
        return this._jsonDict[a] ||
            ""
    },
    getObject: function(a) {
        return this._jsonDict[a]
    },
    parse: function(a) {
        this._jsonDict = cc.loader.getRes(a)
    }
});
ccs.ComAttribute.create = function() {
    return new ccs.ComAttribute
};
ccs.ComAudio = ccs.Component.extend({
    _filePath: "",
    _loop: !1,
    ctor: function() {
        cc.Component.prototype.ctor.call(this);
        this._name = "Audio";
        ccs.ComAudio.prototype.init.call(this)
    },
    init: function() {
        return !0
    },
    onExit: function() {
        this.stopBackgroundMusic(!0);
        this.stopAllEffects()
    },
    end: function() {
        cc.audioEngine.end()
    },
    preloadBackgroundMusic: function(a) {
        cc.loader.load(a)
    },
    playBackgroundMusic: function(a, b) {
        a ? cc.audioEngine.playMusic(a, b) : cc.audioEngine.playMusic(this._filePath, this._loop)
    },
    stopBackgroundMusic: function(a) {
        cc.audioEngine.stopMusic(a)
    },
    pauseBackgroundMusic: function() {
        cc.audioEngine.pauseMusic()
    },
    resumeBackgroundMusic: function() {
        cc.audioEngine.resumeMusic()
    },
    rewindBackgroundMusic: function() {
        cc.audioEngine.rewindMusic()
    },
    willPlayBackgroundMusic: function() {
        return cc.audioEngine.willPlayMusic()
    },
    isBackgroundMusicPlaying: function() {
        return cc.audioEngine.isMusicPlaying()
    },
    getBackgroundMusicVolume: function() {
        return cc.audioEngine.getMusicVolume()
    },
    setBackgroundMusicVolume: function(a) {
        cc.audioEngine.setMusicVolume(a)
    },
    getEffectsVolume: function() {
        return cc.audioEngine.getEffectsVolume()
    },
    setEffectsVolume: function(a) {
        cc.audioEngine.setEffectsVolume(a)
    },
    playEffect: function(a, b) {
        return a ? cc.audioEngine.playEffect(a, b) : cc.audioEngine.playEffect(this._filePath, this._loop)
    },
    pauseEffect: function(a) {
        cc.audioEngine.pauseEffect(a)
    },
    pauseAllEffects: function() {
        cc.audioEngine.pauseAllEffects()
    },
    resumeEffect: function(a) {
        cc.audioEngine.resumeEffect(a)
    },
    resumeAllEffects: function() {
        cc.audioEngine.resumeAllEffects()
    },
    stopEffect: function(a) {
        cc.audioEngine.stopEffect(a)
    },
    stopAllEffects: function() {
        cc.audioEngine.stopAllEffects()
    },
    preloadEffect: function(a) {
        cc.loader.getRes(a);
        this.setFile(a);
        this.setLoop(!1)
    },
    unloadEffect: function(a) {
        cc.audioEngine.unloadEffect(a)
    },
    setFile: function(a) {
        this._filePath = a
    },
    setLoop: function(a) {
        this._loop = a
    },
    getFile: function() {
        return this._filePath
    },
    isLoop: function() {
        return this._loop
    }
});
ccs.ComAudio.create = function() {
    return new ccs.ComAudio
};
ccs.ComController = ccs.Component.extend({
    ctor: function() {
        cc.Component.prototype.ctor.call(this);
        this._name = "ComController";
        ccs.ComController.prototype.init.call(this)
    },
    onEnter: function() {
        null != this._owner && this._owner.scheduleUpdate()
    },
    isEnabled: function() {
        return this._enabled
    },
    setEnabled: function(a) {
        this._enabled = a
    }
});
ccs.ComController.create = function() {
    return new ccs.ComController
};
ccs.ComRender = ccs.Component.extend({
    _render: null,
    ctor: function(a, b) {
        cc.Component.prototype.ctor.call(this);
        this._render = a;
        this._name = b;
        this.isRenderer = !0;
        ccs.ComRender.prototype.init.call(this)
    },
    onEnter: function() {
        this._owner && this._owner.addChild(this._render)
    },
    onExit: function() {
        this._owner && (this._owner.removeChild(this._render, !0), this._render = null)
    },
    getNode: function() {
        return this._render
    },
    setNode: function(a) {
        this._render = a
    }
});
ccs.ComRender.create = function(a, b) {
    return new ccs.ComRender(a, b)
};
ccs.objectFactory = {
    _typeMap: {},
    createObject: function(a) {
        var b = null;
        (a = this._typeMap[a]) && (b = cc.isFunction(a._fun) ? new a._fun : a._fun);
        return b
    },
    registerType: function(a) {
        this._typeMap[a._className] = a
    },
    createGUI: function(a) {
        var b = null;
        "Panel" === a ? a = "Layout" : "TextArea" === a ? a = "Label" : "TextButton" === a && (a = "Button");
        if ((a = this._typeMap[a]) && a._fun) b = a._fun;
        return b
    },
    removeAll: function() {
        this._typeMap = {}
    }
};
ccs.TInfo = ccs.Class.extend({
    _className: "",
    _fun: null,
    ctor: function(a, b) {
        b ? (this._className = a, this._fun = b) : (this._className = a._className, this._fun = a._fun);
        ccs.objectFactory.registerType(this)
    }
});
ccs.sendEvent = function(a) {
    a = ccs.triggerManager.get(a);
    if (null != a)
        for (var b = 0; b < a.length; b++) {
            var c = a[b];
            null != c && c.detect() && c.done()
        }
};
ccs.registerTriggerClass = function(a, b) {
    new ccs.TInfo(a, b)
};
ccs.triggerManager = {
    _eventTriggers: {},
    _triggerObjs: {},
    _movementDispatches: [],
    parse: function(a) {
        for (var b = 0; b < a.length; ++b) {
            var c = a[b],
                d = new ccs.TriggerObj;
            d.serialize(c);
            for (var c = d.getEvents(), e = 0; e < c.length; e++) this.add(c[e], d);
            this._triggerObjs[d.getId()] = d
        }
    },
    get: function(a) {
        return this._eventTriggers[a]
    },
    getTriggerObj: function(a) {
        return this._triggerObjs[a]
    },
    add: function(a, b) {
        var c = this._eventTriggers[a];
        c || (c = []); - 1 == c.indexOf(b) && (c.push(b), this._eventTriggers[a] = c)
    },
    removeAll: function() {
        for (var a in this._eventTriggers)
            for (var b =
                this._eventTriggers[a], c = 0; c < b.length; c++) b[c].removeAll();
        this._eventTriggers = {}
    },
    remove: function(a, b) {
        if (b) return this._removeObj(a, b);
        var c = !1,
            d = this._eventTriggers[a];
        if (d) {
            for (c = 0; c < d.length; c++) {
                var e = d[c];
                e && e.removeAll()
            }
            delete this._eventTriggers[a];
            c = !0
        }
        return c
    },
    _removeObj: function(a, b) {
        var c = !1;
        do {
            var d = this._eventTriggers[a];
            if (d) {
                for (c = 0; c < d.length; c++) {
                    var e = d[c];
                    if (e && e == b) {
                        e.removeAll();
                        d.splice(c, 1);
                        break
                    }
                }
                c = !0
            }
        } while (0);
        return c
    },
    removeTriggerObj: function(a) {
        a = this.getTriggerObj(a);
        if (!a) return !1;
        for (var b = a.getEvents(), c = 0; c < b.length; c++) this.remove(b[c], a);
        return !0
    },
    isEmpty: function() {
        return !this._eventTriggers || 0 >= this._eventTriggers.length
    },
    addArmatureMovementCallBack: function(a, b, c) {
        if (!(null == a || null == c || null == b)) {
            for (var d, e = !1, f = 0; f < this._movementDispatches.length; f++)
                if ((d = this._movementDispatches[f]) && d[0] == a) d.addAnimationEventCallBack(b, c), e = !0;
            e || (d = new ccs.ArmatureMovementDispatcher, a.getAnimation().setMovementEventCallFunc(d.animationEvent, d), d.addAnimationEventCallBack(b,
                c), this._movementDispatches.push([a, d]))
        }
    },
    removeArmatureMovementCallBack: function(a, b, c) {
        if (!(null == a || null == b || null == c))
            for (var d, e = 0; e < this._movementDispatches.length; e++)(d = this._movementDispatches[e]) && d[0] == a && d.removeAnimationEventCallBack(c, b)
    },
    removeArmatureAllMovementCallBack: function(a) {
        if (null != a)
            for (var b, c = 0; c < this._movementDispatches.length; c++)
                if ((b = this._movementDispatches[c]) && b[0] == a) {
                    this._movementDispatches.splice(c, 1);
                    break
                }
    },
    removeAllArmatureMovementCallBack: function() {
        this._movementDispatches.length =
            0
    },
    version: function() {
        return "1.2.0.0"
    }
};
ccs.ArmatureMovementDispatcher = ccs.Class.extend({
    _mapEventAnimation: null,
    ctor: function() {
        this._mapEventAnimation = []
    },
    animationEvent: function(a, b, c) {
        for (var d, e, f = 0; f < this._mapEventAnimation.length; f++) d = this._mapEventAnimation[f], e = d[0], (d = d[1]) && d.call(e, a, b, c)
    },
    addAnimationEventCallBack: function(a, b) {
        this._mapEventAnimation.push([b, a])
    },
    removeAnimationEventCallBack: function(a, b) {
        for (var c, d = 0; d < this._mapEventAnimation.length; d++) c = this._mapEventAnimation[d], c[0] == b && this._mapEventAnimation.splice(d,
            1)
    }
});
ccs.BaseTriggerCondition = ccs.Class.extend({
    ctor: function() {},
    init: function() {
        return !0
    },
    detect: function() {
        return !0
    },
    serialize: function(a) {},
    removeAll: function() {}
});
ccs.BaseTriggerAction = ccs.Class.extend({
    ctor: function() {},
    init: function() {
        return !0
    },
    done: function() {},
    serialize: function(a) {},
    removeAll: function() {}
});
ccs.TriggerObj = ccs.Class.extend({
    _cons: null,
    _acts: null,
    _id: 0,
    _enable: !0,
    _vInt: null,
    ctor: function() {
        this._id = 0;
        this._enable = !0;
        ccs.TriggerObj.prototype.init.call(this)
    },
    init: function() {
        this._cons = [];
        this._acts = [];
        this._vInt = [];
        return !0
    },
    detect: function() {
        if (!this._enable || 0 == this._cons.length) return !0;
        for (var a = !0, b = null, c = 0; c < this._cons.length; c++)(b = this._cons[c]) && b.detect && (a = a && b.detect());
        return a
    },
    done: function() {
        if (this._enable && 0 != this._acts.length)
            for (var a, b = 0; b < this._acts.length; b++)(a =
                this._acts[b]) && a.done && a.done()
    },
    removeAll: function() {
        for (var a = null, b = 0; b < this._cons.length; b++)(a = this._cons[b]) && a.removeAll();
        this._cons = [];
        for (b = 0; b < this._acts.length; b++)(a = this._acts[b]) && a.removeAll();
        this._acts = []
    },
    serialize: function(a) {
        this._id = a.id || 0;
        for (var b = a.conditions || [], c = 0; c < b.length; c++) {
            var d = b[c],
                e = d.classname,
                f = ccs.objectFactory.createObject(e);
            f ? (f.serialize(d), f.init(), this._cons.push(f)) : cc.log("class named classname(" + e + ") can not implement!")
        }
        b = a.actions || [];
        for (c = 0; c <
            b.length; c++) d = b[c], e = d.classname, (f = ccs.objectFactory.createObject(e)) ? (f.serialize(d), f.init(), this._acts.push(f)) : cc.log("class named classname(" + e + ") can not implement!");
        a = a.events || [];
        for (c = 0; c < a.length; c++) d = a[c], d = d.id, 0 > d || this._vInt.push(d)
    },
    getId: function() {
        return this._id
    },
    setEnable: function(a) {
        this._enable = a
    },
    getEvents: function() {
        return this._vInt
    }
});
ccs.TriggerObj.create = function() {
    return new ccs.TriggerObj
};
ccs.buttonReader = {
    setPropsFromJsonDictionary: function(a, b) {
        ccs.widgetReader.setPropsFromJsonDictionary.call(this, a, b);
        var c = ccs.uiReader.getFilePath(),
            d = b.scale9Enable;
        a.setScale9Enabled(d);
        var e = b.normalData;
        switch (e.resourceType) {
            case 0:
                e = e.path;
                a.loadTextureNormal(e && "" !== e ? c + e : null);
                break;
            case 1:
                e = e.path, a.loadTextureNormal(e, 1)
        }
        e = b.pressedData;
        switch (e.resourceType) {
            case 0:
                e = e.path;
                a.loadTexturePressed(e && "" !== e ? c + e : null);
                break;
            case 1:
                e = e.path, a.loadTexturePressed(e, 1)
        }
        e = b.disabledData;
        switch (e.resourceType) {
            case 0:
                e =
                    e.path;
                a.loadTextureDisabled(e && "" !== e ? c + e : null);
                break;
            case 1:
                e = e.path, a.loadTextureDisabled(e, 1)
        }
        d && (a.setCapInsets(cc.rect(b.capInsetsX, b.capInsetsY, b.capInsetsWidth, b.capInsetsHeight)), c = b.scale9Width, d = b.scale9Height, null != c && null != d && a.setSize(cc.size(c, d)));
        c = b.text;
        null != c && a.setTitleText(c);
        a.setTitleColor(cc.color(null !== b.textColorR ? b.textColorR : 255, null !== b.textColorG ? b.textColorG : 255, null !== b.textColorB ? b.textColorB : 255));
        null != b.fontSize && a.setTitleFontSize(b.fontSize);
        b.fontName && a.setTitleFontName(b.fontName);
        ccs.widgetReader.setColorPropsFromJsonDictionary.call(this, a, b)
    },
    setPropsFromProtocolBuffers: function(a, b) {
        ccs.widgetReader.setPropsFromProtocolBuffers.call(this, a, b);
        var c = b.buttonOptions,
            d = ccs.uiReader.getFilePath(),
            e = c.scale9Enable;
        a.setScale9Enabled(e);
        var f = c.normalData,
            g = f.resourceType,
            f = ccs.widgetReader.getResourcePath(f.path, g);
        a.loadTextureNormal(f, g);
        f = c.pressedData;
        g = f.resourceType;
        f = ccs.widgetReader.getResourcePath(f.path, g);
        a.loadTexturePressed(f, g);
        f = c.disabledData;
        g = f.resourceType;
        f = ccs.widgetReader.getResourcePath(f.path, g);
        a.loadTextureDisabled(f, g);
        e && (a.setUnifySizeEnabled(!1), a.ignoreContentAdaptWithSize(!1), a.setCapInsets(cc.rect(c.capInsetsX, c.capInsetsY, c.capInsetsWidth, c.capInsetsHeight)), e = c.scale9Width, g = c.scale9Height, e && g && a.setContentSize(cc.size(e, g)));
        (e = c.text) && a.setTitleText(e);
        a.setTitleColor(cc.color(null !== c.textColorR ? c.textColorR : 255, null !== c.textColorG ? c.textColorG : 255, null !== c.textColorB ? c.textColorB : 255));
        a.setTitleFontSize(null !== c.fontSize ? c.fontSize :
            14);
        e = !0;
        null !== c.displaystate && (e = c.displaystate);
        a.setBright(e);
        a.setTitleFontName(null !== c.fontName ? c.fontName : "\u5fae\u8f6f\u96c5\u9ed1");
        c.fontResource && a.setTitleFontName(d + c.fontResource.path);
        c = b.widgetOptions;
        a.setColor(cc.color(c.colorR, c.colorG, c.colorB));
        a.setOpacity(null !== c.Alpha ? c.Alpha : 255);
        ccs.widgetReader.setColorPropsFromProtocolBuffers.call(this, a, b)
    }
};
ccs.checkBoxReader = {
    setPropsFromJsonDictionary: function(a, b) {
        ccs.widgetReader.setPropsFromJsonDictionary.call(this, a, b);
        var c = b.backGroundBoxData,
            d = c.resourceType,
            c = ccs.widgetReader._getResourcePath(c, "path", d);
        a.loadTextureBackGround(c, d);
        var e = b.backGroundBoxSelectedData,
            f = e.resourceType,
            e = ccs.widgetReader._getResourcePath(e, "path", f);
        e || (f = d, e = c);
        a.loadTextureBackGroundSelected(e, f);
        c = b.frontCrossData;
        d = c.resourceType;
        c = ccs.widgetReader._getResourcePath(c, "path", d);
        a.loadTextureFrontCross(c, d);
        e = b.backGroundBoxDisabledData;
        f = e.resourceType;
        e = ccs.widgetReader._getResourcePath(e, "path", f);
        e || (f = d, e = c);
        a.loadTextureBackGroundDisabled(e, f);
        c = b.frontCrossDisabledData;
        d = c.resourceType;
        c = ccs.widgetReader._getResourcePath(c, "path", d);
        a.loadTextureFrontCrossDisabled(c, d);
        b.selectedState && a.setSelected(b.selectedState);
        ccs.widgetReader.setColorPropsFromJsonDictionary.call(this, a, b)
    },
    setPropsFromProtocolBuffers: function(a, b) {
        ccs.widgetReader.setPropsFromProtocolBuffers.call(this, a, b);
        var c = b.checkBoxOptions,
            d = ccs.uiReader.getFilePath(),
            e = c.backGroundBoxData,
            f = e.resourceType;
        1 == f && cc.spriteFrameCache.addSpriteFrames(d + e.plistFile);
        d = ccs.widgetReader.getResourcePath(e.path, f);
        a.loadTextureBackGround(d, f);
        d = c.backGroundBoxSelectedData;
        f = d.resourceType;
        d = ccs.widgetReader.getResourcePath(d.path, f);
        a.loadTextureBackGroundSelected(d, f);
        d = c.frontCrossData;
        f = d.resourceType;
        d = ccs.widgetReader.getResourcePath(d.path, f);
        a.loadTextureFrontCross(d, f);
        d = c.backGroundBoxDisabledData;
        f = d.resourceType;
        d = ccs.widgetReader.getResourcePath(d.path,
            f);
        a.loadTextureBackGroundDisabled(d, f);
        d = c.frontCrossDisabledData;
        f = d.resourceType;
        d = ccs.widgetReader.getResourcePath(d.path, f);
        a.loadTextureFrontCrossDisabled(d, f);
        a.setSelected(c.selectedState);
        f = !0;
        null !== c.displaystate && (f = c.displaystate);
        a.setBright(f);
        ccs.widgetReader.setColorPropsFromProtocolBuffers.call(this, a, b)
    },
    getResourceType: function(a) {
        return "Normal" == a || "Default" == a || "MarkedSubImage" == a ? 0 : 1
    }
};
ccs.imageViewReader = {
    setPropsFromJsonDictionary: function(a, b) {
        ccs.widgetReader.setPropsFromJsonDictionary.call(this, a, b);
        var c = ccs.uiReader.getFilePath(),
            d = b.fileNameData;
        switch (d.resourceType) {
            case 0:
                (d = d.path) && "" !== d && a.loadTexture(c + d);
                break;
            case 1:
                d = d.path, a.loadTexture(d, 1)
        }
        c = !1;
        b.scale9Enable && (c = b.scale9Enable);
        a.setScale9Enabled(c);
        c && (c = b.scale9Height, b.scale9Width && c && a.setSize(cc.size(b.scale9Width, b.scale9Height)), a.setCapInsets(cc.rect(b.capInsetsX, b.capInsetsY, b.capInsetsWidth, b.capInsetsHeight)));
        ccs.widgetReader.setColorPropsFromJsonDictionary.call(this, a, b)
    },
    setPropsFromProtocolBuffers: function(a, b) {
        ccs.widgetReader.setPropsFromProtocolBuffers.call(this, a, b);
        var c = b.imageViewOptions;
        ccs.uiReader.getFilePath();
        var d = c.fileNameData,
            e = d.resourceType,
            d = ccs.widgetReader.getResourcePath(d.path, e);
        a.loadTexture(d, e);
        e = !1;
        null !== c.scale9Enable && (e = c.scale9Enable);
        a.setScale9Enabled(e);
        e && (a.setUnifySizeEnabled(!1), a.ignoreContentAdaptWithSize(!1), a.setContentSize(cc.size(null !== c.scale9width ? c.scale9Width :
            80, null !== c.scale9height ? c.scale9Height : 80)), a.setCapInsets(cc.rect(c.capInsetsX, c.capInsetsY, null !== c.capInsetsWidth ? c.capInsetsWidth : 1, null !== c.capInsetsHeight ? c.capInsetsHeight : 1)));
        ccs.widgetReader.setColorPropsFromProtocolBuffers.call(this, a, b);
        e = c.flippedX;
        c = c.flippedY;
        !1 != e && a.setFlippedX(e);
        !1 != c && a.setFlippedY(c)
    }
};
ccs.labelAtlasReader = {
    setPropsFromJsonDictionary: function(a, b) {
        ccs.widgetReader.setPropsFromJsonDictionary.call(this, a, b);
        var c = ccs.uiReader.getFilePath(),
            d = b.stringValue,
            e = b.charMapFileData,
            f = b.itemWidth,
            g = b.itemHeight,
            h = b.startCharMap;
        if (null != d && e && null != f && null != g && null != h) switch (e = b.charMapFileData, e.resourceType) {
            case 0:
                a.setProperty(d, c + e.path, f, g, h);
                break;
            case 1:
                cc.log("Wrong res type of LabelAtlas!")
        }
        ccs.widgetReader.setColorPropsFromJsonDictionary.call(this, a, b)
    },
    setPropsFromProtocolBuffers: function(a,
        b) {
        ccs.widgetReader.setPropsFromProtocolBuffers.call(this, a, b);
        var c = ccs.uiReader.getFilePath(),
            d = b.textAtlasOptions,
            e = d.charMapFileData;
        switch (e.resourceType) {
            case 0:
                a.setProperty(null !== d.stringValue ? d.stringValue : "12345678", c + e.path, null !== d.itemWidth ? d.itemWidth : 24, null !== d.itemHeight ? d.itemHeight : 32, d.startCharMap);
                break;
            case 1:
                cc.log("Wrong res type of LabelAtlas!")
        }
        ccs.widgetReader.setColorPropsFromProtocolBuffers.call(this, a, b)
    }
};
ccs.labelBMFontReader = {
    setPropsFromJsonDictionary: function(a, b) {
        ccs.widgetReader.setPropsFromJsonDictionary.call(this, a, b);
        var c = ccs.uiReader.getFilePath(),
            d = b.fileNameData;
        switch (d.resourceType) {
            case 0:
                a.setFntFile(c + d.path);
                break;
            case 1:
                cc.log("Wrong res type of LabelAtlas!")
        }
        a.setString(b.text);
        ccs.widgetReader.setColorPropsFromJsonDictionary.call(this, a, b)
    },
    setPropsFromProtocolBuffers: function(a, b) {
        ccs.widgetReader.setPropsFromProtocolBuffers.call(this, a, b);
        var c = ccs.uiReader.getFilePath(),
            d =
            b.textBMFontOptions;
        if (d) {
            var e = d.fileNameData;
            switch (e.resourceType) {
                case 0:
                    a.setFntFile(c + e.path);
                    break;
                case 1:
                    cc.log("Wrong res type of LabelAtlas!")
            }
            a.setString(null !== d.text ? d.text : "Text Label")
        }
        ccs.widgetReader.setColorPropsFromProtocolBuffers.call(this, a, b)
    }
};
ccs.labelReader = {
    setPropsFromJsonDictionary: function(a, b) {
        ccs.widgetReader.setPropsFromJsonDictionary.call(this, a, b);
        a.setTouchScaleChangeEnabled(b.touchScaleEnable);
        a.setString(b.text);
        null != b.fontSize && a.setFontSize(b.fontSize);
        null != b.fontName && a.setFontName(b.fontName);
        var c = b.areaHeight;
        null != b.areaWidth && null != c && (c = cc.size(b.areaWidth, b.areaHeight), a.setTextAreaSize(c));
        null != b.hAlignment && a.setTextHorizontalAlignment(b.hAlignment);
        null != b.vAlignment && a.setTextVerticalAlignment(b.vAlignment);
        ccs.widgetReader.setColorPropsFromJsonDictionary.call(this, a, b)
    },
    setPropsFromProtocolBuffers: function(a, b) {
        var c = b.textOptions;
        a.ignoreContentAdaptWithSize(!c.IsCustomSize);
        ccs.widgetReader.setPropsFromProtocolBuffers.call(this, a, b);
        a.setUnifySizeEnabled(!1);
        var d = ccs.uiReader.getFilePath();
        a.setTouchScaleChangeEnabled(c.touchScaleEnable);
        a.setString(null !== c.text ? c.text : "Text Label");
        a.setFontSize(null !== c.fontSize ? c.fontSize : 20);
        a.setFontName(null !== c.fontName ? c.fontName : "\u5fae\u8f6f\u96c5\u9ed1");
        var e = c.areaWidth,
            f = c.areaHeight;
        null !== e && null !== f && (e = cc.size(e, f), a.setTextAreaSize(e));
        (e = c.hAlignment) && a.setTextHorizontalAlignment(e);
        (e = c.vAlignment) && a.setTextVerticalAlignment(e);
        c.fontResource && a.setFontName(d + c.fontResource.path);
        ccs.widgetReader.setColorPropsFromProtocolBuffers.call(this, a, b)
    }
};
ccs.layoutReader = {
    setPropsFromJsonDictionary: function(a, b) {
        ccs.widgetReader.setPropsFromJsonDictionary.call(this, a, b);
        var c = ccs.uiReader.getFilePath(),
            d = 0,
            e = 0;
        b.adaptScreen ? (e = cc.director.getWinSize(), d = e.width, e = e.height) : (d = b.width, e = b.height);
        a.setSize(cc.size(d, e));
        a.setClippingEnabled(b.clipAble);
        d = b.backGroundScale9Enable;
        a.setBackGroundImageScale9Enabled(d);
        var e = b.bgColorR,
            f = b.bgColorG,
            g = b.bgColorB,
            h = b.bgStartColorR,
            k = b.bgStartColorG,
            m = b.bgStartColorB,
            n = b.bgEndColorR,
            q = b.bgEndColorG,
            r = b.bgEndColorB;
        a.setBackGroundColorVector(cc.p(b.vectorX, b.vectorY));
        var s = b.bgColorOpacity;
        a.setBackGroundColorType(b.colorType);
        a.setBackGroundColor(cc.color(h, k, m), cc.color(n, q, r));
        a.setBackGroundColor(cc.color(e, f, g));
        a.setBackGroundColorOpacity(s);
        if (e = b.backGroundImageData) switch (e.resourceType) {
            case 0:
                e = e.path;
                a.setBackGroundImage(e && "" !== e ? c + e : null);
                break;
            case 1:
                e = e.path, a.setBackGroundImage(e, 1)
        }
        d && a.setBackGroundImageCapInsets(cc.rect(b.capInsetsX, b.capInsetsY, b.capInsetsWidth, b.capInsetsHeight));
        a.setLayoutType(b.layoutType);
        ccs.widgetReader.setColorPropsFromJsonDictionary.call(this, a, b)
    },
    setPropsFromProtocolBuffers: function(a, b) {
        ccs.widgetReader.setPropsFromProtocolBuffers.call(this, a, b);
        var c = b.PanelOptions;
        if (c) {
            ccs.uiReader.getFilePath();
            a.setClippingEnabled(c.clipAble);
            var d = c.backGroundScale9Enable;
            a.setBackGroundImageScale9Enabled(d);
            var e, f, g, h, k, m, n, q, r;
            a instanceof ccui.PageView ? (g = f = e = 150, n = m = k = h = 255, q = 150, r = 100) : a instanceof ccui.ListView ? (f = e = 150, m = k = h = g = 255, q = n = 150, r = 255) : a instanceof ccui.ScrollView ? (e =
                255, f = 150, g = 100, n = m = k = h = 255, q = 150, r = 100) : (e = 150, f = 200, m = k = h = g = 255, n = 150, q = 200, r = 255);
            e = null !== c.bgColorR ? c.bgColorR : e;
            f = null !== c.bgColorG ? c.bgColorG : f;
            g = null !== c.bgColorB ? c.bgColorB : g;
            h = null !== c.bgStartColorR ? c.bgStartColorR : h;
            k = null !== c.bgStartColorG ? c.bgStartColorG : k;
            m = null !== c.bgStartColorB ? c.bgStartColorB : m;
            n = null !== c.bgEndColorR ? c.bgEndColorR : n;
            q = null !== c.bgEndColorG ? c.bgEndColorG : q;
            r = null !== c.bgEndColorB ? c.bgEndColorB : r;
            var s = 0,
                t = -0.5;
            null !== c.vectorX && (s = c.vectorX);
            c.vectorY && (t = c.vectorY);
            a.setBackGroundColorVector(cc.p(s, t));
            s = null !== c.bgColorOpacity ? c.bgColorOpacity : 100;
            a.setBackGroundColorType(null !== c.colorType ? c.colorType : 1);
            a.setBackGroundColor(cc.color(h, k, m), cc.color(n, q, r));
            a.setBackGroundColor(cc.color(e, f, g));
            a.setBackGroundColorOpacity(s);
            if (f = c.backGroundImageData) e = f.resourceType, f = ccs.widgetReader.getResourcePath(f.path, e), a.setBackGroundImage(f, e);
            d && (d = c.scale9Width, e = c.scale9Height, null != d && null !== e && a.setContentSize(cc.size(d, e)));
            a.setLayoutType(c.layoutType);
            c =
                b.widgetOptions;
            a.setColor(cc.color(null !== c.colorR ? c.colorR : 255, null !== c.colorG ? c.colorG : 255, null !== c.colorB ? c.colorB : 255));
            a.setOpacity(null !== c.Alpha ? c.Alpha : 255);
            ccs.widgetReader._setAnchorPointForWidget(a, b);
            d = c.flipY;
            a.setFlippedX(c.flipX);
            a.setFlippedY(d)
        }
    }
};
ccs.scrollViewReader = {
    setPropsFromJsonDictionary: function(a, b) {
        ccs.layoutReader.setPropsFromJsonDictionary.call(this, a, b);
        a.setInnerContainerSize(cc.size(null != b.innerWidth ? b.innerWidth : 200, null != b.innerHeight ? b.innerHeight : 200));
        a.setDirection(null != b.direction ? b.direction : 1);
        a.setBounceEnabled(b.bounceEnable);
        ccs.widgetReader.setColorPropsFromJsonDictionary.call(this, a, b)
    },
    setPropsFromProtocolBuffers: function(a, b) {
        ccs.widgetReader.setPropsFromProtocolBuffers.call(this, a, b);
        var c = b.scrollViewOptions;
        ccs.uiReader.getFilePath();
        a.setClippingEnabled(c.clipAble);
        var d = c.backGroundScale9Enable;
        a.setBackGroundImageScale9Enabled(d);
        var e, f, g, h, k, m, n, q, r;
        e = null !== c.bgColorR ? c.bgColorR : 255;
        f = null !== c.bgColorG ? c.bgColorG : 150;
        g = null !== c.bgColorB ? c.bgColorB : 100;
        h = null !== c.bgStartColorR ? c.bgStartColorR : 255;
        k = null !== c.bgStartColorG ? c.bgStartColorG : 255;
        m = null !== c.bgStartColorB ? c.bgStartColorB : 255;
        n = null !== c.bgEndColorR ? c.bgEndColorR : 255;
        q = null !== c.bgEndColorG ? c.bgEndColorG : 150;
        r = null !== c.bgEndColorB ? c.bgEndColorB :
            100;
        var s = 0,
            t = -0.5;
        c.vectorX && (s = c.vectorX);
        null !== c.vectorY && (t = c.vectorY);
        a.setBackGroundColorVector(cc.p(s, t));
        s = null !== c.bgColorOpacity ? c.bgColorOpacity : 100;
        a.setBackGroundColorType(c.colorType ? c.colorType : 1);
        a.setBackGroundColor(cc.color(h, k, m), cc.color(n, q, r));
        a.setBackGroundColor(cc.color(e, f, g));
        a.setBackGroundColorOpacity(s);
        if (f = c.backGroundImageData) e = f.resourceType, f = ccs.widgetReader.getResourcePath(f.path, e), a.setBackGroundImage(f, e);
        d && (a.setBackGroundImageCapInsets(cc.rect(c.capInsetsX,
            c.capInsetsY, null !== c.capInsetsWidth ? c.capInsetsWidth : 1, null !== c.capInsetsHeight ? c.capInsetsHeight : 1)), d = c.scale9Width, e = c.scale9Height, null != d && null != e && a.setContentSize(cc.size(d, e)));
        a.setLayoutType(c.layoutType);
        d = b.widgetOptions;
        a.setColor(cc.color(null !== d.colorR ? d.colorR : 255, d.colorG ? d.colorG : 255, d.colorB ? d.colorB : 255));
        a.setOpacity(null !== d.Alpha ? d.Alpha : 255);
        a.setInnerContainerSize(cc.size(null !== c.innerWidth ? c.innerWidth : 200, null !== c.innerHeight ? c.innerHeight : 200));
        a.setDirection(null !==
            c.direction ? c.direction : 1);
        a.setBounceEnabled(c.bounceenAble);
        ccs.widgetReader.setAnchorPointForWidget(a, b);
        c = d.flipY;
        a.setFlippedX(d.flipX);
        a.setFlippedY(c)
    }
};
ccs.listViewReader = {
    setPropsFromJsonDictionary: function(a, b) {
        ccs.scrollViewReader.setPropsFromJsonDictionary.call(this, a, b);
        a.setDirection(b.direction);
        a.setGravity(b.gravity);
        a.setItemsMargin(b.itemMargin)
    },
    setPropsFromProtocolBuffers: function(a, b) {
        ccs.widgetReader.setPropsFromProtocolBuffers.call(this, a, b);
        var c = b.listviewOptions;
        ccs.uiReader.getFilePath();
        a.setClippingEnabled(c.clipAble);
        var d = c.backGroundScale9enAble;
        a.setBackGroundImageScale9Enabled(d);
        var e, f, g, h, k, m, n, q, r;
        e = null !== c.bgColorR ?
            c.bgColorR : 150;
        f = null !== c.bgColorG ? c.bgColorG : 150;
        g = null !== c.bgColorB ? c.bgColorB : 255;
        h = null !== c.bgStartColorR ? c.bgStartColorR : 255;
        k = null !== c.bgStartColorG ? c.bgStartColorG : 255;
        m = null !== c.bgStartColorB ? c.bgStartColorB : 255;
        n = null !== c.bgEndColorR ? c.bgEndColorR : 150;
        q = null !== c.bgEndColorG ? c.bgEndColorG : 150;
        r = null !== c.bgEndColorB ? c.bgEndColorB : 255;
        a.setBackGroundColorVector(cc.p(c.vectorX, null !== c.ectorY ? c.vectorY : -0.5));
        var s = null !== c.bgColorOpacity ? c.bgColorOpacity : 100;
        a.setBackGroundColorType(null !==
            c.colorType ? c.colorType : 1);
        a.setBackGroundColor(cc.color(h, k, m), cc.color(n, q, r));
        a.setBackGroundColor(cc.color(e, f, g));
        a.setBackGroundColorOpacity(s);
        f = c.backGroundImageData;
        e = f.resourceType;
        f = ccs.widgetReader.getResourcePath(f.path, e);
        a.setBackGroundImage(f, e);
        d && (a.setBackGroundImageCapInsets(cc.rect(c.capInsetsX, c.capInsetsY, null !== c.capInsetsWidth ? c.capInsetsWidth : 1, null !== c.capInsetsHeight ? c.capInsetsHeight : 1)), d = c.scale9width, e = c.scale9height, null != d && null != e && a.setContentSize(cc.size(d, e)));
        d = b.widgetOptions;
        a.setColor(cc.color(null !== d.colorR ? d.colorR : 255, null !== d.colorG ? d.colorG : 255, null !== d.colorB ? d.colorB : 255));
        a.setOpacity(null != d.Alpha ? d.Alpha : 255);
        a.setInnerContainerSize(cc.size(null !== c.innerWidth ? c.innerWidth : 200, null !== c.innerHeight ? c.innerHeight : 200));
        a.setBounceEnabled(c.bounceEnable);
        a.setDirection(null != c.direction ? c.direction : 2);
        a.setGravity(null !== c.gravity ? c.gravity : 3);
        a.setItemsMargin(c.itemMargin);
        ccs.widgetReader.setAnchorPointForWidget(a, b);
        c = d.flipY;
        a.setFlippedX(d.flipX);
        a.setFlippedY(c)
    }
};
ccs.loadingBarReader = {
    setPropsFromJsonDictionary: function(a, b) {
        ccs.widgetReader.setPropsFromJsonDictionary.call(this, a, b);
        var c = ccs.uiReader.getFilePath(),
            d = b.textureData;
        switch (d.resourceType) {
            case 0:
                (d = d.path) && "" !== d && a.loadTexture(c + d);
                break;
            case 1:
                d = d.path, a.loadTexture(d, 1)
        }
        c = b.scale9Enable;
        a.setScale9Enabled(c);
        c && (a.setCapInsets(cc.rect(b.capInsetsX, b.capInsetsY, b.capInsetsWidth, b.capInsetsHeight)), a.setSize(cc.size(b.width, b.height)));
        a.setDirection(b.direction);
        a.setPercent(b.percent);
        ccs.widgetReader.setColorPropsFromJsonDictionary.call(this,
            a, b)
    },
    setPropsFromProtocolBuffers: function(a, b) {
        ccs.widgetReader.setPropsFromProtocolBuffers.call(this, a, b);
        var c = b.loadingBarOptions;
        ccs.uiReader.getFilePath();
        var d = c.textureData,
            e = d.resourceType,
            d = ccs.widgetReader.getResourcePath(d.path, e);
        a.loadTexture(d, e);
        e = c.scale9Enable;
        a.setScale9Enabled(e);
        var d = c.capinsetsX,
            f = c.capinsetsY,
            g = null != c.capinsetsWidth ? c.capinsetsWidth : 1,
            h = null != c.capinsetsHeight ? c.capinsetsHeight : 1;
        e && a.setCapInsets(cc.rect(d, f, g, h));
        e = b.widgetOptions;
        a.setContentSize(cc.size(e.width,
            e.height));
        a.setDirection(c.direction);
        a.setPercent(null !== c.percent ? c.percent : 100);
        ccs.widgetReader.setColorPropsFromProtocolBuffers.call(this, a, b)
    }
};
ccs.pageViewReader = {
    setPropsFromJsonDictionary: function(a, b) {
        ccs.layoutReader.setPropsFromJsonDictionary.call(this, a, b)
    },
    setPropsFromProtocolBuffers: function(a, b) {
        ccs.widgetReader.setPropsFromProtocolBuffers.call(this, a, b);
        var c = b.pageViewOptions;
        ccs.uiReader.getFilePath();
        a.setClippingEnabled(c.clipAble);
        var d = c.backGroundScale9Enable;
        a.setBackGroundImageScale9Enabled(d);
        var e, f, g, h, k, m, n, q, r;
        e = null !== c.bgColorR ? c.bgColorR : 150;
        f = null !== c.bgColorG ? c.bgColorG : 150;
        g = null !== c.bgColorB ? c.bgColorB : 150;
        h = null !== c.bgStartColorR ? c.bgStartColorR : 255;
        k = null !== c.bgStartColorG ? c.bgStartColorG : 255;
        m = null !== c.bgStartColorB ? c.bgStartColorB : 255;
        n = null !== c.bgEndColorR ? c.bgEndColorR : 255;
        q = null !== c.bgEndColorG ? c.bgEndColorG : 150;
        r = null !== c.bgEndColorB ? c.bgEndColorB : 100;
        var s = 0,
            t = -0.5;
        null !== c.vectorX && (s = c.vectorX);
        null !== c.vectorY && (t = c.vectorY);
        a.setBackGroundColorVector(cc.p(s, t));
        s = null !== c.bgColorOpacity ? c.bgColorOpacity : 100;
        a.setBackGroundColorType(null !== c.colorType ? c.colorType : 1);
        a.setBackGroundColor(cc.color(h,
            k, m), cc.color(n, q, r));
        a.setBackGroundColor(cc.color(e, f, g));
        a.setBackGroundColorOpacity(s);
        if (f = c.backGroundImageData) e = f.resourceType, f = ccs.widgetReader.getResourcePath(f.path, e), a.setBackGroundImage(f, e);
        d && (a.setBackGroundImageCapInsets(cc.rect(c.capInsetsX, c.capInsetsY, null !== c.capInsetsWidth ? c.capInsetsWidth : 1, null !== c.capInsetsHeight ? c.capInsetsHeight : 1)), d = c.scale9Width, c = c.scale9Height, null != d && null != c && a.setContentSize(cc.size(d, c)));
        c = b.widgetOptions;
        a.setColor(cc.color(null !== c.colorR ?
            c.colorR : 255, null !== c.colorG ? c.colorG : 255, null !== c.colorB ? c.colorB : 255));
        a.setOpacity(null !== c.Alpha ? c.Alpha : 255);
        ccs.widgetReader.setAnchorPointForWidget(a, b);
        d = c.flipY;
        a.setFlippedX(c.flipX);
        a.setFlippedY(d)
    }
};
ccs.sliderReader = {
    setPropsFromJsonDictionary: function(a, b) {
        ccs.widgetReader.setPropsFromJsonDictionary.call(this, a, b);
        var c = ccs.uiReader.getFilePath(),
            d = b.scale9Enable;
        a.setScale9Enabled(d);
        var e = b.length,
            f = b.barFileNameData,
            g = f.resourceType,
            f = f.path;
        if (null != b.barFileName) {
            if (d) {
                switch (g) {
                    case 0:
                        a.loadBarTexture(f ? c + f : null);
                        break;
                    case 1:
                        a.loadBarTexture(f, 1)
                }
                a.setSize(cc.size(e, a.getContentSize().height))
            }
        } else switch (g) {
            case 0:
                a.loadBarTexture(f ? c + f : null);
                break;
            case 1:
                a.loadBarTexture(f, 1)
        }
        e = b.ballNormalData;
        d = e.resourceType;
        e = e.path;
        switch (d) {
            case 0:
                a.loadSlidBallTextureNormal(e ? c + e : null);
                break;
            case 1:
                a.loadSlidBallTextureNormal(e, 1)
        }
        f = b.ballPressedData;
        g = f.resourceType;
        f = f.path;
        null === f && (g = d, f = e);
        switch (g) {
            case 0:
                a.loadSlidBallTexturePressed(f ? c + f : null);
                break;
            case 1:
                a.loadSlidBallTexturePressed(f, 1)
        }
        d = b.ballDisabledData;
        e = d.path;
        switch (d.resourceType) {
            case 0:
                a.loadSlidBallTextureDisabled(e ? c + e : null);
                break;
            case 1:
                a.loadSlidBallTextureDisabled(e, 1)
        }
        d = b.progressBarData;
        e = d.path;
        switch (d.resourceType) {
            case 0:
                a.loadProgressBarTexture(e ?
                    c + e : null);
                break;
            case 1:
                a.loadProgressBarTexture(e, 1)
        }
        ccs.widgetReader.setColorPropsFromJsonDictionary.call(this, a, b)
    },
    setPropsFromProtocolBuffers: function(a, b) {
        ccs.widgetReader.setPropsFromProtocolBuffers.call(this, a, b);
        var c = b.sliderOptions;
        ccs.uiReader.getFilePath();
        var d = !!c.scale9Enable;
        d && a.setUnifySizeEnabled(!1);
        a.setScale9Enabled(d);
        a.setPercent(c.percent);
        var e = null !== c.length ? c.length : 290,
            f = c.barFileNameData,
            g = f.resourceType,
            f = ccs.widgetReader.getResourcePath(f.path, g);
        a.loadBarTexture(f,
            g);
        d && a.setContentSize(cc.size(e, a.getContentSize().height));
        e = c.ballNormalData;
        d = e.resourceType;
        f = ccs.widgetReader.getResourcePath(e.path, d);
        a.loadSlidBallTextureNormal(f, d);
        e = c.ballPressedData;
        d = e.resourceType;
        e = ccs.widgetReader.getResourcePath(e.path, d);
        a.loadSlidBallTexturePressed(e, d);
        e = c.ballDisabledData;
        d = e.resourceType;
        e = ccs.widgetReader.getResourcePath(e.path, d);
        a.loadSlidBallTextureDisabled(e, d);
        e = c.progressBarData;
        d = e.resourceType;
        e = ccs.widgetReader.getResourcePath(e.path, d);
        a.loadProgressBarTexture(e,
            d);
        d = !0;
        null !== c.displaystate && (d = c.displaystate);
        a.setBright(d);
        ccs.widgetReader.setColorPropsFromProtocolBuffers.call(this, a, b)
    }
};
ccs.textFieldReader = {
    setPropsFromJsonDictionary: function(a, b) {
        ccs.widgetReader.setPropsFromJsonDictionary.call(this, a, b);
        var c = b.placeHolder;
        c && a.setPlaceHolder(c);
        a.setString(b.text || "Text Field");
        (c = b.fontSize1) && a.setFontSize(c);
        (c = b.fontName) && a.setFontName(c);
        var c = b.touchSizeWidth,
            d = b.touchSizeHeight;
        null != c && null != d && a.setTouchSize(c, d);
        c = b.maxLengthEnable;
        a.setMaxLengthEnabled(c);
        c && a.setMaxLength(b.maxLength);
        c = b.passwordEnable;
        a.setPasswordEnabled(c);
        c && a.setPasswordStyleText(b.passwordStyleText);
        c = b.areaWidth;
        d = b.areaHeight;
        null != c && null != d && (c = cc.size(c, d), a.setTextAreaSize(c));
        (c = b.hAlignment) && a.setTextHorizontalAlignment(c);
        (c = b.vAlignment) && a.setTextVerticalAlignment(c);
        ccs.widgetReader.setColorPropsFromJsonDictionary.call(this, a, b)
    },
    setPropsFromProtocolBuffers: function(a, b) {
        var c = b.textfieldOptions,
            d = ccs.uiReader.getFilePath(),
            e = c.isCustomSize;
        a.ignoreContentAdaptWithSize(!e);
        e && (e = b.widgetOptions, a.setContentSize(cc.size(e.width, e.height)));
        ccs.widgetReader.setPropsFromProtocolBuffers.call(this,
            a, b);
        ccs.widgetReader.setAnchorPointForWidget.call(this, a, b);
        a.setUnifySizeEnabled(!1);
        null !== c.placeholder && a.setPlaceHolder(null !== c.placeholder ? c.placeholder : "inputs words here");
        a.setString(null !== c.text ? c.text : "Text Field");
        a.setFontSize(c.fontSize ? c.fontSize : 20);
        a.setFontName(null !== c.fontName ? c.fontName : "\u5fae\u8f6f\u96c5\u9ed1");
        e = c.maxlengthEnable;
        a.setMaxLengthEnabled(e);
        e && a.setMaxLength(null !== c.maxLength ? c.maxLength : 10);
        e = c.passwordEnable;
        a.setPasswordEnabled(e);
        e && a.setPasswordStyleText(null !==
            c.passwordStyleText ? c.passwordStyleText : "*");
        null !== c.fontResource && a.setFontName(d + c.fontresource.path);
        ccs.widgetReader.setColorPropsFromProtocolBuffers.call(this, a, b)
    }
};
ccs.WidgetReaderProtocol = ccs.Class.extend({
    setPropsFromJsonDictionary: function(a, b) {}
});
ccs.widgetReader = {
    setPropsFromJsonDictionary: function(a, b) {
        var c = b.ignoreSize;
        null != c && a.ignoreContentAdaptWithSize(c);
        a.setSizeType(b.sizeType);
        a.setPositionType(b.positionType);
        a.setSizePercent(cc.p(b.sizePercentX, b.sizePercentY));
        a.setPositionPercent(cc.p(b.positionPercentX, b.positionPercentY));
        var d = c = 0;
        b.adaptScreen ? (d = cc.director.getWinSize(), c = d.width, d = d.height) : (c = b.width, d = b.height);
        a.setContentSize(c, d);
        a.setTag(b.tag);
        a.setActionTag(b.actiontag);
        a.setTouchEnabled(b.touchAble);
        c = b.name;
        a.setName(c ? c : "default");
        a.setPosition(b.x, b.y);
        a.setScaleX(null != b.scaleX ? b.scaleX : 1);
        a.setScaleY(null != b.scaleY ? b.scaleY : 1);
        a.setRotation(b.rotation || 0);
        c = b.visible || !1;
        null != c && a.setVisible(c);
        a.setLocalZOrder(b.ZOrder);
        if (null != b.layoutParameter) {
            c = b.layoutParameter;
            d = null;
            switch (c.type) {
                case 1:
                    d = new ccui.LinearLayoutParameter;
                    d.setGravity(c.gravity);
                    break;
                case 2:
                    var e = d = new ccui.RelativeLayoutParameter;
                    e.setRelativeName(c.relativeName);
                    e.setRelativeToWidgetName(c.relativeToName);
                    e.setAlign(c.align)
            }
            null !=
                d && (d.setMargin(c.marginLeft || 0, c.marginTop || 0, c.marginRight || 0, c.marginDown || 0), a.setLayoutParameter(d))
        }
    },
    setColorPropsFromJsonDictionary: function(a, b) {
        var c = b.opacity;
        null != c && a.setOpacity(c);
        var c = b.colorR,
            d = b.colorG,
            e = b.colorB;
        a.setColor(cc.color(null == c ? 255 : c, null == d ? 255 : d, null == e ? 255 : e));
        ccs.widgetReader._setAnchorPointForWidget(a, b);
        a.setFlippedX(b.flipX);
        a.setFlippedY(b.flipY)
    },
    _setAnchorPointForWidget: function(a, b) {
        var c = b.anchorPointX,
            d;
        d = null != c ? b.anchorPointX : a.getAnchorPoint().x;
        var e =
            b.anchorPointY,
            f;
        f = null != e ? b.anchorPointY : a.getAnchorPoint().y;
        (null != c || null != e) && a.setAnchorPoint(cc.p(d, f))
    },
    _getResourcePath: function(a, b, c) {
        a = a[b];
        var d;
        null != a && (0 == c ? d = ccs.uiReader.getFilePath() + a : 1 == c ? d = a : cc.assert(0, "invalid TextureResType!!!"));
        return d
    },
    setPropsFromProtocolBuffers: function(a, b) {
        var c = b.widgetOptions;
        a.setCascadeColorEnabled(!0);
        a.setCascadeOpacityEnabled(!0);
        a.setAnchorPoint(cc.p(0, 0));
        a.setUnifySizeEnabled(!0);
        c.ignoreSize && a.ignoreContentAdaptWithSize(c.ignoreSize);
        a.setSizeType(c.sizeType);
        a.setPositionType(c.positionType);
        a.setSizePercent(cc.p(c.sizePercentX, c.sizePercentY));
        a.setPositionPercent(cc.p(c.positionPercentX, c.positionPercentY));
        a.setContentSize(cc.size(c.width, c.height));
        a.setTag(c.tag);
        a.setActionTag(c.actionTag);
        a.setTouchEnabled(c.touchAble);
        var d = c.name;
        a.setName(d ? d : "default");
        a.setPosition(cc.p(c.x, c.y));
        c.Alpha && a.setOpacity(c.Alpha);
        a.setScaleX(null !== c.scaleX ? c.scaleX : 1);
        a.setScaleY(null !== c.scaleY ? c.scaleY : 1);
        a.setRotationX(null !== c.rotationSkewX ? c.rotationSkewX :
            0);
        a.setRotationY(null !== c.rotationSkewY ? c.rotationSkewY : 0);
        c.visible && a.setVisible(c.visible);
        a.setLocalZOrder(c.zorder);
        if (c.layoutParameter) {
            c = c.layoutParameter;
            d = null;
            switch (c.type) {
                case 1:
                    d = new ccui.LinearLayoutParameter;
                    d.setGravity(c.gravity);
                    break;
                case 2:
                    var e = d = new ccui.RelativeLayoutParameter;
                    e.setRelativeName(c.relativeName);
                    e.setRelativeToWidgetName(c.relativeToName);
                    e.setAlign(c.align)
            }
            d && (d.setMargin(new ccui.Margin(c.marginLeft, c.marginTop, c.marginRight, c.marginDown)), a.setLayoutParameter(d))
        }
    },
    setColorPropsFromProtocolBuffers: function(a, b) {
        var c = b.widgetOptions,
            d = null !== c.colorG,
            e = null !== c.colorB,
            f = c.colorR,
            g = c.colorG,
            h = c.colorB;
        null !== c.colorR && (d && e) && a.setColor(cc.color(f, g, h));
        ccs.widgetReader.setAnchorPointForWidget(a, b);
        d = c.flipY;
        a.setFlippedX(c.flipX);
        a.setFlippedY(d)
    },
    setAnchorPointForWidget: function(a, b) {
        var c = b.widgetOptions,
            d = c.anchorPointX,
            e;
        e = d ? c.anchorPointX : a.getAnchorPoint().x;
        var f = c.anchorPointY,
            c = f ? c.anchorPointY : a.getAnchorPoint().y;
        (d || f) && a.setAnchorPoint(cc.p(e, c))
    },
    getResourcePath: function(a, b) {
        var c = ccs.uiReader.getFilePath(),
            d;
        null != a && 0 != "" != a && (b == ccui.Widget.LOCAL_TEXTURE ? d = c + a : b == ccui.Widget.PLIST_TEXTURE ? d = a : cc.assert(0, "invalid TextureResType!!!"));
        return d
    }
};
var PBP;
PBP = CSParseBinary && window.dcodeIO && window.dcodeIO.ProtoBuf ? dcodeIO.ProtoBuf.loadProto(CSParseBinary).build().protocolbuffers : null;
(function() {
    var a = ccs.objectFactory;
    a.registerType({
        _className: "ButtonReader",
        _fun: ccs.buttonReader
    });
    a.registerType({
        _className: "CheckBoxReader",
        _fun: ccs.checkBoxReader
    });
    a.registerType({
        _className: "SliderReader",
        _fun: ccs.sliderReader
    });
    a.registerType({
        _className: "ImageViewReader",
        _fun: ccs.imageViewReader
    });
    a.registerType({
        _className: "LoadingBarReader",
        _fun: ccs.loadingBarReader
    });
    a.registerType({
        _className: "TextAtlasReader",
        _fun: ccs.labelAtlasReader
    });
    a.registerType({
        _className: "TextReader",
        _fun: ccs.labelReader
    });
    a.registerType({
        _className: "TextBMFontReader",
        _fun: ccs.labelBMFontReader
    });
    a.registerType({
        _className: "TextFieldReader",
        _fun: ccs.textFieldReader
    });
    a.registerType({
        _className: "LayoutReader",
        _fun: ccs.layoutReader
    });
    a.registerType({
        _className: "PageViewReader",
        _fun: ccs.pageViewReader
    });
    a.registerType({
        _className: "ScrollViewReader",
        _fun: ccs.scrollViewReader
    });
    a.registerType({
        _className: "ListViewReader",
        _fun: ccs.listViewReader
    });
    a.registerType({
        _className: "WidgetReader",
        _fun: ccs.widgetReader
    });
    a.registerType({
        _className: "Button",
        _fun: ccui.Button
    });
    a.registerType({
        _className: "CheckBox",
        _fun: ccui.CheckBox
    });
    a.registerType({
        _className: "ImageView",
        _fun: ccui.ImageView
    });
    a.registerType({
        _className: "Text",
        _fun: ccui.Text
    });
    a.registerType({
        _className: "TextAtlas",
        _fun: ccui.TextAtlas
    });
    a.registerType({
        _className: "TextBMFont",
        _fun: ccui.TextBMFont
    });
    a.registerType({
        _className: "LoadingBar",
        _fun: ccui.LoadingBar
    });
    a.registerType({
        _className: "Slider",
        _fun: ccui.Slider
    });
    a.registerType({
        _className: "TextField",
        _fun: ccui.TextField
    });
    a.registerType({
        _className: "Layout",
        _fun: ccui.Layout
    });
    a.registerType({
        _className: "ListView",
        _fun: ccui.ListView
    });
    a.registerType({
        _className: "PageView",
        _fun: ccui.PageView
    });
    a.registerType({
        _className: "ScrollView",
        _fun: ccui.ScrollView
    })
})();
ccs.uiReader = {
    _filePath: "",
    _olderVersion: !1,
    _fileDesignSizes: {},
    _mapObject: {},
    _mapParseSelector: {},
    getVersionInteger: function(a) {
        if (!a) return 0;
        var b = a,
            c = b.length;
        if (7 > c) return 0;
        var d = b.indexOf("."),
            e = b.substr(0, d),
            b = b.substr(d + 1, c - 1),
            d = b.indexOf("."),
            f = b.substr(0, d),
            b = b.substr(d + 1, c - 1),
            d = b.indexOf(".");
        a = b.substr(0, d);
        b = b.substr(d + 1, c - 1);
        d = b.indexOf(".");
        b = -1 == d ? b : b.substr(0, d);
        e = parseInt(e);
        f = parseInt(f);
        a = parseInt(a);
        b = parseInt(b);
        return 1E3 * e + 100 * f + 10 * a + b
    },
    storeFileDesignSize: function(a, b) {
        this._fileDesignSizes[a] =
            b
    },
    getFileDesignSize: function(a) {
        return this._fileDesignSizes[a]
    },
    widgetFromJsonFile: function(a) {
        var b = cc.loader.getRes(a);
        if (!b) throw "Please load the resource first : " + a;
        var c = cc.path.dirname(a);
        this._filePath = "" == c ? c : c + "/";
        var c = b.version,
            d = this.getVersionInteger(c);
        a = (c ? 250 > d ? new ccs.WidgetPropertiesReader0250 : new ccs.WidgetPropertiesReader0300 : new ccs.WidgetPropertiesReader0250).createWidget(b, this._filePath, a);
        if (!c || 250 > d) this._olderVersion = !0;
        return a
    },
    clear: function() {
        this._filePath = "";
        this._olderVersion = !1;
        this._fileDesignSizes = {}
    },
    registerTypeAndCallBack: function(a, b, c, d) {
        var e = ccs.objectFactory;
        b = new ccs.TInfo(a, b);
        e.registerType(b);
        c && (this._mapObject[a] = c);
        d && (this._mapParseSelector[a] = d)
    },
    getFilePath: function() {
        return this._filePath
    },
    setFilePath: function(a) {
        this._filePath = a
    },
    getParseObjectMap: function() {
        return this._mapObject
    },
    getParseCallBackMap: function() {
        return this._mapParseSelector
    }
};
ccs.WidgetPropertiesReader = ccs.Class.extend({
    _filePath: "",
    createWidget: function(a, b, c) {},
    widgetFromJsonDictionary: function(a) {},
    _createGUI: function(a) {
        a = this._getGUIClassName(a);
        return ccs.objectFactory.createObject(a)
    },
    _getGUIClassName: function(a) {
        var b = a;
        "Panel" == a ? b = "Layout" : "TextArea" == a ? b = "Text" : "TextButton" == a ? b = "Button" : "Label" == a ? b = "Text" : "LabelAtlas" == a ? b = "TextAtlas" : "LabelBMFont" == a ? b = "TextBMFont" : "Node" == a && (b = "Layout");
        return b
    },
    _getWidgetReaderClassName: function(a) {
        "Panel" == a ? a = "Layout" :
            "TextArea" == a ? a = "Text" : "TextButton" == a ? a = "Button" : "Label" == a ? a = "Text" : "LabelAtlas" == a ? a = "TextAtlas" : "LabelBMFont" == a && (a = "TextBMFont");
        return a + "Reader"
    },
    _getWidgetReaderClassNameFromWidget: function(a) {
        var b = "";
        a instanceof ccui.Button ? b = "ButtonReader" : a instanceof ccui.CheckBox ? b = "CheckBoxReader" : a instanceof ccui.ImageView ? b = "ImageViewReader" : a instanceof ccui.TextAtlas ? b = "TextAtlasReader" : a instanceof ccui.TextBMFont ? b = "TextBMFontReader" : a instanceof ccui.Text ? b = "TextReader" : a instanceof ccui.LoadingBar ?
            b = "LoadingBarReader" : a instanceof ccui.Slider ? b = "SliderReader" : a instanceof ccui.TextField ? b = "TextFieldReader" : a instanceof ccui.ListView ? b = "ListViewReader" : a instanceof ccui.PageView ? b = "PageViewReader" : a instanceof ccui.ScrollView ? b = "ScrollViewReader" : a instanceof ccui.Layout ? b = "LayoutReader" : a instanceof ccui.Widget && (b = "WidgetReader");
        return b
    },
    _createWidgetReaderProtocol: function(a) {
        return ccs.objectFactory.createObject(a)
    }
});
ccs.WidgetPropertiesReader0250 = ccs.WidgetPropertiesReader.extend({
    createWidget: function(a, b, c) {
        this._filePath = "" == b ? b : cc.path.join(b, "/");
        for (var d = a.textures, e = 0; e < d.length; e++) {
            var f = b,
                f = f + d[e];
            cc.spriteFrameCache.addSpriteFrames(f)
        }
        b = a.designWidth;
        d = a.designHeight;
        0 >= b || 0 >= d ? (cc.log("Read design size error!"), e = cc.director.getWinSize(), ccs.uiReader.storeFileDesignSize(c, e)) : ccs.uiReader.storeFileDesignSize(c, cc.size(b, d));
        e = this.widgetFromJsonDictionary(a.widgetTree);
        f = e.getContentSize();
        0 == f.width &&
            0 == f.height && e.setSize(cc.size(b, d));
        ccs.actionManager.initWithDictionary(c, a.animation, e);
        return e
    },
    widgetFromJsonDictionary: function(a) {
        var b = null,
            c = a.classname,
            d = a.options;
        "Button" == c ? (b = new ccui.Button, this.setPropsForButtonFromJsonDictionary(b, d)) : "CheckBox" == c ? (b = new ccui.CheckBox, this.setPropsForCheckBoxFromJsonDictionary(b, d)) : "Label" == c ? (b = new ccui.Text, this.setPropsForLabelFromJsonDictionary(b, d)) : "LabelAtlas" == c ? (b = new ccui.TextAtlas, this.setPropsForLabelAtlasFromJsonDictionary(b, d)) : "LoadingBar" ==
            c ? (b = new ccui.LoadingBar, this.setPropsForLoadingBarFromJsonDictionary(b, d)) : "ScrollView" == c ? (b = new ccui.ScrollView, this.setPropsForScrollViewFromJsonDictionary(b, d)) : "TextArea" == c ? (b = new ccui.Text, this.setPropsForLabelFromJsonDictionary(b, d)) : "TextButton" == c ? (b = new ccui.Button, this.setPropsForButtonFromJsonDictionary(b, d)) : "TextField" == c ? (b = new ccui.TextField, this.setPropsForTextFieldFromJsonDictionary(b, d)) : "ImageView" == c ? (b = new ccui.ImageView, this.setPropsForImageViewFromJsonDictionary(b, d)) : "Panel" ==
            c ? (b = new ccui.Layout, this.setPropsForLayoutFromJsonDictionary(b, d)) : "Slider" == c ? (b = new ccui.Slider, this.setPropsForSliderFromJsonDictionary(b, d)) : "LabelBMFont" == c ? (b = new ccui.TextBMFont, this.setPropsForLabelBMFontFromJsonDictionary(b, d)) : "DragPanel" == c && (b = new ccui.ScrollView, this.setPropsForScrollViewFromJsonDictionary(b, d));
        a = a.children;
        for (c = 0; c < a.length; c++)(d = this.widgetFromJsonDictionary(a[c])) && b.addChild(d);
        return b
    },
    setPropsForWidgetFromJsonDictionary: function(a, b) {
        void 0 !== b.ignoreSize &&
            a.ignoreContentAdaptWithSize(b.ignoreSize);
        a.setSize(cc.size(b.width, b.height));
        a.setTag(b.tag);
        a.setActionTag(b.actiontag);
        a.setTouchEnabled(b.touchAble);
        var c = b.name;
        a.setName(c ? c : "default");
        a.setPosition(cc.p(b.x, b.y));
        void 0 !== b.scaleX && a.setScaleX(b.scaleX);
        void 0 !== b.scaleY && a.setScaleY(b.scaleY);
        void 0 !== b.rotation && a.setRotation(b.rotation);
        void 0 !== b.visible && a.setVisible(b.visible);
        a.setLocalZOrder(b.ZOrder)
    },
    setPropsForAllWidgetFromJsonDictionary: function() {},
    setPropsForAllCustomWidgetFromJsonDictionary: function() {},
    setColorPropsForWidgetFromJsonDictionary: function(a, b) {
        void 0 !== b.opacity && a.setOpacity(b.opacity);
        a.setColor(cc.color(void 0 !== b.colorR ? b.colorR : 255, void 0 !== b.colorG ? b.colorG : 255, void 0 !== b.colorB ? b.colorB : 255));
        var c = void 0 !== b.anchorPointX ? b.anchorPointX : a.getWidgetType() == ccui.Widget.TYPE_WIDGET ? 0.5 : 0,
            d = void 0 !== b.anchorPointY ? b.anchorPointY : a.getWidgetType() == ccui.Widget.TYPE_WIDGET ? 0.5 : 0;
        a.setAnchorPoint(c, d);
        c = b.flipY;
        a.setFlippedX(b.flipX);
        a.setFlippedY(c)
    },
    setPropsForButtonFromJsonDictionary: function(a,
        b) {
        this.setPropsForWidgetFromJsonDictionary(a, b);
        var c = b.scale9Enable;
        a.setScale9Enabled(c);
        var d = b.normal,
            e = b.pressed,
            f = b.disabled,
            g = d ? this._filePath + d : null,
            h = e ? this._filePath + e : null,
            k = f ? this._filePath + f : null,
            m = b.useMergedTexture;
        c ? (m ? a.loadTextures(d, e, f, ccui.Widget.PLIST_TEXTURE) : a.loadTextures(g, h, k), void 0 !== b.scale9Width && void 0 !== b.scale9Height && a.setSize(cc.size(b.scale9Width, b.scale9Height))) : m ? a.loadTextures(d, e, f, ccui.Widget.PLIST_TEXTURE) : a.loadTextures(g, h, k);
        void 0 !== b.text && (c = b.text ||
            "") && a.setTitleText(c);
        void 0 !== b.fontSize && a.setTitleFontSize(b.fontSize);
        void 0 !== b.fontName && a.setTitleFontName(b.fontName);
        c = cc.color(void 0 !== b.textColorR ? b.textColorR : 255, void 0 !== b.textColorG ? b.textColorG : 255, void 0 !== b.textColorB ? b.textColorB : 255);
        a.setTitleColor(c);
        this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForCheckBoxFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b);
        var c = b.backGroundBox,
            d = b.backGroundBoxSelected,
            e = b.frontCross,
            f = b.backGroundBoxDisabled,
            g = b.frontCrossDisabled,
            h = this._filePath,
            k = c ? h + c : null,
            m = d ? h + d : null,
            n = e ? h + e : null,
            q = f ? h + f : null,
            h = g ? h + g : null;
        b.useMergedTexture ? a.loadTextures(c, d, e, f, g, ccui.Widget.PLIST_TEXTURE) : a.loadTextures(k, m, n, q, h);
        a.setSelected(b.selectedState || !1);
        this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForImageViewFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b);
        var c = b.fileName,
            d = b.scale9Enable || !1;
        a.setScale9Enabled(d);
        var e = this._filePath,
            f = null;
        c && (f = e + c);
        e = b.useMergedTexture;
        d ? (e ? a.loadTexture(c, ccui.Widget.PLIST_TEXTURE) : a.loadTexture(f), void 0 !== b.scale9Width && void 0 !== b.scale9Height && a.setSize(cc.size(b.scale9Width, b.scale9Height)), a.setCapInsets(cc.rect(b.capInsetsX, b.capInsetsY, b.capInsetsWidth, b.capInsetsHeight))) : e ? a.loadTexture(c, ccui.Widget.PLIST_TEXTURE) : a.loadTexture(f);
        this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForLabelFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b);
        a.setTouchScaleChangeEnabled(b.touchScaleEnable);
        a.setString(b.text);
        void 0 !== b.fontSize && a.setFontSize(b.fontSize);
        void 0 !== b.fontName && a.setFontName(b.fontName);
        if (void 0 !== b.areaWidth && void 0 !== b.areaHeight) {
            var c = cc.size(b.areaWidth, b.areaHeight);
            a.setTextAreaSize(c)
        }
        b.hAlignment && a.setTextHorizontalAlignment(b.hAlignment);
        b.vAlignment && a.setTextVerticalAlignment(b.vAlignment);
        this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForLabelAtlasFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b);
        var c = b.charMapFileData,
            d = b.stringValue,
            e = b.itemWidth,
            f = b.itemHeight,
            g = b.startCharMap;
        void 0 !== d && (void 0 !== c && void 0 !== e && void 0 !== f && void 0 !== g && c) && a.setProperty(d, this._filePath + c, e, f, g);
        this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForLayoutFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b);
        !(a instanceof ccui.ScrollView) && !(a instanceof ccui.ListView) && a.setClippingEnabled(b.clipAble);
        var c = b.backGroundScale9Enable;
        a.setBackGroundImageScale9Enabled(c);
        var d = b.bgColorR,
            e = b.bgColorG,
            f = b.bgColorB,
            g = b.bgStartColorR,
            h = b.bgStartColorG,
            k = b.bgStartColorB,
            m = b.bgEndColorR,
            n = b.bgEndColorG,
            q = b.bgEndColorB;
        a.setBackGroundColorVector(cc.p(b.vectorX, b.vectorY));
        var r = b.bgColorOpacity;
        a.setBackGroundColorType(b.colorType);
        a.setBackGroundColor(cc.color(g, h, k), cc.color(m, n, q));
        a.setBackGroundColor(cc.color(d, e, f));
        a.setBackGroundColorOpacity(r);
        e = (d = b.backGroundImage) ? this._filePath + d : null;
        b.useMergedTexture ? a.setBackGroundImage(d, ccui.Widget.PLIST_TEXTURE) : a.setBackGroundImage(e);
        c && a.setBackGroundImageCapInsets(cc.rect(b.capInsetsX,
            b.capInsetsY, b.capInsetsWidth, b.capInsetsHeight));
        this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForScrollViewFromJsonDictionary: function(a, b) {
        this.setPropsForLayoutFromJsonDictionary(a, b);
        a.setInnerContainerSize(cc.size(b.innerWidth, b.innerHeight));
        a.setDirection(b.direction);
        a.setBounceEnabled(b.bounceEnable);
        this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForContainerWidgetFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b);
        (a instanceof ccui.ScrollView ||
            a instanceof ccui.ListView) && a.setClippingEnabled(b.clipAble);
        this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForSliderFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b);
        var c = b.barTextureScale9Enable || !1;
        a.setScale9Enabled(c);
        var d = b.length,
            e = b.useMergedTexture;
        if (void 0 !== b.barFileName)
            if (c) {
                var f = (c = b.barFileName) ? this._filePath + c : null;
                e ? a.loadBarTexture(c, ccui.Widget.PLIST_TEXTURE) : a.loadBarTexture(f);
                a.setSize(cc.size(d, a.getContentSize().height))
            } else f =
                (c = b.barFileName) ? this._filePath + c : null, e ? a.loadBarTexture(c, ccui.Widget.PLIST_TEXTURE) : a.loadBarTexture(f);
        var d = b.ballNormal,
            c = b.ballPressed,
            f = b.ballDisabled,
            g = d ? this._filePath + d : null,
            h = c ? this._filePath + c : null,
            k = f ? this._filePath + f : null;
        e ? a.loadSlidBallTextures(d, c, f, ccui.Widget.PLIST_TEXTURE) : a.loadSlidBallTextures(g, h, k);
        a.setPercent(b.percent);
        f = (c = b.progressBarFileName) ? this._filePath + c : null;
        e ? a.loadProgressBarTexture(c, ccui.Widget.PLIST_TEXTURE) : a.loadProgressBarTexture(f);
        this.setColorPropsForWidgetFromJsonDictionary(a,
            b)
    },
    setPropsForTextAreaFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b);
        a.setString(b.text);
        void 0 !== b.fontSize && a.setFontSize(b.fontSize);
        var c = b.colorR,
            d = b.colorG,
            e = b.colorB;
        a.setColor(cc.color(null == c ? 255 : c, null == d ? 255 : d, null == e ? 255 : e));
        a.setFontName(b.fontName);
        void 0 !== b.areaWidth && void 0 !== b.areaHeight && (c = cc.size(b.areaWidth, b.areaHeight), a.setTextAreaSize(c));
        b.hAlignment && a.setTextHorizontalAlignment(b.hAlignment);
        b.vAlignment && a.setTextVerticalAlignment(b.vAlignment);
        this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForTextButtonFromJsonDictionary: function(a, b) {
        this.setPropsForButtonFromJsonDictionary(a, b);
        a.setTitleText(b.text || "");
        a.setTitleColor(cc.color(void 0 !== b.textColorR ? b.textColorR : 255, void 0 !== b.textColorG ? b.textColorG : 255, void 0 !== b.textColorB ? b.textColorB : 255));
        void 0 !== b.fontSize && a.setTitleFontSize(b.fontSize);
        void 0 !== b.fontName && a.setTitleFontName(b.fontName);
        this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForTextFieldFromJsonDictionary: function(a,
        b) {
        this.setPropsForWidgetFromJsonDictionary(a, b);
        void 0 !== b.placeHolder && a.setPlaceHolder(b.placeHolder);
        a.setString(b.text);
        void 0 !== b.fontSize && a.setFontSize(b.fontSize);
        void 0 !== b.fontName && a.setFontName(b.fontName);
        void 0 !== b.touchSizeWidth && void 0 !== b.touchSizeHeight && a.setTouchSize(cc.size(b.touchSizeWidth, b.touchSizeHeight));
        var c = b.maxLengthEnable;
        a.setMaxLengthEnabled(c);
        c && a.setMaxLength(b.maxLength);
        c = b.passwordEnable;
        a.setPasswordEnabled(c);
        c && a.setPasswordStyleText(b.passwordStyleText);
        this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForLoadingBarFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b);
        var c = b.texture,
            d = c ? this._filePath + c : null;
        b.useMergedTexture ? a.loadTexture(c, ccui.Widget.PLIST_TEXTURE) : a.loadTexture(d);
        a.setDirection(b.direction);
        a.setPercent(b.percent);
        this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForListViewFromJsonDictionary: function(a, b) {
        this.setPropsForLayoutFromJsonDictionary(a, b)
    },
    setPropsForPageViewFromJsonDictionary: function(a,
        b) {
        this.setPropsForLayoutFromJsonDictionary(a, b)
    },
    setPropsForLabelBMFontFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b);
        a.setFntFile(this._filePath + b.fileName);
        a.setString(b.text);
        this.setColorPropsForWidgetFromJsonDictionary(a, b)
    }
});
ccs.WidgetPropertiesReader0300 = ccs.WidgetPropertiesReader.extend({
    createWidget: function(a, b, c) {
        this._filePath = "" == b ? b : cc.path.join(b, "/");
        for (var d = a.textures, e = 0; e < d.length; e++) {
            var f = b,
                f = f + d[e];
            cc.spriteFrameCache.addSpriteFrames(f)
        }
        b = a.designWidth;
        d = a.designHeight;
        0 >= b || 0 >= d ? (cc.log("Read design size error!"), e = cc.director.getWinSize(), ccs.uiReader.storeFileDesignSize(c, e)) : ccs.uiReader.storeFileDesignSize(c, cc.size(b, d));
        e = this.widgetFromJsonDictionary(a.widgetTree);
        f = e.getContentSize();
        0 == f.width &&
            0 == f.height && e.setSize(cc.size(b, d));
        ccs.actionManager.initWithDictionary(c, a.animation, e);
        return e
    },
    setPropsForAllWidgetFromJsonDictionary: function(a, b, c) {
        a && a.setPropsFromJsonDictionary && a.setPropsFromJsonDictionary(b, c)
    },
    setPropsForAllCustomWidgetFromJsonDictionary: function(a, b, c) {
        var d = ccs.uiReader,
            e = d.getParseObjectMap()[a],
            d = d.getParseCallBackMap()[a];
        e && d && d.call(e, a, b, c)
    },
    widgetFromJsonDictionary: function(a) {
        var b = a.classname,
            c = a.options,
            d = this._createGUI(b),
            e = this._getWidgetReaderClassName(b);
        (e = this._createWidgetReaderProtocol(e)) ? this.setPropsForAllWidgetFromJsonDictionary(e, d, c): (e = this._getWidgetReaderClassNameFromWidget(d), (e = ccs.objectFactory.createObject(e)) && d ? (this.setPropsForAllWidgetFromJsonDictionary(e, d, c), c = JSON.parse(c.customProperty), this.setPropsForAllCustomWidgetFromJsonDictionary(b, d, c)) : cc.log("Widget or WidgetReader doesn't exists!!!  Please check your json file."));
        a = a.children;
        for (b = 0; b < a.length; b++)
            if (c = this.widgetFromJsonDictionary(a[b]))
                if (d instanceof ccui.PageView) d.addPage(c);
                else if (d instanceof ccui.ListView) d.pushBackCustomItem(c);
        else {
            if (!(d instanceof ccui.Layout)) {
                if (c.getPositionType() == ccui.Widget.POSITION_PERCENT) {
                    var e = c.getPositionPercent(),
                        f = d.getAnchorPoint();
                    c.setPositionPercent(cc.p(e.x + f.x, e.y + f.y))
                }
                e = d.getAnchorPointInPoints();
                c.setPosition(cc.p(c.getPositionX() + e.x, c.getPositionY() + e.y))
            }
            d.addChild(c)
        }
        return d
    },
    setPropsForWidgetFromJsonDictionary: function(a, b) {
        var c = b.name;
        a.setName(c ? c : "default");
        void 0 !== b.ignoreSize && a.ignoreContentAdaptWithSize(b.ignoreSize);
        a.setSizeType(b.sizeType);
        a.setPositionType(b.positionType);
        a.setSizePercent(cc.p(b.sizePercentX, b.sizePercentY));
        a.setPositionPercent(cc.p(b.positionPercentX, b.positionPercentY));
        a.setSize(cc.size(b.width, b.height));
        a.setTag(b.tag);
        a.setActionTag(b.actiontag);
        a.setTouchEnabled(b.touchAble);
        a.setPosition(cc.p(b.x, b.y));
        void 0 !== b.scaleX && a.setScaleX(b.scaleX);
        void 0 !== b.scaleY && a.setScaleY(b.scaleY);
        void 0 !== b.rotation && a.setRotation(b.rotation);
        void 0 !== b.visible && a.setVisible(b.visible);
        a.setLocalZOrder(b.ZOrder);
        if (c = b.layoutParameter) {
            var d;
            switch (c.type) {
                case 1:
                    d = new ccui.LinearLayoutParameter;
                    d.setGravity(c.gravity);
                    break;
                case 2:
                    d = new ccui.RelativeLayoutParameter, d.setRelativeName(c.relativeName), d.setRelativeToWidgetName(c.relativeToName), d.setAlign(c.align)
            }
            d.setMargin(new ccui.Margin(c.marginLeft, c.marginTop, c.marginRight, c.marginDown));
            a.setLayoutParameter(d)
        }
    },
    setColorPropsForWidgetFromJsonDictionary: function(a, b) {
        void 0 !== b.opacity && a.setOpacity(b.opacity);
        a.setColor(cc.color(void 0 !== b.colorR ? b.colorR :
            255, void 0 !== b.colorG ? b.colorG : 255, void 0 !== b.colorB ? b.colorB : 255));
        var c = void 0 !== b.anchorPointX ? b.anchorPointX : a.getWidgetType() == ccui.Widget.TYPE_WIDGET ? 0.5 : 0,
            d = void 0 !== b.anchorPointY ? b.anchorPointY : a.getWidgetType() == ccui.Widget.TYPE_WIDGET ? 0.5 : 0;
        a.setAnchorPoint(c, d);
        c = b.flipY;
        a.setFlippedX(b.flipX);
        a.setFlippedY(c)
    },
    setPropsForButtonFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b);
        var c = b.scale9Enable;
        a.setScale9Enabled(c);
        var d = b.normalData;
        switch (d.resourceType) {
            case 0:
                d =
                    d.path;
                a.loadTextureNormal(d ? this._filePath + d : null);
                break;
            case 1:
                d = d.path, a.loadTextureNormal(d, ccui.Widget.PLIST_TEXTURE)
        }
        d = b.pressedData;
        switch (d.resourceType) {
            case 0:
                d = d.path;
                a.loadTexturePressed(d ? this._filePath + d : null);
                break;
            case 1:
                d = d.path, a.loadTexturePressed(d, ccui.Widget.PLIST_TEXTURE)
        }
        d = b.disabledData;
        switch (d.resourceType) {
            case 0:
                d = d.path;
                a.loadTextureDisabled(d ? this._filePath + d : null);
                break;
            case 1:
                d = d.path, a.loadTextureDisabled(d, ccui.Widget.PLIST_TEXTURE)
        }
        c && (a.setCapInsets(cc.rect(b.capInsetsX,
            b.capInsetsY, b.capInsetsWidth, b.capInsetsHeight)), void 0 !== b.scale9Width && void 0 !== b.scale9Height && a.setSize(cc.size(b.scale9Width, b.scale9Height)));
        void 0 !== b.text && (c = b.text || "") && a.setTitleText(c);
        void 0 !== b.fontSize && a.setTitleFontSize(b.fontSize);
        void 0 !== b.fontName && a.setTitleFontName(b.fontName);
        c = cc.color(void 0 !== b.textColorR ? b.textColorR : 255, void 0 !== b.textColorG ? b.textColorG : 255, void 0 !== b.textColorB ? b.textColorB : 255);
        a.setTitleColor(c);
        this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForCheckBoxFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b);
        var c = b.backGroundBoxData;
        switch (c.resourceType) {
            case 0:
                c = c.path;
                a.loadTextureBackGround(c ? this._filePath + c : null);
                break;
            case 1:
                c = c.path, a.loadTextureBackGround(c, ccui.Widget.PLIST_TEXTURE)
        }
        c = b.backGroundBoxSelectedData;
        switch (c.resourceType) {
            case 0:
                c = c.path;
                a.loadTextureBackGroundSelected(c ? this._filePath + c : null);
                break;
            case 1:
                c = c.path, a.loadTextureBackGroundSelected(c, ccui.Widget.PLIST_TEXTURE)
        }
        c = b.frontCrossData;
        switch (c.resourceType) {
            case 0:
                c = c.path;
                a.loadTextureFrontCross(c ? this._filePath + c : null);
                break;
            case 1:
                c = c.path, a.loadTextureFrontCross(c, ccui.Widget.PLIST_TEXTURE)
        }
        c = b.backGroundBoxDisabledData;
        switch (c.resourceType) {
            case 0:
                c = c.path;
                a.loadTextureBackGroundDisabled(c ? this._filePath + c : null);
                break;
            case 1:
                c = c.path, a.loadTextureBackGroundDisabled(c, ccui.Widget.PLIST_TEXTURE)
        }
        switch (b.frontCrossDisabledData.resourceType) {
            case 0:
                c = b.path;
                a.loadTextureFrontCrossDisabled(c ? this._filePath + c : null);
                break;
            case 1:
                c =
                    b.path, a.loadTextureFrontCrossDisabled(c, ccui.Widget.PLIST_TEXTURE)
        }
        a.setSelectedState(b.selectedState || !1);
        a.setSelectedState(b, "selectedState");
        this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForImageViewFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b);
        var c = b.fileNameData;
        switch (c.resourceType) {
            case 0:
                var d = this._filePath;
                (c = c.path) && a.loadTexture(d + c);
                break;
            case 1:
                c = c.path, a.loadTexture(c, ccui.Widget.PLIST_TEXTURE)
        }
        d = b.scale9Enable || !1;
        a.setScale9Enabled(d);
        d && (void 0 !== b.scale9Width && void 0 !== b.scale9Height && a.setSize(cc.size(b.scale9Width, b.scale9Height)), a.setCapInsets(cc.rect(b.capInsetsX, b.capInsetsY, b.capInsetsWidth, b.capInsetsHeight)));
        this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForLabelFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b);
        a.setTouchScaleChangeEnabled(b.touchScaleEnable);
        a.setString(b.text);
        void 0 !== b.fontSize && a.setFontSize(b.fontSize);
        void 0 !== b.fontName && a.setFontName(b.fontName);
        if (void 0 !==
            b.areaWidth && void 0 !== b.areaHeight) {
            var c = cc.size(b.areaWidth, b.areaHeight);
            a.setTextAreaSize(c)
        }
        b.hAlignment && a.setTextHorizontalAlignment(b.hAlignment);
        b.vAlignment && a.setTextVerticalAlignment(b.vAlignment);
        this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForLabelAtlasFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b);
        var c = void 0 !== b.charMapFile,
            d = void 0 !== b.itemWidth,
            e = void 0 !== b.itemHeight,
            f = void 0 !== b.startCharMap;
        if (void 0 !== b.stringValue && c && d && e && f) switch (c =
            b.charMapFileData, c.resourceType) {
            case 0:
                a.setProperty(b.stringValue, this._filePath + c.path, b.itemWidth, b.itemHeight, b.startCharMap);
                break;
            case 1:
                cc.log("Wrong res type of LabelAtlas!")
        }
        this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForLayoutFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b);
        !(a instanceof ccui.ScrollView) && !(a instanceof ccui.ListView) && a.setClippingEnabled(b.clipAble);
        var c = b.backGroundScale9Enable;
        a.setBackGroundImageScale9Enabled(c);
        var d =
            b.bgColorR,
            e = b.bgColorG,
            f = b.bgColorB,
            g = b.bgStartColorR,
            h = b.bgStartColorG,
            k = b.bgStartColorB,
            m = b.bgEndColorR,
            n = b.bgEndColorG,
            q = b.bgEndColorB;
        a.setBackGroundColorVector(cc.p(b.vectorX, b.vectorY));
        var r = b.bgColorOpacity;
        a.setBackGroundColorType(b.colorType);
        a.setBackGroundColor(cc.color(g, h, k), cc.color(m, n, q));
        a.setBackGroundColor(cc.color(d, e, f));
        a.setBackGroundColorOpacity(r);
        d = b.backGroundImageData || {};
        switch (d.resourceType) {
            case 0:
                d = d.path;
                a.setBackGroundImage(d ? this._filePath + d : null);
                break;
            case 1:
                d =
                    d.path, a.setBackGroundImage(d, ccui.Widget.PLIST_TEXTURE)
        }
        c && a.setBackGroundImageCapInsets(cc.rect(b.capInsetsX, b.capInsetsY, b.capInsetsWidth, b.capInsetsHeight));
        a.setLayoutType(b.layoutType);
        this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForScrollViewFromJsonDictionary: function(a, b) {
        this.setPropsForLayoutFromJsonDictionary(a, b);
        a.setInnerContainerSize(cc.size(b.innerWidth, b.innerHeight));
        a.setDirection(b.direction);
        a.setBounceEnabled(b.bounceEnable);
        this.setColorPropsForWidgetFromJsonDictionary(a,
            b)
    },
    setPropsForSliderFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b);
        var c = b.barTextureScale9Enable || !1;
        a.setScale9Enabled(c);
        var d = b.length;
        if (void 0 !== b.barFileName)
            if (c) {
                var c = b.barFileNameData,
                    e = c.resourceType;
                switch (e) {
                    case 0:
                        c = (c = c.path) ? this._filePath + c : null;
                        a.loadBarTexture(c);
                        break;
                    case 1:
                        c = c.path, a.loadBarTexture(c, ccui.Widget.PLIST_TEXTURE)
                }
                a.setSize(cc.size(d, a.getContentSize().height))
            } else switch (c = b.barFileNameData, e = c.resourceType, e) {
                case 0:
                    c = (c = c.path) ?
                        this._filePath + c : null;
                    a.loadBarTexture(c);
                    break;
                case 1:
                    c = c.path, a.loadBarTexture(c, ccui.Widget.PLIST_TEXTURE)
            }
            d = b.ballNormalData;
        switch (d.resourceType) {
            case 0:
                d = d.path;
                a.loadSlidBallTextureNormal(d ? this._filePath + d : null);
                break;
            case 1:
                d = d.path, a.loadSlidBallTextureNormal(d, ccui.Widget.PLIST_TEXTURE)
        }
        d = b.ballPressedData;
        switch (d.resourceType) {
            case 0:
                d = d.path;
                a.loadSlidBallTexturePressed(d ? this._filePath + d : null);
                break;
            case 1:
                d = d.path, a.loadSlidBallTexturePressed(d, ccui.Widget.PLIST_TEXTURE)
        }
        d = b.ballDisabledData;
        switch (d.resourceType) {
            case 0:
                d = d.path;
                a.loadSlidBallTextureDisabled(d ? this._filePath + d : null);
                break;
            case 1:
                d = d.path, a.loadSlidBallTextureDisabled(d, ccui.Widget.PLIST_TEXTURE)
        }
        d = b.progressBarData;
        switch (d.resourceType) {
            case 0:
                c = (c = d.path) ? this._filePath + c : null;
                a.loadProgressBarTexture(c);
                break;
            case 1:
                c = d.path, a.loadProgressBarTexture(c, ccui.Widget.PLIST_TEXTURE)
        }
        this.setColorPropsForWidgetFromJsonDictionary(a, b);
        a.setPercent(b.percent)
    },
    setPropsForTextAreaFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a,
            b);
        a.setString(b.text);
        void 0 !== b.fontSize && a.setFontSize(b.fontSize);
        var c = b.colorR,
            d = b.colorG,
            e = b.colorB;
        a.setColor(cc.color(null == c ? 255 : c, null == d ? 255 : d, null == e ? 255 : e));
        a.setFontName(b.fontName);
        void 0 !== b.areaWidth && void 0 !== b.areaHeight && (c = cc.size(b.areaWidth, b.areaHeight), a.setTextAreaSize(c));
        b.hAlignment && a.setTextHorizontalAlignment(b.hAlignment);
        b.vAlignment && a.setTextVerticalAlignment(b.vAlignment);
        this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForTextButtonFromJsonDictionary: function(a,
        b) {
        this.setPropsForButtonFromJsonDictionary(a, b);
        a.setTitleText(b.text || "");
        a.setTitleColor(cc.color(void 0 !== b.textColorR ? b.textColorR : 255, void 0 !== b.textColorG ? b.textColorG : 255, void 0 !== b.textColorB ? b.textColorB : 255));
        void 0 !== b.fontSize && a.setTitleFontSize(b.fontSize);
        void 0 !== b.fontName && a.setTitleFontName(b.fontName);
        this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForTextFieldFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b);
        void 0 !== b.placeHolder && a.setPlaceHolder(b.placeHolder);
        a.setString(b.text);
        void 0 !== b.fontSize && a.setFontSize(b.fontSize);
        void 0 !== b.fontName && a.setFontName(b.fontName);
        void 0 !== b.touchSizeWidth && void 0 !== b.touchSizeHeight && a.setTouchSize(cc.size(b.touchSizeWidth, b.touchSizeHeight));
        var c = b.maxLengthEnable;
        a.setMaxLengthEnabled(c);
        c && a.setMaxLength(b.maxLength);
        c = b.passwordEnable;
        a.setPasswordEnabled(c);
        c && a.setPasswordStyleText(b.passwordStyleText);
        this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForLoadingBarFromJsonDictionary: function(a,
        b) {
        this.setPropsForWidgetFromJsonDictionary(a, b);
        var c = b.textureData;
        switch (c.resourceType) {
            case 0:
                var d = this._filePath;
                (c = c.path) && a.loadTexture(d + c);
                break;
            case 1:
                c = c.path, a.loadTexture(c, ccui.Widget.PLIST_TEXTURE)
        }
        d = b.scale9Enable;
        a.setScale9Enabled(d);
        d && (a.setCapInsets(cc.rect(b.capInsetsX, b.capInsetsY, b.capInsetsWidth, b.capInsetsHeight)), a.setSize(cc.size(b.width, b.height)));
        a.setDirection(b.direction);
        a.setPercent(b.percent);
        this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    setPropsForListViewFromJsonDictionary: function(a,
        b) {
        this.setPropsForLayoutFromJsonDictionary(a, b);
        a.setInnerContainerSize(cc.size(b.innerWidth || 0, b.innerHeight || 0));
        a.setDirection(b.direction || 0);
        a.setGravity(b.gravity || 0);
        a.setItemsMargin(b.itemMargin || 0)
    },
    setPropsForPageViewFromJsonDictionary: function(a, b) {
        this.setPropsForLayoutFromJsonDictionary(a, b)
    },
    setPropsForLabelBMFontFromJsonDictionary: function(a, b) {
        this.setPropsForWidgetFromJsonDictionary(a, b);
        var c = b.fileNameData;
        switch (c.resourceType) {
            case 0:
                a.setFntFile(this._filePath + c.path);
                break;
            case 1:
                cc.log("Wrong res type of LabelAtlas!")
        }
        a.setString(b.text);
        this.setColorPropsForWidgetFromJsonDictionary(a, b)
    },
    widgetFromProtocolBuffers: function(a) {
        var b = a.classname,
            c = this._createGUI(b),
            d = this._getWidgetReaderClassName(b);
        (d = this._createWidgetReaderProtocol(d)) ? this.setPropsForAllWidgetFromProtocolBuffers(d, c, a): (d = this._getWidgetReaderClassNameFromWidget(c), (d = this._createWidgetReaderProtocol(d)) && c ? (this.setPropsForAllWidgetFromProtocolBuffers(d, c, a), this.setPropsForAllCustomWidgetFromJsonDictionary(b,
            c, a.widgetOptions.componentOptions)) : cc.log("Widget or WidgetReader doesn't exists!!!  Please check your json file."));
        b = a.children.length;
        for (d = 0; d < b; ++d) {
            var e = this.widgetFromProtocolBuffers(a.children[d]);
            if (e) {
                var f = c;
                f instanceof ccui.PageView ? f.addPage(e) : (f = c, f instanceof ccui.ListView ? f.pushBackCustomItem(e) : c.addChild(e))
            }
        }
        return c
    },
    setPropsForAllWidgetFromProtocolBuffers: function(a, b, c) {
        a.setPropsFromProtocolBuffers(b, c)
    },
    widgetFromXML: function(a, b) {
        var c = b.substr(0, b.find("ObjectData")),
            d = this.createGUI(c),
            e = this.getWidgetReaderClassName(c);
        (e = this.createWidgetReaderProtocol(e)) ? this.setPropsForAllWidgetFromXML(e, d, a): (e = this.getWidgetReaderClassName(d), (e = this.createWidgetReaderProtocol(e)) && d ? (this.setPropsForAllWidgetFromXML(e, d, a), (void 0).Parse(""), (void 0).HasParseError() && cc.log("GetParseError %s\n", (void 0).GetParseError()), this.setPropsForAllCustomWidgetFromJsonDictionary(c, d, void 0)) : cc.log("Widget or WidgetReader doesn't exists!!!  Please check your json file."));
        c = !1;
        for (a = a.FirstChildElement(); a;) {
            if ("Children" !== a.Name()) {
                c = !0;
                break
            }
            a = a.NextSiblingElement()
        }
        if (c)
            for (a = a.FirstChildElement(); a;) {
                for (c = a.FirstAttribute(); c;) {
                    var e = c.Name(),
                        f = c.Value();
                    if ("ctype" == e) {
                        if (f = this.widgetFromXML(a, f)) e = c = d, c instanceof ccui.PageView ? (e = f, e instanceof ccui.Layout && c.addPage(e)) : e ? (c = f, c instanceof ccui.Widget && e.pushBackCustomItem(c)) : d.addChild(f);
                        break
                    }
                    c = c.Next()
                }
                a = a.NextSiblingElement()
            }
        return d
    },
    setPropsForAllWidgetFromXML: function(a, b, c) {
        a.setPropsFromXML(b, c)
    }
});
ccs.sceneReader = {
    _baseBath: "",
    _listener: null,
    _selector: null,
    _node: null,
    createNodeWithSceneFile: function(a) {
        this._node = null;
        this._baseBath = cc.path.dirname(a);
        var b = cc.loader.getRes(a);
        if (!b) throw "Please load the resource first : " + a;
        this._node = this.createObject(b, null);
        ccs.triggerManager.parse(b.Triggers || []);
        return this._node
    },
    createObject: function(a, b) {
        var c = a.classname;
        if ("CCNode" == c) {
            var d = null;
            b ? (d = new cc.Node, b.addChild(d)) : d = new cc.Node;
            this.setPropertyFromJsonDict(d, a);
            for (var e = a.components,
                f = 0; f < e.length; f++) {
                var g = e[f];
                if (!g) break;
                var c = g.classname,
                    h = g.name,
                    k = g.fileData,
                    m = "",
                    n = "",
                    q = 0;
                null != k && (q = void 0 !== k.resourceType ? k.resourceType : -1, m = cc.path.join(this._baseBath, k.path), n = k.plistFile);
                var r = cc.path.extname(m);
                if ("CCSprite" == c) {
                    c = null;
                    if (0 == q) {
                        if (".png" != r) continue;
                        c = new cc.Sprite(m)
                    } else if (1 == q) {
                        if (".plist" != r) continue;
                        n = cc.path.join(this._baseBath, n);
                        m = cc.path.changeExtname(n, ".png");
                        cc.spriteFrameCache.addSpriteFrames(n, m);
                        c = new cc.Sprite("#" + k.path)
                    } else continue;
                    m = new ccs.ComRender(c,
                        "CCSprite");
                    null != h && m.setName(h);
                    d.addComponent(m);
                    this._callSelector(c, g)
                } else if ("CCTMXTiledMap" == c) k = null, 0 == q && ".tmx" == r && (k = new cc.TMXTiledMap(m), m = new ccs.ComRender(k, "CCTMXTiledMap"), null != h && m.setName(h), d.addComponent(m), this._callSelector(k, g));
                else if ("CCParticleSystemQuad" == c) ".plist" == r && (k = null, 0 == q ? (k = new cc.ParticleSystem(m), k.setPosition(0, 0), m = new ccs.ComRender(k, "CCParticleSystemQuad"), null != h && m.setName(h), d.addComponent(m), this._callSelector(k, g)) : cc.log("unknown resourcetype on CCParticleSystemQuad!"));
                else if ("CCArmature" == c) 0 == q && ((q = cc.loader.getRes(m)) || cc.log("Please load the resource [%s] first!", m), q = q.armature_data[0].name, ccs.armatureDataManager.addArmatureFileInfo(m), q = new ccs.Armature(q), m = new ccs.ComRender(q, "CCArmature"), null != h && m.setName(h), d.addComponent(m), (h = g.selectedactionname) && q.getAnimation() && q.getAnimation().play(h), this._callSelector(q, g));
                else if ("CCComAudio" == c) {
                    var s = null;
                    0 == q && (s = new ccs.ComAudio, s.preloadEffect(m), h && s.setName(h), d.addComponent(s), this._callSelector(s,
                        g))
                } else "CCComAttribute" == c ? (k = null, 0 == q ? (k = new ccs.ComAttribute, "" != m && k.parse(m), h && k.setName(h), d.addComponent(k), this._callSelector(k, g)) : cc.log("unknown resourcetype on CCComAttribute!")) : "CCBackgroundAudio" == c ? r && 0 == q && (s = new ccs.ComAudio, s.preloadBackgroundMusic(m), s.setFile(m), q = Boolean(g.loop || 0), s.setLoop(q), h && s.setName(h), d.addComponent(s), s.playBackgroundMusic(m, q), this._callSelector(s, g)) : "GUIComponent" == c && (m = ccs.uiReader.widgetFromJsonFile(m), m = new ccs.ComRender(m, "GUIComponent"),
                    null != h && m.setName(h), d.addComponent(m), this._callSelector(s, g))
            }
            e = a.gameobjects;
            for (f = 0; f < e.length; f++) {
                g = e[f];
                if (!g) break;
                this.createObject(g, d)
            }(f = a.CanvasSize) && d.setContentSize(cc.size(f._width, f._height));
            return d
        }
        return null
    },
    _nodeByTag: function(a, b) {
        if (null == a) return null;
        for (var c = null, d = a.getChildren(), e = 0; e < d.length && !((c = d[e]) && c.getTag() == b) && !(c = this._nodeByTag(c, b)); e++);
        return c
    },
    getNodeByTag: function(a) {
        return null == this._node ? null : this._node.getTag() == a ? this._node : this._nodeByTag(this._node,
            a)
    },
    setPropertyFromJsonDict: function(a, b) {
        var c = cc.isUndefined(b.x) ? 0 : b.x,
            d = cc.isUndefined(b.y) ? 0 : b.y;
        a.setPosition(c, d);
        c = Boolean(cc.isUndefined(b.visible) ? 1 : b.visible);
        a.setVisible(c);
        c = cc.isUndefined(b.objecttag) ? -1 : b.objecttag;
        a.setTag(c);
        c = cc.isUndefined(b.zorder) ? 0 : b.zorder;
        a.setLocalZOrder(c);
        c = cc.isUndefined(b.scalex) ? 1 : b.scalex;
        d = cc.isUndefined(b.scaley) ? 1 : b.scaley;
        a.setScaleX(c);
        a.setScaleY(d);
        c = cc.isUndefined(b.rotation) ? 0 : b.rotation;
        a.setRotation(c);
        a.setName(b.name || "")
    },
    setTarget: function(a,
        b) {
        this._listener = b;
        this._selector = a
    },
    _callSelector: function(a, b) {
        this._selector && this._selector.call(this._listener, a, b)
    },
    version: function() {
        return "1.2.0.0"
    },
    clear: function() {
        ccs.triggerManager.removeAll();
        cc.audioEngine.end()
    }
};
ccs.ActionTimelineData = ccs.Class.extend({
    _actionTag: 0,
    ctor: function(a) {
        this._init(a)
    },
    _init: function(a) {
        this._actionTag = a;
        return !0
    },
    setActionTag: function(a) {
        this._actionTag = a
    },
    getActionTag: function() {
        return this._actionTag
    }
});
ccs.ActionTimelineData.create = function(a) {
    return new ccs.ActionTimelineData(a)
};
ccs.ActionTimeline = cc.Action.extend({
    _timelineMap: null,
    _timelineList: null,
    _duration: 0,
    _time: null,
    _timeSpeed: 1,
    _frameInternal: 1 / 60,
    _playing: !1,
    _currentFrame: 0,
    _startFrame: 0,
    _endFrame: 0,
    _loop: null,
    _frameEventListener: null,
    ctor: function() {
        cc.Action.prototype.ctor.call(this);
        this._timelineMap = {};
        this._timelineList = [];
        this.init()
    },
    _gotoFrame: function(a) {
        for (var b = this._timelineList.length, c = 0; c < b; c++) this._timelineList[c]._gotoFrame(a)
    },
    _stepToFrame: function(a) {
        for (var b = this._timelineList.length, c = 0; c <
            b; c++) this._timelineList[c]._stepToFrame(a)
    },
    _emitFrameEvent: function(a) {
        this._frameEventListener && this._frameEventListener(a)
    },
    init: function() {
        return !0
    },
    gotoFrameAndPlay: function(a, b, c, d) {
        var e = 0,
            f = arguments.length,
            g = [],
            h;
        for (e; e < f; e++) "boolean" === typeof arguments[e] ? h = arguments[e] : g.push(arguments[e]);
        a = g[0];
        b = g[1] || this._duration;
        c = g[2] || a;
        this._startFrame = a;
        this._endFrame = b;
        this._currentFrame = c;
        this._loop = null != h ? h : !0;
        this._time = this._currentFrame * this._frameInternal;
        this.resume();
        this._gotoFrame(this._currentFrame)
    },
    gotoFrameAndPause: function(a) {
        this._startFrame = this._currentFrame = a;
        this._time = this._currentFrame * this._frameInternal;
        this.pause();
        this._gotoFrame(this._currentFrame)
    },
    pause: function() {
        this._playing = !1
    },
    resume: function() {
        this._playing = !0
    },
    isPlaying: function() {
        return this._playing
    },
    setTimeSpeed: function(a) {
        this._timeSpeed = a
    },
    getTimeSpeed: function() {
        return this._timeSpeed
    },
    setDuration: function(a) {
        this._duration = a
    },
    getDuration: function() {
        return this._duration
    },
    getStartFrame: function() {
        return this._startFrame
    },
    getEndFrame: function() {
        return this._endFrame
    },
    setCurrentFrame: function(a) {
        a >= this._startFrame && a >= this._endFrame ? (this._currentFrame = a, this._time = this._currentFrame * this._frameInternal) : cc.log("frame index is not between start frame and end frame")
    },
    getCurrentFrame: function() {
        return this._currentFrame
    },
    addTimeline: function(a) {
        var b = a.getActionTag();
        this._timelineMap[b] || (this._timelineMap[b] = []);
        this._timelineMap[b].some(function(b) {
            if (b === a) return !0
        }) || (this._timelineList.push(a), this._timelineMap[b].push(a),
            a.setActionTimeline(this))
    },
    removeTimeline: function(a) {
        var b = a.getActionTag();
        this._timelineMap[b] && this._timelineMap[b].some(function(b) {
            if (b === a) return !0
        }) && (cc.arrayRemoveObject(this._timelineMap[b], a), cc.arrayRemoveObject(this._timelineList, a), a.setActionTimeline(null))
    },
    getTimelines: function() {
        return this._timelineList
    },
    setFrameEventCallFunc: function(a) {
        this._frameEventListener = a
    },
    clearFrameEventCallFunc: function() {
        this._frameEventListener = null
    },
    clone: function() {
        var a = new ccs.ActionTimeline;
        a.setDuration(this._duration);
        a.setTimeSpeed(this._timeSpeed);
        for (var b in this._timelineMap) {
            var c = this._timelineMap[b],
                d;
            for (d in c) {
                var e = c[d].clone();
                a.addTimeline(e)
            }
        }
        return a
    },
    reverse: function() {
        return null
    },
    step: function(a) {
        if (this._playing && !(0 == this._timelineMap.length || 0 == this._duration)) this._time += a * this._timeSpeed, this._currentFrame = this._time / this._frameInternal, this._stepToFrame(this._currentFrame), this._time > this._endFrame * this._frameInternal && ((this._playing = this._loop) ? this.gotoFrameAndPlay(this._startFrame,
            this._endFrame, this._loop) : this._time = this._endFrame * this._frameInternal)
    },
    _foreachNodeDescendant: function(a, b) {
        b(a);
        for (var c = a.getChildren(), d = 0; d < c.length; d++) this._foreachNodeDescendant(c[d], b)
    },
    startWithTarget: function(a) {
        cc.Action.prototype.startWithTarget.call(this, a);
        var b = this;
        this._foreachNodeDescendant(a, function(a) {
            var d = a.getUserObject();
            if (d && (d = d.getActionTag(), b._timelineMap[d]))
                for (var d = b._timelineMap[d], e = 0; e < d.length; e++) d[e].setNode(a)
        })
    },
    isDone: function() {
        return !1
    }
});
ccs.ActionTimeline.create = function() {
    return new ccs.ActionTimeline
};
ccui.actionTimelineCacheStatic = {
    FrameType_VisibleFrame: "VisibleFrame",
    FrameType_PositionFrame: "PositionFrame",
    FrameType_ScaleFrame: "ScaleFrame",
    FrameType_RotationFrame: "RotationFrame",
    FrameType_SkewFrame: "SkewFrame",
    FrameType_RotationSkewFrame: "RotationSkewFrame",
    FrameType_AnchorFrame: "AnchorPointFrame",
    FrameType_InnerActionFrame: "InnerActionFrame",
    FrameType_ColorFrame: "ColorFrame",
    FrameType_TextureFrame: "TextureFrame",
    FrameType_EventFrame: "EventFrame",
    FrameType_ZOrderFrame: "ZOrderFrame",
    ACTION: "action",
    DURATION: "duration",
    TIMELINES: "timelines",
    FRAME_TYPE: "frameType",
    FRAMES: "frames",
    FRAME_INDEX: "frameIndex",
    TWEEN: "tween",
    TIME_SPEED: "speed",
    ACTION_TAG: "actionTag",
    INNER_ACTION: "innerActionType",
    START_FRAME: "startFrame",
    X: "x",
    Y: "y",
    ROTATION: "rotation",
    ALPHA: "alpha",
    RED: "red",
    GREEN: "green",
    BLUE: "blue",
    Value: "value"
};
ccs.actionTimelineCache = {
    _FrameCreateFunc: null,
    _Pair: null,
    _funcs: null,
    _animationActions: null,
    init: function() {
        this._animationActions = {};
        this._funcs = {};
        this._funcs.VisibleFrame = this._loadVisibleFrame;
        this._funcs.PositionFrame = this._loadPositionFrame;
        this._funcs.ScaleFrame = this._loadScaleFrame;
        this._funcs.RotationFrame = this._loadRotationFrame;
        this._funcs.SkewFrame = this._loadSkewFrame;
        this._funcs.RotationSkewFrame = this._loadRotationSkewFrame;
        this._funcs.AnchorFrame = this._loadAnchorPointFrame;
        this._funcs.InnerActionFrame =
            this._loadInnerActionFrame;
        this._funcs.ColorFrame = this._loadColorFrame;
        this._funcs.TextureFrame = this._loadTextureFrame;
        this._funcs.EventFrame = this._loadEventFrame;
        this._funcs.ZOrderFrame = this._loadZOrderFrame
    },
    removeAction: function(a) {
        this._animationActions[a] && delete this._animationActions[a]
    },
    createAction: function(a) {
        var b = a.lastIndexOf("."),
            b = a.substr(b + 1, a.length),
            c = ccs.actionTimelineCache;
        if ("csb" == b) return c.createActionFromProtocolBuffers(a);
        if ("json" == b || "ExportJson" == b) return c.createActionFromJson(a);
        "xml" == b && cc.log("Does not support");
        return null
    },
    createActionFromJson: function(a) {
        var b = this._animationActions[a];
        null == b && (b = this.loadAnimationActionWithFile(a));
        return b.clone()
    },
    loadAnimationActionWithFile: function(a) {
        var b = cc.loader.getRes(a);
        return this.loadAnimationActionWithContent(a, b)
    },
    loadAnimationActionWithContent: function(a, b) {
        var c = this._animationActions[a];
        if (c) return c;
        var d = b[ccui.actionTimelineCacheStatic.ACTION],
            c = new ccs.ActionTimeline;
        c.setDuration(d[ccui.actionTimelineCacheStatic.DURATION]);
        c.setTimeSpeed(d[ccui.actionTimelineCacheStatic.TIME_SPEED] || 1);
        for (var e = d[ccui.actionTimelineCacheStatic.TIMELINES].length, f = 0; f < e; f++) {
            var g = this._loadTimeline(d[ccui.actionTimelineCacheStatic.TIMELINES][f]);
            g && c.addTimeline(g)
        }
        return this._animationActions[a] = c
    },
    createActionFromProtocolBuffers: function(a) {
        var b = this._animationActions[a];
        null == b && (b = this.loadAnimationActionWithFileFromProtocolBuffers(a));
        return b.clone()
    },
    loadAnimationActionWithFileFromProtocolBuffers: function(a) {
        var b = this._animationActions[a];
        if (b) return b;
        var b = cc.loader.getRes(a),
            c = PBP.CSParseBinary.decode(b).action,
            b = new ccs.ActionTimeline;
        b.setDuration(c.duration);
        b.setTimeSpeed(null !== c.speed ? c.speed : 1);
        for (var d = c.timelines.length, e = 0; e < d; e++) var f = c.timelines[e],
            f = this.loadTimelineFromProtocolBuffers(f);
        for (e = 0; e < d; e++) f = c.timelines[e], (f = this.loadTimelineFromProtocolBuffers(f)) && b.addTimeline(f);
        return this._animationActions[a] = b
    },
    _loadTimeline: function(a) {
        var b = null,
            c = a[ccui.actionTimelineCacheStatic.FRAME_TYPE];
        if (null == c) return null;
        if (c && this._funcs[c]) {
            b = new ccs.Timeline;
            b.setActionTag(a[ccui.actionTimelineCacheStatic.ACTION_TAG]);
            for (var c = this._funcs[c], d = a[ccui.actionTimelineCacheStatic.FRAMES].length, e = 0; e < d; e++) {
                var f = a[ccui.actionTimelineCacheStatic.FRAMES][e],
                    g = null;
                null != c && (g = c(f), g.setFrameIndex(f[ccui.actionTimelineCacheStatic.FRAME_INDEX]), g.setTween(f[ccui.actionTimelineCacheStatic.TWEEN] || !1));
                b.addFrame(g)
            }
        }
        return b
    },
    _loadVisibleFrame: function(a) {
        var b = new ccs.VisibleFrame;
        b.setVisible(a[ccui.actionTimelineCacheStatic.Value]);
        return b
    },
    _loadPositionFrame: function(a) {
        var b = new ccs.PositionFrame;
        b.setPosition(cc.p(a[ccui.actionTimelineCacheStatic.X], a[ccui.actionTimelineCacheStatic.Y]));
        return b
    },
    _loadScaleFrame: function(a) {
        var b = new ccs.ScaleFrame,
            c = a[ccui.actionTimelineCacheStatic.Y];
        b.setScaleX(a[ccui.actionTimelineCacheStatic.X]);
        b.setScaleY(c);
        return b
    },
    _loadSkewFrame: function(a) {
        var b = new ccs.SkewFrame,
            c = a[ccui.actionTimelineCacheStatic.Y];
        b.setSkewX(a[ccui.actionTimelineCacheStatic.X]);
        b.setSkewY(c);
        return b
    },
    _loadRotationSkewFrame: function(a) {
        var b =
            new ccs.RotationSkewFrame,
            c = a[ccui.actionTimelineCacheStatic.Y];
        b.setSkewX(a[ccui.actionTimelineCacheStatic.X]);
        b.setSkewY(c);
        return b
    },
    _loadRotationFrame: function(a) {
        var b = new ccs.RotationFrame;
        b.setRotation(a[ccui.actionTimelineCacheStatic.ROTATION]);
        return b
    },
    _loadAnchorPointFrame: function(a) {
        var b = new ccs.AnchorPointFrame;
        b.setAnchorPoint(Point(a[ccui.actionTimelineCacheStatic.X], a[ccui.actionTimelineCacheStatic.Y]));
        return b
    },
    _loadInnerActionFrame: function(a) {
        var b = new ccs.InnerActionFrame,
            c =
            a[ccui.actionTimelineCacheStatic.START_FRAME];
        b.setInnerActionType(a[ccui.actionTimelineCacheStatic.INNER_ACTION]);
        b.setStartFrameIndex(c);
        return b
    },
    _loadColorFrame: function(a) {
        var b = new ccs.ColorFrame,
            c = a[ccui.actionTimelineCacheStatic.RED],
            d = a[ccui.actionTimelineCacheStatic.GREEN],
            e = a[ccui.actionTimelineCacheStatic.BLUE];
        b.setAlpha(a[ccui.actionTimelineCacheStatic.ALPHA]);
        b.setColor(cc.color(c, d, e));
        return b
    },
    _loadTextureFrame: function(a) {
        var b = new ccs.TextureFrame;
        a = a[ccui.actionTimelineCacheStatic.Value];
        if (null != a) {
            var c = a;
            null == cc.spriteFrameCache.getSpriteFrame(c) && (c = ccs.csLoader.getJsonPath() + a);
            b.setTextureName(c)
        }
        return b
    },
    _loadEventFrame: function(a) {
        var b = new ccs.EventFrame;
        a = a[ccui.actionTimelineCacheStatic.Value];
        null != a && b.setEvent(a);
        return b
    },
    _loadZOrderFrame: function(a) {
        var b = new ccs.ZOrderFrame;
        b.setZOrder(a[ccui.actionTimelineCacheStatic.Value]);
        return b
    },
    loadTimelineFromProtocolBuffers: function(a) {
        var b = null,
            c = a.frameType;
        if (null == c) return null;
        if (c) {
            b = new ccs.Timeline;
            b.setActionTag(a.actionTag);
            for (var d = a.frames.length, e = 0; e < d; e++) {
                var f = a.frames[e],
                    g = null;
                ccui.actionTimelineCacheStatic.FrameType_VisibleFrame === c ? g = this.loadVisibleFrameFromProtocolBuffers(f.visibleFrame) : ccui.actionTimelineCacheStatic.FrameType_PositionFrame === c ? g = this.loadPositionFrameFromProtocolBuffers(f.positionFrame) : ccui.actionTimelineCacheStatic.FrameType_ScaleFrame === c ? g = this.loadScaleFrameFromProtocolBuffers(f.scaleFrame) : ccui.actionTimelineCacheStatic.FrameType_RotationSkewFrame === c ? g = this.loadRotationSkewFrameFromProtocolBuffers(f.rotationSkewFrame) :
                    ccui.actionTimelineCacheStatic.FrameType_AnchorFrame === c ? g = this.loadAnchorPointFrameFromProtocolBuffers(f.anchorPointFrame) : ccui.actionTimelineCacheStatic.FrameType_ColorFrame === c ? g = this.loadColorFrameFromProtocolBuffers(f.colorFrame) : ccui.actionTimelineCacheStatic.FrameType_TextureFrame === c ? g = this.loadTextureFrameFromProtocolBuffers(f.textureFrame) : ccui.actionTimelineCacheStatic.FrameType_EventFrame === c ? g = this.loadEventFrameFromProtocolBuffers(f.eventFrame) : ccui.actionTimelineCacheStatic.FrameType_ZOrderFrame ===
                    c && (g = this.loadZOrderFrameFromProtocolBuffers(f.zOrderFrame));
                b.addFrame(g)
            }
        }
        return b
    },
    loadVisibleFrameFromProtocolBuffers: function(a) {
        var b = new ccs.VisibleFrame;
        b.setVisible(a.value);
        b.setFrameIndex(null !== a.frameIndex ? a.frameIndex : 0);
        b.setTween(null !== a.tween ? a.tween : !1);
        return b
    },
    loadPositionFrameFromProtocolBuffers: function(a) {
        var b = new ccs.PositionFrame;
        b.setPosition(cc.p(a.x, a.y));
        b.setFrameIndex(null !== a.frameIndex ? a.frameIndex : 0);
        b.setTween(null !== a.tween ? a.tween : !1);
        return b
    },
    loadScaleFrameFromProtocolBuffers: function(a) {
        var b =
            new ccs.ScaleFrame,
            c = a.y;
        b.setScaleX(a.x);
        b.setScaleY(c);
        b.setFrameIndex(null !== a.frameIndex ? a.frameIndex : 0);
        b.setTween(null !== a.tween ? a.tween : !1);
        return b
    },
    loadRotationSkewFrameFromProtocolBuffers: function(a) {
        var b = new ccs.RotationSkewFrame,
            c = a.y;
        b.setSkewX(a.x);
        b.setSkewY(c);
        b.setFrameIndex(null !== a.frameIndex ? a.frameIndex : 0);
        b.setTween(null !== a.tween ? a.tween : !1);
        return b
    },
    loadAnchorPointFrameFromProtocolBuffers: function(a) {
        var b = new ccs.AnchorPointFrame;
        b.setAnchorPoint(cc.p(a.x, a.y));
        b.setFrameIndex(null !==
            a.frameIndex ? a.frameIndex : 0);
        b.setTween(null !== a.tween ? a.tween : !1);
        return b
    },
    loadColorFrameFromProtocolBuffers: function(a) {
        var b = new ccs.ColorFrame,
            c = a.red,
            d = a.green,
            e = a.blue;
        b.setAlpha(a.alpha);
        b.setColor(cc.color(c, d, e));
        b.setFrameIndex(null !== a.frameIndex ? a.frameIndex : 0);
        b.setTween(null !== a.tween ? a.tween : !1);
        return b
    },
    loadTextureFrameFromProtocolBuffers: function(a) {
        var b = new ccs.TextureFrame,
            c = a.filepath;
        null != c && b.setTextureName(c);
        b.setFrameIndex(null !== a.frameIndex ? a.frameIndex : 0);
        b.setTween(null !==
            a.tween ? a.tween : !1);
        return b
    },
    loadEventFrameFromProtocolBuffers: function(a) {
        var b = new ccs.EventFrame,
            c = a.value;
        null != c && b.setEvent(c);
        b.setFrameIndex(null !== a.frameIndex ? a.frameIndex : 0);
        b.setTween(null !== a.tween ? a.tween : !1);
        return b
    },
    loadZOrderFrameFromProtocolBuffers: function(a) {
        var b = new ccs.ZOrderFrame;
        b.setZOrder(a.value);
        b.setFrameIndex(null !== a.frameIndex ? a.frameIndex : 0);
        b.setTween(null !== a.tween ? a.tween : !1);
        return b
    },
    createActionFromXML: function(a) {
        var b = this._animationActions[a];
        null == b &&
            (b = this.loadAnimationActionWithFileFromXML(a));
        return b.clone()
    },
    loadAnimationActionWithFileFromXML: function(a) {
        var b = this._animationActions[a];
        if (b) return b;
        a = cc.loader.getRes(a);
        var c = new tinyxml2.XMLDocument;
        c.Parse(a);
        a = c.RootElement().FirstChildElement();
        for (c = !1; a;) {
            0 == strcmp("Content", a.Name()) && (a.FirstAttribute() || (c = !0));
            if (c) break;
            var d = a.FirstChildElement();
            a = d ? d : a.NextSiblingElement()
        }
        if (c)
            for (d = a.FirstChildElement(); d;) "Animation" == d.Name() && (b = this.loadActionTimelineFromXML(d)), d = d.NextSiblingElement();
        return b
    },
    loadActionTimelineFromXML: function(a) {
        for (var b = new ccs.ActionTimeline, c = a.FirstAttribute(); c;) {
            var d = c.Name(),
                e = c.Value();
            "Duration" == d ? b.setDuration(atoi(e.c_str())) : "Speed" == d && b.setTimeSpeed(atof(e.c_str()));
            c = c.Next()
        }
        for (a = a.FirstChildElement(); a;)(c = loadTimelineFromXML(a)) && b.addTimeline(c), a = a.NextSiblingElement();
        return b
    },
    loadTimelineFromXML: function(a) {
        for (var b = null, c = 0, d = "", e = a.FirstAttribute(); e;) {
            var f = e.Name(),
                g = e.Value();
            "ActionTag" == f ? c = atoi(g.c_str()) : "FrameType" == f &&
                (d = g);
            e = e.Next()
        }
        "" != d && (b = new ccs.Timeline, b.setActionTag(c));
        for (a = a.FirstChildElement(); a;) c = null, d == FrameType_VisibleFrame ? c = loadVisibleFrameFromXML(a) : d == FrameType_PositionFrame ? c = loadPositionFrameFromXML(a) : d == FrameType_ScaleFrame ? c = loadScaleFrameFromXML(a) : d == FrameType_RotationSkewFrame ? c = loadRotationSkewFrameFromXML(a) : d == FrameType_AnchorFrame ? c = loadAnchorPointFrameFromXML(a) : d == FrameType_ColorFrame ? c = loadColorFrameFromXML(a) : d == FrameType_TextureFrame ? c = loadTextureFrameFromXML(a) : d == FrameType_EventFrame ?
            c = loadEventFrameFromXML(a) : d == FrameType_ZOrderFrame && (c = loadZOrderFrameFromXML(a)), c && b.addFrame(c), a = a.NextSiblingElement();
        return b
    },
    loadVisibleFrameFromXML: function(a) {
        var b = new ccs.VisibleFrame;
        b.setTween(!0);
        for (a = a.FirstAttribute(); a;) {
            var c = a.Name(),
                d = a.Value();
            "Value" == c ? b.setVisible("True" == d ? !0 : !1) : "FrameIndex" == c ? b.setFrameIndex(atoi(d)) : "Tween" == c && b.setTween("True" == d ? !0 : !1);
            a = a.Next()
        }
        return b
    },
    loadPositionFrameFromXML: function(a) {
        var b = new ccs.PositionFrame;
        b.setTween(!0);
        for (a = a.FirstAttribute(); a;) {
            var c =
                a.Name(),
                d = a.Value();
            "X" == c ? b.setX(atof(d)) : "Y" == c ? b.setY(atof(d)) : "FrameIndex" == c ? b.setFrameIndex(atoi(d)) : "Tween" == c && b.setTween("True" == d ? !0 : !1);
            a = a.Next()
        }
        return b
    },
    loadScaleFrameFromXML: function(a) {
        var b = new ccs.ScaleFrame;
        b.setTween(!0);
        for (a = a.FirstAttribute(); a;) {
            var c = a.Name(),
                d = a.Value();
            "X" == c ? b.setScaleX(atof(d)) : "Y" == c ? b.setScaleY(atof(d)) : "FrameIndex" == c ? b.setFrameIndex(atoi(d)) : "Tween" == c && b.setTween("True" == d ? !0 : !1);
            a = a.Next()
        }
        return b
    },
    loadRotationSkewFrameFromXML: function(a) {
        var b =
            new ccs.RotationSkewFrame;
        b.setTween(!0);
        for (a = a.FirstAttribute(); a;) {
            var c = a.Name(),
                d = a.Value();
            "X" == c ? b.setSkewX(atof(d)) : "Y" == c ? b.setSkewY(atof(d)) : "FrameIndex" == c ? b.setFrameIndex(atoi(d)) : "Tween" == c && b.setTween("True" == d ? !0 : !1);
            a = a.Next()
        }
        return b
    },
    loadAnchorPointFrameFromXML: function(a) {
        var b = new ccs.AnchorPointFrame,
            c = 0.5,
            d = 0.5;
        b.setTween(!0);
        for (a = a.FirstAttribute(); a;) {
            var e = a.Name(),
                f = a.Value();
            "X" == e ? c = atof(f) : "Y" == e ? d = atof(f) : "FrameIndex" == e ? b.setFrameIndex(atoi(f)) : "Tween" == e && b.setTween("True" ==
                f ? !0 : !1);
            a = a.Next()
        }
        b.setAnchorPoint(cc.p(c, d));
        return b
    },
    loadColorFrameFromXML: function(a) {
        var b = new ccs.ColorFrame,
            c = 255,
            d = 255,
            e = 255;
        b.setTween(!0);
        for (var f = a.FirstAttribute(); f;) {
            var g = f.Name(),
                h = f.Value();
            "FrameIndex" == g ? b.setFrameIndex(atoi(h)) : "Alpha" == g ? b.setAlpha(atoi(h)) : "Tween" == g && b.setTween("True" == h ? !0 : !1);
            f = f.Next()
        }
        for (a = a.FirstChildElement(); a;) {
            for (f = a.FirstAttribute(); f;) g = f.Name(), h = f.Value(), "R" == g ? c = atoi(h) : "G" == g ? d = atoi(h) : "B" == g && (e = atoi(h)), f = f.Next();
            a = a.NextSiblingElement()
        }
        b.setColor(cc.color(c,
            d, e));
        return b
    },
    loadTextureFrameFromXML: function(a) {
        var b = new ccs.TextureFrame;
        b.setTween(!0);
        for (a = a.FirstAttribute(); a;) {
            var c = a.Name(),
                d = a.Value();
            "Path" == c ? b.setTextureName(d) : "FrameIndex" == c ? b.setFrameIndex(atoi(d.c_str())) : "Tween" == c && b.setTween("True" == d ? !0 : !1);
            a = a.Next()
        }
        return b
    },
    loadEventFrameFromXML: function(a) {
        var b = new ccs.EventFrame;
        b.setTween(!0);
        for (a = a.FirstAttribute(); a;) {
            var c = a.Name(),
                d = a.Value();
            "EventStr" == c ? b.setEvent(d) : "FrameIndex" == c ? b.setFrameIndex(atoi(d.c_str())) : "Tween" ==
                c && b.setTween("True" == d ? !0 : !1);
            a = a.Next()
        }
        return b
    },
    loadZOrderFrameFromXML: function(a) {
        a = new ccs.ZOrderFrame;
        a.setTween(!0);
        for (var b = frameElement.FirstAttribute(); b;) {
            var c = b.Name(),
                d = b.Value();
            "zorder" == c ? a.setZOrder(atoi(d)) : "FrameIndex" == c ? a.setFrameIndex(atoi(d)) : "Tween" == c && a.setTween("True" == d ? !0 : !1);
            b = b.Next()
        }
        return a
    }
};
ccs.actionTimelineCache.init();
ccs.actionTimelineCache._sharedActionCache = null;
ccs.Frame = ccs.Class.extend({
    _frameIndex: null,
    _tween: null,
    _timeline: null,
    _node: null,
    ctor: function() {
        this._frameIndex = 0;
        this._tween = !0;
        this._node = this._timeline = null
    },
    _emitEvent: function() {
        this._timeline && this._timeline.getActionTimeline()._emitFrameEvent(this)
    },
    _cloneProperty: function(a) {
        this._frameIndex = a.getFrameIndex();
        this._tween = a.isTween()
    },
    setFrameIndex: function(a) {
        this._frameIndex = a
    },
    getFrameIndex: function() {
        return this._frameIndex
    },
    setTimeline: function(a) {
        this._timeline = a
    },
    getTimeline: function(a) {
        return this._timeline
    },
    setNode: function(a) {
        this._node = a
    },
    getNode: function() {
        return this._node
    },
    setTween: function(a) {
        this._tween = a
    },
    isTween: function() {
        return this._tween
    },
    onEnter: function(a) {},
    apply: function(a) {},
    clone: function() {}
});
ccs.VisibleFrame = ccs.Frame.extend({
    _visible: !0,
    ctor: function() {
        ccs.Frame.prototype.ctor.call(this);
        this._visible = !0
    },
    onEnter: function(a) {
        this._node.setVisible(this._visible)
    },
    clone: function() {
        var a = new ccs.VisibleFrame;
        a.setVisible(this._visible);
        a._cloneProperty(this);
        return a
    },
    setVisible: function(a) {
        this._visible = a
    },
    isVisible: function() {
        return this._visible
    }
});
ccs.VisibleFrame.create = function() {
    return new ccs.VisibleFrame
};
ccs.TextureFrame = ccs.Frame.extend({
    _sprite: null,
    _textureName: null,
    ctor: function() {
        ccs.Frame.prototype.ctor.call(this);
        this._textureName = ""
    },
    setNode: function(a) {
        ccs.Frame.prototype.setNode.call(this, a);
        this._sprite = a
    },
    onEnter: function(a) {
        this._sprite && (a = cc.spriteFrameCache.getSpriteFrame(this._textureName), null != a ? this._sprite.setSpriteFrame(a) : this._sprite.setTexture(this._textureName))
    },
    clone: function() {
        var a = new ccs.TextureFrame;
        a.setTextureName(this._textureName);
        a._cloneProperty(this);
        return a
    },
    setTextureName: function(a) {
        this._textureName = a
    },
    getTextureName: function() {
        return this._textureName
    }
});
ccs.TextureFrame.create = function() {
    return new ccs.TextureFrame
};
ccs.RotationFrame = ccs.Frame.extend({
    _rotation: null,
    _betwennRotation: null,
    ctor: function() {
        ccs.Frame.prototype.ctor.call(this);
        this._rotation = 0
    },
    onEnter: function(a) {
        this._node.setRotation(this._rotation);
        this._tween && (this._betwennRotation = a._rotation - this._rotation)
    },
    apply: function(a) {
        this._tween && 0 != this._betwennRotation && this._node.setRotation(this._rotation + a * this._betwennRotation)
    },
    clone: function() {
        var a = new ccs.RotationFrame;
        a.setRotation(this._rotation);
        a._cloneProperty(this);
        return a
    },
    setRotation: function(a) {
        this._rotation =
            a
    },
    getRotation: function() {
        return this._rotation
    }
});
ccs.RotationFrame.create = function() {
    return new ccs.RotationFrame
};
ccs.SkewFrame = ccs.Frame.extend({
    _skewX: null,
    _skewY: null,
    _betweenSkewX: null,
    _betweenSkewY: null,
    ctor: function() {
        ccs.Frame.prototype.ctor.call(this);
        this._skewY = this._skewX = 0
    },
    onEnter: function(a) {
        this._node.setSkewX(this._skewX);
        this._node.setSkewY(this._skewY);
        this._tween && (this._betweenSkewX = a._skewX - this._skewX, this._betweenSkewY = a._skewY - this._skewY)
    },
    apply: function(a) {
        if (this._tween && (0 != this._betweenSkewX || 0 != this._betweenSkewY)) {
            var b = this._skewY + a * this._betweenSkewY;
            this._node.setSkewX(this._skewX +
                a * this._betweenSkewX);
            this._node.setSkewY(b)
        }
    },
    clone: function() {
        var a = new ccs.SkewFrame;
        a.setSkewX(this._skewX);
        a.setSkewY(this._skewY);
        a._cloneProperty(this);
        return a
    },
    setSkewX: function(a) {
        this._skewX = a
    },
    getSkewX: function() {
        return this._skewX
    },
    setSkewY: function(a) {
        this._skewY = a
    },
    getSkewY: function() {
        return this._skewY
    }
});
ccs.SkewFrame.create = function() {
    return new ccs.SkewFrame
};
ccs.RotationSkewFrame = ccs.SkewFrame.extend({
    onEnter: function(a) {
        this._node.setRotationX(this._skewX);
        this._node.setRotationY(this._skewY);
        this._tween && (this._betweenSkewX = a._skewX - this._skewX, this._betweenSkewY = a._skewY - this._skewY)
    },
    apply: function(a) {
        if (this._tween && (0 != this._betweenSkewX || 0 != this._betweenSkewY)) {
            var b = this._skewY + a * this._betweenSkewY;
            this._node.setRotationX(this._skewX + a * this._betweenSkewX);
            this._node.setRotationY(b)
        }
    },
    clone: function() {
        var a = new ccs.RotationSkewFrame;
        a.setSkewX(this._skewX);
        a.setSkewY(this._skewY);
        a._cloneProperty(this);
        return a
    }
});
ccs.RotationSkewFrame.create = function() {
    return new ccs.RotationSkewFrame
};
ccs.PositionFrame = ccs.Frame.extend({
    _position: null,
    _betweenX: null,
    _betweenY: null,
    ctor: function() {
        ccs.Frame.prototype.ctor.call(this);
        this._position = cc.p(0, 0)
    },
    onEnter: function(a) {
        this._node.setPosition(this._position);
        this._tween && (this._betweenX = a._position.x - this._position.x, this._betweenY = a._position.y - this._position.y)
    },
    apply: function(a) {
        if (this._tween && (0 != this._betweenX || 0 != this._betweenY)) {
            var b = cc.p(0, 0);
            b.x = this._position.x + this._betweenX * a;
            b.y = this._position.y + this._betweenY * a;
            this._node.setPosition(b)
        }
    },
    clone: function() {
        var a = new ccs.PositionFrame;
        a.setPosition(this._position);
        a._cloneProperty(this);
        return a
    },
    setPosition: function(a) {
        this._position = a
    },
    getPosition: function() {
        return this._position
    },
    setX: function(a) {
        this._position.x = a
    },
    getX: function() {
        return this._position.x
    },
    setY: function(a) {
        this._position.y = a
    },
    getY: function() {
        return this._position.y
    }
});
ccs.PositionFrame.create = function() {
    return new ccs.PositionFrame
};
ccs.ScaleFrame = ccs.Frame.extend({
    _scaleX: null,
    _scaleY: null,
    _betweenScaleX: null,
    _betweenScaleY: null,
    ctor: function() {
        ccs.Frame.prototype.ctor.call(this);
        this._scaleY = this._scaleX = 1
    },
    onEnter: function(a) {
        this._node.setScaleX(this._scaleX);
        this._node.setScaleY(this._scaleY);
        this._tween && (this._betweenScaleX = a._scaleX - this._scaleX, this._betweenScaleY = a._scaleY - this._scaleY)
    },
    apply: function(a) {
        if (this._tween && (0 != this._betweenScaleX || 0 != this._betweenScaleY)) {
            var b = this._scaleY + this._betweenScaleY * a;
            this._node.setScaleX(this._scaleX +
                this._betweenScaleX * a);
            this._node.setScaleY(b)
        }
    },
    clone: function() {
        var a = new ccs.ScaleFrame;
        a.setScaleX(this._scaleX);
        a.setScaleY(this._scaleY);
        a._cloneProperty(this);
        return a
    },
    setScale: function(a) {
        this._scaleY = this._scaleX = a
    },
    setScaleX: function(a) {
        this._scaleX = a
    },
    getScaleX: function() {
        return this._scaleX
    },
    setScaleY: function(a) {
        this._scaleY = a
    },
    getScaleY: function() {
        return this._scaleY
    }
});
ccs.ScaleFrame.create = function() {
    return new ccs.ScaleFrame
};
ccs.AnchorPointFrame = ccs.Frame.extend({
    _anchorPoint: null,
    ctor: function() {
        ccs.Frame.prototype.ctor.call(this);
        this._anchorPoint = cc.p(0, 0)
    },
    onEnter: function(a) {
        this._node.setAnchorPoint(this._anchorPoint)
    },
    clone: function() {
        var a = new ccs.AnchorPointFrame;
        a.setAnchorPoint(this._anchorPoint);
        a._cloneProperty(this);
        return a
    },
    setAnchorPoint: function(a) {
        this._anchorPoint = a
    },
    getAnchorPoint: function() {
        return this._anchorPoint
    }
});
ccs.AnchorPointFrame.create = function() {
    return new ccs.AnchorPointFrame
};
ccs.InnerActionType = {
    LoopAction: 0,
    NoLoopAction: 1,
    SingleFrame: 2
};
ccs.InnerActionFrame = ccs.Frame.extend({
    _innerActionType: null,
    _startFrameIndex: null,
    ctor: function() {
        ccs.Frame.prototype.ctor.call(this);
        this._innerActionType = ccs.InnerActionType.LoopAction;
        this._startFrameIndex = 0
    },
    onEnter: function(a) {},
    clone: function() {
        var a = new ccs.InnerActionFrame;
        a.setInnerActionType(this._innerActionType);
        a.setStartFrameIndex(this._startFrameIndex);
        a._cloneProperty(this);
        return a
    },
    setInnerActionType: function(a) {
        this._innerActionType = a
    },
    getInnerActionType: function() {
        return this._innerActionType
    },
    setStartFrameIndex: function(a) {
        this._startFrameIndex = a
    },
    getStartFrameIndex: function() {
        return this._startFrameIndex
    }
});
ccs.InnerActionFrame.create = function() {
    return new ccs.InnerActionFrame
};
ccs.ColorFrame = ccs.Frame.extend({
    _alpha: null,
    _color: null,
    _betweenAlpha: null,
    _betweenRed: null,
    _betweenGreen: null,
    _betweenBlue: null,
    ctor: function() {
        ccs.Frame.prototype.ctor.call(this);
        this._alpha = 255;
        this.color = cc.color(255, 255, 255)
    },
    onEnter: function(a) {
        this._node.setOpacity(this._alpha);
        this._node.setColor(this._color);
        this._tween && (this._betweenAlpha = a._alpha - this._alpha, a = a._color, this._betweenRed = a.r - this._color.r, this._betweenGreen = a.g - this._color.g, this._betweenBlue = a.b - this._color.b)
    },
    apply: function(a) {
        if (this._tween &&
            (0 != this._betweenAlpha || 0 != this._betweenRed || 0 != this._betweenGreen || 0 != this._betweenBlue)) {
            var b = this._alpha + this._betweenAlpha * a,
                c = cc.color(255, 255, 255);
            c.r = this._color.r + this._betweenRed * a;
            c.g = this._color.g + this._betweenGreen * a;
            c.b = this._color.b + this._betweenBlue * a;
            this._node.setOpacity(b);
            this._node.setColor(c)
        }
    },
    clone: function() {
        var a = new ccs.ColorFrame;
        a.setAlpha(this._alpha);
        a.setColor(this._color);
        a._cloneProperty(this);
        return a
    },
    setAlpha: function(a) {
        this._alpha = a
    },
    getAlpha: function() {
        return this._alpha
    },
    setColor: function(a) {
        this._color = a
    },
    getColor: function() {
        return this._color
    }
});
ccs.ColorFrame.create = function() {
    return new ccs.ColorFrame
};
ccs.EventFrame = ccs.Frame.extend({
    _event: null,
    ctor: function() {
        ccs.Frame.prototype.ctor.call(this);
        this._event = ""
    },
    onEnter: function(a) {
        this._emitEvent()
    },
    clone: function() {
        var a = new ccs.EventFrame;
        a.setEvent(this._event);
        a._cloneProperty(this);
        return a
    },
    setEvent: function(a) {
        this._event = a
    },
    getEvent: function() {
        return this._event
    }
});
ccs.EventFrame.create = function() {
    return new ccs.EventFrame
};
ccs.ZOrderFrame = ccs.Frame.extend({
    _zorder: null,
    onEnter: function(a) {
        this._node && this._node.setLocalZOrder(this._zorder)
    },
    clone: function() {
        var a = new ccs.ZOrderFrame;
        a.setZOrder(this._zorder);
        a._cloneProperty(this);
        return a
    },
    setZOrder: function(a) {
        this._zorder = a
    },
    getZOrder: function() {
        return this._zorder
    }
});
ccs.ZOrderFrame.create = function() {
    return new ccs.ZOrderFrame
};
ccs.Timeline = ccs.Class.extend({
    _frames: null,
    _currentKeyFrame: null,
    _currentKeyFrameIndex: null,
    _fromIndex: null,
    _toIndex: null,
    _betweenDuration: null,
    _actionTag: null,
    _ActionTimeline: null,
    _node: null,
    ctor: function() {
        this._frames = [];
        this._currentKeyFrame = null;
        this._actionTag = this._betweenDuration = this._toIndex = this._fromIndex = this._currentKeyFrameIndex = 0;
        this._node = this._ActionTimeline = null
    },
    _gotoFrame: function(a) {
        0 != this._frames.length && (this._binarySearchKeyFrame(a), this._apply(a))
    },
    _stepToFrame: function(a) {
        0 !=
            this._frames.length && (this._updateCurrentKeyFrame(a), this._apply(a))
    },
    getFrames: function() {
        return this._frames
    },
    addFrame: function(a) {
        this._frames.push(a);
        a.setTimeline(this)
    },
    insertFrame: function(a, b) {
        this._frames.splice(b, 0, a);
        a.setTimeline(this)
    },
    removeFrame: function(a) {
        cc.arrayRemoveObject(this._frames, a);
        a.setTimeline(null)
    },
    setActionTag: function(a) {
        this._actionTag = a
    },
    getActionTag: function() {
        return this._actionTag
    },
    setNode: function(a) {
        for (var b = 0; b < this._frames.length; b++) this._frames[b].setNode(a)
    },
    getNode: function() {
        return this._node
    },
    setActionTimeline: function(a) {
        this._ActionTimeline = a
    },
    getActionTimeline: function() {
        return this._ActionTimeline
    },
    clone: function() {
        var a = new ccs.Timeline;
        a._actionTag = this._actionTag;
        for (var b = 0; b < this._frames.length; b++) {
            var c = this._frames[b].clone();
            a.addFrame(c)
        }
        return a
    },
    _apply: function(a) {
        this._currentKeyFrame && this._currentKeyFrame.apply(0 == this._betweenDuration ? 0 : (a - this._currentKeyFrameIndex) / this._betweenDuration)
    },
    _binarySearchKeyFrame: function(a) {
        var b =
            null,
            c = null,
            d = this._frames.length,
            e = !1;
        do
            if (a <= this._frames[0].getFrameIndex()) this._currentKeyFrameIndex >= this._frames[0].getFrameIndex() && (e = !0), b = c = this._frames[0], this._currentKeyFrameIndex = 0, this._betweenDuration = this._frames[0].getFrameIndex();
            else if (a >= this._frames[d - 1].getFrameIndex()) b = c = this._frames[d - 1], this._currentKeyFrameIndex = this._frames[d - 1].getFrameIndex(), this._betweenDuration = 0;
        else {
            for (var f = -1, b = 0, c = d - 1, g = 0; b <= c;) {
                g = Math.ceil((b + c) / 2);
                if (a >= this._frames[g].getFrameIndex() &&
                    a < this._frames[g + 1].getFrameIndex()) {
                    f = g;
                    break
                }
                this._frames[g].getFrameIndex() > a ? c = g - 1 : b = g + 1
            }
            b = this._frames[f];
            c = this._frames[f + 1];
            0 == f && this._currentKeyFrameIndex < b.getFrameIndex() && (e = !0);
            this._currentKeyFrameIndex = b.getFrameIndex();
            this._betweenDuration = c.getFrameIndex() - b.getFrameIndex()
        }
        while (0);
        if (e || this._currentKeyFrame != b) this._currentKeyFrame = b, this._currentKeyFrame.onEnter(c)
    },
    _updateCurrentKeyFrame: function(a) {
        if (a < this._currentKeyFrameIndex || a >= this._currentKeyFrameIndex + this._betweenDuration) {
            var b =
                null,
                c = null;
            do {
                var d = this._frames.length;
                if (a < this._frames[0].getFrameIndex()) b = c = this._frames[0], this._currentKeyFrameIndex = 0, this._betweenDuration = this._frames[0].getFrameIndex();
                else if (a >= this._frames[d - 1].getFrameIndex()) b = c = this._frames[d - 1], this._currentKeyFrameIndex = this._frames[d - 1].getFrameIndex(), this._betweenDuration = 0;
                else {
                    do
                        if (this._fromIndex = this._toIndex, b = this._frames[this._fromIndex], this._currentKeyFrameIndex = b.getFrameIndex(), this._toIndex = this._fromIndex + 1, this._toIndex >= d &&
                            (this._toIndex = 0), c = this._frames[this._toIndex], a == b.getFrameIndex()) break;
                    while (a < b.getFrameIndex() || a >= c.getFrameIndex());
                    this._betweenDuration = c.getFrameIndex() - b.getFrameIndex()
                }
            } while (0);
            this._currentKeyFrame = b;
            this._currentKeyFrame.onEnter(c)
        }
    }
});
ccs.Timeline.create = function() {
    return new ccs.Timeline
};
ccui.CSLoaderStatic = {
    ClassName_Node: "Node",
    ClassName_SubGraph: "SubGraph",
    ClassName_Sprite: "Sprite",
    ClassName_Particle: "Particle",
    ClassName_TMXTiledMap: "TMXTiledMap",
    ClassName_Panel: "Panel",
    ClassName_Button: "Button",
    ClassName_CheckBox: "CheckBox",
    ClassName_ImageView: "ImageView",
    ClassName_TextAtlas: "TextAtlas",
    ClassName_LabelAtlas: "LabelAtlas",
    ClassName_LabelBMFont: "LabelBMFont",
    ClassName_TextBMFont: "TextBMFont",
    ClassName_Text: "Text",
    ClassName_LoadingBar: "LoadingBar",
    ClassName_TextField: "TextField",
    ClassName_Slider: "Slider",
    ClassName_Layout: "Layout",
    ClassName_ScrollView: "ScrollView",
    ClassName_ListView: "ListView",
    ClassName_PageView: "PageView",
    ClassName_Widget: "Widget",
    ClassName_Label: "Label",
    ClassName_ComAudio: "ComAudio",
    NODE: "nodeTree",
    CHILDREN: "children",
    CLASSNAME: "classname",
    FILE_PATH: "fileName",
    PLIST_FILE: "plistFile",
    TMX_FILE: "tmxFile",
    TMX_STRING: "tmxString",
    RESOURCE_PATH: "resourcePath",
    COMPONENTS: "components",
    COMPONENT_TYPE: "componentType",
    COMPONENT_NAME: "componentName",
    COMPONENT_ENABLED: "componentEnabled",
    COMPONENT_AUDIO_FILE_PATH: "comAudioFilePath",
    COMPONENT_LOOP: "comAudioloop",
    TAG: "tag",
    ACTION_TAG: "actionTag",
    OPTIONS: "options",
    WIDTH: "width",
    HEIGHT: "height",
    X: "x",
    Y: "y",
    SCALE_X: "scaleX",
    SCALE_Y: "scaleY",
    SKEW_X: "skewX",
    SKEW_Y: "skewY",
    ROTATION: "rotation",
    ROTATION_SKEW_X: "rotationSkewX",
    ROTATION_SKEW_Y: "rotationSkewY",
    ANCHOR_X: "anchorPointX",
    ANCHOR_Y: "anchorPointY",
    ALPHA: "opacity",
    RED: "colorR",
    GREEN: "colorG",
    BLUE: "colorB",
    ZORDER: "ZOrder",
    PARTICLE_NUM: "particleNum",
    FLIPX: "flipX",
    FLIPY: "flipY",
    VISIBLE: "visible",
    TEXTURES: "textures",
    TEXTURES_PNG: "texturesPng",
    MONO_COCOS2D_VERSION: "cocos2dVersion"
};
ccs.csLoader = {
    _recordJsonPath: !0,
    _jsonPath: "",
    _recordProtocolBuffersPath: !1,
    _protocolBuffersPath: "",
    _monoCocos2dxVersion: "",
    init: function() {
        this._funcs = {};
        this._componentFuncs = {};
        this._funcs[ccui.CSLoaderStatic.ClassName_Node] = ccs.csLoader.loadSimpleNode.bind(this);
        this._funcs[ccui.CSLoaderStatic.ClassName_SubGraph] = ccs.csLoader.loadSubGraph.bind(this);
        this._funcs[ccui.CSLoaderStatic.ClassName_Sprite] = ccs.csLoader.loadSprite.bind(this);
        this._funcs[ccui.CSLoaderStatic.ClassName_Particle] = ccs.csLoader.loadParticle.bind(this);
        this._funcs[ccui.CSLoaderStatic.ClassName_TMXTiledMap] = ccs.csLoader.loadTMXTiledMap.bind(this);
        this._funcs[ccui.CSLoaderStatic.ClassName_LabelAtlas] = ccs.csLoader.loadWidget.bind(this);
        this._funcs[ccui.CSLoaderStatic.ClassName_LabelBMFont] = ccs.csLoader.loadWidget.bind(this);
        this._funcs[ccui.CSLoaderStatic.ClassName_Panel] = ccs.csLoader.loadWidget.bind(this);
        this._funcs[ccui.CSLoaderStatic.ClassName_Button] = ccs.csLoader.loadWidget.bind(this);
        this._funcs[ccui.CSLoaderStatic.ClassName_CheckBox] = ccs.csLoader.loadWidget.bind(this);
        this._funcs[ccui.CSLoaderStatic.ClassName_ImageView] = ccs.csLoader.loadWidget.bind(this);
        this._funcs[ccui.CSLoaderStatic.ClassName_TextAtlas] = ccs.csLoader.loadWidget.bind(this);
        this._funcs[ccui.CSLoaderStatic.ClassName_TextBMFont] = ccs.csLoader.loadWidget.bind(this);
        this._funcs[ccui.CSLoaderStatic.ClassName_Text] = ccs.csLoader.loadWidget.bind(this);
        this._funcs[ccui.CSLoaderStatic.ClassName_LoadingBar] = ccs.csLoader.loadWidget.bind(this);
        this._funcs[ccui.CSLoaderStatic.ClassName_TextField] = ccs.csLoader.loadWidget.bind(this);
        this._funcs[ccui.CSLoaderStatic.ClassName_Slider] = ccs.csLoader.loadWidget.bind(this);
        this._funcs[ccui.CSLoaderStatic.ClassName_Layout] = ccs.csLoader.loadWidget.bind(this);
        this._funcs[ccui.CSLoaderStatic.ClassName_ScrollView] = ccs.csLoader.loadWidget.bind(this);
        this._funcs[ccui.CSLoaderStatic.ClassName_ListView] = ccs.csLoader.loadWidget.bind(this);
        this._funcs[ccui.CSLoaderStatic.ClassName_PageView] = ccs.csLoader.loadWidget.bind(this);
        this._funcs[ccui.CSLoaderStatic.ClassName_Widget] = ccs.csLoader.loadWidget.bind(this);
        this._funcs[ccui.CSLoaderStatic.ClassName_Label] = ccs.csLoader.loadWidget.bind(this);
        this._componentFuncs[ccui.CSLoaderStatic.ClassName_ComAudio] = ccs.csLoader.loadComAudio.bind(this)
    },
    createNode: function(a) {
        var b = a.lastIndexOf("."),
            b = a.substr(b + 1, a.length),
            c = ccs.csLoader;
        return "csb" == b ? c.createNodeFromProtocolBuffers(a) : "json" == b || "ExportJson" == b ? c.createNodeFromJson(a) : null
    },
    createTimeline: function(a) {
        var b = a.lastIndexOf("."),
            b = a.substr(b + 1, a.length),
            c = ccs.actionTimelineCache;
        return "csb" == b ? c.createActionFromProtocolBuffers(a) :
            "json" == b || "ExportJson" == b ? c.createActionFromJson(a) : null
    },
    createNodeFromJson: function(a) {
        if (this._recordJsonPath) {
            var b = a.substr(0, a.lastIndexOf("/") + 1);
            ccs.uiReader.setFilePath(b);
            this._jsonPath = b
        } else ccs.uiReader.setFilePath(""), this._jsonPath = "";
        return this.loadNodeWithFile(a)
    },
    loadNodeWithFile: function(a) {
        var b = cc.loader.getRes(a),
            c = this.loadNodeWithContent(b);
        ccs.actionTimelineCache.loadAnimationActionWithContent(a, b);
        return c
    },
    loadNodeWithContent: function(a) {
        this._monoCocos2dxVersion = a[ccui.CSLoaderStatic.MONO_COCOS2D_VERSION] ||
            a.version;
        for (var b = a[ccui.CSLoaderStatic.TEXTURES], c = a[ccui.CSLoaderStatic.TEXTURES_PNG], d = b.length, e = 0; e < d; e++) {
            var f = b[e],
                g = c[e],
                f = this._jsonPath + f,
                g = this._jsonPath + g;
            cc.spriteFrameCache.addSpriteFrames(f, g)
        }
        return this.loadNode(a[ccui.CSLoaderStatic.NODE])
    },
    setRecordJsonPath: function(a) {
        this._recordJsonPath = a
    },
    isRecordJsonPath: function() {
        return this._recordJsonPath
    },
    setJsonPath: function(a) {
        this._jsonPath = a
    },
    getJsonPath: function() {
        return this._jsonPath
    },
    createNodeFromProtocolBuffers: function(a) {
        if (this._recordProtocolBuffersPath) {
            var b =
                a.substr(0, a.lastIndexOf("/") + 1);
            ccs.uiReader.setFilePath(b);
            this._protocolBuffersPath = b
        } else ccs.uiReader.setFilePath(""), this._protocolBuffersPath = "";
        return this.nodeFromProtocolBuffersFile(a)
    },
    nodeFromProtocolBuffersFile: function(a) {
        for (var b = cc.loader.getRes(a), b = PBP.CSParseBinary.decode(b), c = b.textures.length, d = 0; d < c; ++d) {
            var e = b.textures[d],
                f = b.texturesPng[d],
                e = this._protocolBuffersPath + e,
                f = this._protocolBuffersPath + f;
            cc.spriteFrameCache.addSpriteFrames(e, f)
        }
        c = b.designWidth;
        d = b.designHeight;
        0 >= c || 0 >= d ? (cc.log("Read design size error!\n"), c = cc.director.getWinSize(), ccs.uiReader.storeFileDesignSize(a, c)) : ccs.uiReader.storeFileDesignSize(a, cc.size(c, d));
        return this.nodeFromProtocolBuffers(b.nodeTree)
    },
    nodeFromProtocolBuffers: function(a) {
        var b = null,
            c = a.classname,
            d;
        if ("Node" == c) {
            var b = new ccs.Node,
                e = a.widgetOptions;
            this.setPropsForNodeFromProtocolBuffers(b, e);
            d = e
        } else if ("SingleNode" == c) b = new ccs.Node, e = a.widgetOptions, this.setPropsForSingleNodeFromProtocolBuffers(b, e), d = e;
        else if ("Sprite" ==
            c) b = new cc.Sprite, d = a.widgetOptions, e = a.spriteOptions, this.setPropsForSpriteFromProtocolBuffers(b, e, d);
        else if ("ProjectNode" == c) {
            if (d = a.widgetOptions, e = a.projectNodeOptions, c = e.filename(), "" != c && (b = this.createNodeFromProtocolBuffers(this._protocolBuffersPath + c), this.setPropsForProjectNodeFromProtocolBuffers(b, e, d), e = ccs.ActionTimelineCache.createActionFromProtocolBuffers(this._protocolBuffersPath + c))) b.runAction(e), e.gotoFrameAndPlay(0)
        } else if ("Particle" == c) d = a.widgetOptions, e = a.particleSystemOptions,
            b = this.createParticleFromProtocolBuffers(e, d);
        else if ("GameMap" == c) d = a.widgetOptions, e = a.tmxTiledMapOptions, b = this.createTMXTiledMapFromProtocolBuffers(e, d);
        else if ("SimpleAudio" == c) b = new cc.Node, e = a.widgetOptions, this.setPropsForSimpleAudioFromProtocolBuffers(b, e), d = e;
        else if (this.isWidget(c)) {
            var e = this.getGUIClassName(c),
                b = e + "Reader",
                e = ccs.objectFactory.createObject(e),
                f = ccs.objectFactory.createObject(b);
            f.setPropsFromProtocolBuffers(e, a);
            f = a.widgetOptions;
            b = f.actionTag;
            e.setUserObject(new ccs.ActionTimelineData(b));
            b = e
        } else this.isCustomWidget(c) && (e = ccs.objectFactory.createObject(c), b = this.getWidgetReaderClassName(e), (f = ccs.objectFactory.createObject(b)) && e ? (b = new ccs.WidgetPropertiesReader0300, b.setPropsForAllWidgetFromProtocolBuffers(f, e, a), f = a.widgetOptions, b.setPropsForAllCustomWidgetFromJsonDictionary(c, e, f.customProperty)) : cc.log("Widget or WidgetReader doesn't exists!!!  Please check your protocol buffers file."), f = a.widgetOptions, b = f.actionTag, e.setUserObject(new ccs.ActionTimelineData(b)), b = e); if (d) {
            e =
                d.componentOptions.length;
            for (c = 0; c < e; ++c)(f = this.createComponentFromProtocolBuffers(d.componentOptions[c])) && b.addComponent(f)
        }
        d = a.children.length;
        for (c = 0; c < d; ++c) {
            var g = this.nodeFromProtocolBuffers(a.children[c]);
            g && (f = e = b, e instanceof ccui.PageView ? (f = g, f instanceof ccui.Layout && e.addPage(f)) : f instanceof ccui.ListView ? (e = g, e instanceof ccui.Widget && f.pushBackCustomItem(e)) : b.addChild(g))
        }
        return b
    },
    setRecordProtocolBuffersPath: function(a) {
        this._recordProtocolBuffersPath = a
    },
    isRecordProtocolBuffersPath: function() {
        return this._recordProtocolBuffersPath
    },
    setProtocolBuffersPath: function(a) {
        this._protocolBuffersPath = a
    },
    getProtocolBuffersPath: function() {
        return this._protocolBuffersPath
    },
    loadNode: function(a) {
        var b = null,
            c = a[ccui.CSLoaderStatic.CLASSNAME],
            d = this._funcs[c];
        if (null != d) {
            var e = a[ccui.CSLoaderStatic.OPTIONS];
            if (b = d(e))
                for (var d = e[ccui.CSLoaderStatic.COMPONENTS], f = e[ccui.CSLoaderStatic.COMPONENTS] || 0, e = 0; e < f; ++e) {
                    var g = d[ccui.CSLoaderStatic.COMPONENTS][e];
                    (g = this.loadComponent(g)) && b.addComponent(g)
                }
        }
        if (b) {
            c = a[ccui.CSLoaderStatic.CHILDREN].length ||
                0;
            for (e = 0; e < c; e++)
                if (g = a[ccui.CSLoaderStatic.CHILDREN][e], d = this.loadNode(g))
                    if (g = f = b, f instanceof ccui.PageView) d instanceof ccui.Layout && f.addPage(d);
                    else if (g instanceof ccui.ListView) f = d, f instanceof ccui.Widget && g.pushBackCustomItem(f);
            else {
                if ("3.x" != this._monoCocos2dxVersion && (f = d, g = b, f instanceof ccui.Widget && g instanceof ccui.Widget && !(g instanceof ccui.Layout)))
                    if (f.getPositionType() == ccui.Widget.POSITION_PERCENT) f.setPositionPercent(cc.p(f.getPositionPercent().x + g.getAnchorPoint().x, f.getPositionPercent().y +
                        g.getAnchorPoint().y)), f.setPosition(cc.p(f.getPositionX() + g.getAnchorPointInPoints().x, f.getPositionY() + g.getAnchorPointInPoints().y));
                    else {
                        var h = g.getContentSize();
                        f.setPosition(cc.p(f.getPositionX() + h.width * g.getAnchorPoint().x, f.getPositionY() + h.height * g.getAnchorPoint().y))
                    }
                b.addChild(d)
            }
        } else cc.log("Not supported NodeType: %s", c);
        return b
    },
    locateNodeWithMulresPosition: function(a, b) {},
    initNode: function(a, b) {
        var c = null != b[ccui.CSLoaderStatic.WIDTH] ? b[ccui.CSLoaderStatic.WIDTH] : 0,
            d = null != b[ccui.CSLoaderStatic.HEIGHT] ?
            b[ccui.CSLoaderStatic.HEIGHT] : 0,
            e = null != b[ccui.CSLoaderStatic.X] ? b[ccui.CSLoaderStatic.X] : 0,
            f = null != b[ccui.CSLoaderStatic.Y] ? b[ccui.CSLoaderStatic.Y] : 0,
            g = null != b[ccui.CSLoaderStatic.SCALE_X] ? b[ccui.CSLoaderStatic.SCALE_X] : 1,
            h = null != b[ccui.CSLoaderStatic.SCALE_Y] ? b[ccui.CSLoaderStatic.SCALE_Y] : 1,
            k = null != b[ccui.CSLoaderStatic.ROTATION] ? b[ccui.CSLoaderStatic.ROTATION] : 0,
            m = null != b[ccui.CSLoaderStatic.ROTATION_SKEW_X] ? b[ccui.CSLoaderStatic.ROTATION_SKEW_X] : 0,
            n = null != b[ccui.CSLoaderStatic.ROTATION_SKEW_Y] ?
            b[ccui.CSLoaderStatic.ROTATION_SKEW_Y] : 0,
            q = null != b[ccui.CSLoaderStatic.SKEW_X] ? b[ccui.CSLoaderStatic.SKEW_X] : 0,
            r = null != b[ccui.CSLoaderStatic.SKEW_Y] ? b[ccui.CSLoaderStatic.SKEW_Y] : 0,
            s = null != b[ccui.CSLoaderStatic.ANCHOR_X] ? b[ccui.CSLoaderStatic.ANCHOR_X] : 0.5,
            t = null != b[ccui.CSLoaderStatic.ANCHOR_Y] ? b[ccui.CSLoaderStatic.ANCHOR_Y] : 0.5,
            u = null != b[ccui.CSLoaderStatic.ALPHA] ? b[ccui.CSLoaderStatic.ALPHA] : 255,
            w = null != b[ccui.CSLoaderStatic.RED] ? b[ccui.CSLoaderStatic.RED] : 255,
            v = null != b[ccui.CSLoaderStatic.GREEN] ?
            b[ccui.CSLoaderStatic.GREEN] : 255,
            y = null != b[ccui.CSLoaderStatic.BLUE] ? b[ccui.CSLoaderStatic.BLUE] : 255,
            D = null != b[ccui.CSLoaderStatic.ZORDER] ? b[ccui.CSLoaderStatic.ZORDER] : 0,
            C = null != b[ccui.CSLoaderStatic.TAG] ? b[ccui.CSLoaderStatic.TAG] : 0,
            z = null != b[ccui.CSLoaderStatic.ACTION_TAG] ? b[ccui.CSLoaderStatic.ACTION_TAG] : 0,
            A = null != b[ccui.CSLoaderStatic.VISIBLE] ? b[ccui.CSLoaderStatic.VISIBLE] : !0;
        (0 != e || 0 != f) && a.setPosition(cc.p(e, f));
        1 != g && a.setScaleX(g);
        1 != h && a.setScaleY(h);
        0 != k && a.setRotation(k);
        0 != m && a.setRotationX(m);
        0 != n && a.setRotationY(n);
        0 != q && a.setSkewX(q);
        0 != r && a.setSkewY(r);
        (0.5 != s || 0.5 != t) && a.setAnchorPoint(cc.p(s, t));
        (0 != c || 0 != d) && a.setContentSize(cc.size(c, d));
        0 != D && a.setLocalZOrder(D);
        !0 != A && a.setVisible(A);
        255 != u && a.setOpacity(u);
        (255 != w || 255 != v || 255 != y) && a.setColor(cc.color(w, v, y));
        a.setTag(C);
        a.setUserObject(new ccs.ActionTimelineData(z))
    },
    loadSimpleNode: function(a) {
        var b = new ccs.Node;
        this.initNode(b, a);
        return b
    },
    loadSubGraph: function(a) {
        var b = a[ccui.CSLoaderStatic.FILE_PATH],
            c = null,
            c = b && "" != b ? this.createNode(b) :
            new ccs.Node;
        this.initNode(c, a);
        return c
    },
    loadSprite: function(a) {
        var b = a[ccui.CSLoaderStatic.FILE_PATH],
            c = null;
        null != b ? (c = b, (b = cc.spriteFrameCache.getSpriteFrame(c)) ? c = ccs.Sprite.createWithSpriteFrame(b) : (c = this._jsonPath + c, c = new ccs.Sprite(c)), c || (c = new cc.Sprite, cc.log("filePath is empty. Create a sprite with no texture"))) : c = new ccs.Sprite;
        this.initNode(c, a);
        b = a[ccui.CSLoaderStatic.FLIPX];
        a = a[ccui.CSLoaderStatic.FLIPY];
        !1 != b && c.setFlippedX(b);
        !1 != a && c.setFlippedY(a);
        return c
    },
    loadParticle: function(a) {
        var b =
            a[ccui.CSLoaderStatic.PARTICLE_NUM],
            c = new cc.ParticleSystemQuad(a[ccui.CSLoaderStatic.PLIST_FILE]);
        c.setTotalParticles(b);
        this.initNode(c, a);
        return c
    },
    loadTMXTiledMap: function(a) {
        var b = a[ccui.CSLoaderStatic.TMX_FILE],
            c = a[ccui.CSLoaderStatic.TMX_STRING];
        a = a[ccui.CSLoaderStatic.RESOURCE_PATH];
        var d = null;
        b && "" != b ? d = new cc.TMXTiledMap(b) : c && "" != c && (a && "" != a) && (d = new cc.TMXTiledMap(c, a));
        return d
    },
    loadWidget: function(a) {
        var b = a[ccui.CSLoaderStatic.CLASSNAME];
        if (null == b) return null;
        var c = new ccs.WidgetPropertiesReader0300,
            d = null;
        if (this.isWidget(b)) {
            var e = this.getGUIClassName(b),
                e = e + "Reader",
                d = this.getGUIClassName(b),
                d = ccs.objectFactory.createObject(d),
                e = ccs.objectFactory.createObject(e);
            c.setPropsForAllWidgetFromJsonDictionary(e, d, a)
        } else this.isCustomWidget(b) && (d = ccs.objectFactory.createObject(b), e = this.getWidgetReaderClassName(d), (e = ccs.objectFactory.createObject(e)) && d ? (c.setPropsForAllWidgetFromJsonDictionary(e, d, a), c.setPropsForAllCustomWidgetFromJsonDictionary(b, d, a.customProperty)) : cc.log("Widget or WidgetReader doesn't exists!!!  Please check your protocol buffers file."));
        if (d) {
            var c = a[ccui.CSLoaderStatic.ROTATION_SKEW_X],
                b = a[ccui.CSLoaderStatic.ROTATION_SKEW_Y],
                e = a[ccui.CSLoaderStatic.SKEW_X],
                f = a[ccui.CSLoaderStatic.SKEW_Y];
            0 != c && d.setRotationX(c);
            0 != b && d.setRotationY(b);
            0 != e && d.setSkewX(e);
            0 != f && d.setSkewY(f);
            d.setUserObject(new ccs.ActionTimelineData(a[ccui.CSLoaderStatic.ACTION_TAG]))
        }
        return d
    },
    loadComponent: function(a) {
        var b = null,
            c = this._componentFuncs[a[ccui.CSLoaderStatic.COMPONENT_TYPE]];
        null != c && (b = c(a));
        return b
    },
    loadComAudio: function(a) {
        var b = new ccs.ComAudio,
            c = a[ccui.CSLoaderStatic.COMPONENT_ENABLED];
        b.setName(a[ccui.CSLoaderStatic.COMPONENT_NAME]);
        b.setEnabled(c);
        c = a[ccui.CSLoaderStatic.COMPONENT_LOOP];
        b.setFile(a[ccui.CSLoaderStatic.COMPONENT_AUDIO_FILE_PATH]);
        b.setLoop(c);
        return b
    },
    setPropsForNodeFromProtocolBuffers: function(a, b) {
        var c = b.x,
            d = b.y,
            e = b.scaleX,
            f = b.scaleY,
            g = b.rotation,
            h = null !== b.rotationSkewX ? b.rotationSkewX : 0,
            k = null !== b.rotationSkewY ? b.rotationSkewY : 0,
            m = null !== b.anchorPointX ? b.anchorPointX : 0.5,
            n = null !== b.anchorPointY ? b.anchorPointY : 0.5,
            q = b.zorder,
            r = b.tag,
            s = b.actionTag,
            t = b.visible;
        a.setName(b.name);
        (0 != c || 0 != d) && a.setPosition(cc.p(c, d));
        1 != e && a.setScaleX(e);
        1 != f && a.setScaleY(f);
        0 != g && a.setRotation(g);
        0 != h && a.setRotationX(h);
        0 != k && a.setRotationY(k);
        (0.5 != m || 0.5 != n) && a.setAnchorPoint(cc.p(m, n));
        0 != q && a.setLocalZOrder(q);
        !0 != t && a.setVisible(t);
        a.setTag(r);
        a.setUserObject(new ccs.ActionTimelineData(s));
        a.setCascadeColorEnabled(!0);
        a.setCascadeOpacityEnabled(!0)
    },
    setPropsForSingleNodeFromProtocolBuffers: function(a, b) {
        this.setPropsForNodeFromProtocolBuffers(a,
            b)
    },
    setPropsForSpriteFromProtocolBuffers: function(a, b, c) {
        var d = b.fileNameData;
        switch (d.resourceType) {
            case 0:
                d = this._protocolBuffersPath + d.path;
                "" != d && a.setTexture(d);
                break;
            case 1:
                cc.spriteFrameCache.addSpriteFrames(this._protocolBuffersPath + d.plistFile), d = d.path, "" != d && a.setSpriteFrame(d)
        }
        this.setPropsForNodeFromProtocolBuffers(a, c);
        var d = null !== c.Alpha ? c.Alpha : 255,
            e = null !== c.colorR ? c.colorR : 255,
            f = null !== c.colorG ? c.colorG : 255;
        c = null !== c.colorB ? c.colorB : 255;
        255 != d && a.setOpacity(d);
        (255 != e || 255 != f ||
            255 != c) && a.setColor(cc.color(e, f, c));
        c = b.flippedX;
        b = b.flippedY;
        c && a.setFlippedX(c);
        b && a.setFlippedY(b)
    },
    createParticleFromProtocolBuffers: function(a, b) {
        var c = null,
            d = a.fileNameData;
        switch (d.resourceType) {
            case 0:
                d = this._protocolBuffersPath + d.path, "" != d && (c = new cc.ParticleSystemQuad(d))
        }
        c && this.setPropsForNodeFromProtocolBuffers(c, b);
        return c
    },
    createTMXTiledMapFromProtocolBuffers: function(a, b) {
        var c = null,
            d = a.fileNameData;
        switch (d.resourceType) {
            case 0:
                (d = this._protocolBuffersPath + d.path) && "" != d && (c = new cc.TMXTiledMap(d))
        }
        c &&
            this.setPropsForNodeFromProtocolBuffers(c, b);
        return c
    },
    setPropsForProjectNodeFromProtocolBuffers: function(a, b, c) {
        this.setPropsForNodeFromProtocolBuffers(a, c)
    },
    setPropsForSimpleAudioFromProtocolBuffers: function(a, b) {
        this.setPropsForNodeFromProtocolBuffers(a, b)
    },
    createComponentFromProtocolBuffers: function(a) {
        var b = null;
        "ComAudio" == a.type && (b = new ccs.ComAudio, this.setPropsForComAudioFromProtocolBuffers(b, a.comAudioOptions));
        return b
    },
    setPropsForComponentFromProtocolBuffers: function(a, b) {
        "ComAudio" ==
        b.type && (a = new ccs.ComAudio, this.setPropsForComAudioFromProtocolBuffers(a, b.comAudioOptions))
    },
    setPropsForComAudioFromProtocolBuffers: function(a, b) {
        var c = b.fileNameData;
        switch (c.resourceType) {
            case 0:
                a.setFile(this._protocolBuffersPath + c.path)
        }
        a.setLoop(b.loop);
        a.setName(b.name);
        a.setLoop(b.loop)
    },
    isWidget: function(a) {
        return a == ccui.CSLoaderStatic.ClassName_Panel || a == ccui.CSLoaderStatic.ClassName_Button || a == ccui.CSLoaderStatic.ClassName_CheckBox || a == ccui.CSLoaderStatic.ClassName_ImageView || a == ccui.CSLoaderStatic.ClassName_TextAtlas ||
            a == ccui.CSLoaderStatic.ClassName_LabelAtlas || a == ccui.CSLoaderStatic.ClassName_LabelBMFont || a == ccui.CSLoaderStatic.ClassName_TextBMFont || a == ccui.CSLoaderStatic.ClassName_Text || a == ccui.CSLoaderStatic.ClassName_LoadingBar || a == ccui.CSLoaderStatic.ClassName_TextField || a == ccui.CSLoaderStatic.ClassName_Slider || a == ccui.CSLoaderStatic.ClassName_Layout || a == ccui.CSLoaderStatic.ClassName_ScrollView || a == ccui.CSLoaderStatic.ClassName_ListView || a == ccui.CSLoaderStatic.ClassName_PageView || a == ccui.CSLoaderStatic.ClassName_Widget ||
            a == ccui.CSLoaderStatic.ClassName_Label
    },
    isCustomWidget: function(a) {
        return ccs.objectFactory.createObject(a) ? !0 : !1
    },
    getGUIClassName: function(a) {
        var b = a;
        "Panel" == a ? b = "Layout" : "TextArea" == a ? b = "Text" : "TextButton" == a ? b = "Button" : "Label" == a ? b = "Text" : "LabelAtlas" == a ? b = "TextAtlas" : "LabelBMFont" == a && (b = "TextBMFont");
        return b
    },
    getWidgetReaderClassName: function(a) {
        var b;
        a instanceof ccui.Button ? b = "ButtonReader" : a instanceof ccui.CheckBox ? b = "CheckBoxReader" : a instanceof ccui.ImageView ? b = "ImageViewReader" : a instanceof
        ccui.TextAtlas ? b = "TextAtlasReader" : a instanceof ccui.TextBMFont ? b = "TextBMFontReader" : a instanceof ccui.Text ? b = "TextReader" : a instanceof ccui.LoadingBar ? b = "LoadingBarReader" : a instanceof ccui.Slider ? b = "SliderReader" : a instanceof ccui.TextField ? b = "TextFieldReader" : a instanceof ccui.ListView ? b = "ListViewReader" : a instanceof ccui.PageView ? b = "PageViewReader" : a instanceof ccui.ScrollView ? b = "ScrollViewReader" : a instanceof ccui.Layout ? b = "LayoutReader" : a instanceof ccui.Widget && (b = "WidgetReader");
        return b
    }
};
ccs.csLoader.init();
var s_font = "Arial",
    sBMF_fnt = "res/wenzi.fnt",
    fontSize = 23,
    uifont_plist = "res/miniuifont.plist",
    uifont_png = "res/miniuifont.png",
    uifontRes = {
        uifont_0: "#uifont_0.png",
        uifont_1: "#uifont_1.png",
        uifont_2: "#uifont_2.png",
        uifont_3: "#uifont_3.png",
        uifont_Draw: "#uifont_Draw.png",
        uifont_Go: "#uifont_Go.png",
        uifont_Lose: "#uifont_Lose.png",
        uifont_Level: "#uifont_Level.png",
        uifont_Ready: "#uifont_Ready.png",
        uifont_Win: "#uifont_Win.png",
        uifont_menu_s: "#uifont_menu_s.png",
        uifont_menu_n: "#uifont_menu_n.png",
        uifont_uiHeart: "#uifont_uiHeart.png",
        uifont_uiHeartbg: "#uifont_uiHeartbg.png",
        touchpass_png: "#touchpass.png"
    },
    fingerGuess_bg = "res/fingerGuessBg.png",
    fingerGuess_plist = "res/fingerGuess.plist",
    fingerGuess_png = "res/fingerGuess.png",
    fingerGuessRes = {
        finger_1: "#finger_1.png",
        finger_2: "#finger_2.png",
        finger_3: "#finger_3.png",
        finger_noramal: "#finger_normal.png",
        finger_select: "#finger_select.png",
        finger_cal_1: "#finger_cal_1.png",
        finger_cal_2: "#finger_cal_2.png",
        finger_cal_3: "#finger_cal_3.png",
        finger_chacha: "#finger_chacha.png",
        finger_bg: "#finger_bg.png",
        finger_headbg: "#finger_headbg.png",
        finger_headsl: "#finger_headsl.png",
        finger_hand_1: "#finger_hand_1.png",
        finger_hand_2: "#finger_hand_2.png",
        finger_hand_3: "#finger_hand_3.png"
    },
    winui_plist = "res/winui.plist",
    winui_png = "res/winui.png",
    winuiRes = {
        winui_againBg: "#winui_againBg.png",
        winui_againFront: "#winui_againFront.png",
        winui_app: "#winui_app.png",
        winui_contact: "#winui_contact.png",
        winui_shareBg: "#winui_shareBg.png",
        winui_shareFront: "#winui_shareFront.png"
    },
    musicRes = {
        bg: "res/bg.mp3",
        burst: "res/burst.mp3",
        lose: "res/lose.mp3",
        win: "res/win.mp3"
    },
    Res = {
        shuoming_png: "res/shuoming.png",
        progressSp: "res/progressSp.png",
        arrow_png: "res/arrow.png"
    },
    comic_csb = "res/comic/1006.csb",
    addArrayNum = function(a, b) {
        a.push("res/" + b + "/" + b + ".ExportJson");
        a.push("res/" + b + "/" + b + "0.plist");
        a.push("res/" + b + "/" + b + "0.png")
    },
    g_resources = [];
g_resources.push(uifont_plist);
g_resources.push(uifont_png);
g_resources.push(fingerGuess_bg);
g_resources.push(fingerGuess_plist);
g_resources.push(fingerGuess_png);
g_resources.push(winui_plist);
g_resources.push(winui_png);
g_resources.push(sBMF_fnt);
for (var i = 1; 7 > i; i++) {
    var nowString = "res/comic/1006_p" + i + ".jpg";
    g_resources.push(nowString)
}
g_resources.push(comic_csb);
for (i in Res) g_resources.push(Res[i]);
for (i in musicRes) g_resources.push(musicRes[i]);
addArrayNum(g_resources, "1006_01");
addArrayNum(g_resources, "1006_02");
addArrayNum(g_resources, "1006_03");
addArrayNum(g_resources, "1006_04");
var viewPotY = 50,
    EventString = {
        GameScene_event: "GameScene_event",
        GameUILayer_event: "GameUILayer_event"
    },
    GameSceneEvent = {
        winnerScene: 103,
        loseScene: 104
    },
    Helper = Helper || {};
Helper.loadSpriteFrames = function(a, b) {
    cc.loader.load([a, b], function(c, d) {
        c ? cc.log("Failed to load %s, %s", a, b) : cc.spriteFrameCache.addSpriteFrames(a)
    })
};
Helper.plistToSpriteFrames = function(a) {
    for (var b = 0; b < a.length; b++) cc.spriteFrameCache.addSpriteFrames(a[b])
};
Helper.loadImage = function(a) {
    cc.loader.load(a, function(a, c) {})
};
Helper.createAnimation = function(a, b, c, d) {
    for (var e = []; b <= c; b++) {
        var f = a + b + ".png";
        cc.log("nowString %s", f);
        f = cc.spriteFrameCache.getSpriteFrame(f);
        e.push(f)
    }
    cc.log("spriteFrameArr %d", e.length);
    return new cc.Animation(e, d)
};
Helper.loadJsonAnimate = function(a) {
    ccs.armatureDataManager.addArmatureFileInfo("res/" + a + "/" + a + ".ExportJson")
};
Helper.splitStringData = function(a) {
    var b = [];
    a = a.split(",");
    for (var c = 0; c < a.length; c++) {
        for (var d = a[c].split("_"), e = [], f = 0; f < d.length; f++) {
            var g = parseInt(d[f]);
            e.push(g)
        }
        b.push(e)
    }
    return b
};
Helper.createSpriteOnMenuItemSprite = function(a, b, c, d, e) {
    var f = new cc.Sprite(a);
    a = new cc.Sprite(a);
    b = new cc.Sprite(b);
    c = new cc.Sprite(c);
    f.setPosition(b.getContentSize().width / 2, b.getContentSize().height / 2 + 2);
    a.setPosition(c.getContentSize().width / 2, c.getContentSize().height / 2 + 2);
    b.addChild(f);
    c.addChild(a);
    return new cc.MenuItemSprite(b, c, d, e)
};
Helper.removeSelf = function(a) {
    a.removeFromParent()
};
Helper.playMusic = function(a, b) {
    cc.audioEngine.playMusic(a, b)
};
Helper.playEffect = function(a) {};
var FingerGuessData = {
    level: 0,
    maxLevel: 99,
    hp: 3,
    maxHp: 3,
    bossNum: 0
};
initFingerGuessData = function() {
    FingerGuessData.level = 0;
    FingerGuessData.maxLevel = 99;
    FingerGuessData.hp = 3;
    FingerGuessData.maxHp = 3;
    FingerGuessData.bossNum = 0
};
var ComicLayer = cc.Layer.extend({
    comicId: 0,
    goNextMenu: null,
    ctor: function() {
        this._super();
        this.initLayer();
        return !0
    },
    initLayer: function() {
        var a = comic_csb,
            b = ccs.csLoader.createNode(a);
        b && (b.setPosition(0, 0), this.addChild(b), a = ccs.actionTimelineCache.createAction(a), b.runAction(a), a.setTimeSpeed(0.2), a.gotoFrameAndPlay(0, a.getDuration(), !1));
        b = new cc.Sprite(uifontRes.touchpass_png);
        b.x = winSize.width - 70;
        b.y = 22 + viewPotY;
        this.addChild(b, 10);
        this.runAction(cc.sequence(cc.delayTime(1), cc.callFunc(this.touchToPass,
            this)))
    },
    touchToPass: function() {
        var a = this,
            b = cc.EventListener.create({
                event: cc.EventListener.TOUCH_ONE_BY_ONE,
                swallowTouches: !0,
                onTouchBegan: function(b, d) {
                    a.passComic();
                    return !0
                }
            });
        cc.eventManager.addListener(b, this)
    },
    passComic: function() {
        this.showReadyLayer()
    },
    showNextBtn: function() {
        var a = Helper.createSpriteOnMenuItemSprite(uifontRes.uifont_Go, uifontRes.uifont_menu_n, uifontRes.uifont_menu_s, this.showReadyLayer, this);
        a.attr({
            x: 220,
            y: 120
        });
        this.goNextMenu = new cc.Menu(a);
        this.goNextMenu.x = 0;
        this.goNextMenu.y =
            0;
        this.addChild(this.goNextMenu, 10)
    },
    showReadyLayer: function() {
        var a = new cc.Scene,
            b = new TutorialLayer;
        a.addChild(b, 5);
        a = new cc.TransitionFade(1, a);
        cc.director.runScene(a)
    }
});
var TutorialLayer = cc.Layer.extend({
    _richText: null,
    ctor: function() {
        this._super();
        this.initLayer();
        return !0
    },
    initLayer: function() {
        var a = new cc.Sprite(Res.shuoming_png);
        a.attr({
            x: winSize.width / 2,
            y: winSize.height / 2
        });
        this.addChild(a);
        a = Helper.createSpriteOnMenuItemSprite(uifontRes.uifont_Go, uifontRes.uifont_menu_n, uifontRes.uifont_menu_s, function() {
            var a = new GameScene,
                a = new cc.TransitionFade(1, a);
            cc.director.runScene(a)
        }, this);
        a.attr({
            x: winSize.width / 2,
            y: 116
        });
        a = new cc.Menu(a);
        a.x = 0;
        a.y = 0;
        this.addChild(a,
            1)
    }
});
var gameLayerZorder = {
        gameUILayer: 5,
        redLayer: 4,
        mainGameLayer: 2
    },
    GameScene = cc.Scene.extend({
        listener1: null,
        nowIndex: 0,
        nowLayer: null,
        gameUILayer: null,
        pauseLayer: null,
        endGameLayer: null,
        ctor: function() {
            this._super();
            initFingerGuessData();
            return !0
        },
        onEnter: function() {
            this._super();
            this.gameUILayer = new FingerGuessUI;
            this.gameUILayer.x = 0;
            this.gameUILayer.y = 0;
            this.addChild(this.gameUILayer, gameLayerZorder.gameUILayer);
            this.resetNowLayer();
            var a = this;
            this.listener1 = cc.EventListener.create({
                event: cc.EventListener.CUSTOM,
                eventName: EventString.GameScene_event,
                callback: function(b) {
                    b = b.getUserData();
                    b == GameSceneEvent.winnerScene ? a.changeToWinScene() : b == GameSceneEvent.loseScene && a.changeToLoseScene()
                }
            });
            cc.eventManager.addListener(this.listener1, this)
        },
        onEnterTransitionDidFinish: function() {
            this._super();
            this.gameUILayer.readyGoActionHandle(0.1, this.startEnterActionOnGameScene, this)
        },
        changeToWinScene: function() {
            this.changeToLoseScene()
        },
        changeToLoseScene: function() {
            this.endGameLayer = new EndGameLayer;
            this.endGameLayer.setPosition(0,
                0);
            this.addChild(this.endGameLayer, 20)
        },
        resetNowLayer: function() {
            this.nowLayer && (this.nowLayer.removeFromParent(), this.nowLayer = null);
            this.nowLayer = new FingerGuessing;
            this.addChild(this.nowLayer, gameLayerZorder.mainGameLayer)
        },
        startEnterActionOnGameScene: function() {
            this.nowLayer && this.nowLayer.startEnterAction()
        }
    });
var FingerGuessManType = [{
        id: 100,
        Num: 1,
        Tips: 1,
        Spe: 2,
        Wat: 1
    }, {
        id: 101,
        Num: 1,
        Tips: 2,
        Spe: 2,
        Wat: 1
    }, {
        id: 102,
        Num: 1,
        Tips: 1,
        Spe: 1,
        Wat: 1
    }, {
        id: 103,
        Num: 1,
        Tips: 2,
        Spe: 1,
        Wat: 1
    }, {
        id: 200,
        Num: 1,
        Tips: 21,
        Spe: 2,
        Wat: 1
    }, {
        id: 201,
        Num: 1,
        Tips: 21,
        Spe: 1,
        Wat: 1
    }, {
        id: 202,
        Num: 1,
        Tips: 22,
        Spe: 1,
        Wat: 1
    }, {
        id: 300,
        Num: 1,
        Tips: 32,
        Spe: 2,
        Wat: 1
    }, {
        id: 301,
        Num: 1,
        Tips: 31,
        Spe: 1,
        Wat: 1
    }, {
        id: 302,
        Num: 1,
        Tips: 32,
        Spe: 1,
        Wat: 1
    }, {
        id: 401,
        Num: 1,
        Tips: 41,
        Spe: 1,
        Wat: 1
    }, {
        id: 402,
        Num: 1,
        Tips: 42,
        Spe: 1,
        Wat: 1
    }, {
        id: 500,
        Num: 4,
        Tips: 51,
        Spe: 2,
        Wat: 1
    }, {
        id: 501,
        Num: 4,
        Tips: 51,
        Spe: 1.4,
        Wat: 1
    }, {
        id: 600,
        Num: 1,
        Tips: 0,
        Spe: 1,
        Wat: 1,
        Parm: 0
    }],
    FingerGuessing = cc.Layer.extend({
        myRoleNode: null,
        winNode: null,
        enemyRoleArray: null,
        yanWuNode: null,
        myFingerResult: 0,
        otherFingerResult: 0,
        nowGameResult: 0,
        BMFLabel: null,
        timeAction: null,
        bgLayerSpeedArr: [1.2, 2.4, 5],
        bgLayerSpeedAction: null,
        numberLabelNode: null,
        bgLayer: null,
        handLayer: null,
        bottomNode: null,
        topNode: null,
        TimeActionTag: 143,
        EnemyActionTag: 145,
        bgNodeTag: 147,
        TimeAction: null,
        fingerGuessDataArray: null,
        progress: null,
        ctor: function() {
            this._super();
            this.initLayer();
            return !0
        },
        initLayer: function() {
            Helper.loadSpriteFrames(fingerGuess_plist, fingerGuess_png);
            Helper.loadJsonAnimate("1006_01");
            Helper.loadJsonAnimate("1006_02");
            Helper.loadJsonAnimate("1006_03");
            Helper.loadJsonAnimate("1006_04");
            this.fingerGuessDataArray = [];
            for (var a = 0; a < FingerGuessManType.length; a++) this.fingerGuessDataArray[FingerGuessManType[a].id.toString()] = FingerGuessManType[a];
            a = new cc.Sprite(Res.progressSp);
            a.color = cc.color(25, 160, 253);
            this.progress = new cc.ProgressTimer(a);
            this.addChild(this.progress,
                20);
            this.progress.setPosition(winSize.width / 2, 75 + viewPotY);
            this.progress.percentage = 0;
            this.progress.visible = !1;
            this.progress.type = cc.ProgressTimer.TYPE_BAR;
            this.progress.midPoint = cc.p(0, 0.5);
            this.progress.barChangeRate = cc.p(1, 0);
            this.handLayerInit();
            this.bgLayer = new cc.Layer;
            this.bgLayer.setPosition(0, 0);
            this.addChild(this.bgLayer);
            for (a = 0; 4 > a; a++) {
                var b = new cc.Sprite(fingerGuess_bg);
                b.setPosition(winSize.width / 2, 200 + 400 * a);
                this.bgLayer.addChild(b)
            }
            this.myRoleNode = new NewRoleNode("1006_01");
            this.myRoleNode.armature.scale =
                0.6;
            this.myRoleNode.setPosition(winSize.width / 2, -20 + viewPotY);
            this.addChild(this.myRoleNode);
            this.myRoleNode.play("idle", -1, 1);
            this.winNode = new NewRoleNode("1006_02");
            this.winNode.armature.scale = 0.6;
            this.winNode.armature.visible = !1;
            this.winNode.setPosition(winSize.width / 2, 10 + viewPotY);
            this.addChild(this.winNode);
            this.enemyRoleArray = [];
            for (a = 0; 1 > a; a++) b = new NewRoleNode("1006_03"), b.armature.scale = 0.5, b.setPosition(winSize.width / 2, 2E3), this.addChild(b), b.play("idle", -1, 1), this.enemyRoleArray.push(b);
            this.yanWuNode = new NewRoleNode("1006_04");
            this.yanWuNode.armature.scale = 0.8;
            this.yanWuNode.setPosition(winSize.width / 2, 550);
            this.yanWuNode.play("idle", -1, 0);
            this.yanWuNode.armature.getAnimation().pause();
            this.addChild(this.yanWuNode, 1);
            this.bottomNode = new FingerGuessTouchLayer;
            this.bottomNode.setPosition(0, 0);
            this.addChild(this.bottomNode, 1);
            this.bottomNode.setState(2);
            this.numberLabelNode = new cc.Node;
            this.addChild(this.numberLabelNode, 1);
            this.numberLabelNode.setPosition(winSize.width / 2, winSize.height /
                2 + 40);
            for (a = 0; 4 > a; a++) b = new cc.Sprite("#uifont_" + a + ".png"), b.x = 0, b.y = 0, b.tag = a, b.scale = 1.7, b.visible = !1, this.numberLabelNode.addChild(b)
        },
        aiStartAction: function() {
            var a = 1,
                b = 1,
                c = this.nowFingerData;
            c && (a = c.Tips, b = c.Spe);
            90 < FingerGuessData.level ? (b -= 0.7, this.bgLayerSpeedArr[1] = 6, this.bgLayerSpeedArr[2] = 8) : 70 < FingerGuessData.level ? (b -= 0.5, this.bgLayerSpeedArr[1] = 5, this.bgLayerSpeedArr[2] = 7.5) : 50 < FingerGuessData.level ? (b -= 0.3, this.bgLayerSpeedArr[1] = 4, this.bgLayerSpeedArr[2] = 7) : 30 < FingerGuessData.level ?
                (b -= 0.2, this.bgLayerSpeedArr[1] = 3.5, this.bgLayerSpeedArr[2] = 6.5) : 10 < FingerGuessData.level && (b -= 0.1, this.bgLayerSpeedArr[1] = 3, this.bgLayerSpeedArr[2] = 6);
            this.bgLayerSpeedAction.setSpeed(this.bgLayerSpeedArr[1]);
            this.otherFingerResult = 0;
            c = 100 * Math.random();
            this.otherFingerResult = 34 > c ? 1 : 67 > c ? 2 : 3;
            if (51 == a) a = 6, c = !1, 40 < FingerGuessData.level ? (a = 10, c = !0) : 30 < FingerGuessData.level ? a = 9 : 15 < FingerGuessData.level && (a = 8), this.showDifferentAndHide(this.otherFingerResult, a, b, c);
            else if (1 == a || 21 == a) {
                var c = 100 * Math.random(),
                    d = 0;
                50 > c && (d = 1);
                var e = !1,
                    f = !1;
                21 == a && (f = !0);
                c = 1 + 1.2 * Math.random();
                this.showOneSpriteAndHide(this.otherFingerResult, d, c, b, e, f)
            } else if (2 == a || 22 == a) {
                c = 100 * Math.random();
                d = this.otherFingerResult + 1;
                50 > c && (d = this.otherFingerResult - 1);
                10 > FingerGuessData.level && (d = this.otherFingerResult - 1);
                1 > d ? d = 3 : 3 < d && (d = 1);
                var c = 1 + 1.2 * Math.random(),
                    e = 100 * Math.random(),
                    g = 0,
                    h = 1;
                50 > e && (g = 1, h = 0);
                f = e = !1;
                21 == a && (f = !0);
                this.showOneSpriteAndHide(this.otherFingerResult, g, c, b, e, f);
                this.showOneSpriteAndHide(d, h, c, b, e, f)
            } else if (31 ==
                a || 41 == a) c = 100 * Math.random(), d = 0, 50 > c && (d = 1), e = 100 * Math.random(), g = this.otherFingerResult + 1, 50 > e && (g = this.otherFingerResult - 1), 1 > g ? g = 3 : 3 < g && (g = 1), e = !0, f = !1, 41 == a && (f = !0), c = 1 + 1.2 * Math.random(), this.showOneSpriteAndHide(g, d, c, b, e, f);
            else if (32 == a || 42 == a) {
                var d = this.otherFingerResult + 1,
                    k = this.otherFingerResult - 1;
                1 > d ? d = 3 : 3 < d && (d = 1);
                1 > k ? k = 3 : 3 < k && (k = 1);
                c = 1 + 1.2 * Math.random();
                e = 100 * Math.random();
                g = 0;
                h = 1;
                50 > e && (g = 1, h = 0);
                e = !0;
                f = !1;
                42 == a && (f = !0);
                this.showOneSpriteAndHide(d, g, c, b, e, f);
                this.showOneSpriteAndHide(k,
                    h, c, b, e, f)
            }
            b = cc.sequence(cc.delayTime(4), cc.callFunc(this.oneMyGressFinish, this));
            b.setTag(this.EnemyActionTag);
            this.runAction(b);
            this.progress.visible = !1;
            this.progress.runAction(cc.sequence(cc.delayTime(1), cc.show(), cc.progressFromTo(3, 100, 0)))
        },
        showOneSpriteAndHide: function(a, b, c, d, e, f) {
            var g = [fingerGuessRes.finger_1, fingerGuessRes.finger_2, fingerGuessRes.finger_3][a - 1];
            a = new cc.Layer;
            0 == b ? a.setPosition(winSize.width / 2 - 100, 630) : 1 == b ? a.setPosition(winSize.width / 2 + 100, 630) : a.setPosition(winSize.width /
                2, 630);
            this.addChild(a, 2);
            a.visible = !1;
            a.setTag(this.bgNodeTag);
            a.runAction(cc.sequence(cc.delayTime(c), cc.show(), cc.delayTime(d), cc.callFunc(Helper.removeSelf, this)));
            c = new cc.Sprite(fingerGuessRes.finger_bg);
            c.setPosition(0, 0);
            c.scale = 1.1;
            a.addChild(c);
            c = new cc.Sprite(g);
            c.setPosition(0, 0);
            c.scale = 1.4;
            a.addChild(c);
            !0 == e && (e = new cc.Sprite(fingerGuessRes.finger_chacha), e.setPosition(0, 0), e.setScale(1.2), e.setOpacity(130), a.addChild(e, 2));
            !0 == f && (f = 100 * Math.random(), 33 > f ? c.setRotation(90) : 66 > f ? c.setRotation(-90) :
                c.setRotation(180));
            f = new cc.Sprite(fingerGuessRes.finger_bg);
            f.scale = 0.2;
            a.addChild(f);
            0 == b ? f.setPosition(30, -30) : 1 == b ? f.setPosition(-30, -30) : f.setPosition(0, -30);
            f = new cc.Sprite(fingerGuessRes.finger_bg);
            f.scale = 0.1;
            a.addChild(f);
            0 == b ? f.setPosition(40, -40) : 1 == b ? f.setPosition(-40, -40) : f.setPosition(0, -40)
        },
        showDifferentAndHide: function(a, b, c, d) {
            var e = [fingerGuessRes.finger_1, fingerGuessRes.finger_2, fingerGuessRes.finger_3],
                f = 100 * Math.random(),
                g = 0,
                g = 37 > f ? a + 1 : 75 > f ? a - 1 : a;
            1 > g ? g = 3 : 3 < g && (g = 1);
            f = new cc.Layer;
            f.setPosition(0, 0);
            this.addChild(f, 3);
            f.visible = !1;
            f.setTag(this.bgNodeTag);
            f.runAction(cc.sequence(cc.delayTime(1), cc.show(), cc.delayTime(c), cc.callFunc(Helper.removeSelf, this)));
            var h = [];
            for (c = 0; 24 > c; c++) h.push(c);
            var k = [];
            for (c = 0; c < b; c++) {
                var m = Math.floor(Math.random() * h.length);
                k.push(h[m] + 1);
                h.splice(m, 1)
            }
            for (c = 0; c < b; c++) {
                var m = 0 == c ? e[a - 1] : e[g - 1],
                    n = k[c] - 1,
                    h = 45 + 60 * Math.floor(n % 6),
                    n = 500 + 60 * Math.floor(n / 6),
                    q = new cc.Sprite(fingerGuessRes.finger_bg);
                q.setPosition(h, n);
                f.addChild(q);
                m = new cc.Sprite(m);
                m.setPosition(h, n);
                m.setScale(1.4);
                f.addChild(m, 1);
                !0 == d && (h = 100 * Math.random(), 25 > h ? m.setRotation(90) : 50 > h ? m.setRotation(-90) : 75 > h && m.setRotation(180))
            }
        },
        startEnterAction: function() {
            this.bottomNode.startListener();
            this.aiStartAction();
            this.numberLabelStartAction()
        },
        onEnter: function() {
            this._super();
            var a = cc.sequence(cc.moveTo(8, cc.p(0, -800)), cc.place(cc.p(0, 0))).repeatForever();
            this.bgLayerSpeedAction = cc.speed(a, this.bgLayerSpeedArr[1]);
            this.bgLayer.runAction(this.bgLayerSpeedAction);
            this.fallDownEnemy();
            Helper.playMusic(musicRes.bg, !0)
        },
        onExit: function() {
            this._super();
            this.fingerGuessDataArray = null
        },
        levelEnemyData: function() {
            var a = 100 * Math.random(),
                b = "100",
                b = 1 > FingerGuessData.level ? "100" : 3 > FingerGuessData.level ? "101" : 5 > FingerGuessData.level ? "200" : 7 > FingerGuessData.level ? "300" : 8 > FingerGuessData.level ? "500" : 10 > a ? "102" : 32 > a ? "103" : 42 > a ? "201" : 52 > a ? "202" : 63 > a ? "301" : 78 > a ? "302" : 80 > a ? "401" : 83 > a ? "402" : 98 > a ? "501" : "600";
            this.nowFingerData = this.fingerGuessDataArray[b]
        },
        fallDownEnemy: function() {
            this.levelEnemyData();
            var a = this.nowFingerData;
            if (a) {
                a = a.Num;
                if (this.enemyRoleArray.length < a)
                    for (var b = a - this.enemyRoleArray.length, c = 0; c < b; c++) {
                        var d = new NewRoleNode("1006_03");
                        d.armature.scale = 0.5;
                        d.setPosition(winSize.width / 2, 2E3);
                        this.addChild(d);
                        d.play("idle", -1, 1);
                        this.enemyRoleArray.push(d)
                    } else if (this.enemyRoleArray.length > a) {
                        b = this.enemyRoleArray.length - a;
                        for (c = 0; c < b; c++) d = this.enemyRoleArray.pop(), d.removeFromParent(!0)
                    }
                if (1 == a)
                    for (c = 0; c < this.enemyRoleArray.length; c++) d = this.enemyRoleArray[c], d.armature.visible = !0, d.armature.scale = 0.5, d.setRotation(0), d.setPosition(winSize.width / 2, 850), d.runAction(cc.moveTo(0.6, d.x, 450)), d.play("idle", -1, 1);
                else
                    for (c = 0; c < this.enemyRoleArray.length; c++) d = this.enemyRoleArray[c], d.armature.visible = !0, d.armature.scale = 0.5, d.play("idle", -1, 1), d.setRotation(0), d.setPosition(winSize.width / 2 - 135 + 90 * c, 850), 1 == c || 2 == c ? d.runAction(cc.moveTo(0.6, d.x, 450)) : d.runAction(cc.moveTo(0.6, d.x, 400))
            }
        },
        changeColorcallback: function() {
            this.bottomNode.setState(0);
            this.bottomNode.setTouchble(!0)
        },
        timeFinish: function() {
            this.bottomNode.setTouchble(!1);
            this.bottomNode.setAllVisible(!1)
        },
        numberLabelStartAction: function() {
            for (var a = 1; 4 > a; a++) this.numberLabelNode.getChildByTag(a).runAction(cc.sequence(cc.delayTime(4 - a), cc.show(), cc.delayTime(1), cc.hide()));
            a = cc.sequence(cc.delayTime(1), cc.callFunc(this.changeColorcallback, this), cc.delayTime(3), cc.callFunc(this.timeFinish, this));
            a.setTag(this.TimeActionTag);
            this.runAction(a)
        },
        myFingerAction: function(a) {
            0 == this.myFingerResult && (this.myFingerResult =
                a);
            for (a = 0; 4 > a; a++) {
                var b = this.numberLabelNode.getChildByTag(a);
                b.stopAllActions();
                b.visible = !1
            }
            b = this.getChildren();
            for (a = 0; a < b.length; a++) {
                var c = b[a];
                c.tag == this.bgNodeTag && (c.stopAllActions(), c.visible = !1, c.removeFromParent())
            }
            this.stopActionByTag(this.TimeActionTag);
            this.stopActionByTag(this.EnemyActionTag);
            this.progress.stopAllActions();
            this.runAction(cc.sequence(cc.delayTime(0.5), cc.callFunc(this.oneMyGressFinish, this)))
        },
        oneMyGressFinish: function() {
            this.progress.visible = !1;
            this.progress.stopAllActions();
            var a = -1;
            0 < this.myFingerResult && (this.otherFingerResult == this.myFingerResult ? a = 0 : 1 == this.myFingerResult && 2 == this.otherFingerResult ? a = 1 : 2 == this.myFingerResult && 3 == this.otherFingerResult ? a = 1 : 3 == this.myFingerResult && 1 == this.otherFingerResult && (a = 1));
            cc.log("endResult %d", a);
            this.nowGameResult = a;
            if (0 < this.myFingerResult) {
                this.runAction(cc.sequence(cc.delayTime(1), cc.callFunc(this.playHandMusic, this)));
                this.showHandLayer();
                this.myRoleNode.armature.visible = !1;
                this.winNode.armature.visible = !1;
                this.bottomNode.visible = !1;
                for (a = 0; a < this.enemyRoleArray.length; a++) this.enemyRoleArray[a].armature.visible = !1;
                this.bgLayerSpeedAction.setSpeed(this.bgLayerSpeedArr[0])
            } else this.bottomNode.visible = !1;
            this.runAction(cc.sequence(cc.delayTime(1), cc.callFunc(this.oneMyGressEndAnimation, this)))
        },
        oneMyGressEndAnimation: function() {
            0 < this.myFingerResult && (this.bgLayerSpeedAction.setSpeed(this.bgLayerSpeedArr[1]), this.hideHandLayer());
            var a;
            if (-1 == this.nowGameResult) {
                a = uifontRes.uifont_Lose;
                FingerGuessData.hp -= 1;
                this.sendMsgToUIUpdate();
                var b = new cc.LayerColor(cc.color(250, 0, 0, 100));
                this.addChild(b, 20);
                b.runAction(cc.sequence(cc.fadeTo(1, 0), cc.callFunc(Helper.removeSelf, this)));
                this.myRoleNode.play("idle3", -1, 0);
                this.myRoleNode.armature.visible = !0;
                for (b = 0; b < this.enemyRoleArray.length; b++) {
                    var c = this.enemyRoleArray[b];
                    c.armature.visible = !0;
                    c.play("idle3", -1, 1)
                }
                this.runAction(cc.sequence(cc.delayTime(1.2), cc.callFunc(this.oneMyGressInit, this)))
            } else if (0 == this.nowGameResult) {
                a = uifontRes.uifont_Draw;
                this.myRoleNode.play("idle3", -1,
                    0);
                this.myRoleNode.armature.visible = !0;
                for (b = 0; b < this.enemyRoleArray.length; b++) c = this.enemyRoleArray[b], c.armature.visible = !0, c.play("idle3", -1, 0);
                this.runAction(cc.sequence(cc.delayTime(1.2), cc.callFunc(this.oneMyGressInit, this)))
            } else {
                Helper.playEffect(musicRes.burst);
                this.yanWuNode.play("idle", -1, 0);
                a = uifontRes.uifont_Win;
                if (b = this.nowFingerData) FingerGuessData.level += b.Num, this.sendMsgToUIUpdate();
                this.myRoleNode.armature.visible = !1;
                this.winNode.armature.visible = !0;
                for (b = 0; b < this.enemyRoleArray.length; b++) c =
                    this.enemyRoleArray[b], c.armature.visible = !0, c.play("idle5", -1, 0);
                this.bgLayerSpeedAction.setSpeed(this.bgLayerSpeedArr[2]);
                this.runAction(cc.sequence(cc.delayTime(1.2), cc.callFunc(this.endfallDown, this)))
            }
            a = new cc.Sprite(a);
            a.setPosition(winSize.width / 2, winSize.height / 2 + 40);
            this.addChild(a, 10);
            a.runAction(cc.sequence(cc.scaleTo(0.8, 1.5, 1.5), cc.delayTime(0.2), cc.callFunc(Helper.removeSelf, this)))
        },
        endfallDown: function() {
            FingerGuessData.level > FingerGuessData.maxLevel ? this.sendMsgToWinScene() : (this.fallDownEnemy(),
                this.runAction(cc.sequence(cc.delayTime(1), cc.callFunc(this.oneMyGressInit, this))))
        },
        oneMyGressInit: function() {
            this.bgLayerSpeedAction.setSpeed(this.bgLayerSpeedArr[1]);
            if (1 > FingerGuessData.hp) this.sendMsgToLoseScene();
            else {
                this.bottomNode.setState(2);
                this.bottomNode.setTouchble(!1);
                this.myRoleNode.armature.visible = !0;
                this.myRoleNode.play("idle", -1, 1);
                this.winNode.armature.visible = !1;
                for (var a = 0; a < this.enemyRoleArray.length; a++) this.enemyRoleArray[a].play("idle", -1, 1);
                this.nowGameResult = this.myFingerResult =
                    0;
                this.bottomNode.visible = !0;
                this.aiStartAction();
                this.numberLabelStartAction()
            }
        },
        handLayerInit: function() {
            this.handLayer = new cc.Layer;
            this.handLayer.setPosition(0, 0);
            this.addChild(this.handLayer, 20);
            for (var a = [fingerGuessRes.finger_hand_1, fingerGuessRes.finger_hand_2, fingerGuessRes.finger_hand_3], b = 0; b < a.length; b++) {
                var c = a[b],
                    c = new cc.Sprite(c);
                c.x = 450;
                c.y = 70 + viewPotY;
                c.setAnchorPoint(1, 0);
                c.tag = b + 11;
                c.setScaleX(1.6);
                c.setScaleY(-1.6);
                c.setRotation(90);
                c.visible = !1;
                this.handLayer.addChild(c)
            }
            for (var d =
                0; 4 > d; d++)
                for (b = 0; b < a.length; b++) c = a[b], c = new cc.Sprite(c), c.x = 0, c.y = 670, c.setAnchorPoint(1, 0), c.tag = b + 21 + 10 * d, c.setScaleX(-1.6), c.setScaleY(1.6), c.setRotation(90), c.visible = !1, this.handLayer.addChild(c)
        },
        playHandMusic: function() {
            1 == this.nowGameResult ? Helper.playEffect(musicRes.win) : -1 == this.nowGameResult && Helper.playEffect(musicRes.lose)
        },
        showHandLayer: function() {
            if (0 < this.otherFingerResult) {
                var a = this.nowFingerData;
                if (a)
                    for (var b = 0; b < a.Num; b++) {
                        var c = this.handLayer.getChildByTag(20 + 10 * b + this.otherFingerResult);
                        c.x = -100 - 15 * b;
                        c.y = 700 - 60 * b;
                        c.visible = !0;
                        c.runAction(cc.moveTo(0.4, 0, c.y))
                    }
            }
            0 < this.myFingerResult && (a = this.handLayer.getChildByTag(10 + this.myFingerResult), a.x = 550, a.visible = !0, a.runAction(cc.moveTo(0.4, 450, a.y)))
        },
        hideHandLayer: function() {
            for (var a = this.handLayer.getChildren(), b = 0; b < a.length; b++) a[b].visible = !1
        },
        stopAllThisNode: function() {
            this.bgLayer.stopAllActions();
            for (var a = 0; a < this.enemyRoleArray.length; a++) this.enemyRoleArray[a].pauseAllAction();
            this.myRoleNode.pauseAllAction();
            this.winNode.pauseAllAction();
            this.bottomNode.setTouchble(!1);
            this.bottomNode.setAllVisible(!1)
        },
        sendMsgToUIUpdate: function() {
            var a = new cc.EventCustom(EventString.GameUILayer_event);
            cc.eventManager.dispatchEvent(a)
        },
        sendMsgToWinScene: function() {
            this.stopAllThisNode();
            var a = new cc.EventCustom(EventString.GameScene_event);
            a.setUserData(GameSceneEvent.winnerScene);
            cc.eventManager.dispatchEvent(a)
        },
        sendMsgToLoseScene: function() {
            this.stopAllThisNode();
            var a = new cc.EventCustom(EventString.GameScene_event);
            a.setUserData(GameSceneEvent.loseScene);
            cc.eventManager.dispatchEvent(a)
        }
    });
var gameUILayerZorder = {
        leftNode: 1,
        rightMenu: 2,
        readyGoLabel: 5,
        cheerlayer: 8
    },
    FingerGuessUI = cc.Layer.extend({
        maxHongXin: 3,
        nowHongXin: 3,
        maxLevel: 100,
        nowLevel: 0,
        BMFLabel: null,
        leftUINode: null,
        ctor: function() {
            this._super();
            this.initLayerUI();
            return !0
        },
        initLayerUI: function() {
            this.maxHongXin = FingerGuessData.maxHp;
            this.nowHongXin = FingerGuessData.hp;
            this.maxLevel = FingerGuessData.maxLevel;
            this.nowLevel = FingerGuessData.level;
            this.BMFLabel = new cc.LabelBMFont("0", sBMF_fnt, cc.LabelAutomaticWidth, cc.TEXT_ALIGNMENT_LEFT,
                cc.p(0, 0));
            this.addChild(this.BMFLabel, 1);
            this.BMFLabel.setPosition(120, 770);
            var a = new cc.Sprite(fingerGuessRes.finger_headsl);
            a.setPosition(50, 770);
            this.addChild(a);
            a = new cc.Sprite(fingerGuessRes.finger_chacha);
            a.scale = 0.8;
            a.setPosition(90, 770);
            this.addChild(a);
            this.updataUINode()
        },
        updataUINode: function() {
            this.leftUINode && (this.leftUINode.removeFromParent(), this.leftUINode = null);
            this.leftUINode = new cc.Node;
            this.addChild(this.leftUINode, gameUILayerZorder.leftNode);
            this.leftUINode.x = 10;
            this.leftUINode.y =
                726;
            this.leftUINode.scale = 0.6;
            for (var a = uifontRes.uifont_uiHeart, b = uifontRes.uifont_uiHeartbg, c = 0; c < this.nowHongXin; c++) {
                var d = new cc.Sprite(a);
                d.x = 50 + 64 * c;
                d.y = 0;
                this.leftUINode.addChild(d)
            }
            for (c = this.nowHongXin; c < this.maxHongXin; c++) d = new cc.Sprite(b), d.x = 50 + 64 * c, d.y = 0, this.leftUINode.addChild(d)
        },
        updataThisLayer: function() {
            this.nowLevel != FingerGuessData.level && (this.nowLevel = FingerGuessData.level, this.BMFLabel.setString(FingerGuessData.level), this.BMFLabel.runAction(cc.sequence(cc.scaleTo(0.3, 1.8,
                1.8), cc.scaleTo(0.3, 1, 1))));
            this.nowHongXin != FingerGuessData.hp && (this.nowHongXin = FingerGuessData.hp, this.updataUINode())
        },
        onEnter: function() {
            this._super();
            var a = this,
                b = cc.EventListener.create({
                    event: cc.EventListener.CUSTOM,
                    eventName: EventString.GameUILayer_event,
                    callback: function(b) {
                        a.updataThisLayer()
                    }
                });
            cc.eventManager.addListener(b, this)
        },
        changeGoStr: function() {
            var a = new cc.Sprite(uifontRes.uifont_Go);
            a.attr({
                x: winSize.width / 2,
                y: winSize.height / 2,
                scale: 1.4
            });
            this.addChild(a, gameUILayerZorder.readyGoLabel +
                1);
            a.runAction(cc.sequence(cc.delayTime(0.7), cc.callFunc(Helper.removeSelf, this)))
        },
        readyGoActionHandle: function(a, b, c) {
            var d = new cc.Sprite(uifontRes.uifont_Ready);
            d.attr({
                x: winSize.width / 2,
                y: winSize.height / 2
            });
            this.addChild(d, gameUILayerZorder.readyGoLabel);
            d.runAction(cc.sequence(cc.delayTime(a), cc.scaleTo(0.4, 2, 2), cc.scaleTo(0.4, 1.4, 1.4), cc.delayTime(0.3), cc.hide(), cc.callFunc(this.changeGoStr, this), cc.delayTime(0.4), cc.callFunc(b, c), cc.callFunc(Helper.removeSelf, this)))
        }
    });
var FingerGuessTouchLayer = cc.Layer.extend({
    isCanTouch: !1,
    myNormalArr: null,
    mySelectArr: null,
    myDisArr: null,
    ctor: function() {
        this._super();
        this.initLayerUI();
        return !0
    },
    initLayerUI: function() {
        var a = winSize.width / 2;
        this.myNormalArr = [];
        this.mySelectArr = [];
        this.myDisArr = [];
        for (var b = [fingerGuessRes.finger_1, fingerGuessRes.finger_2, fingerGuessRes.finger_3], c = 0; c < b.length; c++) {
            var d = b[c],
                e = new cc.Sprite(fingerGuessRes.finger_select);
            e.x = a - 110 + 110 * c;
            e.y = 140 + viewPotY;
            e.scale = 1.4;
            d = new cc.Sprite(d);
            d.x = e.getContentSize().width /
                2;
            d.y = e.getContentSize().height / 2;
            e.addChild(d);
            this.addChild(e, 3);
            this.mySelectArr.push(e)
        }
        for (c = 0; c < b.length; c++) d = b[c], e = new cc.Sprite(fingerGuessRes.finger_noramal), e.x = a - 110 + 110 * c, e.y = 140 + viewPotY, e.scale = 1.4, d = new cc.Sprite(d), d.x = e.getContentSize().width / 2, d.y = e.getContentSize().height / 2, e.addChild(d), this.addChild(e, 2), this.myNormalArr.push(e);
        b = [fingerGuessRes.finger_cal_1, fingerGuessRes.finger_cal_2, fingerGuessRes.finger_cal_3];
        for (c = 0; c < b.length; c++) d = b[c], d = new cc.Sprite(d), d.x = a - 110 +
            110 * c, d.y = 140 + viewPotY, d.scale = 1.4, this.addChild(d, 4), this.myDisArr.push(d)
    },
    startListener: function() {
        var a = cc.EventListener.create({
            event: cc.EventListener.TOUCH_ONE_BY_ONE,
            swallowTouches: !0,
            onTouchBegan: function(a, c) {
                var d = c.getCurrentTarget();
                if (!0 == d.isCanTouch)
                    for (var e = 0; e < d.myNormalArr.length; e++) {
                        var f = d.myNormalArr[e],
                            f = cc.rect(f.x - 1.4 * (f.getContentSize().width / 2), f.y - 1.4 * (f.getContentSize().height / 2), 1.4 * f.getContentSize().width, 1.4 * f.getContentSize().height);
                        cc.rectContainsPoint(f, a.getLocation()) &&
                            d.myAction(e + 1)
                    }
                return !0
            }
        });
        cc.eventManager.addListener(a, this)
    },
    initData: function() {
        this.isCanTouch = !1
    },
    myAction: function(a) {
        cc.log("touch this %d", a);
        this.isCanTouch = !1;
        this.setState(1, a - 1);
        var b = this.getParent();
        b && b.myFingerAction(a)
    },
    setState: function(a, b) {
        if (0 == a)
            for (var c = 0; c < this.myNormalArr.length; c++) this.myNormalArr[c].visible = !0, this.mySelectArr[c].visible = !1, this.myDisArr[c].visible = !1;
        else if (1 == a) {
            for (c = 0; c < this.myNormalArr.length; c++) this.myNormalArr[c].visible = !0, this.mySelectArr[c].visible = !1, this.myDisArr[c].visible = !1;
            this.mySelectArr[b].visible = !0
        } else if (2 == a)
            for (c = 0; c < this.myNormalArr.length; c++) this.myNormalArr[c].visible = !1, this.mySelectArr[c].visible = !1, this.myDisArr[c].visible = !0
    },
    setAllVisible: function(a) {
        this.visible = a
    },
    setTouchble: function(a) {
        this.isCanTouch = a
    }
});
var EndGameLayer = cc.LayerColor.extend({
    shareLayer: null,
    fontLayer: null,
    isShowShare: !1,
    mainMenu: null,
    ctor: function() {
        this._super(cc.color(0, 0, 0, 200));
        this.shareLayer = this.initShareLayer();
        this.shareLayer.setPosition(0, 0);
        this.shareLayer.visible = !1;
        this.addChild(this.shareLayer);
        this.fontLayer = this.initFontLayer();
        this.fontLayer.setPosition(0, 0);
        this.addChild(this.fontLayer);
        cc.audioEngine.stopMusic();
        return !0
    },
    menucallback_playAgain: function() {
        var a = new GameScene,
            a = new cc.TransitionFade(1, a);
        cc.director.runScene(a)
    },
    menucallback_Share: function() {
        !1 == this.isShowShare && this.changeBtn()
    },
    initFontLayer: function() {
        var a = new cc.Layer,
            b = 0,
            c = "",
            d = FingerGuessData.level,
            e;
        window.myPlayGameSore = FingerGuessData.level;
        // Play68.setRankingScoreDesc(window.myPlayGameSore);
        // updateShare(window.myPlayGameSore);
        console.log(FingerGuessData.level);
        1 > d ? (b = 0, c = "\u6211\u4e0d\u662f\u62d9\u7537", e = "\u88ab\u5168\u56fd99.9%\u7684\u7ade\u4e89\u8005\u51fb\u8d25\u4e86") : 10 > d ? (b = 20 + Math.floor(2.7 * (d / 2.718)) + d, c = "\u6211\u4e0d\u662f\u62d9\u7537") : 20 > d ? (b = 22 + Math.floor(2.7 * (d / 2.718)) + d, c = '"\u597d\u4eba"\u5728\u628a\u59b9') : 40 > d ? (b = 35 + Math.floor(1.1 * (d / 2.718)) + d, c = "\u628a\u59b9\u5c0f\u5e05\u9505") : 80 > d ? (b = 77 +
            0.45 * (d - 40), c = "\u628a\u59b9\u7ec8\u7ed3\u8005") : 100 > d ? (b = 95 + 0.21 * (d - 80), c = "\u628a\u59b9\u638c\u95e8\u4eba") : (b = 99.9, c = "\u628a\u59b9\u9b54\u5c0a");
        null == e && (e = "\u51fb\u8d25\u4e86\u5168\u56fd" + b + "%\u7684\u7ade\u4e89\u8005");
        b = c;
        d = new cc.LabelTTF("\u60a8\u5e72\u7ffb\u4e86" + d + "\u4e2a\u60c5\u654c", s_font, fontSize);
        d.setPosition(winSize.width / 2, 700);
        a.addChild(d);
        e = new cc.LabelTTF(e, s_font, fontSize);
        e.setPosition(winSize.width / 2, 650);
        a.addChild(e);
        e = new cc.LabelTTF("\u83b7\u5f97\u79f0\u53f7:", s_font, fontSize);
        e.setPosition(winSize.width / 2 - 80, 590);
        a.addChild(e);
        e = new cc.LabelTTF(b, s_font, fontSize + 6);
        e.setPosition(winSize.width / 2 + 50, 590);
        e.color = cc.color(200, 150, 40);
        a.addChild(e);
        e.runAction(cc.sequence(cc.delayTime(0.1), cc.scaleTo(0.3, 1.8, 1.8), cc.scaleTo(0.3, 1, 1)));
        !1 == cc.sys.isNative && (window.wxData.desc = "\u6211\u4e00\u53e3\u6c14\u5e72\u7ffb\u4e86" + FingerGuessData.level + "\u4e2a\u60c5\u654c\uff0c\u5f97\u5230\u7f8e\u599e\u4e00\u679a\uff0c\u987a\u624b\u6492\u5230\u670b\u53cb\u5708\u4e86~", isBaidu && eg.share().desc("\u6211\u4e00\u53e3\u6c14\u5e72\u7ffb\u4e86" +
            FingerGuessData.level + "\u4e2a\u60c5\u654c\uff0c\u5f97\u5230\u7f8e\u599e\u4e00\u679a\uff0c\u987a\u624b\u6492\u5230\u670b\u53cb\u5708\u4e86~"));
        e = Helper.createSpriteOnMenuItemSprite(winuiRes.winui_againFront, winuiRes.winui_againBg, winuiRes.winui_againBg, this.menucallback_playAgain, this);
        e.attr({
            x: winSize.width / 2,
            y: winSize.height / 2 + 100
        });
        b = Helper.createSpriteOnMenuItemSprite(winuiRes.winui_shareFront, winuiRes.winui_shareBg, winuiRes.winui_shareBg, this.menucallback_Share, this);
        b.attr({
            x: winSize.width /
                2,
            y: winSize.height / 2
        });
        d = new cc.Sprite(winuiRes.winui_app);
        c = new cc.Sprite(winuiRes.winui_app);
        d = new cc.MenuItemSprite(d, c, this.appSpItemCallback, this);
        d.setPosition(winSize.width / 2, 100);
        this.mainMenu = new cc.Menu(e, b, d);
        this.mainMenu.x = 0;
        this.mainMenu.y = 0;
        a.addChild(this.mainMenu, 5);
        e = new cc.Sprite(winuiRes.winui_contact);
        e.setPosition(winSize.width / 2, 30);
        a.addChild(e);
        return a
    },
    appSpItemCallback: function() {
        cc.sys.isNative || window.open("http://mp.weixin.qq.com/s?__biz\x3dMzAxNTEwODczNw\x3d\x3d\x26mid\x3d203120125\x26idx\x3d1\x26sn\x3d43291c86b20db2a8618cac240c292568#rd")
    },
    initShareLayer: function() {
        var a = new cc.Layer,
            b = new cc.Sprite(Res.arrow_png);
        b.anchorX = 1;
        b.anchorY = 1;
        b.x = winSize.width - 15;
        b.y = winSize.height - 55;
        a.addChild(b);
        b = new cc.LabelTTF('\u8bf7\u70b9\u51fb\u53f3\u4e0a\u89d2\u7684\u83dc\u5355\u6309\u94ae\n\u7136\u540e"\u5206\u4eab\u5230\u670b\u53cb\u5708"\n\u6d4b\u6d4b\u597d\u53cb\u7684\u624b\u6307\u7075\u6d3b\u5ea6\u5427', s_font, fontSize, cc.size(0.7 * winSize.width, 250), cc.TEXT_ALIGNMENT_CENTER);
        b.x = winSize.width / 2;
        b.y = winSize.height - 100;
        b.anchorY = 1;
        a.addChild(b);
        return a
    },
    changeBtn: function() {
        // play68_submitScore(window.myPlayGameSore);
    },
    onEnter: function() {
        this._super();
        var a = this;
        cc.eventManager.addListener({
            event: cc.EventListener.TOUCH_ONE_BY_ONE,
            swallowTouches: !0,
            onTouchBegan: function(b, c) {
                !0 == a.isShowShare && a.changeBtn();
                return !0
            }
        }, this);
        this.runAction(cc.sequence(cc.delayTime(4),
            cc.callFunc(this.baiduPop, this)))
    },
    baiduPop: function() {
        !1 == cc.sys.isNative && isBaidu && eg.share().popup()
    }
});
var NewRoleNode = cc.Node.extend({
    rect: null,
    sprite: null,
    armature: null,
    newRole: null,
    ctor: function(a) {
        this._super();
        this.initNode(a);
        return !0
    },
    initNode: function(a) {
        this.initArmature(a)
    },
    initArmature: function(a) {
        this.armature = ccs.Armature.create(a);
        this.armature.setPosition(0, 0);
        this.addChild(this.armature);
        this.armature.getAnimation().playWithIndex(0, -1, 1);
        this.rect = cc.rect(-10, -10, 20, 20)
    },
    play: function(a, b, c) {
        var d = -1,
            e = 0;
        b && (d = b);
        c && (e = c);
        this.armature.getAnimation().play(a, d, e)
    },
    pauseAllAction: function() {
        this.armature.getAnimation().pause()
    },
    resumeAllAction: function() {
        this.armature.getAnimation().resume()
    },
    printAllArmatureName: function() {
        for (var a = this.armature.getAnimation().getMovementCount(), b = 0; b < a; b++) {
            this.armature.getAnimation().playWithIndex(b, -1, 0);
            var c = this.armature.getAnimation().getCurrentMovementID();
            cc.log("count %s", c)
        }
    },
    setRect: function(a, b, c, d) {
        this.rect = cc.rect(a, b, c, d)
    }
});
var winSize, isBaidu = !1;
cc.game.onStart = function() {
    cc.view.adjustViewPort(!0);
    cc.view.setDesignResolutionSize(450, 800, cc.ResolutionPolicy.SHOW_ALL);
    cc.view.resizeWithBrowserSize(!0);
    winSize = cc.winSize;
    ccs.csLoader.setRecordProtocolBuffersPath(!0);
    if (!1 == cc.sys.isNative && isBaidu) {
        var a = eg.share("\u5e72\u7ffb\u60c5\u654c");
        a.title("\u5e72\u7ffb\u60c5\u654c");
        a.desc("\u6562\u4e0d\u6562\u5e72\u7ffb\u60c5\u654c\uff0c\u62b1\u5f97\u7f8e\u4eba\u5f52\uff1f");
        a.icon("http://ifinger.sinaapp.com/gameicon.png")
    }
    cc.LoaderScene.preload(g_resources, function() {
        Helper.plistToSpriteFrames([uifont_plist,
            fingerGuess_plist, winui_plist
        ]);
        var a = new cc.Scene,
            c = new ComicLayer;
        a.addChild(c);
        cc.director.runScene(a)
    }, this)
};
cc.game.run();